- en: Chapter 5. Cryptographic Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces Android’s cryptographic provider architecture and discusses
    the built-in providers and the algorithms they support. Because Android builds
    on the *Java Cryptography Architecture (JCA)*, we introduce its design in brief,
    starting with the *cryptographic service provider (CSP)* framework. We then discuss
    the main JCA classes and interfaces, and the cryptographic primitives they implement.
    (We will briefly introduce each cryptographic primitive, but a thorough discussion
    is beyond the scope of this book and some familiarity with basic cryptography
    is assumed.) Next, we present Android’s JCA providers and cryptographic libraries
    as well as the algorithms each provider supports. Finally, we show how to use
    additional cryptography algorithms by installing a custom JCA provider.
  prefs: []
  type: TYPE_NORMAL
- en: JCA Provider Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JCA provides an extensible cryptographic provider framework and a set of APIs
    covering the major cryptographic primitives in use today (block ciphers, message
    digests, digital signatures, and so on). This architecture aims to be implementation-independent
    and extensible. Applications that use the standard JCA APIs only need to specify
    the cryptographic algorithm they want to use and (in most cases) do not depend
    on a particular provider implementation. Support for new cryptographic algorithms
    can be added by simply registering an additional provider that implements the
    required algorithms. Additionally, cryptographic services offered by different
    providers are generally interoperable (with certain restrictions when keys are
    hardware-protected or key material is otherwise not directly available) and applications
    are free to mix and match services from different providers as needed. Let’s look
    at JCA’s architecture in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic Service Providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JCA splits cryptographic functionality into a number of abstract cryptographic
    services called *engines* and defines APIs for each service in the form of an
    *engine class*. For example, digital signatures are represented by the `Signature`
    engine class, and encryption is modeled with the `Cipher` class. (You’ll find
    a comprehensive list of engine classes in the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: In the context of JCA, a *cryptographic service provider* (*CSP*, or simply
    *provider*) is a package (or set of packages) that provides a concrete implementation
    of certain cryptographic services. Each provider advertises the services and algorithms
    it implements, allowing the JCA framework to maintain a registry of supported
    algorithms and their implementing providers. This registry maintains a preference
    order for providers, so if a certain algorithm is offered by more than one provider,
    the one with higher preference order is returned to the requesting application.
    An exception to this rule is made for engine classes that support *delayed provider
    selection* (`Cipher`, `KeyAgreement`, `Mac`, and `Signature`). With delayed provider
    selection, the provider is selected not when an instance of the engine class is
    created, but when the engine class is initialized for a particular cryptographic
    operation. Initialization requires a `Key` instance, which the system uses to
    find a provider that can accept the specified `Key` object. Delayed provider selection
    is helpful when using keys that are stored in hardware because the system cannot
    find the hardware-backed provider based on the algorithm name alone. However,
    concrete `Key` instances passed to initialization methods usually have enough
    information to determine the underlying provider.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Current Android versions don’t support delayed provider selection, but some
    related work is being done in the master branch, and delayed provider selection
    will likely be supported in a future version.*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example using the provider configuration illustrated in [Figure 5-1](ch05.html#jca_algorithm_implementation_selection_w
    "Figure 5-1. JCA algorithm implementation selection when provider is not specified").
  prefs: []
  type: TYPE_NORMAL
- en: '![JCA algorithm implementation selection when provider is not specified](figs/web/05fig01.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1. JCA algorithm implementation selection when provider is not specified
  prefs: []
  type: TYPE_NORMAL
- en: If an application requests an implementation of the SHA-256 digest algorithm
    without specifying a provider (as shown in [Example 5-1](ch05.html#requesting_a_sha-256_implementation_with
    "Example 5-1. Requesting a SHA-256 implementation without specifying a provider")),
    the provider framework returns the implementation found in *ProviderB* (number
    2 in the list in [Figure 5-1](ch05.html#jca_algorithm_implementation_selection_w
    "Figure 5-1. JCA algorithm implementation selection when provider is not specified")),
    not the one in *ProviderC*, which also supports SHA-256, but which is number 3
    in the list in [Figure 5-1](ch05.html#jca_algorithm_implementation_selection_w
    "Figure 5-1. JCA algorithm implementation selection when provider is not specified").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1. Requesting a SHA-256 implementation without specifying a provider
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, if the application specifically requests *ProviderC* (as
    shown in [Example 5-2](ch05.html#requesting_a_sha-256_implementation_from "Example 5-2. Requesting
    a SHA-256 implementation from a specific provider")), its implementation will
    be returned even though *ProviderB* has a higher preference order.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2. Requesting a SHA-256 implementation from a specific provider
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Generally, applications should not explicitly request a provider unless they
    include the requested provider as part of the application or can handle fallback
    if the preferred provider is not available.
  prefs: []
  type: TYPE_NORMAL
- en: Provider Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JCA framework guarantees implementation independence by requiring all implementations
    of a particular cryptographic service or algorithm to conform to a common interface.
    For each engine class that represents a particular cryptographic service, the
    framework defines a corresponding abstract *Service Provider Interface (SPI)*
    class. Providers that offer a particular cryptographic service implement and advertise
    the corresponding SPI class. For example, a provider that implements a given encryption
    algorithm would have an implementation of the `CipherSpi` class that corresponds
    to the `Cipher` engine class. When an application calls the `Cipher.getInstance()`
    factory method, the JCA framework finds the appropriate provider by using the
    process outlined in “[Cryptographic Service Providers](ch05.html#cryptographic_service_providers
    "Cryptographic Service Providers")” and returns a `Cipher` instance that routes
    all of its method calls to the `CipherSpi` subclass implemented in the selected
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to SPI implementation classes, each provider has a subclass of the
    abstract `java.security.Provider` class that defines the name and version of the
    provider and, more importantly, a list of the supported algorithms and matching
    SPI implementation classes. The JCA provider framework uses this `Provider` class
    to build the provider registry, and queries it when searching for algorithm implementations
    to return to its clients.
  prefs: []
  type: TYPE_NORMAL
- en: Static Provider Registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order for a provider to be visible to the JCA framework, it must be registered
    first. There are two ways to register a provider: statically and dynamically.
    Static registration requires editing the system security properties file and adding
    an entry for the provider. (On Android, this properties file is called *security.properties*
    and is only present inside the *core.jar* system library. Therefore, it cannot
    be edited and static provider registration is not supported. We describe it here
    only for completeness.)'
  prefs: []
  type: TYPE_NORMAL
- en: A provider entry in the security properties file is formatted as shown in [Example 5-3](ch05.html#static_registration_of_a_jca_provider
    "Example 5-3. Static registration of a JCA provider").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3. Static registration of a JCA provider
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, *n* is the provider’s preference order that is used when searching for
    requested algorithms (when no provider name is specified). The order is 1-based;
    that is, 1 is the most preferred, followed by 2, and so on. `ProviderClassName`
    is the name of the `java.security.Provider` class implementation described in
    “[Provider Implementation](ch05.html#provider_implementation "Provider Implementation")”.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Provider Registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Providers are registered dynamically (at runtime) with the `addProvider()` and
    `insertProviderAt()` methods of the `java.security.Security` class. These methods
    return the actual position in which the provider was added, or –1 if the provider
    was not added because it was already installed. Providers can also be removed
    dynamically by calling the `removeProvider()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Security` class manages the list of security `Provider`s and effectively
    acts as the provider registry described in the previous sections. In Java SE,
    programs require special permissions in order to register providers and modify
    the provider registry because by inserting a new provider at the top of the provider
    list, they can effectively replace the system security implementation. In Android,
    modifications to the provider registry are limited to the current app process
    and cannot affect the system or other applications. Therefore, no special permissions
    are required in order to register a JCA provider.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic modifications to the provider registry are typically placed in a static
    block to ensure that they are executed before any application code. [Example 5-4](ch05.html#dynamically_inserting_a_custom_jca_provi
    "Example 5-4. Dynamically inserting a custom JCA provider") shows an example of
    replacing the default (top priority) provider with a custom one.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4. Dynamically inserting a custom JCA provider
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If the class is loaded more than once (for example, by different class loaders),
    the static block may be executed multiple times. You can work around this by checking
    whether the provider is already available or by using a holder class that is loaded
    only once.*'
  prefs: []
  type: TYPE_NORMAL
- en: JCA Engine Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An engine class provides the interface to a specific type of cryptographic
    service. JCA engines provide one of the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic operations (encrypt/decrypt, sign/verify, hash, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation or conversion of cryptographic material (keys and algorithm parameters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Management and storage of cryptographic objects, such as keys and digital certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining an Engine Class Instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to providing a unified interface to cryptographic operations, engine
    classes decouple client code from the underlying implementation, which is why
    they cannot be instantiated directly; instead, they provide a static factory method
    called `getInstance()` that lets you request an implementation indirectly. The
    `getInstance()` method typically has one of the signatures shown in [Example 5-5](ch05.html#jca_engine_class_factory_method_signatur
    "Example 5-5. JCA engine class factory method signatures").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5. JCA engine class factory method signatures
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Usually, you would use the signature at ➊ and specify only the algorithm name.
    The signatures at ➋ and ➌ allow you to request an implementation from a specific
    provider. All variants throw a `NoSuchAlgorithmException` if an implementation
    for the requested algorithm is not available and ➋ throws `NoSuchProviderException`
    if a provider with the specified name is not registered.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The string `algorithm` parameter that all factory methods take maps to a particular
    cryptographic algorithm or transformation, or specifies an implementation strategy
    for higher-level objects that manage collections of certificates or keys. Usually,
    the mapping is straightforward. For example, *SHA-256* maps to an implementation
    of the SHA-256 hashing algorithm and *AES* requests an implementation of the AES
    encryption algorithm. However, some algorithm names have structure and specify
    more than one parameter of the requested implementation. For example, *SHA256withRSA*
    specifies a signature implementation that uses SHA-256 for hashing the signed
    message and RSA to perform the signature operation. Algorithms can also have aliases,
    and more than one algorithm name can map to the same implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm names are case-insensitive. The standard algorithm names supported
    by each JCA engine class are defined in the *JCA Standard Algorithm Name Documentation*
    (sometimes referred to as just *Standard Names*).^([[38](#ftn.ch05fn01)]) In addition
    to those, providers can define their own algorithm names and aliases. (See each
    provider’s documentation for details.) You can use the code in [Example 5-6](ch05.html#listing_all_jca_providers_and_the_algori
    "Example 5-6. Listing all JCA providers and the algorithms they support") to list
    all providers, the algorithm names of cryptographic services offered by each provider,
    and the implementation classes they map to.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6. Listing all JCA providers and the algorithms they support
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will show the format for the algorithm name of major engine classes as we
    introduce them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: SecureRandom
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SecureRandom` class represents a cryptographic *Random Number Generator
    (RNG)*. While you may not directly use it too often, it is used internally by
    most cryptographic operations to generate keys and other cryptographic material.
    The typical software implementation is usually a *Cryptographically Secure Pseudo
    Random Number Generator (CSPRNG)*, which produces a sequence of numbers that approximate
    the properties of true random numbers based on an initial value called a *seed*.
    As the quality of random numbers produced by a CSPRNG largely depends on its seed,
    it is chosen carefully, usually based on the output of a true RNG.
  prefs: []
  type: TYPE_NORMAL
- en: On Android, CSPRNG implementations are seeded by reading seed bytes from the
    standard Linux */dev/urandom* device file, which is an interface to the kernel
    CSPRNG. As the kernel CSPRNG itself may be in a fairly predictable state right
    after starting, Android periodically saves the state (which is 4096 bytes as of
    Android 4.4) of the kernel CSPRNG to the */data/system/entropy.dat* file. The
    contents of that file are written back to */dev/urandom* on boot in order to carry
    over the previous CSPRNG state. This is performed by the `EntropyMixer` system
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most engine classes, `SecureRandom` has public constructors that you
    can use to create an instance. The recommended way to get a properly seeded instance
    on Android is to use the default (no argument) constructor (➊ in [Example 5-7](ch05.html#using_securerandom_to_generate_random_by
    "Example 5-7. Using SecureRandom to generate random bytes")). If you use the `getInstance()`
    factory method, you need to pass *SHA1PRNG* as the algorithm name, which is the
    only universally supported algorithm name for `SecureRandom`. Because *SHA1PRNG*
    is not exactly a cryptographic standard, implementations from different providers
    might behave differently. To have `SecureRandom` generate random bytes, you pass
    a byte array to its `nextBytes()` method (➋ in [Example 5-7](ch05.html#using_securerandom_to_generate_random_by
    "Example 5-7. Using SecureRandom to generate random bytes")). It will generate
    as many bytes as the array length (16 in [Example 5-7](ch05.html#using_securerandom_to_generate_random_by
    "Example 5-7. Using SecureRandom to generate random bytes")) and store them in
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-7. Using `SecureRandom` to generate random bytes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Seeding `SecureRandom` manually is not recommended because seeding the system
    CSPRNG improperly may result in it producing a predictable sequence of bytes,
    which could compromise any higher-level operations that require random input.
    However, if you need to manually seed `SecureRandom` for some reason (for example,
    if the default system seeding implementation is known to be flawed), you can do
    so by using the `SecureRandom(byte[] seed)` constructor or by calling the `setSeed()`
    method. When seeding manually, make sure that the seed you are using is sufficiently
    random; for example, by reading it from */dev/urandom*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, depending on the underlying implementation, calling `setSeed()`
    may not replace, but instead only add to the internal CSPRNG state; so two `SecureRandom`
    instances seeded with the same seed value may not produce the same number sequence.
    Therefore, `SecureRandom` should not be used when deterministic values are required.
    Instead, use a cryptographic primitive that is designed to produce deterministic
    output from a given input, such as a hash algorithm or a key derivation function.
  prefs: []
  type: TYPE_NORMAL
- en: MessageDigest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MessageDigest` class represents the functionality of a cryptographic message
    digest, also referred to as a hash function. A cryptographic message digest takes
    an arbitrarily long sequence of bytes and generates a fixed-size byte sequence
    called a *digest* or *hash*. A good hash function guarantees that even a small
    change in its input results in completely different output and that it is very
    difficult to find two inputs that are different but produce the same hash value
    (*collision resistance*), or generate an input that has a given hash (*pre-image
    resistance*). Another important property of hash functions is second pre-image
    resistance. In order to withstand second pre-image attacks, a hash function should
    make it difficult to find a second input m[2] that hashes to the same value as
    a given input m[1].
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-8](ch05.html#using_messagedigest_to_hash_data "Example 5-8. Using
    MessageDigest to hash data") shows how to use the `MessageDigest` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-8. Using `MessageDigest` to hash data
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A `MessageDigest` instance is created by passing the hash algorithm name to
    the `getInstance()` factory method ➊. Input may be provided in chunks by using
    one of the `update()` methods, and then calling one of the `digest()` methods
    to get the calculated hash value. Alternatively, if the input data size is fixed
    and relatively short, it can be hashed in one step by using the `digest(byte[]
    input)` method ➋, as shown in [Example 5-8](ch05.html#using_messagedigest_to_hash_data
    "Example 5-8. Using MessageDigest to hash data").
  prefs: []
  type: TYPE_NORMAL
- en: Signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Signature` class provides a common interface for digital signature algorithms
    based on asymmetric encryption. A digital signature algorithm takes an arbitrary
    message and a private key and produces a fixed-sized byte string called a *signature*.
    Digital signatures typically apply a digest algorithm to the input message, encode
    the calculated hash value, and then use a private key operation to produce the
    signature. The signature can then be verified using the corresponding public key
    by applying the reverse operation, calculating the hash value of the signed message,
    and comparing it to the one encoded in the signature. Successful verification
    guarantees the integrity of the signed message and, on the condition that the
    signing private key has remained indeed private, its authenticity.
  prefs: []
  type: TYPE_NORMAL
- en: '`Signature` instances are created with the standard `getInstance()` factory
    method. The algorithm name used is generally in the form *<digest>with <encryption>*,
    where *<digest>* is a hash algorithm name as used by `MessageDigest` (such as
    *SHA256*), and *<encryption>* is an asymmetric encryption algorithm (such as *RSA*
    or *DSA*). For example, a *SHA512withRSA* `Signature` would first use the SHA-512
    hash algorithm to produce a digest value and then encrypt the encoded digest with
    an RSA private key to produce the signature. For signature algorithms that use
    a mask generation function such as RSA-PSS, the algorithm name takes the form
    *<digest>with<encryption>and<mgf>* (for example, *SHA256withRSAandMGF1*).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-9](ch05.html#generating_and_verifying_a_signature_wit "Example 5-9. Generating
    and verifying a signature with the Signature class") shows how to use the `Signature`
    class to generate and verify a cryptographic signature.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-9. Generating and verifying a signature with the `Signature` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After obtaining an instance, the `Signature` object is initialized for either
    signing, by passing a private key to the `initSign()` method (➊ in [Example 5-9](ch05.html#generating_and_verifying_a_signature_wit
    "Example 5-9. Generating and verifying a signature with the Signature class")),
    or verification, by passing a public key or certificate to the `initVerify()`
    method ➍ for verification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signing is similar to calculating a hash with `MessageDigest`: the data to
    be signed is fed in chunks to one of the `update()` methods ➋ or in bulk to the
    `sign()` method ➌, which returns the signature value. To verify a signature, the
    signed data is passed to one of the `update()` methods. Finally, the signature
    is passed to the `verify()` method ➎, which returns `true` if the signature is
    valid.'
  prefs: []
  type: TYPE_NORMAL
- en: Cipher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Cipher` class provides a common interface to encryption and decryption
    operations. Encryption is the process of using some algorithm (called a *cipher*)
    and a key to transform data (called *plaintext,* or *plaintext message*) into
    a randomly looking form (called *ciphertext*). The inverse operation, called *decryption*,
    transforms the ciphertext back into the original plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two major types of encryption widely used today are *symmetric encryption*
    and *asymmetric encryption*. Symmetric, or *secret key*, encryption uses the same
    key to encrypt and decrypt data. Asymmetric encryption uses a pair of keys: a
    *public key* and a *private key*. Data encrypted with one of the keys can only
    be decrypted with the other key of the pair. The `Cipher` class supports both
    symmetric and asymmetric encryption.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how they process input, ciphers can be *block* or *stream*. Block
    ciphers work on fixed-sized chunks of data called *blocks*. If the input cannot
    be divided into an integral number of blocks, the last block is *padded* by adding
    the necessary number of bytes to match the block size. Both the operation and
    the added bytes are called *padding*. Padding is removed in the decryption process
    and is not included in the decrypted plaintext. If a padding algorithm is specified,
    the `Cipher` class can add and remove padding automatically. On the other hand,
    stream ciphers process input data one byte (or even bit) at a time and do not
    require padding.
  prefs: []
  type: TYPE_NORMAL
- en: Block Cipher Modes of Operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Block ciphers employ different strategies when processing input blocks in order
    to produce the final ciphertext (or plaintext when decrypting). Those strategies
    are called *modes of operation*, *cipher modes*, or simply *modes*. The simplest
    processing strategy is to split the plaintext into blocks (padding as necessary),
    apply the cipher to each block, and then concatenate the encrypted blocks to produce
    the ciphertext. This mode is called *Electronic Code Book (ECB)* mode, and while
    it’s straightforward and easy to use, it has the major disadvantage that identical
    plaintext blocks produce identical ciphertext blocks. Thus, plaintext structure
    is reflected in the ciphertext, which compromises message confidentiality and
    facilitates cryptanalysis. This has often been illustrated with the infamous “ECB
    Penguin” from the Wikipedia entry on block cipher modes.^([[39](#ftn.ch05fn02)])
    We present our Android version in [Figure 5-2](ch05.html#ciphertext_patterns_produced_by_differen
    "Figure 5-2. Ciphertext patterns produced by different cipher modes").^([[40](#ftn.ch05fn03)])
    Here, ➊ is the original image, ➋ is the image encrypted in ECB mode, and ➌ is
    the same image encrypted in CBC mode. As you can see, the pattern of the original
    image is distinguishable in ➋, while ➌ looks like random noise.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ciphertext patterns produced by different cipher modes](figs/web/05fig02.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2. Ciphertext patterns produced by different cipher modes
  prefs: []
  type: TYPE_NORMAL
- en: '*Feedback modes* add randomness to the ciphertext by combining the previous
    encrypted block with the current plaintext block before encrypting. In order to
    produce the first cipher block, they combine the first plaintext block with a
    block-sized string of bytes not found in the original plain text, called an *initialization
    vector (IV)*. When configured to use a feedback mode, the `Cipher` class can use
    a client-specified IV or generate one automatically. Commonly used feedback modes
    are *Cipher-block chaining (CBC)*, *Cipher feedback (CFB)*, and *Output feedback
    (OFB)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Another way to add randomness to the ciphertext, employed by the *Counter (CTR)*
    mode, is to encrypt the successive values of a counter sequence in order to produce
    a new key for each plaintext block that needs to be encrypted. This effectively
    turns the underlying block cipher into a stream cipher and no padding is required.
  prefs: []
  type: TYPE_NORMAL
- en: Newer cipher modes, such as *Galois/Counter Mode (GCM)*, not only diffuse patterns
    in the original plaintext but also authenticate the ciphertext, making sure it
    has not been tampered with. They provide *authenticated encryption (AE)* or *Authenticated
    Encryption with Associated Data (AEAD)*.^([[41](#ftn.ch05fn04)]) The `Cipher`
    APIs have been extended to support authenticated encryption in Java SE 7, and
    those extensions have been available since Android 4.4, which has a Java 7–compatible
    runtime library API. AE ciphers concatenate the authentication tag output by the
    encryption operation to the ciphertext that operation produces in order to form
    their final output. In the Java `Cipher` API, the tag is included (or verified,
    when decrypting) implicitly after calling `doFinal()`, so you should not use the
    output of `update()` until you’re sure the implicit tag at the end validates.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a Cipher Instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having reviewed the major parameters of a cipher, we can finally discuss how
    to create `Cipher` instances. Like the other engine classes, `Cipher` objects
    are created with the `getInstance()` factory method, which requires not just a
    simple algorithm name, but that you fully specify the cryptographic *transformation*
    that the requested cipher will perform.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-10](ch05.html#creating_a_cipher_instance "Example 5-10. Creating
    a Cipher instance") shows how to create a `Cipher` instance by passing a transformation
    string to `getInstance()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-10. Creating a `Cipher` instance
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A transformation needs to specify the encryption algorithm, cipher mode, and
    padding. The transformation string passed to `getInstance()` is in the *algorithm/mode/padding*
    format. For example, the transformation string used in [Example 5-10](ch05.html#creating_a_cipher_instance
    "Example 5-10. Creating a Cipher instance") would create a `Cipher` instance that
    uses AES as the encryption algorithm, CBC as the cipher mode, and PKCS#5 padding.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The term* PKCS *will appear quite a few times in our discussion of JCA providers
    and engine classes. The acronym stands for* Public Key Cryptography Standard *and
    refers to a group of cryptography standards that were originally developed and
    published by RSA Security, Inc. in the early 1990s. Most have evolved into public
    Internet standard and are now published and maintained as RFCs (Requests for Comments,
    formal documents describing Internet standards), but they are still referred to
    by their original name. Notable standards include PKCS#1, which defines the basic
    algorithms for RSA encryption and signatures; PKCS#5, which defines password-based
    encryption; PKCS#7, which defines message encryption and signing under a PKI and
    became the basis of S/MIME; and PKCS#12, which defines a container for keys and
    certificates. A full list can be found on EMC’s website.*^([[42](#ftn.ch05fn05)])'
  prefs: []
  type: TYPE_NORMAL
- en: A `Cipher` instance can be created by passing only the algorithm name, but in
    that case the returned implementation would use provider-specific defaults for
    the cipher mode and padding. This is not only not portable across providers, but
    could severely impact the security of the system if, for example, a less-secure-than-intended
    cipher mode (such as ECB) is used at runtime. This “shortcut” is a major design
    flaw of the JCA provider framework and should never be used.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Cipher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once a `Cipher` instance has been obtained, it needs to be initialized before
    encrypting or decrypting data. A `Cipher` is initialized by passing an integer
    constant that denotes the operation mode (`ENCRYPT_MODE`, `DECRYPT_MODE`, `WRAP_MODE`,
    or `UNWRAP_MODE`), a key or certificate, and, optionally, algorithm parameters,
    to one of the corresponding `init()` methods. `ENCRYPT_MODE` and `DECRYPT_MODE`
    are used to encrypt and decrypt arbitrary data, while `WRAP_MODE` and `UNWRAP_MODE`
    are specialized modes used when encrypting (*wrapping*) and decrypting (*unwrapping*)
    the key material of a `Key` object with another key.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-11](ch05.html#using_the_cipher_class_to_encrypt_and_de "Example 5-11. Using
    the Cipher class to encrypt and decrypt data") shows how to use the `Cipher` class
    to encrypt and decrypt data.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-11. Using the `Cipher` class to encrypt and decrypt data
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a `Cipher` instance that uses AES in CBC mode and
    PKCS#5 padding ➊; generate a random IV and wrap it into an `IvParameterSpec` object
    ➋; and then initialize the `Cipher` for encryption by passing `ENCRYPT_MODE`,
    the encryption key, and the IV to the `init()` method ➌. We can then encrypt data
    by passing data chunks to the `update()` method ➍, which returns intermediate
    results (or `null` if the input data is too short to result in a new block), and
    obtain the last block by calling the `doFinal()` method ➎. The final ciphertext
    is obtained by concatenating the intermediate result(s) with the final block.
  prefs: []
  type: TYPE_NORMAL
- en: To decrypt, we initialize the `cipher` in `DECRYPT_MODE` ➏, passing the same
    key and the IV used for encryption. We then call `update()` ➐, this time using
    the ciphertext as input, and finally call `doFinal()` ➑ to obtain the last chunk
    of plaintext. The final plaintext is obtained by concatenating the intermediate
    result(s) with the final chunk ➒.
  prefs: []
  type: TYPE_NORMAL
- en: Mac
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Mac` class provides a common interface to *Message Authentication Code
    (MAC)* algorithms. A MAC is used to check the integrity of messages transmitted
    over an unreliable channel. MAC algorithms use a secret key to calculate a value,
    *the MAC* (also called a *tag*), which can be used to authenticate the message
    and check its integrity. The same key is used to perform verification, so it needs
    to be shared between the communicating parties. (A MAC is often combined with
    a cipher to provide both confidentiality and integrity.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-12. Using the `Mac` class to generate a message authentication code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A `Mac` instance is obtained with the `getInstance()` factory method ➊ (as shown
    in [Example 5-12](ch05.html#using_the_mac_class_to_generate_a_messag "Example 5-12. Using
    the Mac class to generate a message authentication code")) by requesting an implementation
    of the HMAC^([[43](#ftn.ch05fn06)]) MAC algorithm that uses SHA-256 as the hash
    function. It is then initialized ➋ with a `SecretKey` instance, which may be generated
    with a `KeyGenerator` (see “[KeyGenerator](ch05.html#keygenerator "KeyGenerator")”),
    derived from a password or directly instantiated from raw key bytes. For MAC implementations
    based on hash functions (such as HMAC SHA-256 in this example), the type of key
    does not matter, but implementations that use a symmetric cipher may require a
    matching key type to be passed. We can then pass the message in chunks using one
    of the `update()` methods and call `doFinal()` to obtain the final MAC value,
    or perform the operation in one step by passing the message bytes directly to
    `doFinal()` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Key` interface represents *opaque* keys in the JCA framework. Opaque keys
    can be used in cryptographic operations, but usually do not provide access to
    the underlying *key material* (raw key bytes). This allows us to use the same
    JCA classes and interfaces both with software implementations of cryptographic
    algorithms that store key material on memory, and with hardware-backed ones, where
    the key material may reside in a hardware token (smart card, HSM^([[44](#ftn.ch05fn07)])
    and so on) and is not directly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Key` interface defines only three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`String getAlgorithm()`****. Returns the name of the encryption algorithm
    (symmetric or asymmetric) that this key can be used with. Examples are *AES* or
    *RSA*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`byte[] getEncoded()`****. Returns a standard encoded form of the key that
    can be used when transmitting the key to other systems. This can be encrypted
    for private keys. For hardware-backed implementations that do not allow exporting
    key material, this method typically returns `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`String getFormat()`****. Returns the format of the encoded key. This is
    usually *RAW* for keys that are not encoded in any particular format. Other formats
    defined in JCA are *X.509* and *PKCS#8*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can obtain a `Key` instance in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate keys using a `KeyGenerator` or a `KeyPairGenerator`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert from some encoded representation using a `KeyFactory`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve a stored key from a `KeyStore`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discuss different `Key` types and how they are created and accessed in the
    next sections.
  prefs: []
  type: TYPE_NORMAL
- en: SecretKey and PBEKey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SecretKey` interface represents keys used in symmetric algorithms. It is
    a marker interface and does not add any methods to those of the parent `Key` interface.
    It has only one implementation that can be directly instantiated, namely `SecretKeySpec`.
    It is both a key implementation and a key specification (as discussed in the “[KeySpec](ch05.html#keyspec
    "KeySpec")” section that follows) and allows you to instantiate `SecretKey` instances
    based on the raw key material.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PBEKey` subinterface represents keys derived using *Password Based Encryption
    (PBE)*.^([[45](#ftn.ch05fn08)]) PBE defines algorithms that derive strong cryptographic
    keys from passwords and passphrases, which typically have low entropy and thus
    cannot be used directly as keys. PBE is based on two main ideas: using a *salt*
    to protect from table-assisted (pre-computed) dictionary attacks (*salting*),
    and using a large iteration count to make the key derivation computationally expensive
    (*key stretching*). The salt and iteration count are used as parameters to PBE
    algorithms and thus need to be retained in order to generate the same key from
    a particular password. Thus `PBEKey` implementations are required to implement
    `getSalt()` and `getIterationCount()` along with `getPassword()`.'
  prefs: []
  type: TYPE_NORMAL
- en: PublicKey, PrivateKey, and KeyPair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Public and private keys for asymmetric encryption algorithms are modeled with
    the `PublicKey` and `PrivateKey` interfaces. They are marker interfaces and do
    not add any new methods. JCA defines specialized classes for concrete asymmetric
    algorithms that hold the parameters of the corresponding keys, such as `RSAPublicKey`
    and `RSAPrivateCrtKey`. The `KeyPair` interface is simply a container for a public
    key and a private key.
  prefs: []
  type: TYPE_NORMAL
- en: KeySpec
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [Key](ch05.html#key "Key"), the JCA `Key` interface represents
    opaque keys. On the other hand, `KeySpec` models a *key specification*, which
    is a *transparent* key representation that allows you to access individual key
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, most `Key` and `KeySpec` interfaces for concrete algorithms overlap
    considerably because the key parameters need to be accessible in order to implement
    the encryption algorithms. For example, both `RSAPrivateKey` and `RSAPrivateKeySpec`
    define `getModulus()` and `getPrivateExponent()` methods. The difference is only
    important when an algorithm is implemented in hardware, in which case the `KeySpec`
    will only contain a reference to the hardware-managed key and not the actual key
    parameters. The corresponding `Key` will hold a handle to the hardware-managed
    key and can be used to perform cryptographic operations, but it will not hold
    any key material. For example, an `RSAPrivateKey` that is stored in hardware will
    return `null` when its `getPrivateExponent()` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: '`KeySpec` implementations can hold an encoded key representation, in which
    case they are algorithm independent. For example, the `PKCS8EncodedKeySpec` can
    hold either an RSA key or a DSA key in DER-encoded PKCS#8 format.^([[46](#ftn.ch05fn09)])
    On the other hand, an algorithm-specific `KeySpec` holds all key parameters as
    fields. For example, `RSAPrivateKeySpec` contains the modulus and private exponent
    for an RSA key, which can be obtained using the `getModulus()` and `getPrivateExponent()`
    methods, respectively. Regardless of their type, `KeySpec`s are converted to `Key`
    objects using a `KeyFactory`.'
  prefs: []
  type: TYPE_NORMAL
- en: KeyFactory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `KeyFactory` encapsulates a conversion routine needed to turn a transparent
    public or private key representation (some `KeySpec` subclass) into an opaque^([[47](#ftn.ch05fn10)])
    key object (some `Key` subclass) that can be used to perform a cryptographic operation,
    or vice versa. A `KeyFactory` that converts an encoded key typically parses the
    encoded key data and stores each key parameter in the corresponding field of the
    concrete `Key` class. For example, to parse an X.509-encoded RSA public key, you
    can use the following code (see [Example 5-13](ch05.html#using_a_keyfactory_to_convert_an_xdot509
    "Example 5-13. Using a KeyFactory to convert an X.509 encoded key to an RSAPublicKey
    object")).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-13. Using a `KeyFactory` to convert an X.509 encoded key to an `RSAPublicKey`
    object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we create an RSA `KeyFactory` by passing *RSA* to `KeyFactory.getInstance()`
    ➊. We then read the encoded RSA key, use the encoded key bytes to instantiate
    an `X509EncodedKeySpec` ➋, and finally pass the `KeySpec` to the factory’s `generatePublic()`
    method ➌ in order to obtain an `RSAPublicKey` instance.
  prefs: []
  type: TYPE_NORMAL
- en: A `KeyFactory` can also convert an algorithm-specific `KeySpec`, such as `RSAPrivateKeySpec`,
    to a matching `Key` (`RSAPrivateKey`, in this example) instance, but in that case
    it merely copies the key parameters (or key handle) from one class to the other.
    Calling the `KeyFactory.getKeySpec()` method converts a `Key` object to a `KeySpec`,
    but this usage is not very common because an encoded key representation can be
    obtained simply by calling `getEncoded()` directly on the key object, and algorithm-specific
    `KeySpec`s generally do not provide any more information than a concrete `Key`
    class does.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature of `KeyFactory` is converting a `Key` instance from a different
    provider into a corresponding key object compatible with the current provider.
    The operation is called *key translation* and is performed using the `translateKey(Key
    key)` method.
  prefs: []
  type: TYPE_NORMAL
- en: SecretKeyFactory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SecretKeyFactory` is very similar to `KeyFactory` except that it only operates
    on secret (symmetric) keys. You can use it to convert a symmetric key specification
    into a `Key` object and vice versa. In practice though, if you have access to
    the key material of a symmetric key, it is much easier to use it to instantiate
    directly a `SecretKeySpec` that is also a `Key`, so it is not used very often
    in this fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: A much more common use case is generating a symmetric key from a user-supplied
    password using PBE (see [Example 5-14](ch05.html#generating_a_secret_key_from_a_password
    "Example 5-14. Generating a secret key from a password using SecretKeyFactory")).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-14. Generating a secret key from a password using `SecretKeyFactory`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, a `PBEKeySpec` is initialized with the password, a randomly generated
    salt, iteration count, and the desired key length ➊. A `SecretKey` factory that
    implements a PBE key derivation algorithm (in this case, PBKDF2) is then obtained
    with a call to `getInstance()` ➋. Passing the `PBEKeySpec` to `generateSecret()`
    executes the key derivation algorithm and returns a `SecretKey` instance ➌ that
    can be used for encryption or decryption.
  prefs: []
  type: TYPE_NORMAL
- en: KeyPairGenerator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `KeyPairGenerator` class generates pairs of public and private keys. A `KeyPairGenerator`
    is instantiated by passing an asymmetric algorithm name to the `getInstance()`
    factory method (➊ in [Example 5-15](ch05.html#initializing_keypairgenerator_with_algor
    "Example 5-15. Initializing KeyPairGenerator with algorithm-specific parameters")).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-15. Initializing `KeyPairGenerator` with algorithm-specific parameters
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways to initialize a `KeyPairGenerator`: by specifying the desired
    key size and by specifying algorithm-specific parameters. In both cases, you can
    optionally pass a `SecureRandom` instance to be used for key generation. If only
    a key size is specified, key generation will use default parameters (if any).
    To specify additional parameters, you must instantiate and configure an `AlgorithmParameterSpec`
    instance appropriate for the asymmetric algorithm you are using and pass it to
    the `initialize()` method, as shown in [Example 5-15](ch05.html#initializing_keypairgenerator_with_algor
    "Example 5-15. Initializing KeyPairGenerator with algorithm-specific parameters").
    In this example, the `ECGenParameterSpec` initialized in ➋ is an `AlgorithmParameterSpec`
    that allows you to specify the curve name used when generating *Elliptic Curve
    (EC)* cryptography keys. After it is passed to the `initialize()` method in ➌,
    the subsequent `generateKeyPair()` call in ➍ will use the specified curve (*secp256r1*)
    to generate the key pair.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While named curves have been defined by various standards, the Oracle JCA
    specification does not explicitly define any elliptic curve names. As there is
    no official JCA standard, curve names supported by Android may vary based on platform
    version.*'
  prefs: []
  type: TYPE_NORMAL
- en: KeyGenerator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `KeyGenerator` is very similar to the `KeyPairGenerator` class, except that
    it generates symmetric keys. While you can generate most symmetric keys by requesting
    a sequence of random bytes from `SecureRandom`, `KeyGenerator` implementations
    perform additional checks for weak keys and set key parity bytes where appropriate
    (for DES and derived algorithms) and can take advantage of available cryptography
    hardware, so it’s best to use `KeyGenerator` instead of generating keys manually.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-16](ch05.html#generating_an_aes_key_with_keygenerator "Example 5-16. Generating
    an AES key with KeyGenerator") shows how to generate an AES key using `KeyGenerator`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-16. Generating an AES key with `KeyGenerator`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To generate a key using `KeyGenerator`, create an instance ➊, specify the desired
    key size with `init()` ➋, and then call `generateKey()` ➌ to generate the key.
  prefs: []
  type: TYPE_NORMAL
- en: KeyAgreement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `KeyAgreement` class represents a *key agreement protocol* that allows two
    or more parties to generate a shared key without needing to exchange secret information.
    While there are different key agreement protocols, the ones most widely used today
    are based on the *Diffie-Hellman (DH) key exchange*— either the original one based
    on discrete logarithm cryptography^([[48](#ftn.ch05fn11)]) (simply known as *DH*),
    or the newer variant based on elliptic key cryptography (*ECDH*^([[49](#ftn.ch05fn12)])).
  prefs: []
  type: TYPE_NORMAL
- en: Both variants of the protocol are modeled in JCA using the `KeyAgreement` class
    and can be performed in the same way, with the only difference being the keys.
    For both variants, each communicating party needs to have a key pair, with both
    key pairs generated with the same key parameters (prime modulus and base generator
    for DH, and typically the same well-defined named curve for ECDH). Then the parties
    only need to exchange public keys and execute the key agreement algorithm to arrive
    at a common secret.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-17](ch05.html#using_keyagreement_to_generate_a_shared "Example 5-17. Using
    KeyAgreement to generate a shared secret") illustrates using the `KeyAgreement`
    class to generate a shared secret using ECDH.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-17. Using `KeyAgreement` to generate a shared secret
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A `KeyAgreement` instance is first created by passing the algorithm name, *ECDH*,
    to the `getInstance()` factory method ➊. Then the agreement is initialized by
    passing the local private key to the `init()` method ➋. Next, the `doPhase()`
    method is called *N* – 1 times, where *N* is the number of communicating parties,
    passing each party’s public key as the first parameter, and setting the second
    parameter to `true` when executing the last phase of the agreement ➌. (For two
    communicating parties, as in this example, the `doPhase()` method needs to be
    called only once.) Finally, calling the `generateSecret()` method ➍ produces the
    shared secret.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-17](ch05.html#using_keyagreement_to_generate_a_shared "Example 5-17. Using
    KeyAgreement to generate a shared secret") shows the call flow for only one of
    the parties (*A*), but the other party (*B*) needs to execute the same sequence
    using its own private key to initialize the agreement, and passing *A*’s public
    key to `doPhase()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while the value (or part of it) returned by `generateSecret()` can
    be used directly as a symmetric key, the preferred method is to use it as the
    input for a *key-derivation function (KDF)* and use the output of the KDF as key(s).
    Directly using the generated shared secret may lead to some loss of entropy, and
    doing so limits the number of keys that can be produced using a single DH key
    agreement operation. On the other hand, using a KDF diffuses any structure that
    the secret may have (such as padding) and allows for generating multiple derived
    keys by mixing in a salt.
  prefs: []
  type: TYPE_NORMAL
- en: '`KeyAgreement` has another `generateSecret()` method which takes an algorithm
    name as a parameter and returns a `SecretKey` instance that can be used to initialize
    a `Cipher` directly. If the `KeyAgreement` instance has been created with an algorithm
    string that includes a KDF specification (for example, *ECDHwithSHA1KDF*), this
    method will apply the KDF to the shared secret before returning a `SecretKey`.
    If a KDF has not been specified, most implementations simply truncate the shared
    secret in order to obtain key material for the returned `SecretKey`.'
  prefs: []
  type: TYPE_NORMAL
- en: KeyStore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JCA uses the term *keystore* to refer to a database of keys and certificates.
    A keystore manages multiple cryptographic objects, referred to as *entries* that
    are each associated with a string *alias.* The `KeyStore` class offers a well-defined
    interface to a keystore that defines three types of entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`PrivateKeyEntry`****. A private key with an associated certificate chain.
    For a software implementation, the private key material is usually encrypted and
    protected by a user-supplied passphrase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`SecretKeyEntry`****. A secret (symmetric) key. Not all `KeyStore` implementations
    support storing secret keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`TrustedCertificateEntry`****. A public key certificate of another party.
    `TrustedCertificateEntry`s often contain CA certificates that can be used to establish
    trust relationships. A keystore that contains only `TrustedCertificateEntry`s
    is called a *truststore*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KeyStore Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `KeyStore` implementation does not need to be persistent, but most implementations
    are. Different implementations are identified by a *keystore type* that defines
    the storage and data format of the keystore, as well as the methods used to protect
    stored keys. The default `KeyStore` type is set with the `keystore.type` system
    property.
  prefs: []
  type: TYPE_NORMAL
- en: The default `KeyStore` implementation of most JCA providers is usually a keystore
    type that stores its data in a file. The file format may be proprietary or based
    on a public standard. Proprietary formats include the original Java SE *JKS* format
    and its security enhanced version *JCEKS*, as well as the *Bouncy Castle KeyStore
    (BKS)* format, which is the default in Android.
  prefs: []
  type: TYPE_NORMAL
- en: PKCS#12 File-Backed KeyStores
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most widely used public standard that allows for bundling private keys and
    associated certificates in a file is the *Personal Information Exchange Syntax
    Standard*, commonly referred to as *PKCS#12*. It is a successor of the *Personal
    Information Exchange Syntax (PFX)* standard, so the terms PKCS#12 and PFX are
    used somewhat interchangeably, and PKCS#12 files are often called PFX files.
  prefs: []
  type: TYPE_NORMAL
- en: PKCS#12 is a container format that can contain multiple embedded objects, such
    as private keys, certificates, and even CRLs. Like the previous PKCS standards,
    which PKCS#12 builds upon, the container contents are defined in *ASN.1*^([[50](#ftn.ch05fn13)])
    and are essentially a sequence of nested structures. The internal container structures
    are called `SafeBags`, with different bags defined for certificates (`CertBag`),
    private keys (`KeyBag`), and encrypted private keys (`PKCS8ShroudedKeyBag`). The
    integrity of the whole file is protected by a MAC that uses a key derived from
    an *integrity password*, and each individual private key entry is encrypted with
    a key derived from a *privacy password*. In practice, the two passwords are usually
    the same. PKCS#12 can also use public keys to protect the privacy and integrity
    of the archive contents, but this usage is not very common.
  prefs: []
  type: TYPE_NORMAL
- en: A typical PKCS#12 file that contains a user’s encrypted password key and an
    associated certificate might have structure like that illustrated in Figure 5-3
    (note that some of the wrapper structures have been removed for clarity).
  prefs: []
  type: TYPE_NORMAL
- en: '![Structure of a PKCS#12 file holding a private key and an associated certificate](figs/web/05fig03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3. Structure of a PKCS#12 file holding a private key and an associated
    certificate
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-18](ch05.html#using_the_keystore_class_to_extract_a_pr "Example 5-18. Using
    the KeyStore class to extract a private key and certificate from a PKCS#12 file")
    shows how to obtain a private key and certificate from a PKCS#12 file.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-18. Using the `KeyStore` class to extract a private key and certificate
    from a PKCS#12 file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `KeyStore` class can be used to access the contents of a PKCS#12 file by
    specifying *PKCS12* as the keystore type when creating an instance (➊ in [Example 5-18](ch05.html#using_the_keystore_class_to_extract_a_pr
    "Example 5-18. Using the KeyStore class to extract a private key and certificate
    from a PKCS#12 file")). To load and parse the PKCS#12 file, we call the `load()`
    method ➋, passing an `InputStream` from which to read the file, and the file integrity
    password. Once the file is loaded, we can obtain a private key entry by calling
    the `getEntry()` method and passing the key alias ➌ and, optionally, a `KeyStore.PasswordProtection`
    instance initialized with the password for the requested entry, if it’s different
    from the file integrity password. If the alias is unknown, all aliases can be
    listed with the `aliases()` method. Once we have a `PrivateKeyEntry`, we can access
    the public key certificate ➍ or the private key ➎. New entries can be added with
    the `setEntry()` method and deleted with the `deleteEntry()` method. Changes to
    the `KeyStore` contents can be persisted to disk by calling the `store()` method,
    which accepts an `OutputStream` (to which the keystore bytes are written) and
    an integrity password (which is used to derive MAC and encryption keys) as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: A `KeyStore` implementation does not have to use a single file for storing key
    and certificate objects. It can use multiple files, a database, or any other storage
    mechanism. In fact, keys may not be stored on the host system at all, but on a
    separate hardware device such as a smart card or a *hardware security module (HSM)*.
    (Android-specific `KeyStore` implementations that provide an interface to the
    system’s trust store and credential storage are introduced in [Chapter 6](ch06.html
    "Chapter 6. Network Security and PKI") and [Chapter 7](ch07.html "Chapter 7. Credential
    Storage").)
  prefs: []
  type: TYPE_NORMAL
- en: CertificateFactory and CertPath
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CertificateFactory` acts as a certificate and CRL parser and can build certificate
    chains from a list of certificates. It can read a stream that contains encoded
    certificates or CRLs and output a collection (or a single instance) of `java.security.cert.Certificate`
    and `java.security.cert.CRL` objects. Usually, only an *X.509* implementation
    that parses X.509 certificates and CRLs is available.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-19](ch05.html#parsing_an_xdot509_certificate_file_with "Example 5-19. Parsing
    an X.509 certificate file with CertificateFactory") shows how to parse a certificate
    file using `CertificateFactory`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-19. Parsing an X.509 certificate file with `CertificateFactory`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To create a `CertificateFactory`, we pass *X.509* as the factory type to `getInstance()`
    ➊, and then call `generateCertificate()`, passing an `InputStream` from which
    to read ➋. Because this is an *X.509* factory, the obtained object can be safely
    cast to `java.security.cert.X509Certificate`. If the read file includes multiple
    certificates that form a certificate chain, a `CertPath` object can be obtained
    by calling the `generateCertPath()` method.
  prefs: []
  type: TYPE_NORMAL
- en: CertPathValidator and CertPathBuilder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CertPathValidator` class encapsulates a certificate chain validation algorithm
    as defined by the *Public-Key Infrastructure (X.509)* or *PKIX* standard.^([[51](#ftn.ch05fn14)])
    We discuss PKIX and certificate chain validation in more detail in [Chapter 6](ch06.html
    "Chapter 6. Network Security and PKI"), but [Example 5-20](ch05.html#building_and_validating_a_certificate_ch
    "Example 5-20. Building and validating a certificate chain with CertPathValidator")
    shows how to use `CertificateFactory` and `CertPathValidator` to build and validate
    a certificate chain.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-20. Building and validating a certificate chain with `CertPathValidator`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we first obtain a `CertPathValidator` instance by passing *PKIX*
    to the `getInstance()` method ➊. We then build a certificate chain using `CertificateFactory`’s
    `generateCertPath()` method ➋. Note that if the passed list of certificates does
    not form a valid chain, this method throws a `CertificateException`. If we do
    not already have all the certificates needed to form a chain, we can use a `CertPathBuilder`
    initialized with a `CertStore` to find the needed certificates and build a `CertPath`
    (not shown).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a `CertPath`, we initialize the `PKIXParameters` class with a set
    of *trust anchors* (typically, these are trusted CA certificates; see [Chapter 6](ch06.html
    "Chapter 6. Network Security and PKI") for details) ➌, and then call `CertPathValidator.validate()`
    ➍, passing the `CertPath` that we built in ➋ and the `PKIXParameters` instance.
    If validation succeeds, `validate()` returns a `PKIXCertPathValidatorResult` instance;
    if not, it throws a `CertPathValidatorException` that contains detailed information
    about why it failed.
  prefs: []
  type: TYPE_NORMAL
- en: Android JCA Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android’s cryptography providers are based on JCA and follow its architecture
    with some relatively minor exceptions. While low-level Android components directly
    use native cryptography libraries (such as OpenSSL), JCA is the main cryptographic
    API and is used by system components and third-party applications alike.
  prefs: []
  type: TYPE_NORMAL
- en: Android has three core JCA providers that include implementations of the engine
    classes outlined in the previous section and two *Java Secure Socket Extension
    (JSSE)* providers that implement SSL functionality. (JSSE is discussed in detail
    in [Chapter 6](ch06.html "Chapter 6. Network Security and PKI").)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine Android’s core JCA providers.
  prefs: []
  type: TYPE_NORMAL
- en: Harmony’s Crypto Provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android’s Java runtime library implementation is derived from the retired Apache
    Harmony project,^([[52](#ftn.ch05fn15)]) which also includes a limited JCA provider
    simply named *Crypto* that provides implementations for basic cryptographic services
    like random number generation, hashing, and digital signatures. Crypto is still
    included in Android for backward compatibility but has the lowest priority of
    all JCA providers, so engine class implementations from Crypto are not returned
    unless explicitly requested. [Table 5-1](ch05.html#algorithms_supported_by_the_crypto_provi
    "Table 5-1. Algorithms Supported by the Crypto Provider as of Android 4.4.4")
    shows the engine classes and algorithms that Crypto supports.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1. Algorithms Supported by the Crypto Provider as of Android 4.4.4
  prefs: []
  type: TYPE_NORMAL
- en: '| Engine Class Name | Supported Algorithms |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyFactory` | *DSA* |'
  prefs: []
  type: TYPE_TB
- en: '| `MessageDigest` | *SHA-1* |'
  prefs: []
  type: TYPE_TB
- en: '| `SecureRandom` | *SHA1PRNG* |'
  prefs: []
  type: TYPE_TB
- en: '| `Signature` | *SHA1withDSA* |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While the algorithms listed in [Table 5-1](ch05.html#algorithms_supported_by_the_crypto_provi
    "Table 5-1. Algorithms Supported by the Crypto Provider as of Android 4.4.4")
    are still available in Android 4.4, all except* SHA1PRNG *have been removed in
    the Android master branch and may not be available in future versions.*'
  prefs: []
  type: TYPE_NORMAL
- en: Android’s Bouncy Castle Provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before Android version 4.0, the only full-featured JCA provider in Android was
    the Bouncy Castle provider. The Bouncy Castle provider is part of the Bouncy Castle
    Crypto APIs,^([[53](#ftn.ch05fn16)]) a set of open source Java implementations
    of cryptographic algorithms and protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Android includes a modified version of the Bouncy Castle provider, which is
    derived from the mainstream version by applying a set of Android-specific patches.
    Those patches are maintained in the Android source tree and updated for each new
    release of the mainstream Bouncy Castle provider. The main differences from the
    mainstream version are summarized below.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms, modes, and algorithm parameters not supported by Java’s reference
    implementation (RI) have been removed (RIPEMD, SHA-224, GOST3411, Twofish, CMAC,
    El Gamal, RSA-PSS, ECMQV, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insecure algorithms such as MD2 and RC2 have been removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java-based implementations of MD5 and the SHA family of digest algorithms have
    been replaced with a native implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some PBE algorithms have been removed (for example, *PBEwithHmacSHA256*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for accessing certificates stored in LDAP has been removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for certificate blacklists has been added (blacklists are discussed
    in [Chapter 6](ch06.html "Chapter 6. Network Security and PKI")).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various performance optimizations have been made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package name has been changed to `com.android.org.bouncycastle` to avoid
    conflict with apps that bundle in Bouncy Castle (since Android 3.0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The engine classes and algorithms supported by Android’s Bouncy Castle provider
    as of version 4.4.4 (based on Bouncy Castle 1.49) are listed in [Table 5-2](ch05.html#algorithms_supported_by_androidapostroph
    "Table 5-2. Algorithms Supported by Android’s Bouncy Castle Provider as of Android
    4.4.4").
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2. Algorithms Supported by Android’s Bouncy Castle Provider as of Android
    4.4.4
  prefs: []
  type: TYPE_NORMAL
- en: '| Engine Class Name | Supported Algorithms |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CertPathBuilder` | *PKIX* |'
  prefs: []
  type: TYPE_TB
- en: '| `CertPathValidator` | *PKIX* |'
  prefs: []
  type: TYPE_TB
- en: '| `CertStore` | *Collection* |'
  prefs: []
  type: TYPE_TB
- en: '| `CertificateFactory` | *X.509* |'
  prefs: []
  type: TYPE_TB
- en: '| `Cipher` | *AES**AESWRAP**ARC4**BLOWFISH**DES**DESEDE**DESEDEWRAP**PBEWITHMD5AND128BITAES-CBC-OPENSSL**PBEWITHMD5AND192BITAES-CBC-OPENSSL**PBEWITHMD5AND256BITAES-CBC-OPENSSL**PBEWITHMD5ANDDES**PBEWITHMD5ANDRC2**PBEWITHSHA1ANDDES**PBEWITHSHA1ANDRC2**PBEWITHSHA256AND128BITAES-CBC-BC**PBEWITHSHA256AND192BITAES-CBC-BC**PBEWITHSHA256AND256BITAES-CBC-BC**PBEWITHSHAAND128BITAES-CBC-BC**PBEWITHSHAAND128BITRC2-CBC**PBEWITHSHAAND128BITRC4**PBEWITHSHAAND192BITAES-CBC-BC**PBEWITHSHAAND2-KEYTRIPLEDES-CBC**PBEWITHSHAAND256BITAES-CBC-BC**PBEWITHSHAAND3-KEYTRIPLEDES-CBC**PBEWITHSHAAND40BITRC2-CBC**PBEWITHSHAAND40BITRC4**PBEWITHSHAANDTWOFISH-CBC**RSA*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyAgreement` | *DH**ECDH* |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyFactory` | *DH**DSA**EC**RSA* |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyGenerator` | *AES**ARC4**BLOWFISH**DES**DESEDE**HMACMD5**HMACSHA1**HMACSHA256**HMACSHA384**HMACSHA512*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyPairGenerator` | *DH**DSA**EC**RSA* |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyStore` | *BKS* (default)*BouncyCastle**PKCS12* |'
  prefs: []
  type: TYPE_TB
- en: '| `Mac` | *HMACMD5**HMACSHA1**HMACSHA256**HMACSHA384**HMACSHA512**PBEWITHHMACSHA**PBEWITHHMACSHA1*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MessageDigest` | *MD5**SHA-1**SHA-256**SHA-384**SHA-512* |'
  prefs: []
  type: TYPE_TB
- en: '| `SecretKeyFactory` | *DES**DESEDE**PBEWITHHMACSHA1**PBEWITHMD5AND128BITAES-CBC-OPENSSL**PBEWITHMD5AND192BITAES-CBC-OPENSSL**PBEWITHMD5AND256BITAES-CBC-OPENSSL**PBEWITHMD5ANDDES**PBEWITHMD5ANDRC2**PBEWITHSHA1ANDDES**PBEWITHSHA1ANDRC2**PBEWITHSHA256AND128BITAES-CBC-BC**PBEWITHSHA256AND192BITAES-CBC-BC**PBEWITHSHA256AND256BITAES-CBC-BC**PBEWITHSHAAND128BITAES-CBC-BC**PBEWITHSHAAND128BITRC2-CBC**PBEWITHSHAAND128BITRC4**PBEWITHSHAAND192BITAES-CBC-BC**PBEWITHSHAAND2-KEYTRIPLEDES-CBC**PBEWITHSHAAND256BITAES-CBC-BC**PBEWITHSHAAND3-KEYTRIPLEDES-CBC**PBEWITHSHAAND40BITRC2-CBC**PBEWITHSHAAND40BITRC4**PBEWITHSHAANDTWOFISH-CBC**PBKDF2WithHmacSHA1**PBKDF2WithHmacSHA1And8BIT*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Signature` | *ECDSA**MD5WITHRSA**NONEWITHDSA**NONEwithECDSA**SHA1WITHRSA**SHA1withDSA**SHA256WITHECDSA**SHA256WITHRSA**SHA384WITHECDSA**SHA384WITHRSA**SHA512WITHECDSA**SHA512WITHRSA*
    |'
  prefs: []
  type: TYPE_TB
- en: AndroidOpenSSL Provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in [Android’s Bouncy Castle Provider](ch05.html#androidapostrophes_bouncy_castle_provide
    "Android’s Bouncy Castle Provider"), hash algorithms in Android’s Bouncy Castle
    provider have been replaced with native code for performance reasons. In order
    to further improve cryptographic performance, the number of supported engine classes
    and algorithms in the native AndroidOpenSSL provider has been steadily growing
    with each release since 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, AndroidOpenSSL was only used to implement SSL sockets, but as of
    Android 4.4, it covers most of the functionality offered by Bouncy Castle. Because
    it is the preferred provider (with the highest priority, 1), engine classes that
    don’t explicitly request Bouncy Castle get an implementation from the AndroidOpenSSL
    provider. As the name implies, its cryptographic functionality is provided by
    the OpenSSL library. The provider implementation uses JNI to link OpenSSL’s native
    code to the Java SPI classes required to implement a JCA provider. The bulk of
    the implementation is in the `NativeCrypto` Java class, which is called by most
    SPI classes.
  prefs: []
  type: TYPE_NORMAL
- en: AndroidOpenSSL is part of Android’s *libcore* library, which implements the
    core part of Android’s Java runtime library. Starting with Android 4.4, AndroidOpenSSL
    has been decoupled from *libcore* so that it can be compiled as a standalone library
    and included in applications that want a stable cryptographic implementation that
    does not depend on the platform version. The standalone provider is called *Conscrypt*
    and lives in the `org.conscrypt` package, renamed to `com.android.org.conscrypt`
    when built as part of the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: The engine classes and algorithms supported by the AndroidOpenSSL provider as
    of version 4.4.4 are listed in [Table 5-3](ch05.html#algorithms_supported_by_the_androidopens
    "Table 5-3. Algorithms Supported by the AndroidOpenSSL Provider as of Android
    4.4.4").
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-3. Algorithms Supported by the AndroidOpenSSL Provider as of Android
    4.4.4
  prefs: []
  type: TYPE_NORMAL
- en: '| Engine Class Name | Supported Algorithms |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CertificateFactory` | *X509* |'
  prefs: []
  type: TYPE_TB
- en: '| `Cipher` | *AES/CBC/NoPadding**AES/CBC/PKCS5Padding**AES/CFB/NoPadding**AES/CTR/NoPadding**AES/ECB/NoPadding**AES/ECB/PKCS5Padding**AES/OFB/NoPadding**ARC4**DESEDE/CBC/NoPadding**DESEDE/CBC/PKCS5Padding**DESEDE/CFB/NoPadding**DESEDE/ECB/NoPadding**DESEDE/ECB/PKCS5Padding**DESEDE/OFB/NoPadding**RSA/ECB/NoPadding**RSA/ECB/PKCS1Padding*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyAgreement` | *ECDH* |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyFactory` | *DSA**EC**RSA* |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyPairGenerator` | *DSA**EC**RSA* |'
  prefs: []
  type: TYPE_TB
- en: '| `Mac` | *HmacMD5**HmacSHA1**HmacSHA256**HmacSHA384**HmacSHA512* |'
  prefs: []
  type: TYPE_TB
- en: '| `MessageDigest` | *MD5**SHA-1**SHA-256**SHA-384**SHA-512* |'
  prefs: []
  type: TYPE_TB
- en: '| `SecureRandom` | *SHA1PRNG* |'
  prefs: []
  type: TYPE_TB
- en: '| `Signature` | *ECDSA**MD5WithRSA**NONEwithRSA**SHA1WithRSA**SHA1withDSA**SHA256WithRSA**SHA256withECDSA**SHA384WithRSA**SHA384withECDSA**SHA512WithRSA**SHA512withECDSA*
    |'
  prefs: []
  type: TYPE_TB
- en: OpenSSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenSSL is an open source cryptographic toolkit that implements the SSL and
    TLS protocols and is widely used as a general purpose cryptography library.^([[54](#ftn.ch05fn17)])
    It is included in Android as a system library and used to implement the AndroidOpenSSL
    JCA provider that was introduced in “[AndroidOpenSSL Provider](ch05.html#androidopenssl_provider
    "AndroidOpenSSL Provider")”, as well as by some other system components.
  prefs: []
  type: TYPE_NORMAL
- en: Different Android releases use different OpenSSL versions (generally the latest
    stable version, which is 1.0.1e in Android 4.4), with an evolving set of patches
    applied. Therefore, Android does not offer a stable public OpenSSL API, so applications
    that need to use OpenSSL should include the library and not link to the system
    version. The only public cryptographic API is the JCA one, which offers a stable
    interface decoupled from the underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Custom Provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Android’s built-in providers cover most widely used cryptographic primitives,
    they do not support some more exotic algorithms and even some newer standards.
    As mentioned in our discussion of the JCA architecture, Android applications can
    register custom providers for their own use, but cannot affect system-wide providers.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most widely used and full-featured JCA providers is Bouncy Castle,
    also the base of one of Android’s built-in providers. However, as discussed in
    [Android’s Bouncy Castle Provider](ch05.html#androidapostrophes_bouncy_castle_provide
    "Android’s Bouncy Castle Provider"), the version shipped with Android has had
    a number of algorithms removed. If you need to use any of those algorithms, you
    can try simply bundling the full Bouncy Castle library with your application—but
    that may cause class loading conflicts, especially on versions of Android earlier
    than 3.0, which do not change the system’s Bouncy Castle’s package name. To avoid
    this, you can change the library’s root package with a tool such as jarjar,^([[55](#ftn.ch05fn18)])
    or use Spongy Castle.^([[56](#ftn.ch05fn19)])
  prefs: []
  type: TYPE_NORMAL
- en: Spongy Castle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spongy Castle is a repackaged version of Bouncy Castle. It moves all package
    names from `org.bouncycastle.*` to `org.spongycastle.*` in order to avoid class
    loader conflicts, and changes the provider name from *BC* to *SC*. No class names
    are changed, so the API is the same as Bouncy Castle. To use Spongy Castle, you
    simply need to register it with the JCA framework using `Security.addProvider()`
    or `Security.insertProviderAt()`. You can then request algorithms not implemented
    by Android’s built-in providers simply by passing the algorithm name to the respective
    `getInstance()` method.
  prefs: []
  type: TYPE_NORMAL
- en: To explicitly request an implementation from Spongy Castle, pass the *SC* string
    as the provider name. If you bundle the Spongy Castle library with your app, you
    can also directly use Bouncy Castle’s lightweight cryptographic API (which is
    often more flexible) without going through the JCA engine classes. Additionally,
    some cryptographic operations, such as signing an X.509 certificate or creating
    an S/MIME message, have no matching JCA APIs and can only be performed using the
    lower-level Bouncy Castle APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-21](ch05.html#registering_and_using_the_spongy_castle "Example 5-21. Registering
    and using the Spongy Castle provider") shows how to register the Spongy Castle
    provider and request an RSA-PSS (originally defined in PKCS#1^([[57](#ftn.ch05fn20)]))
    `Signature` implementation, which is not supported by any of Android’s built-in
    JCA providers.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-21. Registering and using the Spongy Castle provider
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android implements the Java Cryptography Architecture (JCA) and comes bundled
    with a number of cryptographic providers. JCA defines interfaces to common cryptographic
    algorithms in the form of engine classes. Cryptographic providers offer implementations
    of those engine classes and allow clients to request an algorithm implementation
    by name, without having to know about the actual underlying implementation. The
    two main JCA providers in Android are the Bouncy Castle provider and the AndroidOpenSSL
    provider. Bouncy Castle is implemented in pure Java, while AndroidOpenSSL is backed
    by native code and offers better performance. As of Android 4.4, AndroidOpenSSL
    is the preferred JCA provider.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[38](#ch05fn01)]) Oracle, *Java™ Cryptography Architecture Standard Algorithm
    Name Documentation*, *[http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[39](#ch05fn02)]) Wikipedia, “Block cipher mode of operation,” *[https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[40](#ch05fn03)]) The Android robot is reproduced or modified from work created
    and shared by Google and used according to terms described in the Creative Commons
    3.0 Attribution License.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[41](#ch05fn04)]) D. McGrew, *RFC 5116 – An Interface and Algorithms for
    Authenticated Encryption*, *[http://www.ietf.org/rfc/rfc5116.txt](http://www.ietf.org/rfc/rfc5116.txt)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[42](#ch05fn05)]) RSA Laboratories, *Public-Key Cryptography Standards (PKCS)*,
    *[http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/public-key-cryptography-standards.htm](http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/public-key-cryptography-standards.htm)*
  prefs: []
  type: TYPE_NORMAL
- en: '^([[43](#ch05fn06)]) H. Krawczyk, M. Bellare, and R. Canetti, *HMAC: Keyed-Hashing
    for Message Authentication*, *[http://tools.ietf.org/html/rfc2104](http://tools.ietf.org/html/rfc2104)*'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[44](#ch05fn07)]) Hardware Security Module
  prefs: []
  type: TYPE_NORMAL
- en: '^([[45](#ch05fn08)]) B. Kaliski, *PKCS #5: Password-Based Cryptography Specification,
    Version 2.0*, *[http://www.ietf.org/rfc/rfc2898.txt](http://www.ietf.org/rfc/rfc2898.txt)*'
  prefs: []
  type: TYPE_NORMAL
- en: '^([[46](#ch05fn09)]) RSA Laboratories, *PKCS #8: Private-Key Information Syntax
    Standard*, *[http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm](http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm)*'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[47](#ch05fn10)]) Some `Key` subclasses, such as `RSAPrivateKey`, expose
    all key material and thus are not technically opaque.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[48](#ch05fn11)]) RSA Laboratories, *PKCS #3: Diffie-Hellman Key-Agreement
    Standard*, *[ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-3.asc](ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-3.asc)*'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[49](#ch05fn12)]) NIST, *Recommendation for Pair-Wise Key Establishment Schemes
    Using Discrete Logarithm Cryptography*, *[http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf](http://csrc.nist.gov/publications/nistpubs/800-56A/SP800-56A_Revision1_Mar08-2007.pdf)*
  prefs: []
  type: TYPE_NORMAL
- en: '^([[50](#ch05fn13)]) *Abstract Syntax Notation One (ASN.1)*: A standard notation
    that describes rules and structures for encoding data in telecommunications and
    computer networking. Extensively used in cryptography standards to define the
    structure of cryptographic objects.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[51](#ch05fn14)]) D. Cooper et al., *Internet X.509 Public Key Infrastructure
    Certificate and Certificate Revocation List (CRL) Profile*, May 2008, *[http://tools.ietf.org/html/rfc5280](http://tools.ietf.org/html/rfc5280)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[52](#ch05fn15)]) The Apache Software Foundation, “Apache Harmony,” *[http://harmony.apache.org/](http://harmony.apache.org/)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[53](#ch05fn16)]) Legion of the Bouncy Castle Inc., “Bouncy Castle Crypto
    APIs,” *[https://www.bouncycastle.org/java.html](https://www.bouncycastle.org/java.html)*
  prefs: []
  type: TYPE_NORMAL
- en: '^([[54](#ch05fn17)]) The OpenSSL Project, “OpenSSL: The Open Source toolkit
    for SSL/TLS,” *[http://www.openssl.org/](http://www.openssl.org/)*'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[55](#ch05fn18)]) Chris Nokleberg, “Jar Jar Links,” *[https://code.google.com/p/jarjar/](https://code.google.com/p/jarjar/)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[56](#ch05fn19)]) Roberto Tyley, “Spongy Castle,” *[http://rtyley.github.io/spongycastle/](http://rtyley.github.io/spongycastle/)*
  prefs: []
  type: TYPE_NORMAL
- en: '^([[57](#ch05fn20)]) J. Jonsson and B. Kaliski, *Public-Key Cryptography Standards
    (PKCS) #1: RSA Cryptography Specifications Version 2.1*, *[http://tools.ietf.org/html/rfc3447](http://tools.ietf.org/html/rfc3447)*'
  prefs: []
  type: TYPE_NORMAL
