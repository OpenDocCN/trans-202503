<html><head></head><body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_335"/><strong><span class="big">15</span><br/>MAKING YOUR SYSTEM USEFUL</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">A basic FreeBSD install includes <em>exactly</em> enough to make the system run, plus a few extra bits that Unix systems traditionally include. You can decide whether to install additional programs or source code. While FreeBSD has grown over the years, a complete base install fills about a gigabyte—much less disk space than either a Windows or a commercial Linux install.</p>
<p class="indent">The advantage to this sparseness is that it includes only necessary system components. Debugging becomes much simpler when you know that no shared library you’ve never even heard of, and would never use, can be responsible for your problems. The downside is that you must decide what functions you do need and select software to provide those functions. FreeBSD simplifies add-on software installation through ports and packages.</p>
<h3 class="h3" id="lev635"><span epub:type="pagebreak" id="page_336"/><strong>Ports and Packages</strong></h3>
<p class="noindent">FreeBSD supports two different ways to install add-on software. Everything starts with the Ports Collection, but most users will prefer preconfigured packages.</p>
<p class="indent">FreeBSD has a system for building add-on software called the <em>Ports Collection</em>, or just <em>ports</em>. Ports let you start with raw source code from the program vendor and build the software in exactly the way you need, enabling and disabling features as you need. Ports are fast and easy for the experienced user but require a certain amount of Unix expertise and can intimidate the new user.</p>
<p class="indent"><em>Packages</em> are the result of building ports, using the options the port maintainer thinks will be most useful to the widest variety of people, and bundling them up in a lump to make them easily installable. The FreeBSD Project has a whole farm of systems that do nothing but build all the ports, bundle them up, and make them available for users to download and install. Packages let you quickly install, uninstall, and upgrade add-on software.</p>
<div class="sidebar">
<p class="sidebart"><strong>INTERNET ADVICE STICKS AROUND FOREVER</strong></p>
<p class="spara">Forums and mailing list archives contain many recommendations to skip packages and proceed directly to ports. This is no longer true; packages are preferable for both technical reasons and your own peace of mind. The older package system, pkg_tools, had serious limitations.</p>
<p class="spara1">Ignore any recommendations that mention tools like pkg_add(8), pkg_delete(8), pkg_create(8), and so on. It’s extremely obsolete.</p>
</div>
<p class="indent">FreeBSD’s highly flexible packaging system is called <em>package</em>, pkg(8), or just plain pkg. Package information gets stored in SQLite databases, which lets you perform arbitrary queries on package data. During development, pkg was called <em>pkgNG</em>. That name’s been gone for years now but lingers on in some old docs and third-party software. Don’t let the name confuse you.<sup><a href="footnote.xhtml#ch15fn1" id="ch15fn1a">1</a></sup></p>
<p class="indent">We’ll start by discussing managing systems with pkg(8) and then proceed to customizing software with ports.</p>
<h3 class="h3" id="lev636"><strong>Packages</strong></h3>
<p class="noindent">Packages are precompiled software from the Ports Collection, bundled up for a particular version of FreeBSD. The FreeBSD Project offers several sets of packages in a public repository, updated every few days. Packages are the <span epub:type="pagebreak" id="page_337"/>simplest way to install add-on software. Any software without legal restrictions on its distribution is probably available as a package.</p>
<p class="indent">Legal restrictions? Software can have any license terms, including some really odd ones. The license of some software prohibits distribution in any form other than source code. FreeBSD can’t legally package that. Other software can legally be distributed only in precompiled form. FreeBSD usually packages such software, distributing it as the precompiled binary plus FreeBSD-specific packaging information.</p>
<p class="indent">Packages are built on the oldest supported release of each major FreeBSD version. Packages for all versions of FreeBSD 12 are built on the oldest supported release of FreeBSD 12, FreeBSD 13 packages are built on the oldest supported version of FreeBSD 13, and so on. This helps reduce, identify, and contain ABI incompatibilities.</p>
<p class="indent">If you need to build your own package repository, investigate the Ports Collection (see <a href="ch16.xhtml#ch16">Chapter 16</a>) and the add-on package <em>poudriere</em>.</p>
<h4 class="h4" id="lev637"><strong><em>Package Files</em></strong></h4>
<p class="noindent">Ultimately, packages contain files. Those files might be binary programs, documentation, configuration files, or anything else the software might need. These files are considered part of the operating system. Don’t edit them manually.</p>
<p class="indent">The one odd case is when a package contains a sample configuration file. If a program needs a configuration file, the package should include a sample. You’ll need to edit the configuration to fit your needs—that’s what configuration files are <em>for</em>.</p>
<p class="indent">FreeBSD reconciles this by installing the package’s configuration files with the suffix <em>.sample</em>. Our web server configuration file appears as something like <em>httpd.conf.sample</em>.</p>
<p class="indent">If there’s no production configuration file, the package installation also copies the sample file into place. That file is yours to edit.</p>
<p class="indent">If you upgrade a package, pkg(8) compares the current production file to the old sample file. If the sample is identical to the production version, the upgrade replaces the production file. If the files differ in any way, pkg updates only the sample file. It’s your job to merge any desirable changes into your production configuration. Note that the package upgrade always replaces the sample configuration, so if an old sample is important, you need to make a point to hang on to it.</p>
<h4 class="h4" id="lev638"><strong><em>Introducing pkg(8)</em></strong></h4>
<p class="noindent">Unlike the older packaging system, pkg(8) is a single program with a whole flock of subcommands. You’ll use the same program to install, uninstall, and investigate packages. All changes to installed packages must be run as root. Here’s how you’d install a vital program desired by all right-thinking sysadmins:</p>
<p class="programs"># <span class="codestrong1">pkg install emacs</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_338"/>Those of you clinging to irrational biases against superior text processors probably want to remove it.</p>
<p class="programs"># <span class="codestrong1">pkg delete emacs</span></p>
<p class="indent">All package operations use the pkg(8) command.</p>
<p class="indent">While the pkg(8) man page documents the base pkg functions, each subcommand has its own man page, named <em>pkg-</em> and the subcommand. Examples include pkg-install(8) and pkg-delete(8). You can also use the <span class="literal">pkg help</span> command and the name of the subcommand to get assistance—for example, <span class="literal">pkg help install</span>.</p>
<p class="indent">FreeBSD doesn’t ship with pkg(8) installed. You need to install it . . . as a package. No, wait, don’t scream—it’s <em>much</em> better than it sounds.</p>
<h4 class="h4" id="lev639"><strong><em>Installing pkg(8)</em></strong></h4>
<p class="noindent">FreeBSD ships with a very simple package manager in <em>/usr/sbin/pkg</em>, pkg(7). It has barely enough brains to find FreeBSD’s current package manager. It installs that new package manager and surrenders all responsibility for package management to it. This gives FreeBSD the flexibility to update the package manager with the packages.</p>
<p class="indent">The first time you try to install a package, pkg(8) prompts you to install the package manager. I found I needed the dmidecode package on a new server, so I can get an RMA on a bad power supply from the manufacturer. (Don’t worry about how I <em>found</em> the dmidecode package—just go with me for the moment.)</p>
<p class="programs"># <span class="codestrong1">pkg install dmidecode</span></p>
<p class="indent">FreeBSD runs pkg(8) and finds that no package management is installed yet.</p>
<p class="programs">The package management tool is not yet installed on your system.<br/>Do you want to fetch and install it now? [y/N]: <span class="codestrong1">y</span></p>
<p class="indent">The default answer appears in capital letters. If I hit <span class="literal">n</span> and <small>ENTER</small>, pkg terminates. If I hit <span class="literal">y</span> and <small>ENTER</small>, FreeBSD bootstraps the system.</p>
<p class="programs"><span class="ent">➊</span> Bootstrapping pkg from pkg+http://pkg.FreeBSD.org/FreeBSD:12:amd64/quarterly, please wait...<br/><span class="ent">➋</span> Verifying signature with trusted certificate pkg.freebsd.org.2013102301... done<br/><span class="ent">➌</span> Installing pkg-1.10.0_2...<br/>   Extracting pkg-1.10.0_2: 100%<br/><span class="ent">➍</span> Updating FreeBSD repository catalogue...<br/>   meta.txz                                 : 100%  944 B     0.9kB/s    00:01<br/>   packagesite.txz                          : 100%    6 MiB   2.0MB/s    00:03<br/>   Processing entries: 100%<br/>   FreeBSD repository update completed. 26059 packages processed.<br/>   All repositories are up to date.<br/>   Updating database digests format: 100%</p>
<p class="indent"><span epub:type="pagebreak" id="page_339"/>The installation starts by downloading the current pkg tools from a FreeBSD mirror <span class="ent">➊</span>. It then checks the digital signature on the downloaded file <span class="ent">➋</span>. The tools are extracted and installed <span class="ent">➌</span>. Pkg then downloads and installs the catalog of available packages <span class="ent">➍</span>.</p>
<p class="indent">The packaging system is now installed. To smooth things out, the stub pkg(8) that ships with FreeBSD tells the newly installed packaging system to install the program you really wanted. In this case, our new pkg(8) installs dmidecode for you.</p>
<p class="indent">You can install the packaging system on its own, without adding other packages, by running <span class="codestrong">pkg bootstrap</span>—but seriously, nobody does that at the command line. Running <span class="codestrong">pkg bootstrap</span> does nothing when the packaging system is already installed, so it’s useful for setup scripts.</p>
<h4 class="h4" id="lev640"><strong><em>Common pkg Options</em></strong></h4>
<p class="noindent">While each pkg subcommand has unique features, a few command options work across almost all of them.</p>
<p class="indent">In its default configuration, pkg prompts you for confirmation before doing anything. Tell pkg to take action without prompting you with the <span class="literal">-y</span> flag.</p>
<p class="indent">On the other hand, maybe you want pkg to show you what it would do if you ran a command, but not actually do anything. Perform a dry run by using the <span class="literal">-n</span> flag. For example, a package install using <span class="literal">-n</span> would show the names of every package to be installed, including dependencies. There’s no risk that the system would install the packages, however. Dry runs can help you prepare for changes during a maintenance window.</p>
<p class="indent">Many pkg operations produce a bunch of output. Reduce the amount of output with <span class="literal">-q</span>.</p>
<p class="indent">The <span class="literal">-a</span> flag usually applies a command to all installed packages.</p>
<p class="indent">Finally, pkg usually refuses to do pointless things or things that damage the system. The <span class="literal">-f</span> flag forces pkg to do what you said. Forcing package activities is usually, but not always, a bad idea. For example, you might need <span class="literal">-f</span> to forcibly reinstall a damaged package.</p>
<h4 class="h4" id="lev641"><strong><em>Configuring pkg(8)</em></strong></h4>
<p class="noindent">The pkg(8) program is designed to be highly flexible. While each subcommand has a whole bunch of options, you can establish customized but consistent behavior for most programs with the configuration file, <em>/usr/local/etc/pkg.conf</em>.</p>
<p class="indent">The <em>pkg.conf</em> file contains commented-out defaults for pkg(8). It’s a great place to look to see how the system behaves when you haven’t mucked with it at all. The configuration is written in UCL (see <a href="ch02.xhtml#ch02">Chapter 2</a>). Variables can be set to an integer; a string, such as a file path; or a Boolean value, like <span class="literal">YES</span> or <span class="literal">NO</span>. <span class="literal">YES</span>, <span class="literal">ON</span>, and <span class="literal">TRUE</span> are synonyms, as are <span class="literal">NO</span>, <span class="literal">OFF</span>, and <span class="literal">FALSE</span>. All are case-insensitive.</p>
<p class="programs">#PKG_DBDIR = "/var/db/pkg";<br/>#PKG_CACHEDIR = "/var/cache/pkg";<br/>#PORTSDIR = "/usr/ports";<br/><span epub:type="pagebreak" id="page_340"/>#INDEXDIR = "";<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">FreeBSD runs perfectly well with an empty <em>pkg.conf</em>. The default configuration contains a whole bunch of commented-out entries and quite a few aliases. You might consider these example settings as you proceed.</p>
<p class="indent">Most pkg operations offer a yes/no dialog, showing the default as a capital letter. Being conservative, pkg normally defaults to <span class="literal">NO</span>. Change that default to <span class="literal">YES</span> with the <span class="literal">DEFAULT_ALWAYS_YES</span> option.</p>
<p class="indent">You can make a pkg command assume you’ll answer yes to everything by adding the <span class="literal">-y</span> flag. If you get tired of typing <span class="literal">-y</span>, make pkg assume you always answer yes by setting the <span class="literal">ASSUME_ALWAYS_YES</span> flag to <span class="literal">YES</span>.</p>
<p class="indent">As I’m lazy but not reckless, I prefer these <em>pkg.conf</em> settings:</p>
<p class="programs">DEFAULT_ALWAYS_YES = true;<br/>ASSUME_ALWAYS_YES = false;</p>
<p class="indent">If installing a package runs amok, you might want debugging output. Setting <span class="literal">DEBUG_LEVEL</span> turns on debugging output. This variable accepts an integer from 0 (no debugging) to 4 (complete debugging).</p>
<p class="indent">Many packages include scripts as part of their installation procedure. Turn on debugging for each script by setting <span class="literal">DEBUG_SCRIPTS</span> to <span class="literal">YES</span>.</p>
<p class="indent">Any <em>pkg.conf</em> settings are also usable as environment variables. Environment variables override anything in the configuration file. You could install a package with debugging like this:</p>
<p class="programs">   # <span class="codestrong1">env DEBUG_LEVEL=4 pkg upgrade</span></p>
<p class="indent">All of the options are documented in pkg.conf(5). Not all of the options have a commented-out entry, though. If a sample of an option doesn’t exist but you want it, add it. We’ll examine many of them in the following sections.</p>
<h4 class="h4" id="lev642"><strong><em>Finding Packages</em></strong></h4>
<p class="noindent">Now that you have a package manager installed, you can install packages. Sysadmins familiar with a variety of Unix-like operating systems know that different operating systems assign different names to packaged versions of the same software. A package for the Apache web server on FreeBSD will have a completely different name than the packaged Apache on illumos or even different Linux distributions. Before you can install anything, you’ll need to figure out what it’s called.</p>
<p class="indent">Suppose the client wants to run WordPress on Apache. Your job isn’t to question the client’s choice in web servers; your job is to build and support the web server. First, find Apache with the pkg search command. You’ll need to provide a text string for pkg to perform a case-insensitive search.</p>
<p class="programs"><span epub:type="pagebreak" id="page_341"/># <span class="codestrong1">pkg search apache</span><br/>apache-ant-1.9.7    Java- and XML-based build tool<br/>apache-forrest-0.9  Tool for rapid development of small sites<br/>apache-mode.el-2.0  Emacs major mode for editing Apache configuration files<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">I deliberately picked an annoying example; FreeBSD has 50-odd packages related to the Apache web server. Fortunately, each search result lists a one-line package description. It’s pretty easy to flip through the results until you find the actual web servers.</p>
<p class="programs">--<span class="codeitalic1">snip</span>--<br/>apache22-2.2.31_1              Version 2.2.x of Apache web server with prefork MPM<br/>apache22-event-mpm-2.2.31_1    Version 2.2.x of Apache web server with event MPM<br/>apache22-itk-mpm-2.2.31_1      Version 2.2.x of Apache web server with itk MPM<br/>apache22-peruser-mpm-2.2.31_1  Version 2.2.x of Apache web server with peruser MPM<br/>apache22-worker-mpm-2.2.31_1   Version 2.2.x of Apache web server with worker MPM<br/>apache24-2.4.25_1              Version 2.4.x of Apache web server<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">Six different versions of Apache. First, look at the package names. When a piece of software comes in multiple versions, the major version number gets integrated into the package name. Apache 2.2 is a very different beast than Apache 2.4, so the packages are named <em>apache22</em> and <em>apache24</em>. The actual version number follows. Our first Apache 2.2 package is actually for Apache 2.2.31. The trailing <span class="literal">_1</span> is the package version number, which means that this an updated package. The included software hasn’t changed, but the package has been altered somehow. Package version numbers get bumped for two reasons. When the source port changes in a way that has a material impact on the package, the version number is increased. When an ABI change in a required shared library demands recompiling the package, that also merits a version bump.</p>
<p class="indent">Apache 2.2 comes in five different packages. People familiar with Apache probably remember that this version of Apache could use different Multi-Processing Modules (MPMs), but the MPM had to be selected at compile time. I have blissfully forgotten everything I ever knew about MPMs, so rather than fuss with them, I’ll choose to install the Apache 2.4 package, apache24.</p>
<h5 class="h5" id="lev643"><strong>Package Searching Options</strong></h5>
<p class="noindent">Some searches can generate hundreds of results. Try searching for Perl, and you’ll get about 150 packages. Perl modules all begin with the string <span class="literal">p5-</span>; FreeBSD has packages for over 5,200 Perl modules! Use command line options to trim or adjust the search results. While pkg-search(8) lists many options, here are some of the most common.</p>
<ul>
<li class="noindent"><span epub:type="pagebreak" id="page_342"/>Make a search case-sensitive with <span class="literal">-C</span>.</li>
<li class="noindent">If you know exactly which package you want, and you only want to see whether it’s available for your system, use the <span class="literal">-e</span> flag to search for an exact match. Your search term must include the package version number, though.</li>
<li class="noindent">If you need to highly customize your searches and your search results, investigate the <span class="literal">-L</span>, <span class="literal">-S</span>, and <span class="literal">-Q</span> flags in pkg-search(8).</li>
</ul>
<h5 class="h5" id="lev644"><strong>Examining Found Packages</strong></h5>
<p class="noindent">Perhaps you’re not sure whether a package is what you really want. You might look up details on the package from a third-party site, like FreshPorts (<em><a href="https://www.freshports.org/">https://www.freshports.org/</a></em>), but that would require leaving your terminal, and I can’t countenance that. Use the <span class="literal">-R</span> flag to examine the repository catalog’s metadata for the package. This metadata is a subset of the full <em>package manifest</em> built into each package.</p>
<p class="programs"># <span class="codestrong1">pkg search -R apache24</span><br/>name: "apache24"<br/>origin: "www/apache24"<br/>version: "2.4.25_1"<br/>comment: "Version 2.4.x of Apache web server"<br/>maintainer: "apache@FreeBSD.org"<br/>www: "http://httpd.apache.org/"<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">The package manifest includes fields for the package name, the port the package is built from, the software version, the package repository, dependencies, and more. It’s rarely enough used and subject to change, so we won’t discuss it in detail, but scrolling through this information provides more details about the software inside the package.</p>
<p class="indent">One important detail here is the <em>www</em> field, which gives the website the original software comes from. This is the Apache web server, not a fork or some other project using that name.</p>
<p class="indent">The default format for this raw manifest is YAML, or “YAML Ain’t Markup Language.” It’s yet another syntax for formatting configuration files, but it’s fairly human-readable. Use the <span class="literal">--raw-format</span> flag to choose an alternate format. Other supported formats include json and json-compact.</p>
<p class="programs"># <span class="codestrong1">pkg search -R --raw-format json-compact apache24</span></p>
<p class="indent">If you want to automatically parse package information, this is how you grab the raw data.</p>
<h4 class="h4" id="lev645"><strong><em>Installing Software</em></strong></h4>
<p class="noindent">Use pkg’s <span class="literal">install</span> subcommand and the name of a package to install a package. You don’t need to give the complete package name.</p>
<p class="programs"><span epub:type="pagebreak" id="page_343"/># <span class="codestrong1">pkg install apache24</span></p>
<p class="indent">The first thing that happens is that pkg checks to see whether its local copy of the package database is the same as that on the package server. You’ll either get a message like “Updating FreeBSD repository catalogue” or be told that the “FreeBSD repository is up to date.”</p>
<p class="indent">The system then checks for any packages that your chosen package requires. Read the dependency list. Is there anything here you don’t want installed on this host? Does the list give you a reason <em>not</em> to install the package?</p>
<p class="programs">The following 8 package(s) will be affected (of 0 checked):<br/>New packages to be INSTALLED:<br/>        apache24: 2.4.25_1<br/>        libxml2: 2.9.4<br/>--<span class="codeitalic1">snip</span>--<br/>Number of packages to be installed: 8</p>
<p class="indent">As a final warning, pkg tells you how much disk space and bandwidth the installation requires. You then get prompted to change your mind.</p>
<p class="programs">The process will require 139 MiB more space.<br/>33 MiB to be downloaded.<br/><br/>Proceed with this action? [y/N]:</p>
<p class="indent">Enter <span class="codestrong">y</span>, and pkg fetches the package from the repository and installs it to your system.</p>
<p class="indent">The <span class="literal">install</span> subcommand assumes that you’re either giving the complete name of a package or the name of a package without the package version number. You can request the apache24 package and pkg will figure out that the current package is apache24-2.4.25_1. You can also use the name of the port the package was built from, as in <span class="literal">pkg install</span> <span class="literal">www/apache24</span>.</p>
<p class="indent">In the last section, our package search turned up five different Apache 2.2 packages, each a slightly different variant. If you ask <span class="literal">pkg install</span> to grab the apache22 package, it installs the version named apache22 plus a package version number. If you want a variant, such as apache22-event-mpm, specify the full package name in the <span class="literal">install</span> command.</p>
<p class="indent">Some packages include installation messages. These messages might be helpful instructions, warnings, caveats, or anything else relevant. If the package creator felt a chunk of information sufficiently important enough to spend her precious time composing a message about it, then the least you can do is read it. You might use script(1) to record this information or run <span class="literal">pkg info --pkg-message</span> and the package name to show it again.</p>
<h5 class="h5" id="lev646"><span epub:type="pagebreak" id="page_344"/><strong>Fetching Packages</strong></h5>
<p class="noindent">FreeBSD installs packages by downloading them over the internet. You might want to download packages in one location to install them elsewhere or at another time. Use the <span class="codestrong">pkg fetch</span> command to download but not install packages. Fetching packages makes the most sense when combined with <span class="literal">-d</span>, which makes <span class="literal">pkg fetch</span> grab all the dependencies as well as the named package.</p>
<p class="programs"># <span class="codestrong1">pkg fetch -d apache24</span></p>
<p class="indent">You’ll see the normal repository update messages, followed by a notice of what pkg will download.</p>
<p class="programs">New packages to be FETCHED:<br/>        apache24-2.4.25_1 (5 MiB: 14.25% of the 33 MiB to download)<br/>        libxml2-2.9.4 (821 KiB: 2.43% of the 33 MiB to download)<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">Verify that what pkg plans to download matches what you expect, and then hit <span class="codestrong">y</span> to proceed. The packages are downloaded to the package file cache.</p>
<p class="indent">To install a downloaded package, run <span class="codestrong">pkg install</span> normally. The installation process uses the cached files rather than the downloaded ones.</p>
<p class="indent">Those of you who read man pages might notice the <span class="literal">-a</span> flag, which downloads the entire package repository. Don’t use that. The <span class="literal">-a</span> option is intended for public repository mirrors. Average sysadmins who mirror the entire repository waste bandwidth and slow down the system for everyone. Generous people donate FreeBSD’s package server bandwidth. Don’t waste it. You might need a whole bunch of packages. With dependencies, you might need hundreds or even thousands of packages. You don’t need tens of thousands of packages. Download only what you need.</p>
<h5 class="h5" id="lev647"><strong>Download Timing</strong></h5>
<p class="noindent">Any tool that accesses the internet needs to set a maximum length of time to try to download files. You can customize pkg’s download behavior with two <em>pkg.conf</em> settings.</p>
<p class="indent">If a download fails, pkg tries again. The <span class="literal">FETCH_RETRY</span> option controls how many times pkg retries a download. The default is three, which means that it tries to download one time and retries up to three more times.</p>
<p class="indent">Downloads happen fairly quickly on most modern internet connections. If your uplink isn’t quite so modern, you might need to increase the amount of time pkg will spend on a single download attempt. The <span class="literal">FETCH_TIMEOUT</span> setting controls how long pkg waits for any one file to download. The default, 30, limits downloads to 30 seconds. If you’re downloading LibreOffice over a 33.6 modem, you’ll want to increase this setting and consider having files shipped to you on a removable drive via the Pony Express.</p>
<h4 class="h4" id="lev648"><span epub:type="pagebreak" id="page_345"/><strong><em>The Package Cache</em></strong></h4>
<p class="noindent">The ability to download packages and install them later implies that pkg(8) sticks those packages somewhere on the disk for later consumption. The package cache, <em>/var/cache/pkg</em>, contains the original package files downloaded from the internet. While you can administer FreeBSD hosts for years without futzing with the cache, here are a few things you should know.</p>
<h5 class="h5" id="lev649"><strong>Cleaning the Cache</strong></h5>
<p class="noindent">What with upgrades, new packages, removed packages, and the gleeful randomness of system administration, the cache directory can fill up. My web server has only a few packages but somehow has accumulated 1.7GB of old package files. The <span class="literal">pkg clean</span> command removes any cached packages that have been replaced by newer versions, as well as any package files that are no longer in the repository. You’ll get a list of all the files that will get removed, plus a chance to proceed or quit.</p>
<p class="programs"># <span class="codestrong1">pkg clean</span><br/>The following package files will be deleted:<br/>        /var/cache/pkg/php56-mbstring-5.6.26.txz<br/>        /var/cache/pkg/mod_php56-5.6.21-c80f5ce183.txz<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">If you’ve never cleaned the package cache on a long-running system, the list will be pretty long. At the prompt, hit <span class="codestrong">y</span> to proceed.</p>
<p class="indent">If you want to remove all cached packages, use the <span class="literal">-a</span> flag.</p>
<p class="indent">Remember that <span class="literal">pkg clean</span> removes package files that are no longer available in the package repository. If you depend on a package that’s been removed from the repository, back up that file outside the cache before a thoughtless cleaning removes it forever. You could also try pkg-create(8) to rebuild a package from its installed components.</p>
<p class="indent">If you want to clean the package cache automatically after each package install or upgrade, set the <em>pkg.conf</em> option <span class="literal">AUTOCLEAN</span> to <span class="codestrong">true</span>. I find autocleaning too aggressive, as sometimes the new bugs in an upgraded package compel me to revert to the older version. We cover upgrading packages at the end of this chapter.</p>
<h5 class="h5" id="lev650"><strong>Moving the Cache</strong></h5>
<p class="noindent">You might want the package cache located elsewhere on the filesystem. Use the <em>pkg.conf</em> option <span class="literal">PKG_CACHEDIR</span> to set a new package cache directory.</p>
<p class="indent">Why move the cache directory? Many server farms share a package cache across multiple machines. You can safely share a package cache between hosts running the same FreeBSD major release and hardware architecture. Verify that your NFS configuration uses locking, and set the <em>pkg.conf</em> option <span class="literal">NFS_WITH_PROPER_LOCKING</span>.</p>
<h4 class="h4" id="lev651"><span epub:type="pagebreak" id="page_346"/><strong><em>Package Information and Automatic Installs</em></strong></h4>
<p class="noindent">After a while, you’ll forget which packages you’ve installed on a system. Get the complete list of installed software with <span class="literal">pkg info</span>.</p>
<p class="programs"># <span class="codestrong1">pkg info</span><br/>gettext-runtime-0.19.8.1_1  GNU gettext runtime libraries and programs<br/>indexinfo-0.2.6             Utility to regenerate the GNU info page index<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">If you want more information about an installed package, use <span class="literal">pkg info</span> and the package name. This shows the package manifest and installation details in a human-friendly report.</p>
<p class="programs"># <span class="codestrong1">pkg info apache24</span><br/>apache24-2.4.25_1<br/>Name           : apache24<br/>Version        : 2.4.25_1<br/>Installed on   : Tue Mar 14 16:56:14 2017 EDT<br/>Origin         : www/apache24<br/>Architecture   : freebsd:12:x86:64<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">When was the package installed? Was the package installed on this machine built from the Ports Tree with certain options enabled? What’s the license? What shared libraries does every program in the package require? Answer all these and more with <span class="literal">pkg info</span> and the package name.</p>
<p class="indent">The <span class="literal">pkg info</span> subcommand has many other features. We’ll see some of them, such as locking status, later this chapter. The pkg-info(8) man page has the complete details.</p>
<h5 class="h5" id="lev652"><strong>Automatic Packages</strong></h5>
<p class="noindent">Look back at the sample <span class="literal">pkg info</span> output. I deliberately installed a few different programs on this system, but I’m pretty sure I never knowingly installed anything about GNU info pages or gettext.</p>
<p class="indent">I did install those programs. I merely didn’t pay much attention to what they were because I was more concerned about installing the package that required them. They’re dependencies.</p>
<p class="indent">FreeBSD records whether you requested a package be installed or it was brought along as a dependency. Packages installed as dependencies are called <em>automatic</em> packages. Packages you requested are just packages, although they’re sometimes called <em>nonautomatic</em> packages.</p>
<p class="indent">You might want to know which packages you requested to be installed and which were dragged along as dependencies. That’s when things get tricky.</p>
<h5 class="h5" id="lev653"><strong>Querying the Package Database</strong></h5>
<p class="noindent">The pkg tools can’t cover every possible contingency a sysadmin might face. The simplest way to get some information is to interrogate the <span epub:type="pagebreak" id="page_347"/>installed package database. While you could use raw SQLite, that would mean you’d need to become intimate with the database’s innards. Most sysadmins don’t have that kind of time, especially when that database might change any time. FreeBSD insulates from that with the <span class="literal">pkg query</span> subcommand. A complete survey of package queries would fill a chapter, but here’s a quick overview.</p>
<div class="sidebar">
<p class="sidebart"><strong>REMOTE QUERIES</strong></p>
<p class="spara">Use pkg-query(8) to search the database of installed packages. If your database of packages available in the repository is up to date, though, you can search it using pkg-rquery(8). The database of available packages doesn’t contain all the metadata of an installed package, however, so not all patterns are available.</p>
</div>
<p class="indent">Anything you might want to get out of the package database has a convenient representation in <span class="literal">pkg query</span>. The catch is, everything than anyone might possibly want to extract from the package database is in <span class="literal">pkg query</span>, as a quick perusal of pkg-query(8) shows. The query and command structure is deliberately designed for use in scripts, but we’ll use it interactively now and then.</p>
<p class="indent">Run queries by using <em>patterns</em>. A pattern is a variable that has an assigned meaning, represented by a percent sign and a letter. For example, <span class="literal">%n</span> contains the package name, <span class="literal">%o</span> contains the port the package was built from, and <span class="literal">%t</span> contains the timestamp indicating when the package was installed.</p>
<p class="indent">Running <span class="literal">pkg query</span> and giving a pattern produces that value for every installed package. As <span class="literal">%n</span> represents the package name, here’s how you’d get a list of everything on the system:</p>
<p class="programs"># <span class="codestrong1">pkg query %n</span><br/>apache24<br/>apr<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">We don’t get the extra information <span class="literal">pkg info</span> shows—but maybe that’s what you want.</p>
<p class="indent">You can request multiple items in a single query. The <span class="literal">%v</span> pattern represents the package version, while <span class="literal">%c</span> represents the comment. Here, I separate the package name and version with a dash but put a tab between the version and the comment. Using the shell tab character <span class="literal">\t</span> means I must quote the <span class="literal">pkg query</span> argument.</p>
<p class="programs"># <span class="codestrong1">pkg query "%n-%v\t%c"</span><br/>apache24-2.4.25_1       Version 2.4.x of Apache web server<br/>apr-1.5.2.1.5.4_2       Apache Portability Library<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent"><span epub:type="pagebreak" id="page_348"/>You know, this looks an awful lot like the output of <span class="literal">pkg info</span>. When a pkg command queries or manipulates the package database, it uses these exact same patterns. You have the same visibility into the packaging system that the rest of the tools do.</p>
<p class="indent">If you want to get a pattern for a specific package, give the package name as a final argument. Here, I get the port the apache24 package came from:</p>
<p class="programs"># <span class="codestrong1">pkg query %o apache24</span><br/>www/apache24</p>
<p class="indent">We do have a middle ground between asking all the packages and specific packages, however.</p>
<h5 class="h5" id="lev654"><strong>Evaluations in Queries</strong></h5>
<p class="noindent">Here’s one last nifty package querying feature. Many—not all, but many—patterns are available as variables. A command can evaluate those variables and take action based on the results. Use the <span class="literal">-e</span> command line option to evaluate a variable with using a logical operator. A complete list of logical operators appears in pkg-query(8).</p>
<p class="indent">Evaluation breaks down into “if this is true, do that.” The test goes inside quotes. Here’s an example:</p>
<p class="programs"># <span class="codestrong1">pkg query -e '%a = 0' %n</span></p>
<p class="indent">This query goes down the whole list of installed packages. The <span class="literal">-e</span> shows we’re evaluating a variable for each package. The statement inside the quotes, <span class="literal">%a = 0</span>, means we’re testing the value of <span class="literal">%a</span> in that package. If <span class="literal">%a</span> equals 0, the query evaluates to true and <span class="literal">pkg query</span> prints out the contents of <span class="literal">%n</span>. If <span class="literal">%a</span> equals anything except 0, the statement is false and <span class="literal">pkg query</span> proceeds to the next package without doing anything.</p>
<p class="indent">We already know that <span class="literal">%n</span> contains the package name. The variable <span class="literal">%a</span> contains pkg’s record of whether or not the package was automatically installed. If you requested this particular package, it’s set to 0. If a package was originally installed as a dependency, it’s set to 1. So: if a package is not a dependency, print the name. This query prints nonautomatic packages.</p>
<p class="programs"># pkg query -e '%a = 0' %n<br/>apache24<br/>dmidecode<br/>pkg<br/>youtube_dl</p>
<p class="indent">A couple things stand out here. First, I didn’t deliberately ask pkg to install pkg(8). I requested dmidecode, and pkg bootstrapped itself. The pkg suite itself is always considered a nonautomatic package, though.</p>
<p class="indent">Second: who installed youtube_dl on this box?</p>
<p class="indent">To find out which packages were installed as dependencies, evaluate whether <span class="literal">%a</span> is set to 1.</p>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_349"/><strong>= OR ==?</strong></p>
<p class="spara">You’ll see the examples using double equal signs, as if <span class="literal">pkg query</span> were a programming language. My examples use a single equal sign. Surely there’s some subtle difference between the two and special conditions under which you should use each?</p>
<p class="spara1">Nope!</p>
<p class="spara1">You can use either single or double equal signs, as your muscle memory prefers.</p>
</div>
<p class="indent">Realistically, though, I’m not going to bother remembering how to run this query on all my hosts. I need a simple way to make pkg(8) remember it for me.</p>
<h5 class="h5" id="lev655"><strong>Pkg Command Aliases</strong></h5>
<p class="noindent">You can define aliases for pkg subcommands in <em>pkg.conf</em>. This lets you, say, create aliases to show automatic and nonautomatic commands. I could do something similar in my shell, but it wouldn’t show up as pkg(8) subcommands and I’m easily confused.</p>
<p class="indent">At the bottom of <em>pkg.conf</em>, you’ll find a section labeled <span class="literal">ALIAS</span>.</p>
<p class="programs">ALIAS              : {<br/>  all-depends: query %dn-%dv,<br/>  annotations: info -A,<br/>--<span class="codeitalic1">snip</span>--<br/>  }</p>
<p class="indent">An alias is a single word for the alias name, either a colon or an equal sign, and then the pkg command to run. If you run <span class="literal">pkg all-depends</span>, pkg(8) looks in <em>pkg.conf</em> and runs <span class="literal">pkg query %dn-%dv</span>. Every alias ends in a colon to indicate that the aliases list continues on the next line.</p>
<p class="indent">Many of the aliases in the default configuration represent hangovers from the pkg_add aeon, created for us old timers. The existing aliases are a great place to find sample queries and searches, though. And searching through the aliases turns up this fine entry:</p>
<p class="programs">noauto = "query -e '%a == 0' '%n-%v'",</p>
<p class="indent">This alias, <em>noauto</em>, runs a <span class="literal">pkg query</span> command to evaluate <span class="literal">%a</span> and print the package’s name and version number if it’s 0. It prints packages that weren’t automatically installed. I added a very similar alias to print automatic packages.</p>
<p class="programs">auto = "query -e '%a == 1' '%n-%v'",</p>
<p class="indent">When you find yourself repeatedly running complex commands, add aliases.</p>
<h4 class="h4" id="lev656"><span epub:type="pagebreak" id="page_350"/><strong><em>Uninstalling Packages</em></strong></h4>
<p class="noindent">We’ve all installed software only to rip it out in disgust. The only difference is what, exactly, disgusted us. Uninstall packages with the <span class="literal">pkg delete</span> subcommand. It’s also available as <span class="literal">pkg remove</span>. That extraneous youtube_dl package? Let’s remove it from the system.</p>
<p class="programs"># <span class="codestrong1">pkg delete youtube_dl</span><br/>Checking integrity... done (0 conflicting)</p>
<p class="indent">The removal process makes sure that nothing terrible has happened to the package, that nobody else needs it, and that its removal won’t do terrible things that the package system can predict.<sup><a href="footnote.xhtml#ch15fn2" id="ch15fn2a">2</a></sup></p>
<p class="indent">You’ll then get a list of packages to be removed and how much space they’ll free up. At the end is a final chance to say no.</p>
<p class="programs">Proceed with deinstalling packages? [Y/n]: <span class="codestrong1">y</span><br/><br/>[1/1] Deinstalling youtube_dl-2017.02.11...<br/>[1/1] Deleting files for youtube_dl-2017.02.11: 100%</p>
<p class="indent">The package is deleted from your system.</p>
<h5 class="h5" id="lev657"><strong>Removing Dependencies</strong></h5>
<p class="noindent">If you remove a package that other packages depend on, pkg removes the depending packages as well.</p>
<p class="programs"># <span class="codestrong1">pkg delete trousers</span><br/>--<span class="codeitalic1">snip</span>--<br/>Installed packages to be REMOVED:<br/>        trousers-0.3.14_1<br/>        gnutls-3.5.9<br/>        emacs-nox11-25.1,3<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">The gnutls package needs trousers, and emacs-nox11 needs gnutls. Removing trousers breaks both of them, so pkg figures you clearly don’t want them on your system either.</p>
<p class="indent">If you really want to delete a package that other packages depend on, add the <span class="literal">-f</span> flag.</p>
<p class="indent">Read the warnings from <span class="literal">pkg delete</span> <em>very</em> carefully!</p>
<h5 class="h5" id="lev658"><strong>Autoremoval</strong></h5>
<p class="noindent">Leaving unnecessary software installed on a host increases the security risks and sysadmin workload. On a long-running system, you don’t always know which software to remove. Removing software you chose to install is easy, <span epub:type="pagebreak" id="page_351"/>but that software might have brought along dependencies that you never really paid attention to. Or maybe a new version of a package has fewer or different dependencies than the previous version.</p>
<p class="indent">I removed the youtube_dl package from my test system. That leaves me with other packages I deliberately installed and their dependencies. It also leaves the packages youtube_dl depended on but that nothing else needs. The <span class="literal">pkg autoremove</span> subcommand identifies packages that were installed as dependencies but are no longer required by any other package. It offers to remove these no longer needed. I strongly recommend performing a dry run before removing unneeded dependencies, simply to give your feeble human brain a chance to look at the list twice.</p>
<p class="programs"># <span class="codestrong1">pkg autoremove</span></p>
<p class="indent">Pkg runs a database query to identify unneeded dependencies and proposes them for removal.</p>
<p class="programs">Installed packages to be REMOVED:<br/>        python27-2.7.13_1<br/>        readline-6.3.8<br/>        rtmpdump-2.4.20151223<br/>        librtmp-2.4.20151223<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">Study this list carefully. It’s not uncommon for a piece of nonpackaged software to need a package that was brought in elsewhere. You probably don’t need the video processing tools rtmpdump and librtmp without youtube_dl, but an awful lot of software needs a Python interpreter. Do you <em>really</em> want to blow that away?</p>
<p class="indent">If you really can remove all these packages, answer <span class="literal">y</span> and proceed. If one of those dependencies has become critical, though, change your database to tell it so.</p>
<h4 class="h4" id="lev659"><strong><em>Changing the Package Database</em></strong></h4>
<p class="noindent">Thinking of changing the package database outside of pkg(8)? Don’t. You will only cause yourself pain, and your pleas for assistance will be met either with derisive laughter or suggestions to blow away all your packages and start over.</p>
<p class="indent">There are a couple circumstances where pkg(8) supports altering the package database, though. That’s when you can use <span class="literal">pkg set</span>. The pkg-set(8) subcommand lets you correctly adjust a few sensible values within the database without corrupting the data. The most common is when you want to make an automatic package no longer automatic.</p>
<p class="indent">The <span class="literal">-A</span> flag to <span class="literal">pkg set</span> lets you change a package’s automatic setting. Setting this flag to 1 means that the package was installed automatically, as a dependency, while a 0 means that the package was specifically requested by the user.</p>
<p class="indent"><span epub:type="pagebreak" id="page_352"/>In the previous section, the list of four packages to be deleted by <span class="literal">pkg autoremove</span> included Python. I want to keep Python—not just this time, but any time I perform autoremovery in the future. The simple way to do that is to change Python from automatic to nonautomatic.</p>
<p class="programs"># <span class="codestrong1">pkg set -A 0 python27</span><br/>Mark python27-2.7.13_1 as not automatically installed? [Y/n]: <span class="codestrong1">y</span></p>
<p class="indent">Python is now a nonautomatic package. The results of pkg autoremove now look different.</p>
<p class="programs"># <span class="codestrong1">pkg autoremove -n</span><br/>--<span class="codeitalic1">snip</span>--<br/>Installed packages to be REMOVED:<br/>        rtmpdump-2.4.20151223<br/>        librtmp-2.4.20151223<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">Only two packages instead of four? Apparently Python needs readline. I’m glad that pkg figured that out for me because I can’t be bothered to remember it.</p>
<p class="indent">We’ll cover <span class="literal">pkg set</span> more as needed.</p>
<h4 class="h4" id="lev660"><strong><em>Locking Packages</em></strong></h4>
<p class="noindent">Some software is like a subway’s electrified rail. Touching it causes suffering or death.</p>
<p class="indent">My favorite example is the remote file synchronization program rsync(8). Rsync has been around for decades, and its internal protocol has changed over time. Many embedded and legacy systems use rsync, but it’s never been upgraded. I’ve spent many painful hours debugging why a current rsync can’t communicate with that on a 20th-century embedded phone switch controller. It turned out that an rsync point release dropped support for the very old protocol supported by the phone switch. Upgrading the phone switch wasn’t possible, so I needed the rsync package on my host to never upgrade. <em>Never</em>.</p>
<p class="indent">That’s where locking packages comes in.</p>
<p class="indent">When you lock a package, pkg won’t upgrade, downgrade, uninstall, or reinstall it. It applies the same rules to the package’s dependencies and the programs it depends on. The host responsible for fetching the phone switch files needed to have its rsync package locked. Use <span class="literal">pkg lock</span> to lock a package.</p>
<p class="programs"># <span class="codestrong1">pkg lock rsync</span><br/>rsync-3.1.2_6: lock this package? [Y/n]: <span class="codestrong1">y</span><br/>Locking rsync-3.1.2_6</p>
<p class="indent">This package is now nailed in place.</p>
<p class="indent">To show all the locked packages on the system, use the <span class="literal">-l</span> flag. This shows only the packages you’ve deliberately locked, not the dependents or dependencies.</p>
<p class="programs"><span epub:type="pagebreak" id="page_353"/># <span class="codestrong1">pkg lock -l</span><br/>Currently locked packages:<br/>rsync-3.1.2_6</p>
<p class="indent">Use the <span class="literal">pkg unlock</span> command to remove the lock.</p>
<p class="programs"># <span class="codestrong1">pkg unlock rsync</span><br/>rsync-3.1.2_6: unlock this package? [Y/n]: <span class="codestrong1">y</span><br/>Unlocking rsync-3.1.2_6</p>
<p class="indent">To lock or unlock all packages on the system, use the <span class="literal">-a</span> flag. You’ll get a confirmation prompt for every package, so if you really want to affect all the packages, add the <span class="literal">-y</span> flag.</p>
<p class="programs"># <span class="codestrong1">pkg unlock -a</span><br/>apache24-2.4.25_1: already unlocked<br/>apr-1.5.2.1.5.4_2: already unlocked<br/>--<span class="codeitalic1">snip</span>--<br/>rsync-3.1.2_6: unlock this package? [Y/n]: <span class="codestrong1">y</span><br/>Unlocking rsync-3.1.2_6<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">Package locking doesn’t prevent someone with root access from mucking with the files contained in a package.</p>
<p class="indent">On a related note, <a href="ch22.xhtml#ch22">Chapter 22</a> covers using jails to contain really old software.</p>
<h4 class="h4" id="lev661"><strong><em>Package Files</em></strong></h4>
<p class="noindent">Files installed by a package are considered system files, and you shouldn’t manually edit them. Before you <em>can</em> edit those files, you must know what files came with the package. Use <span class="literal">pkg info -l</span> and the package name to see the complete list. (It’s also available as <span class="literal">pkg list</span>, thanks to a <em>pkg.conf</em> alias.)</p>
<p class="programs"># <span class="codestrong1">pkg info -l rsync</span><br/>rsync-3.1.2_6:<br/>        /usr/local/bin/rsync<br/>        /usr/local/etc/rc.d/rsyncd<br/>        /usr/local/etc/rsync/rsyncd.conf.sample<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">Another possibility is that you want to know which package a file came from. Use the <span class="literal">pkg which</span> command. I normally use this when I’ve found a weird library and want to know where it came from.</p>
<p class="programs"># <span class="codestrong1">pkg which libp11-kit.so</span><br/>/usr/local/lib/libp11-kit.so was installed by package p11-kit-0.23.5</p>
<p class="indent">My question is now, “What is p11-kit?” But that’s progress.</p>
<h4 class="h4" id="lev662"><span epub:type="pagebreak" id="page_354"/><strong><em>Package Integrity</em></strong></h4>
<p class="noindent">While you shouldn’t alter package files, eventually, someone does. You can use pkg to discover those alterations and undo the damage.</p>
<p class="indent">The pkg-check(8) tool includes features for identifying damage to packages and package dependencies. Developers can also use pkg-check(8) to check the bundled packages built from ports and distributed to end users, but that’s a whole separate problem.</p>
<h5 class="h5" id="lev663"><strong>File Corruption</strong></h5>
<p class="noindent">Verify that a package’s files are unaltered with <span class="literal">pkg check -s</span> and the package name. When my locked rsync package stops synchronizing files from the finicky remote server, one thing I verify is the package integrity.</p>
<p class="programs"># <span class="codestrong1">pkg check -s rsync</span><br/>Checking rsync:   0%<br/>rsync-3.1.2_6: checksum mismatch for /usr/local/bin/rsync<br/>Checking rsync: 100%</p>
<p class="indent">Either the disk is failing or someone has mucked with my rsync(1) binary. As this system uses self-healing ZFS, there’s gonna be a paddling.</p>
<p class="indent">You could uninstall and reinstall the package, but that might trigger changes depending on which packages require the package you’re updating. Also, as discussed earlier, this particular package is special. I don’t want pkg to upgrade the package to the newest version. Instead, I want to force pkg to reinstall the current package from the package cache. Use the <span class="literal">-f</span> flag to <span class="literal">pkg install</span>. While it updates the repository database, it reinstalls the cached package. If the package is locked, you must unlock it first.</p>
<p class="programs"># <span class="codestrong1">pkg unlock -y rsync</span><br/>Unlocking rsync-3.1.2_6<br/># <span class="codestrong1">pkg install -fy rsync</span><br/>--<span class="codeitalic1">snip</span>--<br/>[1/1] Reinstalling rsync-3.1.2_6...<br/>[1/1] Extracting rsync-3.1.2_6: 100%<br/># <span class="codestrong1">pkg lock -y rsync</span></p>
<p class="indent">My precious rsync is restored.</p>
<p class="indent">Check the integrity of all your packages by running <span class="literal">pkg check -saq</span>. It produces no output unless something has changed, so you could schedule it via cron (see <a href="ch20.xhtml#ch20">Chapter 20</a>).</p>
<h5 class="h5" id="lev664"><strong>Dependency Problems</strong></h5>
<p class="noindent">If someone really tries, they can delete packages that other packages depend on. Use the <span class="literal">-d</span> flag of <span class="literal">pkg check</span> to identify and fix missing dependencies.</p>
<p class="programs"># <span class="codestrong1">pkg check -d emacs-nox11</span><br/>Checking emacs-nox11: 100%<br/>emacs-nox11 has a missing dependency: gnutls<br/><span epub:type="pagebreak" id="page_355"/>emacs-nox11 is missing a required shared library: <span class="ent">➊</span>libgnutls.so.30<br/>--<span class="codeitalic1">snip</span>--<br/>&gt;&gt;&gt; Try to fix the missing dependencies? [Y/n]: <span class="codestrong1">y</span></p>
<p class="indent">The first thing to note is that when <span class="literal">pkg check</span> identifies a missing dependency, it tries to correct it. Answer <span class="codestrong">y</span> at the prompt to reinstall the dependency.</p>
<p class="indent">Note that this <span class="literal">pkg check</span> run shows us a missing library, libgnutls.so.30 <span class="ent">➊</span>. The dependency check doesn’t actually search for all the files in all of the packages. It knows that this library is missing only because the package that includes it is gone. If you manually remove the library, the dependency check won’t find it. You need to check package file integrity, as earlier.</p>
<p class="indent">If you want to check all package dependencies with <span class="literal">pkg check -d</span>, don’t give it a package name. You could add <span class="literal">-a</span> to explicitly check all packages, but that’s not necessary. If you add the <span class="literal">-q</span> flag, this command produces output only when it finds a problem. Adding <span class="literal">-q</span> also tells <span class="literal">pkg check</span> to attempt to resolve any dependency problems it finds, without user intervention.</p>
<p class="indent">The combination means that while I can run this check as a scheduled job, I’m less comfortable with my host reinstalling a missing dependency. Think about your system installing packages without your attention before automating dependency corrections.</p>
<p class="indent">The <span class="literal">pkg check</span> subcommand includes several other useful options, such as <span class="literal">-B</span> to rebuild shared library dependencies and <span class="literal">-r</span> to manually recompute the checksum of an installed package. Read pkg-check(8) for details.</p>
<h4 class="h4" id="lev665"><strong><em>Package Maintenance</em></strong></h4>
<p class="noindent">The package system includes several maintenance scripts intended to be run from periodic(8). Enable these in <em>/etc/periodic.conf</em>, as discussed in <a href="ch20.xhtml#ch20">Chapter 20</a>. Each adds to the daily, weekly, or security status emails.</p>
<p class="indent">To have the daily maintenance check package checksums and replace damaged packages, as with <span class="literal">pkg check -saq</span>, set <span class="literal">daily_status_security_pkg_checksum_enable</span> to <span class="codestrong">YES</span>.</p>
<p class="indent">To determine whether installed packages have security vulnerabilities published in the FreeBSD package security system, as discussed in <a href="ch19.xhtml#ch19">Chapter 19</a>, set <span class="literal">daily_status_security_pkgaudit_enable</span> to <span class="codestrong">YES</span>.</p>
<p class="indent">If you want FreeBSD to back up the installed packages and the package database every day, set <span class="literal">daily_backup_pkg_enable</span> to <span class="codestrong">YES</span>.</p>
<p class="indent">To be notified of changes in the installed packages, set <span class="literal">daily_status_pkg_changes_enable</span> to <span class="codestrong">YES</span>.</p>
<p class="indent">Finally, you can check for obsolete packages each week by setting <span class="literal">weekly_status_pkg_enable</span> to <span class="codestrong">YES</span>.</p>
<h4 class="h4" id="lev666"><strong><em>Package Networking and Environment</em></strong></h4>
<p class="noindent">FreeBSD’s package system is designed to work for a normal network attached to the internet. That’s something of a cruel joke because no network is normal. You can adjust pkg’s behavior to fit your network.</p>
<p class="indent"><span epub:type="pagebreak" id="page_356"/>The most common change is the need for a proxy server. Pkg uses fetch(3) to download package files, which takes any special networking configuration through environment variables. Set environment variables in the <span class="literal">PKG_ENV</span> section of <em>pkg.conf</em>. Each variable needs the variable name, a colon, and the value. Here, I set the <span class="literal">HTTP_PROXY</span> environment variable to my network proxy:</p>
<p class="programs">pkg_env : {<br/>  HTTP_PROXY: "http://proxy.mwl.io/"<br/>}</p>
<p class="indent">See fetch(3) for the complete list of proxy environment settings.</p>
<p class="indent">Some networks have separate bandwidth for different network stacks. I’ve been on more than one network that has better IPv6 connectivity than IPv4, or the other way. Direct pkg to use one network protocol or the other with the <span class="literal">IP_VERSION</span> setting in <em>pkg.conf</em>. You can set this to 4, 6, or let the host autoselect with the default of 0.</p>
<p class="indent">Finally, the <em>pkg.conf</em> <span class="literal">NAMESERVER</span> setting lets you override the nameservers given in <em>/etc/resolv.conf</em>. Put an IPv4 or IPv6 address here. You can use a hostname here, but pkg will look up that hostname using the default system nameservers.</p>
<h3 class="h3" id="lev667"><strong>Package Repositories</strong></h3>
<p class="noindent">You might want to use packages other than those provided by the FreeBSD Project. Maybe you build your own packages, as discussed in <a href="ch16.xhtml#ch16">Chapter 16</a>. Perhaps you have access to an experimental package repository. Or maybe you want to switch which set of official packages you’re using.</p>
<p class="indent">Pkg supports package <em>repositories</em>, or <em>repos</em>, which are named collections of packages. You can add, remove, enable, and disable repositories.</p>
<p class="indent">Normal repositories are very simple, but in rare cases, they can get quite complicated. We won’t go into the edge cases of configuring your own repositories, but the basics will take you quite far.</p>
<h4 class="h4" id="lev668"><strong><em>Repository Configuration</em></strong></h4>
<p class="noindent">Configure each repository in its own file. Official FreeBSD repositories belong in <em>/etc/pkg</em>. Configure repositories in UCL format (see <a href="ch02.xhtml#ch02">Chapter 2</a>). FreeBSD ships with the repo FreeBSD enabled. You’ll find the configuration file in <em>/etc/pkg/FreeBSD.conf</em>.</p>
<p class="programs">   FreeBSD: {<br/><span class="ent">➊</span> url: "pkg+http://pkg.FreeBSD.org/${ABI}/quarterly",<br/><span class="ent">➋</span> mirror_type: "srv",<br/><span class="ent">➌</span> signature_type: "fingerprints",<br/><span class="ent">➍</span> fingerprints: "/usr/share/keys/pkg",<br/><span class="ent">➎</span> enabled: yes<br/>   }</p>
<p class="indent"><span epub:type="pagebreak" id="page_357"/>This repository, named <em>FreeBSD</em>, supports the FreeBSD repo. When you decide to set up your own repository, give it a meaningful name.</p>
<p class="indent">The <span class="literal">mirror_type</span> entry <span class="ent">➋</span> tells pkg whether this repository is hosted on a normal website. Setting <span class="literal">mirror_type</span> to <span class="literal">NONE</span> tells pkg to use fetch to get packages using the standard network methods, like HTTP, FTP, or even a file path.</p>
<p class="indent">Millions of machines run FreeBSD and need access to the package repository. A single web server can’t keep up. By setting <span class="literal">mirror_type</span> to <span class="literal">srv</span>, you tell pkg to check DNS for an SRV record. SRV records are used to direct high-availability services, like VoIP and Active Directory.</p>
<p class="indent">The <span class="literal">url</span> entry <span class="ent">➊</span> shows the internet site where this repository can be found. I’m sure you’ve seen http URLs before, but what about this pkg+http thing? It ties the request to the SRV record used to direct pkg requests, as set by <span class="literal">mirror_type</span>.</p>
<p class="indent">The package system can verify downloaded packages with public keys or cryptographic hash fingerprints <span class="ent">➌</span>. You’ll need to tell pkg where to find the keys or hashes, though <span class="ent">➍</span>.</p>
<p class="indent">Finally, you must explicitly enable or disable <span class="ent">➎</span> each repository.</p>
<h4 class="h4" id="lev669"><strong><em>Repository Customization</em></strong></h4>
<p class="noindent">You can add and remove repositories as needed. As <em>/etc/pkg</em> is reserved for official FreeBSD repositories, you’ll need another directory. The traditional location is <em>/usr/local/etc/pkg/repos</em>. If you want to use a different directory, you’ll need to set a location in <em>pkg.conf</em> with the <span class="literal">REPO_DIRS</span> option. You’ll see commented-out examples for the defaults.</p>
<p class="programs">#REPOS_DIR [<br/>#    "/etc/pkg/",<br/>#    "/usr/local/etc/pkg/repos/",<br/>#]</p>
<p class="indent">The local repository directory doesn’t exist by default, so you’ll need to create it.</p>
<p class="programs"># <span class="codestrong1">mkdir -p /usr/local/pkg/repos</span></p>
<p class="indent">Put your own repository configurations in that directory.</p>
<p class="indent">FreeBSD searches for packages in directory order, checking directories in the order given in <span class="literal">REPOS_DIR</span>. The obvious implication is that the default FreeBSD repo can’t be disabled or overridden. That’s not quite true, but the reason is a little tricky.</p>
<h4 class="h4" id="lev670"><strong><em>Repository Inheritance</em></strong></h4>
<p class="noindent">You can split a repository’s configuration between multiple files. Entries in later files overwrite the entries in earlier files.</p>
<p class="indent">To see how this works, consider the default repository, called <em>FreeBSD</em>. If you have all of your custom repositories configured in <em>/usr/local/etc/pkg/repos</em>, pkg finds the FreeBSD repo first.</p>
<p class="indent"><span epub:type="pagebreak" id="page_358"/>But now create a <em>/usr/local/etc/pkg/repos/FreeBSD.conf</em> file. Define the FreeBSD repo in there, but include only a single configuration statement.</p>
<p class="programs">FreeBSD: { enabled: no }</p>
<p class="indent">Pkg finds the repo named FreeBSD first in <em>/etc/pkg/FreeBSD.conf</em>. This configuration defines the defaults for this repo. It finds the second configuration later. The second configuration overrides only one option, but that option turns off the repository.</p>
<p class="indent">While disabling the FreeBSD repository is an extreme case for folks who don’t run their own repository, there’s good reason to make minor changes to the repo, as we’ll see next.</p>
<h3 class="h3" id="lev671"><strong>Package Branches</strong></h3>
<p class="noindent">FreeBSD’s packages are built from the Ports Collection (see <a href="ch16.xhtml#ch16">Chapter 16</a>). The Ports Collection attempts to bring tens of thousands of different software suites to FreeBSD. These different programs all have their own release schedules, and the Ports Collection evolves continuously in an effort to keep up with them. As you can imagine, the Ports Collection has a whole bunch of churn. Most of us who run servers want stability. When most sysadmins consider “stability,” the word <em>churn</em> isn’t what comes to mind.</p>
<p class="indent">Most of us don’t need the very latest software on our servers. Most of the time, I’m fine if my database server is a minor point release or two behind; I care only that it keeps working. I’m certainly not going to upgrade my servers just because MySQL or nginx or PHP has a new software version. That way lies the madness of constant upgrades.</p>
<p class="indent">I do want security and stability updates, however. The database server being a little older doesn’t bother me. The database server occasionally losing its brain and sending all my data to the bit bucket, or offering everything to a Detroit hacking crew, bothers me a whole bunch.</p>
<p class="indent">The FreeBSD package system’s <em>quarterly branches</em> try to strike a middle ground between the world’s constant churning software and a sysadmin’s peace of mind. Every January, April, July, and October, the Ports crew forks the Ports Collection into a quarterly branch. The quarterly branch receives only security and stability updates, while the main Ports Collection charges merrily ahead.</p>
<p class="indent">The FreeBSD Project builds two sets of packages for each release. The <em>quarterly</em> packages are built from the quarterly Ports Collection. The <em>latest</em> packages are built from the bleeding-edge packages.</p>
<p class="indent">Some of you prefer the most current packages, despite the churn. That’s okay. Switching is simple. You need override only one entry in the FreeBSD repository. Create a new repository file, <em>/usr/local/etc/pkg/repos/FreeBSD.conf</em>, just as in the last section. Rather than disabling the default repository, though, we’re going to override the package source. Change the “quarterly” and the end of the URL to “latest.”</p>
<p class="programs">FreeBSD: { url: "pkg+http://pkg.FreeBSD.org/${ABI}/latest" }</p>
<p class="indent"><span epub:type="pagebreak" id="page_359"/>Welcome to the churn!</p>
<p class="indent">It’s strongly recommended to run <span class="literal">pkg update -f</span> after changing repositories in order to force pkg to download the latest repository catalogs.</p>
<p class="indent">Switching package collections doesn’t necessarily mean you need to reinstall everything. If your old packages work, use them. If weird problems appear, though, reinstall all of your packages with a command like <span class="literal">pkg upgrade -fa</span>. Even packages that have the same version as those in the other package collection might be subtly different.</p>
<h3 class="h3" id="lev672"><strong>Upgrading Packages</strong></h3>
<p class="noindent">As much as we might wish it were otherwise, you can’t set up a new system and ignore it. Either stability bugs appear or some clever jerk figures out a security exploit. (<a href="ch19.xhtml#ch19">Chapter 19</a> discusses auditing package security.) Sometimes you must upgrade your third-party software. With FreeBSD’s original packaging system, pkg_add, package upgrades risked a certain degree of heartache. With pkg(8), you still risk heartache—but it’s from the newer versions of the software, not the packaging system itself.</p>
<p class="indent">Before upgrading packages, back up your system. Then, use the <span class="literal">upgrade</span> subcommand to have pkg(8) upgrade all your packages. I recommend running a dry run first, with <span class="literal">-n</span>.</p>
<p class="programs"># <span class="codestrong1">pkg upgrade -n</span><br/>--<span class="codeitalic1">snip</span>--<br/>Checking for upgrades (2 candidates): 100%<br/>Processing candidates (2 candidates): 100%<br/>The following 1 package(s) will be affected (of 0 checked):<br/><br/>Installed packages to be UPGRADED:<br/>        ca_root_nss: 3.29.1 -&gt; 3.29.3<br/><br/>Number of packages to be upgraded: 1<br/><br/>335 KiB to be downloaded.</p>
<p class="indent">Carefully look at the list of packages to be upgraded. Are there any large jumps? Do you need to look at any release notes? How intrusive is this likely to be? Does the upgrade remove any packages that you want, like <em>X.org</em> or your text editor? Should you wait until Sunday at 3 <small>AM</small> and have your flunky do it?<sup><a href="footnote.xhtml#ch15fn3" id="ch15fn3a">3</a></sup> Studying the upgrade and considering the risks of each package upgrade might not reduce the amount of work you need to do, but it will reduce the amount of downtime and the amount of time people yell at you.</p>
<p class="indent">Once you’re comfortable with what will change, run the upgrade.</p>
<p class="programs"># <span class="codestrong1">pkg upgrade -y</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_360"/>You’ll see very similar messages about the packages to be upgraded and then notifications of the download and install process. Finally, pkg displays the installation message for every upgraded package.</p>
<p class="indent">Even the world’s most flexible packaging system won’t always meet your needs. FreeBSD makes customizing add-on software very easy through the Ports Collection, where we’ll go next.</p>
</body></html>