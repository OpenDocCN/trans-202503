<html><head></head><body>
<p id="filepos814248" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">12</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">AUTOMATING ARACHNI</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">Arachni is a powerful web application black-box security scanner written in Ruby. It features support for many types of web application vulnerabilities, including many of the OWASP Top 10 vulnerabilities (such as XSS and SQL injection); a highly scalable distributed architecture that allows you to spin up scanners in a cluster dynamically; and full automation through both a remote procedure call (RPC) interface and a representational state transfer (REST) interface. In this chapter, you’ll learn how to drive Arachni with its REST API and then with its RPC interface to scan a given URL for web application vulnerabilities.</p><p id="filepos815207" class="calibre_10"><span class="calibre3"><span class="bold">Installing Arachni</span></span></p><p class="calibre_11">The Arachni website (<a href="http://www.arachni-scanner.com/"><span class="italic">http://www.arachni-scanner.com/</span></a>) gives you the current download package for Arachni across multiple operating systems. You can use these installers to set up Arachni on your own system. Once you’ve downloaded it, you can test it by running Arachni against a server designed to test for web vulnerabilities, as shown in <a href="#filepos816231">Listing 12-1</a>. Although this command isn’t using the RPC to drive Arachni just yet, you can see what kind of output we will get when scanning for potential XSS or SQL injection vulnerabilities.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">arachni --checks xss*,sql* --scope-auto-redundant 2 \</span></span><br class="calibre5"/><span class="calibre4">
</span><span class="calibre4"><span class="bold">"http://demo.testfire.net/default.aspx"</span></span></blockquote><p id="filepos816231" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-1: Running Arachni against an intentionally vulnerable website</span></span></p><p class="calibre_6">This command uses Arachni to check for XSS and SQL vulnerabilities in the website <a href="http://demo.testfire.net/default.aspx"><span class="italic">http://demo.testfire.net/default.aspx</span></a>. We limit the scope of the pages it will follow by setting <span class="calibre4">--scope-auto-redundant</span> to <span class="calibre4">2</span>. Doing so makes Arachni follow URLs with the same parameters but with different parameter values up to twice before moving on to a new URL. Arachni can scan more quickly when a lot of links with the same parameters are available but all go to the same page.</p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">For a full introduction to and documentation of the supported vulnerability checks in Arachni, visit the Arachni GitHub page detailing the command line arguments:</span>
<a href="https://www.github.com/Arachni/arachni/wiki/Command-line-user-interface#checks/">https://www.github.com/Arachni/arachni/wiki/Command-line-user-interface#checks/</a>.</blockquote><p class="calibre_6">Within just a few minutes (depending on your internet speed), Arachni should report back a handful of XSS and SQL injection vulnerabilities in the website. Don’t worry—they’re supposed to be there! This website was built to be vulnerable. Later in the chapter, when testing our custom C# automation, you can use this list of XSS, SQL injection, and other vulnerabilities to ensure your automation is returning the correct results.</p><p class="calibre_6">But let’s say you want to automatically run Arachni against an arbitrary build of your web application as part of a secure software development life cycle (SDLC). Running it by hand isn’t very efficient, but we can easily automate Arachni to kick off scan jobs so it can work with any continuous integration system to pass or fail builds depending on the results of the scans. That’s where the REST API comes in.</p><p id="filepos818497" class="calibre_10"><span class="calibre3"><span class="bold">The Arachni REST API</span></span></p><p class="calibre_11">Recently, a REST API was introduced so that simple HTTP requests can be used to drive Arachni. <a href="#filepos819464">Listing 12-2</a> shows how to start this API.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">arachni_rest_server</span></span><br class="calibre5"/><span class="calibre4">Arachni - Web Application Security Scanner Framework v2.0dev</span><br class="calibre5"/><span class="calibre4"> Author: Tasos "Zapotek" Laskos &lt;tasos.laskos@arachni-scanner.com&gt;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> (With the support of the community and the Arachni Team.)</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Website: http://arachni-scanner.com</span><br class="calibre5"/><span class="calibre4"> Documentation: http://arachni-scanner.com/wiki</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➊[*] Listening on http://127.0.0.1:7331</span></blockquote><p id="filepos819464" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-2: Running the Arachni REST server</span></span></p><p class="calibre_6">When you start the server, Arachni will output some information about itself, including the IP address and port it is listening on ➊. Once you know the server is working, you can start using the API.</p><p class="calibre_6">With the REST API, you can start a simple scan using any common HTTP utility such as curl or even netcat. In this book, we’ll use curl as we have in previous chapters. Our first scan is shown in <a href="#filepos820821">Listing 12-3</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">curl -X POST --data '{"url":"http://demo.testfire.net/default.aspx"}'</span></span><span class="calibre4">➊ </span><span class="calibre4"><span class="bold">\</span></span><br class="calibre5"/><span class="calibre4">
</span><span class="calibre4"><span class="bold">http://127.0.0.1:7331/scans</span></span><br class="calibre5"/><span class="calibre4">{"id":"b139f787f2d59800fc97c34c48863bed"}➋</span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">curl http://127.0.0.1:7331/scans/b139f787f2d59800fc97c34c48863bed</span></span><span class="calibre4">➌</span><br class="calibre5"/><span class="calibre4">{"status":"done","busy":false,"seed":"676fc9ded9dc44b8a32154d1458e20de",</span><br class="calibre5"/><span class="calibre4"><span class="italic">--snip--</span></span></blockquote><p id="filepos820821" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-3: Testing the REST API with curl</span></span></p><p class="calibre_6">To kick off a scan, all we need to do is make a <span class="calibre4">POST</span> request with some JSON in the request body ➊. We start a new Arachni scan by passing JSON with the URL to scan using the <span class="calibre4">--data</span> argument from curl and send that to the <span class="calibre4">/scans</span> endpoint. The ID of the new scan is returned in the HTTP response ➋. After creating the scan, we can also retrieve the current scan status and results with a simple HTTP GET request (the default request type for curl) ➌. We do this by calling on the IP address and port Arachni is listening on and appending the ID we obtained when creating the scan for the <span class="calibre4">scans</span> request to the <span class="calibre4">/scans/</span> URL endpoint. After the scan finishes, the scan log will contain any vulnerabilities found during scanning, such as XSS, SQL injection, and other common web application vulnerabilities.</p><p class="calibre_6">Once this is done and we have an idea of how the REST API works, we can start writing the code that will allow us to use the API to scan any site we have an address for.</p><p id="filepos822120" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating the ArachniHTTPSession Class</span></span></span></p><p class="calibre_11">As in previous chapters, we will implement both a session and a manager class to interact with the Arachni API. Currently, these classes are relatively simple, but breaking them out now allows greater flexibility should the API require authentication or extra steps in the future. <a href="#filepos824524">Listing 12-4</a> details the <span class="calibre4">ArachniHTTPSession</span> class.</p><blockquote class="calibre_14"><span class="calibre4">public class ArachniHTTPSession</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public ➊ArachniHTTPSession(string host, int port)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Host = host;</span><br class="calibre5"/><span class="calibre4"> this.Port = port;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public string Host { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int Port { get; set; }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public JObject ➋ExecuteRequest(string method, string uri, JObject data = null)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string url = "http://" + this.Host + ":" + this.Port.ToString() + uri;</span><br class="calibre5"/><span class="calibre4"> HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);</span><br class="calibre5"/><span class="calibre4"> request.Method = method;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (data != null)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string dataString = data.ToString();</span><br class="calibre5"/><span class="calibre4"> byte[] dataBytes = System.Text.Encoding.UTF8.GetBytes(dataString);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> request.ContentType = "application/json";</span><br class="calibre5"/><span class="calibre4"> request.ContentLength = dataBytes.Length;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> request.GetRequestStream().Write(dataBytes, 0, dataBytes.Length);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string resp = string.Empty;</span><br class="calibre5"/><span class="calibre4"> using (StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream()))</span><br class="calibre5"/><span class="calibre4"> resp = reader.ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return JObject.Parse(resp);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos824524" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-4: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ArachniHTTPSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">At this point in the book, the <span class="calibre4">ArachniHTTPSession</span> class should be fairly simple to read and understand, so we won’t go too deep into the code. We create a constructor ➊ that accepts two arguments—the host and port to connect to—and assigns the values to the corresponding properties. We then create a method to execute a generic HTTP request ➋ based on the parameters passed to the method. The <span class="calibre4">ExecuteRequest()</span> method should return a <span class="calibre4">JObject</span> with any data that will be returned by a given API endpoint. Because the <span class="calibre4">ExecuteRequest()</span> method can be used to make any API call against Arachni, the only thing we can expect is that the response will be JSON that can be parsed from the server’s response into a <span class="calibre4">JObject</span>.</p><p id="filepos825625" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating the ArachniHTTPManager Class</span></span></span></p><p class="calibre_11">The <span class="calibre4">ArachniHTTPManager</span> class should also seem simple at this point, as <a href="#filepos827045">Listing 12-5</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">public class ArachniHTTPManager</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> ArachniHTTPSession _session;</span><br class="calibre5"/><span class="calibre4"> public ➊ArachniHTTPManager(ArachniHTTPSession session)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> _session = session;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> public JObject ➋StartScan(string url, JObject options = ➌null)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> JObject data = new JObject();</span><br class="calibre5"/><span class="calibre4"> data["url"] = url;</span><br class="calibre5"/><span class="calibre4"> data.Merge(options);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return _session.ExecuteRequest("POST", "/scans", data);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public JObject ➍GetScanStatus(Guid id)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return _session.ExecuteRequest("GET", "/scans/" + id.ToString ("N"));</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos827045" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-5: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ArachniHTTPManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">Our <span class="calibre4">ArachniHTTPManager</span> constructor ➊ accepts a single argument—the session to use for executing requests—and then assigns the session to a local private variable for use later. We then create two methods: <span class="calibre4">StartScan()</span> ➋ and <span class="calibre4">GetScanStatus()</span> ➍. These methods are all we need to create a small tool to scan and report on a URL.</p><p class="calibre_6">The <span class="calibre4">StartScan()</span> method accepts two arguments, one of which is optional with a default value of null ➌. By default, you can just specify a URL with no scan options to <span class="calibre4">StartScan()</span>, and Arachni will simply spider the site without checking for vulnerabilities—a feature that could give you an idea of how much <span class="italic">surface area</span> the web application has (that is, how many pages and forms there are to test). However, we actually want to specify extra arguments to tune the Arachni scan, so we’ll go ahead and merge those options into our data <span class="calibre4">JObject</span>, and then we’ll POST the scan details to the Arachni API and return the JSON sent back. The <span class="calibre4">GetScanStatus()</span> method makes a simple GET request, using the ID of the scan passed into the method in the URL of the API, and then returns the JSON response to the caller.</p><p id="filepos828665" class="calibre_10"><span class="calibre3"><span class="bold">Putting the Session and Manager Classes Together</span></span></p><p class="calibre_11">With both of the classes implemented, we can start scanning, as <a href="#filepos830456">Listing 12-6</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> ArachniHTTPSession session = new ArachniHTTPSession("127.0.0.1", 7331);</span><br class="calibre5"/><span class="calibre4"> ArachniHTTPManager manager = new ArachniHTTPManager(session);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➊JObject scanOptions = new JObject();</span><br class="calibre5"/><span class="calibre4"> scanOptions["checks"] = new JArray() { "xss*", "sql*" } ;</span><br class="calibre5"/><span class="calibre4"> scanOptions["audit"] = new JObject();</span><br class="calibre5"/><span class="calibre4"> scanOptions["audit"]["elements"] = new JArray() { "links", "forms" };</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string url = "http://demo.testfire.net/default.aspx";</span><br class="calibre5"/><span class="calibre4"> JObject scanId = manager.➋StartScan(url, scanOptions);</span><br class="calibre5"/><span class="calibre4"> Guid id = Guid.Parse(scanId["id"].ToString());</span><br class="calibre5"/><span class="calibre4"> JObject scan = manager.➌GetScanStatus(id);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> while (scan["status"].ToString() != "done")</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Sleeping a bit until scan is finished");</span><br class="calibre5"/><span class="calibre4"> System.Threading.Thread.Sleep(10000);</span><br class="calibre5"/><span class="calibre4"> scan = manager.GetScanStatus(id);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➍Console.WriteLine(scan.ToString());</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos830456" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-6: Driving Arachni with the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ArachniHTTPSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">and</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ArachniHTTPManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">classes</span></span></p><p class="calibre_6">After instantiating our session and manager classes, we create a new <span class="calibre4">JObject</span> ➊ to store our scan options in. These options directly correlate with the command line options you see from the Arachni tool when running <span class="calibre4">arachni –help</span> (there’s a lot). By storing a <span class="calibre4">JArray</span> with the values <span class="calibre4">xss*</span> and <span class="calibre4">sql*</span> in the <span class="calibre4">checks</span> option key, we tell Arachni to run XSS and SQL injection tests against the website, rather than simply spidering the application and finding all possible pages and forms. The <span class="calibre4">audit</span> option key just below that tells Arachni to audit links it finds and any HTML forms for checks we tell it to run.</p><p class="calibre_6">After setting up the scan options, we start the scan by calling the <span class="calibre4">StartScan()</span> method ➋ and passing our test URL as the argument. Using the ID returned by <span class="calibre4">StartScan()</span>, we retrieve the current scan status with <span class="calibre4">GetScanStatus()</span> ➌ and then loop until the scan is finished, checking every second for a new scan status. Once this is finished, we print the JSON scan results to the screen ➍.</p><p class="calibre_6">The Arachni REST API is simple and easily accessible to most security engineers or hobbyists since it can be used with basic command line tools. It is also highly automatable using the most common C# libraries, and it should be an easy introduction for an SDLC or for general automatic use on your own websites for weekly or monthly scans. For some extra fun, try running Arachni with your automation against previous web applications from the book with known vulnerabilities, such as BadStore. Now that we’ve looked at the Arachni API, we can discuss how to automate its RPC.</p><p id="filepos832765" class="calibre_10"><span class="calibre3"><span class="bold">The Arachni RPC</span></span></p><p class="calibre_11">The Arachni RPC protocol is a bit more advanced than the API, but it’s also more powerful. Although also powered by MSGPACK, just like Metasploit’s RPC, Arachni’s protocol has a twist. The data is sometimes Gzip compressed and is only communicated over a regular TCP socket, not HTTP. This complexity has its benefits: the RPC is blazingly fast without the HTTP overhead, and it gives you more scanner management power than the API, including the abilities to spin scanners up and down at will and create distributed scanning clusters, thus allowing clusters of Arachni to balance scanning across multiple instances. Long story short, the RPC is very powerful, but expect more development focus and support for the REST API because it is more accessible to most developers.</p><p id="filepos833681" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Manually Running the RPC</span></span></span></p><p class="calibre_11">To start an RPC listener, we use the simple script <span class="calibre4">arachni_rpcd</span>, as shown in <a href="#filepos834772">Listing 12-7</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">arachni_rpcd</span></span><br class="calibre5"/><span class="calibre4">Arachni - Web Application Security Scanner Framework v2.0dev</span><br class="calibre5"/><span class="calibre4"> Author: Tasos "Zapotek" Laskos &lt;tasos.laskos@arachni-scanner.com&gt;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> (With the support of the community and the Arachni Team.)</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Website: http://arachni-scanner.com</span><br class="calibre5"/><span class="calibre4"> Documentation: http://arachni-scanner.com/wiki</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">I,[2016-01-16T18:23:29.000746 #18862] INFO - System: RPC Server started.</span><br class="calibre5"/><span class="calibre4">I,[2016-01-16T18:23:29.000834 #18862] INFO - System: Listening on ➊127.0.0.1:7331</span></blockquote><p id="filepos834772" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-7: Running the Arachni RPC server</span></span></p><p class="calibre_6">Now we can test the listener using another script shipped with Arachni called <span class="calibre4">arachni_rpc</span>. Note the dispatcher URL ➊ in the output of the listening RPC server. We’ll need it next. The <span class="calibre4">arachni_rpc</span> script that ships with Arachni allows you to interface with the RPC listener from the command line. After starting the <span class="calibre4">arachni_rpcd</span> listener, open another terminal and change to the Arachni project root directory; then kick off a scan using the <span class="calibre4">arachni_rpc</span> script, as shown in <a href="#filepos835803">Listing 12-8</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">arachni_rpc --dispatcher-url 127.0.0.1:7331 \</span></span><br class="calibre5"/><span class="calibre4">
</span><span class="calibre4"><span class="bold">"http://demo.testfire.net/default.aspx"</span></span></blockquote><p id="filepos835803" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-8: Running an Arachni scan of the same intentionally vulnerable website via the RPC</span></span></p><p class="calibre_6">This command will drive Arachni to use the MSGPACK RPC, just as our C# code will do soon. If this is successful, you should see a nice text-based UI updating you on the status of the current scan with a nice report at the end, as <a href="#filepos839265">Listing 12-9</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">Arachni - Web Application Security Scanner Framework v2.0dev</span><br class="calibre5"/><span class="calibre4"> Author: Tasos "Zapotek" Laskos &lt;tasos.laskos@arachni-scanner.com&gt;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> (With the support of the community and the Arachni Team.)</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Website: http://arachni-scanner.com</span><br class="calibre5"/><span class="calibre4"> Documentation: http://arachni-scanner.com/wiki</span><br class="calibre5"/><span class="calibre4"> [~] 10 issues have been detected.</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [+] 1 | Cross-Site Scripting (XSS) in script context at</span><br class="calibre5"/><span class="calibre4">http://demo.testfire.net/search.aspx in form input `txtSearch` using GET.</span><br class="calibre5"/><span class="calibre4"> [+] 2 | Cross-Site Scripting (XSS) at http://demo.testfire.net/search.aspx</span><br class="calibre5"/><span class="calibre4">in form input `txtSearch` using GET.</span><br class="calibre5"/><span class="calibre4"> [+] 3 | Common directory at http://demo.testfire.net/PR/ in server.</span><br class="calibre5"/><span class="calibre4"> [+] 4 | Backup file at http://demo.testfire.net/default.exe in server.</span><br class="calibre5"/><span class="calibre4"> [+] 5 | Missing 'X-Frame-Options' header at http://demo.testfire.net/default.aspx in server.</span><br class="calibre5"/><span class="calibre4"> [+] 6 | Common administration interface at http://demo.testfire.net/admin.aspx in server.</span><br class="calibre5"/><span class="calibre4"> [+] 7 | Common administration interface at http://demo.testfire.net/admin.htm in server.</span><br class="calibre5"/><span class="calibre4"> [+] 8 | Interesting response at http://demo.testfire.net/default.aspx in server.</span><br class="calibre5"/><span class="calibre4"> [+] 9 | HttpOnly cookie at http://demo.testfire.net/default.aspx in cookie with inputs</span><br class="calibre5"/><span class="calibre4">`amSessionId`.</span><br class="calibre5"/><span class="calibre4"> [+] 10 | Allowed HTTP methods at http://demo.testfire.net/default.aspx in server.</span><br class="calibre5"/><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [~] Status: Scanning</span><br class="calibre5"/><span class="calibre4"> [~] Discovered 3 pages thus far.</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [~] Sent 1251 requests.</span><br class="calibre5"/><span class="calibre4"> [~] Received and analyzed 1248 responses.</span><br class="calibre5"/><span class="calibre4"> [~] In 00:00:45</span><br class="calibre5"/><span class="calibre4"> [~] Average: 39.3732270014467 requests/second.</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [~] Currently auditing http://demo.testfire.net/default.aspx</span><br class="calibre5"/><span class="calibre4"> [~] Burst response time sum 72.511066 seconds</span><br class="calibre5"/><span class="calibre4"> [~] Burst response count total 97</span><br class="calibre5"/><span class="calibre4"> [~] Burst average response time 0.747536762886598 seconds</span><br class="calibre5"/><span class="calibre4"> [~] Burst average 20.086991167522193 requests/second</span><br class="calibre5"/><span class="calibre4"> [~] Timed-out requests 0</span><br class="calibre5"/><span class="calibre4"> [~] Original max concurrency 20</span><br class="calibre5"/><span class="calibre4"> [~] Throttled max concurrency 20</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [~] ('Ctrl+C' aborts the scan and retrieves the report) </span><a id="filepos839265"/><span class="calibre4"><span class="italic">Listing 12-9: The</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">arachni_rpc</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">command line scanning UI</span></span></blockquote><p id="filepos839470" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The ArachniRPCSession Class</span></span></span></p><p class="calibre_11">To run a scan using the RPC framework and C#, we’ll implement the session/manager pattern again, starting with the Arachni RPC session class. With the RPC framework, you get a little bit more intimate with the actual Arachni architecture because you need to deal with dispatchers and instances at a granular level. When you connect to the RPC framework for the first time, you are connected to a <span class="italic">dispatcher</span>. You can interact with this dispatcher to create and manage <span class="italic">instances</span>, which do the actual scanning and work, but these scanning instances end up dynamically listening on a different port than the dispatcher. In order to provide an easy-to-use interface for both dispatchers and instances, we can create a session constructor that allows us to gloss over these distinctions a little bit, as shown in <a href="#filepos841495">Listing 12-10</a>.</p><blockquote class="calibre_14"><span class="calibre4"> public class ArachniRPCSession : IDisposable</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> SslStream _stream = null;</span><br class="calibre5"/><span class="calibre4"> public ArachniRPCSession(➊string host, int port,</span><br class="calibre5"/><span class="calibre4"> bool ➋initiateInstance = false)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Host = host;</span><br class="calibre5"/><span class="calibre4"> this.Port = port;</span><br class="calibre5"/><span class="calibre4"> ➌GetStream(host, port);</span><br class="calibre5"/><span class="calibre4"> this.IsInstanceStream = false;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (initiateInstance)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.InstanceName = ➍Guid.NewGuid().ToString();</span><br class="calibre5"/><span class="calibre4"> MessagePackObjectDictionary resp =</span><br class="calibre5"/><span class="calibre4"> this.ExecuteCommand("dispatcher.dispatch"➎,</span><br class="calibre5"/><span class="calibre4"> new object[] { this.InstanceName }).AsDictionary(); </span><a id="filepos841495"/><span class="calibre4"><span class="italic">Listing 12-10: The first half of the</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">ArachniRPCSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">constructor</span></span></blockquote><p class="calibre_6">The constructor accepts three arguments ➊. The first two—the host to connect to and the port on the host—are required. The third one, which is optional ➋ (with a default value of <span class="calibre4">false</span>), allows the programmer to automatically create a new scanning instance and connect to it, instead of having to create the new instance manually via the dispatcher.</p><p class="calibre_6">After assigning the <span class="calibre4">Host</span> and <span class="calibre4">Port</span> properties the values of the first two arguments passed to the constructor, respectively, we connect to the dispatcher using <span class="calibre4">GetStream()</span> ➌. If a <span class="calibre4">true</span> value is passed in as the third argument, <span class="calibre4">instantiateInstance</span> (which is <span class="calibre4">false</span> by default), we create a unique name for the instance we want to dispatch using a new <span class="calibre4">Guid</span> ➍ and then run the <span class="calibre4">dispatcher.dispatch</span> ➎ RPC command to create a new scanner instance that returns a new port (and potentially new host if you have a cluster of scanner instances). <a href="#filepos844220">Listing 12-11</a> shows the rest of the constructor.</p><blockquote class="calibre_14"><span class="calibre4"> string[] url = ➊resp["url"].AsString().Split(':');</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.InstanceHost = url[0];</span><br class="calibre5"/><span class="calibre4"> this.InstancePort = int.Parse(url[1]);</span><br class="calibre5"/><span class="calibre4"> this.Token = ➋resp["token"].AsString();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➌GetStream(this.InstanceHost, this.InstancePort);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> bool aliveResp = this.➍ExecuteCommand("service.alive?", new object[] { },</span><br class="calibre5"/><span class="calibre4"> this.Token).AsBoolean();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.IsInstanceStream = aliveResp;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➎public string Host { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int Port { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Token { get; set; }</span><br class="calibre5"/><span class="calibre4"> public bool IsInstanceStream { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string InstanceHost { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int InstancePort { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string InstanceName { get; set; }</span></blockquote><p id="filepos844220" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-11: The second half of the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ArachniRPCSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">constructor and its properties</span></span></p><p class="calibre_6">At ➊, we split the scanner instance URL (for example, 127.0.0.1:7331) into the IP address and the port (127.0.01 and 7331, respectively). Once we have the instance host and port we will use to drive the actual scan, we assign the values to our <span class="calibre4">InstanceHost</span> and <span class="calibre4">InstancePort</span> properties, respectively. We also save the authentication token ➋ returned by the dispatcher so we can make authenticated RPC calls later on the scanner instance. This authentication token is automatically generated by the Arachni RPC when we dispatch a new instance so that only we can use the new scanner with the token.</p><p class="calibre_6">We connect to the scanner instance using <span class="calibre4">GetStream()</span> ➌, which provides direct access to the scanning instance. If the connection is successful and the scanning instance is alive ➍, we assign the <span class="calibre4">IsInstanceStream</span> property to <span class="calibre4">true</span> so that we know whether we are driving a dispatcher or a scanning instance (which determines the RPC calls we can make to Arachni, such as creating a scanner or performing a scan) later when we implement the <span class="calibre4">ArachniRPCManager</span> class. After the constructor, we define the properties ➎ for the session class, all of which are used in the constructor.</p><p id="filepos845892" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The Supporting Methods for ExecuteCommand()</span></span></span></p><p class="calibre_11">Before we implement <span class="calibre4">ExecuteCommand()</span>, we need to implement the supporting methods for <span class="calibre4">ExecuteCommand()</span>. We’re almost there! <a href="#filepos849252">Listing 12-12</a> shows the methods we need in order to finish up the <span class="calibre4">ArachniRPCSession</span> class.</p><blockquote class="calibre_14"><span class="calibre4">public byte[] DecompressData(byte[] inData)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> using (MemoryStream outMemoryStream = new MemoryStream())</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (➊ZOutputStream outZStream = new ZOutputStream(outMemoryStream))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> outZStream.Write(inData, 0, inData.Length);</span><br class="calibre5"/><span class="calibre4"> return outMemoryStream.ToArray();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">private byte[] ➋ReadMessage(SslStream sslStream)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> byte[] sizeBytes = new byte[4];</span><br class="calibre5"/><span class="calibre4"> sslStream.Read(sizeBytes, 0, sizeBytes.Length);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (BitConverter.IsLittleEndian)</span><br class="calibre5"/><span class="calibre4"> Array.Reverse(sizeBytes);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> uint size = BitConverter.➌ToUInt32(sizeBytes, 0);</span><br class="calibre5"/><span class="calibre4"> byte[] buffer = new byte[size];</span><br class="calibre5"/><span class="calibre4"> sslStream.Read(buffer, 0, buffer.Length);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return buffer;</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">private void ➍GetStream(string host, int port)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> TcpClient client = new TcpClient(host, port);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> _stream = new SslStream(client.GetStream(), false,</span><br class="calibre5"/><span class="calibre4"> new RemoteCertificateValidationCallback(➎ValidateServerCertificate),</span><br class="calibre5"/><span class="calibre4"> (sender, targetHost, localCertificates,</span><br class="calibre5"/><span class="calibre4"> remoteCertificate, acceptableIssuers)</span><br class="calibre5"/><span class="calibre4"> =&gt; null);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> _stream.AuthenticateAsClient("arachni", null, SslProtocols.Tls, false);</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">private bool ValidateServerCertificate(object sender, X509Certificate certificate,</span><br class="calibre5"/><span class="calibre4"> X509Chain chain, SslPolicyErrors sslPolicyErrors)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> return true;</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">public void ➏Dispose()</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> if (this.IsInstanceStream &amp;&amp; _stream != null)</span><br class="calibre5"/><span class="calibre4"> this.ExecuteCommand(➐"service.shutdown", new object[] { }, this.Token);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (_stream != null)</span><br class="calibre5"/><span class="calibre4"> _stream.Dispose();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> _stream = null;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos849252" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-12: The supporting methods for the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ArachniRPCSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">Most of the support methods for the RPC session class are relatively simple. The <span class="calibre4">DecompressData()</span> method creates a new output stream from the zlib library available in NuGet, called <span class="calibre4">ZOutputStream</span> ➊. This returns the decompressed data as a byte array. In the <span class="calibre4">ReadMessage()</span> method ➋, we read the first 4 bytes from the stream and then convert the bytes into a 32-bit unsigned integer ➌ that represents the length of the rest of the data. Once we have the length, we read the rest of the data from the stream and return the data as a byte array.</p><p class="calibre_6">The <span class="calibre4">GetStream()</span> method ➍ is also very similar to the code we used to create a network stream in the OpenVAS library. We create a new <span class="calibre4">TcpClient</span> and wrap the stream in an <span class="calibre4">SslStream</span>. We use the <span class="calibre4">ValidateServerCertificate()</span> method ➎ to trust all SSL certificates by returning <span class="calibre4">true</span> all the time. This allows us to connect to the RPC instances with self-signed certificates. Finally, <span class="calibre4">Dispose()</span> ➏ is required by the <span class="calibre4">IDisposable</span> interface that the <span class="calibre4">ArachniRPCSession</span> class implements. If we’re driving a scanning instance instead of a dispatcher (set in the constructor when the <span class="calibre4">ArachniRPCSession</span> was created), we send the instance a <span class="calibre4">shutdown</span> command ➐ to clean up the scanning instance but leave the dispatcher running.</p><p id="filepos851147" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">The ExecuteCommand() Method</span></span></span></p><p class="calibre_11">The <span class="calibre4">ExecuteCommand()</span> method shown in <a href="#filepos852474">Listing 12-13</a> wraps all the functionality required to send commands and receive responses from the Arachni RPC.</p><blockquote class="calibre_14"><span class="calibre4">public MessagePackObject ➊ExecuteCommand(string command, object[] args,</span><br class="calibre5"/><span class="calibre4"> string token = null)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4">➋Dictionary&lt;string, object&gt; = new Dictionary&lt;string, object&gt;();</span><br class="calibre5"/><span class="calibre4">➌message["message"] = command;</span><br class="calibre5"/><span class="calibre4"> message["args"] = args;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (token != null)</span><br class="calibre5"/><span class="calibre4"> ➍message["token"] = token;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> byte[] packed;</span><br class="calibre5"/><span class="calibre4"> using (MemoryStream stream = new ➎MemoryStream())</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Packer packer = Packer.Create(stream);</span><br class="calibre5"/><span class="calibre4"> packer.PackMap(message);</span><br class="calibre5"/><span class="calibre4"> packed = stream.ToArray();</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos852474" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-13: The first half of the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ExecuteCommand()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method in the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ArachniRPCSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">The <span class="calibre4">ExecuteCommand()</span> method ➊ accepts three arguments: the command to execute, an object of the arguments to use with the command, and an optional argument for a token if an authentication token was provided. The method will mostly be used by the <span class="calibre4">ArachniRPCManager</span> class later. We start the method by creating a new dictionary called <span class="calibre4">request</span> to hold our command data (the command to run and the arguments for the RPC command) ➋. We then assign the <span class="calibre4">message</span> key ➌ in the dictionary the first argument passed to the <span class="calibre4">ExecuteCommand()</span> method, which is the command to run. We also assign the <span class="calibre4">args</span> key in the dictionary with the second argument passed to the method, which are the options for the command to be run. Arachni will look at these keys when we send our message, run the RPC command with the given arguments, and then return a response. If the third argument, which is optional, is not null, we assign the <span class="calibre4">token</span> key ➍ the authentication token passed to the method. These three dictionary keys (<span class="calibre4">message</span>, <span class="calibre4">args</span>, and <span class="calibre4">token</span>) are all that Arachni will look at when you send the serialized data to it.</p><p class="calibre_6">Once we have set up the <span class="calibre4">request</span> dictionary with the information we want to send to Arachni, we create a new <span class="calibre4">MemoryStream()</span> ➎ and use the same <span class="calibre4">Packer</span> class from the Metasploit bindings in <a href="index_split_016.html#filepos761301">Chapter 11</a> to serialize the <span class="calibre4">request</span> dictionary into a byte array. Now that we have prepared the data to send to Arachni to run an RPC command, we need to send the data and read the response from Arachni. That takes place in the second half of the <span class="calibre4">ExecuteCommand()</span> method, shown in <a href="#filepos856102">Listing 12-14</a>.</p><blockquote class="calibre_14"><span class="calibre4"> byte[] packedLength = ➊BitConverter.GetBytes(packed.Length);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (BitConverter.IsLittleEndian)</span><br class="calibre5"/><span class="calibre4"> Array.Reverse(packedLength);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➋_stream.Write(packedLength);</span><br class="calibre5"/><span class="calibre4"> ➌_stream.Write(packed);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> byte[] respBytes = ➍ReadMessage(_stream);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> MessagePackObjectDictionary resp = null;</span><br class="calibre5"/><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> resp = Unpacking.UnpackObject(respBytes).Value.AsDictionary();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> ➎catch</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> byte[] decompressed = DecompressData(respBytes);</span><br class="calibre5"/><span class="calibre4"> resp = Unpacking.UnpackObject(decompressed).Value.AsDictionary();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return resp.ContainsKey("obj") ? resp["obj"] : resp["exception"];</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos856102" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-14: The second half of the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ExecuteCommand()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method in the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ArachniRPCSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">Since the Arachni RPC stream uses a simple protocol to communicate, we can easily send our MSGPACK data to Arachni, but we need to send Arachni two pieces of information, not just the MSGPACK data. We first need to send Arachni the size of the MSGPACK data as a 4-byte integer in front of the MSGPACK data. This integer is the length of the serialized data in each message and tells the receiving host (in this case, Arachni) how much of the stream needs to be read in as part of the message segment. We need to get the bytes for the length of the data, so we use <span class="calibre4">BitConverter.GetBytes()</span> ➊ to get the 4-byte array. The length of the data and the data itself need to be written to the Arachni stream in a certain order. We first write the 4 bytes representing the data’s length to the stream ➋ and then write the full serialized message to the stream ➌.</p><p class="calibre_6">Next, we need to read the response from Arachni and return the response to the caller. Using the <span class="calibre4">ReadMessage()</span> method ➍, we take the raw bytes of the message from the response and attempt to unpack them into a <span class="calibre4">MessagePackObjectDictionary</span> in a <span class="calibre4">try</span>/<span class="calibre4">catch</span> block. If the first attempt is unsuccessful, that means the data is compressed using Gzip, so the <span class="calibre4">catch</span> block ➎ takes over. We decompress the data and then unpack the decompressed bytes into a <span class="calibre4">MessagePackObjectDictionary</span>. Finally, we return either the full response from the server or an exception if an error has occurred.</p><p id="filepos858162" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">The ArachniRPCManager Class</span></span></span></p><p class="calibre_11">The <span class="calibre4">ArachniRPCManager</span> class is considerably simpler than the <span class="calibre4">ArachniRPCSession</span> class, as shown in <a href="#filepos861121">Listing 12-15</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class ArachniRPCManager : IDisposable</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> ArachniRPCSession _session;</span><br class="calibre5"/><span class="calibre4"> public ArachniRPCManager(➊ArachniRPCSession session)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (!session.IsInstanceStream)</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Session must be using an instance stream");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> _session = session;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public MessagePackObject ➋StartScan(string url, string checks = "*")</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Dictionary&lt;string, object&gt;args = new Dictionary&lt;string, object&gt;();</span><br class="calibre5"/><span class="calibre4"> args["url"] = url;</span><br class="calibre5"/><span class="calibre4"> args["checks"] = checks;</span><br class="calibre5"/><span class="calibre4"> args["audit"] = new Dictionary&lt;string, object&gt;();</span><br class="calibre5"/><span class="calibre4"> ((Dictionary&lt;string, object&gt;)args["audit"])["elements"] = new object[] { "links", "forms" };</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return _session.ExecuteCommand(➌"service.scan", new object[] { args }, _session.Token);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public MessagePackObject ➍GetProgress(List&lt;uint&gt; digests = null)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Dictionary&lt;string, object&gt;args = new Dictionary&lt;string, object&gt;();</span><br class="calibre5"/><span class="calibre4"> args["with"] = "issues";</span><br class="calibre5"/><span class="calibre4"> if (digests != null)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> args["without"] = new Dictionary&lt;string, object&gt;();</span><br class="calibre5"/><span class="calibre4"> ((Dictionary&lt;string, object&gt;)args["without"])["issues"] = digests.ToArray();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> return _session.➎ExecuteCommand("service.progress", new object[] { args }, _session.Token);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public MessagePackObject ➏IsBusy()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return _session.ExecuteCommand("service.busy?", new object[] { }, _session.Token);</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public void Dispose()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➐_session.Dispose();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos861121" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-15: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ArachniRPCManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">First, the <span class="calibre4">ArachniRPCManager</span> constructor accepts an <span class="calibre4">ArachniRPCSession</span> ➊ as its only argument. Our manager class will only implement methods for a scanning instance, not a dispatcher, so if the session passed in is not a scanning instance, we throw an exception. Otherwise, we assign the session to a local class variable for use in the rest of the methods.</p><p class="calibre_6">The first method we create in the <span class="calibre4">ArachniRPCManager</span> class is the <span class="calibre4">StartScan()</span> method ➋, which accepts two arguments. The first argument, which is required, is a string of the URL Arachni will scan. The second argument, which is optional, defaults to running all checks (such as XSS, SQL injection, and path traversal, for example), but it can be changed if the user wants to specify different checks in the options passed to <span class="calibre4">StartScan()</span>. To determine which checks are run, we build a new message to send to Arachni by instantiating a new dictionary using the <span class="calibre4">url</span> and <span class="calibre4">checks</span> arguments passed to the <span class="calibre4">StartScan()</span> method and <span class="calibre4">audit</span>, which Arachni will look at to determine what kind of scan to perform when we send the message. Finally, we send the message using the <span class="calibre4">service.scan</span> command ➌ and return the response to the caller.</p><p class="calibre_6">The <span class="calibre4">GetProgress()</span> method ➍ accepts a single optional argument: a list of integers that Arachni uses to identify reported issues. We’ll talk more about how Arachni reports issues in the next section. Using this argument, we build a small dictionary and pass it to the <span class="calibre4">service.progress</span> command ➎, which will return the current progress and status of the scan. We send the command to Arachni and then return the result to the caller.</p><p class="calibre_6">The last important method, <span class="calibre4">IsBusy()</span> ➏, simply tells us whether the current scanner is performing a scan. Finally, we clean it all up with <span class="calibre4">Dispose()</span> ➐.</p><p id="filepos863613" class="calibre_10"><span class="calibre3"><span class="bold">Putting It All Together</span></span></p><p class="calibre_11">Now we have the building blocks to drive Arachni’s RPC to scan a URL and report the results in real time. <a href="#filepos866078">Listing 12-16</a> shows how we glue all the parts together to scan a URL with the RPC.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> using (ArachniRPCSession session = new ➊ArachniRPCSession("127.0.0.1",</span><br class="calibre5"/><span class="calibre4"> 7331, true))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (ArachniRPCManager manager = new ArachniRPCManager(session))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.➋WriteLine("Using instance: " + session.InstanceName);</span><br class="calibre5"/><span class="calibre4"> manager.StartScan("http://demo.testfire.net/default.aspx");</span><br class="calibre5"/><span class="calibre4"> bool isRunning = manager.IsBusy().AsBoolean();</span><br class="calibre5"/><span class="calibre4"> List&lt;uint&gt; issues = new List&lt;uint&gt;();</span><br class="calibre5"/><span class="calibre4"> DateTime start = DateTime.Now;</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Starting scan at " + start.ToLongTimeString());</span><br class="calibre5"/><span class="calibre4"> ➌while (isRunning)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Thread.Sleep(10000);</span><br class="calibre5"/><span class="calibre4"> var progress = manager.GetProgress(issues);</span><br class="calibre5"/><span class="calibre4"> foreach (MessagePackObject p in</span><br class="calibre5"/><span class="calibre4"> progress.AsDictionary()["issues"].AsEnumerable())</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> MessagePackObjectDictionary dict = p.AsDictionary();</span><br class="calibre5"/><span class="calibre4"> Console.➍WriteLine("Issue found: " + dict["name"].AsString());</span><br class="calibre5"/><span class="calibre4"> issues.Add(dict["digest"].AsUInt32());</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> isRunning = manager.➎IsBusy().AsBoolean();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> DateTime end = DateTime.Now;</span><br class="calibre5"/><span class="calibre4"> ➏Console.WriteLine("Finishing scan at " + end.ToLongTimeString() +</span><br class="calibre5"/><span class="calibre4"> ". Scan took " + ((end - start).ToString()) + ".");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos866078" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-16: Driving Arachni with the RPC classes</span></span></p><p class="calibre_6">We start the <span class="calibre4">Main()</span> method by creating a new <span class="calibre4">ArachniRPCSession</span> ➊, passing the host and port for the Arachni dispatcher, as well as <span class="calibre4">true</span> as the third argument to automatically get a new scanning instance. Once we have the session and manager classes and are connected to Arachni, we print our current instance name ➋, which should just be the unique ID we generated when we created the scanning instance to connect to it. We then start the scan by passing the test URL to the <span class="calibre4">StartScan()</span> method.</p><p class="calibre_6">Once the scan is started, we can watch it until it’s finished and then print the final report. After creating a few variables such as an empty list, which we’ll use to store the issues that Arachni reports back, and the time when the scan started, we begin a <span class="calibre4">while</span> loop ➌, which will loop until <span class="calibre4">isRunning</span> is <span class="calibre4">false</span>. Within the <span class="calibre4">while</span> loop, we call <span class="calibre4">GetProgress()</span> to get the current progress of our scan; then we print ➍ and store any new issues found since we last called <span class="calibre4">GetProgress()</span>. We finally sleep for 10 seconds and then call <span class="calibre4">IsBusy()</span> ➎ again. We then start the process all over again until the scan is finished. When all is said and done, we print a small summary ➏ of how long the scan took. If you look at the vulnerabilities reported by your automation (my truncated results are shown in <a href="#filepos868851">Listing 12-17</a>) and the original Arachni scans we performed by hand at the beginning of the chapter, they should match up!</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">mono ./ch12_automating_arachni.exe</span></span><br class="calibre5"/><span class="calibre4">Using instance: 1892413b-7656-4491-b6c0-05872396b42f</span><br class="calibre5"/><span class="calibre4">Starting scan at 8:58:12 AM</span><br class="calibre5"/><span class="calibre4">Issue found: Cross-Site Scripting (XSS)➊</span><br class="calibre5"/><span class="calibre4">Issue found: Common directory</span><br class="calibre5"/><span class="calibre4">Issue found: Backup file➋</span><br class="calibre5"/><span class="calibre4">Issue found: Missing 'X-Frame-Options' header</span><br class="calibre5"/><span class="calibre4">Issue found: Interesting response</span><br class="calibre5"/><span class="calibre4">Issue found: Allowed HTTP methods</span><br class="calibre5"/><span class="calibre4">Issue found: Interesting response</span><br class="calibre5"/><span class="calibre4">Issue found: Path Traversal➌</span><br class="calibre5"/><span class="calibre4"><span class="italic">--snip--</span></span></blockquote><p id="filepos868851" class="calibre_15"><span class="calibre4"><span class="italic">Listing 12-17: Running the Arachni C# classes to scan and report on a sample URL</span></span></p><p class="calibre_6"> Because we are running Arachni with all the checks enabled, this site will report a lot of vulnerabilities! In just the first 10 or so lines, Arachni reported an XSS vulnerability ➊, a backup file with potentially sensitive information ➋, and a path traversal weakness ➌. If you wanted to limit the checks Arachni performs to just an XSS vulnerability scan, you could pass a second argument to <span class="calibre4">StartScan</span> with the string <span class="calibre4">xss*</span> (the default value for the argument is <span class="calibre4">*</span>, which means “all checks”), and Arachni would only check for and report any XSS vulnerabilities found. The command would end up looking like the following line of code: manager.StartScan("http://demo.testfire.net/default.aspx", "xss*"); Arachni supports a wide variety of checks, including SQL and command injection, so I encourage you to read the documentation on the supported checks.</p><p id="filepos869982" class="calibre_10"><span class="calibre3"><span class="bold">Conclusion</span></span></p><p class="calibre_11">Arachni is an incredibly powerful and versatile web application scanner that should be a tool in any serious security engineer or pentester’s arsenal. As you have seen in this chapter, you can easily drive it in both simple and complex scenarios. If you only need to scan a single application regularly, the HTTP API might be enough for you. However, if you find yourself constantly scanning new and different applications, the ability to spin up scanners at will may be the best way for you to distribute your scans and prevent bottlenecking.</p><p class="calibre_6">We first implemented a set of simple classes that interfaced with the Arachni REST API in order to kick off, watch, and report on a scan. Using the base HTTP libraries in our toolset, we were able to easily build modular classes to drive Arachni.</p><p class="calibre_6">Once we finished the simpler REST API, we took Arachni a step further to drive it via the MSGPACK RPC. Using a couple of open source third-party libraries, we were able to drive Arachni with some of its more powerful features. We used its distributed model to create a new scanning instance with the RPC dispatcher, and then we scanned a URL and reported the results in real time.</p><p class="calibre_6">Using either of these building blocks, you can incorporate Arachni into any SDLC or continuous integration system to ensure the quality and security of the web applications being used or built by you or your organization. </p><div class="mbp_pagebreak" id="calibre_pb_17"/>
</body></html>