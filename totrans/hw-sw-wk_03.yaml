- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**Web Security**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web安全**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: 'You may not have realized it before, but the Internet as we know it couldn’t
    exist without a solution to the shared key problem. Think about a typical situation:
    you’re buying something at an online retailer that you’ve never purchased from
    before. At some point you will be asked for your credit card data. Your browser
    tells you that your data is secure, perhaps by displaying a “lock” icon in the
    corner. But for the browser to protect your card number using AES, both your system
    and the retailer must use the same encryption key. How do two systems securely
    transmit data without getting together beforehand to exchange a key?'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前没意识到，但我们所知的互联网如果没有解决共享密钥问题，根本无法存在。想象一个典型的情境：你在一个你以前没有购买过东西的在线零售商那里购物。某一时刻，你会被要求提供信用卡数据。浏览器告诉你，你的数据是安全的，可能通过在角落里显示一个“锁”图标来告知你。但要让浏览器通过AES保护你的卡号，必须确保你的系统和零售商使用相同的加密密钥。那两个系统如何在不事先交换密钥的情况下安全地传输数据呢？
- en: 'Solving this shared key problem is essential to providing any security on the
    Web. We’ll explore the solution to the shared key problem in this chapter, which
    uses all the techniques we’ve seen in the previous two chapters, plus a new special
    ingredient: public-key cryptography.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个共享密钥问题对于提供Web安全至关重要。在本章中，我们将探讨解决共享密钥问题的方法，它结合了我们在前两章中看到的所有技术，并添加了一个新的特殊元素：公钥密码学。
- en: '**How Public-Key Cryptography Solves the Shared Key Problem**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**公钥密码学如何解决共享密钥问题**'
- en: In the world of physical security, the shared key problem has a straightforward
    solution because locks and keys are two separate things. Suppose person A needs
    to ship confidential physical documents to person B. Person B could buy a strongbox
    and a keyed lock and then mail the box and lock to person A while keeping the
    key. Then person A puts the documents in the box, locks the box with B’s lock,
    and ships the box back to B. Because B has the only key to the lock, this is a
    secure delivery method.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理安全的世界里，共享密钥问题有一个直接的解决方案，因为锁和钥匙是两个独立的物件。假设A需要将机密物理文件发送给B。B可以购买一个强箱和一把带钥匙的锁，然后将箱子和锁邮寄给A，同时保留钥匙。然后A将文件放入箱子，用B的锁把箱子锁好，接着将箱子寄回给B。由于B是唯一拥有锁钥匙的人，这是一种安全的递送方式。
- en: This is the desired situation for transmitting data digitally as well. We need
    to separate the methods for locking and unlocking data, so that knowing how to
    encrypt data won’t provide the means to decrypt the resulting ciphertext.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是数字传输数据的理想情况。我们需要将数据的加锁和解锁方法分开，这样仅知道如何加密数据的人就无法解密结果的密文。
- en: In [Chapter 1](ch01.html#ch01), we learned about AES, which is a symmetric-key
    encryption method, meaning the same key is used for encryption and decryption.
    For transmission, we need an *asymmetric-key* encryption method, with one key
    for encryption and another key for decryption. The encryption key is known as
    the *public key*, because it can be freely distributed with no ill effects if
    it falls into the hands of an attacker; for this reason, asymmetric-key encryption
    is also known as *public-key cryptography*. The decryption key is known only to
    the recipient, so it’s known as the *private key*. These relationships are shown
    in [Figure 3-1](ch03.html#ch3fig1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html#ch01)中，我们了解了AES，它是一种对称密钥加密方法，意味着加密和解密使用相同的密钥。对于数据传输，我们需要一种*非对称密钥*加密方法，一种密钥用于加密，另一种用于解密。加密密钥被称为*公钥*，因为即使它落入攻击者手中，公开分发也不会带来不良影响；因此，非对称密钥加密也被称为*公钥密码学*。解密密钥只有接收者知道，因此被称为*私钥*。这些关系如[图3-1](ch03.html#ch3fig1)所示。
- en: '![image](graphics/f03-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f03-01.jpg)'
- en: '*Figure 3-1: Asymmetric-key encryption, with a public key for encryption and
    a private key for decryption. Only the receiver has the private key.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：非对称密钥加密，使用公钥加密，使用私钥解密。只有接收者拥有私钥。*'
- en: '**Math Tools for Public-Key Cryptography**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**公钥密码学的数学工具**'
- en: What public-key cryptography requires, then, is an encryption method that’s
    reversible but *not* with the cipher key that was used in the encryption. The
    basic tools of the encryption methods we’ve seen so far won’t work for public-key
    cryptography. The most common operation in AES, for example, is exclusive-or,
    which is used precisely because when something is XORed twice with the same binary
    number, you get the same number you started with. Reversible operations such as
    XOR inevitably lead to having the same key for encryption and decryption.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，公钥密码学所需要的，是一种可逆的加密方法，但*不是*使用在加密中的密钥来反转。我们到目前为止所见的加密方法的基本工具，不适用于公钥密码学。例如，AES中最常用的操作是异或（exclusive-or），之所以使用它，恰恰是因为当某个东西与相同的二进制数字异或两次时，结果会得到你开始时的那个数字。像异或这样的可逆操作不可避免地导致加密和解密使用相同的密钥。
- en: Public-key encryption, therefore, requires a new technique. As it turns out,
    the secrets to public-key encryption lie in the hidden relationships between numbers.
    In order to explain what those relationships are and how they can be exploited
    for cryptography, we need to go over a few pieces of math terminology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，公钥加密需要一种新的技术。事实证明，公钥加密的秘密在于数字之间隐藏的关系。为了说明这些关系是什么以及它们如何用于密码学，我们需要了解一些数学术语。
- en: '***Invertible Functions***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可逆函数***'
- en: Broadly stated, a *function* describes any situation where each numerical input
    results in a single numerical output. The current Celsius temperature, for example,
    is a function of the current Fahrenheit temperature. For any particular temperature
    in Fahrenheit degrees, there is exactly one matching temperature in Celsius degrees.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 广义地说，*函数*描述了任何一种情形，其中每个数值输入都会产生一个唯一的数值输出。例如，当前的摄氏温度是当前华氏温度的一个函数。对于任何特定的华氏温度，总会有一个对应的摄氏温度。
- en: In the same way, the monetary value of a pile of coins is a function of the
    number of coins of each type. A pile containing three quarters, two nickels, a
    dime, and four pennies has a monetary value of 99 cents. This pile of coins cannot
    be worth any other amount.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一堆硬币的货币价值是每种类型硬币数量的函数。一个包含三枚25美分硬币、两枚5美分硬币、一枚10美分硬币和四枚1美分硬币的堆，货币总值为99美分。这个硬币堆不能值其他任何金额。
- en: 'Sometimes a function can be reversed to produce another function. If we know
    a temperature in degrees Fahrenheit, we also know it in degrees Celsius, and the
    reverse is true: if we know a temperature in Celsius, we can also figure it out
    in Fahrenheit. In mathematical terms, we would say that the Celsius-to-Fahrenheit
    function is the *inversion* of the Fahrenheit-to-Celsius function, and that the
    original function is *invertible*. The coin example, though, is not invertible.
    The same total monetary value can be produced by multiple combinations of coins.
    If the coins in my pocket are worth 99 cents, I might have three quarters, two
    nickels, a dime, and four pennies, or I might have nine dimes and nine pennies,
    or some other combination.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个函数可以被反转来产生另一个函数。如果我们知道一个温度的华氏度数，我们也可以知道它的摄氏度数，反之亦然：如果我们知道一个温度的摄氏度数，我们也能算出它的华氏度数。从数学角度来说，我们可以说摄氏到华氏的转换函数是华氏到摄氏函数的*反转*，而原始函数是*可逆的*。然而，硬币的例子则是不可逆的。相同的总货币价值可以通过多种不同的硬币组合产生。如果我口袋里的硬币总值是99美分，我可能有三枚25美分硬币、两枚5美分硬币、一枚10美分硬币和四枚1美分硬币，或者我可能有九枚10美分硬币和九枚1美分硬币，或者其他的组合。
- en: '***One-Way Functions***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***单向函数***'
- en: For some invertible functions, computing in one direction may be a lot easier
    than the other. For example, the mathematical concepts of *square* and *square
    root* are complementary functions. Suppose you have a square room in your home
    that is covered in black-and-white tiles, as shown in [Figure 3-2](ch03.html#ch3fig2).
    To find the total surface area of the floor, you multiply 12 by 12 to get 144.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些可逆函数，从一个方向进行计算可能比从另一个方向计算要容易得多。例如，*平方*和*平方根*是互补的数学概念。假设你家里有一个正方形的房间，地板上铺着黑白相间的瓷砖，如[图3-2](ch03.html#ch3fig2)所示。要计算地板的总面积，你可以将12乘以12得到144。
- en: 'We say that 144 is the *square* of 12\. Going in the other direction, we say
    that 12 is the *square root* of 144\. These are both functions; each number has
    one square and one square root. The difficulty of computing these two functions
    is very different, though. Figuring out a number’s square is easy: you just multiply
    the number by itself. Figuring out the square root is hard. Unless you have a
    table of values to help you, computing a square root is effectively a trial-and-error
    process. You make a guess at what the root might be, multiply that guess by itself,
    see if your guess was too high or too low, and then adjust your next guess accordingly,
    repeating the process until you find the exact square root or get close enough
    that you are willing to stop. When a function is invertible but its inverse is
    much harder to compute, it is called a *one-way function*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说 144 是 12 的*平方*。反过来，我们说 12 是 144 的*平方根*。这两个都是函数；每个数字都有一个平方和一个平方根。然而，计算这两个函数的难度是截然不同的。算出一个数字的平方很简单：你只需将该数字乘以自身。而算出平方根则很难。除非你有一个数值表来帮助你，否则计算平方根实际上是一个试错过程。你先猜测平方根可能是什么，计算出这个猜测的平方，看它是否太高或太低，然后根据结果调整下一个猜测，重复这一过程直到找到准确的平方根，或者接近得足够可以停止。当一个函数是可逆的，但其逆函数计算起来要困难得多时，它被称为*单向函数*。
- en: '![image](graphics/f03-02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f03-02.jpg)'
- en: '*Figure 3-2: A square room with walls 12 feet long has a total area of 144
    feet.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：一间墙长 12 英尺的正方形房间总面积为 144 平方英尺。*'
- en: '***Trapdoor Functions***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***陷门函数***'
- en: Asymmetric encryption requires a one-way function so that the encryption key
    can be public—the encryption will be easy, but the decryption will be so hard
    as to be infeasible. The problem is, we shouldn’t make the decryption infeasible
    for the intended recipient as well. So any old one-way function isn’t going to
    do the trick. We need what’s known as a *trapdoor function*, a one-way function
    where the inverse function is hard in general, but easy when some secret value
    is known.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密需要一个单向函数，使得加密密钥可以公开——加密过程简单，但解密将变得非常困难，几乎不可行。问题在于，我们不应让预定的接收者也无法解密。因此，任何普通的单向函数都不行。我们需要一种被称为*陷门函数*的单向函数，其中逆函数一般很难计算，但如果知道某个秘密值，逆函数就容易计算。
- en: '**Prime Numbers**'
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**素数**'
- en: The particular trapdoor function we’ll discuss involves prime numbers. A number
    is *prime* if it is greater than 1 and can only be divided (without a remainder)
    by itself and 1\. For example, 5 is prime because it can be divided only by itself
    and 1\. It cannot be evenly divided into 2, 3, or 4 parts. The number 6, though,
    can be divided by 2 and 3 in addition to 1 and itself. It is therefore a nonprime,
    or *composite*, number. Smaller numbers that divide into a larger number are known
    as the larger number’s *factors*. Every number is divisible by itself and by 1,
    but we call these *trivial factors* and tend to ignore them when discussing factors.
    A prime number has only trivial factors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的特定“陷门”函数涉及素数。一个数字如果大于 1 且只能被自身和 1 整除（没有余数），则被称为*素数*。例如，5 是素数，因为它只能被自身和
    1 整除，不能被 2、3 或 4 整除。然而，6 除了可以被 1 和自身整除外，还可以被 2 和 3 整除，因此它是一个非素数或*合成*数。能整除较大数字的小数字被称为较大数字的*因数*。每个数字都能被其自身和
    1 整除，但我们称这些为*平凡因数*，并且在讨论因数时通常会忽略它们。一个素数只有平凡因数。
- en: '**Coprime Numbers**'
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**互质数**'
- en: In a related concept, two numbers are said to be *coprime* if they share only
    1 as a factor. Either number may or may not be prime itself, but each can be thought
    of as prime as far as the other number knows. For example, the composite numbers
    9 and 4 are coprime because there is no number that divides them both except for
    1\. In contrast, 6 isn’t coprime with either 9 or 4, because 6 shares factors
    with both. These relationships are demonstrated in [Table 3-1](ch03.html#ch3tab1).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个相关概念中，如果两个数字只有 1 作为公因数，则称它们是*互质*的。无论每个数字本身是否为素数，它们都可以被认为是素数，至少从另一个数字的角度来看是如此。例如，合成数
    9 和 4 是互质的，因为除了 1 外，没有其他数字可以同时整除它们。相反，6 与 9 或 4 都不是互质的，因为 6 与两者都有共同的因数。这些关系在[表
    3-1](ch03.html#ch3tab1)中有所展示。
- en: '**Table 3-1:** Showing that 9 and 4 Are Coprime, but 6 Is Not Coprime with
    9 or 4'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1:** 显示 9 和 4 是互质的，但 6 与 9 或 4 都不是互质的'
- en: '| **Divisor** | **Remainder from 9** | **Remainder from 6** | **Remainder from
    4** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **因数** | **来自 9 的余数** | **来自 6 的余数** | **来自 4 的余数** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 9 | (trivial) |  |  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 9 | (平凡的) |  |  |'
- en: '| 8 | 1 |  |  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1 |  |  |'
- en: '| 7 | 2 |  |  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 2 |  |  |'
- en: '| 6 | 3 | (trivial) |  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 3 | (平凡的) |  |'
- en: '| 5 | 4 | 1 |  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 4 | 1 |  |'
- en: '| 4 | 1 | 2 | (trivial) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1 | 2 | （简单）|'
- en: '| 3 | 0 | 0 | 1 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0 | 0 | 1 |'
- en: '| 2 | 1 | 0 | 0 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 0 | 0 |'
- en: '| 1 | (trivial) | (trivial) | (trivial) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 1 | （简单） | （简单） | （简单）|'
- en: Although 1 is not a prime number, it’s considered to be coprime with every other
    number.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 1 不是质数，但它被认为是与任何其他数字互质的。
- en: '**Prime Factors**'
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**质因数**'
- en: Now we are getting close to the hidden relationships that make public-key encryption
    work. If we multiply two prime numbers, the resulting product has only those two
    prime numbers as factors (again, not counting itself and 1). For example, 5 and
    3 are prime numbers. The product of 3 and 5 is 15, and 15 has only 3 and 5 as
    factors, as shown in [Table 3-2](ch03.html#ch3tab2).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们即将接近使公钥加密能够工作的隐藏关系。如果我们将两个质数相乘，得到的积只有这两个质数作为因数（再次强调，不计算它自身和 1）。例如，5 和 3
    是质数。3 和 5 的积是 15，且 15 只有 3 和 5 作为因数，如 [表 3-2](ch03.html#ch3tab2) 所示。
- en: '**Table 3-2:** The Product of Prime Numbers 3 and 5 Is 15, and 15 Has Only
    3 and 5 as Factors'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-2：** 3 和 5 的积是 15，且 15 只有 3 和 5 作为因数'
- en: '| **Divide 15 by** | **Result** | **Remainder** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **除以 15** | **结果** | **余数** |'
- en: '| --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 15 | 0 | 0 (trivial) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 0 | 0 （简单）|'
- en: '| 14 | 1 | 1 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 1 | 1 |'
- en: '| 13 | 1 | 2 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 1 | 2 |'
- en: '| 12 | 1 | 3 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 1 | 3 |'
- en: '| 11 | 1 | 4 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 1 | 4 |'
- en: '| 10 | 1 | 5 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1 | 5 |'
- en: '| 9 | 1 | 6 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 1 | 6 |'
- en: '| 8 | 1 | 7 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1 | 7 |'
- en: '| 7 | 2 | 1 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 2 | 1 |'
- en: '| 6 | 2 | 3 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 2 | 3 |'
- en: '| 5 | 3 | 0 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 3 | 0 |'
- en: '| 4 | 3 | 3 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 | 3 |'
- en: '| 3 | 5 | 0 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 5 | 0 |'
- en: '| 2 | 7 | 1 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 7 | 1 |'
- en: '| 1 | 15 | 0 (trivial) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 15 | 0 （简单）|'
- en: This is a one-way function. If I give you two prime numbers, you can easily
    multiply them together, although you might use a calculator if the numbers are
    large. The inverse of this function would mean starting with the product of two
    prime numbers and finding the two original primes. That’s considerably harder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单向函数。如果我给你两个质数，你可以轻松地将它们相乘，尽管如果数字很大，你可能需要使用计算器。这个函数的逆操作意味着从两个质数的积开始，找出原始的两个质数。这要困难得多。
- en: Let’s take 18,467 as an example. This number is indeed the product of two primes—but
    *which* two primes? To answer this question, you would need to divide 18,467 by
    every prime number starting from 2\. Eventually you would discover that 18,467
    divided by 59 is 313, which means that 59 and 313 are the two prime factors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 18,467 为例。这个数字确实是两个质数的积——但是 *是哪* 两个质数呢？要回答这个问题，你需要将 18,467 除以从 2 开始的每个质数。最终你会发现，18,467
    除以 59 得到 313，这意味着 59 和 313 是这两个质因数。
- en: Finding the prime factors is very difficult if all you have is the product.
    However, when you have the product and one of the two factors, finding the other
    factor is simple, because all you have to do is divide the first prime into the
    product. That makes it a trapdoor function—easy in one direction, hard in another
    unless you have the extra piece of information. If the prime numbers are large
    enough, finding the factors is infeasible without the trapdoor.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有积，找到质因数是非常困难的。然而，当你拥有积和其中一个因数时，找到另一个因数就很简单，因为你只需将第一个质数除以积。这使得它成为一种陷门函数——在一个方向上容易，在另一个方向上则很难，除非你有额外的信息。如果质数足够大，在没有陷门的情况下，找到因数几乎是不可能的。
- en: '**The RSA Encryption Method**'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**RSA 加密方法**'
- en: 'This trapdoor function is at the heart of the *RSA* public-key encryption system,
    named after the initials of its inventors: Rivest, Shamir, and Adleman. In actual
    practice, this system uses very large numbers to prevent a simple brute-force
    attack, but I’ll use small numbers in a simplified example to more easily demonstrate
    how it works.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种陷门函数是 *RSA* 公钥加密系统的核心，该系统以其发明者 Rivest、Shamir 和 Adleman 的首字母命名。在实际应用中，该系统使用非常大的数字来防止简单的暴力破解，但我会在一个简化的示例中使用小数字，以便更容易演示它是如何工作的。
- en: Suppose that siblings Zed and Abigail share a bank account but live apart. Zed
    has just changed the account’s four-digit PIN to 1482 and needs to send this new
    number to Abigail via email. Because email transmissions pass through many potentially
    insecure computers, the PIN must be encrypted in some way, but Zed and Abigail
    haven’t previously shared a cipher key that would allow the use of a method like
    AES. Instead, Zed will securely transmit the new PIN using RSA.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设兄妹 Zed 和 Abigail 共享一个银行账户，但他们住得分开。Zed 刚刚将账户的四位数字密码更改为 1482，并需要通过电子邮件将这个新号码发送给
    Abigail。由于电子邮件传输过程中可能经过许多不安全的计算机，因此必须以某种方式加密密码，但 Zed 和 Abigail 之前并未共享任何可以使用像 AES
    这样的加密方法的密码密钥。因此，Zed 将使用 RSA 安全地传输这个新密码。
- en: '***Creating the Keys***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建密钥***'
- en: Although Zed has the confidential data to transmit in this example, the RSA
    procedure begins with Abigail, who must produce a public key before Zed can encrypt
    the PIN.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个示例中Zed拥有机密数据需要传输，但RSA过程从Abigail开始，她必须生成公钥，然后Zed才能加密PIN码。
- en: '**Step 1**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 1**'
- en: Abigail begins by choosing two prime numbers; let’s say she chooses 97 and 113.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Abigail首先选择两个素数；假设她选择了97和113。
- en: '**Step 2**'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 2**'
- en: Abigail multiplies these two numbers together to get 10,961\. To keep things
    straight, I’ll call this number the *prime-product*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Abigail将这两个数字相乘得到10,961。为了清楚起见，我将这个数字称为*素数积*。
- en: '**Step 3**'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3**'
- en: Next Abigail must compute a *totient* (which is pronounced *TOE-shent*, to rhyme
    with *quotient*). For a number *N*, the totient is the amount of numbers that
    are less than *N* and coprime with *N*. For example, the number 15 is coprime
    with 1, 2, 4, 7, 8, 11, 13, or 14, as shown in [Figure 3-3](ch03.html#ch3fig3).
    Because there are eight numbers coprime with 15, the totient of 15 is 8.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Abigail必须计算*欧拉函数值*（发音为*TOE-shent*，与*quotient*押韵）。对于一个数字*N*，欧拉函数值是小于*N*并且与*N*互质的数字的数量。例如，数字15与1、2、4、7、8、11、13或14互质，如[图3-3](ch03.html#ch3fig3)所示。由于与15互质的数字有八个，因此15的欧拉函数值是8。
- en: '![image](graphics/f03-03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f03-03.jpg)'
- en: '*Figure 3-3: The eight circled numbers have no factors in common with 15\.
    Therefore the totient of 15 is 8.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-3：这八个圈出的数字与15没有共同因子。因此，15的欧拉函数值是8。*'
- en: 'Computing the totient of a number normally requires checking every smaller
    number for common factors, and therefore it’s a lot of work—for huge numbers,
    finding the totient is practically impossible. However, if the number in question
    is the product of two prime numbers, there’s a shortcut: simply subtract 1 from
    each of the two prime numbers and multiply the results together. For example,
    15 is the product of two primes, 3 and 5\. If we subtract 1 from each of the two
    primes, we get 2 and 4; if we multiply 2 and 4 we get 8, the totient of 15.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个数字的欧拉函数值通常需要检查所有小于该数字的数是否有共同因子，因此这是一个繁琐的过程——对于非常大的数字，计算欧拉函数几乎是不可能的。然而，如果该数字是两个素数的乘积，就有一个快捷方式：只需从这两个素数中各减去1，然后将结果相乘。例如，15是两个素数3和5的乘积。如果我们从这两个素数中各减去1，得到2和4；如果我们将2和4相乘，得到8，这是15的欧拉函数值。
- en: This shortcut greatly aids Abigail, whose next step is computing the totient
    of the prime-product, 10,961\. Since that is the product of the primes 97 and
    113, the totient of 10,961 is 96 × 112, or 10,752.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快捷方式极大地帮助了Abigail，她的下一步是计算素数积10,961的欧拉函数值。由于10,961是97和113的乘积，因此10,961的欧拉函数值是96
    × 112，即10,752。
- en: '**Step 4**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 4**'
- en: 'Now Abigail selects a number that meets the following criteria:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Abigail选择一个符合以下标准的数字：
- en: • Greater than 1
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: • 大于1
- en: • Less than the totient
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: • 小于欧拉函数值
- en: • Coprime with the totient
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: • 与欧拉函数值互质
- en: Let’s say she picks 5\. This is acceptable because it is greater than 1, it
    is less than 10,752, and there is no number other than 1 that divides both 5 and
    10,752\. Abigail is going to share this number with Zed, so we’ll call it the
    public key.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设她选择了5。这个选择是可以接受的，因为它大于1，小于10,752，并且除了1，没有其他数可以同时整除5和10,752。Abigail将与Zed共享这个数字，所以我们称之为公钥。
- en: '**Step 5**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 5**'
- en: The chosen public key determines Abigail’s private key, the number she has to
    keep secret. For any given public key and totient, there is just one number that
    can serve as the private key, and we can identify it by testing successive multiples
    of the totient. For each multiple, we add 1 and see if the result is divisible
    by the public key. When it is, the result of this division is the private key.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的公钥决定了Abigail的私钥，这是她需要保密的数字。对于给定的公钥和欧拉函数值，只有一个数字可以作为私钥，我们可以通过测试欧拉函数值的连续倍数来找到它。对于每个倍数，我们加1，看看结果是否能被公钥整除。当能整除时，除法的结果就是私钥。
- en: The process is demonstrated in [Table 3-3](ch03.html#ch3tab3). The first multiple
    of 10,752 is 10,752 itself; Abigail adds 1 to make 10,753, then divides by 5,
    getting 2,150 with a remainder of 3\. She tries the second multiple, 21,504, and
    when she adds 1 and divides by 5, she gets 4,301 and no remainder, so her private
    key is 4,301.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 过程在[表3-3](ch03.html#ch3tab3)中进行了演示。10,752的第一个倍数是10,752本身；Abigail加1得到10,753，然后用5除，得到商2,150，余数为3。她尝试第二个倍数21,504，加1后除以5，得到4,301且没有余数，因此她的私钥是4,301。
- en: '**Table 3-3:** Finding the Private Key'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-3：** 寻找私钥'
- en: '| **Multiple** | **Multiply by 10,752** | **Add 1** | **Divide by 5** | **Remainder**
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **倍数** | **乘以10,752** | **加1** | **除以5** | **余数** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | 10,752 | 10,753 | 2,150 | 3 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 10,752 | 10,753 | 2,150 | 3 |'
- en: '| 2 | 21,504 | 21,505 | 4,301 | 0 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 21,504 | 21,505 | 4,301 | 0 |'
- en: Of course, with larger numbers it may take a lot more multiples to find the
    private key, but there is always one number that will pass the test. The number
    of multiples tested will always be less than the public key (in our example, Abigail
    knows she’ll find the private key in four tries or less). In any case, now that
    Abigail has her private key, the actual encryption can begin.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用更大的数字可能需要更多的倍数来找到私钥，但总有一个数字会通过测试。测试的倍数总是小于公钥（在我们的例子中，Abigail 知道她最多四次尝试就能找到私钥）。无论如何，现在
    Abigail 已经得到了她的私钥，实际的加密过程可以开始了。
- en: '***Encrypting Data with RSA***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 RSA 加密数据***'
- en: Abigail emails both her prime-product (10,961) and public key (5) to Zed. Because
    these numbers don’t allow anyone to decrypt the resulting ciphertext, it doesn’t
    matter who else reads the email before it reaches Zed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Abigail 将她的素数积（10,961）和公钥（5）通过电子邮件发送给 Zed。因为这些数字无法让任何人解密生成的密文，所以在邮件到达 Zed 之前，其他人是否阅读邮件并不重要。
- en: The actual encryption of the new PIN takes just two steps.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 PIN 加密实际只需要两步。
- en: '**Step 1**'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 1**'
- en: 'Zed raises the PIN, 1,482, to the power of the public key, 5—that is, 1,482
    is multiplied by itself five times:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Zed 将 PIN 1,482 提升到公钥 5 的次方——也就是将 1,482 自己乘以五次：
- en: 1,482 × 1,482 × 1,482 × 1,482 × 1,482 = 7,148,929,565,430,432
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 1,482 × 1,482 × 1,482 × 1,482 × 1,482 = 7,148,929,565,430,432
- en: '**Step 2**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 2**'
- en: The second step is to find the remainder of dividing the result of step 1 by
    the prime-product. In this case, 10,961 goes into 7,148,929,565,430,432 about
    652 billion times, but all Zed cares about is that the remainder of that division
    is 2,122\. Zed sends this remainder to Abigail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是找出步骤 1 的结果除以素数积的余数。在这种情况下，10,961 可以进入 7,148,929,565,430,432 大约 652 亿次，但
    Zed 关心的只是那次除法的余数是 2,122。Zed 将这个余数发送给 Abigail。
- en: '**Step 3**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3**'
- en: On the receiving end, Abigail performs two similar steps to decrypt the ciphertext.
    She starts by raising the ciphertext number, 2,122, to the power of the private
    key, 4,301\. Because 2,122^(4,301) is enormous—over 14,000 digits—I won’t show
    it here.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收端，Abigail 执行两步类似的操作来解密密文。她首先将密文数字 2,122 提升到私钥 4,301 的次方。因为 2,122^(4,301)
    非常庞大——超过 14,000 位——我这里不展示它。
- en: '**Step 4**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 4**'
- en: Abigail finds the remainder of dividing the enormous number from step 3 by the
    prime-product. The remainder of that division is exactly 1,482, revealing Zed’s
    PIN.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Abigail 找到将步骤 3 中得到的巨大数字除以素数积的余数。这个余数正好是 1,482，揭示了 Zed 的 PIN。
- en: '***RSA Effectiveness***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RSA 的有效性***'
- en: Remember that the goal of RSA, like any encryption system, is making encryption
    easy, decryption easy for the intended recipient, and decryption very hard for
    anyone else. A summary of our RSA example is shown in [Figure 3-4](ch03.html#ch3fig4).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，RSA 的目标，像任何加密系统一样，是使加密简单，目标接收者的解密也简单，而其他人解密非常困难。我们 RSA 示例的总结见 [图 3-4](ch03.html#ch3fig4)。
- en: Even using much larger primes, encryption and authorized decryption are easy
    with the aid of the computer, as a review of the steps in our example will show.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用更大的素数，借助计算机，加密和授权解密也是简单的，回顾我们示例中的步骤就可以看出这一点。
- en: 1.   Abigail picked two prime numbers and multiplied them together to produce
    her *prime-product*. Multiplying two numbers together is easy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   Abigail 选择了两个素数并将它们相乘，得到了她的 *素数积*。相乘两个数字很容易。
- en: 2.   Abigail computed the *totient* of the prime-product by subtracting one
    from each of the two prime numbers before multiplying. Subtraction and multiplication
    are easy.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   Abigail 通过先从两个素数中每个减去 1 然后再相乘来计算 *欧拉函数*。减法和乘法很容易。
- en: 3.   Abigail chose a *public key*, a number that shares no factors with the
    totient. For large numbers, this would be impractical to find by hand, but for
    a computer, this is easy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   Abigail 选择了一个 *公钥*，这个数字与欧拉函数没有任何公因数。对于大数字来说，手工计算这个是不可行的，但对计算机来说，这是容易的。
- en: 4.   Abigail found the appropriate value for her *private key*, which should,
    when multiplied by the number chosen for her public key, produce a number that’s
    1 more than a multiple of the totient. This is a chore to do by hand, but for
    a computer, this too is easy.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   Abigail 找到了合适的 *私钥*，它应该在与她的公钥相乘时，得到一个比欧拉函数的倍数大 1 的数字。这手动计算很麻烦，但对计算机来说，这也是容易的。
- en: 5.   Abigail sent Zed the prime-product and public key.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   Abigail 发送了素数积和公钥给 Zed。
- en: 6.   Zed raised the PIN to the power of the public key. For a computer, this
    is relatively easy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 6.   Zed 将 PIN 提升到公钥的幂。对计算机来说，这是相对简单的。
- en: 7.   Zed divided the result from the previous step by the prime-product and
    took the remainder. Division is easy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 7.   Zed 将上一步的结果除以素数积并取余。除法很简单。
- en: 8.   Zed sent the remainder to Abigail.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 8.   Zed 将其余部分发送给了 Abigail。
- en: 9.   Abigail raised the number Zed sent to the power of the private key. Easy.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 9.   Abigail 将 Zed 发送的数字提升到私钥的幂。很简单。
- en: 10\. Abigail divided the result of the previous step by the prime-product and
    took the remainder, revealing Zed’s PIN. Easy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 10. Abigail 将前一步的结果除以素数积并取余，从而得出了 Zed 的 PIN。很简单。
- en: '![image](graphics/f03-04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f03-04.jpg)'
- en: '*Figure 3-4: A summary of the RSA example. The box in the middle shows Zed’s
    responsibilities; the rest are Abigail’s.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-4：RSA 示例的总结。中间的框显示了 Zed 的责任；其余的是 Abigail 的。*'
- en: RSA encryption and decryption by authorized parties is easy work for a computer,
    but unauthorized decryption is maddeningly difficult. To decrypt, an attacker
    must have both the prime-product, which Abigail gives out freely, and the private
    key, which she keeps to herself. How could an attacker compute the private key?
    Finding that number means first finding the totient of the prime-product, but
    remember, Abigail was only able to compute the totient quickly because she knows
    the two prime numbers that created the prime-product. Without those two prime
    numbers, an attacker must find the totient the hard way—by checking every number
    less than the prime-product to find all the coprimes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对授权方来说，RSA 加密和解密对于计算机而言是轻松的工作，但未经授权的解密则极其困难。要解密，攻击者必须同时拥有素数积（Abigail 会公开给出）和私钥（Abigail
    会自己保留）。那么攻击者如何计算私钥呢？找到这个数字意味着首先要找到素数积的欧拉函数，但请记住，Abigail 之所以能快速计算欧拉函数，是因为她知道生成素数积的两个质数。没有这两个质数，攻击者必须通过繁琐的方式来计算欧拉函数——检查所有小于素数积的数字，找到所有互质的数。
- en: In our example, the prime-product is small, so it’s feasible for a computer
    to find the totient in this brute-force manner. In actual practice, though, prime-products
    are huge, and finding their totients isn’t feasible at all. In fact, an attacker
    would be better off searching for the two primes that make the prime-product,
    to use the shortcut method of making the totient. That still requires checking
    all numbers up to the square root of the prime-product, though, so for large numbers
    this is as infeasible as finding the totient the long way.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，素数积很小，所以计算机以这种暴力方式找到欧拉函数是可行的。然而，实际上，素数积非常大，根本无法以这种方式找到其欧拉函数。事实上，攻击者更应该去寻找组成素数积的两个质数，利用捷径方法来计算欧拉函数。不过，这仍然需要检查所有小于素数积平方根的数字，所以对于大数字来说，这和通过繁琐方式找到欧拉函数一样不切实际。
- en: The RSA encryption method therefore creates our desired digital equivalent of
    a “lockbox.” Encryption and decryption no longer share the same secrets, so knowing
    how to lock the data doesn’t provide the ability to unlock it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RSA 加密方法创造了我们期望的数字“保险箱”对应物。加密和解密不再共享相同的秘密，所以知道如何锁定数据并不能提供解锁它的能力。
- en: '***RSA Use in the Real World***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RSA 在现实世界中的应用***'
- en: Our simplified example demonstrates the basics of RSA encryption, but for real-world
    use, we have to consider a few other details.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简化示例展示了 RSA 加密的基本原理，但在实际应用中，我们还需要考虑其他一些细节。
- en: '**Bidirectional Transmission**'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**双向传输**'
- en: The system shown in the example allows for Zed to securely transmit to Abigail,
    but not the other way around. If they wanted to send secure messages in either
    direction, Zed would have to go through all the steps that Abigail did, making
    his own prime-product, totient, public key, and private key, and sending the prime-product
    and public key to Abigail.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中展示的系统允许 Zed 安全地传输给 Abigail，但反过来则不行。如果他们想要双向传输安全信息，Zed 必须像 Abigail 那样，完成所有的步骤，生成自己的素数积、欧拉函数、公共密钥和私有密钥，并将素数积和公钥发送给
    Abigail。
- en: '**Key Size**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**密钥大小**'
- en: In RSA, the last step of either encryption or decryption is taking the remainder
    of division with the prime-product, which means the plaintext number must be less
    than the prime-product. In the example with Abigail and Zed, then, the largest
    possible plaintext number is 14,960\. That’s not a problem for Zed and his four-digit
    PIN, but for general use larger ranges are needed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在RSA中，加密或解密的最后一步是对素数乘积进行取余运算，这意味着明文数字必须小于素数乘积。在Abigail和Zed的示例中，最大的明文数字为14,960。这对Zed和他的四位数PIN码来说不是问题，但对于一般用途来说，需要更大的范围。
- en: Just as important, the larger the value of the prime-product, the more difficult
    it will be for an attacker to find the two prime factors. In other words, the
    size of the prime-product directly affects the security of encryption. In current
    practice, primes are chosen to produce a prime-product with a minimum of 1,024
    bits. As you may recall, the Advanced Encryption Standard described in [Chapter
    1](ch01.html#ch01) used only 128 or 256 bits for the key. So we are talking about
    a truly humongous number—1,024 bits is equivalent to a decimal number of over
    300 digits.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，素数乘积的值越大，攻击者找到两个素因子的难度就越大。换句话说，素数乘积的大小直接影响加密的安全性。在当前的实践中，选择素数以产生至少1024位的素数乘积。如你所记得，在[第一章](ch01.html#ch01)中描述的高级加密标准（AES）仅使用128或256位的密钥。所以我们讨论的是一个真正巨大的数字——1024位相当于一个超过300位的十进制数。
- en: '**Long Plaintexts and Performance**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**长明文与性能**'
- en: A 1,024-bit key allows the encryption of very large numbers. But a typical text,
    image, or audio file is a long series of small numbers, not one big number. How
    do we transmit a long series of numbers using RSA? With AES, long files would
    be chopped up into as many 128-bit blocks as necessary. In theory, we could do
    the same with RSA, chopping up files into a multitude of 1,024-bit blocks and
    applying RSA to each block. The problem is that RSA encryption is much slower
    than AES.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个1024位的密钥可以加密非常大的数字。但典型的文本、图像或音频文件是一长串小数字，而不是一个大数字。我们如何使用RSA传输一长串数字呢？对于AES，长文件会被切分成必要的多个128位块。在理论上，我们也可以用RSA做到这一点，将文件切分成多个1024位块，并对每个块应用RSA。问题在于RSA加密比AES慢得多。
- en: AES has more steps than the RSA Encryption Standard, but even so, AES is high-performance
    because the steps themselves are so simple. The most common operations are XOR
    and shifting bits around, and these operations are individually trivial. You can
    grasp this by working out the result of these operations in your head, as shown
    in [Figure 3-5](ch03.html#ch3fig5).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: AES的步骤比RSA加密标准多，但即便如此，AES的性能很高，因为这些步骤本身非常简单。最常见的操作是XOR和位移，这些操作本身非常简单。你可以通过在脑海中运算这些操作的结果来理解这一点，如[图3-5](ch03.html#ch3fig5)所示。
- en: '![image](graphics/f03-05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f03-05.jpg)'
- en: '*Figure 3-5: Computing XOR or rotating bits to new positions is easy.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-5：计算XOR或旋转位到新位置是很简单的。*'
- en: 'In contrast, the RSA process has only a few steps, but the reliance on exponentiation
    means more work overall. Consider a relatively small exponent: 17^(16). Written
    out, that’s ...'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，RSA过程只有几个步骤，但由于依赖指数运算，整体工作量较大。考虑一个相对较小的指数：17^(16)。写出来是……
- en: 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17
- en: Try working that out in your head, and you see the problem. Now imagine exponents
    involving numbers with hundreds of digits. Although a computer can handle these
    calculations, exponents are clearly a lot more work than simple XORs. Because
    exponents take so much time, using RSA for large amounts of data is impractical.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 试着在脑海中计算这个，你就能看出问题所在。现在，想象一下涉及数百位数字的指数。尽管计算机能够处理这些运算，但显然，指数运算要比简单的XOR运算费时得多。由于指数运算需要大量时间，使用RSA处理大量数据并不实际。
- en: '**Combining Systems**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**结合系统**'
- en: 'The solution to the RSA performance problem is simple: don’t transmit large
    amounts of data with RSA. Instead, use RSA to transmit an encryption key for another,
    faster method, such as AES.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解决RSA性能问题的方法很简单：不要使用RSA传输大量数据。相反，使用RSA传输另一个更快方法的加密密钥，例如AES。
- en: Returning to Abigail and Zed, suppose Zed needs to send Abigail a long document
    that he has already converted to a series of numbers using the ASCII table. Zed
    would prefer to encrypt the document using AES rather than take on the hard work
    of RSA. To use AES, though, Zed and Abigail would both need to share an AES encryption
    key. RSA provides the means to share that key safely. Zed can create the AES key
    himself, then encrypt it with RSA using Abigail’s public key. Then Zed can encrypt
    the long document using AES, and Abigail can decrypt the resulting ciphertext
    using the key they now share. This process is illustrated in [Figure 3-6](ch03.html#ch3fig6).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 Abigail 和 Zed，假设 Zed 需要向 Abigail 发送一份他已经用 ASCII 表将其转换为一系列数字的长文档。Zed 会更倾向于使用
    AES 加密该文档，而不是采用 RSA 的复杂工作。但要使用 AES，Zed 和 Abigail 都需要共享一个 AES 加密密钥。RSA 提供了安全共享该密钥的方法。Zed
    可以自己创建 AES 密钥，然后使用 Abigail 的公钥用 RSA 加密该密钥。然后 Zed 可以用 AES 加密长文档，Abigail 可以使用他们现在共享的密钥解密得到的密文。这个过程在[图
    3-6](ch03.html#ch3fig6)中得到了说明。
- en: '![image](graphics/f03-06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f03-06.jpg)'
- en: '*Figure 3-6: Combining RSA and AES to produce an asymmetric public-key system
    with high performance*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-6：结合 RSA 和 AES 以生成具有高性能的非对称公钥系统*'
- en: In this figure, the A-lock symbol means “encrypted with AES” while the R-lock
    means “encrypted with RSA.” By sending both the AES-encrypted document and the
    AES key encrypted with her public RSA key, Abigail has everything necessary to
    decrypt the document, but an attacker intercepting the transmission won’t be able
    to decrypt the document without Abigail’s private key.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，A 锁符号表示“用 AES 加密”，而 R 锁符号表示“用 RSA 加密”。通过发送 AES 加密的文档和用她的公钥 RSA 加密的 AES
    密钥，Abigail 拥有解密文档所需的一切，但拦截传输的攻击者无法在没有 Abigail 私钥的情况下解密文档。
- en: By combining the two encryption methods, we combine their strengths to get the
    high performance of AES and the shared keys of RSA. Public-key encryption is typically
    used this way, to initiate a symmetric-key encryption process that would otherwise
    be impossible.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这两种加密方法，我们将它们的优点结合在一起，获得 AES 的高性能和 RSA 的共享密钥。公钥加密通常以这种方式使用，用来启动一个本来无法实现的对称密钥加密过程。
- en: '***RSA for Authentication***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RSA 用于身份验证***'
- en: Public-key cryptography creates an authentication problem. Because the public
    key is just that—public—anyone can send an encrypted message to the private key
    owner; therefore, the recipient of a transmission cannot be certain of the sender’s
    identity. This problem doesn’t occur with symmetric-key encryption, because the
    secrecy of the one key, when it can be shared, ensures not only the security of
    the message but also that the message originated with the other person who has
    the key. Luckily, public-key cryptography can be also be used to authenticate.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密技术带来了身份验证问题。因为公钥本身就是公开的，任何人都可以向私钥持有者发送加密信息；因此，接收者无法确定发送者的身份。这一问题在对称密钥加密中不会出现，因为当一个密钥可以共享时，它的保密性不仅确保了信息的安全，还能确保信息来自于持有该密钥的另一方。幸运的是，公钥加密也可以用于身份验证。
- en: '**Authentication Using RSA**'
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 RSA 进行身份验证**'
- en: In our RSA example, Abigail has her prime-product of 10,961 and her private
    key of 4,301, while Zed has the prime-product and Abigail’s public key of 5\.
    This allows Zed to send a secure message to Abigail, but it also allows Abigail
    to send an authenticated message to Zed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 RSA 示例中，Abigail 拥有她的素因子积 10,961 和她的私钥 4,301，而 Zed 拥有素因子积和 Abigail 的公钥 5。这使得
    Zed 能够向 Abigail 发送安全信息，同时也使 Abigail 能够向 Zed 发送经过身份验证的信息。
- en: Suppose Abigail wants to send that same PIN, 1482, back to Zed to acknowledge
    its receipt, and in such a way that Zed can be sure the acknowledgment comes from
    Abigail.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Abigail 想要将相同的 PIN 码 1482 返回给 Zed，以确认已收到信息，并且以 Zed 能够确定该确认来自 Abigail 的方式发送。
- en: Abigail takes the PIN, 1,482, and raises it to the power of her private key
    (instead of the public key used for encryption). 1,482^(4,301) is another huge
    number—it has over 13,000 digits—so I’m not going to write it here, but when that
    huge number is divided by the prime-product of 10,961, the remainder is 8,742\.
    Abigail sends an email with that remainder to Zed. Zed now raises that 8,742 to
    the power of Abigail’s public key, 5, which results in 51,056,849,256,616,667,232\.
    Finally, Zed divides that number by the prime-product, getting a remainder of
    1,482\. Zed recognizes this number as the PIN, and knows it must have been transformed
    using Abigail’s private key, proving the number came from Abigail. The relationship
    between security and authentication in RSA is shown in [Figure 3-7](ch03.html#ch3fig7).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Abigail将PIN码1,482作为底数，提升到她的私钥的幂（而不是用于加密的公钥）。1,482^(4,301)是另一个巨大的数字——它有超过13,000位——所以我不打算在这里写出来，但当这个巨大的数字除以10,961的素数积时，余数是8,742。Abigail将这个余数通过电子邮件发送给Zed。Zed现在将8,742提升到Abigail的公钥5的幂，结果是51,056,849,256,616,667,232。最后，Zed将这个数字除以素数积，得到余数1,482。Zed认出这个数字是PIN码，并知道它一定是用Abigail的私钥进行转换的，从而证明这个数字来自Abigail。[RSA安全性与认证之间的关系](ch03.html#ch3fig7)如[图
    3-7](ch03.html#ch3fig7)所示。
- en: '![image](graphics/f03-07.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f03-07.jpg)'
- en: '*Figure 3-7: The RSA process provides either encryption or authentication.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-7：RSA过程提供加密或认证。*'
- en: We can authenticate entire files by applying this authentication process to
    the encryption key of a system like AES and sending the encrypted file and the
    authenticated key to the recipient.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将此认证过程应用于像AES这样的系统的加密密钥，来认证整个文件，并将加密文件和认证过的密钥一起发送给接收者。
- en: The RSA process can therefore produce an authenticated message *or* a secure
    message, depending on whether we encrypt with a private key or a public key. Ideally
    we’d like messages to be both authenticated and secure. We can accomplish this
    by applying both variations of the process to the same message. In our example,
    illustrated in [Figure 3-8](ch03.html#ch3fig8), Abigail could encrypt the number
    she wants to transmit with her private key, then encrypt the result with Zed’s
    public key. Upon receipt, Zed would reverse the procedures, first decrypting with
    his private key, then again with Abigail’s public key.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RSA过程可以生成经过认证的消息*或*安全的消息，具体取决于我们是使用私钥还是公钥进行加密。理想情况下，我们希望消息既能被认证又能保持安全。我们可以通过将该过程的两种变体应用于同一消息来实现这一目标。在我们的示例中，如[图
    3-8](ch03.html#ch3fig8)所示，Abigail可以用她的私钥加密她要传输的数字，然后用Zed的公钥对结果进行加密。收到后，Zed将逆转这些步骤，首先使用他的私钥解密，然后再次使用Abigail的公钥解密。
- en: '![image](graphics/f03-08.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f03-08.jpg)'
- en: '*Figure 3-8: Applying the RSA with the sender’s private key and the recipient’s
    public key provides authentication and security.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-8：使用发送者的私钥和接收者的公钥应用RSA提供认证和安全性。*'
- en: '**Identity Authorities**'
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**身份验证机构**'
- en: You may have noticed that authentication introduces a subtler version of the
    shared key problem. Zed knew the email came from Abigail because he recognized
    the PIN produced when he transformed the number using Abigail’s public key, which
    means the sender must have the matching private key. But if Zed is worried about
    someone pretending to be Abigail, how exactly does he know that the public key
    was sent by Abigail in the first place, not by an imposter who has hacked Abigail’s
    email account?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，认证引入了一种更微妙的共享密钥问题版本。Zed知道电子邮件来自Abigail，因为他认出了用Abigail的公钥转换该数字时产生的PIN码，这意味着发送者必须拥有匹配的私钥。但如果Zed担心有人冒充Abigail，他如何知道公钥最初是由Abigail发送的，而不是一个黑客入侵了Abigail的邮箱账号的冒名顶替者？
- en: The solution to this problem is an *authority*, a third party that helps verify
    identities. As you’ll see, authorities provide the digital equivalent of ID cards.
    When two computers initiate a secure, authenticated transmission through the exchange
    of public keys, they show their IDs, which assures each computer of the identity
    of the other. Of course, this assumes each computer trusts the authority providing
    the ID, so in the end, authentication requires having implicit faith in someone.
    One either trusts that the transmission comes from the entity that claims to have
    sent it, or one trusts some third party to identify the sender. Identity authorities
    form a crucial component of the ultimate subject of this chapter, web security.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案是一个*权威机构*，一个帮助验证身份的第三方。正如你将看到的，权威机构提供了数字等同于身份证的服务。当两台计算机通过交换公钥启动一个安全的、经过身份验证的传输时，它们会展示各自的身份证明，这样可以确保每台计算机知道对方的身份。当然，这假设每台计算机都信任提供身份验证的权威机构，所以最终，身份验证要求你对某个机构有隐性信任。你要么相信传输确实来自声称发送它的实体，要么相信某个第三方来识别发送者。身份认证权威是本章最终讨论主题——网络安全的一个至关重要的组成部分。
- en: '**Security on the Web: HTTPS**'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络安全：HTTPS**'
- en: Web pages are transferred using HTTP, which stands for *Hypertext Transfer Protocol*.
    When this data is transferred securely, it is called HTTPS, where the *S* stands
    for *secure*. This is why you’ll see *https* at the beginning of your browser’s
    address bar when you are transferring sensitive data—or I hope you do. Web security
    is something most people take for granted, but it’s an amazing feat to instantly
    create trust and security between two automated parties who may have just been
    introduced, requiring all the tricks and techniques you’ve seen so far.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 网页是通过HTTP传输的，HTTP代表*超文本传输协议*。当这些数据被安全传输时，它被称为HTTPS，其中*S*代表*安全*。这就是为什么当你在浏览器的地址栏中看到*https*时，表明你正在传输敏感数据——或者我希望你能看到。网络安全是大多数人认为理所当然的事情，但要在两个可能刚刚建立联系的自动化方之间立即建立信任和安全，这需要所有你已经看到的技巧和技术，真是一个了不起的成就。
- en: For this discussion, suppose you’re purchasing from a retail website using a
    computer or phone. In this scenario, your computer is known as the *client*. The
    computer running the website for the retailer is the *server*. This is the first
    time you’ve made a purchase from this retailer, so you have to provide shipping
    and billing information such as your address and credit card number. This situation
    cries out for security, but it requires authentication as well.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本讨论中，假设你正在通过计算机或手机从零售网站购买商品。在这种情况下，你的计算机被称为*客户端*。为零售商运行网站的计算机被称为*服务器*。这是你第一次从这家零售商购买商品，所以你必须提供送货和账单信息，比如你的地址和信用卡号。这个情况迫切需要安全保障，但它也需要身份验证。
- en: To see why, you have to remember that your computer is not directly connected
    to the server. Your data will be passed along from system to system, through computers
    managed by your Internet service provider (ISP) and those managed by the retailer’s
    ISP, and possibly through intermediate systems managed by neither. It’s possible
    for any of these systems to be compromised by attackers such that the infected
    system would intercept transmissions headed for the retailer, responding in its
    place. If this happens, when you place your order, you’re giving your data away
    to attackers, not to the retailer. Although the data is encrypted, it is encrypted
    with the key provided by the compromised system, so the encryption ensures only
    that no one else eavesdrops on the data you are sending to the attackers. This
    sort of impersonation is known as a *man-in-the-middle* attack, and is foiled
    by good authentication.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解其原因，你必须记住，计算机并没有直接连接到服务器。你的数据会通过你的互联网服务提供商（ISP）管理的计算机、零售商的ISP管理的计算机，甚至可能通过既不由两者管理的中介系统传递。任何这些系统都可能被攻击者攻破，从而感染系统并拦截原本要传输给零售商的数据，伪装成零售商进行响应。如果发生这种情况，当你下订单时，你实际上是把数据交给了攻击者，而不是零售商。虽然数据是加密的，但它是使用被感染系统提供的密钥加密的，因此加密只确保没有人窃听你发送给攻击者的数据。这种冒充身份的攻击被称为*中间人攻击*，而它可以通过良好的身份验证来防止。
- en: '***Handshaking***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***握手过程***'
- en: 'Secure transmission of data occurs in sessions. A *session* is the web equivalent
    of a phone call: an extended conversation that begins when you first load a page
    on a site and ends after you have not interacted with the site for some predetermined
    amount of time.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的安全传输是在会话中进行的。*会话*是网络中相当于电话通话的过程：当你第一次加载网站页面时开始，且在你一定时间内没有与网站互动时结束。
- en: Before the transmission can begin, your client and the server must successfully
    perform a ritual called *handshaking*. The name implies that it’s just two computers
    saying howdy, but it’s more like a tense scene in a crime show where one guy doesn’t
    want to show the “stuff” in the back of the van until the other guy shows the
    cash in the briefcase. The handshaking phase, if successful, authenticates the
    server to the client, and creates the key that will be used for encrypting the
    data throughout the session. As with Abigail and Zed, a public-key encryption
    system is used just long enough to share the keys needed for the better-performing
    private-key encryption system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输开始之前，客户端和服务器必须成功执行一个被称为*握手*的过程。这个名字意味着两台计算机仅仅是互相打个招呼，但实际上更像是一场犯罪剧中的紧张场面，一方不愿在另一方拿出公文包里的现金之前，展示面包车后面的“东西”。如果握手成功，客户端就能验证服务器身份，并生成将用于加密整个会话期间数据的密钥。与阿比盖尔和泽德的情况类似，公钥加密系统仅在足够的时间内用于交换所需的密钥，然后切换到性能更好的私钥加密系统。
- en: '**Step 1**'
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤1**'
- en: The client tells the server which encryption methods it supports. The HTTPS
    protocol allows computers to choose from a suite of acceptable methods for encryption,
    which means that different secure websites that you access may use different encryption
    techniques providing higher or lower levels of security. In addition to the encryption
    support information, the client also provides a randomly generated number—the
    purpose of which you’ll soon see.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端告知服务器其支持的加密方法。HTTPS协议允许计算机从一套可接受的加密方法中选择，这意味着不同的安全网站可能使用不同的加密技术，从而提供不同级别的安全性。除了加密支持信息外，客户端还会提供一个随机生成的数字——你很快就会看到这个数字的作用。
- en: '**Step 2**'
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤2**'
- en: The server responds with its own list of supported encryption methods and also
    its *certificate*. The server certificate contains several pieces of data, including
    the domain name of the site (such as [amazon.com](http://amazon.com)) and the
    name of the certificate *issuer* (the authority that will verify the site’s identity).
    It also contains the server’s public key. HTTPS can use several different public-key
    cryptographic systems, but RSA is common. The server uses the same certificate
    for every client it transacts with, so the public-and-private key pair only has
    to be created once for each certificate. Although this means the server uses the
    same RSA keys for all clients, as you’ll see, the RSA keys are used only during
    this handshaking phase.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器返回其支持的加密方法列表，并且还会返回其*证书*。该证书包含多个数据项，包括网站的域名（例如[amazon.com](http://amazon.com)）和证书*颁发机构*的名称（验证网站身份的权威机构）。证书中还包含服务器的公钥。HTTPS可以使用多种不同的公钥加密系统，但RSA是常见的。服务器对每个与其交易的客户端使用相同的证书，因此每个证书只需创建一次公私钥对。虽然这意味着服务器对所有客户端使用相同的RSA密钥，但正如你将看到的，RSA密钥只在握手阶段使用。
- en: The server certificate also contains a *signature*. As discussed in [Chapter
    2](ch02.html#ch02), digital signatures are hash codes. In this case, the server
    hashes the certificate data and encrypts the hash code using the server’s private
    key.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器证书还包含*签名*。正如在[第2章](ch02.html#ch02)中讨论的，数字签名是哈希码。在这种情况下，服务器对证书数据进行哈希处理，并使用服务器的私钥加密哈希码。
- en: In addition, the server also sends a random number to the client, just as the
    client has sent a random number to the server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，服务器还会向客户端发送一个随机数字，就像客户端向服务器发送了一个随机数字一样。
- en: '**Step 3**'
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤3**'
- en: The client validates the certificate. There are two aspects to the validation.
    First, the client applies the server’s public key to the hash code in the certificate,
    then hashes the certificate itself and compares the two hash codes. If the codes
    match, the certificate is internally valid, but it doesn’t prove this is the actual
    certificate for the site.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端验证证书。验证过程有两个方面。首先，客户端使用服务器的公钥对证书中的哈希码进行解密，然后对证书本身进行哈希处理，并比较两个哈希码。如果哈希码匹配，则证明证书在内部有效，但这并不意味着这是该站点的实际证书。
- en: Now the client must check with the issuer of the certificate, a certification
    authority with built-in trust with your browser. If you drill down into your browser’s
    options, you will find a list of issuers under a heading such as “Trusted root
    certification authorities.” The issuer provides a copy of the site’s certificate;
    when this matches the certificate provided by the server, the client is assured
    of the identity of the server.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端必须检查证书的颁发者，这个颁发者是与你的浏览器内建信任的认证机构。如果你深入浏览器的选项，你会发现一个名为“受信任的根证书颁发机构”的颁发者列表。颁发者提供站点证书的副本；当该证书与服务器提供的证书匹配时，客户端就能确认服务器的身份。
- en: '**Step 4**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤4**'
- en: The client generates another random number, 48 bytes long, or 384 bits, known
    as the *premaster secret*. As the name implies, this number must remain a secret.
    However, the client needs to send it to the server, so the client encrypts it
    using the server’s public key.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端生成另一个随机数，长度为48字节或384位，称为*预主密钥*。顾名思义，这个数字必须保持机密。然而，客户端需要将其发送给服务器，因此客户端使用服务器的公钥对其进行加密。
- en: '**Step 5**'
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤5**'
- en: The client and server independently create the 384-bit *master secret* by hashing
    a combination of the premaster secret and the two random numbers that were exchanged
    in the first two steps. Once the master secret is created, the premaster secret
    and the other two random numbers are discarded.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器通过对预主密钥和在前两个步骤中交换的两个随机数进行哈希运算，独立地生成384位的*主密钥*。一旦主密钥生成，预主密钥和其他两个随机数就会被丢弃。
- en: Note that the master secret is not exchanged between client and server. By this
    stage, both the client and the server have all the numbers needed to create the
    master secret. They independently run the numbers through the same process to
    produce the same result.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，主密钥并未在客户端和服务器之间交换。此时，客户端和服务器已经拥有创建主密钥所需的所有数字。它们独立地将这些数字通过相同的过程处理，以生成相同的结果。
- en: A summary of the handshaking process is shown in [Figure 3-9](ch03.html#ch3fig9).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 握手过程的总结如[图3-9](ch03.html#ch3fig9)所示。
- en: '![image](graphics/f03-09.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f03-09.jpg)'
- en: '*Figure 3-9: The HTTPS handshaking procedure*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-9：HTTPS握手过程*'
- en: '***Transmitting Data Under HTTPS***'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过HTTPS传输数据***'
- en: Now the client and server can begin sending actual data—web pages and media
    from the server, and user data from the client. The 384 bits of the master secret
    are divided into three 128-bit sections, each providing a different aspect of
    security.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端和服务器可以开始传输实际的数据——服务器的网页和媒体，以及客户端的用户数据。384位的主密钥被分成三个128位的部分，每部分提供不同的安全性。
- en: '**Data Encryption**'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**数据加密**'
- en: The first section of the master secret is used as the key for a private-key
    encryption system such as AES. Each of the subsequent data transmissions during
    the secure session will be encrypted using this cipher key.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 主密钥的第一部分被用作私钥加密系统（如AES）的密钥。在安全会话期间，后续的每次数据传输都将使用此密码密钥进行加密。
- en: '**Block Chaining**'
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**区块链**'
- en: Because web pages have standard header formats that could provide cribs to attackers,
    a method such as block chaining (discussed in [Chapter 1](ch01.html#ch01)) is
    employed. As you may recall, such systems need a starting value to encrypt the
    first block of the transmission; the middle 128-bit section of the master secret
    is used as this starting value.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网页具有标准的标题格式，这可能为攻击者提供线索，因此采用了诸如区块链（在[第1章](ch01.html#ch01)中讨论）等方法。正如你可能记得的那样，这种系统需要一个起始值来加密传输的第一个数据块；主密钥的中间128位部分被用作这个起始值。
- en: '**Message Authentication Code**'
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**消息认证码**'
- en: The final 128-bit section of the master secret is used to create a *message
    authentication code*, or *MAC*, for each transmission. In this case, we’re not
    trying to authenticate the identity of the sender—that was already handled in
    the handshaking phase. Instead, the MAC ensures that data isn’t altered during
    transmission.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 主密钥的最后128位部分用于为每次传输创建*消息认证码*，或*MAC*。在这种情况下，我们并不是要认证发送者的身份——这一点已经在握手阶段处理过了。相反，MAC确保数据在传输过程中没有被篡改。
- en: In this process, each transmission is hashed through a function like MD5, but
    first the transmission data is combined with the remaining 128-bit section of
    the master secret. This is known as *keyed hashing*, and the 128-bit section in
    this context is known as a *MAC key*. Using a keyed hash helps foil man-in-the-middle
    attacks. An attacker who wishes to pass a fake transmission to the receiver will
    need the MAC key to produce a hash code that will be accepted as genuine by the
    receiver.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，每个传输都会通过像MD5这样的函数进行哈希，但首先，传输数据会与主密钥剩余的128位部分组合。这被称为*带密钥哈希*，在这个上下文中，这128位部分被称为*MAC密钥*。使用带密钥的哈希有助于防止中间人攻击。一个希望向接收方传递伪造传输的攻击者需要MAC密钥来生成一个哈希值，使接收方接受这个哈希值为真实的。
- en: The hashing occurs before the encryption, so that both the original message
    and the hash code are encrypted.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希发生在加密之前，这样原始消息和哈希值都会被加密。
- en: '**The Shared Key Problem Solved?**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**共享密钥问题解决了吗？**'
- en: So that’s how data is securely transmitted over the Web. As you can see, solving
    the shared key problem requires just about every trick in the cryptography toolkit.
    Public-key encryption creates the secure channel for initial communications. Private-key
    encryption is used to secure individual transmissions of data. Hashing authenticates
    both the session and individual messages. If the site uses passwords to authenticate
    users, then all of the password techniques from [Chapter 2](ch02.html#ch02) would
    come into play as well.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是数据如何在 Web 上安全传输的方式。正如你所看到的，解决共享密钥问题几乎需要用到加密学工具包中的每一个技巧。公钥加密为初始通信创建了安全通道。私钥加密用于保护单独的数据传输。哈希算法验证了会话和单个消息的身份。如果网站使用密码来认证用户，那么[第二章](ch02.html#ch02)中的所有密码技术也会派上用场。
- en: 'Web security is a complex system of techniques. And therein lies a potential
    problem: the complexity of computer security can hide weaknesses. Just as a machine
    with more parts has more parts that can break down, the layering of so many intricate
    methods and techniques can mask undiscovered vulnerabilities. Sometimes the vulnerability
    is not within any one part, but in how the parts are connected. Although methods
    like RSA and AES are currently considered safe, clever attackers may find ways
    to break the security without breaking the underlying encryption methods.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Web安全是一个复杂的技术体系。正因如此，它也带来一个潜在的问题：计算机安全的复杂性可能掩盖了其中的弱点。就像一台部件更多的机器有更多部件可能出现故障一样，众多精细方法和技术的层叠也可能掩盖了尚未发现的漏洞。有时候，漏洞并非存在于某个单一部分，而是存在于各部分之间的连接方式。尽管像RSA和AES这样的算法目前被认为是安全的，但聪明的攻击者可能会找到方法，在不破坏底层加密方法的情况下突破安全。
- en: For example, earlier versions of HTTPS were vulnerable to a particular man-in-the-middle
    attack that arose from the observation that most secure sessions begin with a
    user clicking on a link. Suppose, for example, that you have received an email
    from the bank that issues your credit card with a link to your most recent account
    statement. The link is an HTTPS address, which means that when you click it, your
    browser will launch and request a secure connection with the bank’s server. However,
    this request itself is not secure. An attacker’s program could intercept this
    request and pass it along to the bank server as a request for a plain unencrypted
    HTTP connection, and then eavesdrop on all the unencrypted traffic that followed.
    The user might be tipped off by the prefix in the address bar, but how many users
    would think to check that? To cover this security hole, web servers can now tell
    browsers that all connections must be made through HTTPS—but that solution doesn’t
    foil an attacker who can intercept the announcement as well. The ultimate solution
    may be to require HTTPS for all web communications.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，HTTPS的早期版本曾易受到某种中间人攻击，这种攻击源于观察到大多数安全会话开始时，用户点击了一个链接。假设，例如，你收到了来自发行你信用卡的银行的一封邮件，里面有一个链接指向你最近的账户对账单。该链接是一个HTTPS地址，这意味着当你点击它时，你的浏览器会启动并请求与银行服务器建立安全连接。然而，这个请求本身并不安全。攻击者的程序可以拦截这个请求，并将其转发给银行服务器，作为一个普通的未加密HTTP连接请求，然后窃听所有随后的未加密流量。用户可能会通过地址栏中的前缀发现异常，但有多少用户会想到检查这一点呢？为了解决这个安全漏洞，Web服务器现在可以告知浏览器，所有连接必须通过HTTPS进行——但这个解决方案并不能防止一个能够拦截公告的攻击者。最终的解决方案可能是要求所有Web通信都必须使用HTTPS。
- en: Undoubtedly new vulnerabilities will be found in the future, requiring the invention
    of new defenses. Computer security is a moving target. We’ll never be able to
    declare our data entirely safe, but relying on best practices may keep us one
    step ahead of attackers.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，未来会发现新的漏洞，这需要发明新的防御措施。计算机安全是一个不断变化的目标。我们永远无法宣称我们的数据完全安全，但依靠最佳实践可能使我们始终领先一步，超越攻击者。
