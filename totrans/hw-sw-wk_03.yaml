- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Web Security**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may not have realized it before, but the Internet as we know it couldn’t
    exist without a solution to the shared key problem. Think about a typical situation:
    you’re buying something at an online retailer that you’ve never purchased from
    before. At some point you will be asked for your credit card data. Your browser
    tells you that your data is secure, perhaps by displaying a “lock” icon in the
    corner. But for the browser to protect your card number using AES, both your system
    and the retailer must use the same encryption key. How do two systems securely
    transmit data without getting together beforehand to exchange a key?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving this shared key problem is essential to providing any security on the
    Web. We’ll explore the solution to the shared key problem in this chapter, which
    uses all the techniques we’ve seen in the previous two chapters, plus a new special
    ingredient: public-key cryptography.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How Public-Key Cryptography Solves the Shared Key Problem**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the world of physical security, the shared key problem has a straightforward
    solution because locks and keys are two separate things. Suppose person A needs
    to ship confidential physical documents to person B. Person B could buy a strongbox
    and a keyed lock and then mail the box and lock to person A while keeping the
    key. Then person A puts the documents in the box, locks the box with B’s lock,
    and ships the box back to B. Because B has the only key to the lock, this is a
    secure delivery method.
  prefs: []
  type: TYPE_NORMAL
- en: This is the desired situation for transmitting data digitally as well. We need
    to separate the methods for locking and unlocking data, so that knowing how to
    encrypt data won’t provide the means to decrypt the resulting ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html#ch01), we learned about AES, which is a symmetric-key
    encryption method, meaning the same key is used for encryption and decryption.
    For transmission, we need an *asymmetric-key* encryption method, with one key
    for encryption and another key for decryption. The encryption key is known as
    the *public key*, because it can be freely distributed with no ill effects if
    it falls into the hands of an attacker; for this reason, asymmetric-key encryption
    is also known as *public-key cryptography*. The decryption key is known only to
    the recipient, so it’s known as the *private key*. These relationships are shown
    in [Figure 3-1](ch03.html#ch3fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Asymmetric-key encryption, with a public key for encryption and
    a private key for decryption. Only the receiver has the private key.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Math Tools for Public-Key Cryptography**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What public-key cryptography requires, then, is an encryption method that’s
    reversible but *not* with the cipher key that was used in the encryption. The
    basic tools of the encryption methods we’ve seen so far won’t work for public-key
    cryptography. The most common operation in AES, for example, is exclusive-or,
    which is used precisely because when something is XORed twice with the same binary
    number, you get the same number you started with. Reversible operations such as
    XOR inevitably lead to having the same key for encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: Public-key encryption, therefore, requires a new technique. As it turns out,
    the secrets to public-key encryption lie in the hidden relationships between numbers.
    In order to explain what those relationships are and how they can be exploited
    for cryptography, we need to go over a few pieces of math terminology.
  prefs: []
  type: TYPE_NORMAL
- en: '***Invertible Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Broadly stated, a *function* describes any situation where each numerical input
    results in a single numerical output. The current Celsius temperature, for example,
    is a function of the current Fahrenheit temperature. For any particular temperature
    in Fahrenheit degrees, there is exactly one matching temperature in Celsius degrees.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, the monetary value of a pile of coins is a function of the
    number of coins of each type. A pile containing three quarters, two nickels, a
    dime, and four pennies has a monetary value of 99 cents. This pile of coins cannot
    be worth any other amount.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes a function can be reversed to produce another function. If we know
    a temperature in degrees Fahrenheit, we also know it in degrees Celsius, and the
    reverse is true: if we know a temperature in Celsius, we can also figure it out
    in Fahrenheit. In mathematical terms, we would say that the Celsius-to-Fahrenheit
    function is the *inversion* of the Fahrenheit-to-Celsius function, and that the
    original function is *invertible*. The coin example, though, is not invertible.
    The same total monetary value can be produced by multiple combinations of coins.
    If the coins in my pocket are worth 99 cents, I might have three quarters, two
    nickels, a dime, and four pennies, or I might have nine dimes and nine pennies,
    or some other combination.'
  prefs: []
  type: TYPE_NORMAL
- en: '***One-Way Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For some invertible functions, computing in one direction may be a lot easier
    than the other. For example, the mathematical concepts of *square* and *square
    root* are complementary functions. Suppose you have a square room in your home
    that is covered in black-and-white tiles, as shown in [Figure 3-2](ch03.html#ch3fig2).
    To find the total surface area of the floor, you multiply 12 by 12 to get 144.
  prefs: []
  type: TYPE_NORMAL
- en: 'We say that 144 is the *square* of 12\. Going in the other direction, we say
    that 12 is the *square root* of 144\. These are both functions; each number has
    one square and one square root. The difficulty of computing these two functions
    is very different, though. Figuring out a number’s square is easy: you just multiply
    the number by itself. Figuring out the square root is hard. Unless you have a
    table of values to help you, computing a square root is effectively a trial-and-error
    process. You make a guess at what the root might be, multiply that guess by itself,
    see if your guess was too high or too low, and then adjust your next guess accordingly,
    repeating the process until you find the exact square root or get close enough
    that you are willing to stop. When a function is invertible but its inverse is
    much harder to compute, it is called a *one-way function*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: A square room with walls 12 feet long has a total area of 144
    feet.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Trapdoor Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Asymmetric encryption requires a one-way function so that the encryption key
    can be public—the encryption will be easy, but the decryption will be so hard
    as to be infeasible. The problem is, we shouldn’t make the decryption infeasible
    for the intended recipient as well. So any old one-way function isn’t going to
    do the trick. We need what’s known as a *trapdoor function*, a one-way function
    where the inverse function is hard in general, but easy when some secret value
    is known.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prime Numbers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The particular trapdoor function we’ll discuss involves prime numbers. A number
    is *prime* if it is greater than 1 and can only be divided (without a remainder)
    by itself and 1\. For example, 5 is prime because it can be divided only by itself
    and 1\. It cannot be evenly divided into 2, 3, or 4 parts. The number 6, though,
    can be divided by 2 and 3 in addition to 1 and itself. It is therefore a nonprime,
    or *composite*, number. Smaller numbers that divide into a larger number are known
    as the larger number’s *factors*. Every number is divisible by itself and by 1,
    but we call these *trivial factors* and tend to ignore them when discussing factors.
    A prime number has only trivial factors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Coprime Numbers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In a related concept, two numbers are said to be *coprime* if they share only
    1 as a factor. Either number may or may not be prime itself, but each can be thought
    of as prime as far as the other number knows. For example, the composite numbers
    9 and 4 are coprime because there is no number that divides them both except for
    1\. In contrast, 6 isn’t coprime with either 9 or 4, because 6 shares factors
    with both. These relationships are demonstrated in [Table 3-1](ch03.html#ch3tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Showing that 9 and 4 Are Coprime, but 6 Is Not Coprime with
    9 or 4'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Divisor** | **Remainder from 9** | **Remainder from 6** | **Remainder from
    4** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | (trivial) |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 1 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 2 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 3 | (trivial) |  |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 4 | 1 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1 | 2 | (trivial) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | (trivial) | (trivial) | (trivial) |'
  prefs: []
  type: TYPE_TB
- en: Although 1 is not a prime number, it’s considered to be coprime with every other
    number.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prime Factors**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now we are getting close to the hidden relationships that make public-key encryption
    work. If we multiply two prime numbers, the resulting product has only those two
    prime numbers as factors (again, not counting itself and 1). For example, 5 and
    3 are prime numbers. The product of 3 and 5 is 15, and 15 has only 3 and 5 as
    factors, as shown in [Table 3-2](ch03.html#ch3tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** The Product of Prime Numbers 3 and 5 Is 15, and 15 Has Only
    3 and 5 as Factors'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Divide 15 by** | **Result** | **Remainder** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 0 | 0 (trivial) |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 1 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 1 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 1 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 3 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 5 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 7 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 15 | 0 (trivial) |'
  prefs: []
  type: TYPE_TB
- en: This is a one-way function. If I give you two prime numbers, you can easily
    multiply them together, although you might use a calculator if the numbers are
    large. The inverse of this function would mean starting with the product of two
    prime numbers and finding the two original primes. That’s considerably harder.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take 18,467 as an example. This number is indeed the product of two primes—but
    *which* two primes? To answer this question, you would need to divide 18,467 by
    every prime number starting from 2\. Eventually you would discover that 18,467
    divided by 59 is 313, which means that 59 and 313 are the two prime factors.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the prime factors is very difficult if all you have is the product.
    However, when you have the product and one of the two factors, finding the other
    factor is simple, because all you have to do is divide the first prime into the
    product. That makes it a trapdoor function—easy in one direction, hard in another
    unless you have the extra piece of information. If the prime numbers are large
    enough, finding the factors is infeasible without the trapdoor.
  prefs: []
  type: TYPE_NORMAL
- en: '**The RSA Encryption Method**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This trapdoor function is at the heart of the *RSA* public-key encryption system,
    named after the initials of its inventors: Rivest, Shamir, and Adleman. In actual
    practice, this system uses very large numbers to prevent a simple brute-force
    attack, but I’ll use small numbers in a simplified example to more easily demonstrate
    how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that siblings Zed and Abigail share a bank account but live apart. Zed
    has just changed the account’s four-digit PIN to 1482 and needs to send this new
    number to Abigail via email. Because email transmissions pass through many potentially
    insecure computers, the PIN must be encrypted in some way, but Zed and Abigail
    haven’t previously shared a cipher key that would allow the use of a method like
    AES. Instead, Zed will securely transmit the new PIN using RSA.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating the Keys***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although Zed has the confidential data to transmit in this example, the RSA
    procedure begins with Abigail, who must produce a public key before Zed can encrypt
    the PIN.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Abigail begins by choosing two prime numbers; let’s say she chooses 97 and 113.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Abigail multiplies these two numbers together to get 10,961\. To keep things
    straight, I’ll call this number the *prime-product*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Next Abigail must compute a *totient* (which is pronounced *TOE-shent*, to rhyme
    with *quotient*). For a number *N*, the totient is the amount of numbers that
    are less than *N* and coprime with *N*. For example, the number 15 is coprime
    with 1, 2, 4, 7, 8, 11, 13, or 14, as shown in [Figure 3-3](ch03.html#ch3fig3).
    Because there are eight numbers coprime with 15, the totient of 15 is 8.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: The eight circled numbers have no factors in common with 15\.
    Therefore the totient of 15 is 8.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Computing the totient of a number normally requires checking every smaller
    number for common factors, and therefore it’s a lot of work—for huge numbers,
    finding the totient is practically impossible. However, if the number in question
    is the product of two prime numbers, there’s a shortcut: simply subtract 1 from
    each of the two prime numbers and multiply the results together. For example,
    15 is the product of two primes, 3 and 5\. If we subtract 1 from each of the two
    primes, we get 2 and 4; if we multiply 2 and 4 we get 8, the totient of 15.'
  prefs: []
  type: TYPE_NORMAL
- en: This shortcut greatly aids Abigail, whose next step is computing the totient
    of the prime-product, 10,961\. Since that is the product of the primes 97 and
    113, the totient of 10,961 is 96 × 112, or 10,752.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now Abigail selects a number that meets the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: • Greater than 1
  prefs: []
  type: TYPE_NORMAL
- en: • Less than the totient
  prefs: []
  type: TYPE_NORMAL
- en: • Coprime with the totient
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say she picks 5\. This is acceptable because it is greater than 1, it
    is less than 10,752, and there is no number other than 1 that divides both 5 and
    10,752\. Abigail is going to share this number with Zed, so we’ll call it the
    public key.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The chosen public key determines Abigail’s private key, the number she has to
    keep secret. For any given public key and totient, there is just one number that
    can serve as the private key, and we can identify it by testing successive multiples
    of the totient. For each multiple, we add 1 and see if the result is divisible
    by the public key. When it is, the result of this division is the private key.
  prefs: []
  type: TYPE_NORMAL
- en: The process is demonstrated in [Table 3-3](ch03.html#ch3tab3). The first multiple
    of 10,752 is 10,752 itself; Abigail adds 1 to make 10,753, then divides by 5,
    getting 2,150 with a remainder of 3\. She tries the second multiple, 21,504, and
    when she adds 1 and divides by 5, she gets 4,301 and no remainder, so her private
    key is 4,301.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-3:** Finding the Private Key'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Multiple** | **Multiply by 10,752** | **Add 1** | **Divide by 5** | **Remainder**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 10,752 | 10,753 | 2,150 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 21,504 | 21,505 | 4,301 | 0 |'
  prefs: []
  type: TYPE_TB
- en: Of course, with larger numbers it may take a lot more multiples to find the
    private key, but there is always one number that will pass the test. The number
    of multiples tested will always be less than the public key (in our example, Abigail
    knows she’ll find the private key in four tries or less). In any case, now that
    Abigail has her private key, the actual encryption can begin.
  prefs: []
  type: TYPE_NORMAL
- en: '***Encrypting Data with RSA***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Abigail emails both her prime-product (10,961) and public key (5) to Zed. Because
    these numbers don’t allow anyone to decrypt the resulting ciphertext, it doesn’t
    matter who else reads the email before it reaches Zed.
  prefs: []
  type: TYPE_NORMAL
- en: The actual encryption of the new PIN takes just two steps.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Zed raises the PIN, 1,482, to the power of the public key, 5—that is, 1,482
    is multiplied by itself five times:'
  prefs: []
  type: TYPE_NORMAL
- en: 1,482 × 1,482 × 1,482 × 1,482 × 1,482 = 7,148,929,565,430,432
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The second step is to find the remainder of dividing the result of step 1 by
    the prime-product. In this case, 10,961 goes into 7,148,929,565,430,432 about
    652 billion times, but all Zed cares about is that the remainder of that division
    is 2,122\. Zed sends this remainder to Abigail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: On the receiving end, Abigail performs two similar steps to decrypt the ciphertext.
    She starts by raising the ciphertext number, 2,122, to the power of the private
    key, 4,301\. Because 2,122^(4,301) is enormous—over 14,000 digits—I won’t show
    it here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Abigail finds the remainder of dividing the enormous number from step 3 by the
    prime-product. The remainder of that division is exactly 1,482, revealing Zed’s
    PIN.
  prefs: []
  type: TYPE_NORMAL
- en: '***RSA Effectiveness***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember that the goal of RSA, like any encryption system, is making encryption
    easy, decryption easy for the intended recipient, and decryption very hard for
    anyone else. A summary of our RSA example is shown in [Figure 3-4](ch03.html#ch3fig4).
  prefs: []
  type: TYPE_NORMAL
- en: Even using much larger primes, encryption and authorized decryption are easy
    with the aid of the computer, as a review of the steps in our example will show.
  prefs: []
  type: TYPE_NORMAL
- en: 1.   Abigail picked two prime numbers and multiplied them together to produce
    her *prime-product*. Multiplying two numbers together is easy.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Abigail computed the *totient* of the prime-product by subtracting one
    from each of the two prime numbers before multiplying. Subtraction and multiplication
    are easy.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Abigail chose a *public key*, a number that shares no factors with the
    totient. For large numbers, this would be impractical to find by hand, but for
    a computer, this is easy.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Abigail found the appropriate value for her *private key*, which should,
    when multiplied by the number chosen for her public key, produce a number that’s
    1 more than a multiple of the totient. This is a chore to do by hand, but for
    a computer, this too is easy.
  prefs: []
  type: TYPE_NORMAL
- en: 5.   Abigail sent Zed the prime-product and public key.
  prefs: []
  type: TYPE_NORMAL
- en: 6.   Zed raised the PIN to the power of the public key. For a computer, this
    is relatively easy.
  prefs: []
  type: TYPE_NORMAL
- en: 7.   Zed divided the result from the previous step by the prime-product and
    took the remainder. Division is easy.
  prefs: []
  type: TYPE_NORMAL
- en: 8.   Zed sent the remainder to Abigail.
  prefs: []
  type: TYPE_NORMAL
- en: 9.   Abigail raised the number Zed sent to the power of the private key. Easy.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Abigail divided the result of the previous step by the prime-product and
    took the remainder, revealing Zed’s PIN. Easy.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: A summary of the RSA example. The box in the middle shows Zed’s
    responsibilities; the rest are Abigail’s.*'
  prefs: []
  type: TYPE_NORMAL
- en: RSA encryption and decryption by authorized parties is easy work for a computer,
    but unauthorized decryption is maddeningly difficult. To decrypt, an attacker
    must have both the prime-product, which Abigail gives out freely, and the private
    key, which she keeps to herself. How could an attacker compute the private key?
    Finding that number means first finding the totient of the prime-product, but
    remember, Abigail was only able to compute the totient quickly because she knows
    the two prime numbers that created the prime-product. Without those two prime
    numbers, an attacker must find the totient the hard way—by checking every number
    less than the prime-product to find all the coprimes.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the prime-product is small, so it’s feasible for a computer
    to find the totient in this brute-force manner. In actual practice, though, prime-products
    are huge, and finding their totients isn’t feasible at all. In fact, an attacker
    would be better off searching for the two primes that make the prime-product,
    to use the shortcut method of making the totient. That still requires checking
    all numbers up to the square root of the prime-product, though, so for large numbers
    this is as infeasible as finding the totient the long way.
  prefs: []
  type: TYPE_NORMAL
- en: The RSA encryption method therefore creates our desired digital equivalent of
    a “lockbox.” Encryption and decryption no longer share the same secrets, so knowing
    how to lock the data doesn’t provide the ability to unlock it.
  prefs: []
  type: TYPE_NORMAL
- en: '***RSA Use in the Real World***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our simplified example demonstrates the basics of RSA encryption, but for real-world
    use, we have to consider a few other details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bidirectional Transmission**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The system shown in the example allows for Zed to securely transmit to Abigail,
    but not the other way around. If they wanted to send secure messages in either
    direction, Zed would have to go through all the steps that Abigail did, making
    his own prime-product, totient, public key, and private key, and sending the prime-product
    and public key to Abigail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Size**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In RSA, the last step of either encryption or decryption is taking the remainder
    of division with the prime-product, which means the plaintext number must be less
    than the prime-product. In the example with Abigail and Zed, then, the largest
    possible plaintext number is 14,960\. That’s not a problem for Zed and his four-digit
    PIN, but for general use larger ranges are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Just as important, the larger the value of the prime-product, the more difficult
    it will be for an attacker to find the two prime factors. In other words, the
    size of the prime-product directly affects the security of encryption. In current
    practice, primes are chosen to produce a prime-product with a minimum of 1,024
    bits. As you may recall, the Advanced Encryption Standard described in [Chapter
    1](ch01.html#ch01) used only 128 or 256 bits for the key. So we are talking about
    a truly humongous number—1,024 bits is equivalent to a decimal number of over
    300 digits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Long Plaintexts and Performance**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A 1,024-bit key allows the encryption of very large numbers. But a typical text,
    image, or audio file is a long series of small numbers, not one big number. How
    do we transmit a long series of numbers using RSA? With AES, long files would
    be chopped up into as many 128-bit blocks as necessary. In theory, we could do
    the same with RSA, chopping up files into a multitude of 1,024-bit blocks and
    applying RSA to each block. The problem is that RSA encryption is much slower
    than AES.
  prefs: []
  type: TYPE_NORMAL
- en: AES has more steps than the RSA Encryption Standard, but even so, AES is high-performance
    because the steps themselves are so simple. The most common operations are XOR
    and shifting bits around, and these operations are individually trivial. You can
    grasp this by working out the result of these operations in your head, as shown
    in [Figure 3-5](ch03.html#ch3fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: Computing XOR or rotating bits to new positions is easy.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, the RSA process has only a few steps, but the reliance on exponentiation
    means more work overall. Consider a relatively small exponent: 17^(16). Written
    out, that’s ...'
  prefs: []
  type: TYPE_NORMAL
- en: 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17 × 17
  prefs: []
  type: TYPE_NORMAL
- en: Try working that out in your head, and you see the problem. Now imagine exponents
    involving numbers with hundreds of digits. Although a computer can handle these
    calculations, exponents are clearly a lot more work than simple XORs. Because
    exponents take so much time, using RSA for large amounts of data is impractical.
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining Systems**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The solution to the RSA performance problem is simple: don’t transmit large
    amounts of data with RSA. Instead, use RSA to transmit an encryption key for another,
    faster method, such as AES.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning to Abigail and Zed, suppose Zed needs to send Abigail a long document
    that he has already converted to a series of numbers using the ASCII table. Zed
    would prefer to encrypt the document using AES rather than take on the hard work
    of RSA. To use AES, though, Zed and Abigail would both need to share an AES encryption
    key. RSA provides the means to share that key safely. Zed can create the AES key
    himself, then encrypt it with RSA using Abigail’s public key. Then Zed can encrypt
    the long document using AES, and Abigail can decrypt the resulting ciphertext
    using the key they now share. This process is illustrated in [Figure 3-6](ch03.html#ch3fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-6: Combining RSA and AES to produce an asymmetric public-key system
    with high performance*'
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the A-lock symbol means “encrypted with AES” while the R-lock
    means “encrypted with RSA.” By sending both the AES-encrypted document and the
    AES key encrypted with her public RSA key, Abigail has everything necessary to
    decrypt the document, but an attacker intercepting the transmission won’t be able
    to decrypt the document without Abigail’s private key.
  prefs: []
  type: TYPE_NORMAL
- en: By combining the two encryption methods, we combine their strengths to get the
    high performance of AES and the shared keys of RSA. Public-key encryption is typically
    used this way, to initiate a symmetric-key encryption process that would otherwise
    be impossible.
  prefs: []
  type: TYPE_NORMAL
- en: '***RSA for Authentication***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Public-key cryptography creates an authentication problem. Because the public
    key is just that—public—anyone can send an encrypted message to the private key
    owner; therefore, the recipient of a transmission cannot be certain of the sender’s
    identity. This problem doesn’t occur with symmetric-key encryption, because the
    secrecy of the one key, when it can be shared, ensures not only the security of
    the message but also that the message originated with the other person who has
    the key. Luckily, public-key cryptography can be also be used to authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication Using RSA**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In our RSA example, Abigail has her prime-product of 10,961 and her private
    key of 4,301, while Zed has the prime-product and Abigail’s public key of 5\.
    This allows Zed to send a secure message to Abigail, but it also allows Abigail
    to send an authenticated message to Zed.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose Abigail wants to send that same PIN, 1482, back to Zed to acknowledge
    its receipt, and in such a way that Zed can be sure the acknowledgment comes from
    Abigail.
  prefs: []
  type: TYPE_NORMAL
- en: Abigail takes the PIN, 1,482, and raises it to the power of her private key
    (instead of the public key used for encryption). 1,482^(4,301) is another huge
    number—it has over 13,000 digits—so I’m not going to write it here, but when that
    huge number is divided by the prime-product of 10,961, the remainder is 8,742\.
    Abigail sends an email with that remainder to Zed. Zed now raises that 8,742 to
    the power of Abigail’s public key, 5, which results in 51,056,849,256,616,667,232\.
    Finally, Zed divides that number by the prime-product, getting a remainder of
    1,482\. Zed recognizes this number as the PIN, and knows it must have been transformed
    using Abigail’s private key, proving the number came from Abigail. The relationship
    between security and authentication in RSA is shown in [Figure 3-7](ch03.html#ch3fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-7: The RSA process provides either encryption or authentication.*'
  prefs: []
  type: TYPE_NORMAL
- en: We can authenticate entire files by applying this authentication process to
    the encryption key of a system like AES and sending the encrypted file and the
    authenticated key to the recipient.
  prefs: []
  type: TYPE_NORMAL
- en: The RSA process can therefore produce an authenticated message *or* a secure
    message, depending on whether we encrypt with a private key or a public key. Ideally
    we’d like messages to be both authenticated and secure. We can accomplish this
    by applying both variations of the process to the same message. In our example,
    illustrated in [Figure 3-8](ch03.html#ch3fig8), Abigail could encrypt the number
    she wants to transmit with her private key, then encrypt the result with Zed’s
    public key. Upon receipt, Zed would reverse the procedures, first decrypting with
    his private key, then again with Abigail’s public key.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-8: Applying the RSA with the sender’s private key and the recipient’s
    public key provides authentication and security.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity Authorities**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You may have noticed that authentication introduces a subtler version of the
    shared key problem. Zed knew the email came from Abigail because he recognized
    the PIN produced when he transformed the number using Abigail’s public key, which
    means the sender must have the matching private key. But if Zed is worried about
    someone pretending to be Abigail, how exactly does he know that the public key
    was sent by Abigail in the first place, not by an imposter who has hacked Abigail’s
    email account?
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is an *authority*, a third party that helps verify
    identities. As you’ll see, authorities provide the digital equivalent of ID cards.
    When two computers initiate a secure, authenticated transmission through the exchange
    of public keys, they show their IDs, which assures each computer of the identity
    of the other. Of course, this assumes each computer trusts the authority providing
    the ID, so in the end, authentication requires having implicit faith in someone.
    One either trusts that the transmission comes from the entity that claims to have
    sent it, or one trusts some third party to identify the sender. Identity authorities
    form a crucial component of the ultimate subject of this chapter, web security.
  prefs: []
  type: TYPE_NORMAL
- en: '**Security on the Web: HTTPS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web pages are transferred using HTTP, which stands for *Hypertext Transfer Protocol*.
    When this data is transferred securely, it is called HTTPS, where the *S* stands
    for *secure*. This is why you’ll see *https* at the beginning of your browser’s
    address bar when you are transferring sensitive data—or I hope you do. Web security
    is something most people take for granted, but it’s an amazing feat to instantly
    create trust and security between two automated parties who may have just been
    introduced, requiring all the tricks and techniques you’ve seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: For this discussion, suppose you’re purchasing from a retail website using a
    computer or phone. In this scenario, your computer is known as the *client*. The
    computer running the website for the retailer is the *server*. This is the first
    time you’ve made a purchase from this retailer, so you have to provide shipping
    and billing information such as your address and credit card number. This situation
    cries out for security, but it requires authentication as well.
  prefs: []
  type: TYPE_NORMAL
- en: To see why, you have to remember that your computer is not directly connected
    to the server. Your data will be passed along from system to system, through computers
    managed by your Internet service provider (ISP) and those managed by the retailer’s
    ISP, and possibly through intermediate systems managed by neither. It’s possible
    for any of these systems to be compromised by attackers such that the infected
    system would intercept transmissions headed for the retailer, responding in its
    place. If this happens, when you place your order, you’re giving your data away
    to attackers, not to the retailer. Although the data is encrypted, it is encrypted
    with the key provided by the compromised system, so the encryption ensures only
    that no one else eavesdrops on the data you are sending to the attackers. This
    sort of impersonation is known as a *man-in-the-middle* attack, and is foiled
    by good authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '***Handshaking***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Secure transmission of data occurs in sessions. A *session* is the web equivalent
    of a phone call: an extended conversation that begins when you first load a page
    on a site and ends after you have not interacted with the site for some predetermined
    amount of time.'
  prefs: []
  type: TYPE_NORMAL
- en: Before the transmission can begin, your client and the server must successfully
    perform a ritual called *handshaking*. The name implies that it’s just two computers
    saying howdy, but it’s more like a tense scene in a crime show where one guy doesn’t
    want to show the “stuff” in the back of the van until the other guy shows the
    cash in the briefcase. The handshaking phase, if successful, authenticates the
    server to the client, and creates the key that will be used for encrypting the
    data throughout the session. As with Abigail and Zed, a public-key encryption
    system is used just long enough to share the keys needed for the better-performing
    private-key encryption system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The client tells the server which encryption methods it supports. The HTTPS
    protocol allows computers to choose from a suite of acceptable methods for encryption,
    which means that different secure websites that you access may use different encryption
    techniques providing higher or lower levels of security. In addition to the encryption
    support information, the client also provides a randomly generated number—the
    purpose of which you’ll soon see.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The server responds with its own list of supported encryption methods and also
    its *certificate*. The server certificate contains several pieces of data, including
    the domain name of the site (such as [amazon.com](http://amazon.com)) and the
    name of the certificate *issuer* (the authority that will verify the site’s identity).
    It also contains the server’s public key. HTTPS can use several different public-key
    cryptographic systems, but RSA is common. The server uses the same certificate
    for every client it transacts with, so the public-and-private key pair only has
    to be created once for each certificate. Although this means the server uses the
    same RSA keys for all clients, as you’ll see, the RSA keys are used only during
    this handshaking phase.
  prefs: []
  type: TYPE_NORMAL
- en: The server certificate also contains a *signature*. As discussed in [Chapter
    2](ch02.html#ch02), digital signatures are hash codes. In this case, the server
    hashes the certificate data and encrypts the hash code using the server’s private
    key.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the server also sends a random number to the client, just as the
    client has sent a random number to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 3**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The client validates the certificate. There are two aspects to the validation.
    First, the client applies the server’s public key to the hash code in the certificate,
    then hashes the certificate itself and compares the two hash codes. If the codes
    match, the certificate is internally valid, but it doesn’t prove this is the actual
    certificate for the site.
  prefs: []
  type: TYPE_NORMAL
- en: Now the client must check with the issuer of the certificate, a certification
    authority with built-in trust with your browser. If you drill down into your browser’s
    options, you will find a list of issuers under a heading such as “Trusted root
    certification authorities.” The issuer provides a copy of the site’s certificate;
    when this matches the certificate provided by the server, the client is assured
    of the identity of the server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The client generates another random number, 48 bytes long, or 384 bits, known
    as the *premaster secret*. As the name implies, this number must remain a secret.
    However, the client needs to send it to the server, so the client encrypts it
    using the server’s public key.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 5**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The client and server independently create the 384-bit *master secret* by hashing
    a combination of the premaster secret and the two random numbers that were exchanged
    in the first two steps. Once the master secret is created, the premaster secret
    and the other two random numbers are discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the master secret is not exchanged between client and server. By this
    stage, both the client and the server have all the numbers needed to create the
    master secret. They independently run the numbers through the same process to
    produce the same result.
  prefs: []
  type: TYPE_NORMAL
- en: A summary of the handshaking process is shown in [Figure 3-9](ch03.html#ch3fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-9: The HTTPS handshaking procedure*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Transmitting Data Under HTTPS***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now the client and server can begin sending actual data—web pages and media
    from the server, and user data from the client. The 384 bits of the master secret
    are divided into three 128-bit sections, each providing a different aspect of
    security.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Encryption**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first section of the master secret is used as the key for a private-key
    encryption system such as AES. Each of the subsequent data transmissions during
    the secure session will be encrypted using this cipher key.
  prefs: []
  type: TYPE_NORMAL
- en: '**Block Chaining**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Because web pages have standard header formats that could provide cribs to attackers,
    a method such as block chaining (discussed in [Chapter 1](ch01.html#ch01)) is
    employed. As you may recall, such systems need a starting value to encrypt the
    first block of the transmission; the middle 128-bit section of the master secret
    is used as this starting value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Message Authentication Code**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final 128-bit section of the master secret is used to create a *message
    authentication code*, or *MAC*, for each transmission. In this case, we’re not
    trying to authenticate the identity of the sender—that was already handled in
    the handshaking phase. Instead, the MAC ensures that data isn’t altered during
    transmission.
  prefs: []
  type: TYPE_NORMAL
- en: In this process, each transmission is hashed through a function like MD5, but
    first the transmission data is combined with the remaining 128-bit section of
    the master secret. This is known as *keyed hashing*, and the 128-bit section in
    this context is known as a *MAC key*. Using a keyed hash helps foil man-in-the-middle
    attacks. An attacker who wishes to pass a fake transmission to the receiver will
    need the MAC key to produce a hash code that will be accepted as genuine by the
    receiver.
  prefs: []
  type: TYPE_NORMAL
- en: The hashing occurs before the encryption, so that both the original message
    and the hash code are encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Shared Key Problem Solved?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So that’s how data is securely transmitted over the Web. As you can see, solving
    the shared key problem requires just about every trick in the cryptography toolkit.
    Public-key encryption creates the secure channel for initial communications. Private-key
    encryption is used to secure individual transmissions of data. Hashing authenticates
    both the session and individual messages. If the site uses passwords to authenticate
    users, then all of the password techniques from [Chapter 2](ch02.html#ch02) would
    come into play as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web security is a complex system of techniques. And therein lies a potential
    problem: the complexity of computer security can hide weaknesses. Just as a machine
    with more parts has more parts that can break down, the layering of so many intricate
    methods and techniques can mask undiscovered vulnerabilities. Sometimes the vulnerability
    is not within any one part, but in how the parts are connected. Although methods
    like RSA and AES are currently considered safe, clever attackers may find ways
    to break the security without breaking the underlying encryption methods.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, earlier versions of HTTPS were vulnerable to a particular man-in-the-middle
    attack that arose from the observation that most secure sessions begin with a
    user clicking on a link. Suppose, for example, that you have received an email
    from the bank that issues your credit card with a link to your most recent account
    statement. The link is an HTTPS address, which means that when you click it, your
    browser will launch and request a secure connection with the bank’s server. However,
    this request itself is not secure. An attacker’s program could intercept this
    request and pass it along to the bank server as a request for a plain unencrypted
    HTTP connection, and then eavesdrop on all the unencrypted traffic that followed.
    The user might be tipped off by the prefix in the address bar, but how many users
    would think to check that? To cover this security hole, web servers can now tell
    browsers that all connections must be made through HTTPS—but that solution doesn’t
    foil an attacker who can intercept the announcement as well. The ultimate solution
    may be to require HTTPS for all web communications.
  prefs: []
  type: TYPE_NORMAL
- en: Undoubtedly new vulnerabilities will be found in the future, requiring the invention
    of new defenses. Computer security is a moving target. We’ll never be able to
    declare our data entirely safe, but relying on best practices may keep us one
    step ahead of attackers.
  prefs: []
  type: TYPE_NORMAL
