- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5'
- en: SWARM OPTIMIZATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 群体优化**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Swarm techniques do more than optimize mathematical functions. In this chapter,
    we’ll use randomness to pack circles in a square, place cell towers, enhance images,
    and organize product placement at the grocery store. We’ll apply the same collection
    of swarm intelligence and evolutionary algorithms as in the previous chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 群体技术不仅仅用于优化数学函数。在本章中，我们将使用随机性来将圆形填充到正方形中，布置基站，增强图像，以及组织超市的商品陈列。我们将应用与上一章相同的群体智能和进化算法集。
- en: '**Packing Circles in a Square**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在正方形中填充圆**'
- en: A classic math problem involves packing equal diameter circles in a square.
    An equivalent formulation is to locate, for a given number of points, positions
    in the unit square ([0, 1]) where the smallest distance between any pair of points
    is as large as possible. The point locations correspond to the centers of the
    best-packed circles. For example, where in the unit square do we put two points
    to maximize the distance between them? In opposite corners. In that case, the
    distance between the points is ![Image](../images/f0137-01.jpg), and it can’t
    be any larger.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的数学问题涉及将相同直径的圆放入一个正方形。等价的表述是，对于给定数量的点，找到单位正方形（[0, 1]）中位置，使得任意两点之间的最小距离尽可能大。这些点的位置对应于最佳填充圆的圆心。例如，在哪个位置放置两个点，才能使它们之间的距离最大？在对角的两个角落。此时，点之间的距离是
    ![Image](../images/f0137-01.jpg)，而且无法再更大。
- en: 'What about three points? Four points? Seventeen points? Now the answer isn’t
    so obvious. We might approach this problem by using the elaborate algorithm detailed
    in Locatelli and Raber’s 2002 paper, “Packing Equal Circles in a Square: A Deterministic
    Global Optimization Approach,” but that’s not how we’ll do it here. Instead, we’ll
    use randomness in the form of a swarm search. We need to map positions in some
    multidimensional space to candidate solutions and then search this space for the
    best possible solution.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么三个点呢？四个点呢？十七个点呢？现在答案就不那么明显了。我们可能会采用 Locatelli 和 Raber 在 2002 年的论文《在正方形中填充相同大小的圆：一种确定性全局优化方法》中详细描述的复杂算法来处理这个问题，但我们在这里不会这样做。相反，我们将使用群体搜索中的随机性。我们需要将某个多维空间中的位置映射到候选解，然后在这个空间中搜索最佳解。
- en: 'If we have *n* points and want to know the coordinates of *n* circle centers
    that are, for each pair, as far apart as possible while still within [0, 1], we
    need to find *n* points. At first, we might believe we have an *n*-dimensional
    problem. However, the dimensionality is actually 2*n*: we need both the *x*- and
    *y*-coordinates to specify a point. We know the search’s bounds are [0, 1] for
    each dimension. Therefore, we’ll use swarms that are 2*n*-dimensional vectors
    bounded by [0, 1] where each pair of components is a point, (*x*, *y*). In other
    words, if we want to find five points, each particle is a 10-element vector:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有 *n* 个点，并且想要知道 *n* 个圆心的坐标，这些圆心之间的每一对距离尽可能远，同时仍在 [0, 1] 范围内，我们需要找到 *n* 个点。刚开始时，我们可能认为这是一个
    *n* 维的问题。然而，实际的维度是 2*n*：我们需要 *x* 和 *y* 坐标来确定一个点。我们知道搜索的边界是每个维度都在 [0, 1] 之间。因此，我们将使用由
    [0, 1] 限制的 2*n* 维向量来表示粒子，其中每一对组件是一个点，(*x*, *y*)。换句话说，如果我们要找五个点，每个粒子就是一个 10 元素的向量：
- en: '***p*** = (*x*[0], *y*[0]; *x*[1], *y*[1]; *x*[2], *y*[2]; *x*[3], *y*[3];
    *x*[4], *y*[4])'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '***p*** = (*x*[0], *y*[0]; *x*[1], *y*[1]; *x*[2], *y*[2]; *x*[3], *y*[3];
    *x*[4], *y*[4])'
- en: 'To run a search, we need the dimensionality of the problem and the bounds,
    both of which we now have. The only remaining issue is the objective function,
    which tells us how good a solution each particle position represents. The problem
    specification lights the way: we need to maximize the smallest distance between
    any pair of points. If there are five points, we calculate the distance between
    each possible pair, find which distance is the smallest, and return the opposite.
    Our framework only minimizes, so to maximize, we return the negative. The largest
    smallest distance between pairs, when made negative, becomes the most negative
    number.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行搜索，我们需要问题的维度和界限，我们现在已经有了这两个信息。唯一剩下的问题是目标函数，它告诉我们每个粒子位置所代表的解有多好。问题的描述为我们指引了方向：我们需要最大化任意两点之间的最小距离。如果有五个点，我们计算每一对可能的点之间的距离，找出最小的那个距离，然后返回相反值。我们的框架只支持最小化，因此为了最大化，我们返回负值。将对的最小距离变为负数后，它就变成了最负的数。
- en: '***The Swarm Search***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***群体搜索***'
- en: 'The code we want is in *circles.py*. Consider putting the book down and reading
    through the file to understand the flow. Once you’ve done that, we can begin with
    the objective function class:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的代码在 *circles.py* 中。考虑放下书本，通读一下文件以理解代码流程。理解之后，我们就可以从目标函数类开始：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The constructor does nothing more than initialize `fcount`, which counts the
    number of times `Evaluate` is called. The `Evaluate` method is given a position
    vector (`p`) that is immediately reshaped into a set of (*x*, *y*) pairs (`xy`).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数只是初始化 `fcount`，它用来统计 `Evaluate` 被调用的次数。`Evaluate` 方法接收一个位置向量（`p`），它立即被重塑为一组
    (*x*, *y*) 对（`xy`）。
- en: The second code paragraph in `Evaluate` runs through each pairing of points
    in `xy` and calculates the Euclidean distance between them. If that distance is
    the smallest found so far, we keep it in `dmin`. We want to maximize the smallest
    distance between any pair of points, so we first find the smallest distance between
    any two points represented by the particle position.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evaluate` 中的第二段代码会遍历 `xy` 中每一对点，并计算它们之间的欧几里得距离。如果该距离是目前找到的最小距离，我们就将其保存在 `dmin`
    中。我们希望最大化任意两点之间的最小距离，因此我们首先找到粒子位置表示的任意两点之间的最小距离。'
- en: The final line returns the negative of `dmin`. Because the framework minimizes,
    returning the negative of the smallest pairwise distance forces the framework
    to *maximize* this smallest distance—exactly what we want.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行返回 `dmin` 的负值。由于框架是为了最小化而设计的，返回最小的成对距离的负值就迫使框架*最大化*这个最小距离——这正是我们想要的。
- en: We now have everything we need to implement the search. The main body of *circles.py*
    follows the standard approach of pulling values off the command line and setting
    up the framework objects before calling `Optimize` to execute the search.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经具备了实现搜索所需的一切。*circles.py* 的主体遵循标准方法，从命令行获取值并设置框架对象，然后调用 `Optimize` 执行搜索。
- en: 'In code, the essential steps are:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，主要步骤如下：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We create the desired randomness engine, followed by the bounds, initializer,
    and objective function instance. Notice that the objective function requires no
    ancillary information.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了所需的随机引擎，接着是边界、初始化器和目标函数实例。请注意，目标函数不需要任何附加信息。
- en: The `swarm` object, `PSO` configured for bare-bones searching, is followed by
    `Optimize` and `Results`. Not shown is code to report the best set of points and
    the distance between them before dumping all search results, including a simple
    plot of the point locations, into the supplied output directory.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`swarm` 对象，配置为基础的 `PSO` 搜索，后面跟着 `Optimize` 和 `Results`。没有显示的是报告最佳点集及其之间距离的代码，然后将所有搜索结果（包括点的位置简单图示）转储到提供的输出目录。'
- en: Try running *circles.py* with no command line options to see what it expects.
    Now that we have it, let’s use it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在没有命令行选项的情况下运行 *circles.py*，看看它期望什么。现在我们已经准备好了，就来使用它吧。
- en: '***The Code***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'Let’s pack some circles. I created two shell scripts, *go_circle_results* and
    *go_plots*. The former runs *circles.py* for 2 through 20 circles and 7 algorithms:
    bare-bones PSO, canonical PSO, DE, GWO, Jaya, RO, and GA. The output is stored
    in the *results* directory. I recommend starting it in the evening and coming
    back the next morning, as the framework is designed for clarity, not speed. Run
    it with:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来打包一些圆圈。我创建了两个 Shell 脚本，*go_circle_results* 和 *go_plots*。前者运行 *circles.py*，用于
    2 到 20 个圆圈和 7 种算法：基础的 PSO、标准 PSO、DE、GWO、Jaya、RO 和 GA。输出结果存储在 *results* 目录中。我建议你在晚上启动它，第二天早上再回来查看，因为这个框架是为了清晰设计的，而非速度。用以下命令运行：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When *go_circle_results* finishes, execute *go_plots* to produce a series of
    plots showing the circle configuration each algorithm located. My results from
    this exercise are in [Table 5-1](ch05.xhtml#ch05tab01), though yours will be somewhat
    different due to the stochastic nature of the swarm searches.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *go_circle_results* 完成后，执行 *go_plots* 来生成一系列图表，显示每个算法定位的圆圈配置。我的结果在 [表 5-1](ch05.xhtml#ch05tab01)
    中，不过由于群体搜索的随机性，你的结果会有所不同。
- en: '**Table 5-1:** Largest Center Distance, Known and as Found by Each Algorithm'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1：** 每个算法已知和找到的最大中心距离'
- en: '| ***n*** | **Known** | **Bare** | **DE** | **PSO** | **GWO** | **Jaya** |
    **RO** | **GA** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| ***n*** | **已知** | **基础** | **DE** | **PSO** | **GWO** | **Jaya** | **RO**
    | **GA** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 2 | 1.4142 | 1.4142 | 1.4142 | 1.4142 | 1.4142 | 1.4142 | 1.4142 | 1.4134
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1.4142 | 1.4142 | 1.4142 | 1.4142 | 1.4142 | 1.4142 | 1.4142 | 1.4134
    |'
- en: '| 3 | 1.0353 | 1.0353 | 1.0353 | 1.0353 | 1.0353 | 1.0353 | 1.0301 | 1.0264
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1.0353 | 1.0353 | 1.0353 | 1.0353 | 1.0353 | 1.0353 | 1.0301 | 1.0264
    |'
- en: '| 4 | 1.0000 | 1.0000 | 1.0000 | 1.0000 | 1.0000 | 1.0000 | 0.9998 | 0.9969
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1.0000 | 1.0000 | 1.0000 | 1.0000 | 1.0000 | 1.0000 | 0.9998 | 0.9969
    |'
- en: '| 5 | 0.7071 | 0.7071 | 0.7070 | 0.6250 | 0.7025 | 0.7071 | 0.6796 | 0.6052
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0.7071 | 0.7071 | 0.7070 | 0.6250 | 0.7025 | 0.7071 | 0.6796 | 0.6052
    |'
- en: '| 6 | 0.6009 | 0.5951 | 0.5953 | 0.5995 | 0.5988 | 0.5858 | 0.5723 | 0.5884
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0.6009 | 0.5951 | 0.5953 | 0.5995 | 0.5988 | 0.5858 | 0.5723 | 0.5884
    |'
- en: '| 7 | 0.5359 | 0.5359 | 0.5223 | 0.5000 | 0.5072 | 0.5176 | 0.5000 | 0.4843
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 0.5359 | 0.5359 | 0.5223 | 0.5000 | 0.5072 | 0.5176 | 0.5000 | 0.4843
    |'
- en: '| 8 | 0.5176 | 0.5090 | 0.5045 | 0.5000 | 0.5002 | 0.4801 | 0.4661 | 0.4355
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 0.5176 | 0.5090 | 0.5045 | 0.5000 | 0.5002 | 0.4801 | 0.4661 | 0.4355
    |'
- en: '| 9 | 0.5000 | 0.5000 | 0.4202 | 0.5000 | 0.4798 | 0.5000 | 0.4421 | 0.4470
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 0.5000 | 0.5000 | 0.4202 | 0.5000 | 0.4798 | 0.5000 | 0.4421 | 0.4470
    |'
- en: '| 10 | 0.4213 | 0.4147 | 0.3697 | 0.4195 | 0.4187 | 0.3517 | 0.3788 | 0.3819
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 0.4213 | 0.4147 | 0.3697 | 0.4195 | 0.4187 | 0.3517 | 0.3788 | 0.3819
    |'
- en: '| 11 | 0.3980 | 0.3978 | 0.3296 | 0.3694 | 0.3895 | 0.3918 | 0.3588 | 0.3787
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 0.3980 | 0.3978 | 0.3296 | 0.3694 | 0.3895 | 0.3918 | 0.3588 | 0.3787
    |'
- en: '| 12 | 0.3887 | 0.3726 | 0.2989 | 0.3717 | 0.3289 | 0.3819 | 0.3496 | 0.3542
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 0.3887 | 0.3726 | 0.2989 | 0.3717 | 0.3289 | 0.3819 | 0.3496 | 0.3542
    |'
- en: '| 13 | 0.3660 | 0.3595 | 0.2752 | 0.3333 | 0.3277 | 0.2832 | 0.3212 | 0.3230
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 0.3660 | 0.3595 | 0.2752 | 0.3333 | 0.3277 | 0.2832 | 0.3212 | 0.3230
    |'
- en: '| 14 | 0.3451 | 0.3354 | 0.2537 | 0.3333 | 0.3116 | 0.3435 | 0.3037 | 0.3204
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 0.3451 | 0.3354 | 0.2537 | 0.3333 | 0.3116 | 0.3435 | 0.3037 | 0.3204
    |'
- en: '| 15 | 0.3372 | 0.3256 | 0.2303 | 0.3333 | 0.3278 | 0.2437 | 0.2949 | 0.2995
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 0.3372 | 0.3256 | 0.2303 | 0.3333 | 0.3278 | 0.2437 | 0.2949 | 0.2995
    |'
- en: '| 16 | 0.3333 | 0.2996 | 0.2269 | 0.2500 | 0.3011 | 0.2220 | 0.2760 | 0.2761
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 0.3333 | 0.2996 | 0.2269 | 0.2500 | 0.3011 | 0.2220 | 0.2760 | 0.2761
    |'
- en: '| 17 | 0.3060 | 0.2985 | 0.2062 | 0.2913 | 0.2952 | 0.1992 | 0.2658 | 0.2721
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 0.3060 | 0.2985 | 0.2062 | 0.2913 | 0.2952 | 0.1992 | 0.2658 | 0.2721
    |'
- en: '| 18 | 0.3005 | 0.2782 | 0.1927 | 0.2808 | 0.2703 | 0.2126 | 0.2516 | 0.2493
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 0.3005 | 0.2782 | 0.1927 | 0.2808 | 0.2703 | 0.2126 | 0.2516 | 0.2493
    |'
- en: '| 19 | 0.2900 | 0.2697 | 0.1852 | 0.2500 | 0.1905 | 0.1731 | 0.2384 | 0.2559
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 0.2900 | 0.2697 | 0.1852 | 0.2500 | 0.1905 | 0.1731 | 0.2384 | 0.2559
    |'
- en: '| 20 | 0.2866 | 0.2632 | 0.1789 | 0.2500 | 0.2419 | 0.1659 | 0.2200 | 0.2342
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 0.2866 | 0.2632 | 0.1789 | 0.2500 | 0.2419 | 0.1659 | 0.2200 | 0.2342
    |'
- en: '[Table 5-1](ch05.xhtml#ch05tab01) shows the best-known distance between the
    points and the distance found by the swarm searches, by algorithm. These numbers
    will be our gold standard.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5-1](ch05.xhtml#ch05tab01) 显示了点之间的已知最佳距离以及群体搜索得到的距离，按算法分类。这些数值将成为我们的黄金标准。'
- en: For *n* < 10, many of the distances are known from geometric arguments, as [Table
    5-2](ch05.xhtml#ch05tab02) shows.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *n* < 10，许多距离可以通过几何推导得到，正如 [表 5-2](ch05.xhtml#ch05tab02) 所示。
- en: '**Table 5-2:** Known Circle Center Distances'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-2：** 已知圆心距离'
- en: '| ***n*** | **Distance** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| ***n*** | **距离** |'
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2 | ![Image](../images/f0140-01.jpg) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 2 | ![Image](../images/f0140-01.jpg) |'
- en: '| 3 | ![Image](../images/f0140-02.jpg) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 3 | ![Image](../images/f0140-02.jpg) |'
- en: '| 4 | 1 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1 |'
- en: '| 5 | ![Image](../images/f0140-03.jpg) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 5 | ![Image](../images/f0140-03.jpg) |'
- en: '| 6 | ![Image](../images/f0140-04.jpg) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 6 | ![Image](../images/f0140-04.jpg) |'
- en: '| 7 | ![Image](../images/f0140-05.jpg) |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 7 | ![Image](../images/f0140-05.jpg) |'
- en: '| 8 | ![Image](../images/f0140-06.jpg) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 8 | ![Image](../images/f0140-06.jpg) |'
- en: '| 9 | 0.5 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 0.5 |'
- en: '| 10 | 0.42127954 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 0.42127954 |'
- en: The expressions come from Table D1 in *Unsolved Problems in Geometry* by Croft,
    Falconer, and Guy (Springer, 1991). The *plot_results.py* file, called by *go_plots*,
    uses this table to generate plots showing the packed circles. If the packing is
    optimal, the circles barely touch. Otherwise, the circles are separated from each
    other or overlap.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式来自 Croft、Falconer 和 Guy 的《几何中的未解问题》（Springer，1991年）中的表 D1。由 *go_plots*
    调用的 *plot_results.py* 文件使用该表生成显示打包圆形的图表。如果打包是最优的，圆形几乎不会接触。否则，圆形之间会有间隙或重叠。
- en: Examining [Table 5-1](ch05.xhtml#ch05tab01) reveals 2 through 4 circles to be
    straightforward; every algorithm located the best arrangement. For 5 circles,
    bare-bones PSO, DE, and Jaya converged on the solution. We won’t quibble about
    the one-ten-thousandth difference between the known distance and differential
    evolution’s solution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 [表 5-1](ch05.xhtml#ch05tab01) 可以发现 2 到 4 个圆是直接的；每个算法都找到了最佳排列。对于 5 个圆，基本的
    PSO、DE 和 Jaya 都达到了收敛解。我们不会在已知距离与差分进化解之间的一万分之一的差异上争辩。
- en: The swarms begin to struggle after 5 circles. For 6 circles, no swarm nails
    the distance, at least to four decimals, but several come pretty close. [Figure
    5-1](ch05.xhtml#ch05fig01) shows the output plots for each algorithm.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 群体在 5 个圆之后开始出现问题。对于 6 个圆，虽然没有任何群体精确到四位小数，但有几个方法非常接近。 [图 5-1](ch05.xhtml#ch05fig01)展示了每个算法的输出图表。
- en: '![Image](../images/05fig01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig01.jpg)'
- en: '*Figure 5-1: Packing 6 circles. From top left to right: PSO, GWO, DE, bare-bones
    PSO, GA, RO, and Jaya.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1: 打包6个圆圈。从左上到右：PSO，GWO，DE，简化版PSO，GA，RO和Jaya。*'
- en: While solutions are unique regarding the distance between the circle centers,
    they aren’t in terms of rotations. The canonical PSO, DE, and GWO results are
    essentially the same, only rotated by 90 degrees in some cases.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管解决方案在圆心距离方面是独特的，但在旋转方面并不独特。标准的PSO、DE和GWO结果本质上是相同的，只是在某些情况下旋转了90度。
- en: View all graphs generated by *go_plots* by the number of circles. As *n* increases,
    the swarms struggle more and more, but there are nice *n* values, like *n* = 9,
    where the swarms are more likely to arrive at the highly symmetric solution. Since
    we’re packing a square, it makes sense that *n* values that are perfect squares—like
    4, 9, and 16—lead to nicely aligned packings. However, only a few algorithms located
    the ideal *n* = 9 output, and none found the best *n* = 16 outcome.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过圆圈的数量查看*go_plots*生成的所有图形。随着*n*的增大，群体越发挣扎，但仍然有一些不错的*n*值，例如*n* = 9，在这种情况下群体更有可能找到高度对称的解决方案。由于我们在打包一个正方形，*n*的值是完全平方数—如4、9和16—因此可以得到对齐良好的打包。然而，只有少数算法找到了理想的*n*
    = 9输出，且没有任何算法找出最好的*n* = 16结果。
- en: Let’s move on to a more practical problem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续解决一个更实际的问题。
- en: '**Placing Cell Towers**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**放置手机塔**'
- en: Placing a cell phone tower is not an academic exercise; real utility and cost
    are involved. In this section we’ll experiment with a (simplified) cell tower
    placement problem.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 放置手机塔并非一种学术练习；涉及到实际的效用和成本。在这一部分，我们将实验一个（简化版的）手机塔位置问题。
- en: Our inputs are a collection of cell towers, each with a different effective
    range, and a mask showing where cell towers can be placed. The output is a collection
    of locations where the specified towers should be placed to maximize coverage.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输入是一组手机塔，每个塔有不同的有效范围，以及一张显示手机塔可以放置位置的掩膜。输出是一个位置集合，指示应该放置指定塔的位置以最大化覆盖范围。
- en: The code we’ll work with is in *cell.py*. It has the same general structure
    as the other swarm experiments, but is slightly more advanced because evaluating
    a particle position involves checking for illegal tower positions and building
    an image. The `Evaluate` method of the objective function class is more complex,
    but still accepts a particle position and returns a score where lower implies
    a better solution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的代码在*cell.py*中。它与其他群体实验的结构相同，但稍微更高级，因为评估粒子位置需要检查是否存在非法的塔位置并构建图像。目标函数类的`Evaluate`方法更为复杂，但仍然接受一个粒子位置并返回一个评分，较低的评分意味着更好的解决方案。
- en: I’ll lay out the plan of attack; then we’ll walk through the essential parts
    of the code before running some experiments.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我将概述攻击计划；然后我们将逐步浏览代码的关键部分，再进行一些实验。
- en: '***The Swarm Search***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***群体搜索***'
- en: We need to translate vectors of numbers within some bounds into possible solutions.
    We’ll work with cell towers and maps telling us where we can place them. Let’s
    begin with representing towers and maps.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将一定范围内的数字向量转换为可能的解决方案。我们将使用手机塔和地图，告诉我们可以在哪里放置这些塔。让我们从表示塔和地图开始。
- en: The cell towers radiate in all directions, so we’ll represent them as circles
    where the diameter of the circle indicates the tower’s strength and the center
    of the circle the tower’s location. Not all towers are of equal strength. We specify
    a tower with a single floating-point number in (0, 1]; exactly how will become
    clear momentarily.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 手机塔向所有方向辐射，因此我们将它们表示为圆圈，圆的直径表示塔的强度，圆心表示塔的位置。并非所有塔的强度都相同。我们用一个(0, 1]范围内的浮动数值来指定一个塔；具体方法稍后会明确。
- en: The maps are grayscale images. If a pixel’s value is 0, that pixel is a possible
    tower location; if the pixel is 255, it’s off-limits. I placed a collection of
    maps in the *maps* directory. You can make your own in any graphics program; use
    255 to mark regions off-limits to towers and 0 for everything else. The maps need
    not be square. Note that the larger the map, the slower the search, which is why
    the supplied maps are rather small.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些地图是灰度图像。如果一个像素的值为0，则该像素是一个可能的塔位置；如果像素值为255，则该位置不可用。我将一组地图放在*maps*目录中。你可以在任何图形程序中制作自己的地图；使用255标记塔无法放置的区域，0则表示其他区域。地图不必是正方形。需要注意的是，地图越大，搜索越慢，这也是为什么提供的地图较小。
- en: Tower sizes are fractions of half the map’s largest dimension. For example,
    the supplied maps are 80 pixels on a side. Therefore, a tower given as 0.1 has
    a diameter of 0.1 × 40 = 4 pixels, while a 0.6 tower’s diameter is 0.6 × 40 =
    24 pixels. Towers are stored in a text file, one number per line, with the number
    of lines indicating the number of towers. Examine the files in the *towers* directory
    to see what I mean.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 塔的大小是地图最大维度的一半的分数。例如，给定的地图大小是每边 80 像素。因此，一个大小为 0.1 的塔的直径为 0.1 × 40 = 4 像素，而一个
    0.6 塔的直径为 0.6 × 40 = 24 像素。塔的位置存储在一个文本文件中，每行一个数字，行数表示塔的数量。查看 *towers* 目录中的文件，你会明白我的意思。
- en: 'Particle positions represent tower locations. If there are *n* towers, we need
    2*n*-dimensional particles, as we did for packing circles. Every two elements
    of a particle position are the center location for a tower. The order in which
    towers are specified maps, one-to-one, to pairs of particle elements. For example,
    *towers0* has six lines for six towers: 0.1, 0.2, 0.3, 0.4, 0.5, 0.6\. Therefore,
    a search using *towers0* involves 12-dimensional particles'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子位置代表塔的位置。如果有 *n* 个塔，我们需要 2*n* 维的粒子，就像我们在打包圆形时一样。粒子位置中的每两个元素是一个塔的中心位置。指定塔的顺序与粒子元素的顺序一一对应。例如，*towers0*
    有六行，表示六个塔：0.1、0.2、0.3、0.4、0.5、0.6。因此，使用 *towers0* 进行搜索时，涉及到的是 12 维的粒子。
- en: (*x*[0], *y*[0]; *x*[1], *y*[1]; *x*[2], *y*[2]; *x*[3], *y*[3]; *x*[4], *y*[4];
    *x*[5], *y*[5])
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: (*x*[0], *y*[0]; *x*[1], *y*[1]; *x*[2], *y*[2]; *x*[3], *y*[3]; *x*[4], *y*[4];
    *x*[5], *y*[5])
- en: where (*x*[0], *y*[0]) is the location of the 0.1 tower, (*x*[1], *y*[1]) is
    the location of the 0.2 tower, and so on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，(*x*[0], *y*[0]) 是 0.1 塔的位置，(*x*[1], *y*[1]) 是 0.2 塔的位置，依此类推。
- en: '[Figure 5-2](ch05.xhtml#ch05fig02) shows the default maps.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-2](ch05.xhtml#ch05fig02) 显示了默认地图。'
- en: '![Image](../images/05fig02.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig02.jpg)'
- en: '*Figure 5-2: The default maps*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：默认地图*'
- en: The first map is blank, with no forbidden regions. Any marked area on the other
    maps is off-limits to a tower. Think of these as roads, parking lots, lakes, and
    so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张地图是空白的，没有禁区。其他地图上标记的区域对塔是禁止进入的。可以把这些区域想象成道路、停车场、湖泊等。
- en: We have towers and maps. We know how to represent tower locations and sizes.
    How do we put towers, maps, and locations together to get a score? We want to
    cover the map as much as possible by placing towers in allowed locations. Therefore,
    we want to minimize the number of allowed map pixels that aren’t covered by a
    tower; we want the number of zero pixels after placing towers to be as small as
    possible. This sounds like a job for the objective function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有塔和地图。我们知道如何表示塔的位置和大小。那么，如何将塔、地图和位置结合起来得到评分呢？我们希望通过将塔放置在合法位置，尽可能多地覆盖地图。因此，我们希望最小化没有被塔覆盖的合法地图像素的数量；我们希望在放置塔后，剩下的零像素尽可能少。这听起来像是目标函数的工作。
- en: For a given particle position, the objective function needs to determine whether
    any proposed cell tower centers are in an illegal location. If even one tower
    is, the objective function rejects the entire configuration by immediately returning
    a score of 1.0, the largest possible, implying that none of the map is covered.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的粒子位置，目标函数需要判断是否有任何提出的塔中心位于非法位置。如果即使一个塔的位置不合法，目标函数将通过立即返回 1.0 的评分（最大可能值）来拒绝整个配置，意味着地图没有任何被覆盖。
- en: If all proposed tower locations are allowed, it’s time to calculate the coverage.
    The number of uncovered pixels divided by the number of pixels in the map is a
    value in [0, 1], where 0 means all pixels are covered. The lower this value, the
    better the coverage.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有提出的塔位置都是合法的，那么就可以计算覆盖情况了。未覆盖像素的数量除以地图中的像素总数，得出一个[0, 1]区间的值，其中 0 表示所有像素都已覆盖。这个值越低，覆盖效果越好。
- en: The approach I chose begins with an empty image the same size as the map image.
    We add towers to the image by adding each pixel covered by the tower to any current
    pixel value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择的方法从一张与地图图像大小相同的空图开始。我们通过将每个塔覆盖的像素添加到当前像素值中，来向图像中添加塔。
- en: 'Adding pixels in this way accomplishes two things: first, any pixel of the
    initially empty image that is still 0 after adding all the pixels covered by towers
    is uncovered; second, adding pixels tower by tower builds a comprehensible image.
    We’ll be able to see each tower and its covered region clearly, including areas
    where towers overlap.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式添加像素有两个目的：首先，最初为空的图像中，所有在塔覆盖区域内仍为 0 的像素将被暴露；其次，逐个塔添加像素，构建出一个易于理解的图像。我们将能够清楚地看到每个塔及其覆盖的区域，包括塔重叠的区域。
- en: 'To recap, for a given particle position, we:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，对于给定的粒子位置，我们：
- en: Convert the tower coordinates to a set of points as we did earlier for packing
    circles.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将塔的坐标转换为一组点，就像我们之前为打包圆形所做的那样。
- en: Return 1.0 as the score if any tower centers land on illegal regions of the
    map.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何塔的中心落在地图的非法区域，则返回1.0作为得分。
- en: Add each tower to an initially empty image array, including all covered pixels,
    if all tower centers are allowed.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个塔添加到最初为空的图像数组中，包括所有被覆盖的像素，如果所有塔的中心都被允许的话。
- en: Return the count of uncovered pixels divided by the total number of pixels as
    the score.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回未覆盖像素的数量与总像素数之比作为得分。
- en: These steps map particle positions to solutions, thereby generating a single
    number representing the quality of the solution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将粒子位置映射到解决方案，从而生成一个表示解决方案质量的单一数字。
- en: '[Figure 5-3](ch05.xhtml#ch05fig03) shows an input map on the left and output
    generated after a canonical particle swarm search using the six towers in *towers0*
    on the right.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-3](ch05.xhtml#ch05fig03)展示了左侧的输入地图和使用六个塔（位于*towers0*）通过经典粒子群搜索生成的输出结果，右侧为塔的放置情况。'
- en: '![Image](../images/05fig03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/05fig03.jpg)'
- en: '*Figure 5-3: An input mask (left) and resulting tower placement (right)*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：输入掩膜（左）和生成的塔放置结果（右）*'
- en: The towers overlap only slightly, and no centers are in masked areas. Examine
    the files in the *example* directory to view these images in more detail.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 塔的重叠仅轻微，且没有塔中心位于被遮挡的区域。请查看*example*目录中的文件，查看这些图像的更详细内容。
- en: Let’s review the essential parts of *cell.py* to understand how the steps were
    translated into code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下*cell.py*中的关键部分，以了解这些步骤是如何被转换为代码的。
- en: '***The Code***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: The code in *cell.py* is relatively complex. Spend some quality time with the
    file before continuing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*cell.py*中的代码相对复杂。在继续之前，花一些时间好好研究这个文件。'
- en: The most important piece of code is the objective function class and friends;
    see [Listing 5-1](ch05.xhtml#ch05list01).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的代码部分是目标函数类及其相关代码；请参见[列表 5-1](ch05.xhtml#ch05list01)。
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-1: The objective function class*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：目标函数类*'
- en: The constructor stores the map (`image`), towers vector (`towers`), and `radius`,
    which is one-half the largest dimension of the map image. This sets the largest
    possible cell tower range; for example, if the tower’s range is 1, then the circle
    representing the tower has a radius of `radius` pixels, which is half the height
    or width of the map image, whichever is larger. Internally, `radii` is a vector
    of tower radii in pixels ➊.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数存储地图（`image`）、塔的向量（`towers`）和`radius`，即地图图像最大维度的一半。这设置了最大的塔范围；例如，如果塔的范围为1，那么表示塔的圆形的半径就是`radius`像素，即地图图像的高度或宽度的一半，以较大的为准。在内部，`radii`是一个表示塔半径的像素向量
    ➊。
- en: The `Evaluate` method first reshapes the particle position vector into (*x*,
    *y*) points, as we did for *circles.py*. In this case, we want pixel coordinates,
    so `floor` ensures that points are integer valued ➋.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evaluate`方法首先将粒子位置向量重塑为(*x*, *y*)点，正如我们在*circles.py*中做的那样。在这种情况下，我们需要的是像素坐标，因此`floor`确保点的值为整数
    ➋。'
- en: The `Collisions` method first checks whether any proposed cell tower centers
    are in a forbidden region. This is a simple query against the map image. If the
    center pixel isn’t 0, count it as a collision. If any collisions happen, return
    a score of 1.0, implying all pixels are uncovered.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collisions`方法首先检查任何提议的塔中心是否位于禁区内。这是一个简单的地图图像查询。如果中心像素不是0，则计为一次碰撞。如果发生任何碰撞，则返回1.0的得分，表示所有像素都没有被覆盖。'
- en: Assuming no collisions, it’s time to place the towers and calculate the score.
    An `empty` image the same size as the map image is created and passed to `CoverageMap`
    along with the tower centers (`xy`) and `radii` ➌. The return value, `cover`,
    is an image similar to the right side of [Figure 5-3](ch05.xhtml#ch05fig03), but
    without proper scaling to [0, 255]—it is a floating-point array. If an element
    of `cover` is 0, that element isn’t in the range of any tower, so we count it
    with NumPy’s `where` function and divide that count by the number of pixels in
    the map to calculate the score.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设没有碰撞，现在是放置塔并计算得分的时候了。创建一个与地图图像大小相同的`empty`图像，并将其与塔的中心（`xy`）和半径（`radii`）一同传递给`CoverageMap`
    ➌。返回值`cover`是一个类似于[图 5-3](ch05.xhtml#ch05fig03)右侧的图像，但没有适当的缩放到[0, 255]—它是一个浮点数组。如果`cover`的某个元素为0，意味着该元素不在任何塔的覆盖范围内，因此我们使用NumPy的`where`函数计算该元素的数量，并将其除以地图中的像素总数来计算得分。
- en: The `CoverageMap` method is not of the `Objective` class because it’s used elsewhere
    in *cell.py*. It is, however, critical to the success of the code, so let’s walk
    through it in some detail ([Listing 5-2](ch05.xhtml#ch05list02)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoverageMap` 方法不属于 `Objective` 类，因为它在 *cell.py* 中的其他地方使用。然而，它对于代码的成功至关重要，因此让我们详细了解一下它（[清单
    5-2](ch05.xhtml#ch05list02)）。'
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-2: Generating the coverage map for a set of tower positions*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：为一组塔位置生成覆盖图*'
- en: The `CoverageMap` method accepts the map image, tower center locations, and
    tower radii as input. Its goal is to fill in `im`. Passing an empty image to `CoverageMap`
    seems odd at present, but later calls to the function pass the map image itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoverageMap` 方法接受地图图像、塔的中心位置和塔的半径作为输入。其目标是填充 `im`。当前传递一个空图像给 `CoverageMap`
    似乎有些奇怪，但稍后的函数调用会传递地图图像本身。'
- en: Towers are applied in turn with center at (*x*, *y*) ➊. The (inefficient) double
    loop ➋ examines every pixel in the map that could be inside the range of the current
    tower. The body of the inner loop asks whether the current pixel, (*i*, *j*),
    is within the disk of the current tower (the `if` statement). If so, and the (*i*,
    *j*) pixel is within the space of the image, the current pixel value is incremented
    according to
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 塔依次应用，中心位置为 (*x*, *y*) ➊。 (低效的) 双重循环 ➋ 检查地图中每一个可能位于当前塔范围内的像素。内循环的主体检查当前像素 (*i*,
    *j*) 是否在当前塔的磁盘范围内（`if` 语句）。如果是，并且 (*i*, *j*) 像素在图像空间内，则根据以下公式递增当前像素值
- en: 0.5(*k* + 1)/*n*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 0.5(*k* + 1)/*n*
- en: where *n* is the number of towers. This equation increments the pixel value
    (`im` is a floating-point array) by an amount specific to each tower. The result
    leads to the right side of [Figure 5-3](ch05.xhtml#ch05fig03), where each disk
    is a different intensity and overlaps are visible.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *n* 是塔的数量。这个方程通过每个塔的特定量递增像素值（`im` 是一个浮动点数组）。结果会导致[图 5-3](ch05.xhtml#ch05fig03)的右侧，其中每个磁盘具有不同的强度，并且重叠部分是可见的。
- en: After all towers are added, a final loop over adds each tower’s center point
    ➌. The value of the center point is always 1.4 times the intensity of the maximum
    pixel value to make the center points visible (best viewed on a computer screen).
    Since `im` is a floating-point array, it isn’t restricted to [0, 255]. Scaling
    comes later in the code when writing output images to disk.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有塔添加后，一个最终的循环会添加每个塔的中心点 ➌。中心点的值总是最大像素值强度的 1.4 倍，以使中心点可见（最好在计算机屏幕上查看）。由于 `im`
    是一个浮动点数组，它不受 [0, 255] 的限制。缩放将在稍后的代码中进行，当输出图像写入磁盘时。
- en: The `CoverageMap` method returns a two-dimensional array where any remaining
    zero values are pixels not covered by any tower. The number of zero values scaled
    by the number of pixels is the final score for the given tower locations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoverageMap` 方法返回一个二维数组，其中任何剩余的零值表示没有被任何塔覆盖的像素。零值的数量与像素总数的比例即为给定塔位置的最终得分。'
- en: 'The main body of *cell.py* follows *circles.py* in form: parse the command
    line, create framework objects, and do the search. However, instead of calling
    `Optimize`, the search is performed by repeated calls to `Step` so the current
    best score can be displayed per iteration.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*cell.py* 的主体形式上与 *circles.py* 相似：解析命令行，创建框架对象并执行搜索。然而，搜索不是通过调用 `Optimize`
    来执行的，而是通过反复调用 `Step`，以便可以在每次迭代中显示当前最佳得分。'
- en: The search is configured as in [Listing 5-3](ch05.xhtml#ch05list03).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索配置如同在[清单 5-3](ch05.xhtml#ch05list03)中所示。
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-3: Configuring the search*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：配置搜索*'
- en: Here `radius` sets the maximum radius for any tower.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `radius` 设置了任何塔的最大半径。
- en: The search itself is a loop ([Listing 5-4](ch05.xhtml#ch05list04)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索本身是一个循环（[清单 5-4](ch05.xhtml#ch05list04)）。
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-4: Running the search*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4：运行搜索*'
- en: The `Initialize` method configures the swarm, `Done` returns `True` when the
    search is complete (all iterations done or tolerance met), and `Step` performs
    one update of the swarm (it acts like headquarters).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Initialize` 方法配置群体，`Done` 在搜索完成时返回 `True`（所有迭代完成或达到容忍度），而 `Step` 执行群体的一个更新（它像总部一样工作）。'
- en: Every iteration calls the `Results` method to report on the current best value—the
    fraction of image pixels not covered by a tower. After the loop exits, the final
    call to `Results` returns the best set of tower locations. Additional code captures
    the per-iteration output and generates the output map for the swarm’s best configuration.
    See the `frames` option on the command line.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代都会调用`Results`方法来报告当前最佳值——未被塔楼覆盖的图像像素的比例。循环退出后，最后一次调用`Results`会返回最佳的塔楼位置集。附加的代码捕获每次迭代的输出，并生成最优配置的覆盖图。请参阅命令行中的`frames`选项。
- en: Finally, the coverage map is generated and stored in the output directory, as
    shown in [Listing 5-5](ch05.xhtml#ch05list05).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，覆盖图被生成并存储在输出目录中，如[列表 5-5](ch05.xhtml#ch05list05)所示。
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-5: Generating the coverage map*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：生成覆盖图*'
- en: The swarm best position (`p`) is converted to a set of (*x*, *y*) points, which,
    along with the corresponding radii for the towers, are passed to `CoverageMap`
    along with the input map itself (`map_image`). Unlike the `Evaluate` method in
    the objective function, the map with masked regions is passed rather than an empty
    image.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 群体的最佳位置（`p`）被转换为一组(*x*, *y*)点，并与塔楼的相应半径一起传递给`CoverageMap`，同时还传入输入地图本身（`map_image`）。与目标函数中的`Evaluate`方法不同，这里传递的是带有遮罩区域的地图，而不是空白图像。
- en: The resulting coverage map (`cover`) is passed through a square root function
    to squash intensities before converting to a grayscale image (`img`) and writing
    to the output directory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的覆盖图（`cover`）会通过平方根函数进行处理，以压缩强度，然后转换为灰度图像（`img`），并写入输出目录。
- en: By necessity, we skipped code in *cell.py*, but a careful reading of the file
    will make those sections clear. Now let’s see what *cell.py* can do.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要，我们跳过了*cell.py*中的代码，但仔细阅读文件后，这些部分会变得清晰。现在，让我们看看*cell.py*能做什么。
- en: 'Running *cell.py* without arguments shows us how to use it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有参数的情况下运行*cell.py*可以展示如何使用它：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s run the code using *map_01* and *towers0*. For example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用*map_01*和*towers0*来运行代码。例如：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’re using the GA with 20 particles for 100 iterations and dumping the output
    to a directory called *test*. The `frames` keyword outputs the current best tower
    placement per iteration so we can trace the evolution of the swarm visually.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用20个粒子的GA进行100次迭代，并将输出结果存储到名为*test*的目录中。`frames`关键字会输出每次迭代时的当前最佳塔楼位置，这样我们就可以直观地追踪群体的演变。
- en: Notice that 100 iterations is not many compared to the 10,000 or more we used
    with *circles.py*. All the manipulation to generate the coverage map takes time,
    so running for 10,000 iterations is out of the question. Fortunately, we don’t
    usually need more than a few hundred iterations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，100次迭代相对于我们在*circles.py*中使用的10,000次或更多的迭代来说并不多。生成覆盖图的所有操作都需要时间，因此运行10,000次迭代是不可行的。幸运的是，我们通常只需要几百次迭代。
- en: As *cell.py* runs, it dumps the current swarm best score along with a summary
    when the search ends. The output directory contains this text in *README.txt*
    along with the original map image (*map.png*) and the final coverage map (*coverage.png*).
    The Python `pickle` file (*.pkl*) contains the swarm objects, should you wish
    to explore the evolution in more detail. The output directory also contains a
    *frames* directory holding images representing the swarm’s best configuration
    by iteration. Page through these files to watch the swarm evolve.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在*cell.py*运行时，它会输出当前群体最佳分数，并在搜索结束时给出总结。输出目录中包含*README.txt*文本文件，其中包含原始地图图像（*map.png*）和最终的覆盖图（*coverage.png*）。如果你想更详细地查看群体演化，Python的`pickle`文件（*.pkl*）包含了群体对象。输出目录中还包含一个*frames*目录，里面保存了每次迭代时群体最佳配置的图像。翻阅这些文件，你可以看到群体如何演化。
- en: My run produced a final coverage value of 0.358, meaning about 36 percent of
    the map wasn’t covered by a tower, as seen in [Figure 5-4](ch05.xhtml#ch05fig04).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我的运行最终得到了一个覆盖值为0.358，这意味着大约36%的地图没有被塔楼覆盖，具体情况见[图 5-4](ch05.xhtml#ch05fig04)。
- en: '![Image](../images/05fig04.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig04.jpg)'
- en: '*Figure 5-4: Placing towers*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：塔楼放置*'
- en: All six towers in *towers0* are visible in the output. The towers overlap only
    slightly, which is a good sign. Each tower center avoids masked regions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*towers0*中的所有六个塔楼在输出中都可见。塔楼重叠非常少，这是一个好兆头。每个塔楼的中心避免了遮罩区域。'
- en: To experiment with *cell.py*, run the shell scripts *go_tower_results*, *go_towers*,
    and *go_towers0*. The first applies *towers0* to all sample maps using all algorithms.
    The second applies all tower files and algorithms to *map_02*. Finally, the last
    one applies each tower file to *map_00* using only bare-bones PSO to illustrate
    how the swarm places towers when there are no obstacles.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验 *cell.py*，请运行 shell 脚本 *go_tower_results*、*go_towers* 和 *go_towers0*。第一个脚本将
    *towers0* 应用到所有样本地图，使用所有算法。第二个脚本将所有塔楼文件和算法应用于 *map_02*。最后，第三个脚本将每个塔楼文件应用于 *map_00*，仅使用基础的
    PSO 来演示当没有障碍物时群体是如何放置塔楼的。
- en: Run *go_results* and *go_towers*, then run *make_results_plot.py* and *make
    _towers_plot.py* to produce an image file containing all the results with each
    row showing the output of a different swarm algorithm.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 *go_results* 和 *go_towers*，然后运行 *make_results_plot.py* 和 *make_towers_plot.py*，生成包含所有结果的图像文件，每一行显示不同群体算法的输出。
- en: The final script, *go_towers0*, produces the output seen in [Figure 5-5](ch05.xhtml#ch05fig05).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最终脚本 *go_towers0* 生成了在[图 5-5](ch05.xhtml#ch05fig05)中看到的输出。
- en: '![Image](../images/05fig05.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig05.jpg)'
- en: '*Figure 5-5: Placing towers on the default maps*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：在默认地图上放置塔楼*'
- en: It runs bare-bones PSO over the blank map for each tower file. Note that *towers0*
    isn’t able to completely cover the map, but the resulting positions do not overlap,
    meaning bare-bones PSO found an optimal configuration (one of many). The output
    for *towers3* is much the same with the small towers not overlapping the larger
    ones.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它在空白地图上对每个塔楼文件运行基础 PSO。请注意，*towers0* 无法完全覆盖地图，但结果位置不会重叠，这意味着基础 PSO 找到了一个最优配置（多个配置中的一个）。*towers3*
    的输出也差不多，小塔楼与大塔楼没有重叠。
- en: Contrast these results with those for *towers1* and *towers2*. It’s not immediately
    clear whether *towers1* is capable of completely covering the map, but *towers2*
    certainly is—yet tiny parts of the map remained uncovered. I suspect running for
    more than 300 iterations would take care of this. Does it? Is there a difference
    in runtime between using any map with masked regions and the blank map? If so,
    why might that be?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些结果与 *towers1* 和 *towers2* 的结果进行对比。是否能够立刻看出 *towers1* 是否能够完全覆盖地图，尚不清楚，但 *towers2*
    确实能够——然而，地图的某些小部分仍然未被覆盖。我怀疑运行超过 300 次迭代会解决这个问题。它能解决吗？在使用带有遮蔽区域的地图和空白地图时，运行时间有差别吗？如果有，为什么会这样？
- en: Feel free to experiment with different custom maps and numbers and sizes of
    towers to find whether there’s an optimal or more utilitarian mix of tower sizes.
    What works best, many small towers or a few larger ones?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试不同的自定义地图和塔楼的数量及大小，看看是否能找到一个最佳或更具实用性的塔楼大小组合。哪个效果最好，许多小塔楼还是几个大塔楼？
- en: Let’s use randomness to implement a “make it pretty” image filter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用随机性来实现一个“make it pretty”图像滤镜。
- en: '**Enhancing Images**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**图像增强**'
- en: When I view images I’ve taken with my phone in its gallery, I’m offered the
    option to remaster the picture; I call it the “make it pretty” filter. In this
    section, we’ll use a swarm search to implement a “make it pretty” filter for grayscale
    images.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在手机图库中查看自己拍摄的照片时，我会被提供一个重新制作图片的选项；我称之为“make it pretty”滤镜。在这一节中，我们将使用群体搜索来实现一个针对灰度图像的“make
    it pretty”滤镜。
- en: 'Our filter is based on one that has consistently appeared in academic literature.
    It’s a good example of the tendency to take an existing paper, slightly alter
    the technique, and publish it as new. A quick review of the literature turned
    up eight papers all implementing this approach with only a tweak of the optimization
    algorithm: PSO, Firefly, Cuckoo search, DE, PSO, Cuckoo, Cuckoo, and DE, respectively.
    While our implementation is yet another in this illustrious line of research,
    I’m claiming the excuse of pedagogy and do not appeal to novelty or applicability.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的滤镜基于一种在学术文献中经常出现的滤镜。这是一个很好的例子，展示了将现有论文稍作修改后，作为新技术发表的趋势。快速回顾文献发现有八篇论文都在实施这种方法，只对优化算法做了微小的调整：PSO、萤火虫算法、布谷鸟搜索、差分进化、PSO、布谷鸟、布谷鸟和差分进化，依次类推。虽然我们的实现只是这条光辉研究路线中的又一篇，但我以教学为借口，并不依赖新颖性或适用性来进行辩护。
- en: Disclaimers aside, the “make it pretty” filter applies a local image enhancement
    function to an input grayscale image to make it look nicer. If that sentence is
    as clear as mud, have no worries—I’ll explain.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 抛开免责声明不谈，"make it pretty" 滤镜将一个局部图像增强函数应用于输入的灰度图像，以使其看起来更漂亮。如果这句话听起来像泥一样模糊，不用担心——我会解释清楚的。
- en: We intend to apply a function to each pixel of the input image to produce a
    new output pixel. Let’s apply the function
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算对输入图像的每个像素应用一个函数，生成一个新的输出像素。让我们应用这个函数。
- en: '![Image](../images/f0151-01.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0151-01.jpg)'
- en: to the pixel at row *i* and column *j*; that is, *g[ij]*. We need to find *a*,
    *b*, *m*, and *k* to make the image look as nice as possible.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到像素 *i* 行和 *j* 列的位置；也就是 *g[ij]*。我们需要找到 *a*、*b*、*m* 和 *k* 来使图像看起来尽可能好。
- en: '*G* is the original image’s *mean intensity*, or the value found by adding
    all the pixel intensities and dividing by the number of pixels. The *µ* and *σ*
    variables are the mean (*µ*) and standard deviation (*σ*) of a 3×3 region around
    the current pixel, *g[ij]*. Imagine a tic-tac-toe (naughts and crosses) board
    as in [Figure 5-6](ch05.xhtml#ch05fig06).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*G* 是原始图像的*均值强度*，即通过将所有像素强度相加并除以像素数量得到的值。*µ* 和 *σ* 变量分别是当前像素 *g[ij]* 周围 3×3
    区域的均值 (*µ*) 和标准差 (*σ*)。可以将其想象成一个井字棋（圈叉游戏）板，如 [图 5-6](ch05.xhtml#ch05fig06) 所示。'
- en: '![Image](../images/05fig06.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig06.jpg)'
- en: '*Figure 5-6: Pixel offsets*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：像素偏移*'
- en: The 3×3 region slides over the image visiting each pixel, calculates *µ* and
    *σ*, and then uses [Equation 5.1](ch05.xhtml#ch05equ1) to create a new pixel value,
    ![Image](../images/f0151-02.jpg). Note that ![Image](../images/f0151-03.jpg) is
    the value of the *ij* pixel in the output image; it does not update the original
    image pixel, *g[ij]*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 3×3 区域在图像上滑动，访问每个像素，计算 *µ* 和 *σ*，然后使用 [方程 5.1](ch05.xhtml#ch05equ1) 来创建新的像素值，
    ![Image](../images/f0151-02.jpg)。请注意，![Image](../images/f0151-03.jpg) 是输出图像中 *ij*
    像素的值；它并不更新原始图像中的像素 *g[ij]*。
- en: The function for updating image pixels has four parameters we need to find,
    along with other values that depend on the original image and how we apply the
    function. However, the function only tells us how to update the image for a given
    *a*, *b*, *m*, and *k*; it doesn’t say anything about how nice the output image
    will appear to a human observer. For that, we need an objective function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 用于更新图像像素的函数有四个参数我们需要找到，以及依赖于原始图像和我们如何应用函数的其他值。然而，函数仅告诉我们如何根据给定的 *a*、*b*、*m*
    和 *k* 来更新图像；它并没有说明输出图像在人眼观察者看来有多美观。为了做到这一点，我们需要一个目标函数。
- en: 'Researchers claim that the following function captures something of what makes
    an image look pleasant to humans:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员声称，以下函数捕捉了让图像看起来让人愉悦的某些因素：
- en: '![Image](../images/f0152-01.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0152-01.jpg)'
- en: 'We’ll use *F* as our objective function. The higher *F* is, the better the
    image will look to a human observer—at least, that’s the theory. *I* is the sum
    of the pixel intensities of an edge-detected version of the input image. The “edgels”
    variable is the number of edges in the edge-detected version of the image above
    a threshold, here 20\. Finally, *r* and *c* are the image dimensions (rows and
    columns) and *h* is the entropy of the image:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 *F* 作为目标函数。*F* 的值越高，图像对于人眼观察者的效果就越好——至少理论上是这样。*I* 是输入图像经过边缘检测处理后的像素强度之和。*edgels*
    变量是边缘检测版本中高于阈值（此处为 20）的边缘数量。最后，*r* 和 *c* 是图像的维度（行和列），*h* 是图像的熵：
- en: '![Image](../images/f0152-02.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0152-02.jpg)'
- en: Here *p[i]* is the probability of pixel intensity in bin *i* of a 64-bin histogram.
    Entropy, in this sense, refers to the information content of the image.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 *p[i]* 是 64-bin 直方图中第 *i* 个区间的像素强度概率。熵在这个意义上指的是图像的信息量。
- en: This exercise seems superficially similar to curve fitting. We have a function
    with parameters to be optimized, but the algorithm behind the application of the
    function has many more steps. However, as we’ll soon learn, the extra effort means
    little to our swarm algorithms. They still provide floating-point vectors to the
    objective function and expect a scalar quality measure in return. The swarm is
    blissfully unaware of what it’s optimizing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习表面上似乎类似于曲线拟合。我们有一个带有需要优化的参数的函数，但应用该函数的算法包含更多步骤。然而，正如我们很快将了解到的那样，这些额外的步骤对我们的群体算法几乎没有影响。它们仍然提供浮动点向量给目标函数，并期待返回一个标量质量度量值。群体算法对它们正在优化的内容浑然不觉。
- en: '***The Enhancement Function***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***增强函数***'
- en: 'We have a four-parameter optimization problem: for a given image, we want to
    find the best *a*, *b*, *m*, and *k* values, all of which are floating-point numbers.
    From a framework perspective, the setup is straightforward once we decide on bounds
    for the parameters. All the cool code will be in the objective function class.
    The full program is in *enhance.py*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个四参数优化问题：对于给定的图像，我们希望找到最佳的 *a*、*b*、*m* 和 *k* 值，这些值都是浮动点数。从框架的角度来看，一旦我们确定了参数的边界，设置过程是直接的。所有的酷炫代码都将在目标函数类中。完整程序位于
    *enhance.py*。
- en: We start with [Listing 5-6](ch05.xhtml#ch05list06), the objective function class,
    which implements both the elaborate image enhancement and *F* functions given
    previously.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[列表 5-6](ch05.xhtml#ch05list06)开始，这是目标函数类，它实现了之前给出的精细图像增强和*F*函数。
- en: '[PRE10]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 5-6: The image enhancement objective function class*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：图像增强目标函数类*'
- en: The class constructor stores a copy of the original image. The `Evaluate` method
    extracts *a*, *b*, *m*, and *k* from the supplied particle position, passing them
    and the original image to `ApplyEnhancement` to return a new image, `dst`. We
    pass the new image to the `F` method to calculate the score. Since we want to
    maximize *F*, we return the negative.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数存储了原始图像的副本。`Evaluate`方法从提供的粒子位置中提取*a*、*b*、*m*和*k*，将它们和原始图像传递给`ApplyEnhancement`，返回一个新的图像`dst`。我们将新图像传递给`F`方法以计算分数。由于我们希望最大化*F*，因此返回其负值。
- en: I’ll explain `ApplyEnhancement` momentarily; let’s focus on `F` for now. The
    method is linear and makes heavy use of powerful functions supplied by NumPy and
    PIL (`Image` and `ImageFilter`). Walking through, line by line, makes sense in
    this case.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我会稍后解释`ApplyEnhancement`；现在我们先专注于`F`。该方法是线性的，并且大量使用了NumPy和PIL（`Image`和`ImageFilter`）提供的强大函数。在这种情况下，逐行分析是有意义的。
- en: First, we extract the image dimensions (`r`, `c`). In the next line, we apply
    an edge detection filter to the image producing `Is` from `dst`. The output of
    an edge detector looks like [Figure 5-7](ch05.xhtml#ch05fig07).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们提取图像的维度（`r`、`c`）。在下一行，我们对图像应用边缘检测滤波器，生成`Is`作为`dst`的输出。边缘检测器的输出类似于[图 5-7](ch05.xhtml#ch05fig07)。
- en: '![Image](../images/05fig07.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig07.jpg)'
- en: '*Figure 5-7: An edge detector in action*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：边缘检测器的作用*'
- en: We recast the PIL image, `Is`, as a NumPy array before using `where` to count
    the number of edge pixels greater than 20\. We chose 20 because it’s an empirically
    selected threshold that works well. The count is stored in `edgels`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将PIL图像`Is`重新转换为NumPy数组，然后使用`where`来统计边缘像素大于20的数量。我们选择20是因为这是一个经验选定的阈值，效果很好。统计结果存储在`edgels`中。
- en: The only part of *F* yet to determine is the entropy, *h*, here given as `ent`.
    To get this, we first need the histogram of the image using 64 bins, conveniently
    acquired in a single line of code courtesy of NumPy’s `histogram` function. Scaling
    the histogram by the sum of all bins converts from counts per bin to an estimate
    of the probability per bin, `p`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 目前唯一未确定的*F*部分是熵*h*，这里表示为`ent`。为了获得这一点，我们首先需要图像的直方图，使用64个箱子，这可以通过NumPy的`histogram`函数在一行代码内便捷地获得。通过将直方图按所有箱子的总和进行缩放，可以将每个箱子的计数转换为每个箱子的概率估计`p`。
- en: With `p` in hand, we calculate the entropy by summing the probabilities multiplied
    by the log, base 2, of the probabilities (`ent`). The penultimate line in `F`
    is a direct analog of the equation for *F*, the value of which is returned.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 得到`p`后，我们通过将概率乘以概率的对数（以 2 为底）来计算熵（`ent`）。`F`中的倒数第二行直接对应于*F*的方程，返回其值。
- en: Now for `ApplyEnhancement` in [Listing 5-7](ch05.xhtml#ch05list07).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是[列表 5-7](ch05.xhtml#ch05list07)中的`ApplyEnhancement`。
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 5-7: Applying a set of parameters to an image*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7：将一组参数应用于图像*'
- en: We enhance the original image by applying [Equation 5.1](ch05.xhtml#ch05equ1).
    The output image (`dst`) is constructed, pixel by pixel, using the local 3×3 region
    mean (`m`) and standard deviation (`s`) in conjunction with the arguments `a`,
    `b`, `c`, and `k`. Note that `c` is *m* in [Equation 5.1](ch05.xhtml#ch05equ1).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过应用[方程 5.1](ch05.xhtml#ch05equ1)来增强原始图像。输出图像（`dst`）是逐像素构建的，使用局部的 3×3 区域均值（`m`）和标准差（`s`），结合参数`a`、`b`、`c`和`k`。请注意，`c`在[方程
    5.1](ch05.xhtml#ch05equ1)中是*m*。
- en: The helper function, `stats`, defines the 3×3 region around (*i*, *j*), accounting
    for the image index limits. It then returns the mean and standard deviation. The
    `if` catches the edge case where too few pixels exist for a meaningful standard
    deviation calculation. Notice the `ddof` keyword in the call to `std`. By default,
    NumPy calculates the biased estimator of the variance by dividing by the number
    of values instead of the unbiased estimate found by dividing by one less than
    the number of values. Many statistics packages use the unbiased estimator by default.
    In most cases, especially if there are < 20 values in the dataset, we want the
    unbiased estimator, so we set `ddof=1`. Recall that the standard deviation is
    the square root of the variance.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数`stats`定义了围绕（*i*, *j*）的 3×3 区域，考虑了图像的索引限制。然后，它返回均值和标准差。`if`语句处理了像素太少以至于无法进行有意义标准差计算的边界情况。注意在调用`std`时的`ddof`关键词。默认情况下，NumPy通过除以数值的数量来计算偏差估计的方差，而不是通过除以比数值数量少1的数量来计算无偏估计。许多统计软件包默认使用无偏估计。在大多数情况下，特别是当数据集中的值少于20个时，我们希望使用无偏估计，因此设置`ddof=1`。回想一下，标准差是方差的平方根。
- en: All that remains is to configure the search, as shown in [Listing 5-8](ch05.xhtml#ch05list08).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是配置搜索，具体见[Listing 5-8](ch05.xhtml#ch05list08)。
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 5-8: Configuring the search*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-8: 配置搜索*'
- en: 'The configuration follows our framework: randomness source (`rng`), bounds
    (`b`), initializer (`i`), objective function (`obj`), and a `swarm` object, here
    `GWO`. We force the input image (`orig`) to grayscale (`convert`) and scale it
    by 256 to be in the range [0, 1) (`img`). It’s not uncommon to manipulate images
    in this range instead of [0, 255]. After manipulation, the image is scaled to
    [0, 255] and converted to an integer type before writing it to disk.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 配置遵循我们的框架：随机源（`rng`）、边界（`b`）、初始化器（`i`）、目标函数（`obj`）和`swarm`对象，这里是`GWO`。我们强制将输入图像（`orig`）转换为灰度图像（`convert`），并将其按
    256 进行缩放，使其位于 [0, 1) 范围内（`img`）。在这个范围内操作图像比在 [0, 255] 范围内更为常见。操作完成后，图像将被缩放回 [0,
    255]，并转换为整数类型，最后写入磁盘。
- en: The search is four dimensional (`ndim`), so there are four bounds. The bounds
    vary by dimension. The limits *a ∈* [0, 1.5], *b ∈* [1.0, 22], *m ∈* [0, 1], and
    *k ∈* [0.5, 1.5] are based on values used in the literature. As we’ll see, they
    appear to work well, but try experimenting with them, especially if you notice
    output values near the limits. We’ll soon learn how to find these values after
    a search.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索是四维的（`ndim`），所以有四个边界。每个维度的边界不同。边界 *a ∈* [0, 1.5]，*b ∈* [1.0, 22]，*m ∈* [0,
    1]，*k ∈* [0.5, 1.5] 是基于文献中的值。正如我们将看到的，它们似乎效果很好，但可以尝试调整它们，特别是如果你注意到输出值接近边界时。我们很快就会学会如何在搜索后找到这些值。
- en: Running the search is as simple as calling `Optimize` on the `swarm` object,
    but we want to track the *F* score as we go, so we’ll loop manually instead ([Listing
    5-9](ch05.xhtml#ch05list09)).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行搜索就像调用`Optimize`方法对`swarm`对象进行操作那样简单，但为了在过程中跟踪*F*评分，我们将手动循环执行，而不是直接调用（见[Listing
    5-9](ch05.xhtml#ch05list09)）。
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 5-9: Running the search*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-9: 运行搜索*'
- en: The search ends after all specified iterations. We then dump the final results
    (`res`) to the output directory via `pickle`. Use the `gpos` key to return the
    final set of parameters. To conclude, the image is enhanced with the best set
    and written to the output directory along with the original image for comparison
    purposes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索在所有指定的迭代次数后结束。然后，我们通过`pickle`将最终结果（`res`）输出到目标目录。使用`gpos`键返回最终的参数集合。最后，使用最佳参数集对图像进行增强，并将其与原始图像一起写入输出目录以便进行对比。
- en: Does *enhance.py* work? Let’s find out.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*enhance.py* 是否有效？让我们来找出答案。'
- en: '***The Code***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'Run *enhance.py* without arguments to learn what it expects on the command
    line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*enhance.py*，不带参数，以了解它在命令行中需要哪些输入：
- en: '[PRE14]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need to supply the original image, swarm size, iterations, algorithm type,
    randomness source, and output directory name.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供原始图像、群体大小、迭代次数、算法类型、随机性源和输出目录名称。
- en: The *images* directory contains a set of 128×128-pixel grayscale images that
    we’ll use for our experiments. The search isn’t particularly fast, given the sequential
    nature of the framework and the extensive image manipulations each call to the
    objective function entails, so smaller images work best. The program will work
    with larger images, which need not be square; all that’s required is patience.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*images* 目录包含一组 128×128 像素的灰度图像，我们将用它们进行实验。考虑到框架的顺序性质和每次调用目标函数时需要进行的大量图像操作，搜索速度并不是特别快，因此较小的图像效果最好。程序也能处理较大的图像，它们不必是正方形；唯一需要的是耐心。'
- en: 'Give this command line a try:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这个命令行：
- en: '[PRE15]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output shows the current swarm best *F* score by iteration. The value is
    negative because we want to maximize *F*. The command line specified GWO with
    a swarm of 10 particles, 60 iterations, and an output directory named *babs*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了每次迭代的当前群体最佳*F*分数。由于我们想最大化*F*，所以该值是负数。命令行指定了GWO，群体为10个粒子，60次迭代，输出目录名为*babs*。
- en: 'On my system, the search finishes with this output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上，搜索以以下输出结束：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Therefore, the best set of parameters led to *F* = 6.09797 after 14 swarm best
    updates. The *babs* output directory contains
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最佳参数集在14次群体最佳更新后得到了*F* = 6.09797。*babs*输出目录包含：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: giving us the enhanced image, the original image, the pickled results, and a
    README file containing all output generated during the search.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 给我们提供了增强后的图像、原图、pickle格式的结果以及一个README文件，其中包含在搜索过程中生成的所有输出。
- en: The enhanced image should look sharper with better contrast than the original.
    Unfortunately, a printed version will likely not show the differences clearly.
    Nonetheless, [Figure 5-8](ch05.xhtml#ch05fig08) shows both images, with the original
    on the left and the enhanced version on the right.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 增强后的图像应该看起来更清晰，具有更好的对比度，比原图更好。不幸的是，打印版本可能无法清晰显示这些差异。不过，[图 5-8](ch05.xhtml#ch05fig08)展示了两张图片，左边是原图，右边是增强版。
- en: '![Image](../images/05fig08.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig08.jpg)'
- en: '*Figure 5-8: The original and enhanced images*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：原图与增强图像*'
- en: Look, in particular, at the books in the bookcase. They are better defined and
    show improved contrast.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意书架上的书。它们的定义更加清晰，显示了改善的对比度。
- en: To extract the enhancement parameters, load the *results.pkl* file
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取增强参数，加载*results.pkl*文件。
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: which tells us that *a* = 0.01867, *b* = 1.0078, *m* = 0.45469, and *k* = 1.17311\.
    We haven’t used `pickle` before; it requires a file object (the output of `open`)
    and must use binary mode (`"rb"`).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，*a* = 0.01867，*b* = 1.0078，*m* = 0.45469，*k* = 1.17311。我们之前没有使用过`pickle`，它需要一个文件对象（`open`的输出），并且必须使用二进制模式（`"rb"`）。
- en: 'There are nine images in the *images* directory. We’ll run various swarm and
    evolutionary algorithms against these images, and then collect the resulting output
    to produce composite images showing the original and the enhanced versions so
    we might rate each algorithm’s performance. To that end, I created two Python
    scripts: *process_images.py* and *merge_images.py*.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*images*目录中有九张图片。我们将对这些图片运行各种群体和进化算法，然后收集结果输出，生成展示原图和增强版的复合图像，以便评估每个算法的表现。为此，我创建了两个Python脚本：*process_images.py*和*merge_images.py*。'
- en: Run *process_images.py* first. I recommend starting it in the evening and returning
    in the morning. The script processes every image in *images* using each swarm
    algorithm. The swarm consists of 10 particles and runs for 75 iterations in all
    cases.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先运行*process_images.py*。我建议你在晚上开始运行，早上回来查看。这个脚本使用每个群体算法处理*images*中的每一张图片。群体包含10个粒子，并且在所有情况下都会运行75次迭代。
- en: When *process_images.py* finishes, use *merge_images.py* to produce composite
    images showing the results, which are in the *output* directory. For example
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当*process_images.py*完成时，使用*merge_images.py*生成复合图像，展示结果，这些结果位于*output*目录中。例如：
- en: '[PRE19]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: creates *zelda_results.png*, as in [Figure 5-9](ch05.xhtml#ch05fig09). Canonical
    PSO looks like the winner here.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 创建*zelda_results.png*，如[图 5-9](ch05.xhtml#ch05fig09)所示。标准PSO看起来是这里的胜者。
- en: '![Image](../images/05fig09.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig09.jpg)'
- en: '*Figure 5-9: A composite image. From top left: original, bare-bones PSO, DE,
    GA, GWO, Jaya, canonical PSO, RO.*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-9：复合图像。左上角开始：原图、裸骨PSO、DE、GA、GWO、Jaya、标准PSO、RO。*'
- en: '[Table 5-3](ch05.xhtml#ch05tab03) lists the *F* scores and parameters for each
    algorithm.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5-3](ch05.xhtml#ch05tab03)列出了每个算法的*F*分数和参数。'
- en: '**Table 5-3:** *F* Scores and Parameters for Each Algorithm'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-3：** 每个算法的*F*分数和参数'
- en: '|  | ***F*** | ***a*** | ***b*** | ***m*** | ***k*** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  | ***F*** | ***a*** | ***b*** | ***m*** | ***k*** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **GWO** | 4.59328 | 0.00030 | 2.21893 | 0.71926 | 0.99232 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **GWO** | 4.59328 | 0.00030 | 2.21893 | 0.71926 | 0.99232 |'
- en: '| **Canonical PSO** | 5.07767 | 0.00585 | 1.50612 | 0.39545 | 1.46734 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **标准PSO** | 5.07767 | 0.00585 | 1.50612 | 0.39545 | 1.46734 |'
- en: '| **Jaya** | 4.31448 | 1.21667 | 1.00493 | 0.76448 | 1.47750 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **Jaya** | 4.31448 | 1.21667 | 1.00493 | 0.76448 | 1.47750 |'
- en: '| **DE** | 4.29245 | 1.24982 | 1.00076 | 0.76535 | 1.46355 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **DE** | 4.29245 | 1.24982 | 1.00076 | 0.76535 | 1.46355 |'
- en: '| **Bare-bones PSO** | 4.27962 | 1.09779 | 1.01205 | 0.89588 | 1.49625 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **裸骨PSO** | 4.27962 | 1.09779 | 1.01205 | 0.89588 | 1.49625 |'
- en: '| **GA** | 4.10057 | 1.14040 | 1.64773 | 0.12196 | 1.19704 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **GA** | 4.10057 | 1.14040 | 1.64773 | 0.12196 | 1.19704 |'
- en: '| **RO** | 4.01708 | 1.08478 | 5.07904 | 0.53249 | 0.97552 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **RO** | 4.01708 | 1.08478 | 5.07904 | 0.53249 | 0.97552 |'
- en: The subjectively best-looking image is also the image with the largest *F* score—a
    good sign. The GWO image, which has low contrast but is quite sharp, has the second-highest
    *F* score. The GWO parameters are also quite different from the others. It’s possible
    that the enhancement function parameter space has a fairly complex structure,
    and there are multiple local minima. For the Zelda image, the GWO algorithm seems
    to have landed apart from the others. Does this happen with the other images?
    Which algorithm seems to work best overall?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 主观上看起来最好的图像也是*F*得分最高的图像——这是一个好兆头。GWO图像对比度较低，但非常清晰，其*F*得分位居第二。GWO参数也与其他算法有很大不同。增强函数的参数空间可能具有相当复杂的结构，并且存在多个局部最小值。对于Zelda图像，GWO算法似乎与其他结果有所不同。这种情况在其他图像中也会发生吗？哪个算法似乎整体表现最佳？
- en: The program *F.py* applies a specific set of parameters to an image. What happens
    if we apply *a* from the GWO result and *b*, *m*, and *k* from the canonical PSO
    result?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 程序*F.py*将一组特定的参数应用于图像。如果我们应用GWO结果中的*a*和经典PSO结果中的*b*、*m*和*k*，会发生什么？
- en: '[PRE20]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The new *F* score is higher still, and the output file, *zelda2.png*, looks
    even better than the canonical PSO result.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 新的*F*得分更高，输出文件*zelda2.png*看起来比经典PSO结果更好。
- en: There is much more to explore here. I’ll provide a few suggestions in “Exercises”
    on [page 169](ch05.xhtml#ch00lev1_33), including a way to (possibly) enhance color
    images. For the time being, let’s move on to another experiment, which combines
    optimization with simulation to maximize profit by figuring out how to best arrange
    the products in a grocery store.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有很多值得探索的内容。我将在“练习”部分提供一些建议，见[第169页](ch05.xhtml#ch00lev1_33)，包括一种（可能的）增强彩色图像的方法。目前，让我们继续进行另一个实验，该实验结合了优化和仿真，通过找出最佳的商品陈列方式来最大化超市的利润。
- en: '**Arranging a Grocery Store**'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安排超市布局**'
- en: Have you noticed that grocery stores usually put milk in the back, as far from
    the entrance as possible? Or that candy is located right at the front, near the
    checkouts? The placement of products in a grocery store is not an accident; it’s
    intentional to maximize profit. Many people stop by the store to pick up necessities,
    like milk, and often pick up something else if they run across it, like candy.
    Grocery stores arrange the products to maximize such occurrences and increase
    revenue.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，超市通常把牛奶放在最远的地方，尽可能远离入口？或者糖果总是在最前面，靠近收银台？超市商品的摆放并不是偶然的；它是故意设计的，以最大化利润。许多人到商店来买生活必需品，比如牛奶，常常会顺便捎带点其他东西，比如糖果。超市通过这种商品布局来最大化此类偶然事件的发生，并增加收入。
- en: This section attempts to replicate such an arrangement of products to validate
    or refute common store practice. This experiment combines optimization with simulation.
    We’ll optimize product placement in the store using a set of simulated shoppers
    to evaluate the arrangement. Our goal is an arrangement of products, our objective
    function score is revenue over a day, and the function itself is a simulation
    of several hundred shoppers. Randomness is everywhere, from swarm initialization
    and position updates to the collection of shoppers and their habits. To jump in,
    read through *store.py*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本节尝试复制这样的商品排列，以验证或反驳常见的商店做法。这个实验结合了优化和仿真。我们将通过一组模拟顾客来优化商店的商品摆放，并评估这一安排。我们的目标是商品的排列方式，目标函数得分是一天的收入，函数本身是对数百名顾客的模拟。从群体初始化和位置更新到顾客的收集和习惯，随机性无处不在。要开始，请阅读*store.py*。
- en: '***The Environment***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***环境***'
- en: Let’s define our operating environment. Actual stores are essentially two dimensional;
    there is a layout over some floor space. Our framework uses position vectors,
    one-dimensional entities. We’ll make the store one-dimensional as well, so a position
    vector can be a store layout with each element a product. Shoppers will enter
    the store on the left (index 0) and progress through the store to the right, like
    in [Figure 5-10](ch05.xhtml#ch05fig10).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一下我们的操作环境。实际的商店本质上是二维的；有一个布置在某个地面空间上的布局。我们的框架使用位置向量（一维实体）。我们将商店设为一维，因此位置向量可以是一个商店布局，每个元素代表一个商品。顾客将从商店的左侧（索引0）进入，沿着商店向右走，就像在[图5-10](ch05.xhtml#ch05fig10)中一样。
- en: '![Image](../images/05fig10.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/05fig10.jpg)'
- en: '*Figure 5-10: Shopping at a one-dimensional grocery store (Illustration by
    Joseph Kneusel)*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-10：在一维超市购物（插图：Joseph Kneusel）*'
- en: People typically go to the store to pick up a specific product; we’ll call this
    the *target product*. The shoppers will also have impulse products that they’ll
    buy if they encounter them before the target product.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常去商店购买特定的商品；我们称之为*目标商品*。购物者还会有冲动购买的商品，如果在找到目标商品之前遇到这些商品，他们也会购买。
- en: For example, [Figure 5-10](ch05.xhtml#ch05fig10) shows two shoppers who are
    thinking of a target product (signified by the question mark) and an impulse product
    (the exclamation point).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图5-10](ch05.xhtml#ch05fig10)显示了两位购物者，他们在考虑目标商品（用问号表示）和冲动商品（用感叹号表示）。
- en: The shopper on the left is searching for the diamond product, but will purchase
    the circle product if they see it. Since they encounter the diamond before the
    circle, they buy only the diamond product and leave the store.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的购物者正在寻找钻石商品，但如果看到圆形商品，他们也会购买。由于他们先遇到钻石商品，再遇到圆形商品，因此他们只购买了钻石商品并离开了商店。
- en: The shopper on the right is searching for the triangle product, but they’ll
    buy the square product if they come across it. They find the square while searching
    for the triangle and purchase both.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的购物者正在寻找三角形商品，但如果遇到方形商品，他们也会购买。在寻找三角形商品时，他们发现了方形商品并购买了两者。
- en: 'The shopping simulation requires products, located in the *products.pkl* file.
    The file contains three lists, each of 24 elements: counts, names, and prices,
    in that order. The data comes from an actual collection of products purchased
    over some period. The products are stored in decreasing purchase frequency, so
    the item most often purchased is first, and the least often purchased is last.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 购物模拟需要商品，这些商品位于*products.pkl*文件中。该文件包含三个列表，每个列表有24个元素：计数、名称和价格，按此顺序排列。这些数据来自实际的一段时间内购买的商品集合。商品按购买频率递减存储，因此最常购买的商品排在最前面，最少购买的商品排在最后面。
- en: We convert the counts to a purchase probability by dividing each by the sum
    of all the counts. We’ll use the purchase probability in our objective function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将每个计数除以所有计数的总和，将计数转换为购买概率。我们将在目标函数中使用购买概率。
- en: If there are 24 products in the store, we have 24-dimensional position vectors.
    We’re searching for the best ordering of products to maximize daily revenue. We’ll
    visit the simulation part in more detail later, but for the moment, let’s focus
    on the product order and how we’ll represent it in a swarm.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果商店里有24个商品，我们就有24维的位置向量。我们正在寻找商品的最佳排列，以最大化每日收入。我们稍后将更详细地讨论模拟部分，但目前让我们关注商品的顺序以及如何在群体中表示它。
- en: At first, we might think to make the position vectors discrete values in [0,
    23], where each number is a product, an index into the list of products read from
    *products.pkl*. However, I implemented an alternate approach using position vectors
    in [0, 1).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们可能会考虑将位置向量设为[0, 23]中的离散值，其中每个数字代表一个商品，是从*products.pkl*文件中读取的商品列表的索引。然而，我实现了一种替代方法，使用[0,
    1)中的位置向量。
- en: Ultimately, we want a vector that places products in a particular order, some
    permutation of the vector {0, 1, 2, 3, . . . , 23}. The trick is to abstract this
    permutation so we can still use continuous floating-point values in [0, 1). Instead
    of using the product numbers directly, we pass each position vector to NumPy’s
    `argsort` function, which returns the order of indices that would sort the vector.
    For a vector of 24 elements, the output of `argsort` is a permutation of the numbers
    0 through 23.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们需要一个向量，将商品按照特定顺序排列，这是向量{0, 1, 2, 3, . . . , 23}的某种排列。诀窍是将这种排列抽象化，这样我们仍然可以在[0,
    1)中使用连续的浮点数值。我们不直接使用商品编号，而是将每个位置向量传递给NumPy的`argsort`函数，该函数返回对向量进行排序所需的索引顺序。对于一个24元素的向量，`argsort`的输出是数字0到23的排列。
- en: That this approach works—and we’ll see that it does—is impressive. We’re asking
    the swarms to generate a collection of floating-point numbers, [0, 1), that are
    useful only when the additional operation of determining their sort order has
    happened. The reason it works likely has to do with the fact that using integer
    values requires some kind of truncation or rounding of a floating-point number
    where the implemented approach uses the numbers as they are. If changing a particular
    element of the particle position from 0.304 to 0.288 alters the sort order of
    the entire vector to a more profitable configuration, the swarm makes use of that
    change, whereas truncation might call both numbers 0.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效——我们将看到它确实有效——令人印象深刻。我们要求群体生成一组浮动的实数，[0, 1)，这些数只有在确定它们的排序顺序之后才有用。它之所以有效，可能与使用整数值需要某种截断或舍入浮动小数点数字的情况有关，而实现的方法直接使用这些数字本身。如果将粒子位置中的某个元素从
    0.304 更改为 0.288，使得整个向量的排序顺序变为更有利的配置，群体会利用这个变化，而截断可能会把这两个数字都看作 0。
- en: 'Here are the steps we need to implement:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要实现的步骤：
- en: Initialize the swarm with 24-element position vectors in [0, 1).
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用 [0, 1) 中的 24 个元素位置向量来初始化群体。
- en: Initialize a collection of randomly generated shoppers.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个随机生成的购物者集合。
- en: Run our usual swarm search where each position vector is evaluated by passing
    shoppers through the store using the sort order of the current vector as the arrangement
    of products. Then, tally the amount of money each shopper spends. They’ll always
    find their target product, but may not find their impulse products. Finally, return
    the negative of the total spent by the shoppers, as we want to maximize daily
    revenue.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行我们通常的群体搜索，在该过程中，每个位置向量通过将购物者传递到商店并使用当前向量的排序顺序作为产品的排列来进行评估。然后，统计每个购物者花费的金额。他们总是能找到目标产品，但可能找不到冲动产品。最后，返回购物者总花费的负值，因为我们希望最大化每日收入。
- en: Let the swarm algorithm update positions as usual until all iterations have
    run.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让群体算法像往常一样更新位置，直到所有迭代完成。
- en: Report the sort order of the best position found as the “ideal” ordering of
    the products.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 报告找到的最佳位置的排序顺序，作为产品的“理想”排序。
- en: The following two sections detail how to implement shoppers and how the objective
    function works. With those in mind, we’ll be ready to go shopping and see if our
    simulation agrees with grocery industry experts.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个部分详细介绍如何实现购物者以及目标函数是如何工作的。有了这些信息，我们就准备好去购物，看看我们的模拟结果是否与食品行业专家的意见一致。
- en: '***The Shoppers***'
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***购物者***'
- en: A shopper is an instance of the Shopper class, as shown in [Listing 5-10](ch05.xhtml#ch05list010).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一个购物者是 `Shopper` 类的一个实例，如[清单 5-10](ch05.xhtml#ch05list010)所示。
- en: '[PRE21]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 5-10: The* Shopper *class*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-10：* Shopper *类*'
- en: The constructor configures the shopper by selecting the target (`target`) and
    impulse (`impulse`) products. It also keeps a copy of the product prices (`item_values`)
    for when it’s time to go shopping.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数通过选择目标（`target`）和冲动（`impulse`）产品来配置购物者。它还会保留产品价格（`item_values`）的副本，以便在购物时使用。
- en: A call to `Select` returns the target product, which is an index into the product
    list ➊. The `Select` method takes advantage of the fact that `fi` is the probability
    of a product being purchased in decreasing order ([Listing 5-11](ch05.xhtml#ch05list011)).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `Select` 的调用返回目标产品，这是产品列表中的一个索引 ➊。`Select` 方法利用了 `fi` 是按递减顺序排列的产品购买概率这一事实（[清单
    5-11](ch05.xhtml#ch05list011)）。
- en: '[PRE22]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 5-11: Selecting a product according to its purchase frequency*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-11：根据购买频率选择产品*'
- en: We select a random value, [0, 1) (`t`). We then add successive probabilities
    for each product to `c` until equaling or exceeding `t`. When that happens, as
    it must because *t* < 1 and the sum of all product probabilities is 1.0, the current
    product index is returned (`i`).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择一个随机值，[0, 1)（`t`）。然后，我们将每个产品的连续概率加到 `c` 上，直到其值等于或超过 `t`。当这种情况发生时，必然发生，因为
    *t* < 1 且所有产品的概率总和为 1.0，这时返回当前产品的索引（`i`）。
- en: 'Let’s see an example to clarify how `Select` works. Imagine there are five
    products, each selected with probability:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，来澄清 `Select` 是如何工作的。假设有五个产品，每个产品的选择概率如下：
- en: 0.5, 0.3, 0.1, 0.07, 0.03
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 0.5, 0.3, 0.1, 0.07, 0.03
- en: 'This means product 0 is purchased about 50 percent of the time while product
    4 is purchased only 3 percent of the time. The sum is 1.0, or 100 percent. Now,
    pick a random value in *t ∈* [0, 1). This will be less than 0.5 half of the time,
    meaning `Select` will return index 0\. The sum of the first two product probabilities
    is 0.5 + 0.3 = 0.8\. But half the time *t* < 0.5, so the difference between 0.5
    and 0.8 is the fraction of the time 0.5 > *t ≤* 0.8: 30 percent of the time. Similarly,
    10 percent of the time 0.8 > *t ≤* 0.9, 7 percent of the time 0.9 > *t ≤* 0.97,
    and 3 percent of the time 0.97 > *t ≤* 1.0\. Therefore, the index returned by
    `Select` reflects the true purchase probability for the item.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着产品 0 大约有 50% 的概率被购买，而产品 4 只有 3% 的概率被购买。总和是 1.0，即 100%。现在，选择一个随机值 *t ∈* [0,
    1)。这将有一半时间小于 0.5，意味着 `Select` 将返回索引 0。前两个产品概率的总和是 0.5 + 0.3 = 0.8。但是一半时间 *t* <
    0.5，因此 0.5 和 0.8 之间的差异是 0.5 > *t ≤* 0.8 的时间段：30% 的时间。类似地，10% 的时间 0.8 > *t ≤* 0.9，7%
    的时间 0.9 > *t ≤* 0.97，3% 的时间 0.97 > *t ≤* 1.0。因此，`Select` 返回的索引反映了该项目的真实购买概率。
- en: '[Figure 5-10](ch05.xhtml#ch05fig10) shows a single impulse purchase product.
    In reality, the simulation selects three unique impulse products that aren’t the
    target product ➋. The call to `argsort` returns a permutation of the product indices,
    so keeping the first three ensures unique products. The `while` loop repeats the
    process, if necessary, to ensure that the target isn’t one of the impulse purchases.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-10](ch05.xhtml#ch05fig10) 显示了一个单一的冲动购买产品。实际上，模拟选择了三个独特的冲动购买产品，它们不是目标产品
    ➋。`argsort` 的调用返回产品索引的排列，因此保持前三个确保了唯一的产品。`while` 循环在必要时重复此过程，以确保目标不是冲动购买之一。'
- en: When evaluating a particle position, we call the `GoShopping` method. It’s passed
    a list of `products`, the sort order for the current particle. It then walks through
    the list, checking if the current product is the target or one of the impulse
    buys. If it is either, the method adds the price to `spent` to indicate that the
    shopper purchased the item. If the item is the target, the loop exits, and any
    unencountered impulse products are ignored ➌. The method then returns the total
    spent.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估粒子位置时，我们调用 `GoShopping` 方法。它接收一个 `products` 列表，这是当前粒子的排序顺序。然后它遍历列表，检查当前产品是否为目标或冲动购买之一。如果是，方法将价格添加到
    `spent` 中，表示购物者购买了该商品。如果是目标商品，则循环退出，任何未遇到的冲动购买商品将被忽略 ➌。方法最后返回总消费金额。
- en: The `Shopper` class represents a single shopper. The `Objective` class manages
    a collection of shoppers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shopper` 类表示一个单独的购物者。`Objective` 类管理购物者集合。'
- en: '***The Objective Function***'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***目标函数***'
- en: The `Objective` class evaluates a single particle position, or a configuration
    of products, as shown in [Listing 5-12](ch05.xhtml#ch05list012).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`Objective` 类评估一个单一粒子位置，或者说是一种产品配置，如 [清单 5-12](ch05.xhtml#ch05list012) 所示。'
- en: '[PRE23]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 5-12: The* Objective *function class*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-12：* 目标 *函数类*'
- en: The constructor builds a list of randomly initialized shoppers, meaning we use
    the same collection of shoppers for the entire simulation. Here, `pci` is the
    probability of each product being selected, most probable first, and `pv` is the
    associated price.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数构建了一个随机初始化的购物者列表，这意味着我们在整个模拟过程中使用相同的购物者集合。这里，`pci` 是每个产品被选择的概率，按概率从高到低排列，`pv`
    是相关的价格。
- en: The `Evaluate` method receives a single particle position; however, we aren’t
    interested in `p`’s values, only the `order` in which they need to be moved to
    sort them ➊. This is the product order `GoShopping` uses to determine how much
    money the shopper spends. To get the total revenue, then, each shopper is asked
    to go shopping while tallying the amount of money spent (`revenue`). The objective
    function value is the negative of this amount (to maximize).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evaluate` 方法接收一个单一的粒子位置；然而，我们并不关心 `p` 的值，而是关心它们需要按什么顺序进行移动以对其进行排序 ➊。这就是 `GoShopping`
    用来确定购物者花费多少钱的产品顺序。为了得到总收入，每个购物者都被要求去购物并统计花费的金额（`revenue`）。目标函数的值是该金额的负值（为了最大化）。'
- en: 'The remainder of *store.py* loads the products and then parses the command
    line:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*store.py* 的其余部分加载产品并解析命令行：'
- en: '[PRE24]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code then creates the list of purchase probabilities (`pci`)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后代码创建购买概率列表（`pci`）。
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'before initializing the swarm and running the search:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化群体并运行搜索之前：
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The remainder of the file generates a report showing how successful the search
    was.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的其余部分生成一份报告，显示搜索的成功程度。
- en: '***The Shopping Simulation***'
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***购物模拟***'
- en: 'Enough prep; let’s run and see what output we get:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的准备工作；让我们运行看看会得到什么输出：
- en: '[PRE27]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code expects the number of shoppers to simulate (`250`), the number of particles
    (`20`) and iterations (`200`), the algorithm (`pso`), and a randomness source
    (`mt19937`). The output prints to the screen.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要模拟的购物者数量（`250`）、粒子数量（`20`）和迭代次数（`200`）、算法（`pso`）以及随机源（`mt19937`）。输出会显示在屏幕上。
- en: First, we’re told this run generated $1,114.28 as the maximum daily revenue.
    The product order is as given, where the first product is at the front of the
    store, here cream cheese (strangely). The order provides the product name, the
    probability of purchasing it, and the price.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们被告知这次运行的最大日收入为$1,114.28。产品顺序如下所示，其中第一款产品位于商店前端，这里是奶油奶酪（奇怪的是）。该顺序提供了产品名称、购买概率和价格。
- en: Conventional wisdom says to put the milk at the back of the store and the candy
    at the front. In this case, milk ended up as product 23, which is at the back
    of the store, while candy was product 3, very close to the front. This run followed
    conventional wisdom—a good sign.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 传统智慧告诉我们将牛奶放在商店的后面，糖果放在前面。在这个案例中，牛奶最终成为了第23号产品，位于商店的后部，而糖果则是第3号产品，靠近前部。此次运行遵循了传统智慧——这是一个好兆头。
- en: 'The remainder of the output gives the median purchase probability for products
    in the first half of the store along with the median price for those products,
    and then again for products in the second half of the store. If the swarm is ordering
    the store along the lines we expect it to, then lower probability items that cost
    more will appear in the front part of the store (the top half of the product list).
    At the same time, higher probability items that generally cost less will appear
    toward the back of the store. This is precisely what we see in the output: items
    toward the back are more likely to be purchased and, in general, cost less.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的其余部分给出了商店前半部分产品的中位购买概率以及这些产品的中位价格，然后是商店后半部分产品的同样数据。如果商群按照我们预期的方式排列商店，那么价格较高的低概率商品会出现在商店的前部（产品列表的前半部分）。与此同时，通常价格较低的高概率商品则会出现在商店的后部。这正是我们在输出中看到的：后部的商品更可能被购买，而且通常价格较低。
- en: Overall, the search produced reasonable output validating conventional wisdom.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，搜索产生了合理的输出，验证了传统智慧。
- en: The script *go_store* runs 10 searches for each algorithm capturing the results
    in the *output* directory. Run it with
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本*go_store*对每个算法进行10次搜索，将结果保存在*output*目录中。可以通过以下命令运行它：
- en: '[PRE28]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'then follow with *process_results.py*:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后继续使用*process_results.py*：
- en: '[PRE29]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This should produce a *results* directory that contains NumPy files (*.npy*)
    holding the milk and candy rankings for each algorithm and run, along with the
    best revenue for each run by algorithm. Also included is a plot tracking the milk
    and candy rankings across runs for each algorithm; see [Figure 5-11](ch05.xhtml#ch05fig11).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成一个*results*目录，其中包含NumPy文件（*.npy*），存储每个算法和运行的牛奶和糖果排名，以及每次运行的最佳收入。同时，还包括一张图，展示了每个算法在不同运行中的牛奶和糖果排名；请参见[图
    5-11](ch05.xhtml#ch05fig11)。
- en: '![Image](../images/05fig11.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig11.jpg)'
- en: '*Figure 5-11: Product rankings by algorithm across 10 runs, in which solid
    circles are milk and open circles are candy*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-11：各算法在10次运行中的产品排名，其中实心圆表示牛奶，空心圆表示糖果*'
- en: In the figure, solid circles represent where milk ended up in the rankings,
    and open circles are for candy. Almost all algorithms were able to put milk near
    the very back of the store, with both PSO variants and Jaya perhaps the most consistent
    (for this single run of *go_store*). An obvious exception is RO. While it managed
    to put milk behind candy on every run, at times the placement wasn’t particularly
    great. For example, in run 9, milk and candy were almost next to each other.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，实心圆表示牛奶在排名中的位置，空心圆则表示糖果的位置。几乎所有算法都能将牛奶放在商店的最靠后的位置，PSO的两种变体和Jaya可能是最一致的（对于这次*go_store*的单次运行）。一个明显的例外是RO。尽管它每次运行都能将牛奶排在糖果后面，但有时位置并不理想。例如，在第9次运行中，牛奶和糖果几乎紧挨在一起。
- en: 'The *process_results.py* code also outputs a summary. For example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*process_results.py*代码还会输出一个摘要。例如：'
- en: '[PRE30]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first part shows the mean revenue across the 10 runs by algorithm. The standard
    error of the mean (standard deviation divided by the square root of the number
    of samples, here 10) is in parentheses. Bare-bones PSO is the winner, averaging
    a daily revenue of $1,148.59 compared with RO’s meager performance of $1,023.75.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分展示了不同算法在10次运行中的平均收入。平均值的标准误（标准差除以样本数量的平方根，这里是10）放在括号中。最简版PSO是赢家，平均日收入为$1,148.59，相比之下，RO的收入仅为$1,023.75。
- en: The right-hand part of the output requires some explanation. I wanted to compare
    the revenue across runs by algorithm. The code locates the highest performing
    algorithm, bare-bones PSO in this case, and runs a t-test with it against the
    others. A *t-test* is a hypothesis test that asks whether two datasets are plausibly
    from the same data generating process. The value shown is the p-value, the probability
    of the observed difference in the means and standard deviations of the two datasets
    (or greater), given they are from the same data generating process. If the p-value
    is high, then the two data-sets are likely from the same data generating process,
    meaning the test’s null hypothesis is likely valid. In this case, the bare-bones
    PSO result is not meaningfully different from the GWO result, because the p-value
    is 0.36.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的右侧部分需要一些解释。我想比较不同算法在各次运行中的收入。代码找出了表现最好的算法，在这种情况下是最简版PSO，并与其他算法进行t检验。*t检验*是一种假设检验，用于判断两个数据集是否可能来自相同的数据生成过程。显示的值是p值，它表示在假设两个数据集来自同一数据生成过程的前提下，观察到的均值和标准差差异（或更大）的概率。如果p值较高，那么这两个数据集很可能来自同一个数据生成过程，这意味着检验的原假设可能有效。在这种情况下，最简版PSO的结果与GWO的结果没有显著差异，因为p值为0.36。
- en: The smaller the p-value, the more likely that the results aren’t from the same
    data generating process. For RO and GA, the p-values are very low, giving us confidence
    that the bare-bones PSO result is better. However, the other p-values are also
    low. So, is bare-bones PSO head and shoulders above all the others for this task,
    or was it just lucky this time around?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: p值越小，结果越可能不是来自同一个数据生成过程。对于RO和GA，p值非常低，这让我们确信最简版PSO的结果更好。然而，其他算法的p值也很低。那么，最简版PSO是否真的在这项任务中远超其他算法，还是这次仅仅是运气好呢？
- en: To find out, I ran *go_store* five more times and accumulated the output of
    *process_results.py* in the *results_per_run.txt* file. The best-performing algorithm
    varied across runs, but there were trends. For three of the six runs, Jaya was
    the top performer; for two, it was bare-bones PSO; and for one, GWO. The GA and
    RO results were always the worst. Looking at the p-values from the t-tests, Jaya,
    bare-bones PSO, and GWO are good algorithms to use for this task, with likely
    no meaningful difference between Jaya and bare-bones PSO.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出答案，我再次运行了*go_store*五次，并将*process_results.py*的输出累积到*results_per_run.txt*文件中。每次运行的最佳算法有所不同，但还是有一些趋势。在六次运行中，有三次Jaya表现最好；两次是最简版PSO；一次是GWO。GA和RO的结果总是最差的。通过t检验的p值来看，Jaya、最简版PSO和GWO是适用于这个任务的优秀算法，且Jaya和最简版PSO之间可能没有显著差异。
- en: The products in *products.pkl* are arranged in decreasing order of purchase
    probability but increasing order of price, meaning the least likely product to
    be purchased is the most expensive and vice versa. Therefore, we might expect
    to maximize profit by arranging the products so the least likely but most expensive
    is first and the most likely, least costly is last, at the back of the store.
    The order generated by a run of *store.py* is the swarm’s attempt to meet this
    ideal.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*products.pkl*中的产品是按照购买概率递减的顺序排列，同时价格是递增的顺序，这意味着最不可能购买的产品是最贵的，反之亦然。因此，我们可能期望通过将产品按以下方式排序来最大化利润：最不可能购买但最贵的产品排在前面，而最可能购买、最便宜的产品排在最后，放在店铺的最远端。*store.py*的运行结果是群体试图实现这一理想排序的结果。'
- en: Run *product_order.py*, passing it an output directory (*output* created by
    *go_store*) followed by another directory name, like *orders*. You’ll generate
    a collection of plots, one for each algorithm, showing the mean value of each
    product slot, from 0 through 23, for all 10 runs of each algorithm. Also plotted
    is the curve reflecting the ideal product ordering, the reverse of the product
    order in *products.pkl*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*product_order.py*，传入一个输出目录（*go_store*创建的*output*）以及另一个目录名，比如*orders*。你将生成一系列图表，每个算法一个，显示每个产品位置的均值，从0到23，涵盖每个算法的10次运行。同时，还会绘制反映理想产品排序的曲线，即*products.pkl*中的产品顺序的反向排序。
- en: '[Figure 5-12](ch05.xhtml#ch05fig12) shows the mean product cost by position
    in the store over 10 runs of each algorithm compared to the ideal ordering (smooth
    curve).'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig12.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-12: Comparing the mean swarm value by product order to the ideal.
    From top left to right: bare-bones PSO, DE, GA, GWO, Jaya, canonical PSO, RO.*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: First, note that in no way did the swarm search seek to match the ideal sequence.
    Instead, any match is an emergent effect of the swarms’ attempts to maximize daily
    profit.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Second, all algorithms except RO were effective at matching the order of the
    cheapest products. We also see this in [Figure 5-11](ch05.xhtml#ch05fig11) by
    the consistency of milk placement compared to candy. Most of the variation between
    algorithms is in the order of the first few products. We also see this in the
    larger error bars for products near the front of the store compared to those at
    the back.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The placement of products near the front of the store might be more difficult
    because those products are the least often purchased. Both bare-bones PSO and
    Jaya did reasonably well with more expensive products, but one could argue that
    GWO more closely matched the ideal curve. This tells us that the differences between
    algorithms are subtle, at least when viewed in this fashion, though GA was nearly
    as poor at matching the early product order as RO.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Had enough of swarm algorithms? Me neither. Here’s more to explore and contemplate:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '*Circles.py* used `enforce="clip"` to pack circles. Change this to `enforce=
    "resample"`. If the results are suddenly different, why?'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packing circles in a square is a similar problem to packing spheres in a cube.
    Modify a copy of *circles.py* to pack spheres in a cube, making a 2D problem a
    3D problem. Run your code and compare it to the numbers in *sphere_dmin.png*.
    If you get stuck, take a peek at *spheres.py*.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing cell towers on an empty map returns (primarily) non-overlapping towers.
    What sort of output do you get from *cell.py* if the map is particularly busy
    with relatively few allowed locations? You can make your own map or give *map_busy.png*
    in the *maps* directory a try. Can the swarm algorithms find places for the towers?
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *enhance.py* file manipulates grayscale images. Modify it to enhance RGB
    images instead. A crude approach is in the file *process_rgb_images.py* in the
    *rgb* directory. This directory also contains some RGB images (*original*). Does
    *process_rgb_images.py* consistently produce good results? Why? Implement a new
    version that doesn’t enhance channels independently, but instead seeks a set of
    parameters that work best across all channels, perhaps by summing *F* per channel.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify *enhance.py* to use `ddof=0` instead of `ddof=1`—to use the biased variance
    and not the unbiased. Do you notice any difference in the results?
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The grocery store simulation used the same collection of shoppers for each iteration
    of the swarm. What happens to the results if the collection of shoppers is regenerated
    before each iteration? Do you expect this to make a difference?
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杂货店仿真中，每次群体的迭代都使用相同的购物者集合。如果在每次迭代前重新生成购物者集合，结果会如何？你认为这会有什么影响吗？
- en: The simulation results presented in the grocery store simulation used 250 shoppers.
    What happens to my claim that Jaya and bare-bones PSO are well suited to the task
    if there are only five shoppers? Ten? Fifty?
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在杂货店仿真中，模拟结果使用了250个购物者。如果购物者数量减少到只有五个？十个？五十个？我所说的Jaya和基础PSO算法非常适合这个任务的论点会受到什么影响？
- en: '**Summary**'
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter continued our exploration of swarm optimization algorithms. We
    learned how to pack circles in squares, place cell towers while avoiding restricted
    locations, implement a “make it pretty” filter, and mix optimization and simulation
    to develop a product placement plan for a grocery store.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续探索群体优化算法。我们学习了如何将圆形物体放入正方形中、在避免限制区域的同时放置手机信号塔、实现“美化”过滤器，以及将优化与仿真相结合，开发杂货店的产品布局计划。
- en: We did all this using the same collection of algorithms. We didn’t change a
    single swarm intelligence or evolutionary algorithm to adapt it to the problem.
    Instead, casting the problem in the proper form enabled the direct application
    of the algorithms. This is a powerful ability that’s widely applicable. Many processes
    in the real world are, in the end, optimization problems, meaning swarm algorithms
    likely have a role to play. They are general-purpose algorithms, as are many machine
    learning algorithms to which we now turn.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的算法集合完成了所有这些工作。我们没有改变任何一个群体智能或进化算法来适应问题。相反，将问题转化为适当的形式使得算法能够直接应用。这是一种广泛适用的强大能力。现实世界中的许多过程，归根结底，都是优化问题，这意味着群体算法可能有它的作用。它们是通用算法，就像许多我们现在要讨论的机器学习算法一样。
- en: The experiments in this chapter and the previous one introduced a powerful approach
    to general optimization problems. If we can cast the problem as finding the best
    position in a multidimensional space where each point represents a possible solution,
    then swarm intelligence and evolutionary algorithms are likely applicable. I can’t
    emphasize enough the usefulness of this concept.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 本章及前一章的实验介绍了一种强大的通用优化问题方法。如果我们能够将问题转化为在一个多维空间中寻找最佳位置，其中每个点代表一个可能的解，那么群体智能和进化算法可能是适用的。我无法过分强调这一概念的有用性。
- en: 'We used a simple framework supporting a handful of standard swarm algorithms,
    of which there are hundreds to choose from—though not all are created equal. We
    designed the framework to be easy to use and pedagogical instead of performant.
    The framework acts as a stepping stone to more sophisticated tools, should you
    often return to swarm algorithms. If that’s the case, then consider exploring
    more advanced toolkits like these:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个简单的框架，支持少量的标准群体算法，而实际上有数百种算法可供选择——不过并非所有算法都等同。我们设计这个框架的目的是让它易于使用且具教学性，而非性能优越。这个框架是通向更复杂工具的垫脚石，如果你经常使用群体算法，应该考虑探索像这样的高级工具包：
- en: '**inspyred**   *[https://pythonhosted.org/inspyred](https://pythonhosted.org/inspyred)*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**inspyred**   *[https://pythonhosted.org/inspyred](https://pythonhosted.org/inspyred)*'
- en: '**pyswarms**   *[https://github.com/ljvmiranda921/pyswarms](https://github.com/ljvmiranda921/pyswarms)*'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**pyswarms**   *[https://github.com/ljvmiranda921/pyswarms](https://github.com/ljvmiranda921/pyswarms)*'
- en: '**DEAP**   *[https://github.com/DEAP/deap](https://github.com/DEAP/deap)*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**DEAP**   *[https://github.com/DEAP/deap](https://github.com/DEAP/deap)*'
- en: 'These toolkits support multiple swarm algorithms, both swarm intelligence and
    evolutionary, and are designed for performance. Toolkits for other languages include:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具包支持多种群体算法，包括群体智能和进化算法，并且针对性能进行了优化。其他语言的工具包包括：
- en: '**Java**   *[https://cs.gmu.edu/~clab/projects/ecj](https://cs.gmu.edu/~clab/projects/ecj)*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**   *[https://cs.gmu.edu/~clab/projects/ecj](https://cs.gmu.edu/~clab/projects/ecj)*'
- en: '**C++**   *[https://eodev.sourceforge.net](https://eodev.sourceforge.net)*'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++**   *[https://eodev.sourceforge.net](https://eodev.sourceforge.net)*'
- en: Swarm algorithms will make another appearance in [Chapter 7](ch07.xhtml), but
    for now, we’ll explore randomness in the world of artificial intelligence.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 群体算法将在[第七章](ch07.xhtml)中再次出现，但现在，我们将探索人工智能世界中的随机性。
