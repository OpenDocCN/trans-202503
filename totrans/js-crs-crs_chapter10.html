<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>JavaScript Crash Course</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:26ab05bf-a247-42ca-b08d-ede069333d2b" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch10" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch10">
<span class="CN"><span aria-label=" Page 159. " epub:type="pagebreak" id="pg_159" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">PONG</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.png"/>
</figure>
<p class="INTROTNI2">In this first project, you’ll use JavaScript to re-create one of the first arcade video games: the classic <i>Pong</i> from Atari. <i>Pong</i> is a simple game, but it will teach you some important aspects of game design: a game loop, player input, collision detection, and score keeping. We’ll even use some basic artificial intelligence to program the computer opponent.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-51"/><samp class="SANS_Futura_Std_Bold_B_11">The Game</samp></h3>
<p class="TNI1"><i>Pong</i> was developed in 1972 and was released that year as a hugely successful arcade machine. It’s a very basic game, like table tennis, consisting of a ball and two paddles positioned on the left and right sides of the screen, which the players can move up and down. If the ball hits the top or bottom edge of the screen, it bounces off, but if it hits the left or right edge the player on the opposite side scores a point. The ball bounces off the paddles normally, <span aria-label=" Page 160. " epub:type="pagebreak" id="pg_160" role="doc-pagebreak"/>unless it hits near the top or bottom edge of the paddle, in which case the angle of return changes.</p>
<p class="TX">In this chapter we’ll make our own version of <i>Pong</i>, which we’ll call <i>Tennjs</i> (like <i>Tennis</i> but with <i>JS</i>, get it?). In our game, the left paddle will be controlled by the computer and the right paddle will be controlled by a human player. In the original game, the paddles were controlled with rotating dial controllers, but in our version we’ll use the mouse. The computer, rather than trying to anticipate where the ball will bounce, will just attempt to always match the vertical position of the ball. In order to give the human player a chance, we’ll set an upper limit on how fast the computer can move the paddle.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><span id="h1-52"/><samp class="SANS_Futura_Std_Bold_B_11">Setup</samp></h3>
<p class="TNI1">We’ll begin by setting up the project’s file structure and creating a canvas for displaying the game. As usual, the project will require an HTML file and a JavaScript file. We’ll start with the HTML file. Create a directory called <i>tennjs</i> and a file in that directory called <i>index.html</i>. Then enter the content shown in <a href="#Lis10-1">Listing 10-1</a>.</p>
<span id="Lis10-1"/>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Tennjs&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id="canvas" width="300" height="300"&gt;&lt;/canvas&gt;
    &lt;script src="script.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: The</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file for our game</samp></p>
<p class="TX">This is almost exactly the same as the HTML file we created in <a href="chapter9.xhtml">Chapter 9</a>, so there should be no surprises. The <span class="SANS_TheSansMonoCd_W5Regular_11">body</span> element includes a <span class="SANS_TheSansMonoCd_W5Regular_11">canvas</span> element, where we’ll draw the game, and a <span class="SANS_TheSansMonoCd_W5Regular_11">script</span> element referencing the file <i>script.js</i>, where our game code will live.</p>
<p class="TX">Next, we’ll write some JavaScript to set up the canvas. Create the file <i>script.js</i>, and enter the code shown in <a href="#Lis10-2">Listing 10-2</a>.</p>
<span id="Lis10-2"/>
<pre><code>let canvas = document.querySelector("#canvas");
let ctx = canvas.getContext("2d");
let width = canvas.width;
let height = canvas.height;

ctx.fillStyle = "black";
ctx.fillRect(0, 0, width, height);
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Setting up the canvas in</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp></p>
<p class="TX">This code should also be familiar. We first get a reference to the canvas with <span class="SANS_TheSansMonoCd_W5Regular_11">document.querySelector</span> and get the canvas’s drawing context. Then we <span aria-label=" Page 161. " epub:type="pagebreak" id="pg_161" role="doc-pagebreak"/>save the width and height of the canvas to variables called <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> for easy access within the code. Finally, we set the fill style to black and draw a black square the size of the canvas. This way the canvas appears to have a black background.</p>
<p class="TX">Open <i>index.html</i> in your browser, and you should see something like <a href="chapter10.xhtml#fig10-1">Figure 10-1</a>.</p>
<figure class="IMG"><img alt="" class="img6" id="fig10-1" src="../images/Figure_10-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: Our black square</samp></p></figcaption>
</figure>
<p class="TX">We now have a blank, black canvas where we can create our game.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H1" id="sec3"><span id="h1-53"/><samp class="SANS_Futura_Std_Bold_B_11">The Ball</samp></h3>
<p class="TNI1">Next, we’ll draw the ball. Add the code in <a href="#Lis10-3">Listing 10-3</a> to the end of <i>script.js</i>.</p>
<span id="Lis10-3"/>
<pre><code><var>--snip--</var>
<span class="gray">ctx.fillStyle =</span><span class="gray"> "black";</span>
<span class="gray">ctx.fillRect(0, 0, width, height);</span>

const BALL_SIZE = 5;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> let ballPosition = {x: 20, y: 30};

ctx.fillStyle = "white";
ctx.fillRect(ballPosition.x, ballPosition.y, BALL_SIZE, BALL_SIZE);
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: Drawing the ball</samp></p>
<p class="TX">This code uses the <span class="SANS_TheSansMonoCd_W5Regular_11">fillRect</span> method to draw the ball as a small white square near the top-left corner of the canvas. As in the original <i>Pong</i> game, the ball is a square rather than a circle. This gives the game a retro feel, and it will also simplify the task of detecting when the ball has collided with the walls or with a paddle. The size of the ball is stored in a constant called <span class="SANS_TheSansMonoCd_W5Regular_11">BALL_SIZE</span>. We use the “true constant” all-caps style for the identifier name <span aria-label=" Page 162. " epub:type="pagebreak" id="pg_162" role="doc-pagebreak"/>because the ball size won’t change during the course of the program. We could just use the value <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> instead of the constant <span class="SANS_TheSansMonoCd_W5Regular_11">BALL_SIZE</span> when we call the <span class="SANS_TheSansMonoCd_W5Regular_11">fillRect</span> method to draw the ball, but we’re going to end up needing to refer to the ball’s size a lot more throughout the program. Giving the size a name will make it much easier to understand code that needs to know the size of the ball. The other good thing about this approach is that if we change our mind later and decide the ball should be bigger or smaller, we have to update the code in only place: the declaration of the <span class="SANS_TheSansMonoCd_W5Regular_11">BALL_SIZE</span> constant.</p>
<p class="TX">We keep track of the ball’s position with an object containing its x- and y-coordinates, created using an object literal <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. In <a href="chapter9.xhtml">Chapter 9</a> we used separate variables for the x- and y-coordinates of the circle that was being drawn, but it’s a bit tidier to store the two variables together as one object, especially since this program is going to be longer and more complex.</p>
<p class="TX">Refresh <i>index.html</i> and you should see the white ball sitting in the top-left corner of the canvas, as shown in <a href="chapter10.xhtml#fig10-2">Figure 10-2</a>.</p>
<figure class="IMG"><img alt="" class="img6" id="fig10-2" src="../images/Figure_10-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: The ball</samp></p></figcaption>
</figure>
<p class="TX">The ball is stationary for now, but soon enough we’ll write code to make it move.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H1" id="sec4"><span id="h1-54"/><samp class="SANS_Futura_Std_Bold_B_11">Refactoring</samp></h3>
<p class="TNI1">Next we’re going to do a simple refactor. <i>Refactoring</i> is a software development term for modifying some code without changing its behavior, usually to make the code easier to understand or update. As the code for a project grows more complex, refactoring can help keep it organized.</p>
<p class="TX">In this case, I know that we’re going to want to draw to the canvas multiple times, not just once. In fact, we’ll eventually want to redraw the canvas once every 30 ms to give our game the appearance of motion. To make that easier to accomplish, we’ll refactor so all the current drawing code becomes <span aria-label=" Page 163. " epub:type="pagebreak" id="pg_163" role="doc-pagebreak"/>part of a function called <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span>. That way we can simply call the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> function anytime we want to redraw the canvas.</p>
<p class="TX">Update <i>script.js</i> with the changes shown in <a href="#Lis10-4">Listing 10-4</a>.</p>
<span id="Lis10-4"/>
<pre><code><span class="gray">let canvas = document.querySelector("#canvas");</span>
<span class="gray">let ctx = canvas.getContext("2d");</span>
<span class="gray">let width = canvas.width;</span>
<span class="gray">let height = canvas.height;</span>

<span class="gray">const BALL_SIZE =</span><span class="gray"> 5;</span>
<span class="gray">let ballPosition = {x: 20, y: 30};</span>

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> function draw() {
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, width, height);

  ctx.fillStyle = "white";
  ctx.fillRect(ballPosition.x, ballPosition.y, BALL_SIZE, BALL_SIZE);
}

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> draw();
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: Refactoring the drawing code</samp></p>
<p class="TX">The only change here is to group all the drawing code into a single function called <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, which we then immediately call <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Because it’s a refactoring, nothing actually changes in the behavior of the program. You can refresh <i>index.html</i> to confirm that everything still looks as before.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="h1-55"/><samp class="SANS_Futura_Std_Bold_B_11">The Game Loop</samp></h3>
<p class="TNI1">Almost all games contain a <i>game loop</i> that orchestrates everything that has to happen for each frame of the game. Game loops are similar to animation loops, like the one we looked at in <a href="chapter9.xhtml">Chapter 9</a>, but with some additional logic. Here’s the general shape of the game loop in most games:</p>
<div class="top">
<p class="NL">  1.  Clear canvas</p>
<p class="NL">  2.  Draw image</p>
<p class="NL">  3.  Get player input</p>
<p class="NL">  4.  Update state</p>
<p class="NL">  5.  Check collisions</p>
<p class="NL">  6.  Wait a short time</p>
<p class="NL">  7.  Repeat</p>
</div>
<p class="TX">Getting and acting on input from a player (or players) is the main thing that distinguishes a game from an animation. <i>Collision detection</i> is another important aspect of most games: checking for when two objects in the game meet and responding accordingly. Collision detection is what stops you from walking through walls or driving through another car—and in this <span aria-label=" Page 164. " epub:type="pagebreak" id="pg_164" role="doc-pagebreak"/>case, it’s what will make the ball bounce off the walls and paddles. Apart from the player input and collision detection elements, the steps in the game loop are more or less the same as in an animation loop: we clear the canvas, draw the image, update the state of the game to move objects to their new positions, pause, and repeat.</p>
<p class="TX">Rather than trying to write the whole game loop at once, we’ll build it up gradually. Update <i>script.js</i> with the content in <a href="#Lis10-5">Listing 10-5</a>, which will be the beginnings of the game loop in our game. This code moves the ball (that is, updates the ball’s state), redraws the canvas, pauses, and repeats.</p>
<span id="Lis10-5"/>
<pre><code><var>--snip--</var>
<span class="gray">const BALL_SIZE = 5;</span>
<span class="gray">let ballPosition = {x: 20, y: 30};</span>

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> let xSpeed = 4;
let ySpeed = 2;

<span class="gray">function draw() {</span>
<span class="gray">  ctx.fillStyle = "black";</span>
<span class="gray">  ctx.fillRect(0, 0, width, height);</span>

<span class="gray">  ctx.fillStyle = "white";</span>
<span class="gray">  ctx.fillRect(ballPosition.x, ballPosition.y, BALL_SIZE, BALL_SIZE);</span>
<span class="gray">}</span>

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> function update() {
  ballPosition.x += xSpeed;
  ballPosition.y += ySpeed;
}

<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> function gameLoop() {
  draw();
  update();

    // Call this function again after a timeout
  setTimeout(gameLoop, 30);
}

<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> gameLoop();
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: The game loop</samp></p>
<p class="TX">The first change here is to initialize two new variables <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span>. We’ll use these to control the horizontal and vertical speed of the ball. The new <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> uses these two variables to update the position of the ball. For every frame, the ball will move <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> pixels along the x-axis and <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> pixels along the y-axis. The two variables start out at <span class="SANS_TheSansMonoCd_W5Regular_11">4</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>, so every frame the ball will move 4 pixels to the right and 2 pixels down.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span> function <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> calls the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> function followed by the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function. Then it calls <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout(gameLoop, 30)</span>, which will call the <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span> function again after 30 ms. This is almost exactly the same as the <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span> technique we used in <a href="chapter9.xhtml">Chapter 9</a>. You may recall that <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> calls its <span aria-label=" Page 165. " epub:type="pagebreak" id="pg_165" role="doc-pagebreak"/>function only once after the timeout, while <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span> calls its function repeatedly. We’re using <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> here so we have more control over whether or not to keep looping; later on we’ll add some conditional logic to either call <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> or end the game.</p>
<p class="TX">Notice the line above the <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> call beginning with two slashes (<span class="SANS_TheSansMonoCd_W5Regular_11">//</span>). This is an example of a <i>comment</i>, a note for yourself (or other people reading your code) embedded in the program file. When a JavaScript program executes, any text on a line following a <span class="SANS_TheSansMonoCd_W5Regular_11">//</span> is ignored (anything on the line before the <span class="SANS_TheSansMonoCd_W5Regular_11">//</span> is still evaluated as JavaScript code). Thus, you can use comments like this to explain how the code works, highlight important features, or make note of something you still need to do, without affecting the functionality of the program.</p>
<p class="TX">At the end of the script, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span> function <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> to set the game in motion. Since <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span> currently ends with <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span>, the result is that <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span> will be repeatedly called once every 30 ms. Reload your page and you should see the ball move down and to the right, much like the animation from <a href="chapter9.xhtml">Chapter 9</a>.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H1" id="sec6"><span id="h1-56"/><samp class="SANS_Futura_Std_Bold_B_11">Bouncing</samp></h3>
<p class="TNI1">In the previous section you got the ball moving, but it just flew off the edge of the canvas. Next you’ll learn how to make it bounce off the edge of the canvas at the appropriate angle—our first collision detection code. Update <i>script.js</i> with the code in <a href="#Lis10-6">Listing 10-6</a>, which adds a <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> function to our game.</p>
<span id="Lis10-6"/>
<pre><code><var>--snip--</var>
<span class="gray">function update() {</span>
<span class="gray">  ballPosition.x += xSpeed;</span>
<span class="gray">  ballPosition.y += ySpeed;</span>
<span class="gray">}</span>

function checkCollision() {
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> let ball = {
    left: ballPosition.x,
    right: ballPosition.x + BALL_SIZE,
    top: ballPosition.y,
    bottom: ballPosition.y + BALL_SIZE
  }

<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if (ball.left &lt; 0 || ball.right &gt; width) {
    xSpeed = -xSpeed;
  }
<span aria-label="annotation3" class="CodeAnnotationCode">❸</span> if (ball.top &lt; 0 || ball.bottom &gt; height) {
    ySpeed = -ySpeed;
  }
}

<span class="gray">function gameLoop() {</span>
<span class="gray">  draw();</span>
<span class="gray">  update();</span>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> checkCollision();

<span aria-label=" Page 166. " epub:type="pagebreak" id="pg_166" role="doc-pagebreak"/><span class="gray">  // Call this function again after a timeout</span>
<span class="gray">  setTimeout(gameLoop, 30);</span>
<span class="gray">}</span>

<span class="gray">gameLoop();</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: Wall collision detection</samp></p>
<p class="TX">The new function, <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span>, checks to see if the ball has collided with one of the four walls of the canvas. If it has, it updates <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> as appropriate to make the ball bounce off the wall. First, we calculate values for the edges of the ball. We need to know where the left, right, top, and bottom edges are to determine if these edges have exceeded the bounds of the playing area. We group the values in an object called <span class="SANS_TheSansMonoCd_W5Regular_11">ball</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> that has <span class="SANS_TheSansMonoCd_W5Regular_11">left</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">right</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">top</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">bottom</span> properties. Identifying the left and top ball edges is easy: they’re <span class="SANS_TheSansMonoCd_W5Regular_11">ballPosition.x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ballPosition.y</span>, respectively. To get the right and bottom edges, we add <span class="SANS_TheSansMonoCd_W5Regular_11">BALL_SIZE</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">ballPosition.x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ballPosition.y</span>. This is one of those cases noted earlier where having access to the ball’s size as a constant is helpful.</p>
<p class="TX">Next, we perform the actual collision detection. If the left edge of the ball is less than <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> or the right edge of the ball is greater than the width of the canvas <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, we know that the ball has hit the left or right wall. In both cases, the math is the same: the new value of <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> should be the negative of the current value (that is, the value is <i>negated</i>). For example, the first time the ball hits the right edge, <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> will go from <span class="SANS_TheSansMonoCd_W5Regular_11">4</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">-4</span>. Meanwhile, <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> remains unchanged. As a result, the ball continues moving down the screen at the same rate, but now it’s moving to the left instead of to the right.</p>
<p class="TX">The same kind of check happens for the top of the ball colliding with the top wall or the bottom of the ball colliding with the bottom wall <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. In either of these cases, we negate <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span>, changing it from <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">-2</span> when the ball hits the top edge, or from <span class="SANS_TheSansMonoCd_W5Regular_11">-2</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> when the ball hits the bottom edge.</p>
<p class="TX">The only other change to the code is to add a call to <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> to the list of things that happen in the <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span> function <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Now when you refresh <i>index.html</i>, you should see the ball continuously bounce around the play area.</p>
<p class="TX">If you’ve been paying attention, you might have noticed that the ball isn’t supposed to bounce off the left and right walls. Once we have moving paddles, we’ll modify the collision detection code to only bounce off the paddles or the top and bottom walls, and to score a point for a side wall collision.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><span id="h1-57"/><samp class="SANS_Futura_Std_Bold_B_11">The Paddles</samp></h3>
<p class="TNI1">Our next task is to draw the two paddles. To do that we’ll first introduce some new constants that establish the paddle dimensions and their horizontal position relative to the sides of the canvas, as well as some variables defining their vertical positions. (The paddles can only move up and down, not from side to side, so only their vertical positions need to be variables.) Update <i>script.js</i> with the changes in <a href="#Lis10-7">Listing 10-7</a>.</p>
<span id="Lis10-7"/>
<pre><code><span aria-label=" Page 167. " epub:type="pagebreak" id="pg_167" role="doc-pagebreak"/><var>--snip--</var>
<span class="gray">let xSpeed = 4;</span>
<span class="gray">let ySpeed = 2;</span>

const PADDLE_WIDTH = 5;
const PADDLE_HEIGHT = 20;
const PADDLE_OFFSET = 10;

let leftPaddleTop = 10;
let rightPaddleTop = 30;

<span class="gray">function draw() {</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: Defining the paddles</samp></p>
<p class="TX">First we set up the constants that define the paddles. <span class="SANS_TheSansMonoCd_W5Regular_11">PADDLE_WIDTH</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">PADDLE_HEIGHT</span> define both paddles to be 5 pixels wide and 20 pixels tall. <span class="SANS_TheSansMonoCd_W5Regular_11">PADDLE_OFFSET</span> refers to the distance of the paddle from the left or right edge of the playing area.</p>
<p class="TX">The variables <span class="SANS_TheSansMonoCd_W5Regular_11">leftPaddleTop</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">rightPaddleTop</span> define the current vertical position of the top of each paddle. Eventually, <span class="SANS_TheSansMonoCd_W5Regular_11">leftPaddleTop</span> will be controlled by the computer through a function we’ll write to follow the ball, and <span class="SANS_TheSansMonoCd_W5Regular_11">rightPaddleTop</span> will be updated when the player moves the mouse. For now, we’re simply setting these values to <span class="SANS_TheSansMonoCd_W5Regular_11">10</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">30</span>, respectively.</p>
<p class="TX">Next, we update the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> function to display the paddles using the information we just defined. I’ve also added comments to the code to clarify what’s happening at each step of the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> function. Modify the code as shown in <a href="#Lis10-8">Listing 10-8</a>.</p>
<span id="Lis10-8"/>
<pre><code><var>--snip--</var>
<span class="gray">function draw() {</span>
  // Fill the canvas with black
<span class="gray">  ctx.fillStyle = "black";</span>
<span class="gray">  ctx.fillRect(0, 0, width, height);</span>

  // Everything else will be white
<span class="gray">  ctx.fillStyle = "white";</span>

  // Draw the ball
<span class="gray">  ctx.fillRect(ballPosition.x, ballPosition.y, BALL_SIZE, BALL_SIZE);</span>

  // Draw the paddles
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> ctx.fillRect(
    PADDLE_OFFSET,
    leftPaddleTop,
    PADDLE_WIDTH,
    PADDLE_HEIGHT
  );
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> ctx.fillRect(
    width - PADDLE_WIDTH - PADDLE_OFFSET,
    rightPaddleTop,
<span aria-label=" Page 168. " epub:type="pagebreak" id="pg_168" role="doc-pagebreak"/>    PADDLE_WIDTH,
    PADDLE_HEIGHT
  );
<span class="gray">}</span>

<span class="gray">function update() {</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-8: Drawing the paddles</samp></p>
<p class="TX">In addition to some extra comments to help document the program, the new code features two calls to <span class="SANS_TheSansMonoCd_W5Regular_11">fillRect</span>, one for drawing the left paddle <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and one for the right <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. I’ve split the arguments over multiple lines because the identifiers are so long. Remember that the parameters to <span class="SANS_TheSansMonoCd_W5Regular_11">fillRect</span> are <span class="SANS_TheSansMonoCd_W5Regular_11">x</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">width</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span>, where <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> are the coordinates of the top-left corner of the rectangle. The x-coordinate of the left paddle is <span class="SANS_TheSansMonoCd_W5Regular_11">PADDLE_OFFSET</span> because we’re using that to mean the paddle’s distance from the left edge of the canvas, while the y-coordinate of the left paddle is just <span class="SANS_TheSansMonoCd_W5Regular_11">leftPaddleTop</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> arguments are the <span class="SANS_TheSansMonoCd_W5Regular_11">PADDLE_WIDTH</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">PADDLE_HEIGHT</span> constants.</p>
<p class="TX">The right paddle is a bit more complicated to draw: to get the x-coordinate of the paddle’s top-left corner, we need to take the width of the canvas and subtract the width of the paddle and the offset of the paddle from the right edge. Given that the width of the canvas is 500, and the paddle width and offset are both 10, that means the x-coordinate of the right paddle is 480.</p>
<p class="TX">When you refresh <i>index.html</i>, you should see the two paddles in addition to the bouncing ball, as shown in <a href="chapter10.xhtml#fig10-3">Figure 10-3</a>.</p>
<figure class="IMG"><img alt="" class="img6" id="fig10-3" src="../images/Figure_10-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: The paddles and ball</samp></p></figcaption>
</figure>
<p class="TX">Note that the ball currently passes straight through the paddles, because we haven’t set up collision detection for the paddles yet. We’ll get to that later in this section.</p>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="h2-62"/><span aria-label=" Page 169. " epub:type="pagebreak" id="pg_169" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Moving the Paddles with Player Input</samp></h4>
<p class="TNI1">The paddles are drawn at the vertical positions given by the variables <span class="SANS_TheSansMonoCd_W5Regular_11">leftPaddleTop</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">rightPaddleTop</span>, so to make the paddles move up and down, we just have to update the values of these variables. Right now we’re concerned only with the right paddle, which will be controlled by the human player.</p>
<p class="TX">To let the player control the right paddle, we’ll add an event handler to <i>script.js</i> that listens for <span class="SANS_TheSansMonoCd_W5Regular_11">mousemove</span> events. <a href="#Lis10-9">Listing 10-9</a> shows how it’s done.</p>
<span id="Lis10-9"/>
<pre><code><var>--snip--</var>
<span class="gray">let leftPaddleTop = 10;</span>
<span class="gray">let rightPaddleTop = 30;</span>

document.addEventListener("mousemove", e =&gt; {
  rightPaddleTop = e.y - canvas.offsetTop;
});

<span class="gray">function draw() {</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-9: Adding an event handler to move the right paddle</samp></p>
<p class="TX">This code follows the same pattern for event handling that you first saw in <a href="chapter8.xhtml">Chapter 8</a>. We use <span class="SANS_TheSansMonoCd_W5Regular_11">document.addEventListener</span> to check for mouse movements. When one is detected, the event handler function updates the value of <span class="SANS_TheSansMonoCd_W5Regular_11">rightPaddleTop</span> based on the y-coordinate of the <span class="SANS_TheSansMonoCd_W5Regular_11">mousemove</span> event (<span class="SANS_TheSansMonoCd_W5Regular_11">e.y</span>). The y-coordinate is relative to the top of the page, not the top of the canvas, so we subtract <span class="SANS_TheSansMonoCd_W5Regular_11">canvas.offsetTop</span> (the distance from the top of the canvas to the top of the page) from the y-coordinate. This way the assigned <span class="SANS_TheSansMonoCd_W5Regular_11">rightPaddleTop</span> value will be based on the distance of the mouse from the top of the canvas, and the paddle will follow the mouse accurately.</p>
<p class="TX">Refresh <i>index.html</i>, and you should see the right paddle move vertically as the mouse moves up and down. <a href="chapter10.xhtml#fig10-4">Figure 10-4</a> shows how it should look.</p>
<figure class="IMG"><img alt="" class="img6" id="fig10-4" src="../images/Figure_10-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: The right paddle moving with the mouse</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 170. " epub:type="pagebreak" id="pg_170" role="doc-pagebreak"/>Our game has now officially become interactive! The player has full control of the position of the right paddle.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="h2-63"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Paddle Collisions</samp></h4>
<p class="TNI1">The next step is to add collision detection for the paddles. We need to know if the ball has hit a paddle and, if so, make the ball bounce off the paddle appropriately. This requires a lot of code, so I’ll break it up over a few listings.</p>
<p class="TX">The first thing we have to do is create objects defining the four edges of the two paddles, as we did for the ball in <a href="#Lis10-6">Listing 10-6</a>. These changes are shown in <a href="#Lis10-10">Listing 10-10</a>.</p>
<span id="Lis10-10"/>
<pre><code><var>--snip--</var>
<span class="gray">function checkCollision() {</span>
<span class="gray">  let ball = {</span>
<span class="gray">    left: ballPosition.x,</span>
<span class="gray">    right: ballPosition.x + BALL_SIZE,</span>
<span class="gray">    top: ballPosition.y,</span>
<span class="gray">    bottom: ballPosition.y + BALL_SIZE</span>
<span class="gray">  }</span>
 
  let leftPaddle = {
    left: PADDLE_OFFSET,
    right: PADDLE_OFFSET + PADDLE_WIDTH,
    top: leftPaddleTop,
    bottom: leftPaddleTop + PADDLE_HEIGHT
  };

   let rightPaddle = {
    left: width - PADDLE_WIDTH - PADDLE_OFFSET,
    right: width - PADDLE_OFFSET,
    top: rightPaddleTop,
    bottom: rightPaddleTop + PADDLE_HEIGHT
  };

<span class="gray">  if (ball.left &lt; 0 || ball.right </span><span class="gray">&gt; width) {</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-10: Defining the edges of the paddles</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">leftPaddle</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">rightPaddle</span> objects contain the edges of their respective paddles as four properties, <span class="SANS_TheSansMonoCd_W5Regular_11">left</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">right</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">top</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">bottom</span>. As in <a href="#Lis10-8">Listing 10-8</a>, determining where the edges of the right paddle are requires a bit more math because we have to take into account the width of the canvas, the offset of the paddle, and the width of the paddle.</p>
<p class="TX">Next we need a function, which we’ll call <span class="SANS_TheSansMonoCd_W5Regular_11">checkPaddleCollision</span>, that takes the ball object and one of the paddle objects and returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> if the ball is intersecting with that paddle. The function definition is shown in <a href="#Lis10-11">Listing 10-11</a>.</p>
<span id="Lis10-11"/>
<pre><code><span aria-label=" Page 171. " epub:type="pagebreak" id="pg_171" role="doc-pagebreak"/><var>--snip--</var>
<span class="gray">function update() {</span>
<span class="gray">  ballPosition.x += xSpeed;</span>
<span class="gray">  ballPosition.y += ySpeed;</span>
<span class="gray">}</span>

function checkPaddleCollision(ball, paddle) {
  // Check if the paddle and ball overlap vertically and horizontally
  return (
    ball.left   &lt; paddle.right &amp;&amp;
    ball.right  &gt; paddle.left &amp;&amp;
    ball.top    &lt; paddle.bottom &amp;&amp;
    ball.bottom &gt; paddle.top
  );
}

<span class="gray">function checkCollision() {</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-11: The checkPaddleCollision function</samp></p>
<p class="TX">This function will be called with the ball and each of the paddle objects defined earlier. It uses a long Boolean expression made up of four subexpressions that are all <span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</span>’d together, so it returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> only if all four subexpressions are <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. (I added spacing to each subexpression so the operands line up vertically; this is just to make the code easier to read.) In English, the subexpressions say:</p>
<div class="top">
<p class="NL">  1.  The left edge of the ball must be to the left of the right edge of the paddle.</p>
<p class="NL">  2.  The right edge of the ball must be to the right of the left edge of the paddle.</p>
<p class="NL">  3.  The top edge of the ball must be above the bottom edge of the paddle.</p>
<p class="NL">  4.  The bottom edge of the ball must be below the top edge of the paddle.</p>
</div>
<p class="TX">If the first two conditions are true, the ball is intersecting horizontally, and if the last two conditions are true, the ball is intersecting vertically. The ball is truly intersecting with the paddle only if all four conditions are true. To illustrate this, see <a href="chapter10.xhtml#fig10-5">Figure 10-5</a>.</p>
<p class="TX">The figure shows four possible scenarios we might check. In all the scenarios, the paddle has the following bounds: <span class="SANS_TheSansMonoCd_W5Regular_11">{left: 10, right: 15, top: 5, bottom: 25}</span>.</p>
<p class="TX">In <a href="chapter10.xhtml#fig10-5">Figure 10-5</a>(a), <span class="SANS_TheSansMonoCd_W5Regular_11">ball</span> has the bounds <span class="SANS_TheSansMonoCd_W5Regular_11">{left: 20, right: 25, top: 30, bottom: 35}</span>. In this case, <span class="SANS_TheSansMonoCd_W5Regular_11">ball.left &lt; paddle.right</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> (the left side of the ball is not to the left of the right side of the paddle), but <span class="SANS_TheSansMonoCd_W5Regular_11">ball.right &gt; paddle.left</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. Likewise, <span class="SANS_TheSansMonoCd_W5Regular_11">ball.top &lt; paddle.bottom</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ball.bottom &gt; paddle.top</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. The ball is neither vertically nor horizontally intersecting with the paddle.</p>
<p class="TX">In <a href="chapter10.xhtml#fig10-5">Figure 10-5</a>(b), <span class="SANS_TheSansMonoCd_W5Regular_11">ball</span> has the bounds <span class="SANS_TheSansMonoCd_W5Regular_11">{left: 20, right: 25, top: 22, bottom: 27}</span>. This time, <span class="SANS_TheSansMonoCd_W5Regular_11">ball.top &lt; paddle.bottom</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ball.bottom &gt; paddle.top</span> <span aria-label=" Page 172. " epub:type="pagebreak" id="pg_172" role="doc-pagebreak"/>are both <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, which means that the ball is vertically intersecting with the paddle, but not horizontally intersecting.</p>
<p class="TX">In <a href="chapter10.xhtml#fig10-5">Figure 10-5</a>(c), <span class="SANS_TheSansMonoCd_W5Regular_11">ball</span> has the bounds <span class="SANS_TheSansMonoCd_W5Regular_11">{left: 13, right: 18, top: 30, bottom: 35}</span>. In this case, the ball is horizontally intersecting with the paddle, but not vertically intersecting.</p>
<p class="TX">Finally, in <a href="chapter10.xhtml#fig10-5">Figure 10-5</a>(d), <span class="SANS_TheSansMonoCd_W5Regular_11">ball</span> has the bounds <span class="SANS_TheSansMonoCd_W5Regular_11">{left: 13, right: 18, top: 22, bottom: 27}</span>. Now the ball is both horizontally and vertically intersecting with the paddle. All four subexpressions are <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, so <span class="SANS_TheSansMonoCd_W5Regular_11">check PaddleCollision</span> returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>.</p>
<figure class="IMG"><img alt="" class="img1" id="fig10-5" src="../images/Figure_10-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: Collision detection conditions</samp></p></figcaption>
</figure>
<p class="TX">Now it’s time to actually call the <span class="SANS_TheSansMonoCd_W5Regular_11">checkPaddleCollision</span> function from within the <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> function, once for each paddle, and handle the case where the function returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. You can find this code in <a href="#Lis10-12">Listing 10-12</a>.</p>
<span id="Lis10-12"/>
<pre><code><span aria-label=" Page 173. " epub:type="pagebreak" id="pg_173" role="doc-pagebreak"/><var>--snip--</var>
<span class="gray">  let rightPaddle = {</span>
<span class="gray">    left: width - PADDLE_WIDTH - PADDLE_OFFSET,</span>
<span class="gray">    right: width - PADDLE_OFFSET,</span>
<span class="gray">    top: rightPaddleTop,</span>
<span class="gray">    bottom: rightPaddleTop + PADDLE_HEIGHT</span>
<span class="gray">  };</span>

  if (checkPaddleCollision(ball, leftPaddle)) {
    // Left paddle collision happened
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> xSpeed = Math.abs(xSpeed);
  }

  if (checkPaddleCollision(ball, rightPaddle)) {
    // Right paddle collision happened
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> xSpeed = -Math.abs(xSpeed);
  }

<span class="gray">  if (ball.left &lt; 0 || ball.right &gt; width) {</span>
<span class="gray">    xSpeed = -xSpeed;</span>
<span class="gray">  }</span>
<span class="gray">  if (ball.top &lt; 0 || ball.bottom &gt; height) {</span>
<span class="gray">    ySpeed = -ySpeed;</span>
<span class="gray">  }</span>
<span class="gray">}</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-12: Checking for paddle collisions</samp></p>
<p class="TX">Remember that <span class="SANS_TheSansMonoCd_W5Regular_11">checkPaddleCollision</span> takes an object representing the ball and an object representing a paddle and returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> if the two are intersecting. If <span class="SANS_TheSansMonoCd_W5Regular_11">checkPaddleCollision(ball, leftPaddle)</span> returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>, we set <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">Math.abs(xSpeed)</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, which has the effect of setting it to <span class="SANS_TheSansMonoCd_W5Regular_11">4</span> because in our game <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> is only ever <span class="SANS_TheSansMonoCd_W5Regular_11">4</span> (when moving to the right) or <span class="SANS_TheSansMonoCd_W5Regular_11">-4</span> (when moving to the left).</p>
<p class="TX">You might be wondering why we didn’t just negate <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span>, as we did with the vertical wall collision code earlier. Using the absolute value is a little trick to avoid multiple collisions that could send the ball bouncing back and forth “inside” the paddle. It’s possible that if the ball hits at just the right point at the end of the paddle it will get bounced back, but the next frame will also result in a collision with the same paddle. If we were negating the <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span>, then it would just keep bouncing. By forcing the updated <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> to be positive, we can ensure that a collision with the left paddle will always result in the ball bouncing to the right.</p>
<p class="TX">Following this, we do the same thing with the right paddle. In this case, if there’s a collision we update <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">-Math.abs(xSpeed)</span> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, which in effect is <span class="SANS_TheSansMonoCd_W5Regular_11">-4</span>, meaning that the ball will bounce to the left.</p>
<p class="TX">Refresh <i>index.html</i> again, and try to move the right paddle with your mouse so the ball hits it. You should now have ball-paddle bounces happening! At this point the ball can still safely bounce off the side walls, but we’ll fix that soon.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="h2-64"/><span aria-label=" Page 174. " epub:type="pagebreak" id="pg_174" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bouncing Near the Paddle Ends</samp></h4>
<p class="TNI1">I mentioned at the beginning of this chapter that in <i>Pong</i> you can change the angle of the ball’s bounce by hitting it near the top or bottom of the paddle. We’ll implement that functionality now. First we’ll add a new function called <span class="SANS_TheSansMonoCd_W5Regular_11">adjustAngle</span> immediately before <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span>. It checks if the ball is near the top or bottom of the paddle, and updates <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> if it is. See <a href="#Lis10-13">Listing 10-13</a> for the code.</p>
<span id="Lis10-13"/>
<pre><code><var>--snip--</var>
function adjustAngle(distanceFromTop, distanceFromBottom) {
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if (distanceFromTop &lt; 0) {
    // If ball hit near top of paddle, reduce ySpeed
    ySpeed -= 0.5;
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> } else if (distanceFromBottom &lt; 0) {
    // If ball hit near bottom of paddle, increase ySpeed
    ySpeed += 0.5;
  }
}

<span class="gray">function checkCollision() {</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-13: Adjusting the bounce angle</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">adjustAngle</span> function has two parameters, <span class="SANS_TheSansMonoCd_W5Regular_11">distanceFromTop</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">distanceFromBottom</span>. These represent the distance from the top of the ball to the top of the paddle and from the bottom of the paddle to the bottom of the ball, respectively. The function first checks if <span class="SANS_TheSansMonoCd_W5Regular_11">distanceFromTop</span> is less than <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If so, that means the top edge of the ball is above the top edge of the paddle at collision time, which is how we’ll define being near the top of the paddle. In this case, we subtract <span class="SANS_TheSansMonoCd_W5Regular_11">0.5</span> from <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span>. If the ball is moving down the screen when it hits near the top of the paddle, then <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> is positive, so subtracting <span class="SANS_TheSansMonoCd_W5Regular_11">0.5</span> reduces the vertical speed. For example, at the start of the game, <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>. If you align the paddle so the ball hits the top, <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> will become <span class="SANS_TheSansMonoCd_W5Regular_11">1.5</span> after the bounce, effectively reducing the angle of bounce. However, if the ball is moving up the screen, then <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> is negative. In this case, subtracting <span class="SANS_TheSansMonoCd_W5Regular_11">0.5</span> after a hit near the top of the paddle will increase the ball’s vertical speed. For example, a <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> of <span class="SANS_TheSansMonoCd_W5Regular_11">-2</span> will become <span class="SANS_TheSansMonoCd_W5Regular_11">-2.5</span>.</p>
<p class="TX">If the ball hits near the bottom of the paddle <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, the opposite happens. In this case, we add <span class="SANS_TheSansMonoCd_W5Regular_11">0.5</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span>, increasing the vertical speed if the ball is moving down the screen or decreasing the speed if the ball is moving up the screen.</p>
<p class="TX">Next, we need to update the <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> function to call the new <span class="SANS_TheSansMonoCd_W5Regular_11">adjustAngle</span> function as part of the collision detection logic for the two paddles. <a href="#Lis10-14">Listing 10-14</a> shows the changes.</p>
<span id="Lis10-14"/>
<pre><code><var>--snip--</var>
<span class="gray">  let rightPaddle = {</span>
<span class="gray">    left: width - PADDLE_WIDTH - PADDLE_OFFSET,</span>
<span class="gray">    right: width - PADDLE_OFFSET,</span>
<span aria-label=" Page 175. " epub:type="pagebreak" id="pg_175" role="doc-pagebreak"/><span class="gray">    top: rightPaddleTop,</span>
<span class="gray">    bottom: rightPaddleTop + PADDLE_HEIGHT</span>
  <span class="gray">};</span>

<span class="gray">  if (checkPaddleCollision(ball, leftPaddle)) {</span>
<span class="gray">    // Left paddle collision happened</span>
    let distanceFromTop = ball.top - leftPaddle.top;
    let distanceFromBottom = leftPaddle.bottom - ball.bottom;
    adjustAngle(distanceFromTop, distanceFromBottom);
<span class="gray">    xSpeed = Math.abs(xSpeed);</span>
<span class="gray">  }</span>

<span class="gray">  if (checkPaddleCollision(ball, rightPaddle)) {</span>
<span class="gray">    // Right paddle collision happened</span>
    let distanceFromTop = ball.top - rightPaddle.top;
    let distanceFromBottom = rightPaddle.bottom - ball.bottom;
    adjustAngle(distanceFromTop, distanceFromBottom);
<span class="gray">    xSpeed = -Math.abs(xSpeed);</span>
<span class="gray">  }</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-14: Calling adjustAngle</samp></p>
<p class="TX">Within the <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement for each paddle, we declare <span class="SANS_TheSansMonoCd_W5Regular_11">distanceFromTop</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">distanceFromBottom</span>, the arguments needed for the <span class="SANS_TheSansMonoCd_W5Regular_11">adjustAngle</span> function. Then we call <span class="SANS_TheSansMonoCd_W5Regular_11">adjustAngle</span> before updating <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> as before.</p>
<p class="TX">Now try out the game and see if you can hit the ball near the edge of the paddle!</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<aside aria-label="box-33" class="box" id="sec11">
<h4 class="BH" id="box-33"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">10-1.</samp><samp class="SANS_Futura_Std_Book_11">  Hitting the edge of the paddle can be tricky. To make it easier, try reducing the speed of the game by increasing the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> <samp class="SANS_Futura_Std_Book_11">interval—for example, from 30 ms to 60 ms. Another option is to expand what counts as “near the top” and “near the bottom” of the paddle. Instead of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">distanceFromTop &lt; 0</span> <samp class="SANS_Futura_Std_Book_11">you could use</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">distanceFromTop &lt; 5</span><samp class="SANS_Futura_Std_Book_11">, for example, which would check that the top of the ball is less than 5 pixels below the top of the paddle.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">10-2.</samp><samp class="SANS_Futura_Std_Book_11">  It isn’t always obvious when a top or bottom hit has occurred, since the change to</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> <samp class="SANS_Futura_Std_Book_11">is pretty small. To get some more feedback about what’s actually happening when the ball hits the paddle, you can add logging to the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">adjustAngle</span> <samp class="SANS_Futura_Std_Book_11">function. For example, you could add the following line to the start of the function:</samp></p>

<pre><code>console.log(`top: ${distanceFromTop}, bottom: ${distanceFromBottom}`);</code></pre>
<p class="BoxListBody"><samp class="SANS_Futura_Std_Book_11">This way the console will show the ball’s distance from the top and bottom of the paddle every time the ball hits a paddle. Another thing</samp> <span aria-label=" Page 176. " epub:type="pagebreak" id="pg_176" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Book_11">that might help is adding logging to the two conditionals within the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">adjustAngle</span> <samp class="SANS_Futura_Std_Book_11">function, like so:</samp></p>

<pre><code><span class="gray">if (distanceFromTop &lt; 0) {</span>
<span class="gray">  </span><span class="gray">// If ball hit near top of paddle, reduce ySpeed</span>
  console.log("Top hit!");
<span class="gray">  </span><span class="gray">ySpeed -= 0.5;</span>
<span class="gray">} else if (distanceFromBottom &lt;</span><span class="gray"> 0) {</span>
<span class="gray">  </span><span class="gray">// If ball hit near bottom of paddle, increase ySpeed</span>
  console.log("Bottom hit!");
<span class="gray">  </span><span class="gray">ySpeed += 0.5;</span>
<span class="gray">}</span>
</code></pre>
<p class="BoxListBody"><samp class="SANS_Futura_Std_Book_11">Now you’ll get additional feedback indicating that the ball has hit the top or bottom of the paddle and that</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> <samp class="SANS_Futura_Std_Book_11">is being adjusted.</samp></p>
<p class="BoxListBody1"><samp class="SANS_Futura_Std_Book_11">Don’t get carried away with logging, though. You should be careful about where you add logging in games, as it can quickly get very noisy and hard to read, and can also lead to performance problems. If you add logging in the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> <samp class="SANS_Futura_Std_Book_11">function, for example, then every frame of the game will produce a new log line! It’s best to limit the logging to certain conditions that won’t be true all the time: for example, logging only when a collision occurs, as we did here.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H1" id="sec12"><span id="h1-58"/><samp class="SANS_Futura_Std_Bold_B_11">Scoring Points</samp></h3>
<p class="TNI1">Games are usually more fun when you can win or lose. In <i>Pong</i>, you score a point if you hit the wall behind the opposing player’s paddle. When this happens, the ball gets reset to its starting position and speed for the next round of play. We’ll deal with that part in this section too, but first, to keep track of the scores, we’ll need to create some new variables. Update <i>script.js</i> with the code in <a href="#Lis10-15">Listing 10-15</a>.</p>
<span id="Lis10-15"/>
<pre><code><var>--snip--</var>
<span class="gray">let leftPaddleTop = 10;</span>
<span class="gray">let rightPaddleTop = 30;</span>

let leftScore = 0;
let rightScore = 0;

<span class="gray">document.addEventListener("mousemove", e =&gt; {</span>
<span class="gray">  rightPaddleTop = e.y - canvas.offsetTop;</span>
<span class="gray">});</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-15: Variables to keep track of the scores</samp></p>
<p class="TX">Here we declare two new variables, <span class="SANS_TheSansMonoCd_W5Regular_11">leftScore</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">rightScore</span>, and set them both to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>. Later we’ll add logic to increment these variables when points are scored.</p>
<p class="TX"><span aria-label=" Page 177. " epub:type="pagebreak" id="pg_177" role="doc-pagebreak"/>Next, we’ll add code for displaying the scores to the end of the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> function. Update the function as shown in <a href="#Lis10-16">Listing 10-16</a>.</p>
<span id="Lis10-16"/>
<pre><code><var>--snip--</var>
<span class="gray">  ctx.fillRect(</span>
<span class="gray">    width - PADDLE_WIDTH - PADDLE_OFFSET,</span>
<span class="gray">    rightPaddleTop,</span>
<span class="gray">    PADDLE_WIDTH,</span>
<span class="gray">    PADDLE_HEIGHT</span>
<span class="gray">  );</span>

  // Draw scores
  ctx.font = "30px monospace";
  ctx.textAlign = "left";
  ctx.fillText(leftScore.toString(), 50, 50);
  ctx.textAlign = "right";
  ctx.fillText(rightScore.toString(), width - 50, 50);
}

<span class="gray">function update() {</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-16: Drawing the scores</samp></p>
<p class="TX">This code uses some new canvas properties and methods we haven’t seen yet. First, we use <span class="SANS_TheSansMonoCd_W5Regular_11">ctx.font</span> to set the font of the text we’re about to draw. This is similar to a CSS font declaration. In this case, we’re setting the font to be 30 pixels tall and monospace style. <i>Monospace</i> means that each character takes up the same width, and is usually used for code, as in this book’s code listings. It looks <span class="SANS_TheSansMonoCd_W5Regular_11">like this</span>. There are many monospace fonts, but because operating systems can come with different fonts installed, we give only a generic font style (<span class="SANS_TheSansMonoCd_W5Regular_11">monospace</span>), meaning the operating system should use the default font for that font style. In most operating systems, Courier or Courier New is the default monospace font.</p>
<p class="TX">Next, we use <span class="SANS_TheSansMonoCd_W5Regular_11">ctx.textAlign</span> to set the alignment for the text. We choose <span class="SANS_TheSansMonoCd_W5Regular_11">"left"</span> alignment, but because we want this to apply only to the left score, before drawing the right score we change the alignment to <span class="SANS_TheSansMonoCd_W5Regular_11">"right"</span>. This way if the scores get into double digits the numbers will extend toward the middle of the screen, keeping things visually balanced.</p>
<p class="TX">To display the left score, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">ctx.fillText</span> method. This method has three parameters: the text to be drawn, and the x- and y-coordinates at which to draw it. The first parameter must be a string, so we call the <span class="SANS_TheSansMonoCd_W5Regular_11">toString</span> method on <span class="SANS_TheSansMonoCd_W5Regular_11">leftScore</span> to convert it from a number to a string. We use <span class="SANS_TheSansMonoCd_W5Regular_11">50</span> for the x- and y-coordinates to place the text near the top-left corner of the canvas.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>The meaning of the x-coordinate parameter for fillText depends on the text’s alignment. For left-aligned text, the x-coordinate specifies the left edge of the text, whereas for right-aligned text it specifies the right edge.</i></p>
<p class="TX">The right score is handled similarly to the left score: we set the text alignment, then call <span class="SANS_TheSansMonoCd_W5Regular_11">fillText</span> to display the score. This time we set the <span aria-label=" Page 178. " epub:type="pagebreak" id="pg_178" role="doc-pagebreak"/>x-coordinate to <span class="SANS_TheSansMonoCd_W5Regular_11">width - 50</span>, so it appears as far from the right as the left score appears from the left.</p>
<p class="TX">When you refresh <i>index.html</i>, you should see the initial scores rendered, as illustrated in <a href="chapter10.xhtml#fig10-6">Figure 10-6</a>.</p>
<figure class="IMG"><img alt="" class="img6" id="fig10-6" src="../images/Figure_10-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: Displaying the scores</samp></p></figcaption>
</figure>
<p class="TX">Now we have to handle the case where the ball hits the side walls. Instead of bouncing, the appropriate score should be incremented and the ball should be reset to its original speed and position. First we’ll do another refactor and write a function that resets the ball. This also requires some changes to how the ball’s speed and position variables are handled. <a href="#Lis10-17">Listing 10-17</a> shows the changes.</p>
<span id="Lis10-17"/>
<pre><code><var>--snip--</var>
<span class="gray">const BALL_SIZE = 5;</span>
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> let ballPosition;

let xSpeed;
let ySpeed;

function initBall() {
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> ballPosition = {x: 20, y: 30};
  xSpeed = 4;
  ySpeed = 2;
}

<span class="gray">const PADDLE_WIDTH = 5;</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-17: The initBall function</samp></p>
<p class="TX">Here we’ve separated the <i>declaration</i> of the ball state variables (<span class="SANS_TheSansMonoCd_W5Regular_11">ball Position</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span>) from the <i>initialization</i> of those variables. For <span aria-label=" Page 179. " epub:type="pagebreak" id="pg_179" role="doc-pagebreak"/>example, <span class="SANS_TheSansMonoCd_W5Regular_11">ballPosition</span> is declared at the top level of the program <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> but initialized in the new <span class="SANS_TheSansMonoCd_W5Regular_11">initBall</span> function <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> (short for “initialize ball”). The same goes for <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span>. This is so we can reset the ball to its initial position and speed whenever we want simply by calling <span class="SANS_TheSansMonoCd_W5Regular_11">initBall</span>, rather than by copy-pasting the values of the ball state variables all over the program. In particular, we can now call <span class="SANS_TheSansMonoCd_W5Regular_11">initBall</span> at the start of the program to set up the ball for the first time, and we can also call it anytime the ball hits the left or right wall, to reset the ball to its original state.</p>
<p class="TX">Note that we can’t both declare <i>and</i> initialize the ball state variables inside the <span class="SANS_TheSansMonoCd_W5Regular_11">initBall</span> function—for example, by placing <span class="SANS_TheSansMonoCd_W5Regular_11">let ballPosition = {x: 20, y: 30};</span> within the function—because the <span class="SANS_TheSansMonoCd_W5Regular_11">let</span> keyword defines a new variable <i>in the current scope</i>, which in that case would be the body of <span class="SANS_TheSansMonoCd_W5Regular_11">initBall</span>. Thus, the variables would be available only within <span class="SANS_TheSansMonoCd_W5Regular_11">initBall</span>. We want the variables to be available throughout the program, so we declare them with <span class="SANS_TheSansMonoCd_W5Regular_11">let</span> at the top level of the program, outside the body of any functions. However, because we want to initialize the variables multiple times, we assign them their value in the <span class="SANS_TheSansMonoCd_W5Regular_11">initBall</span> function, which can be called repeatedly.</p>
<p class="TX">Next we have to modify the collision detection code in the <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> function to increment the score and reset the ball when the left or right wall is hit. <a href="#Lis10-18">Listing 10-18</a> shows how.</p>
<span id="Lis10-18"/>
<pre><code><var>--snip--</var>
<span class="gray">  if (checkPaddleCollision(ball, rightPaddle)) {</span>
<span class="gray">    // Right paddle collision happened</span>
<span class="gray">    let distanceFromTop = ball.top - rightPaddle.top;</span>
<span class="gray">    let distanceFromBottom = rightPaddle.bottom - ball.bottom;</span>
<span class="gray">    adjustAngle(distanceFromTop, distanceFromBottom);</span>
<span class="gray">    xSpeed = -Math.abs(xSpeed);</span>
  }

<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if (ball.left &lt; 0) {
    rightScore++;
    initBall();
  }
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if (ball.right &gt; width) {
    leftScore++;
    initBall();
  }

<span class="gray">  if (ball.top &lt; 0 || ball.bottom &gt; height) {</span>
<span class="gray">    ySpeed </span><span class="gray">= -ySpeed;</span>
<span class="gray">  }</span>
<span class="gray">}</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-18: Scoring points on wall collisions</samp></p>
<p class="TX">Previously, we checked for left and right wall collisions in a single <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement that made the ball bounce, but we have to handle the left and right walls individually, since a different player scores depending on which <span aria-label=" Page 180. " epub:type="pagebreak" id="pg_180" role="doc-pagebreak"/>wall is hit. Therefore, we’ve split the <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statement into two. If the ball hits the left wall <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">rightScore</span> is incremented and the ball is reset with a call to our new <span class="SANS_TheSansMonoCd_W5Regular_11">initBall</span> function. If the ball hits the right wall <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">leftScore</span> is incremented and the ball is reset. The logic for collisions with the top and bottom walls remains the same.</p>
<p class="TX">Finally, since we’ve moved the initialization of the ball state variables to the <span class="SANS_TheSansMonoCd_W5Regular_11">initBall</span> function, we need to call that function before the game loop starts in order to set the ball up for the first time. Scroll down to the bottom of <i>script.js</i> and update the code as shown in <a href="#Lis10-19">Listing 10-19</a>, adding a call to <span class="SANS_TheSansMonoCd_W5Regular_11">initBall</span> before the call to <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span>.</p>
<span id="Lis10-19"/>
<pre><code><var>--snip--</var>
<span class="gray">function gameLoop() {</span>
<span class="gray">  draw();</span>
<span class="gray">  update();</span>
  <span class="gray">checkCollision();</span>

<span class="gray">  // Call this function again after a timeout</span>
<span class="gray">  setTimeout(gameLoop, 30);</span>
<span class="gray">}</span>

initBall();
<span class="gray">gameLoop();</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-19: Calling initBall for the first time</samp></p>
<p class="TX">Now when you refresh <i>index.html</i>, you should see the scores increment when the ball hits a side wall, and the ball should reset to its original speed and position after a side wall hit. Of course, it’s pretty easy to beat the computer right now because it doesn’t move its paddle yet!</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H1" id="sec13"><span id="h1-59"/><samp class="SANS_Futura_Std_Bold_B_11">Computer Control</samp></h3>
<p class="TNI1">Now let’s add some challenge to this game! We want the computer-controlled opponent to move the left paddle and try to hit the ball. There are various ways to do this, but in our simple approach, we’ll have the computer always try to match the current position of the ball. The logic for the computer will be very simple:</p>
<ul class="ul">
<li class="BL">If the top of the ball is above the top of the paddle, move the paddle up.</li>
<li class="BL">If the bottom of the ball is below the bottom of the paddle, move the paddle down.</li>
<li class="BL">Otherwise, do nothing.</li>
</ul>
<p class="TX">With this approach, if the computer could move at any speed, then it would never miss. Since this would be no fun for us humans, we’ll set a speed limit for the computer. <a href="#Lis10-20">Listing 10-20</a> shows how.</p>
<span id="Lis10-20"/>
<pre><code><span class="gray">let canvas = document.querySelector("#canvas");</span>
<span class="gray">let ctx </span><span class="gray">= canvas.getContext("2d");</span>
<span aria-label=" Page 181. " epub:type="pagebreak" id="pg_181" role="doc-pagebreak"/><span class="gray">let width = canvas.width;</span>
<span class="gray">let height = canvas.height;</span>

const MAX_COMPUTER_SPEED = 2;

<span class="gray">const BALL_SIZE = 5;</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-20: Limiting the computer’s speed</samp></p>
<p class="TX">We declare the computer’s speed limit as a constant, <span class="SANS_TheSansMonoCd_W5Regular_11">MAX_COMPUTER_SPEED</span>. By setting it to <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>, we’re saying that the computer isn’t allowed to move the paddle more than 2 pixels per frame of the game.</p>
<p class="TX">Next, we’ll define a function called <span class="SANS_TheSansMonoCd_W5Regular_11">followBall</span> that applies some very rudimentary artificial intelligence to move the computer’s paddle. The new function is shown in <a href="#Lis10-21">Listing 10-21</a>. Add it to your code between the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> function and the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function.</p>
<span id="Lis10-21"/>
<pre><code><var>--snip--</var>
function followBall() {
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> let ball = {
    top: ballPosition.y,
    bottom: ballPosition.y + BALL_SIZE
  };
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> let leftPaddle = {
    top: leftPaddleTop,
    bottom: leftPaddleTop + PADDLE_HEIGHT
  };

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> if (ball.top &lt; leftPaddle.top) {
    leftPaddleTop -= MAX_COMPUTER_SPEED;
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> } else if (ball.bottom &gt; leftPaddle.bottom) {
    leftPaddleTop += MAX_COMPUTER_SPEED;
  }
}

<span class="gray">function update() {</span>
<span class="gray">  ballPosition.x +=</span><span class="gray"> xSpeed;</span>
<span class="gray">  ballPosition.y += ySpeed;</span>
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> followBall();
<span class="gray">}</span>

<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-21: Computer-controlled paddle</samp></p>
<p class="TX">Within the <span class="SANS_TheSansMonoCd_W5Regular_11">followBall</span> function, we define objects representing the ball <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and the left paddle <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, each with <span class="SANS_TheSansMonoCd_W5Regular_11">top</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">bottom</span> properties representing their upper and lower bounds. Then we implement the paddle movement logic with two <span class="SANS_TheSansMonoCd_W5Regular_11">if</span> statements. If the top of the ball is above the top of the paddle <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, we move the paddle up by subtracting <span class="SANS_TheSansMonoCd_W5Regular_11">MAX_COMPUTER_SPEED</span> from <span class="SANS_TheSansMonoCd_W5Regular_11">leftPaddleTop</span>. Likewise, if the bottom of the ball is below the bottom <span aria-label=" Page 182. " epub:type="pagebreak" id="pg_182" role="doc-pagebreak"/>of the paddle <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, we move the paddle down by adding <span class="SANS_TheSansMonoCd_W5Regular_11">MAX_COMPUTER_SPEED</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">leftPaddleTop</span>.</p>
<p class="TX">We call our new <span class="SANS_TheSansMonoCd_W5Regular_11">followBall</span> function within the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. This way, moving the left paddle becomes part of the process of updating the state of the game that happens with each iteration of the game loop.</p>
<p class="TX">Reload the page and see if you can score a point against the computer!</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H1" id="sec14"><span id="h1-60"/><samp class="SANS_Futura_Std_Bold_B_11">Game Over</samp></h3>
<p class="TNI1">The final step in creating our game is to make it winnable (or losable). To do that, we have to add some kind of game over condition, and stop the game loop at that point. In this case, we’ll stop the game loop once one of the players reaches 10 points, then display the text “GAME OVER.”</p>
<p class="TX">First, we need to declare a variable for keeping track of whether or not the game is over. We’ll use this variable to decide whether to continue repeating the <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span> function. <a href="#Lis10-22">Listing 10-22</a> shows the changes to make.</p>
<span id="Lis10-22"/>
<pre><code><var>--snip--</var>
<span class="gray">let leftScore = 0;</span>
<span class="gray">let rightScore = 0;</span>
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> let gameOver = false;

<span class="gray">document.addEventListener("mousemove", e =&gt; {</span>
<span class="TheSansMonoCd_W5Regular_Italic_I_11">--snip--</span>

<span class="gray">function checkCollision() {</span>
<span class="TheSansMonoCd_W5Regular_Italic_I_11">--snip--</span>
<span class="gray">  if (ball.right &gt; width) {</span>
<span class="gray">    leftScore++</span><span class="gray">;</span>
<span class="gray">    initBall();</span>
<span class="gray">  }</span>
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if (leftScore &gt; 9 || rightScore &gt; 9) {
    gameOver = true;
<span class="gray">  }</span>
<span class="gray">  if (ball.top &lt; 0 || ball.bottom &gt;</span><span class="gray"> height) {</span>
<span class="gray">    ySpeed = -ySpeed;</span>
<span class="gray">  }</span>
<span class="gray">}</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-22: Adding the gameOver variable</samp></p>
<p class="TX">Near the top of <i>script.js</i>, we declare a variable called <span class="SANS_TheSansMonoCd_W5Regular_11">gameOver</span> for recording whether the game is over <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We initialize it to <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> so the game doesn’t end before it begins. Then, within the <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> function, we check to see if either of the scores has exceeded 9 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. If so, we set <span class="SANS_TheSansMonoCd_W5Regular_11">gameOver</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. This check could happen anywhere, but we do it in <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> to keep the logic that increments the scores and the logic that checks the scores together.</p>
<p class="TX"><span aria-label=" Page 183. " epub:type="pagebreak" id="pg_183" role="doc-pagebreak"/>Next, we’ll add a function for writing the text “GAME OVER,” and we’ll modify the game loop so it ends when <span class="SANS_TheSansMonoCd_W5Regular_11">gameOver</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>. <a href="#Lis10-23">Listing 10-23</a> shows how.</p>
<span id="Lis10-23"/>
<pre><code><var>--snip--</var>
<span class="gray">  if (ball.top </span><span class="gray">&lt; 0 || ball.bottom &gt; height) {</span>
<span class="gray">    ySpeed = -ySpeed;</span>
<span class="gray">  }</span>
<span class="gray">}</span>

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> function drawGameOver() {
  ctx.fillStyle = "white";
  ctx.font = "30px monospace";
  ctx.textAlign = "center";
  ctx.fillText("GAME OVER", width / 2, height / 2);
}

<span class="gray">function gameLoop() {</span>
<span class="gray">  draw();</span>
<span class="gray">  update();</span>
<span class="gray">  checkCollision();</span>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> if (gameOver) {
    draw();
    drawGameOver();
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span>} else {
    // Call this function again after a timeout
    setTimeout(gameLoop, 30);
  }
<span class="gray">}</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-23: Ending the game</samp></p>
<p class="TX">We define the <span class="SANS_TheSansMonoCd_W5Regular_11">drawGameOver</span> function after the <span class="SANS_TheSansMonoCd_W5Regular_11">checkCollision</span> function <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. It draws the text “GAME OVER” to the middle of the canvas in large, white text. To position the text in the middle of the canvas, we set the text alignment to <span class="SANS_TheSansMonoCd_W5Regular_11">"center"</span> and use half the canvas width and height as the text’s x- and y-coordinates. (With center alignment, the x-coordinate refers to the horizontal midpoint of the text.)</p>
<p class="TX">Within the <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span> function, we’ve wrapped the call to <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> in a conditional statement that checks the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">gameOver</span> variable. If it’s <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, the game is over, so we call the <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">drawGameOver</span> functions. (The <span class="SANS_TheSansMonoCd_W5Regular_11">draw</span> function is needed to display the final score; otherwise, the winning player would still be stuck with nine points.) If <span class="SANS_TheSansMonoCd_W5Regular_11">gameOver</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, the game can continue: we keep looping as before by using <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> to call <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span> again after 30 ms.</p>
<p class="TX">Once <span class="SANS_TheSansMonoCd_W5Regular_11">gameOver</span> becomes <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> and the game loop ends, the game effectively stops. Nothing else will be drawn to the screen after the “GAME OVER” text—at least, not until the page is refreshed and the program starts again from the beginning. Go ahead and do that now: refresh <i>index.html</i> and see if you can beat the computer! Once one of you gets more than nine points you should see the “GAME OVER” text, as shown in <a href="chapter10.xhtml#fig10-7">Figure 10-7</a>.<span aria-label=" Page 184. " epub:type="pagebreak" id="pg_184" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="" class="img6" id="fig10-7" src="../images/Figure_10-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-7: Game over</samp></p></figcaption>
</figure>
<p class="TX">I hope you beat the computer, but don’t worry if you didn’t—the game is pretty hard. Here are some things you can do to make it easier for yourself:</p>
<ul class="ul">
<li class="BL">Increase the time between frames in <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span>.</li>
<li class="BL">Make the paddles taller.</li>
<li class="BL">Reduce the computer’s max speed.</li>
<li class="BL">Make it easier to hit the edge of the paddle.</li>
<li class="BL">Increase the effect on <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> of hitting the edge of the paddle.</li>
</ul>
<p class="TX">Now that you have a working game, you can make any changes you want. If you’re already a <i>Pong</i> pro, you might want to make it harder instead; the following exercises provide a few suggestions. You could also try customizing the appearance, or changing the size of the canvas—it’s your game now.</p>
<section aria-labelledby="sec15" epub:type="division">
<aside aria-label="box-34" class="box" id="sec15">
<h4 class="BH" id="box-34"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">10-3.</samp><samp class="SANS_Futura_Std_Book_11">  Increase the speed of the game as the scores increase (note that you could do this either by increasing the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">xSpeed</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">ySpeed</span> <samp class="SANS_Futura_Std_Book_11">of the ball, or by reducing the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> <samp class="SANS_Futura_Std_Book_11">time in</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">gameLoop</span><samp class="SANS_Futura_Std_Book_11">).</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">10-4.</samp><samp class="SANS_Futura_Std_Book_11">  Slow down the player’s paddle—this will require something similar to the computer paddle movement, with the right paddle moving by some max amount each frame to try to reach the current mouse position.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">10-5.</samp><samp class="SANS_Futura_Std_Book_11">  Add a second, slower ball.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="H1" id="sec16"><span id="h1-61"/><span aria-label=" Page 185. " epub:type="pagebreak" id="pg_185" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">The Complete Code</samp></h3>
<p class="TNI1">For your convenience, <a href="#Lis10-24">Listing 10-24</a> shows the whole <i>script.js</i> file.</p>
<span id="Lis10-24"/>
<pre><code>let canvas = document.querySelector("#canvas");
let ctx = canvas.getContext("2d");
let width = canvas.width;
let height = canvas.height;

const MAX_COMPUTER_SPEED = 2;

const BALL_SIZE = 5;
let ballPosition;

let xSpeed;
let ySpeed;

function initBall() {
  ballPosition = {x: 20, y: 30};
  xSpeed = 4;
  ySpeed = 2;
}

const PADDLE_WIDTH = 5;
const PADDLE_HEIGHT = 20;
const PADDLE_OFFSET = 10;

let leftPaddleTop = 10;
let rightPaddleTop = 30;

let leftScore = 0;
let rightScore = 0;
let gameOver = false;

document.addEventListener("mousemove", e =&gt; {
  rightPaddleTop = e.y - canvas.offsetTop;
});

function draw() {
  // Fill the canvas with black
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, width, height);

  // Everything else will be white
  ctx.fillStyle = "white";

  // Draw the ball
  ctx.fillRect(ballPosition.x, ballPosition.y, BALL_SIZE, BALL_SIZE);

  // Draw the paddles
  ctx.fillRect(
    PADDLE_OFFSET,
    leftPaddleTop,
    PADDLE_WIDTH,
    PADDLE_HEIGHT
<span aria-label=" Page 186. " epub:type="pagebreak" id="pg_186" role="doc-pagebreak"/>  );
  ctx.fillRect(
    width - PADDLE_WIDTH - PADDLE_OFFSET,
    rightPaddleTop,
    PADDLE_WIDTH,
    PADDLE_HEIGHT
  );

  // Draw scores
  ctx.font = "30px monospace";
  ctx.textAlign = "left";
  ctx.fillText(leftScore.toString(), 50, 50);
  ctx.textAlign = "right";
  ctx.fillText(rightScore.toString(), width - 50, 50);
}

function followBall() {
  let ball = {
    top: ballPosition.y,
    bottom: ballPosition.y + BALL_SIZE
  };
  let leftPaddle = {
    top: leftPaddleTop,
    bottom: leftPaddleTop + PADDLE_HEIGHT
  };
 
  if (ball.top &lt; leftPaddle.top) {
    leftPaddleTop -= MAX_COMPUTER_SPEED;
  } else if (ball.bottom &gt; leftPaddle.bottom) {
    leftPaddleTop += MAX_COMPUTER_SPEED;
  }
}

function update() {
  ballPosition.x += xSpeed;
  ballPosition.y += ySpeed;
  followBall();
}

function checkPaddleCollision(ball, paddle) {
  // Check if the paddle and ball overlap vertically and horizontally
  return (
    ball.left   &lt; paddle.right &amp;&amp;
    ball.right  &gt; paddle.left &amp;&amp;
    ball.top    &lt; paddle.bottom &amp;&amp;
    ball.bottom &gt; paddle.top
  );
}

function adjustAngle(distanceFromTop, distanceFromBottom) {
  if (distanceFromTop &lt; 0) {
    // If ball hit near top of paddle, reduce ySpeed
    ySpeed -= 0.5;
  } else if (distanceFromBottom &lt; 0) {
    // If ball hit near bottom of paddle, increase ySpeed
<span aria-label=" Page 187. " epub:type="pagebreak" id="pg_187" role="doc-pagebreak"/>    ySpeed += 0.5;
  }
}

function checkCollision() {
  let ball = {
    left: ballPosition.x,
    right: ballPosition.x + BALL_SIZE,
    top: ballPosition.y,
    bottom: ballPosition.y + BALL_SIZE
  }

  let leftPaddle = {
    left: PADDLE_OFFSET,
    right: PADDLE_OFFSET + PADDLE_WIDTH,
    top: leftPaddleTop,
    bottom: leftPaddleTop + PADDLE_HEIGHT
  };

  let rightPaddle = {
    left: width - PADDLE_WIDTH - PADDLE_OFFSET,
    right: width - PADDLE_OFFSET,
    top: rightPaddleTop,
    bottom: rightPaddleTop + PADDLE_HEIGHT
  };

  if (checkPaddleCollision(ball, leftPaddle)) {
    // Left paddle collision happened
    let distanceFromTop = ball.top - leftPaddle.top;
    let distanceFromBottom = leftPaddle.bottom - ball.bottom;
    adjustAngle(distanceFromTop, distanceFromBottom);
    xSpeed = Math.abs(xSpeed);
  }

  if (checkPaddleCollision(ball, rightPaddle)) {
    // Right paddle collision happened
    let distanceFromTop = ball.top - rightPaddle.top;
    let distanceFromBottom = rightPaddle.bottom - ball.bottom;
    adjustAngle(distanceFromTop, distanceFromBottom);
    xSpeed = -Math.abs(xSpeed);
  }

  if (ball.left &lt; 0) {
    rightScore++;
    initBall();
  }
  if (ball.right &gt; width) {
    leftScore++;
    initBall();
  }
  if (leftScore &gt; 9 || rightScore &gt; 9) {
    gameOver = true;
  }
<span aria-label=" Page 188. " epub:type="pagebreak" id="pg_188" role="doc-pagebreak"/>  if (ball.top &lt; 0 || ball.bottom &gt; height) {
    ySpeed = -ySpeed;
    }
}

function drawGameOver() {
  ctx.fillStyle = "white";
  ctx.font = "30px monospace";
  ctx.textAlign = "center";
  ctx.fillText("GAME OVER", width / 2, height / 2);
}

function gameLoop() {
  draw();
  update();
  checkCollision();

  if (gameOver) {
    draw();
    drawGameOver();
  } else {
    // Call this function again after a timeout
    setTimeout(gameLoop, 30);
  }
}

initBall();
gameLoop();
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-24: The complete code</samp></p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h3 class="H1" id="sec17"><span id="h1-62"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>
<p class="TNI1">In this chapter you created a full game from scratch. The basics of game loops, collision detection, and rendering are broadly applicable, so with the knowledge you’ve acquired here you can start creating all kinds of 2D games. For example, you might try implementing your own version of <i>Breakout</i> or <i>Snake</i>. If you need some help with the logic, there are lots of tutorials online that you can follow. Have fun!</p>
</section>
</section>
</body>
</html>