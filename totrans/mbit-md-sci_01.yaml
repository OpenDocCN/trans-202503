- en: '![Image](../images/common1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common1.jpg)'
- en: '**1**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1**'
- en: '**GETTING STARTED**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**入门**'
- en: This chapter will get you started with your BBC micro:bit. It will also set
    the stage for the experiments and projects you’ll find in the following chapters.
    I’ll give our Mad Scientist (that’s you!) some ideas about what to do with your
    micro:bit, and I’ll help you start programming your micro:bit. You’ll learn how
    to use Blocks code and MicroPython.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你入门 BBC micro:bit。这也为接下来的实验和项目奠定了基础。我会给我们的疯狂科学家（就是你！）一些关于如何使用 micro:bit
    的想法，并帮助你开始编程。你将学习如何使用 Blocks 代码和 MicroPython。
- en: Mad Scientists are generally too busy and distracted to type in huge amounts
    of code, so all the code used in this book is available to download. This chapter
    explains how to get and use the code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 疯狂科学家通常太忙、太分心，无法输入大量代码，所以本书中使用的所有代码都可以下载。本章将解释如何获取和使用这些代码。
- en: '**A TOUR OF THE MICRO:BIT**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**micro:bit 介绍**'
- en: Let’s take a quick look at the micro:bit and what’s on it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下 micro:bit 和它上面的内容。
- en: '**The Top**'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**顶部**'
- en: '[Figure 1-1](ch01.xhtml#ch1fig1) shows the top of a micro:bit.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](ch01.xhtml#ch1fig1) 展示了 micro:bit 的顶部。'
- en: '![Image](../images/01fig01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig01.jpg)'
- en: '*Figure 1-1: The micro:bit*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：micro:bit*'
- en: At the top of the board is a micro USB socket, which you’ll use to connect the
    micro:bit to a computer. You’ll write programs for your micro:bit on a computer,
    so you’ll have to transfer the programs to the micro:bit using a USB connection.
    The USB socket can also power up the micro:bit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在板子的顶部有一个 micro USB 插口，用来将 micro:bit 连接到电脑。你将在电脑上为 micro:bit 编写程序，因此你需要通过 USB
    连接将程序传输到 micro:bit。这个 USB 插口也能为 micro:bit 提供电源。
- en: On the left and right are two buttons labeled A and B, respectively. We can
    program these buttons to trigger some action, like flashing an image on the LEDs
    or making a doorbell sound.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 左右两边各有一个按钮，分别标记为 A 和 B。我们可以编程这些按钮来触发某些操作，比如在 LED 上闪烁图像或发出门铃声。
- en: Between the two buttons is a grid of 25 LEDs arranged as 5 rows and 5 columns.
    This is the micro:bit’s display. Even though it has only 25 LEDs, this display
    can show scrolling text messages, small images, patterns—a whole load of things!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个按钮之间，有一个由 25 个 LED 组成的网格，排列成 5 行 5 列。这是 micro:bit 的显示屏。尽管它只有 25 个 LED，这个显示屏仍然可以显示滚动的文本信息、小图像、图案——非常多的内容！
- en: At the bottom edge of the micro:bit is a gold-plated (yes, real gold!) strip
    called the *edge connector*. This strip has five holes labeled 0, 1, 2, 3V, and
    GND. These large connectors allow you to connect things to the micro:bit using
    alligator clips. For example, you might connect a speaker to get the micro:bit
    to make sound or a motor to get it to move. The much smaller connectors, the slits
    between the holes, can be used only with a special adapter. In this book, we’ll
    use the large connectors for everything except the two robot projects, which require
    an adapter to connect to a motor controller.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 micro:bit 的底边有一条镀金（是的，真金！）的条形连接器，称为*边缘连接器*。这条连接器上有五个孔，标记为 0、1、2、3V 和 GND。这些较大的连接器可以让你使用鳄鱼夹将其他设备连接到
    micro:bit。例如，你可以连接一个扬声器让 micro:bit 发出声音，或者连接一个电机让它运动。而更小的连接器，即孔与孔之间的缝隙，只能使用特殊的适配器连接。在本书中，除了两个需要适配器连接电机控制器的机器人项目外，我们将使用这些较大的连接器。
- en: '![Image](../images/f0003-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0003-01.jpg)'
- en: '**The Bottom**'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**底部**'
- en: Now let’s turn the micro:bit over and see what we have on the underside ([Figure
    1-2](ch01.xhtml#ch1fig2)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把 micro:bit 翻过来，看看它的底面（见[图 1-2](ch01.xhtml#ch1fig2)）。
- en: '![Image](../images/01fig02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig02.jpg)'
- en: '*Figure 1-2: The micro:bit’s underside, version 1.3B (left) and 1.5 (right)*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：micro:bit 的底面，版本 1.3B（左）和 1.5（右）*'
- en: At the time of writing, there are two versions of the micro:bit in circulation.
    Both work in the same way, and it doesn’t matter which version you have for this
    book. The latest version (1.5) just has a slightly simplified design. You can
    see the difference in the bottom left of the boards shown in [Figure 1-2](ch01.xhtml#ch1fig2).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本书编写时，市面上有两种版本的 micro:bit。两种版本的工作方式相同，对于本书来说，你使用哪个版本都无所谓。最新的版本（1.5）只是设计略有简化。你可以在[图
    1-2](ch01.xhtml#ch1fig2)中看到两款板子的区别，区别在左下角。
- en: The leftmost connector is the micro USB connector. Immediately to the right
    of that is a push switch. This is the micro:bit’s *reset button*. Pressing this
    button will cause the micro:bit to restart whatever program is installed on it.
    To the right of the reset button is the battery connector, which allows you to
    connect a 3V battery pack to your micro:bit.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最左边的连接器是micro USB连接器。紧接着右侧的是一个按键开关。这是micro:bit的*复位按钮*。按下这个按钮会导致micro:bit重新启动上面安装的程序。复位按钮右侧是电池连接器，可以让你将一个3V电池包连接到micro:bit。
- en: Now we’ll take a closer look at each section, starting with how to power your
    micro:bit.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将仔细查看每个部分，从如何为micro:bit供电开始。
- en: '**Power and the Micro:bit**'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**电源和Micro:bit**'
- en: You can power the micro:bit through the USB connector or with batteries, depending
    what you want to do with it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过USB连接器或电池为micro:bit供电，取决于你希望如何使用它。
- en: '**Using USB**'
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用USB**'
- en: The USB connection will provide the micro:bit with 5V (5 volts) of power when
    you plug it into your computer. However, the micro:bit needs only 3.3V, not 5V,
    and too much voltage would damage the micro:bit. Therefore, it has a USB interface
    chip that converts this 5V to the 3.3V that the micro:bit expects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将micro:bit插入电脑时，USB连接会为micro:bit提供5V电压。然而，micro:bit只需要3.3V，而不是5V，过高的电压可能会损坏micro:bit。因此，它有一个USB接口芯片，将5V电压转换为micro:bit所需的3.3V。
- en: When the micro:bit is plugged in via USB, you can use the 3V connector on the
    edge connector to provide power to low-current electronic devices, like external
    LEDs or speakers designed to work with the micro:bit.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当micro:bit通过USB连接时，你可以使用边缘连接器上的3V接口为低功耗电子设备供电，比如外部LED或设计为与micro:bit一起使用的扬声器。
- en: '**NOTE** *The reason this connection is labeled 3V rather than 3.3V is partly
    that there isn’t much space for another number but also that protection circuitry
    reduces the 3.3V to a voltage close to 3V.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** *这个连接被标记为3V而不是3.3V，部分原因是没有足够的空间再写一个数字，但也因为保护电路会将3.3V电压降低到接近3V的电压。*'
- en: The connection labeled GND is the *ground* or 0V power connection. When you
    power your micro:bit, current flows out of the 3V connection, and it needs to
    return to the micro:bit in order to complete the circuit—the GND connection is
    where the current returns.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 标有GND的连接是*地*或0V电源连接。当你为micro:bit供电时，电流从3V连接端流出，并且需要通过GND连接返回micro:bit，才能完成电路。
- en: '**Using Batteries**'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用电池**'
- en: Once you’ve programmed your micro:bit, you may want to move it away from your
    computer, in which case you’ll need batteries. You can use a AAA battery pack,
    like the one shown in [Figure 1-3](ch01.xhtml#ch1fig3). Simply plug the ends of
    the battery pack wires into the 3V socket on the underside of the micro:bit.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为micro:bit编写了程序，可能会希望将它移离电脑，这时你就需要电池。你可以使用AAA电池包，像[图1-3](ch01.xhtml#ch1fig3)中所示的那样。只需将电池包的两端连接到micro:bit底部的3V插座。
- en: '![Image](../images/01fig03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig03.jpg)'
- en: '*Figure 1-3: Battery packs for the micro:bit*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-3：micro:bit电池包*'
- en: The [appendix](app01.xhtml) lists some places you can buy these battery packs.
    A built-in switch is useful because you can power the micro:bit down without unplugging
    the battery pack, a task that can be a bit tricky.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录](app01.xhtml)列出了一些你可以购买这些电池包的地方。内置开关很有用，因为你可以在不拔掉电池包的情况下关闭micro:bit，这是一个相对复杂的操作。'
- en: Don’t use rechargeable AAA batteries because their voltage is generally too
    low to power a micro:bit. These batteries can also allow dangerously high currents
    if the flow of electricity is accidentally short-circuited. If you want to use
    rechargeable batteries, one option is a USB battery backup like the one shown
    on the left of [Figure 1-4](ch01.xhtml#ch1fig4).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用可充电的AAA电池，因为它们的电压通常太低，无法为micro:bit提供足够的电力。这些电池如果发生意外短路，还可能导致危险的高电流。如果你想使用可充电电池，一个选择是像[图1-4](ch01.xhtml#ch1fig4)左侧所示的USB电池备份。
- en: '![Image](../images/01fig04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig04.jpg)'
- en: '*Figure 1-4: Using rechargeable batteries with the micro:bit*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-4：使用可充电电池为micro:bit供电*'
- en: These rechargeable batteries allow you to power your micro:bit through its USB
    port. The lower-capacity, cheaper backup batteries are often more suitable to
    power a micro:bit than are the more expensive versions. The micro:bit uses so
    little current that these more advanced units, which tend to turn off if they
    think the battery hasn’t been used in a while, can be fooled into thinking nothing
    is connected.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可充电电池允许你通过USB端口为micro:bit供电。低容量、价格便宜的备用电池通常比更昂贵的版本更适合为micro:bit供电。micro:bit消耗的电流非常小，这些更先进的电池往往会在认为电池长时间未使用时自动关闭，因此它们可能会错误地认为没有连接设备。
- en: The item on the right of [Figure 1-4](ch01.xhtml#ch1fig4) is the Monk Makes
    Charger for micro:bit. This uses a lithium polymer (LiPo) battery that automatically
    recharges whenever you connect the charger to your computer with a USB cable.
    When you want to run the micro:bit on batteries, you just unplug the USB cable
    to the charger.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-4](ch01.xhtml#ch1fig4)右侧的项目是Monk Makes微型充电器。它使用一块锂聚合物（LiPo）电池，每当你通过USB线将充电器连接到计算机时，它会自动充电。当你希望使用电池运行micro:bit时，只需拔掉连接充电器的USB线。'
- en: You can find out more about the options for powering your micro:bit in the [appendix](app01.xhtml).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[附录](app01.xhtml)中了解更多关于为micro:bit供电的选项。
- en: '**WARNING** *The earliest versions of the micro:bit were susceptible to damage
    when used with USB batteries and power supplies. If you have any board other than
    a V1.3B or V1.5, you should avoid using any power supply except your computer
    USB port or a 3V battery pack.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告** *micro:bit的早期版本在与USB电池和电源一起使用时容易受到损坏。如果你使用的是V1.3B或V1.5版本之外的任何板子，应该避免使用除计算机USB端口或3V电池组之外的任何电源。*'
- en: '*The early micro:bits don’t have a version number on them. Flip your micro:bit
    over and look at the bottom right corner on the underside near connector 0\. If
    it says* V1.3B *or* V1.5, *then using USB battery packs and power supplies will
    be fine. If you don’t see a version identifier here, don’t use these power supplies.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*早期的micro:bit没有版本号。翻转你的micro:bit，查看底部右角靠近连接口0的地方。如果上面写的是*V1.3B*或*V1.5*，那么使用USB电池组和电源是可以的。如果你在这里看不到版本标识，最好不要使用这些电源。*'
- en: '*In either case, steer away from power supplies and USB batteries described
    as* high power.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*无论如何，都应避免使用被描述为*高功率的电源和USB电池。'
- en: '*You can read the micro:bit Foundation’s full safety advice at* [https://microbit.org/guide/safety-advice/](https://microbit.org/guide/safety-advice/).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以阅读micro:bit基金会的完整安全建议，地址是* [https://microbit.org/guide/safety-advice/](https://microbit.org/guide/safety-advice/)。'
- en: '**Connecting Electronics with Input/Output Pins**'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**连接电子设备与输入/输出引脚**'
- en: One especially fun thing about the micro:bit is that you can use the connections
    to attach electronic gadgetry of your own creation. In this book, you’ll build
    projects that use these connectors to control motors, lights, and a loudspeaker.
    You’ll also use them as inputs to gather data from sensors that measure light,
    sound, and temperature.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于micro:bit，有一件特别有趣的事情是，你可以利用它的连接口连接自己制作的电子设备。在本书中，你将构建一些项目，使用这些连接器来控制电机、灯光和扬声器。你还将使用它们作为输入，收集来自传感器的数据，这些传感器能够测量光线、声音和温度。
- en: The 3V and GND connections are there to supply power. The connections labeled
    0, 1, and 2 are usually referred to as *input/output pins*, and you’ll be attaching
    electronics to these.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 3V和GND连接口用于供电。标有0、1和2的连接口通常被称为*输入/输出引脚*，你将在这些引脚上连接电子设备。
- en: '**NOTE** *You might wonder why we call them* pins *when they look nothing like
    pins. The term* pin *comes from the chip on the circuit board that the micro:bit
    connects to. The chip does have a pin—a tiny leg-like connection—for each of these
    three pins.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** *你可能会好奇，为什么我们称这些为*引脚*，它们看起来和引脚完全不同。术语*引脚*来源于micro:bit连接的电路板上的芯片。该芯片上确实有引脚—每个引脚都有一个微小的腿形连接。*'
- en: 'The pins 0, 1, and 2 can be used for:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚0、1和2可以用于：
- en: '![Image](../images/play.jpg)  Digital output—turning an external LED on and
    off, for example'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/play.jpg)  数字输出—例如，控制外部LED的开关'
- en: '![Image](../images/play.jpg)  Analog output—controlling the brightness of an
    LED, for example'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/play.jpg)  模拟输出—例如，用来控制LED的亮度'
- en: '![Image](../images/play.jpg)  Pulse generation—to control a servo motor, for
    example'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/play.jpg)  脉冲生成—例如，用来控制伺服电机'
- en: '![Image](../images/play.jpg)  Digital input—to detect when an external button
    has been pressed, for example'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/play.jpg)  数字输入—例如，当外部按钮被按下时进行检测'
- en: '![Image](../images/play.jpg)  Analog input—to measure temperature using an
    analog temperature sensor, for example'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/play.jpg)  模拟输入——例如，使用模拟温度传感器来测量温度'
- en: '![Image](../images/play.jpg)  Touch input—to detect that you have touched the
    pin or a wire connected to a pin'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/play.jpg)  触摸输入——用于检测你是否触摸了引脚或连接到引脚的电线'
- en: '**Digital and Analog Inputs**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**数字输入和模拟输入**'
- en: 'When you use a pin as a digital output, you can write commands in your programs
    to turn the output on (set it to 3V) or turn it off (set it to 0V), but *only*
    on or off—nothing in between. This is also the case with digital inputs: they
    can only ever be on or off. When your program code reads a digital input, if the
    voltage at the input is nearer 3V than 0V, then the input counts as being on;
    otherwise, it’s off.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将引脚用作数字输出时，你可以在程序中编写命令来开启输出（设置为3V）或关闭输出（设置为0V），但*只能*是开或关——没有中间状态。数字输入也是如此：它们只能是开或关。当你的程序代码读取数字输入时，如果输入端的电压接近3V而非0V，那么该输入被视为开启；否则，就是关闭状态。
- en: Analog inputs, however, can be somewhere between on and off. Analog inputs on
    a micro:bit can be any value between 0 and 1,023, depending on the voltage at
    the pin.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模拟输入的值可以介于开与关之间。micro:bit上的模拟输入可以是0到1,023之间的任何值，这取决于引脚的电压。
- en: '**Making an Analog Signal: Pulse Width Modulation**'
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成模拟信号：脉宽调制**'
- en: A micro:bit, like all other electronics, can work only with digital on or off
    signals. To get analog signals between 0 and 3V, electronic devices *simulate*
    the analog signal by providing a rapid series of digital pulses. The longer the
    pulse, the more power is delivered to whatever is connected to the analog output.
    This is known as *pulse width modulation*, or *PWM*. [Figure 1-5](ch01.xhtml#ch1fig5)
    shows PWM in action.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: micro:bit和所有其他电子设备一样，只能处理数字开关信号。为了获得0到3V之间的模拟信号，电子设备通过快速的数字脉冲序列来*模拟*模拟信号。脉冲持续时间越长，传递给连接到模拟输出的设备的功率就越大。这就是所谓的*脉宽调制*，或者*PWM*。[图1-5](ch01.xhtml#ch1fig5)展示了PWM的实际应用。
- en: '![Image](../images/01fig05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig05.jpg)'
- en: '*Figure 1-5: Analog outputs on the micro:bit delivering different amounts of
    power*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-5：micro:bit上的模拟输出提供不同量的功率*'
- en: If the output is connected to an LED and the pulse is at 3V only 5 percent of
    the time, the LED will appear to glow dimly. In contrast, if the pulse is at 3V
    for 90 percent of the time, the LED will appear to be at almost full brightness.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出连接到一个LED，并且脉冲只有5%的时间保持在3V，那么LED看起来会发出微弱的光。相比之下，如果脉冲有90%的时间保持在3V，那么LED看起来将接近全亮。
- en: Interestingly, in both cases, the LED would actually be flashing at 50 times
    a second, but the human eye can’t see a light flash that quickly. Instead, we
    just register a relatively dim or bright light.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在这两种情况下，LED实际上每秒闪烁50次，但人眼无法看见如此快速的闪烁。相反，我们只会感知到相对昏暗或明亮的光。
- en: If the three pins 0, 1, and 2 are not enough for your project, you can use an
    adapter to access the many pins between the three numbered ones.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果三个引脚0、1和2不足以满足你的项目需求，你可以使用适配器来访问这三个编号引脚之间的多个引脚。
- en: '**Built-In Peripherals**'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**内置外设**'
- en: The writing on the underside of the micro:bit gives us some clues about other
    things the micro:bit can do. Two areas at the bottom left are labeled *compass*
    and *accelerometer*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: micro:bit底部的文字为我们提供了一些关于micro:bit其他功能的线索。左下角的两个区域标记为*指南针*和*加速度计*。
- en: The compass is actually a *magnetometer*, meaning it measures the strength of
    magnetic fields. You can use it as a compass, but you can also use it to detect
    the presence of magnets.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指南针实际上是一个*磁力计*，意味着它可以测量磁场的强度。你可以将其用作指南针，但也可以用来检测磁铁的存在。
- en: The accelerometer measures forces acting on the accelerometer chip. Because
    gravity is a constant force pulling down on everything, you can, by measuring
    the forces acting in different directions, use the accelerometer to detect when
    the micro:bit is being tilted and by how much, as well as when it is being shaken
    or in free fall.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计测量作用于加速度计芯片的力。由于重力是一个常量，始终拉向地面，通过测量作用在不同方向上的力，你可以利用加速度计检测micro:bit何时被倾斜，以及倾斜的程度，还可以检测它是否被摇晃或处于自由落体状态。
- en: Also on the underside, you will see the words *BLE Antenna*. The micro:bit includes
    BLE (Bluetooth Low Energy) hardware that allows your micro:bit to communicate
    wirelessly with other micro:bits or Bluetooth-enabled phones.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，你还会看到*BLE天线*字样。micro:bit包含BLE（蓝牙低能耗）硬件，使得你的micro:bit可以与其他micro:bit或蓝牙支持的手机进行无线通信。
- en: Note that the technology for micro:bit-to-micro:bit communication is not actually
    Bluetooth; it just uses the same frequency. [Chapter 10](ch10.xhtml#ch10) is devoted
    to this feature of the micro:bit.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，micro:bit 之间的通信技术实际上并不是蓝牙；它只是使用相同的频率。[第10章](ch10.xhtml#ch10)专门讲解了 micro:bit
    的这一功能。
- en: '**HARDWARE ESSENTIALS**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**硬件必备**'
- en: 'There are a few things you’ll need for nearly all the experiments and projects
    in this book. They include:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一些东西来完成本书中的几乎所有实验和项目。它们包括：
- en: '**Micro:bit**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micro:bit**'
- en: '**Micro USB cable** To connect your micro:bit to a computer (Make sure this
    is a standard micro USB data cable and not a *charging cable*, which lacks the
    necessary connections for communication. You can’t use a charging cable to load
    programs onto the micro:bit.)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Micro USB 电缆** 用于将 micro:bit 连接到计算机（确保这是标准的 micro USB 数据电缆，而不是*充电电缆*，因为充电电缆缺乏必要的通信连接。你不能使用充电电缆将程序加载到
    micro:bit 上。）'
- en: '**Alligator clip cables** Ideally, these should be no longer than 4 to 5 inches
    to avoid getting tangled up.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**鳄鱼夹电缆** 最好不要超过4到5英寸，以避免缠绕。'
- en: '**3V AAA battery pack with two AAA batteries**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**3V AAA 电池组（包含两节 AAA 电池）**'
- en: '**USB power supply** You’ll need this only for some projects. (See earlier
    warning.)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**USB 电源** 只有某些项目需要使用它。（参见之前的警告。）'
- en: Each project or experiment will have a list of all the items you need, and the
    [appendix](app01.xhtml) at the end of the book gives more information about how
    to acquire these supplies.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目或实验都会列出所需的所有物品，本书末尾的[附录](app01.xhtml)提供了如何获取这些物品的更多信息。
- en: This book tries to keep project construction straightforward and, apart from
    the roving robot in [Chapter 6](ch06.xhtml#ch06), no soldering is required. For
    most projects, you just need alligator clip cables to connect things together.
    When making connections using alligator clips, it’s best to clip the cable in
    vertically so the teeth of the clip look like [Figure 1-6](ch01.xhtml#ch1fig6),
    as this makes it much less likely that the cables will come loose.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本书尝试保持项目构建简单明了，除了[第6章](ch06.xhtml#ch06)中的巡逻机器人，其他项目不需要焊接。对于大多数项目，你只需使用鳄鱼夹电缆将各个组件连接起来。使用鳄鱼夹连接时，最好将电缆垂直夹入，这样夹子的齿部就像[图1-6](ch01.xhtml#ch1fig6)一样，这样可以大大减少电缆松动的可能性。
- en: '![Image](../images/01fig06.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig06.jpg)'
- en: '*Figure 1-6: Securely attaching alligator clips*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-6：安全连接鳄鱼夹*'
- en: '**PROGRAMMING THE MICRO:BIT**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程 micro:bit**'
- en: Mad Scientists aren’t known for their patience, so let’s make our micro:bit
    do something. First, we’ll program our micro:bit.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 疯狂的科学家们可不以耐心著称，所以让我们让我们的 micro:bit 做点事情。首先，我们来编程我们的 micro:bit。
- en: One of the nice things about a micro:bit is that to get started with it, you
    just need a USB cable and a computer with a browser and internet connection. You
    can use a computer running on Windows, macOS, or Linux. As long as your device
    has a modern browser, such as Chrome, it will work fine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 micro:bit 的一个好处是，你只需要一根 USB 电缆和一台带有浏览器及互联网连接的计算机，就可以开始使用它。你可以使用运行 Windows、macOS
    或 Linux 的计算机。只要你的设备有现代浏览器（如 Chrome），就可以正常工作。
- en: 'We’ll first connect up the micro:bit. Then we’ll make a small program using
    two methods: the drag-and-drop Blocks code and MicroPython, which you need to
    type out.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先连接 micro:bit。然后我们将通过两种方法制作一个小程序：拖放式块代码和需要手动输入的 MicroPython。
- en: '**Connecting your Micro:bit**'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**连接你的 Micro:bit**'
- en: Start by connecting your micro:bit to your computer with a micro USB cable.
    Nearly all micro USB cables will work fine, but remember that charging-only cables
    don’t have the necessary data connections and won’t work. If you have trouble
    programming your micro:bit using the following instructions, try using a different
    USB cable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过 micro USB 电缆将 micro:bit 连接到计算机。几乎所有的 micro USB 电缆都可以正常工作，但请记住，只有充电电缆没有必要的数据连接，因此无法使用。如果按照以下说明编程时遇到问题，请尝试使用不同的
    USB 电缆。
- en: Once you connect your micro:bit, your operating system should react as if you’d
    just plugged in a USB flash drive. To transfer a program onto the micro:bit, find
    the micro:bit in your filesystem just like you’d find a flash drive or some other
    plug-in. Then copy a file called a *hex file* into the micro:bit folder icon,
    and, hey presto!, your program will be installed. Loading a program onto your
    micro:bit is also known as *flashing*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你连接了 micro:bit，操作系统应该会像你刚插入 USB 闪存驱动器一样做出反应。要将程序传输到 micro:bit，只需像找到闪存驱动器或其他插入设备一样，在文件系统中找到
    micro:bit。然后将一个名为 *hex 文件* 的文件复制到 micro:bit 文件夹图标中，嘿，程序就安装好了。将程序加载到 micro:bit
    上也叫做 *刷机*。
- en: Let’s make a hex file and flash it to our micro:bit.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个.hex文件并将其烧录到我们的微型:bit上。
- en: '**Programming with Blocks: Hello World**'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用积木编程：Hello World**'
- en: You can build programs for the micro:bit through the micro:bit website without
    downloading any software. We’ll make a program that scrolls some text across the
    LED display on the micro:bit. Open your browser and navigate to *[https://makecode.microbit.org](https://makecode.microbit.org)*,
    and you should see a window something like [Figure 1-7](ch01.xhtml#ch1fig7).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过微型:bit官网来编写程序，无需下载任何软件。我们将编写一个程序，使一些文本在微型:bit的LED显示屏上滚动。打开你的浏览器并访问* [https://makecode.microbit.org](https://makecode.microbit.org)*，你应该会看到一个类似于[图
    1-7](ch01.xhtml#ch1fig7)的窗口。
- en: '![Image](../images/01fig07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig07.jpg)'
- en: '*Figure 1-7: The* [https://makecode.microbit.org](https://makecode.microbit.org)
    *web page*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-7：* [https://makecode.microbit.org](https://makecode.microbit.org) *网页*'
- en: This is the editor that you build programs in. On the left is an image of a
    micro:bit that works like a virtual micro:bit, running whatever programs you write.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你编写程序的编辑器。左侧是一个微型:bit的图像，它像虚拟微型:bit一样工作，运行你编写的任何程序。
- en: The section in the middle is a list of categories such as Basic, Input, and
    Music. Within each of these categories, you’ll find *blocks* that you can drag
    onto the working area on the right. Each block is an instruction for your micro:bit.
    By dragging these blocks around and connecting them, you’ll write code using the
    Blocks language.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的部分是类别列表，如Basic、Input和Music。在这些类别中，你会找到可以拖到右侧工作区的*积木*。每个积木都是给微型:bit的指令。通过拖动这些积木并将它们连接起来，你将使用积木语言编写代码。
- en: 'You’ll notice that when you open the editor, there are already two blocks in
    the editing section: `on start` and `forever`. Any blocks inside the `on start`
    block will run once when the micro:bit first powers up, when a new program is
    uploaded, or when the micro:bit resets because you pressed the reset button. Whatever
    blocks are inside the `forever` block will run over and over again, until you
    stop the program.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当你打开编辑器时，编辑区已经有两个积木：`on start`和`forever`。任何位于`on start`积木内的代码会在微型:bit第一次启动、上传新程序，或因为你按下重置按钮而重置时执行。任何位于`forever`积木内的代码将会一遍又一遍地运行，直到你停止程序。
- en: For our first program, we don’t need the `forever` block, so select it and press
    DELETE to remove it from your program. Next, you need to add a `show string` block
    to your program—*string* is programming speak for *text*. To do this, click the
    **Basic** category, drag the `show string` block into the programming area, and
    place it inside the `on start` block, as shown in [Figure 1-8](ch01.xhtml#ch1fig8).
    If you have sound on your computer, you will hear a satisfying *click* as the
    blocks snap together.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个程序，我们不需要`forever`积木，所以选择它并按DELETE删除它。接下来，你需要将`show string`积木添加到程序中——*string*是编程术语，表示*文本*。为此，点击**Basic**类别，将`show
    string`积木拖到编程区域，并将其放置在`on start`积木内，如[图 1-8](ch01.xhtml#ch1fig8)所示。如果你的电脑有声音，你会听到积木拼接时发出的令人满意的*咔哒*声。
- en: Now click inside the text bubble and type `Hello World`. You can also type different
    text—whatever you want to see displayed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击文本气泡并输入`Hello World`。你也可以输入不同的文本——任何你希望显示的内容。
- en: '![Image](../images/01fig08.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig08.jpg)'
- en: '*Figure 1-8: Blocks code for displaying* Hello World'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-8：用于显示* Hello World 的积木代码'
- en: As soon as you drag the `show string` block into place, the virtual micro:bit
    on the left of the display should scroll your message across its display to show
    you what your program does.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将`show string`积木拖到合适的位置，显示区域左侧的虚拟微型:bit应会在其显示屏上滚动你的信息，展示程序的效果。
- en: Now let’s transfer your program to the real micro:bit. Connect your micro:bit
    using a USB cable and click **Download** at the bottom left of the web page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把你的程序传输到真实的微型:bit上。使用USB线连接你的微型:bit，并点击网页左下角的**下载**按钮。
- en: '![Image](../images/f0014-01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0014-01.jpg)'
- en: This will download the file from the editor in the same way as any other file
    that you might download from the internet. Where the file is saved will depend
    on your operating system and browser, but usually it’s in a folder called *Downloads*.
    Find this folder, click into it, and you should find a file called *microbit.hex*.
    Using the File Manager (or Finder on a Mac) select this file and drag it onto
    the micro:bit where it appears in your filesystem ([Figure 1-9](ch01.xhtml#ch1fig9)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将像从互联网上下载其他文件一样，从编辑器下载文件。文件保存的位置取决于你的操作系统和浏览器，但通常会保存在一个名为*Downloads*的文件夹中。找到这个文件夹，点击进入，你应该能找到一个名为*microbit.hex*的文件。使用文件管理器（或在Mac上使用Finder），选择该文件并将其拖到micro:bit上，当它出现在你的文件系统中时（见[图1-9](ch01.xhtml#ch1fig9)）。
- en: '![Image](../images/01fig09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig09.jpg)'
- en: '*Figure 1-9: Dragging a file onto your micro:bit*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-9：将文件拖到你的micro:bit上*'
- en: As soon as you release your mouse button, the file should start installing itself
    onto the micro:bit. You’ll know this is happening because the LED on the back
    of the micro:bit will start blinking. When the blinking ends, the micro:bit will
    reset itself and run the program, scrolling the text across its display. If you
    miss seeing the message, press the reset button on the back of the micro:bit to
    see it again.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你松开鼠标按钮，文件应该会开始自动安装到micro:bit上。你会知道它正在发生，因为micro:bit背面的LED将开始闪烁。当闪烁结束时，micro:bit会重置自己并运行程序，文本会在显示屏上滚动。如果你错过了看到消息，按下micro:bit背面的重置按钮可以再次查看。
- en: '**DOWNLOADING DIRECTLY TO YOUR MICRO:BIT**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接下载到你的MICRO:BIT**'
- en: Most browsers have an option to choose where a file is saved each time you download
    one. You can use this feature to download files directly onto your micro:bit.
    Then you don’t have to first download and then copy the file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浏览器都提供了一个选项，可以在每次下载文件时选择文件保存的位置。你可以利用这个功能将文件直接下载到micro:bit上。这样你就不必先下载文件再复制到micro:bit。
- en: To set this up in the Chrome browser, go to *chrome://settings/*, click **Advanced**,
    scroll down to the Downloads, and enable the option **Ask where to save each file
    before downloading**. That way, next time you click Download in the editor, you’ll
    be prompted for a location to save your file to and can select the micro:bit folder
    as the destination.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Chrome浏览器中设置此功能，请前往*chrome://settings/*，点击**高级**，向下滚动到下载部分，然后启用选项**下载前询问每个文件的保存位置**。这样，下次你在编辑器中点击下载时，就会提示你选择文件保存的位置，并且可以选择micro:bit文件夹作为目标。
- en: 'At the time of writing, flashing programs onto your micro:bit is about to get
    a whole lot easier for users of the Chrome browser. You can read about this feature
    here: *[https://support.microbit.org/support/solutions/articles/19000084059-beta-testing-web-usb](https://support.microbit.org/support/solutions/articles/19000084059-beta-testing-web-usb)*.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，通过Chrome浏览器将程序烧录到micro:bit上即将变得更加简单。你可以在这里阅读有关此功能的更多信息：*[https://support.microbit.org/support/solutions/articles/19000084059-beta-testing-web-usb](https://support.microbit.org/support/solutions/articles/19000084059-beta-testing-web-usb)*。
- en: '**Adding Graphics**'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加图形**'
- en: To display our message, we added a `show string` block to the `on start` block.
    The `on start` block is a special type of block called an *event block* that runs
    the code connected to it whenever a particular event happens. In this case, the
    event is the start of the program.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示我们的消息，我们将一个`show string`模块添加到了`on start`模块中。`on start`模块是一种特殊类型的模块，称为*事件模块*，每当特定事件发生时，它会运行与之连接的代码。在这个例子中，事件是程序的启动。
- en: Let’s make our program a bit more complicated by adding a new event that will
    detect when button A is pressed. To do this, click the **Input** category and
    drag an `on button A pressed` block into the program area. Next, drag a `show
    leds` block from the Basic category into the `on button A pressed` block. The
    squares in the `show leds` block represent each LED in the LED display. You can
    select which LEDs should light up by clicking them so they turn white. The result
    should look something like [Figure 1-10](ch01.xhtml#ch1fig10).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一个新的事件，使程序变得稍微复杂一点，这个事件将检测到按钮A被按下。当你做这个时，点击**输入**类别，将一个`on button A pressed`模块拖入程序区域。接着，从基础类别中拖动一个`show
    leds`模块到`on button A pressed`模块中。`show leds`模块中的方块表示LED显示器中的每个LED。你可以通过点击方块使其变白来选择应该亮起的LED。结果应该看起来像[图1-10](ch01.xhtml#ch1fig10)那样。
- en: '![Image](../images/01fig10.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig10.jpg)'
- en: '*Figure 1-10: Adding an LED pattern to the program*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-10：将LED图案添加到程序中*'
- en: The `show icon` block has a number of ready-made LED images if you want to choose
    one of those. Click **Download** again and copy the new hex file onto your micro:bit.
    Once the new program has been uploaded, you can test it by pressing button A.
    When you do so, the selected LEDs in the `show leds` block should light up on
    your micro:bit, as in [Figure 1-11](ch01.xhtml#ch1fig11).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`show icon`模块有许多现成的LED图像，如果你想选择其中的某一个，可以直接选择。再次点击**Download**并将新的hex文件复制到你的micro:bit上。上传新程序后，你可以通过按下A按钮来测试它。按下后，`show
    leds`模块中选择的LED应该会在micro:bit上亮起，如[图1-11](ch01.xhtml#ch1fig11)所示。'
- en: '![Image](../images/01fig11.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig11.jpg)'
- en: '*Figure 1-11: Displaying an LED pattern on an actual micro:bit*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-11：在实际的micro:bit上显示LED图案*'
- en: '**Saving and Sharing**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**保存和共享**'
- en: The *[https://makecode.microbit.org](https://makecode.microbit.org)* website
    remembers all your projects. Give your project a name by entering the name in
    the Save area next to the Download button, and your project will be saved. Whenever
    you change your program, it should automatically save, but to make sure, you can
    save manually by clicking the floppy-disk Save icon. Note that when you click
    Save, the hex file will also be downloaded, but you can just click Cancel if you’re
    not ready to flash the program onto your micro:bit.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*[https://makecode.microbit.org](https://makecode.microbit.org)*网站会记住你的所有项目。为你的项目命名，可以在“保存”区域输入名称，按钮旁边会出现“保存”按钮，你的项目就会被保存。每当你修改程序时，它应该会自动保存，但为了确保，你也可以点击软盘图标手动保存。请注意，当你点击保存时，hex文件也会被下载，但如果你不准备将程序刷入micro:bit，只需点击取消即可。'
- en: Note that your stored programs are actually kept in your browser cache, so if
    you delete your cache, you will lose your programs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你保存的程序实际上是保存在浏览器缓存中的，因此如果你删除了缓存，你将丢失程序。
- en: To switch between programs and start new ones, click **Home** at the top of
    the page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要在程序之间切换并开始新的程序，点击页面顶部的**Home**。
- en: To publish a program so others can see it, click **Share** next to Projects.
    This will ask you to confirm that you wish to publish your project. Click **Share**
    again, and you’ll see a link like the one in [Figure 1-12](ch01.xhtml#ch1fig12).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布一个程序让其他人看到，点击“Projects”旁边的**Share**按钮。这将要求你确认是否愿意发布项目。再次点击**Share**，你将看到像[图1-12](ch01.xhtml#ch1fig12)中所示的链接。
- en: '![Image](../images/01fig12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig12.jpg)'
- en: '*Figure 1-12: Sharing a project*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-12：共享项目*'
- en: You can give that URL to anyone, and when they put it in their browser, they’ll
    get a copy of your program to use. Note that because this is just a copy of your
    program, there’s no risk that they’ll spoil your original copy of the code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将那个网址发送给任何人，当他们在浏览器中输入时，他们将获得你的程序副本供使用。请注意，因为这只是你程序的副本，所以他们不会破坏你原始代码的副本。
- en: '**Finding Blocks**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查找模块**'
- en: The `show string` and `show leds` blocks we’ve used so far were pretty easy
    to find, but the Blocks editor contains a lot of blocks, and it keeps the ones
    you don’t use as often hidden. This way, you don’t see a confusing array of choices
    when you start out on your micro:bit adventure.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止使用的`show string`和`show leds`模块比较容易找到，但模块编辑器包含了大量的模块，而且它会将你不常用的模块隐藏起来。这样一来，当你开始使用micro:bit时，你就不会看到令人困惑的选项。
- en: These blocks are hidden in two ways. First, you may have noticed that when you
    select one of the block categories, such as Basic, an item labeled *. . . more*
    appears (see [Figure 1-13](ch01.xhtml#ch1fig13)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块有两种方式被隐藏。首先，你可能注意到，当你选择某个模块类别（如Basic）时，会出现一个标记为*. . . more*的项目（见[图1-13](ch01.xhtml#ch1fig13)）。
- en: '![Image](../images/01fig13.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig13.jpg)'
- en: '*Figure 1-13: Extra blocks in the* more *section*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-13：更多部分中的额外模块*'
- en: In the case of the Basic category, the more section contains blocks such as
    `clear screen` and `show arrow`. If you click through the other categories, you’ll
    see that they all have a more section, some with quite a few extra blocks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Basic”类别中，更多部分包含诸如`clear screen`和`show arrow`等模块。如果你点击其他类别，你会发现它们都有一个“更多”部分，有些类别还包含了不少额外的模块。
- en: Incidentally, hovering your mouse over a block will open a little information
    box telling you what the block does. Investing a little time in getting familiar
    with the various blocks will give you exciting ideas about what you can to do
    with your micro:bit.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，将鼠标悬停在某个模块上会打开一个小信息框，告诉你该模块的功能。花些时间熟悉各种模块，将激发你关于如何使用micro:bit的创意。
- en: The second place to find hidden blocks is in the Advanced category, just after
    Math ([Figure 1-14](ch01.xhtml#ch1fig14)). Selecting this category will reveal
    a host of other categories containing more advanced features of the Blocks language,
    starting with Functions. Again, spend a little time familiarizing yourself with
    the blocks. Don’t worry if it’s not obvious what some of them do. If you’re interested
    in a block that does a particular thing, you may find the search field useful
    for finding the block you want.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个可以找到隐藏块的地方是在“高级”类别中，位于数学后面（[图 1-14](ch01.xhtml#ch1fig14)）。选择该类别会显示更多包含 Blocks
    语言高级特性的类别，从函数开始。同样，花些时间熟悉这些块。如果你不确定某些块的功能，不用担心。如果你对某个做特定事情的块感兴趣，可以使用搜索框来查找你想要的块。
- en: '![Image](../images/01fig14.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig14.jpg)'
- en: '*Figure 1-14: The* Advanced *blocks category*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-14：*高级*块类别*'
- en: The categories in the Advanced section that you’ll use frequently are Text and
    Pins. In some chapters, you’ll also be using Functions and Arrays.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在“高级”部分，你将频繁使用的类别是文本和引脚。在某些章节中，你还会使用到函数和数组。
- en: '**Programming with MicroPython: Hello World**'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用 MicroPython 编程：你好，世界**'
- en: Blocks code is great for getting started with programming, because you can accomplish
    some really impressive things with just a few blocks. However, many people prefer
    writing a program in text rather than dragging blocks around. Typing lines of
    text is also more like regular programming.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Blocks 代码非常适合开始编程，因为你只需几个块就能完成一些非常令人印象深刻的事情。然而，许多人更喜欢编写文本程序，而不是拖动块。输入一行行的文本也更像常规的编程方式。
- en: MicroPython is an implementation of the Python 3 programming language that includes
    everything you need to program your micro:bit with Python. In fact, many of the
    blocks in Blocks code have direct equivalents in MicroPython, so switching from
    programming in Blocks to MicroPython is fairly straightforward. Python is a popular
    first programming language and is often taught in schools for that reason.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: MicroPython 是一种 Python 3 编程语言的实现，包含了你编写 micro:bit 程序所需的一切。事实上，Blocks 代码中的许多块在
    MicroPython 中都有直接的对应项，因此从 Blocks 编程切换到 MicroPython 是相当直接的。Python 是一种流行的初学者编程语言，因此通常在学校教授。
- en: '**Downloading the MicroPython Editor**'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**下载 MicroPython 编辑器**'
- en: We’ll use the *Mu* editor app (*[https://codewith.mu](https://codewith.mu)*),
    which has lots of features. It can be downloaded straight onto your computer.
    Mu also lets you flash your program directly to a micro:bit without having to
    drag the hex file around. The nice thing about Mu is that you don’t need internet
    access to flash the program once Mu has been downloaded.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 *Mu* 编辑器应用程序 (*[https://codewith.mu](https://codewith.mu)*)，它有很多功能。你可以直接将其下载到你的电脑上。Mu
    还允许你将程序直接刷入 micro:bit，而无需拖动 hex 文件。Mu 的好处是，一旦下载了 Mu，你就不需要互联网连接也能刷入程序。
- en: Download Mu from *[https://codewith.mu/#download](https://codewith.mu/#download)*.
    There are several versions of Mu, so it’s important that you get the right one
    for your computer. The download page will offer you different versions for different
    operating systems. If you’re a Windows user, download the version under Windows
    Installer that’s labeled *64-bit* ([Figure 1-15](ch01.xhtml#ch1fig15)). If you’re
    a macOS user, there’s just one version.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://codewith.mu/#download](https://codewith.mu/#download)* 下载 Mu。Mu
    有多个版本，因此确保你选择适合自己电脑的版本。下载页面会为不同操作系统提供不同的版本。如果你是 Windows 用户，请下载 Windows 安装程序下标注为
    *64-bit* 的版本（[图 1-15](ch01.xhtml#ch1fig15)）。如果你是 macOS 用户，只有一个版本。
- en: '![Image](../images/01fig15.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig15.jpg)'
- en: '*Figure 1-15: Downloading Mu*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-15：下载 Mu*'
- en: Run the installer and accept the license agreement and all the default options.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行安装程序，接受许可协议并选择所有默认选项。
- en: The first time you run Mu, it will offer you a choice of *modes*. Make sure
    to select the BBC micro:bit mode ([Figure 1-16](ch01.xhtml#ch1fig16)).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行 Mu 时，它会提供你选择*模式*的选项。确保选择 BBC micro:bit 模式（[图 1-16](ch01.xhtml#ch1fig16)）。
- en: '![Image](../images/01fig16.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig16.jpg)'
- en: '*Figure 1-16: Selecting the right version of Mu*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-16：选择正确版本的 Mu*'
- en: Mu will present you with a blank editor window where you’ll type your first
    program.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Mu 会为你提供一个空白的编辑窗口，在这里你将编写你的第一个程序。
- en: '**Writing the Program**'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编写程序**'
- en: 'Let’s give Mu a go! Add the following code in the Mu window:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试 Mu！在 Mu 窗口中添加以下代码：
- en: from microbit import *
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: display.scroll("Hello World")
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: display.scroll("Hello World")
- en: It should look something like [Figure 1-17](ch01.xhtml#ch1fig17).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像是[图 1-17](ch01.xhtml#ch1fig17)。
- en: '![Image](../images/01fig17.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig17.jpg)'
- en: '*Figure 1-17: Writing a MicroPython program in Mu*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-17：在 Mu 中编写 MicroPython 程序*'
- en: 'Save the program by clicking **Save** at the top of the Mu window. You’ll be
    prompted to enter a name for your program: call it *hello.py*.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击 Mu 窗口顶部的**Save**按钮保存程序。系统会提示你为程序输入一个名称：将其命名为 *hello.py*。
- en: Now, with your micro:bit connected to your computer, click **Flash** at the
    top of the Mu window. This should start the process of loading the hex file to
    the micro:bit, just as though you were dragging over a file produced by the Blocks
    editor. Once the flashing is complete, the *Hello World* message should scroll
    across the display.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，连接你的 micro:bit 到计算机后，点击 Mu 窗口顶部的**Flash**按钮。这将启动将 hex 文件加载到 micro:bit 的过程，就像你拖动一个由
    Blocks 编辑器生成的文件一样。一旦闪烁完成，*Hello World* 信息应该会在显示屏上滚动。
- en: 'Let’s take a closer look at the code. Here’s the first line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看代码。这是第一行：
- en: from microbit import *
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: 'You’ll find this line at the start of pretty much every MicroPython micro:bit
    program, because this is what tells MicroPython to include all the built-in code
    that makes it compatible with the micro:bit’s display and other hardware. This
    code isn’t automatically included because MicroPython can be used on a lot of
    different boards, not just the micro:bit. The line actually means: *from the microbit
    library, import everything* (`*` means everything). You could also enter `import
    microbit`, but then you’d have to prefix everything with `microbit`, which is
    a lot of extra typing.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在几乎每个 MicroPython micro:bit 程序的开头找到这一行代码，因为它告诉 MicroPython 包含所有使其与 micro:bit
    的显示和其他硬件兼容的内置代码。此代码不会自动包含，因为 MicroPython 可以在许多不同的板子上使用，而不仅仅是 micro:bit。实际上，这行代码的意思是：*从
    microbit 库中导入一切*（`*` 表示一切）。你也可以输入`import microbit`，但那样你就必须在每个命令前加上 `microbit`，这会多打很多字。
- en: 'The only other line of code in our minimal program displays a message on the
    display:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最小程序中的唯一其他一行代码是在显示器上显示信息：
- en: display.scroll("Hello World")
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: display.scroll("Hello World")
- en: This line uses the command `display.scroll`, which tells the micro:bit to scroll
    something across its display. Then you add a set of parentheses, inside of which
    we have some text enclosed in quotation marks. You use parentheses to add extra
    information to a command. In this case, the extra information (also called an
    *argument*) is the text you want to display. You also have to enclose the text
    in double quotes to show that the program should treat it as text, not as more
    programming commands.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行使用了命令`display.scroll`，它告诉 micro:bit 在显示屏上滚动某些内容。接着，你加了一对括号，括号内有一些被引号括起来的文本。你使用括号是为了在命令中添加额外的信息。在这种情况下，额外的信息（也叫做*参数*）是你想要显示的文本。你还需要将文本放在双引号中，以表明程序应将其视为文本，而不是更多的编程命令。
- en: If, when you flash the program onto a micro:bit, you see something other than
    *Hello World* (or nothing at all), you probably have an error in your code. When
    using a text-based programming language, you have to be precise in what you type.
    For example, misspelling a word such as `display` or `scroll` will cause an error
    when you run the program. Errors in programming are called *bugs*. Bugs only show
    up when the program tries to run on the micro:bit. If you get any bugs, you can
    carefully compare the code you wrote to the code in the book to make sure it all
    matches. But there’s another way to find and fix bugs—you can use the REPL.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在将程序刷入 micro:bit 时，你看到除了 *Hello World* 以外的内容（或者什么都没有），那么可能是你的代码中有错误。在使用基于文本的编程语言时，你必须准确地输入内容。例如，拼写错误如
    `display` 或 `scroll` 将导致程序运行时出错。编程中的错误被称为*bug*。bug 只会在程序尝试在 micro:bit 上运行时才会显现出来。如果你遇到
    bug，可以仔细对比你写的代码和书中的代码，确保它们完全一致。但还有另一种找到并修复 bug 的方法——你可以使用 REPL。
- en: '**The REPL**'
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**REPL**'
- en: The REPL (Read-Eval-Print-Loop) is a *command line interface* to MicroPython
    on the micro:bit—that is, it’s an area that lets you send Python commands directly
    to the micro:bit, without having to put them into a program first. If you entered
    the line 1 + 2 here, the REPL would respond with 3\. Similarly, if MicroPython
    encounters a problem when it tries to run, it can report this problem to you in
    the REPL without you having to wait for the micro:bit to try to display something.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: REPL（读取-评估-打印-循环）是 MicroPython 在 micro:bit 上的*命令行接口*——也就是说，它是一个让你直接向 micro:bit
    发送 Python 命令的区域，而无需先将它们放入程序中。如果你在这里输入 1 + 2，REPL 会返回 3。类似地，如果 MicroPython 在尝试运行时遇到问题，它可以在
    REPL 中报告这个问题，而不需要你等到 micro:bit 尝试显示某些内容。
- en: 'To experiment with the REPL, let’s deliberately introduce an error into our
    program by misspelling `scroll` so that it only has one `l`. Delete an `l` and
    click **Flash** again. The program will upload despite being faulty, but this
    time, the micro:bit display will say: `AttributeError: ''MicroBitDisplay'' object
    has no attribute ''scrol''`. It takes a long time to scroll out this message,
    so to get a clearer view of it, click the **REPL** button at the top of the Mu
    window and then click the reset button on the back of your micro:bit. You should
    then see the error message in full in the REPL (bottom of [Figure 1-18](ch01.xhtml#ch1fig18)).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '为了实验 REPL，让我们故意在程序中引入一个错误，将 `scroll` 拼写成只有一个 `l`。删除一个 `l`，然后再次点击 **Flash**。尽管程序有错误，仍然会上传，但这次，micro:bit
    显示屏将显示：`AttributeError: ''MicroBitDisplay'' object has no attribute ''scrol''`。由于滚动显示此消息需要较长时间，为了更清楚地查看，点击
    Mu 窗口顶部的 **REPL** 按钮，然后点击 micro:bit 背面的重置按钮。你应该能在 REPL 中完整看到错误信息（见 [图 1-18](ch01.xhtml#ch1fig18)）。'
- en: '![Image](../images/01fig18.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig18.jpg)'
- en: '*Figure 1-18: Catching errors using the REPL in Mu*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-18：在 Mu 中使用 REPL 捕获错误*'
- en: 'The `>>>` prompt in the REPL indicates that you can type Python commands here
    to run immediately on the micro:bit. Try typing the following after the `>>>`
    prompt and hitting ENTER at the end of the line (this time spell `scroll` correctly):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 中的 `>>>` 提示符表示你可以在这里输入 Python 命令，并立即在 micro:bit 上运行。尝试在 `>>>` 提示符后输入以下内容，并在行末按
    ENTER（这次正确拼写 `scroll`）：
- en: display.scroll("The REPL is useful")
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: display.scroll("The REPL is useful")
- en: Your micro:bit’s display should immediately scroll out the message, without
    your needing to upload a program. You don’t need to repeat the `import` command,
    because MicroPython has already executed `import`—it did so before it encountered
    the misspelled `scroll`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 micro:bit 显示屏应该会立即滚动出消息，而不需要你上传程序。你不需要重复 `import` 命令，因为 MicroPython 已经执行了
    `import`——它是在遇到拼写错误的 `scroll` 之前就执行过了。
- en: '**NOTE** *When you were typing in your Hello World program, you may have noticed
    Mu trying to help by guessing what you were typing. For example, if you type*
    `display` and then pause, a list of options (`clear`, `get_pixel`, `is_on`, `off`,
    `on`, `scroll`, `set_pixel`, and `show`) will appear. You can click on the one
    you want to save yourself some typing.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** *当你在输入 Hello World 程序时，可能注意到 Mu 尝试通过猜测你正在输入的内容来帮助你。例如，如果你输入* `display`
    然后暂停，选项列表（`clear`、`get_pixel`、`is_on`、`off`、`on`、`scroll`、`set_pixel` 和 `show`）将会出现。你可以点击你想要的选项，省去一些输入工作。'
- en: '**Adding Graphics**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加图形**'
- en: 'Let’s now add some graphics to the program, just like we did with the Blocks
    code. We again need to detect when button A has been pressed and then display
    the graphics pattern. This is a little trickier in MicroPython because this language
    doesn’t have the same concept of events that you find in the Blocks code. Instead,
    we have to write a *loop* that repeats the commands contained within it until
    told to stop. In our program, these commands will check for a button press and,
    if that event has happened, perform the necessary action. In other words, rather
    than being told that button A has been pressed, the program has to keep checking
    whether it’s been pressed. Here is the code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们像在 Blocks 代码中一样，为程序添加一些图形。我们需要再次检测按钮 A 是否被按下，然后显示图形模式。这在 MicroPython 中稍微复杂一些，因为这个语言没有像
    Blocks 代码那样的事件概念。相反，我们必须编写一个*循环*，让其中的命令重复执行，直到停止。我们的程序中，这些命令会检查按钮是否被按下，如果发生了这个事件，就执行必要的操作。换句话说，程序不是被告知按钮
    A 已被按下，而是必须不断检查它是否被按下。以下是代码：
- en: from microbit import *
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: display.scroll("Hello World")
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: display.scroll("Hello World")
- en: 'while True:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if button_a.was_pressed():'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'if button_a.was_pressed():'
- en: display.show(Image.CHESSBOARD)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: display.show(Image.CHESSBOARD)
- en: The `while True` line of code marks the start of the loop that will continue
    until something stops it, like you unplugging your micro:bit or pressing the reset
    button or CTRL-C at the REPL. Whenever you make a loop, make sure to indent any
    lines of code that should run in that loop. Luckily, Mu recognizes when you have
    started a loop and helpfully indents the next line for you.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`while True`代码行标志着循环的开始，循环将一直执行，直到有某些操作停止它，比如你拔掉micro:bit的电源，按下重置按钮，或在REPL中按CTRL-C。每当你创建一个循环时，请确保将任何应在该循环中执行的代码行进行缩进。幸运的是，Mu会识别你何时开始一个循环，并自动为下一行代码添加缩进。'
- en: The first line within the loop is an `if` statement. This uses the `button_a.was_pressed`
    function to check whether the button has been pressed since last time `was_pressed`
    was used. If it has, then the lines indented below the `if` statement will be
    run. You’ll notice that the next line is indented even more, which means this
    line should only run if the `if` line is true (so if the button was indeed pressed).
    In this case, this line of code tells the display to show a ready-made graphic
    that belongs to the Image library. I’ve chosen the `CHESSBOARD` image. We’ll talk
    about `if` commands more later in “`if` Blocks” on [page 29](ch01.xhtml#page_29).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中的第一行是一个`if`语句。它使用`button_a.was_pressed`函数来检查自从上次使用`was_pressed`以来按钮是否被按下。如果是，那么`if`语句下面缩进的代码将被执行。你会注意到，接下来的代码行会进一步缩进，这意味着这行代码只会在`if`语句为真时运行（也就是按钮确实被按下时）。在这种情况下，这行代码告诉显示器显示一个来自图像库的现成图形。我选择了`CHESSBOARD`图像。稍后我们将在[第29页](ch01.xhtml#page_29)的“`if`
    块”中详细讨论`if`命令。
- en: In Python, indentation is very important, and remembering to indent can be a
    big cause of frustration when first learning the language. Lines that are indented
    within, for example, a `while` or an `if` command must be indented by exactly
    the same amount. In Mu, this is four spaces. As you practice coding in Python,
    knowing when to indent will become easier and easier.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，缩进非常重要，记得缩进可能是刚开始学习这门语言时的一个大难题。比如，在`while`或`if`命令中的缩进行必须精确地缩进相同的数量。在Mu中，这是四个空格。随着你不断练习Python编程，知道何时缩进将变得越来越容易。
- en: '**PROGRAMMING CONCEPTS**'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编程概念**'
- en: Here we’ll go over some key ideas in programming that are worth understanding,
    particularly when you want to modify some project code or start making your own
    projects. These ideas are the same whether you’re using the Blocks editor or MicroPython,
    so we’ll cover how to execute each concept both ways, first in Blocks code and
    then in the MicroPython equivalent.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍一些编程中的关键概念，特别是当你想修改一些项目代码或开始创建自己的项目时，这些概念非常值得理解。无论你使用的是“块编辑器”还是“MicroPython”，这些概念都是相同的，因此我们将分别介绍如何使用这两种方式来实现每个概念，先是用块代码，然后是对应的MicroPython代码。
- en: '**Variables**'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**变量**'
- en: A *variable* is a name associated with a value or multiple values. When you
    want to use the value, you can call the name in your code. Let’s illustrate this
    idea with some examples.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*是与一个或多个值相关联的名称。当你想使用这个值时，可以在代码中调用这个名称。让我们通过一些例子来说明这个概念。'
- en: '**The Blocks Code**'
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**块代码**'
- en: One of the main categories in the Blocks editor is Variables. Start a new project
    by clicking **New Project** from the Blocks editor’s home page. Delete the `forever`
    block (we don’t need it) and then from the Variable category, click **Make a Variable...**.
    When prompted for a new variable name, enter `counter`. Drag the `set counter
    to 0` block into the programming area and click it onto the `on start` block.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在“块编辑器”中，主要的类别之一是“变量”。通过点击块编辑器主页中的**新建项目**来开始一个新项目。删除`永远`块（我们不需要它），然后从“变量”类别中点击**创建一个变量...**。当提示输入新变量名称时，输入`计数器`。将`将计数器设置为
    0`块拖到编程区，并将其点击到`开始时`块上。
- en: Next, from the Input category, add an `on button A pressed` block. Inside this
    block, add a `change counter by 1` block from the Variables category and then
    a `show number` block from the Basic category. Finally, from the Variables category,
    drag out a `counter` block and click it into the `0` in the `show number` block
    to replace the `0`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在“输入”类别中添加一个`按下按钮 A`块。在这个块里面，添加一个来自“变量”类别的`计数器加 1`块，然后再添加一个来自“基础”类别的`显示数字`块。最后，从“变量”类别中拖出一个`计数器`块，将它点击到`显示数字`块中的`0`上，以替换掉`0`。
- en: Once you’ve done this programming, your code should look like the following.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这些编程，代码应该如下所示。
- en: '![Image](../images/f0026-01.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0026-01.jpg)'
- en: You can try out this program in the virtual micro:bit on the left of the editor
    by clicking button A. You should see the number displayed increase by 1.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击编辑器左侧虚拟的micro:bit来尝试这个程序，按下按钮A后，你应该会看到数字显示增加了1。
- en: Let’s have a look at what’s going on here. In the `on start` block, you make
    a variable called `counter` and give it an initial value of 0\. When the `on button
    A pressed` block is activated, the `change` block changes the value of the `counter`
    variable by adding 1 and then shows the value of the `counter` variable on the
    display.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这里发生了什么。在`on start`块中，你创建了一个名为`counter`的变量，并给它赋予初始值0。当`on button A pressed`块被激活时，`change`块通过加1来改变`counter`变量的值，然后在显示器上显示`counter`变量的值。
- en: In this case, our `counter` variable contains a number, but we can also set
    variables to hold text and even collections of data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的`counter`变量包含一个数字，但我们也可以设置变量来存储文本，甚至是数据集合。
- en: '**The MicroPython Code**'
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**MicroPython代码**'
- en: 'The MicroPython version of the program we just wrote looks like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚写的MicroPython版本程序如下所示：
- en: from microbit import *
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: counter = 0
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: counter = 0
- en: 'while True:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if button_a.was_pressed():'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'if button_a.was_pressed():'
- en: counter += 1
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: counter += 1
- en: display.scroll(str(counter))
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: display.scroll(str(counter))
- en: We import the usual micro:bit library, and then make a `counter` variable and
    give it an initial value of 0\. We make a `while` loop that ensures that if button
    A is pressed, 1 is added to `counter`. To add 1, we use `+=`, which is equivalent
    to the `change counter` block.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入常用的micro:bit库，然后创建一个`counter`变量，并赋予它初始值0。我们创建一个`while`循环，确保如果按下按钮A，则会给`counter`加1。为了加1，我们使用`+=`，它等价于`change
    counter`块。
- en: When we want to display the new value, we have to convert the numeric value
    into a text string with `str(counter)`, because the `display` command works only
    with strings.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要显示新值时，我们必须使用`str(counter)`将数字值转换为文本字符串，因为`display`命令只接受字符串。
- en: Note that it’s perfectly okay to use one command inside another. So here, we
    use the `str` command inside the `display.scroll` command by putting it inside
    parentheses. When you do this, the innermost command (`str` in this case) is run
    first and supplies a value to the next command (in this case `display.scroll`).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，完全可以将一个命令嵌套在另一个命令中。所以在这里，我们通过将`str`命令放入括号中来在`display.scroll`命令内使用它。当你这样做时，最内层的命令（在这个例子中是`str`）会先执行并将一个值传递给下一个命令（在这个例子中是`display.scroll`）。
- en: '**Arithmetic**'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算术**'
- en: In the previous example, you saw how we could add a number to a variable. As
    well as addition, we can use all the usual arithmetic options in programs, including
    subtraction, multiplication, and division.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，你看到我们如何将一个数字加到变量中。除了加法，我们还可以在程序中使用所有常见的算术操作，包括减法、乘法和除法。
- en: '**The Blocks Code**'
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**积木代码**'
- en: Say we wanted to keep doubling a number instead of counting by ones. We could
    alter the previous program so that the starting number for `counter` is 1 and
    the `on button A pressed` block multiplies `counter` by 2, as shown here.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将一个数字不断加倍，而不是按单位递增。我们可以修改之前的程序，使得`counter`的起始值为1，并且`on button A pressed`块将`counter`乘以2，如下所示。
- en: '![Image](../images/f0028-01.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0028-01.jpg)'
- en: Now, instead of using a `change counter by 1` block, we use a `set counter to`
    block and, inside that, use a multiply block (`×`). In the first part of the multiply
    block, we place the variable `counter`, and in the second part, we put the number
    `2`. Now every time button A is pressed, `counter` is given the value of 2 times
    its old value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再使用`change counter by 1`块，而是使用`set counter to`块，在里面使用一个乘法块（`×`）。在乘法块的第一部分，我们放入变量`counter`，在第二部分，我们放入数字`2`。现在，每次按下按钮A时，`counter`都会被赋值为其旧值的两倍。
- en: When we use blocks, math like this rapidly becomes quite complicated, as we
    need to nest blocks inside of blocks inside of other blocks. If we have a program
    that needs to do a lot of arithmetic, it may be better to code the project using
    MicroPython.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用积木时，这样的数学运算很快会变得相当复杂，因为我们需要在积木中嵌套积木，再在其他积木中嵌套。如果我们有一个需要进行大量算术运算的程序，使用MicroPython编码可能会更好。
- en: '**The MicroPython Code**'
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**MicroPython代码**'
- en: 'In MicroPython, we use arithmetic symbols such as `+`, `-`, `*` (multiply by),
    and `/` (divide). You can also use brackets to change the order of the math operations,
    as you do in math class. Here’s how we would rewrite the doubling Blocks program
    we just made:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在MicroPython中，我们使用算术符号，如`+`、`-`、`*`（乘法）和`/`（除法）。你还可以使用括号来改变数学运算的顺序，就像在数学课上那样。下面是我们如何重写刚刚制作的加倍程序：
- en: from microbit import *
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: counter = 1
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: counter = 1
- en: 'while True:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if button_a.was_pressed():'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下了 `button_a` 按钮：
- en: counter = counter * 2
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: counter = counter * 2
- en: display.scroll(str(counter))
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 显示 `counter` 的值（以字符串形式滚动显示）
- en: The key line here is `counter = counter * 2`. The `=` symbol after the variable
    name means that whatever follows the equal sign will be assigned to the variable
    as its new value. In this case, that’s `counter * 2` (counter times 2). You could
    also use the shorthand form `counter *= 2`, just as we did earlier when doing
    addition.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键行是 `counter = counter * 2`。变量名后的 `=` 符号表示后面的内容将被赋值给该变量，作为它的新值。在这种情况下，就是
    `counter * 2`（counter 乘以 2）。你也可以使用简写形式 `counter *= 2`，就像我们之前做加法时所做的那样。
- en: '**if Blocks**'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**if 积木**'
- en: Programs can be thought of as a series of steps that the micro:bit will carry
    out. Sometimes you’ll need your program to make decisions and execute particular
    steps based on those decisions. The blocks in the Logic category allow your programs
    to make decisions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以看作是一系列由 micro:bit 执行的步骤。有时候，你需要让程序根据条件做出决策并执行特定的步骤。逻辑类别中的积木让你的程序能够做出决策。
- en: We’ll make a variation of our counting-by-1 example that counts up to 10 and
    then goes back to 0 to start the counting process over.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个修改版的计数程序，它会计数到 10，然后回到 0，重新开始计数过程。
- en: '**The Blocks Code**'
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**积木代码**'
- en: Try making the following Blocks program.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试制作以下的积木程序。
- en: '![Image](../images/f0029-01.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0029-01.jpg)'
- en: First, we add an `if` block after the `change counter by 1` block. Onto the
    `if` block, we drop a comparison block that compares the value of `counter` to
    10\. If the `counter` value is greater than (`>`) 10, the program runs the blocks
    inside the `if` block. In this case, the `if` block contains a single block that
    sets `counter` back to 0\. If `counter` is not greater than 10, then it continues
    to show the number on the display.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `change counter by 1` 积木后添加一个 `if` 积木。接着在 `if` 积木上放置一个比较积木，用来将 `counter`
    的值与 10 进行比较。如果 `counter` 的值大于（`>`）10，程序将执行 `if` 语句内的积木。在这种情况下，`if` 语句内有一个积木将 `counter`
    重置为 0。如果 `counter` 的值不大于 10，那么程序将继续在显示屏上显示当前的数字。
- en: There are other variants of the `if` block that let you carry out one action
    if a condition is true and another action if the condition is false. You’ll learn
    more about these in later chapters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他版本的 `if` 积木，它允许你在条件为真时执行一个动作，在条件为假时执行另一个动作。你将在后续章节中学到更多关于这些积木的内容。
- en: '**The MicroPython Code**'
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**MicroPython 代码**'
- en: 'We’ve already used `if` in MicroPython when we checked whether a button had
    been pressed. Here, we’re not just using it to see whether a condition is true
    or false. Instead, we’re comparing the variable `counter` to the value 10\. The
    MicroPython version of the Blocks code looks like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经在 MicroPython 中使用过 `if`，检查按钮是否被按下。这里，我们不仅仅是用它来判断一个条件是成立还是不成立，而是将变量 `counter`
    与值 10 进行比较。MicroPython 版的积木代码如下所示：
- en: from microbit import *
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: counter = 0
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: counter = 0
- en: 'while True:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if button_a.was_pressed():'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下了 `button_a` 按钮：
- en: counter += 1
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: counter += 1
- en: 'if counter > 10:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'if counter > 10:'
- en: counter = 0
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: counter = 0
- en: display.scroll(str(counter))
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 显示 `counter` 的值（以字符串形式滚动显示）
- en: 'Take a good look at the indentation of this program: we have an `if` inside
    another `if`, which is itself inside a `while`. See if you can figure out how
    this code works, using the explanation of the Blocks version as a guide.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看这个程序的缩进：我们在一个 `if` 语句内嵌套了另一个 `if` 语句，而这个 `if` 又嵌套在一个 `while` 语句中。看看你是否能理解这段代码是如何工作的，可以参考积木版的解释。
- en: '**Strings**'
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: Remember that a string is a series of characters (numbers, letters, or punctuation),
    often a word. You used a string in your very first Hello World program in [Figure
    1-8](ch01.xhtml#ch1fig8) to display the message *Hello World*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，字符串是字符（数字、字母或标点符号）的序列，通常是一个单词。你在你的第一个 Hello World 程序中使用了字符串，在 [图 1-8](ch01.xhtml#ch1fig8)
    中显示了消息 *Hello World*。
- en: '**The Blocks Code**'
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**积木代码**'
- en: Most of the blocks for strings can be found in the Text category. The simplest
    of these is a block with a pair of quotes and a gap where you can add your own
    text to make a string. You can use this block to assign a string, rather than
    a number, to a variable. Here we set the `message` variable to a string. This
    program will display the string’s length.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数字符串相关的积木可以在“文本”类别中找到。其中最简单的是一个带有一对引号和一个空白的积木，你可以在其中添加自己的文本来创建字符串。你可以使用这个积木为变量赋值字符串，而不是数字。这里我们将
    `message` 变量设为一个字符串。这个程序将显示字符串的长度。
- en: '![Image](../images/f0031-01.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0031-01.jpg)'
- en: We use an `on start` block, inside which we set the value of the variable `message`
    to some text. In the `show number` block, you can see a `length of` block and,
    inside that, the `message` variable. The `length of` block supplies the number
    of characters in the string message to `show number`, which then scrolls that
    number across the display.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个`on start`块，在其中我们将变量`message`的值设置为某些文本。在`show number`块中，你可以看到一个`length
    of`块，在该块内是`message`变量。`length of`块将字符串`message`的字符数传递给`show number`，然后该块会在显示屏上滚动显示这个数字。
- en: The Text category has other blocks that let you do things, like join together
    two strings, chop out a section of a string, and convert a string into a number.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 文本类别还有其他块，可以让你执行一些操作，例如连接两个字符串、剪切字符串的一部分以及将字符串转换为数字。
- en: '**The MicroPython Code**'
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**MicroPython代码**'
- en: 'In MicroPython, string values are distinguished from other program code by
    being enclosed in double quotes, just as in Blocks code. We would write the previous
    Blocks program like this in MicroPython:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在MicroPython中，字符串值与其他程序代码的区别是被双引号括起来的，就像在代码块中一样。我们会像这样在MicroPython中编写前面的代码块程序：
- en: from microbit import *
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: message = "This text is in a variable."
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: message = "这段文本存储在一个变量中。"
- en: 'while True:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: display.scroll(str(len(message)))
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: display.scroll(str(len(message)))
- en: This works in the same way as the Blocks code. Notice that we use the `str`
    command to convert the length of the string `len` into a string itself so that
    it can be displayed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这与代码块中的方式相同。注意，我们使用`str`命令将字符串长度`len`转换为字符串本身，以便能够显示出来。
- en: '**Arrays and Lists**'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**数组和列表**'
- en: So far, we’ve used variables that contain just a single piece of data, whether
    that’s a number or string. But sometimes you need to keep a collection of values
    in a variable, often to access each value in turn, like a sequence of notes that
    make up a tune (as you’ll see in [Chapter 2](ch02.xhtml#ch02)).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的变量只包含单一的数据项，无论是数字还是字符串。但有时你需要在一个变量中保存一组值，通常是为了按顺序访问每个值，就像组成旋律的音符序列一样（你将在[第2章](ch02.xhtml#ch02)中看到）。
- en: In Blocks code, a collection of values is called an *array*, and in MicroPython,
    it’s called a *list*. The idea is the same for both, however.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块中，一组值被称为*数组*，而在MicroPython中，它被称为*列表*。不过，两个的概念是相同的。
- en: '**The Blocks Code**'
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**代码块**'
- en: The Blocks editor has an Array category that contains array-related blocks.
    The most important are `set list to`, `set text list to`, and `get value at`.
    The first two allow you to create a list containing numbers or strings, respectively,
    and `get value at` lets you access a particular element of an array.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块编辑器有一个数组类别，其中包含与数组相关的块。最重要的是`set list to`，`set text list to`和`get value at`。前两个允许你创建包含数字或字符串的列表，而`get
    value at`让你访问数组中的特定元素。
- en: The following small program creates a variable called `colors` and assigns it
    to an `array of` four strings. Then it picks a random item from that array to
    display. Note that the `array of` block has `+` and `-` buttons that allow you
    to adjust the number of items in the array when you create it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下这个小程序创建了一个名为`colors`的变量，并将其分配给一个包含四个字符串的`array of`。然后它从这个数组中随机选择一个元素进行显示。请注意，`array
    of`块有`+`和`-`按钮，可以在创建时调整数组中的项数。
- en: '![Image](../images/f0032-01.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0032-01.jpg)'
- en: We add an `on button A pressed` block. Inside it, we add a `show string` block,
    inside which we add a `get value at` block. We then add `pick random` (found in
    the Math category) to choose any number from 0 to 3\. Altogether, this means that
    when button A is pressed, the `pick random` block selects a random number between
    0 and 3 and fetches the array element at that position, and then the `show string`
    block displays that element. Note that in both Blocks and MicroPython programming,
    array numbering starts at 0 rather than 1, so if the number 0 is randomly chosen,
    the *first* element of the array will be displayed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个`on button A pressed`块。在其中，我们添加一个`show string`块，在该块内添加一个`get value at`块。然后我们添加`pick
    random`（在数学类别中找到）来选择0到3之间的任意数字。总之，这意味着当按下A按钮时，`pick random`块会选择一个0到3之间的随机数，并获取该位置的数组元素，然后`show
    string`块会显示该元素。请注意，在代码块和MicroPython编程中，数组的编号从0开始，而不是1，所以如果随机选择的是数字0，那么数组的*第一个*元素会被显示出来。
- en: '**The MicroPython Code**'
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**MicroPython代码**'
- en: 'This is how you would write the previous Blocks program in MicroPython:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你如何在MicroPython中编写前面代码块程序的方法：
- en: from microbit import *
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: from microbit import *
- en: import random
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: numbers = ["orange", "yellow", "green", "blue"]
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = ["orange", "yellow", "green", "blue"]
- en: 'while True:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if button_a.was_pressed():'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 'if button_a.was_pressed():'
- en: display.scroll(numbers[random.randint(0, 3)])
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: display.scroll(numbers[random.randint(0, 3)])
- en: In MicroPython, we use square brackets, `[` and `]`, to enclose the elements
    of a list, and we separate the list elements with commas. We also use square brackets
    to access a particular element of a list using its position. In this case, the
    `random.randint` command, which returns a number between 0 and 3, is enclosed
    within the square brackets.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在MicroPython中，我们使用方括号`[`和`]`来包含列表的元素，并用逗号分隔列表元素。我们还使用方括号通过元素的位置来访问列表中的特定元素。在此例中，`random.randint`命令返回一个0到3之间的数字，它被包含在方括号内。
- en: '**Programming Wrap-Up**'
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**编程总结**'
- en: This has been a very quick introduction to programming the micro:bit. All the
    code for this book is available for download, so you don’t have to master programming
    before you start doing experiments and making projects. As you progress through
    this book, you’ll be introduced to new blocks and MicroPython language features,
    which I’ll explain as they come up.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对micro:bit编程的一个快速介绍。本书的所有代码都可以下载，因此你无需在开始进行实验和制作项目之前掌握编程。随着你逐步阅读本书，你将接触到新的模块和MicroPython语言特性，我会在它们出现时进行解释。
- en: 'For more information on MicroPython for the micro:bit, see *[https://microbit-micropython.readthedocs.io](https://microbit-micropython.readthedocs.io)*.
    If you’re new to Python, you might find my book *Programming micro:bit: Getting
    Started with MicroPython* (McGraw-Hill, 2018) a useful accompaniment to this book.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有关micro:bit的MicroPython的更多信息，请参见*[https://microbit-micropython.readthedocs.io](https://microbit-micropython.readthedocs.io)*。如果你是Python新手，你可能会发现我的书*《编程micro:bit：MicroPython入门》*（麦格劳-希尔出版社，2018年）是这本书的有用补充。
- en: '**DOWNLOADING THE CODE**'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**下载代码**'
- en: Some of the programs in this book are long and complex, and typing them out
    might not be something that a Mad Scientist such as yourself is eager to do. If
    you don’t want to make the programs yourself, you can just download them and flash
    them to your micro:bit.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的一些程序很长且复杂，输入这些代码可能不是像你这样的疯狂科学家愿意做的事情。如果你不想自己编写程序，你可以直接下载它们并将其闪存到你的micro:bit上。
- en: '**Downloading the Blocks Code**'
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**下载Blocks代码**'
- en: All the Blocks code is published on GitHub at *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*.
    When you click a link for the Blocks code, the project will open in your browser.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Blocks代码都发布在GitHub上，地址是*[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*。当你点击一个Blocks代码链接时，项目将在浏览器中打开。
- en: Scroll down the GitHub page until you will see something like [Figure 1-19](ch01.xhtml#ch1fig19).
    You’re looking for a list of links to all the Blocks code programs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动GitHub页面，直到你看到类似于[图 1-19](ch01.xhtml#ch1fig19)的内容。你要寻找的是一个包含所有Blocks代码程序链接的列表。
- en: '![Image](../images/01fig19.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig19.jpg)'
- en: '*Figure 1-19: Links to the Blocks code for all the programs in this book*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-19：本书中所有程序的Blocks代码链接*'
- en: To open one of the programs, just click the link. For example, [Figure 1-20](ch01.xhtml#ch1fig20)
    shows the result of clicking the link for the musical doorbell project.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开其中一个程序，只需点击链接。例如，[图 1-20](ch01.xhtml#ch1fig20)显示了点击音乐门铃项目链接的结果。
- en: '![Image](../images/01fig20.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig20.jpg)'
- en: '*Figure 1-20: Following a link to the Blocks code for the musical doorbell
    project*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-20：跟随链接到音乐门铃项目的Blocks代码*'
- en: You’ll notice that [Figure 1-20](ch01.xhtml#ch1fig20) does not look like the
    normal Blocks editor window. That’s because you’re to just view the code here
    and flash it onto your micro:bit to use. If you want to edit the code, or just
    see the code in its more familiar editor, click the **Edit** button at the top
    right. This will make a copy of the original program for you, and then you’ll
    be able to edit this copy.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，[图 1-20](ch01.xhtml#ch1fig20)看起来不像正常的Blocks编辑器窗口。这是因为你只是要在这里查看代码并将其闪存到你的micro:bit上使用。如果你想编辑代码，或者只是想在更熟悉的编辑器中查看代码，请点击右上角的**编辑**按钮。这将为你创建一个原始程序的副本，然后你就可以编辑这个副本。
- en: '**Downloading the MicroPython Code**'
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**下载MicroPython代码**'
- en: You can download the MicroPython programs from *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从*[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*下载MicroPython程序。
- en: If you’re used to using the Git software, you can clone the entire project onto
    your computer. For non-Git-experts, here’s a step-by-step guide for getting all
    the code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯使用Git软件，你可以将整个项目克隆到你的计算机上。对于非Git专家，这里有一个逐步的指南，帮助你获取所有的代码。
- en: Visit *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*
    and then click the green **Clone or download** button and select **Download ZIP**,
    as shown in [Figure 1-21](ch01.xhtml#ch1fig21).![Image](../images/01fig21.jpg)
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 *[https://github.com/simonmonk/mbms/](https://github.com/simonmonk/mbms/)*，然后点击绿色的
    **克隆或下载** 按钮，选择 **下载 ZIP**，如 [图 1-21](ch01.xhtml#ch1fig21) 所示。![图片](../images/01fig21.jpg)
- en: '*Figure 1-21: Downloading the code for this book*'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 1-21：下载本书的代码*'
- en: Find the ZIP file you just downloaded (*mbms-master.zip*) in your downloads
    folder and extract all the files from it.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到你刚刚下载的 ZIP 文件（*mbms-master.zip*），然后提取其中的所有文件。
- en: The process of extracting the files will vary, depending on whether you use
    Windows, macOS, or Linux. On macOS and most Linux distributions, a ZIP file will
    automatically extract when you open it. If you’re a Windows user, be aware that
    while Windows will let you look inside the ZIP file without extracting it into
    separate files, you won’t be able to use the files unless you extract them. To
    extract the files in Windows, right-click the archive file in File Explorer and
    select the option **Extract All** ([Figure 1-22](ch01.xhtml#ch1fig22)).
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提取文件的过程会有所不同，具体取决于你使用的是 Windows、macOS 还是 Linux。在 macOS 和大多数 Linux 发行版中，打开 ZIP
    文件时会自动提取文件。如果你是 Windows 用户，请注意，尽管 Windows 允许你查看 ZIP 文件的内容而不需要将文件提取到单独的文件夹中，但除非提取文件，否则你无法使用这些文件。在
    Windows 中提取文件，右键点击文件资源管理器中的压缩文件，然后选择“提取所有”选项（见 [图 1-22](ch01.xhtml#ch1fig22)）。
- en: '![Image](../images/01fig22.jpg)'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../images/01fig22.jpg)'
- en: '*Figure 1-22: Extracting the ZIP archive file in Windows*'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 1-22：在 Windows 中提取 ZIP 压缩包文件*'
- en: The extracted files will be contained in a directory called *mbms-master*. Within
    this directory, you’ll find another directory called *python*, and within this,
    you’ll find all the MicroPython programs for the book as separate files, each
    with the file extension *.py*.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提取的文件将保存在一个名为 *mbms-master* 的文件夹中。在这个文件夹内，你将找到另一个名为 *python* 的文件夹，在里面你将找到本书的所有
    MicroPython 程序，每个程序都是单独的文件，扩展名为 *.py*。
- en: Unfortunately, you can’t just double-click a program to open it in Mu. To open
    a program, first open Mu and go to Load. Then find the MicroPython program you
    want to open. As a shortcut, I suggest you move all the MicroPython programs from
    the *python* folder that you just downloaded into the folder where Mu normally
    expects to find its programs. By default, this is a directory within your home
    directory called *mu_code*. Now when you click the Load button in Mu, you’ll see
    all the MicroPython programs straight away.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，你不能只需双击程序在 Mu 中打开它。要打开程序，首先打开 Mu 并选择“加载”选项。然后找到你想要打开的 MicroPython 程序。作为快捷方式，我建议你将刚刚下载的
    *python* 文件夹中的所有 MicroPython 程序移动到 Mu 通常寻找程序的文件夹中。默认情况下，这个文件夹位于你的主目录下，名为 *mu_code*。现在，当你在
    Mu 中点击“加载”按钮时，你将立刻看到所有的 MicroPython 程序。
- en: '**SUMMARY**'
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Now that we’ve looked at some of the basics of the micro:bit, it’s time to get
    started with some proper Mad Scientist experimentation and project work. We’ll
    begin with making and detecting sounds using a micro:bit.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 micro:bit 的一些基础知识，是时候开始进行一些真正的疯狂科学实验和项目工作了。我们将从使用 micro:bit 制作和检测声音开始。
