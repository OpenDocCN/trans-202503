["```\nvoid loop() {\n  // While the ADC interrupt is enabled, wait. The program is\n  // still gathering audio samples in the capture buffer.\n  while (ADCSRA & _BV(ADIE)) {\n    // Wait...\n  }\n\n  // The sampling interrupt has finished filling the buffer,\n  // so show the output we computed last time through the\n  // loop. This sends the data to the LED strip.\n  strip.show();\n\n  // Perform the FFT algorithm to convert samples to\n  // complex numbers.\n  fft_input(capture, bfly_buff);\n\n  // Now that we've updated the LED strip and processed the\n  // audio samples with FFT, we can resume the collection\n  // of audio samples in the sample buffer. The interrupt\n  // service routine (ISR) will run while we compute the next\n  // LED output based on the audio samples we captured.\n  startSampling();\n\n  // Perform the rest of the FFT computation:\n  fft_execute(bfly_buff);          // Process complex data\n  fft_output(bfly_buff, spectrum); // Complex -> spectrum\n\n  // Now call this to analyze the audio. See comments in this\n  // function for details.\n  analyzeAudioSamples();\n\n  // The peak values for each of the 8 bands has been\n  // computed. A bit in the 8-bit value newPeakFlags\n  // indicates whether the analysis found a *new* peak\n  // in the band.\n  for (i = 0; i <= CUTOFF_BAND; i++) {\n    // If a new peak was found in band i...\n    if (newPeakFlags & (1 << i)) {\n      // Map the peak value to a magnitude in range [0,255].\n      // We pass in the band number because the mapping is\n      // different for different bands.\n      uint8_t magnitude = getMagnitude(i, bandPeakLevel[i]);\n\n      // A nonzero magnitude means that the peak value is\n      // large enough to do something visually with it. We\n      // ignore small peaks.\n      if (magnitude > 0) {\n        // We want to store the information about the peak\n        // in a peak_t structure. When we actually draw a\n        // visualization, the peak_t structures in peaks[]\n        // represent the \"visually active\" band peaks.\n\n        // Look through the list of peak structures 'peaks'\n        // for an unused one.\n        for (j = 0; j < N_PEAKS; j++) {\n          if (peaks[j].magnitude == 0) {\n            // Unused peak found.\n            peakIndex = j;\n            break;\n          }\n        }\n        // If an unused one not found, we use the last one\n        // that was used (peakIndex).\n\n        // Initialize the structure.\n        peaks[peakIndex].age = 0;\n        // A random component for a visualization to use. For\n        // example, to shift the color a small amount.\n        peaks[peakIndex].rnd = random(255); \n        peaks[peakIndex].baseColor =\n          getRandomBaseColor(peaks[peakIndex].rnd);\n        peaks[peakIndex].magnitude = magnitude;\n      }\n    }\n  }\n\n  // Clear the last frame.\n  strip.clear();\n  // Draw the peaks on the LED strip.\n  doVisualization();\n} // end loop()\n```", "```\nyour_sketchbook\n |\n +--libraries\n |   |\n |   +--ffft\n |   |\n |   +--Adafruit_NeoPixel\n |\n +--RealtimeMusicVisualizer\n     |\n     +--RealtimeMusicVisualizer.h\n     +--RealtimeMusicVisualizer.ino\n```", "```\n    #define N_LEDS 180\n    ```", "```\n    #define SINGLE_DIRECTION true\n    ```", "```\n    #define CUTOFF_BAND 4\n    ```", "```\n    #define MAX_BRIGHTNESS 100\n    ```", "```\n    #define MIN_COLOR_CHANGE_COUNT 1\n    #define MAX_COLOR_CHANGE_COUNT 1\n    ```"]