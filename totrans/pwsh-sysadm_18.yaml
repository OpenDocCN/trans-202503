- en: '15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PROVISIONING A VIRTUAL ENVIRONMENT
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*PowerLab* is a final, massive project using all the concepts you’ve learned
    and more. It’s a project that automates the provisioning of Hyper-V virtual machines
    (VMs) all the way up to installing and configuring services including SQL and
    IIS. Imagine being able to run a single command such as `New-PowerLabSqlServer`,
    `New-PowerLabIISServer`, or even `New-PowerLab`, wait a few minutes, and have
    a fully configured machine (or machines) pop out. That’s what you’re going to
    get if you stick with me throughout the rest of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the PowerLab project is to remove all the repetitive, time-consuming
    tasks required to bring up a test environment or a lab. When you’re done, you
    should have just a handful of commands to build an entire Active Directory forest
    from nothing but a Hyper-V host and a few ISO files.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve purposefully not covered *everything* that’s going into PowerLab in Parts
    I and II. Instead, I challenge you to notice these areas and come up with unique
    solutions on your own. After all, in programming there are always lots of ways
    to accomplish the same task. If you get stuck, please feel free to reach out to
    me on Twitter at @adbertram.
  prefs: []
  type: TYPE_NORMAL
- en: By building a project of this scale, you will not only cover hundreds of PowerShell
    topics, but also see just how powerful a scripting language can be and come away
    with a substantial time-saving utility.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll get PowerLab started by creating the bare-bones `PowerLab`
    module. Then you’ll add the ability to automate the creation of a virtual switch,
    VM, and virtual hard disk (VHD).
  prefs: []
  type: TYPE_NORMAL
- en: PowerLab Module Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To follow along with all the code examples you’ll work with in [Part III](part3.xhtml#part3),
    you need to meet a few prerequisites. Each chapter in this part has a “Prerequisites”
    section. This is to ensure that you always know what to expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the project in this chapter, you need a Hyper-V host with the following
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: A network adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IP: 10.0.0.5 (optional, but to follow along exactly, you need this IP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subnet mask: 255.255.255.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A workgroup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 100GB of available storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Server 2016 with a full GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a Hyper-V server, you need to install the Hyper-V role on the Windows
    server you intend to use. You can expedite the setup process by downloading and
    running the Hyper-V *Setup.ps1* script in the book’s resources at *[https://github.com/adbertram/PowerShellForSysadmins/](https://github.com/adbertram/PowerShellForSysadmins/)*.
    This will set up Hyper-V and create a few necessary folders.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re planning on following along word for word, please run the associated
    chapter’s Pester prerequisite script* (Prerequisites.Tests.ps1) *to confirm that
    your Hyper-V server is set up as expected. These tests will confirm that your
    lab environment is set up exactly as mine is. Run* Invoke-Pester*, passing it
    the prerequisite script, as in [Listing 15-1](ch15.xhtml#ch15list1). For the rest
    of the book, all code will be executed on the Hyper-V host itself.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-1: Running Pester prerequisite checks for Hyper-V work*'
  prefs: []
  type: TYPE_NORMAL
- en: If you have successfully set up your environment, the output should confirm
    five passes. Once you’ve confirmed that your environment is all set up and ready
    go, you can get started on the project!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because you know that you’ll need to automate a potentially large number of
    tasks that all relate to one another, you should create a PowerShell module. As
    you learned in [Chapter 7](ch07.xhtml#ch7), a PowerShell module is a great way
    to combine lots of like-functions into one unit; that way, you can easily manage
    all the code necessary to perform the tasks surrounding a specific purpose. PowerLab
    is no different. There’s no reason to think about everything at once, so start
    small—add functionality, test, and repeat.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Blank Module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, you need to create a blank module. To do that, remote-desktop to your
    soon-to-be Hyper-V host and log in as the local administrator—or any account in
    the local administrators group. You’ll build this module directly on the Hyper-V
    host to ease VM creation and administration. This means you’ll use an RDP session
    to connect to your Hyper-V host’s console session. Then you’ll create the module
    folder, the module itself (the *.psm1* file), and the optional manifest (the *.psd1*
    file).
  prefs: []
  type: TYPE_NORMAL
- en: Since you’re logged in via the local administrator account and may one day allow
    others to use your PowerLab module, create the module in *C:\ProgramFiles\WindowsPowerShell\Modules*.
    This will allow you to access the module when logged in as any administrative
    user on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open a PowerShell console and choose **Run as Administrator**. Then,
    create a PowerLab module folder by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a blank text file called *PowerLab.psm1*. Use the `New-Item` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Module Manifest
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, create a module manifest. To create a module manifest, use the handy `New-ModuleManifest`
    command. This command creates a template manifest, which you can then open in
    a text editor and tweak after the initial file is built, if necessary. Here are
    the parameters I used to build the template manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to modify the parameter values to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Built-In Prefixes for Function Names
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A function doesn’t necessarily need a specific name. However, when you’re building
    a module that is typically a group of related functions, it’s always a good idea
    to preface the noun part of the function with the same label. For example, your
    project is called *PowerLab*. In this project, you’ll build functions that all
    relate to that common theme. To differentiate the functions in PowerLab from the
    functions in other modules you may have loaded, you can add the name of the module
    before the actual noun portion of the name. This means that most functions’ nouns
    will start with the term *PowerLab*.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all functions will start with the name of the module. Examples
    include helper functions that only assist other functions and will never be called
    by a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re sure you want all function nouns to use the same prefix without
    having to explicitly define it in the function name, the module manifest has an
    option called `DefaultCommandPrefix`. This option will force PowerShell to preface
    the noun with a particular string. For example, if you define the `DefaultCommandPrefix`
    key in a manifest and create a function inside the module called `New-Switch`,
    when the module is imported, the function won’t be available for use as `New-Switch`
    but as `New-PowerLabSwitch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I prefer *not* to go with this approach because it forcefully prefaces *all*
    function name nouns inside the module with that string.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the New Module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve built the manifest, you’re ready to see whether it imports successfully.
    Since you haven’t written any functions yet, the module won’t be able to do anything,
    but it’s important to see whether PowerShell can see the module. If you see the
    following result, you’re good to go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the PowerLab module doesn’t appear at the bottom of the output, return to
    the previous steps. In addition, check to ensure that you have the PowerLab folder
    created under *C:\Program Files\WindowsPowerShell\Modules* with *PowerLab.psm1*
    and *PowerLab.psd1* files inside.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Virtual Environment Provisioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have built the module’s structure, you can begin to add functionality
    to it. Since the task of creating a server, such as SQL or IIS, has various steps
    that depend on one another, you’ll first work on automating the creation of a
    virtual switch, virtual machine, and virtual disk. Then you’ll automate deploying
    the operating system to these VMs, and finally, you’ll install SQL Server and
    IIS on these VMs.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Switches
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before you can begin automating the creation of VMs, you need to ensure that
    a virtual switch is set up on the Hyper-V host. *Virtual switches* allow VMs to
    communicate with client machines and other VMs built on a host.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Virtual Switch Manually
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Your virtual switch will be an *external* switch, called `PowerLab`. Chances
    are, a switch with this name isn’t already on the Hyper-V host, but just to be
    sure, list all the virtual switches on the host. You’ll never regret checking
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see all of the switches set up on your Hyper-V host, use the Get-VmSwitch
    command. Once you confirm that the PowerLab switch doesn’t exist, create a new
    virtual switch with the `New-VmSwitch` command, specifying the name (`PowerLab`)
    and the type of switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Since you need your VMs to be able to communicate with hosts outside Hyper-V,
    you pass the value `External` to the `SwitchType` parameter. Whoever you share
    this project with will also need to create an external switch.
  prefs: []
  type: TYPE_NORMAL
- en: With your switch created, it’s now time to create the PowerLab module’s first
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Automating VM Switch Creation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first PowerLab function, called `New-PowerLabSwitch`, creates the Hyper-V
    switch. This function isn’t too complicated. In fact, without it, you would simply
    need to execute a single command at the prompt—that is, `New-VmSwitch`. But if
    you wrap that Hyper-V command inside a custom function, you will have the ability
    to perform other work: adding any kind of default configuration to the switch,
    for example.'
  prefs: []
  type: TYPE_NORMAL
- en: I am a big fan of *idempotency*, which is a fancy word that means “regardless
    of the state in which the command executes, it performs the same task every time.”
    In this example, if the task of creating the switch were not idempotent, then
    running `New-VmSwitch` would result in an error if the switch already existed.
  prefs: []
  type: TYPE_NORMAL
- en: To remove the requirement to manually check whether the switch is created before
    attempting to create a switch, you can use the `Get-VmSwitch` command. This command
    checks whether the switch has been created. Then, if—and only if—the switch doesn’t
    exist will you attempt to create a new switch. This allows you to run `New-PowerLabSwitch`
    in any environment and know that it will always create the virtual switch without
    returning an error—regardless of the state of the Hyper-V host.
  prefs: []
  type: TYPE_NORMAL
- en: Open the *C:\Program Files\WindowsPowerShell\Modules\PowerLab\PowerLab.psm1*
    file and create the `New-PowerLabSwitch` function, as shown in [Listing 15-2](ch15.xhtml#ch15list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-2: `New-PowerLabSwitch` function in the `PowerLab` module*'
  prefs: []
  type: TYPE_NORMAL
- en: This function first checks to see whether the switch is already created ❶. If
    it isn’t, the function creates it ❷. If the switch is already created, the function
    will simply return a verbose message to the console ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Save the module and then force it to import again by using Import-Module -Name
    PowerLab -Force.
  prefs: []
  type: TYPE_NORMAL
- en: When you add new functions to the module, you must import the module again.
    If a module is already imported, you must use the `Force` parameter with `Import-Module`
    to force PowerShell to import it again. Otherwise, PowerShell will see that the
    module has already been imported and skip it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve imported the module again, the `New-PowerLabSwitch` function should
    be available to you. Run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that you don’t receive an error, but instead, a useful verbose message
    saying the switch has already been created. This is because you passed the optional
    `Verbose` parameter to the function. Defaults were chosen for the `SwitchName`
    and `SwitchType` parameters, since these will usually be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Virtual Machines
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve set up a virtual switch, it’s time to create a VM. For this
    demo, you’ll create a generation 2 VM, called LABDC, with 2GB attached to the
    virtual switch you just built in the *C:\PowerLab\VMs* folder on the Hyper-V host.
    I’ve chosen *LABDC* as the name because this will eventually be our Active Directory
    domain controller. This VM will eventually be the domain controller you’ll use
    for your fully built lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, take a look at all the existing VMs and ensure that one doesn’t already
    exist with the same name. Since you already know the name of the VM you want to
    create, pass that value to the `Name` parameter of `Get-Vm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Get-Vm` command returns an error when it can’t find the VM with the specified
    name. Because you’re just checking whether it exists, and it doesn’t necessarily
    matter to us whether it does or doesn’t at this point, use the `ErrorAction` parameter
    with the `SilentlyContinue` value to ensure that the command returns nothing if
    the VM doesn’t exist in your automation script later. You’re not using a `try/catch`
    here for simplicity’s sake.
  prefs: []
  type: TYPE_NORMAL
- en: This technique works only if the command returns a nonterminating error. If
    the command returns a terminating error, you’ll have to either look into returning
    all the objects and filtering them with `Where-Object` or enclosing the command
    in a `try/catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a VM Manually
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The VM doesn’t exist, which means you need to create it. To create a VM, you
    need to run the `Get-Vm` command and pass it the values that you defined at the
    start of this section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You should now have a VM, but confirm this by running Get-Vm again.
  prefs: []
  type: TYPE_NORMAL
- en: Automating VM Creation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To automate creating a simple VM, you again need to add another function. This
    function will follow the same pattern as that used to create a new virtual switch:
    make an idempotent function that performs a task regardless of the state of the
    Hyper-V host.'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the `New-PowerLabVm` function, as shown in [Listing 15-3](ch15.xhtml#ch15list3),
    into your *PowerLab.psm1* module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-3: `New-PowerLabVm` function in the `PowerLab` module*'
  prefs: []
  type: TYPE_NORMAL
- en: This function checks whether the VM already exists ❶. If it doesn’t, the function
    will create one ❷. If it does, the function will display a verbose message to
    the console ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save *PowerLab.psm1* and execute your new function at the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Again, when you run this command, you can create a VM with the specified parameter
    values—whether that VM already exists (after you force the module to be imported
    again) or not.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Hard Disks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You now have a VM attached to a switch, but a VM isn’t any good without storage
    attached to it. To take care of that, you need to create a local virtual hard
    disk (VHD) and connect it to a VM.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In [Chapter 16](ch16.xhtml#ch16), you’ll use a community script that converts
    an ISO file into a VHD. Therefore, you don’t need to create a VHD. But if you
    aren’t planning on automating the operating system deployment, or if you need
    to automate the VHD creation as part of another script, I still recommend that
    you complete this section.*'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a VHD Manually
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To create a VHD file, you need only a single command: `New-Vhd`. In this section,
    you’ll create a VHD that’s capable of growing to 50GB in size; and to save space,
    you’ll set the VHD to dynamically size.'
  prefs: []
  type: TYPE_NORMAL
- en: You first need to create a folder on the Hyper-V host at *C:\PowerLab\VHDs*
    to place the VHD. Be sure to name your VHD with the same name as the VM you intend
    to attach it to in order to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the VHD with `New-Vhd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You pass `New-Vhd` the path ❶ and the VHD size ❷, and, finally, indicate that
    you want it to dynamically size ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirm that you successfully created the VHD on your Hyper-V host with the
    `Test-Path` command. If `Test-Path` returns `True`, you were successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you need to attach the VHD to the VM you created earlier. To do this, you
    use the `Add-VMHardDiskDrive` command. But because you’re *not* going to be attaching
    a VHD to LABDC—the OS deployment automation, in [Chapter 16](ch16.xhtml#ch16),
    will do that—create another VM, called MYVM, to attach to the VHD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Add-VMHardDiskDrive` command accepts the object type that the `Get-VM`
    command returns for its pipeline input so you can pass the VM directly from `Get-VM`
    to `Add-VMHardDiskDrive`—specifying the path to the VHD on the Hyper-V host ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Immediately after, use `Get-VMHardDiskDrive` to confirm that the VHDX was added
    successfully ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Automating VHD Creation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can add another function to your module to automate the process of creating
    a VHD and attaching it to a VM. When you create scripts or functions, accounting
    for various configurations is important.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-4](ch15.xhtml#ch15list4) defines the `New-PowerLabVhd` function,
    which creates a VHD and attaches a VM to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-4: `New-PowerLabVhd` function in the `PowerLab` module*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function supports both dynamic and fixed sizing ❷, and it accounts for
    four individual states:'
  prefs: []
  type: TYPE_NORMAL
- en: The VHD already exists ❶.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VM to attach the VHD to doesn’t exist ❸.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VM to attach the VHD to exists, but the VHD hasn’t been connected yet ❹.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VM to attach the VHD to exists, and the VHD has already been attached ❺.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function design is a whole other matter entirely. It takes years of coding and
    practice to be able to create a script or function that’s resilient across many
    scenarios. It’s an art that has never truly been perfected, but if you’re able
    to think through as many different ways a problem may occur and account for those
    up front, your function will be that much better off. However, don’t go *too*
    overboard and spend hours on a function or script making sure *every* detail is
    covered! This is just code. You can change it later.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the New-PowerLabVhd Function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can execute this code in various states and account for each state. Let’s
    test multiple states to ensure that this automation script works in each situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, you’re not quite testing in the formal sense. Instead, you’re putting
    your new function through its paces by forcing it to run through each of the code
    paths you defined.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the New Functions with Pester
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should now be able to automate the creation of a Hyper-V VM, but you should
    always build Pester tests for everything you create in order to make sure everything
    works as you expect, as well as monitor your automation over time. You’ll build
    Pester tests for all the work you do in the rest of the book. You can find the
    Pester tests in this book’s resources at [*https://github.com/adbertram/PowerShellForSysadmins/*](https://github.com/adbertram/PowerShellForSysadmins/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you accomplished four things:'
  prefs: []
  type: TYPE_NORMAL
- en: Created a virtual switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created a VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created a VHDX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attached the VHDX to the VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I broke the Pester tests for this chapter into sections that correspond to the
    four accomplishments. Breaking tests into stages like this helps keep your tests
    organized.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run the test against the code you wrote in this chapter. To run the test
    script, make sure you downloaded the *Automating-Hyper-V.Tests.ps1* script from
    the book’s resources. In the following code, the test script is located in the
    root of *C:\*, but your path may be different depending on where you downloaded
    the resource files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All four tests pass, so you’re good to move on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You created the foundation for your first real-world PowerShell automation project!
    I hope you’re already seeing just how much time you can save by automating with
    PowerShell! By using a freely available PowerShell module from Microsoft, you
    were able to run just a few commands to quickly create a virtual switch, VM, and
    disk drive. Microsoft gave you the commands, but it was up to you to build the
    logic around them to make everything flow seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: You might now see that it’s possible to build scripts on the fly that work,
    but by thinking ahead and adding conditional logic, your scripts can account for
    more situations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll take the VM you just created and automate deploying
    an operating system to it with little more than an ISO file.
  prefs: []
  type: TYPE_NORMAL
