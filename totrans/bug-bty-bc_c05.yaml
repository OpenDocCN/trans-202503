- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Web Hacking Reconnaissance
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web 渗透测试侦察
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The first step to attacking any target is conducting *reconnaissance*, or simply
    put, gathering information about the target. Reconnaissance is important because
    it’s how you figure out an application’s attack surface. To look for bugs most
    efficiently, you need to discover all the possible ways of attacking a target
    before deciding on the most effective approach.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击任何目标的第一步是进行*侦察*，简单来说，就是收集关于目标的信息。侦察很重要，因为它是你了解应用程序攻击面的方法。为了最有效地寻找漏洞，你需要在决定最有效的攻击方法之前，发现所有可能的攻击目标的方式。
- en: If an application doesn’t use PHP, for instance, there’s no reason to test it
    for PHP vulnerabilities, and if the organization doesn’t use Amazon Web Services
    (AWS), you shouldn’t waste time trying to crack its buckets. By understanding
    how a target works, you can set up a solid foundation for finding vulnerabilities.
    Recon skills are what separate a good hacker from an ineffective one.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个应用程序不使用 PHP，就没有必要测试它的 PHP 漏洞；如果组织没有使用 Amazon Web Services (AWS)，你也不应该浪费时间尝试破解其存储桶。通过了解目标的工作原理，你可以为发现漏洞奠定坚实的基础。侦察技能是区分一个优秀黑客和一个无效黑客的关键。
- en: In this chapter, I’ll introduce the most useful recon techniques for a bug bounty
    hunter. Then I’ll walk you through the basics of writing bash scripts to automate
    recon tasks and make them more efficient. *Bash* is a shell interpreter available
    on macOS and Linux systems. Though this chapter assumes you’re using a Linux system,
    you should be able to install many of these tools on other operating systems as
    well. You need to install some of the tools we discuss in this chapter before
    using them. I have included links to all the tools at the end of the chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍最有用的侦察技术，供漏洞赏金猎人使用。然后，我将带你学习如何编写 bash 脚本来自动化侦察任务，并提高效率。*Bash* 是一个在
    macOS 和 Linux 系统上可用的 shell 解释器。虽然本章假设你使用的是 Linux 系统，但你应该能够在其他操作系统上安装许多这些工具。你需要在使用这些工具之前先安装它们。我在本章的末尾包含了所有工具的链接。
- en: Before you go on, please verify that you’re allowed to perform intrusive recon
    on your target before you attempt any techniques that actively engage with it.
    In particular, activities like port scanning, spidering, and directory brute-forcing
    can generate a lot of unwanted traffic on a site and may not be welcomed by the
    organization.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续之前，请验证你是否被允许对目标进行侵入式侦察，再尝试任何与目标进行主动交互的技术。特别是，端口扫描、爬虫和目录暴力破解等活动可能会在网站上生成大量不必要的流量，并且可能不受组织的欢迎。
- en: Manually Walking Through the Target
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动浏览目标
- en: Before we dive into anything else, it will help to first manually walk through
    the application to learn more about it. Try to uncover every feature in the application
    that users can access by browsing through every page and clicking every link.
    Access the functionalities that you don’t usually use.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论其他内容之前，首先手动浏览应用程序会帮助你了解它。尝试通过浏览每一页和点击每个链接，发现应用程序中用户可以访问的每一个功能。访问你通常不使用的功能。
- en: For example, if you’re hacking Facebook, try to create an event, play a game,
    and use the payment functionality if you’ve never done so before. Sign up for
    an account at every privilege level to reveal all of the application’s features.
    For example, on Slack, you can create owners, admins, and members of a workspace.
    Also create users who are members of different channels under the same workspace.
    This way, you can see what the application looks like to different users.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在进行 Facebook 渗透测试，尝试创建一个事件、玩一个游戏，并使用支付功能，如果你之前从未这样做过。注册每个权限级别的账户，以揭示应用程序的所有功能。例如，在
    Slack 上，你可以创建工作区的所有者、管理员和成员。还可以创建属于不同频道的用户，但在同一个工作区下。这样，你就可以看到不同用户在应用程序中的视图。
- en: 'This should give you a rough idea of what the *attack surface* (all of the
    different points at which an attacker can attempt to exploit the application)
    looks like, where the data entry points are, and how different users interact
    with each other. Then you can start a more in-depth recon process: finding out
    the technology and structure of an application.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能给你一个大致的了解，关于*攻击面*（攻击者可以尝试利用应用程序的所有不同点）的样子，数据输入点在哪里，以及不同用户之间如何互动。然后，你可以开始更深入的侦察过程：了解应用程序的技术和结构。
- en: Google Dorking
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Dorking
- en: When hunting for bugs, you’ll often need to research the details of a vulnerability.
    If you’re exploiting a potential cross-site scripting (XSS) vulnerability, you
    might want to find a particular payload you saw on GitHub. Advanced search-engine
    skills will help you find the resources you need quickly and accurately.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找漏洞时，你经常需要研究漏洞的细节。如果你正在利用潜在的跨站脚本攻击（XSS）漏洞，你可能想要找到你在 GitHub 上看到的某个特定有效载荷。高级搜索引擎技巧将帮助你快速、准确地找到所需的资源。
- en: In fact, advanced Google searches are a powerful technique that hackers often
    use to perform recon. Hackers call this *Google dorking*. For the average Joe,
    Google is just a text search tool for finding images, videos, and web pages. But
    for the hacker, Google can be a means of discovering valuable information such
    as hidden admin portals, unlocked password files, and leaked authentication keys.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，高级 Google 搜索是一种黑客经常使用的强大技术，用于执行侦察。黑客将其称为*Google dorking*。对于普通人来说，Google
    只是一个用来查找图片、视频和网页的文本搜索工具。但对于黑客而言，Google 可以成为发现有价值信息的手段，如隐藏的管理员门户、解锁的密码文件和泄露的身份验证密钥。
- en: 'Google’s search engine has its own built-in query language that helps you filter
    your searches. Here are some of the most useful operators that can be used with
    any Google search:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Google 的搜索引擎有自己内置的查询语言，可以帮助你筛选搜索结果。以下是一些可以与任何 Google 搜索一起使用的最有用的操作符：
- en: '**site**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**site**'
- en: 'Tells Google to show you results from a certain site only. This will help you
    quickly find the most reputable source on the topic that you are researching.
    For example, if you wanted to search for the syntax of Python’s `print()` function,
    you could limit your results to the official Python documentation with this search:
    `print site:python.org`.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 Google 只显示来自某个特定网站的结果。这将帮助你快速找到你正在研究的主题的最权威来源。例如，如果你想搜索 Python 的 `print()`
    函数的语法，你可以通过以下搜索将结果限制为官方 Python 文档：`print site:python.org`。
- en: '**inurl**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**inurl**'
- en: Searches for pages with a URL that match the search string. It’s a powerful
    way to search for vulnerable pages on a particular website. Let’s say you’ve read
    a blog post about how the existence of a page called */course/jumpto.php* on a
    website could indicate that it’s vulnerable to remote code execution. You can
    check if the vulnerability exists on your target by searching`inurl:"/course/jumpto.php"
    site:example.com`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找URL匹配搜索字符串的页面。这是搜索特定网站上存在漏洞页面的一种强大方式。假设你读了一篇博客，介绍了网站上名为*/course/jumpto.php*的页面可能表明存在远程代码执行漏洞。你可以通过搜索`inurl:"/course/jumpto.php"
    site:example.com`来检查目标是否存在该漏洞。
- en: '**intitle**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**intitle**'
- en: Finds specific strings in a page’s title. This is useful because it allows you
    to find pages that contain a particular type of content. For example, file-listing
    pages on web servers often have *index of* in their titles. You can use this query
    to search for directory pages on a website:`intitle:"index of" site:example.com`*.*
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找页面标题中的特定字符串。这很有用，因为它可以帮助你找到包含特定类型内容的页面。例如，web 服务器上的文件列表页面通常在标题中包含*index of*。你可以使用此查询来搜索网站上的目录页面：`intitle:"index
    of" site:example.com`*。
- en: '**link**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**link**'
- en: Searches for web pages that contain links to a specified URL. You can use this
    to find documentation about obscure technologies or vulnerabilities. For example,
    let’s say you’re researching the uncommon regular expression denial-of-service
    (ReDoS) vulnerability. You’ll easily pull up its definition online but might have
    a hard time finding examples. The `link` operator can discover pages that reference
    the vulnerability’s Wikipedia page to locate discussions of the same topic:`link:"https://en.wikipedia.org/wiki/ReDoS"`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找包含指定 URL 链接的网页。你可以用它来查找关于不常见技术或漏洞的文档。例如，假设你正在研究不常见的正则表达式拒绝服务（ReDoS）漏洞。你可以轻松找到它的定义，但可能很难找到实例。`link`
    操作符可以发现引用漏洞 Wikipedia 页面来定位讨论同一话题的页面：`link:"https://en.wikipedia.org/wiki/ReDoS"`。
- en: '**filetype**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**filetype**'
- en: Searches for pages with a specific file extension. This is an incredible tool
    for hacking; hackers often use it to locate files on their target sites that might
    be sensitive, such as log and password files. For example, this query searches
    for log files, which often have the *.log* file extension, on the target site:`filetype:log
    site:example.com`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找具有特定文件扩展名的页面。这是一个非常强大的黑客工具；黑客经常使用它来定位目标站点上可能敏感的文件，比如日志文件和密码文件。例如，以下查询会在目标站点上搜索日志文件，这些文件通常具有*.log*文件扩展名：`filetype:log
    site:example.com`。
- en: '**Wildcard (`*`)**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wildcard (`*`)**'
- en: You can use the wildcard operator (`*`) within searches to mean *any character
    or series of characters*. For example, the following query will return any string
    that starts with *how to hack* and ends with *using Google*. It will match with
    strings like *how to hack websites using Google*, *how to hack applications using
    Google*, and so on:`"how to hack * using Google"`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在搜索中使用通配符运算符 (`*`) 来表示*任何字符或字符序列*。例如，以下查询将返回任何以*how to hack*开头并以*using Google*结尾的字符串。它会匹配像*how
    to hack websites using Google*、*how to hack applications using Google*等字符串：`"how
    to hack * using Google"`。
- en: '**Quotes (`"` `"`)**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**引号 (`"` `"`)**'
- en: 'Adding quotation marks around your search terms forces an exact match. For
    example, this query will search for pages that contain the phrase *how to hack*:
    `"how to hack"`. And this query will search for pages with the terms *how*, *to*,
    and *hack*, although not necessarily together: `how to hack`.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索词周围添加引号可以强制精确匹配。例如，这个查询将搜索包含短语*如何黑客攻击*的页面：`"how to hack"`。而这个查询将搜索包含*how*、*to*
    和 *hack* 的页面，但它们不一定会出现在一起：`how to hack`。
- en: '**Or (`|`)**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**或运算符 (`|`)**'
- en: 'The or operator is denoted with the pipe character (`|`) and can be used to
    search for one search term or the other, or both at the same time. The pipe character
    must be surrounded by spaces. For example, this query will search for *how to
    hack* on either Reddit or Stack Overflow:`"how to hack" site:(reddit.com | stackoverflow.com)`.
    And this query will search for web pages that mention either *SQL Injection* or
    *SQLi*: `(SQL Injection | SQLi)`. *SQLi* is an acronym often used to refer to
    SQL injection attacks, which we’ll talk about in Chapter 11.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或运算符由管道字符 (`|`) 表示，可以用来搜索一个或另一个搜索词，或者同时搜索两者。管道字符必须用空格分隔。例如，这个查询将在 Reddit 或 Stack
    Overflow 上搜索*如何黑客攻击*：`"how to hack" site:(reddit.com | stackoverflow.com)`。而这个查询将搜索提到*SQL
    注入*或*SQLi*的网页：`(SQL Injection | SQLi)`。*SQLi* 是一个常用于指代 SQL 注入攻击的缩写，我们将在第11章讨论这一点。
- en: '**Minus (`-`)**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**减号 (`-`)**'
- en: The minus operator (`-`) excludes certain search results. For example, let’s
    say you’re interested in learning about websites that discuss hacking, but not
    those that discuss hacking PHP. This query will search for pages that contain
    *how to hack websites* but not *php*:`"how to hack websites" -php`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减号运算符 (`-`) 排除某些搜索结果。例如，假设你有兴趣了解讨论黑客攻击的网站，但不包括那些讨论黑客攻击 PHP 的网站。这个查询将搜索包含*如何黑客攻击网站*但不包含*php*的页面：`"how
    to hack websites" -php`。
- en: 'You can use advanced search engine options in many more ways to make your work
    more efficient. You can even search for the term *Google search operators* to
    discover more. These operators can be more useful than you’d expect. For example,
    look for all of a company’s subdomains by searching as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式使用高级搜索引擎选项来提高工作效率。你甚至可以搜索*Google 搜索运算符*以发现更多功能。这些运算符可能比你预期的更有用。例如，查找某个公司所有子域名的方法如下：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also look for special endpoints that can lead to vulnerabilities. *Kibana*
    is a data visualization tool that displays server operation data such as server
    logs, debug messages, and server status. A compromised Kibana instance can allow
    attackers to collect extensive information about a site’s operation. Many Kibana
    dashboards run under the path *app/kibana*, so this query will reveal whether
    the target has a Kibana dashboard. You can then try to access the dashboard to
    see if it’s unprotected:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以寻找可能导致漏洞的特殊端点。*Kibana* 是一个数据可视化工具，展示服务器操作数据，如服务器日志、调试信息和服务器状态。被攻击的 Kibana
    实例可以让攻击者收集关于网站运行的广泛信息。许多 Kibana 仪表盘位于 *app/kibana* 路径下，因此这个查询将揭示目标是否有 Kibana 仪表盘。你可以尝试访问该仪表盘，看看它是否没有保护：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Google can find company resources hosted by a third party online, such as Amazon
    S3 buckets (we’ll talk about these in more detail in “Third-Party Hosting” on
    page 74):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Google 可以找到由第三方在线托管的公司资源，例如 Amazon S3 存储桶（我们将在第74页的“第三方托管”部分详细讨论这些内容）：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Look for special extensions that could indicate a sensitive file. In addition
    to *.log*, which often indicates log files, search for *.php*, *cfm*, *asp*, *.jsp*,
    and *.pl*, the extensions often used for script files:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查找可能指示敏感文件的特殊扩展名。除了 *.log*，它通常表示日志文件外，还可以搜索 *.php*、*cfm*、*asp*、*.jsp* 和 *.pl*，这些扩展名通常用于脚本文件：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, you can also combine search terms for a more accurate search. For
    example, this query searches the site *example.com* for text files that contain
    *password*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还可以结合多个搜索词进行更精确的搜索。例如，这个查询将在*example.com*网站上搜索包含*password*的文本文件：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In addition to constructing your own queries, check out the Google Hacking Database
    ([https://www.exploit-db.com/google-hacking-database/](https://www.exploit-db.com/google-hacking-database/)),
    a website that hackers and security practitioners use to share Google search queries
    for finding security-related information. It contains many search queries that
    could be helpful to you during the recon process. For example, you can find queries
    that look for files containing passwords, common URLs of admin portals, or pages
    built using vulnerable software.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建自己的查询外，可以查看 Google Hacking Database（[https://www.exploit-db.com/google-hacking-database/](https://www.exploit-db.com/google-hacking-database/)），这是黑客和安全从业者用来共享
    Google 搜索查询以查找与安全相关信息的网站。它包含许多在侦察过程中对你有帮助的搜索查询。例如，你可以找到搜索包含密码的文件、常见的管理员门户 URL
    或者使用易受攻击软件构建的页面的查询。
- en: While you are performing recon using Google search, keep in mind that if you’re
    sending a lot of search queries, Google will start requiring CAPTCHA challenges
    for visitors from your network before they can perform more searches. This could
    be annoying to others on your network, so I don’t recommend Google dorking on
    a corporate or shared network.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Google 搜索进行侦察时，请记住，如果你发送大量搜索查询，Google 会开始要求来自你网络的访问者在继续搜索前进行 CAPTCHA 挑战。这可能会对你网络上的其他人造成困扰，所以我不建议在企业或共享网络上进行
    Google dorking。
- en: Scope Discovery
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围发现
- en: Let’s now dive into recon itself. First, always verify the target’s scope. A
    program’s *scope* on its policy page specifies which subdomains, products, and
    applications you’re allowed to attack. Carefully verify which of the company’s
    assets are in scope to avoid overstepping boundaries during the recon and hacking
    process. For example, if *example.com*’s policy specifies that *dev.example.com*
    and *test.example.com* are out of scope, you shouldn’t perform any recon or attacks
    on those subdomains.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解侦察过程。首先，始终验证目标的范围。一款程序的*范围*会在其政策页面上明确，说明哪些子域名、产品和应用程序是你可以攻击的。仔细核实哪些公司资产在范围内，以避免在侦察和攻击过程中越界。例如，如果*example.com*的政策规定*dev.example.com*和*test.example.com*不在范围内，那么你不应对这些子域名进行任何侦察或攻击。
- en: Once you’ve verified this, discover what’s actually in the scope. Which domains,
    subdomains, and IP addresses can you attack? What company assets is the organization
    hosting on these machines?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 验证完这些内容后，了解实际的范围。你可以攻击哪些域名、子域名和 IP 地址？组织在这些机器上托管了哪些公司资产？
- en: WHOIS and Reverse WHOIS
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WHOIS 和反向 WHOIS
- en: 'When companies or individuals register a domain name, they need to supply identifying
    information, such as their mailing address, phone number, and email address, to
    a domain registrar. Anyone can then query this information by using the `whois`
    command, which searches for the registrant and owner information of each known
    domain. You might be able to find the associated contact information, such as
    an email, name, address, or phone number:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当公司或个人注册域名时，他们需要向域名注册商提供识别信息，如邮寄地址、电话号码和电子邮件地址。任何人都可以通过使用`whois`命令查询这些信息，该命令查找每个已知域名的注册人和所有者信息。你可能能够找到关联的联系信息，如电子邮件、姓名、地址或电话号码：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This information is not always available, as some organizations and individuals
    use a service called *domain privacy*, in which a third-party service provider
    replaces the user’s information with that of a forwarding service.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息并不总是可用的，因为一些组织和个人使用一种叫做*域名隐私*的服务，在这种服务中，第三方服务提供商会将用户的信息替换为转发服务的相关信息。
- en: You could then conduct a *reverse WHOIS* search, searching a database by using
    an organization name, a phone number, or an email address to find domains registered
    with it. This way, you can find all the domains that belong to the same owner.
    Reverse WHOIS is extremely useful for finding obscure or internal domains not
    otherwise disclosed to the public. Use a public reverse WHOIS tool like ViewDNS.info
    ([https://viewdns.info/reversewhois/](https://viewdns.info/reversewhois/)) to
    conduct this search. WHOIS and reverse WHOIS will give you a good set of top-level
    domains to work with.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以进行*反向 WHOIS* 搜索，通过使用组织名称、电话号码或电子邮件地址查询数据库，找到与其注册的域名。通过这种方式，你可以找到所有属于同一所有者的域名。反向
    WHOIS 对于查找不公开的、模糊的或内部域名非常有用。使用像 ViewDNS.info（[https://viewdns.info/reversewhois/](https://viewdns.info/reversewhois/)）这样的公共反向
    WHOIS 工具进行此类搜索。WHOIS 和反向 WHOIS 将为你提供一组良好的顶级域名供你使用。
- en: IP Addresses
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IP 地址
- en: 'Another way of discovering your target’s top-level domains is to locate IP
    addresses. Find the IP address of a domain you know by running the `nslookup`
    command. You can see here that *facebook.com* is located at 157.240.2.35:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 发现目标的顶级域名的另一种方法是查找 IP 地址。通过运行`nslookup`命令查找你已知域名的 IP 地址。你可以看到这里的*facebook.com*
    位于 157.240.2.35：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you’ve found the IP address of the known domain, perform a reverse IP lookup.
    *Reverse IP* searches look for domains hosted on the same server, given an IP
    or domain. You can also use ViewDNS.info for this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了已知域名的 IP 地址，就执行反向 IP 查找。*反向 IP* 搜索是通过给定一个 IP 或域名来查找托管在同一服务器上的域名。你也可以使用
    ViewDNS.info 进行查找。
- en: 'Also run the `whois` command on an IP address, and then see if the target has
    a dedicated IP range by checking the `NetRange` field. An *IP range* is a block
    of IP addresses that all belong to the same organization. If the organization
    has a dedicated IP range, any IP you find in that range belongs to that organization:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以对一个 IP 地址运行`whois`命令，然后查看目标是否有专用的 IP 范围，通过检查`NetRange`字段来确认。*IP 范围*是一个 IP
    地址块，所有地址都属于同一个组织。如果该组织拥有专用的 IP 范围，那么你在该范围内找到的任何 IP 都属于该组织：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Another way of finding IP addresses in scope is by looking at autonomous systems,
    which are routable networks within the public internet. *Autonomous system numbers
    (**ASNs**)* identify the owners of these networks. By checking if two IP addresses
    share an ASN, you can determine whether the IPs belong to the same owner.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 查找范围内的 IP 地址的另一种方法是查看自治系统，这些是公共互联网中的可路由网络。*自治系统编号（**ASNs**）*标识这些网络的所有者。通过检查两个
    IP 地址是否共享同一 ASN，你可以判断这两个 IP 是否属于同一个所有者。
- en: 'To figure out if a company owns a dedicated IP range, run several IP-to-ASN
    translations to see if the IP addresses map to a single ASN. If many addresses
    within a range belong to the same ASN, the organization might have a dedicated
    IP range. From the following output, we can deduce that any IP within the 157.240.2.21
    to 157.240.2.34 range probably belongs to Facebook:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定一个公司是否拥有专用的 IP 范围，可以运行多个 IP 到 ASN 的转换，看这些 IP 是否映射到同一个 ASN。如果一个范围内的许多地址都属于同一个
    ASN，那么该组织可能拥有专用的 IP 范围。从以下输出可以推断，157.240.2.21 到 157.240.2.34 范围内的任何 IP 很可能属于 Facebook：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `-h` flag in the `whois` command sets the WHOIS server to retrieve information
    from, and *whois.cymru.com* is a database that translates IPs to ASNs. If the
    company has a dedicated IP range and doesn’t mark those addresses as out of scope,
    you could plan to attack every IP in that range.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`whois`命令中的`-h`标志设置了 WHOIS 服务器，以便从中获取信息，*whois.cymru.com* 是一个将 IP 转换为 ASN 的数据库。如果公司有专用的
    IP 范围且没有将这些地址标记为不可范围，你可以计划攻击该范围内的每一个 IP。'
- en: Certificate Parsing
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 证书解析
- en: Another way of finding hosts is to take advantage of the Secure Sockets Layer
    (SSL) certificates used to encrypt web traffic. An SSL certificate’s *Subject
    Alternative Name* field lets certificate owners specify additional hostnames that
    use the same certificate, so you can find those hostnames by parsing this field.
    Use online databases like crt.sh, Censys, and Cert Spotter to find certificates
    for a domain.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 查找主机的另一种方法是利用用于加密 Web 流量的安全套接字层（SSL）证书。SSL 证书的*主题备用名称*字段允许证书所有者指定使用相同证书的附加主机名，因此你可以通过解析此字段来找到这些主机名。可以使用像
    crt.sh、Censys 和 Cert Spotter 等在线数据库来查找某个域名的证书。
- en: 'For example, by running a certificate search using crt.sh for *facebook.com*,
    we can find Facebook’s SSL certificate. You’ll see that that many other domain
    names belonging to Facebook are listed:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过使用 crt.sh 运行证书搜索，可以找到 *facebook.com* 的 SSL 证书。你会看到很多其他属于 Facebook 的域名也列在其中：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The crt.sh website also has a useful utility that lets you retrieve the information
    in JSON format, rather than HTML, for easier parsing. Just add the URL parameter
    `output=json` to the request URL: *https://crt.sh/?q=facebook.com&output=json.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: crt.sh 网站也提供了一个有用的工具，允许你以 JSON 格式而非 HTML 格式检索信息，方便解析。只需在请求 URL 中添加 URL 参数`output=json`：*https://crt.sh/?q=facebook.com&output=json.*
- en: Subdomain Enumeration
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子域名枚举
- en: After finding as many domains on the target as possible, locate as many subdomains
    on those domains as you can. Each subdomain represents a new angle for attacking
    the network. The best way to enumerate subdomains is to use automation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到尽可能多的目标域名后，尽量找到这些域名的更多子域名。每个子域名代表一个攻击网络的新角度。枚举子域名的最佳方法是使用自动化工具。
- en: Tools like Sublist3r, SubBrute, Amass, and Gobuster can enumerate subdomains
    automatically with a variety of wordlists and strategies. For example, Sublist3r
    works by querying search engines and online subdomain databases, while SubBrute
    is a brute-forcing tool that guesses possible subdomains until it finds real ones.
    Amass uses a combination of DNS zone transfers, certificate parsing, search engines,
    and subdomain databases to find subdomains. You can build a tool that combines
    the results of multiple tools to achieve the best results. We’ll discuss how to
    do this in “Writing Your Own Recon Scripts” on page 80.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 像Sublist3r、SubBrute、Amass和Gobuster这样的工具可以通过多种词表和策略自动枚举子域名。例如，Sublist3r通过查询搜索引擎和在线子域名数据库来工作，而SubBrute是一种暴力破解工具，通过猜测可能的子域名，直到找到真实的子域名。Amass结合了DNS区域传输、证书解析、搜索引擎和子域名数据库来查找子域名。你可以构建一个工具，将多个工具的结果结合起来，以获得最佳的结果。我们将在第80页的“编写你自己的侦察脚本”中讨论如何做到这一点。
- en: 'To use many subdomain enumeration tools, you need to feed the program a wordlist
    of terms likely to appear in subdomains. You can find some good wordlists made
    by other hackers online. Daniel Miessler’s SecLists at [https://github.com/danielmiessler/SecLists/](https://github.com/danielmiessler/SecLists/)is
    a pretty extensive one. You can also use a wordlist generation tool like Commonspeak2
    ([https://github.com/assetnote/commonspeak2](https://github.com/assetnote/commonspeak2)/)
    to generate wordlists based on the most current internet data. Finally, you can
    combine several wordlists found online or that you generated yourself for the
    most comprehensive results. Here’s a simple command to remove duplicate items
    from a set of two wordlists:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用许多子域名枚举工具，你需要为程序提供一个包含可能出现在子域名中的术语的词表。你可以在网上找到一些其他黑客制作的优秀词表。Daniel Miessler的SecLists位于[https://github.com/danielmiessler/SecLists/](https://github.com/danielmiessler/SecLists/)是一个相当全面的词表。你还可以使用像Commonspeak2（[https://github.com/assetnote/commonspeak2](https://github.com/assetnote/commonspeak2)/）这样的词表生成工具，根据最新的互联网数据生成词表。最后，你可以结合在线找到的多个词表或自己生成的词表，以获得最全面的结果。以下是一个简单的命令，用于删除两个词表集合中的重复项：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `sort` command line tool sorts the lines of text files. When given multiple
    files, it will sort all files and write the output to the terminal. The `-u` option
    tells `sort` to return only unique items in the sorted list.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`命令行工具用于排序文本文件中的行。当提供多个文件时，它将对所有文件进行排序，并将输出写入终端。`-u`选项告诉`sort`返回排序列表中仅包含唯一项。'
- en: 'Gobuster is a tool for brute-forcing to discover subdomains, directories, and
    files on target web servers. Its DNS mode is used for subdomain brute-forcing.
    In this mode, you can use the flag `-d` to specify the domain you want to brute-force
    and `-w` to specify the wordlist you want to use:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Gobuster是一种暴力破解工具，用于发现目标Web服务器上的子域名、目录和文件。它的DNS模式用于子域名暴力破解。在此模式下，你可以使用`-d`标志指定你要暴力破解的域名，使用`-w`标志指定你要使用的词表：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once you’ve found a good number of subdomains, you can discover more by identifying
    patterns. For example, if you find two subdomains of *example.com* named *1.example.com*
    and *3.example.com*, you can guess that *2.example.com* is probably also a valid
    subdomain. A good tool for automating this process is Altdns ([https://github.com/infosec-au/altdns/](https://github.com/infosec-au/altdns/)),
    which discovers subdomains with names that are permutations of other subdomain
    names.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了足够多的子域名，你可以通过识别模式来发现更多。例如，如果你找到*example.com*的两个子域名，分别是*1.example.com*和*3.example.com*，你可以猜测*2.example.com*也可能是一个有效的子域名。一个自动化这个过程的好工具是Altdns（[https://github.com/infosec-au/altdns/](https://github.com/infosec-au/altdns/)），它通过其他子域名名称的排列组合来发现子域名。
- en: In addition, you can find more subdomains based on your knowledge about the
    company’s technology stack. For example, if you’ve already learned that *example.com*
    uses Jenkins, you can check if *jenkins.example.com* is a valid subdomain.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以根据你对公司技术栈的了解来发现更多的子域名。例如，如果你已经知道*example.com*使用Jenkins，你可以检查*jenkins.example.com*是否是一个有效的子域名。
- en: 'Also look for subdomains of subdomains. After you’ve found, say, *dev.example.com*,
    you might find subdomains like *1.dev.example.com*. You can find subdomains of
    subdomains by running enumeration tools recursively: add the results of your first
    run to your Known Domains list and run the tool again.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还要查找子域名的子域名。在你找到例如*dev.example.com*之后，你可能会找到像*1.dev.example.com*这样的子域名。你可以通过递归运行枚举工具来查找子域名的子域名：将第一次运行的结果添加到你的已知域名列表中，并再次运行该工具。
- en: Service Enumeration
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务枚举
- en: Next, enumerate the services hosted on the machines you’ve found. Since services
    often run on default ports, a good way to find them is by port-scanning the machine
    with either active or passive scanning.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，枚举你找到的机器上托管的服务。由于服务通常运行在默认端口上，一种有效的发现方法是通过端口扫描机器，使用主动扫描或被动扫描。
- en: 'In *active scanning*, you directly engage with the server. Active scanning
    tools send requests to connect to the target machine’s ports to look for open
    ones. You can use tools like Nmap or Masscan for active scanning. For example,
    this simple Nmap command reveals the open ports on *scanme.nmap.org*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在*主动扫描*中，你直接与服务器进行交互。主动扫描工具发送请求以连接到目标机器的端口，寻找开放的端口。你可以使用像 Nmap 或 Masscan 这样的工具进行主动扫描。例如，这个简单的
    Nmap 命令可以揭示 *scanme.nmap.org* 上的开放端口：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: On the other hand, in *passive scanning*, you use third-party resources to learn
    about a machine’s ports without interacting with the server. Passive scanning
    is stealthier and helps attackers avoid detection. To find services on a machine
    without actively scanning it, you can use *Shodan*, a search engine that lets
    the user find machines connected to the internet.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在*被动扫描*中，你使用第三方资源了解机器的端口，而无需与服务器交互。被动扫描更为隐蔽，有助于攻击者避免被检测到。为了在不主动扫描机器的情况下发现其服务，你可以使用*Shodan*，这是一个搜索引擎，允许用户查找连接到互联网的机器。
- en: With Shodan, you can discover the presence of webcams, web servers, or even
    power plants based on criteria such as hostnames or IP addresses. For example,
    if you run a Shodan search on *scanme.nmap.org*’s IP address, 45.33.32.156, you
    get the result in [Figure 5-1](#figure5-1). You can see that the search yields
    different data than our port scan, and provides additional information about the
    server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Shodan，你可以根据主机名或 IP 地址等标准发现摄像头、web 服务器，甚至是电厂。例如，如果你对 *scanme.nmap.org* 的
    IP 地址 45.33.32.156 进行 Shodan 搜索，你会得到[图 5-1](#figure5-1)中的结果。你可以看到，该搜索结果与我们的端口扫描结果不同，并且提供了关于服务器的额外信息。
- en: '![f05001](image_fi/501546c05/f05001.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![f05001](image_fi/501546c05/f05001.png)'
- en: 'Figure 5-1: The Shodan results page of *scanme.nmap.org*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：*scanme.nmap.org* 的 Shodan 搜索结果页面
- en: Alternatives to Shodan include Censys and Project Sonar. Combine the information
    you gather from different databases for the best results. With these databases,
    you might also find your target’s IP addresses, certificates, and software versions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Shodan 的替代工具包括 Censys 和 Project Sonar。结合从不同数据库中收集的信息，能够获得最佳结果。通过这些数据库，你还可能找到目标的
    IP 地址、证书和软件版本。
- en: Directory Brute-Forcing
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录暴力破解
- en: The next thing you can do to discover more of the site’s attack surface is brute-force
    the directories of the web servers you’ve found. Finding directories on servers
    is valuable, because through them, you might discover hidden admin panels, configuration
    files, password files, outdated functionalities, database copies, and source code
    files. Directory brute-forcing can sometimes allow you to directly take over a
    server!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做的下一个事情是对你找到的 web 服务器的目录进行暴力破解。找到服务器上的目录很有价值，因为通过这些目录，你可能会发现隐藏的管理员面板、配置文件、密码文件、过时的功能、数据库副本和源代码文件。目录暴力破解有时可以直接让你接管服务器！
- en: Even if you can’t find any immediate exploits, directory information often tells
    you about the structure and technology of an application. For example, a pathname
    that includes *phpmyadmin* usually means that the application is built with PHP.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你无法立即找到任何漏洞，目录信息通常也能告诉你应用程序的结构和技术。例如，包含 *phpmyadmin* 的路径名通常意味着该应用程序是用 PHP
    构建的。
- en: You can use Dirsearch or Gobuster for directory brute-forcing. These tools use
    wordlists to construct URLs, and then request these URLs from a web server. If
    the server responds with a status code in the 200 range, the directory or file
    exists. This means you can browse to the page and see what the application is
    hosting there. A status code of 404 means that the directory or file doesn’t exist,
    while 403 means it exists but is protected. Examine 403 pages carefully to see
    if you can bypass the protection to access the content.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Dirsearch 或 Gobuster 进行目录暴力破解。这些工具使用字典列表来构建 URL，然后向 web 服务器请求这些 URL。如果服务器以
    200 范围内的状态码响应，说明该目录或文件存在。这意味着你可以访问该页面，查看应用程序在其中托管的内容。404 状态码意味着目录或文件不存在，而 403
    状态码表示它存在但被保护。仔细检查 403 页面，看看是否可以绕过保护来访问内容。
- en: 'Here’s an example of running a Dirsearch command. The `-u` flag specifies the
    hostname, and the `-e` flag specifies the file extension to use when constructing
    URLs:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是运行 Dirsearch 命令的示例。`-u` 标志指定主机名，`-e` 标志指定构建 URL 时使用的文件扩展名：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Gobuster’s Dir mode is used to find additional content on a specific domain
    or subdomain. This includes hidden directories and files. In this mode, you can
    use the `-u` flag to specify the domain or subdomain you want to brute-force and
    `-w` to specify the wordlist you want to use:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Gobuster 的 Dir 模式用于查找特定域或子域上的附加内容，包括隐藏的目录和文件。在此模式下，你可以使用 `-u` 标志指定要暴力破解的域或子域，使用
    `-w` 标志指定要使用的字典列表：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Manually visiting all the pages you’ve found through brute-forcing can be time-consuming.
    Instead, use a screenshot tool like EyeWitness ([https://github.com/FortyNorthSecurity/EyeWitness/](https://github.com/FortyNorthSecurity/EyeWitness/))
    or Snapper ([https://github.com/dxa4481/Snapper/](https://github.com/dxa4481/Snapper/))
    to automatically verify that a page is hosted on each location. EyeWitness accepts
    a list of URLs and takes screenshots of each page. In a photo gallery app, you
    can quickly skim these to find the interesting-looking ones. Keep an eye out for
    hidden services, such as developer or admin panels, directory listing pages, analytics
    pages, and pages that look outdated and ill-maintained. These are all common places
    for vulnerabilities to manifest.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 手动访问通过暴力破解找到的所有页面可能非常耗时。相反，可以使用截图工具，如 EyeWitness（[https://github.com/FortyNorthSecurity/EyeWitness/](https://github.com/FortyNorthSecurity/EyeWitness/)）或
    Snapper（[https://github.com/dxa4481/Snapper/](https://github.com/dxa4481/Snapper/)），自动验证每个位置是否托管了某个页面。EyeWitness
    接受一个 URL 列表，并对每个页面进行截图。在照片图库应用中，你可以快速浏览这些截图，找到看起来有趣的页面。留意隐藏的服务，如开发者或管理员面板、目录列出页面、分析页面，以及看起来过时且维护不当的页面。这些都是常见的漏洞出现的地方。
- en: Spidering the Site
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网站爬虫
- en: Another way of discovering directories and paths is through *web spidering*,
    or web crawling, a process used to identify all pages on a site. A web spider
    tool starts with a page to visit. It then identifies all the URLs embedded on
    the page and visits them. By recursively visiting all URLs found on all pages
    of a site, the web spider can uncover many hidden endpoints in an application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 发现目录和路径的另一种方法是通过 *网页爬虫*，或称网页抓取，这是用来识别网站上所有页面的过程。网页爬虫工具从一个页面开始访问。然后它识别页面中嵌入的所有
    URL 并访问这些页面。通过递归访问网站所有页面中找到的所有 URL，网页爬虫可以揭示应用中的许多隐藏端点。
- en: OWASP Zed Attack Proxy (ZAP) at [https://www.zaproxy.org/](https://www.zaproxy.org/)
    has a built-in web spider you can use ([Figure 5-2](#figure5-2)). This open source
    security tool includes a scanner, proxy, and many other features. Burp Suite has
    an equivalent tool called the *crawler*, but I prefer ZAP’s spider.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP Zed Attack Proxy (ZAP) 在 [https://www.zaproxy.org/](https://www.zaproxy.org/)
    上有一个内置的网页爬虫工具你可以使用（[图 5-2](#figure5-2)）。这个开源安全工具包括扫描器、代理和许多其他功能。Burp Suite 有一个等效的工具叫做
    *crawler*，但我更喜欢 ZAP 的爬虫工具。
- en: '![f05002](image_fi/501546c05/f05002.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![f05002](image_fi/501546c05/f05002.png)'
- en: 'Figure 5-2: The startup page of OWASP ZAP'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：OWASP ZAP 的启动页面
- en: Access its spider tool by opening ZAP and choosing **Tools**▶**Spider** ([Figure
    5-3](#figure5-3)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开 ZAP 并选择 **工具**▶**爬虫**，可以访问其爬虫工具（[图 5-3](#figure5-3)）。
- en: '![f05003](image_fi/501546c05/f05003.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![f05003](image_fi/501546c05/f05003.png)'
- en: 'Figure 5-3: You can find the Spider tool via Tools▶Spider.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：你可以通过工具▶爬虫找到爬虫工具。
- en: You should see a window for specifying the starting URL ([Figure 5-4](#figure5-4)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个用于指定起始 URL 的窗口（[图 5-4](#figure5-4)）。
- en: '![f05004](image_fi/501546c05/f05004.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![f05004](image_fi/501546c05/f05004.png)'
- en: 'Figure 5-4: You can specify the target URL to scan.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：你可以指定要扫描的目标 URL。
- en: Click **Start Scan**. You should see URLs pop up in the bottom window ([Figure
    5-5](#figure5-5)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **开始扫描**。你应该看到 URLs 在底部窗口弹出（[图 5-5](#figure5-5)）。
- en: '![f05005](image_fi/501546c05/f05005.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![f05005](image_fi/501546c05/f05005.png)'
- en: 'Figure 5-5: The scan results show up at the bottom pane of the OWASP ZAP window.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5：扫描结果会显示在 OWASP ZAP 窗口的底部窗格。
- en: You should also see a site tree appear on the left side of your ZAP window ([Figure
    5-6](#figure5-6)). This shows you the files and directories found on the target
    server in an organized format.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该看到 ZAP 窗口左侧出现一个网站树（[图 5-6](#figure5-6)）。它以有组织的格式显示了在目标服务器上找到的文件和目录。
- en: '![f05006](image_fi/501546c05/f05006.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![f05006](image_fi/501546c05/f05006.png)'
- en: 'Figure 5-6: The site tree in the left window shows you the files and directories
    found on the target server.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6：左侧窗口中的网站树显示了在目标服务器上找到的文件和目录。
- en: Third-Party Hosting
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三方托管
- en: Take a look at the company’s third-party hosting footprint. For example, look
    for the organization’s S3 buckets. *S3*, which stands for *Simple Storage Service*,
    is Amazon’s online storage product. Organizations can pay to store resources in
    *buckets* to serve in their web applications, or they can use S3 buckets as a
    backup or storage location. If an organization uses Amazon S3, its S3 buckets
    can contain hidden endpoints, logs, credentials, user information, source code,
    and other information that might be useful to you.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 查看公司使用的第三方托管痕迹。例如，查找该组织的 S3 存储桶。*S3*（简单存储服务）是亚马逊的在线存储产品。组织可以支付费用将资源存储在*存储桶*中，供其
    Web 应用程序使用，或者将 S3 存储桶作为备份或存储位置。如果一个组织使用 Amazon S3，其 S3 存储桶可能包含隐藏的端点、日志、凭证、用户信息、源代码以及其他可能对你有用的信息。
- en: 'How do you find an organization’s buckets? One way is through Google dorking,
    as mentioned earlier. Most buckets use the URL format *BUCKET.s3.amazonaws.com*
    or *s3.amazonaws.com/BUCKET*, so the following search terms are likely to find
    results:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如何找到一个组织的存储桶？一种方法是通过 Google dorking，正如前面提到的那样。大多数存储桶使用 URL 格式*BUCKET.s3.amazonaws.com*
    或 *s3.amazonaws.com/BUCKET*，因此以下搜索词可能会找到结果：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the company uses custom URLs for its S3 buckets, try more flexible search
    terms instead. Companies often still place keywords like *aws* and *s3* in their
    custom bucket URLs, so try these searches:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果公司为其 S3 存储桶使用自定义 URL，尝试使用更灵活的搜索词。公司通常仍然会在自定义存储桶 URL 中放置像*aws*和*s3*这样的关键词，所以可以尝试以下搜索：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Another way of finding buckets is to search a company’s public GitHub repositories
    for S3 URLs. Try searching these repositories for the term *s3*. We’ll talk about
    using GitHub for recon in “GitHub Recon” on the following page.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种寻找存储桶的方法是搜索公司的公开 GitHub 仓库，查找 S3 URL。试着在这些仓库中搜索*s3*这个词。我们将在“GitHub Recon”部分讨论如何使用
    GitHub 进行侦查。
- en: '*GrayhatWarfare* ([https://buckets.grayhatwarfare.com/](https://buckets.grayhatwarfare.com/))
    is an online search engine you can use to find publicly exposed S3 buckets ([Figure
    5-7](#figure5-7)). It allows you to search for a bucket by using a keyword. Supply
    keywords related to your target, such as the application, project, or organization
    name, to find relevant buckets.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*GrayhatWarfare*（[https://buckets.grayhatwarfare.com/](https://buckets.grayhatwarfare.com/)）是一个在线搜索引擎，你可以用它来查找公开暴露的
    S3 存储桶（[图 5-7](#figure5-7)）。它允许你通过关键词搜索存储桶。输入与目标相关的关键词，如应用程序、项目或组织名称，以找到相关存储桶。'
- en: '![f05007](image_fi/501546c05/f05007.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![f05007](image_fi/501546c05/f05007.png)'
- en: 'Figure 5-7: The GrayhatWarfare home page'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7：GrayhatWarfare 主页
- en: Finally, you can try to brute-force buckets by using keywords. *Lazys3* ([https://github.com/nahamsec/lazys3/](https://github.com/nahamsec/lazys3/))
    is a tool that helps you do this. It relies on a wordlist to guess buckets that
    are permutations of common bucket names. Another good tool is *Bucket Stream*
    ([https://github.com/eth0izzle/bucket-stream/](https://github.com/eth0izzle/bucket-stream/)),
    which parses certificates belonging to an organization and finds S3 buckets based
    on permutations of the domain names found on the certificates. Bucket Stream also
    automatically checks whether the bucket is accessible, so it saves you time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以尝试使用关键词进行暴力破解存储桶。*Lazys3*（[https://github.com/nahamsec/lazys3/](https://github.com/nahamsec/lazys3/)）是一个帮助你实现这一点的工具。它依赖一个单词列表来猜测常见存储桶名称的排列组合。另一个有用的工具是*Bucket
    Stream*（[https://github.com/eth0izzle/bucket-stream/](https://github.com/eth0izzle/bucket-stream/)），它解析属于某个组织的证书，并根据证书中找到的域名排列组合来查找
    S3 存储桶。Bucket Stream 还会自动检查存储桶是否可访问，从而节省了你的时间。
- en: 'Once you’ve found a couple of buckets that belong to the target organization,
    use the AWS command line tool to see if you can access one. Install the tool by
    using the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了几个属于目标组织的存储桶，使用 AWS 命令行工具查看是否能访问其中一个。使用以下命令安装该工具：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then configure it to work with AWS by following Amazon’s documentation at [https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html).
    Now you should be able to access buckets directly from your terminal via the `aws
    s3` command. Try listing the contents of the bucket you found:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照亚马逊的文档配置它与 AWS 配合使用，文档地址为[https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html)。现在你应该能够通过`aws
    s3`命令直接从终端访问存储桶。试着列出你找到的存储桶的内容：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If this works, see if you can read the contents of any interesting files by
    copying files to your local machine:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，看看你是否能够通过将文件复制到本地机器来读取任何有趣的文件内容：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Gather any useful information leaked via the bucket and use it for future exploitation!
    If the organization reveals information such as active API keys or personal information,
    you should report this right away. Exposed S3 buckets alone are often considered
    a vulnerability. You can also try to upload new files to the bucket or delete
    files from it. If you can mess with its contents, you might be able to tamper
    with the web application’s operations or corrupt company data. For example, this
    command will copy your local file named *TEST_FILE* into the target’s S3 bucket:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 收集通过存储桶泄露的任何有用信息，并将其用于未来的利用！如果该组织泄露了诸如活跃的API密钥或个人信息等内容，你应该立刻报告。单独暴露的S3存储桶通常被视为一种漏洞。你还可以尝试向存储桶上传新文件或删除文件。如果你能篡改其内容，可能会影响网页应用的操作或损坏公司数据。例如，这个命令将把你本地的文件
    *TEST_FILE* 复制到目标的S3存储桶中：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And this command will remove the *TEST_FILE* that you just uploaded:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个命令将删除你刚刚上传的 *TEST_FILE*：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These commands are a harmless way to prove that you have write access to a bucket
    without actually tampering with the target company’s files.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令是一种无害的方式，证明你对某个存储桶具有写入权限，而不会实际篡改目标公司的文件。
- en: Always upload and remove your own test files. Don’t risk deleting important
    company resources during your testing unless you’re willing to entertain a costly
    lawsuit.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 始终上传并删除你自己的测试文件。除非你愿意承担高额的诉讼费用，否则在测试过程中不要冒险删除重要的公司资源。
- en: GitHub Recon
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitHub侦察
- en: Search an organization’s GitHub repositories for sensitive data that has been
    accidentally committed, or information that could lead to the discovery of a vulnerability.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织的GitHub仓库中搜索意外提交的敏感数据，或可能导致发现漏洞的信息。
- en: Start by finding the GitHub usernames relevant to your target. You should be
    able to locate these by searching the organization’s name or product names via
    GitHub’s search bar, or by checking the GitHub accounts of known employees.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从查找与你目标相关的GitHub用户名开始。你应该能够通过GitHub的搜索栏搜索组织名称或产品名称，或通过检查已知员工的GitHub账户来找到这些用户名。
- en: When you’ve found usernames to audit, visit their pages. Find repositories related
    to the projects you’re testing and record them, along with the usernames of the
    organization’s top contributors, which can help you find more relevant repositories.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你找到需要审计的用户名后，访问他们的页面。查找与你测试的项目相关的仓库并记录下来，同时记录下该组织顶级贡献者的用户名，这将帮助你找到更多相关的仓库。
- en: 'Then dive into the code. For each repository, pay special attention to the
    Issues and Commits sections. These sections are full of potential info leaks:
    they could point attackers to unresolved bugs, problematic code, and the most
    recent code fixes and security patches. Recent code changes that haven’t stood
    the test of time are more likely to contain bugs. Look at any protection mechanisms
    implemented to see if you can bypass them. You can also search the Code section
    for potentially vulnerable code snippets. Once you’ve found a file of interest,
    check the Blame and History sections at the top-right corner of the file’s page
    to see how it was developed ([Figure 5-8](#figure5-8)).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后深入代码。对于每个仓库，特别关注Issues和Commits部分。这些部分充满了潜在的信息泄漏：它们可能指引攻击者找到未解决的bug、问题代码以及最近的代码修复和安全补丁。最近的代码更可能包含bug，因为它们经受的时间考验较少。查看任何已实现的保护机制，看看是否可以绕过它们。你还可以在Code部分搜索可能存在漏洞的代码片段。找到感兴趣的文件后，查看文件页面右上角的Blame和History部分，了解它是如何开发的（[图5-8](#figure5-8)）。
- en: '![f05008](image_fi/501546c05/f05008.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![f05008](image_fi/501546c05/f05008.png)'
- en: 'Figure 5-8: The History and Blame sections'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-8：History和Blame部分
- en: We’ll dive deeper into reviewing source code in Chapter 22, but during the recon
    phase, look for hardcoded secrets such as API keys, encryption keys, and database
    passwords. Search the organization’s repositories for terms like *key*, *secret*,
    and *password* to locate hardcoded user credentials that you can use to access
    internal systems. After you’ve found leaked credentials, you can use KeyHacks
    ([https://github.com/streaak/keyhacks/](https://github.com/streaak/keyhacks/))
    to check if the credentials are valid and learn how to use them to access the
    target’s services.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第22章深入探讨源代码审查，但在侦察阶段，重点寻找硬编码的密钥、API密钥、加密密钥和数据库密码等机密信息。在组织的仓库中搜索*key*、*secret*和*password*等术语，寻找硬编码的用户凭证，这些凭证可以用于访问内部系统。找到泄露的凭证后，你可以使用KeyHacks（[https://github.com/streaak/keyhacks/](https://github.com/streaak/keyhacks/)）检查这些凭证是否有效，并了解如何利用它们访问目标的服务。
- en: You should also search for sensitive functionalities in the project. See if
    any of the source code deals with important functions such as authentication,
    password reset, state-changing actions, or private info reads. Pay attention to
    code that deals with user input, such as HTTP request parameters, HTTP headers,
    HTTP request paths, database entries, file reads, and file uploads, because they
    provide potential entry points for attackers to exploit the application’s vulnerabilities.
    Look for any configuration files, as they allow you to gather more information
    about your infrastructure. Also, search for old endpoints and S3 bucket URLs that
    you can attack. Record these files for further review in the future.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该在项目中搜索敏感功能。看看是否有源代码处理重要功能，如身份验证、密码重置、状态更改操作或私密信息读取。注意涉及用户输入的代码，例如 HTTP 请求参数、HTTP
    头部、HTTP 请求路径、数据库条目、文件读取和文件上传，因为这些可能为攻击者提供了利用应用程序漏洞的潜在入口点。还要查找任何配置文件，因为它们可以帮助你收集更多有关基础设施的信息。另外，搜索旧的端点和
    S3 存储桶 URL，看看是否可以攻击这些。记录这些文件，以便日后进一步审查。
- en: Outdated dependencies and the unchecked use of dangerous functions are also
    a huge source of bugs. Pay attention to dependencies and imports being used and
    go through the versions list to see if they’re outdated. Record any outdated dependencies.
    You can use this information later to look for publicly disclosed vulnerabilities
    that would work on your target.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 过时的依赖项和未检查的危险函数使用也是导致漏洞的重要来源。注意正在使用的依赖项和导入项，并查看版本列表，看看它们是否已经过时。记录所有过时的依赖项。你可以稍后使用这些信息，寻找可以作用于目标的公开披露漏洞。
- en: Tools like Gitrob and TruffleHog can automate the GitHub recon process. *Gitrob*
    ([https://github.com/michenriksen/gitrob/](https://github.com/michenriksen/gitrob/))
    locates potentially sensitive files pushed to public repositories on GitHub. *TruffleHog*
    ([https://github.com/trufflesecurity/truffleHog/](https://github.com/trufflesecurity/truffleHog/))
    specializes in finding secrets in repositories by conducting regex searches and
    scanning for high-entropy strings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Gitrob 和 TruffleHog 这样的工具可以自动化 GitHub 的侦查过程。*Gitrob* ([https://github.com/michenriksen/gitrob/](https://github.com/michenriksen/gitrob/))
    可以定位推送到 GitHub 公共仓库中的潜在敏感文件。*TruffleHog* ([https://github.com/trufflesecurity/truffleHog/](https://github.com/trufflesecurity/truffleHog/))
    专门通过执行正则表达式搜索和扫描高熵字符串来查找仓库中的秘密。
- en: Other Sneaky OSINT Techniques
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他隐蔽的 OSINT 技巧
- en: Many of the strategies I discussed so far are all examples of *open source intelligence
    (OSINT)*, or the practice of gathering intel from public sources of information.
    This section details other OSINT sources you might use to extract valuable information.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我讨论的许多策略都是 *开放源代码情报（OSINT）* 的例子，即从公开的信息源收集情报的实践。本节详细介绍了你可能使用的其他 OSINT
    来源，以提取有价值的信息。
- en: 'First, check the company’s job posts for engineering positions. Engineering
    job listings often reveal the technologies the company uses. For example, take
    a look at an ad like this one:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查看公司发布的工程职位招聘信息。工程职位的招聘广告通常会透露公司使用的技术。例如，可以看看类似这样的广告：
- en: '**Full Stack Engineer**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**全栈工程师**'
- en: 'Minimum Qualifications:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最低资格要求：
- en: Proficiency in Python and C/C++
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精通 Python 和 C/C++
- en: Linux experience
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有 Linux 经验
- en: Experience with Flask, Django, and Node.js
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有 Flask、Django 和 Node.js 的经验
- en: Experience with Amazon Web Services, especially EC2, ECS, S3, and RDS
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有亚马逊 Web 服务（AWS）经验，特别是 EC2、ECS、S3 和 RDS
- en: From reading this, you know the company uses Flask, Django, and Node.js to build
    its web applications. The engineers also probably use Python, C, and C++ on the
    backend with a Linux machine. Finally, they use AWS to outsource their operations
    and file storage.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些信息中，你可以得知公司使用 Flask、Django 和 Node.js 构建其 Web 应用程序。工程师们很可能在后台使用 Python、C 和
    C++，并且运行在 Linux 机器上。最后，他们使用 AWS 外包运营和文件存储。
- en: If you can’t find relevant job posts, search for employees’ profiles on LinkedIn,
    and read employees’ personal blogs or their engineering questions on forums like
    Stack Overflow and Quora. The expertise of a company’s top employees often reflects
    the technology used in development.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到相关的职位招聘信息，可以搜索员工在 LinkedIn 上的个人资料，阅读员工的个人博客或他们在 Stack Overflow 和 Quora
    等论坛上的工程问题。公司顶尖员工的专业知识通常反映了开发中使用的技术。
- en: Another source of information is the employees’ Google calendars. People’s work
    calendars often contain meeting notes, slides, and sometimes even login credentials.
    If an employee shares their calendars with the public by accident, you could gain
    access to these. The organization or its employees’ social media pages might also
    leak valuable information. For example, hackers have actually discovered sets
    of valid credentials on Post-it Notes visible in the background of office selfies!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个信息来源是员工的Google日历。人们的工作日历通常包含会议记录、幻灯片，甚至有时包含登录凭证。如果员工不小心将他们的日历公开，你就可能获得这些信息。组织或其员工的社交媒体页面也可能泄露有价值的信息。例如，黑客曾发现一些有效凭证出现在办公室自拍背景中的便利贴上！
- en: If the company has an engineering mailing list, sign up for it to gain insight
    into the company’s technology and development process. Also check the company’s
    SlideShare or Pastebin accounts. Sometimes, when organizations present at conferences
    or have internal meetings, they upload slides to SlideShare for reference. You
    might be able to find information about the technology stack and security challenges
    faced by the company.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果公司有工程邮件列表，可以注册加入，以便了解公司的技术和开发过程。同时，检查公司的SlideShare或Pastebin账户。有时，当组织在会议上演讲或举行内部会议时，他们会将幻灯片上传到SlideShare以供参考。你可能能够找到关于公司技术栈和面临的安全挑战的信息。
- en: Pastebin ([https://pastebin.com/](https://pastebin.com/)) is a website for pasting
    and storing text online for a short time. People use it to share text across machines
    or with others. Engineers sometimes use it to share source code or server logs
    with their colleagues for viewing or collaboration, so it could be a great source
    of information. You might also find uploaded credentials and development comments.
    Go to Pastebin, search for the target’s organization name, and see what happens!
    You can also use automated tools like PasteHunter ([https://github.com/kevthehermit/PasteHunter/](https://github.com/kevthehermit/PasteHunter/))
    to scan for publicly pasted data.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Pastebin（[https://pastebin.com/](https://pastebin.com/)）是一个用于在线暂时存储文本的网站。人们用它来跨机器或与他人共享文本。工程师有时用它来与同事共享源代码或服务器日志，以便查看或协作，因此它可能是一个重要的信息来源。你也可能会发现上传的凭证和开发者评论。你可以访问Pastebin，搜索目标组织的名称，看看会发生什么！你也可以使用自动化工具，如PasteHunter（[https://github.com/kevthehermit/PasteHunter/](https://github.com/kevthehermit/PasteHunter/)）来扫描公开粘贴的数据。
- en: Lastly, consult archive websites like the Wayback Machine ([https://archive.org/web/](https://archive.org/web/)),
    a digital record of internet content ([Figure 5-9](#figure5-9)). It records a
    site’s content at various points in time. Using the Wayback Machine, you can find
    old endpoints, directory listings, forgotten subdomains, URLs, and files that
    are outdated but still in use. Tomnomnom’s tool Waybackurls ([https://github.com/tomnomnom/waybackurls/](https://github.com/tomnomnom/waybackurls/))
    can automatically extract endpoints and URLs from the Wayback Machine.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，参考类似Wayback Machine的存档网站（[https://archive.org/web/](https://archive.org/web/)），这是一个互联网内容的数字化记录（[图5-9](#figure5-9)）。它记录了网站在不同时间点的内容。通过Wayback
    Machine，你可以找到旧的端点、目录列表、被遗忘的子域名、URL和仍在使用的过时文件。Tomnomnom的工具Waybackurls（[https://github.com/tomnomnom/waybackurls/](https://github.com/tomnomnom/waybackurls/)）可以自动从Wayback
    Machine提取端点和URL。
- en: '![f05009](image_fi/501546c05/f05009.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![f05009](image_fi/501546c05/f05009.png)'
- en: 'Figure 5-9: The Wayback Machine archives the internet and allows you to see
    pages that have been removed by a website.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-9：Wayback Machine存档了互联网，并允许你查看已被网站删除的页面。
- en: Tech Stack Fingerprinting
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术栈指纹识别
- en: Fingerprinting techniques can help you understand the target application even
    better. *Fingerprinting* is identifying the software brands and versions that
    a machine or an application uses. This information allows you to perform targeted
    attacks on the application, because you can search for any known misconfigurations
    and publicly disclosed vulnerabilities related to a particular version. For example,
    if you know the server is using an old version of Apache that could be impacted
    by a disclosed vulnerability, you can immediately attempt to attack the server
    using it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 指纹识别技术可以帮助你更好地理解目标应用程序。*指纹识别*是识别机器或应用程序使用的软件品牌和版本。这些信息使你能够对应用程序执行有针对性的攻击，因为你可以搜索与特定版本相关的已知配置错误和公开披露的漏洞。例如，如果你知道服务器使用的是一个老版本的Apache，而这个版本可能受到已披露的漏洞的影响，你可以立即尝试利用该漏洞攻击服务器。
- en: The security community classifies known vulnerabilities as *Common Vulnerabilities
    and Exposures (**CVEs)* and gives each CVE a number for reference. Search for
    them on the CVE database ([https://cve.mitre.org/cve/search_cve_list.html](https://cve.mitre.org/cve/search_cve_list.html)*).*
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 安全社区将已知漏洞分类为 *Common Vulnerabilities and Exposures (**CVEs)* 并为每个 CVE 分配一个编号以供参考。可以在
    CVE 数据库 ([https://cve.mitre.org/cve/search_cve_list.html](https://cve.mitre.org/cve/search_cve_list.html))
    中搜索它们。
- en: 'The simplest way of fingerprinting an application is to engage with the application
    directly. First, run Nmap on a machine with the `-sV` flag on to enable version
    detection on the port scan. Here, you can see that Nmap attempted to fingerprint
    some software running on the target host for us:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对应用程序进行指纹识别的最简单方法是直接与应用程序进行交互。首先，在一台机器上运行带有 `-sV` 参数的 Nmap，以启用端口扫描时的版本检测。在这里，你可以看到
    Nmap 尝试为我们识别目标主机上运行的某些软件：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, in Burp, send an HTTP request to the server to check the HTTP headers
    used to gain insight into the tech stack. A server might leak many pieces of information
    useful for fingerprinting its technology:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 Burp 中，发送 HTTP 请求到服务器，检查使用的 HTTP 头部，以便获得关于技术栈的洞察。服务器可能泄漏许多对指纹识别其技术有用的信息：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: HTTP headers like `Server` and `X-Powered-By` are good indicators of technologies.
    The `Server` header often reveals the software versions running on the server.
    `X-Powered-By` reveals the server or scripting language used. Also, certain headers
    are used only by specific technologies. For example, only Drupal uses `X-Generator`
    and `X-Drupal-Dynamic-Cache`. Technology-specific cookies such as `PHPSESSID`
    are also clues; if a server sends back a cookie named `PHPSESSID`, it’s probably
    developed using PHP.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 头部信息，如 `Server` 和 `X-Powered-By`，是技术的重要指示器。`Server` 头部通常会透露服务器上运行的软件版本。`X-Powered-By`
    显示服务器或脚本语言的使用情况。此外，某些头部信息仅由特定技术使用。例如，只有 Drupal 使用 `X-Generator` 和 `X-Drupal-Dynamic-Cache`。技术特定的
    cookies，如 `PHPSESSID` 也是线索；如果服务器返回一个名为 `PHPSESSID` 的 cookie，那么该网站很可能是用 PHP 开发的。
- en: 'The HTML source code of web pages can also provide clues. Many web frameworks
    or other technologies will embed a signature in source code. Right-click a page,
    select **View Source Code**, and press CTRL-F to search for phrases like *powered
    by*, *built with*, and *running*. For instance, you might find `Powered by: WordPress
    3.3.2` written in the source.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '网页的 HTML 源代码也可以提供线索。许多 Web 框架或其他技术会在源代码中嵌入一个标识。右键单击页面，选择 **查看源代码**，然后按 CTRL-F
    搜索像 *powered by*、*built with* 和 *running* 这样的短语。例如，你可能会在源代码中找到 `Powered by: WordPress
    3.3.2`。'
- en: Check technology-specific file extensions, filenames, folders, and directories.
    For example, a file named *phpmyadmin* at the root directory, like *https://example.com/phpmyadmin*,
    means the application runs PHP. A directory named *jinja2* that contains templates
    means the site probably uses Django and Jinja2\. You can find more information
    about a specific technology’s filesystem signatures by visiting its individual
    documentation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 检查技术特定的文件扩展名、文件名、文件夹和目录。例如，根目录下的一个名为 *phpmyadmin* 的文件，如 *https://example.com/phpmyadmin*，意味着该应用程序运行的是
    PHP。一个名为 *jinja2* 的目录包含模板，意味着该网站可能使用 Django 和 Jinja2。你可以通过访问特定技术的文档，了解更多关于该技术文件系统标识的信息。
- en: Several applications can automate this process. *Wappalyzer* ([https://www.wappalyzer.com/](https://www.wappalyzer.com/))
    is a browser extension that identifies content management systems, frameworks,
    and programming languages used on a site. *BuiltWith* ([https://builtwith.com/](https://builtwith.com/))
    is a website that shows you which web technologies a site is built with. *StackShare*
    ([https://stackshare.io/](https://stackshare.io/)) is an online platform that
    allows developers to share the tech they use. You can use it to find out if the
    organization’s developers have posted their tech stack. Finally, Retire.js is
    a tool that detects outdated JavaScript libraries and Node.js packages. You can
    use it to check for outdated technologies on a site.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个应用程序可以自动化这一过程。*Wappalyzer* ([https://www.wappalyzer.com/](https://www.wappalyzer.com/))
    是一个浏览器扩展，它可以识别网站上使用的内容管理系统、框架和编程语言。*BuiltWith* ([https://builtwith.com/](https://builtwith.com/))
    是一个网站，它显示网站使用了哪些 Web 技术。*StackShare* ([https://stackshare.io/](https://stackshare.io/))
    是一个在线平台，允许开发者分享他们使用的技术。你可以用它来查看该组织的开发者是否发布了他们的技术栈。最后，Retire.js 是一个检测过时 JavaScript
    库和 Node.js 包的工具。你可以使用它检查网站上的过时技术。
- en: Writing Your Own Recon Scripts
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写你自己的侦察脚本
- en: You’ve probably realized by now that good recon is an extensive process. But
    it doesn’t have to be time-consuming or hard to manage. We’ve already discussed
    several tools that use the power of automation to make the process easier.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，好的侦察是一个广泛的过程。但它不一定是耗时的或难以管理的。我们已经讨论了几种利用自动化力量来简化过程的工具。
- en: Sometimes you may find it handy to write your own scripts. A *script* is a list
    of commands designed to be executed by a program. They’re used to automate tasks
    such as data analysis, web-page generation, and system administration. For us
    bug bounty hunters, scripting is a way of quickly and efficiently performing recon,
    testing, and exploitation. For example, you could write a script to scan a target
    for new subdomains, or enumerate potentially sensitive files and directories on
    a server. Once you’ve learned how to script, the possibilities are endless.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能会发现编写自己的脚本非常有用。*脚本*是由程序执行的一系列命令。它们用于自动化任务，比如数据分析、网页生成和系统管理。对于我们这些漏洞赏金猎人来说，脚本是快速高效地进行侦察、测试和利用的一种方式。例如，你可以编写一个脚本来扫描目标的新子域名，或者枚举服务器上可能敏感的文件和目录。一旦你学会了编写脚本，可能性是无限的。
- en: This section covers bash scripts in particular—what they are and why you should
    use them. You’ll learn how to use bash to simplify your recon process and even
    write your own tools. I’ll assume that you have basic knowledge of how programming
    languages work, including variables, conditionals, loops, and functions, so if
    you’re not familiar with these concepts, please take an introduction to coding
    class at Codecademy ([https://www.codecademy.com/](https://www.codecademy.com/))
    or read a programming book.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本节特别介绍了 bash 脚本——它们是什么以及为什么你应该使用它们。你将学习如何使用 bash 来简化你的侦察过程，甚至编写你自己的工具。我假设你已经具备编程语言的基础知识，包括变量、条件语句、循环和函数，因此，如果你不熟悉这些概念，请在
    Codecademy ([https://www.codecademy.com/](https://www.codecademy.com/)) 上参加入门编码课程或阅读一本编程书籍。
- en: Bash scripts, or any type of shell script, are useful for managing complexities
    and automating recurrent tasks. If your commands involve multiple input parameters,
    or if the input of one command depends on the output of another, entering it all
    manually could get complicated quickly and increase the chance of a programming
    mistake. On the other hand, you might have a list of commands that you want to
    execute many, many times. Scripts are useful here, as they save you the trouble
    of typing the same commands over and over again. Just run the script each time
    and be done with it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 脚本，或任何类型的 shell 脚本，对于管理复杂性和自动化重复任务非常有用。如果你的命令涉及多个输入参数，或者一个命令的输入依赖于另一个命令的输出，那么手动输入所有这些内容可能会迅速变得复杂，并增加编程错误的风险。另一方面，你可能有一组命令需要执行多次。此时，脚本非常有用，因为它可以避免你一次又一次地输入相同的命令。每次运行脚本即可，轻松完成。
- en: Understanding Bash Scripting Basics
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Bash 脚本基础
- en: Let’s write our first script. Open any text editor to follow along. The first
    line of every shell script you write should be the *shebang* *line*. It starts
    with a hash mark (`#`) and an exclamation mark (`!`), and it declares the interpreter
    to use for the script. This allows the plaintext file to be executed like a binary.
    We’ll use it to indicate that we’re using bash.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写第一个脚本。打开任何文本编辑器跟着做。你编写的每个 shell 脚本的第一行应该是 *shebang* *行*。它以一个井号（`#`）和一个感叹号（`!`）开头，声明脚本使用的解释器。这使得纯文本文件能够像二进制文件一样执行。我们将使用它来指示我们使用的是
    bash。
- en: 'Let’s say we want to write a script that executes two commands; it should run
    Nmap and then Dirsearch on a target. We can put the commands in the script like
    this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想编写一个脚本，执行两个命令；它应该先运行 Nmap，然后再在目标上运行 Dirsearch。我们可以这样将命令放入脚本中：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This script isn’t very useful; it can scan only one site, *scanme.nmap.org*.
    Instead, we should let users provide input arguments to the bash script so they
    can choose the site to scan. In bash syntax, `$1` represents the first argument
    passed in, `$2` is the second argument, and so on. Also, `$@` represents all arguments
    passed in, while `$#` represents the total number of arguments. Let’s allow users
    to specify their targets with the first input argument, assigned to the variable
    `$1`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本并不是很有用；它只能扫描一个网站，*scanme.nmap.org*。相反，我们应该让用户提供输入参数给 bash 脚本，这样他们就可以选择要扫描的网站。在
    bash 语法中，`$1` 表示传入的第一个参数，`$2` 是第二个参数，以此类推。此外，`$@` 表示所有传入的参数，而 `$#` 表示参数的总数。让我们允许用户通过第一个输入参数来指定目标，将其分配给变量
    `$1`：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now the commands will execute for whatever domain the user passes in as the
    first argument.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论用户传入什么域名作为第一个参数，命令都将执行。
- en: Notice that the third line of the script includes */PATH/TO/dirsearch.py*. You
    should replace */PATH/TO/* with the absolute path of the directory where you stored
    the Dirsearch script. If you don’t specify its location, your computer will try
    to look for it in the current directory, and unless you stored the Dirsearch file
    in the same directory as your shell script, bash won’t find it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，脚本的第三行包含 */PATH/TO/dirsearch.py*。你应该将 */PATH/TO/* 替换为你存储 Dirsearch 脚本的目录的绝对路径。如果你没有指定其位置，计算机会尝试在当前目录中查找，除非你将
    Dirsearch 文件存储在与 shell 脚本相同的目录中，否则 bash 将找不到它。
- en: 'Another way of making sure that your script can find the commands to use is
    through the `PATH` variable, an environmental variable in Unix systems that specifies
    where executable binaries are found. If you run this command to add Dirsearch’s
    directory to your `PATH`, you can run the tool from anywhere without needing to
    specify its absolute path:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 确保脚本可以找到要使用的命令的另一种方法是通过 `PATH` 变量，`PATH` 是 Unix 系统中的一个环境变量，用于指定可执行二进制文件的位置。如果你运行此命令将
    Dirsearch 的目录添加到 `PATH`，你就可以在任何地方运行该工具，而无需指定其绝对路径：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After executing this command, you should be able to use Dirsearch directly:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，你应该能够直接使用 Dirsearch：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that you will have to run the `export` command again after you restart
    your terminal for your `PATH` to contain the path to Dirsearch. If you don’t want
    to export `PATH` over and over again, you can add the `export` command to your
    *~/**.bash_profile*file, a file that stores your bash preferences and configuration.
    You can do this by opening *~/.bash_profile* with your favorite text editor and
    adding the `export` command to the bottom of the file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，重新启动终端后，你需要再次运行 `export` 命令，以便 `PATH` 包含 Dirsearch 的路径。如果你不想一遍又一遍地导出 `PATH`，可以将
    `export` 命令添加到你的 *~/**.bash_profile* 文件中，该文件用于存储你的 bash 配置和偏好设置。你可以通过使用你喜欢的文本编辑器打开
    *~/.bash_profile*，并将 `export` 命令添加到文件的末尾。
- en: 'The script is complete! Save it in your current directory with the filename
    *recon.sh*. The *.sh* extension is the conventional extension for shell scripts.
    Make sure your terminal’s working directory is the same as the one where you’ve
    stored your script by running the command `cd /``location``/``of``/``your``/``script`.
    Execute the script in the terminal with this command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本已经完成！将其保存在当前目录，并命名为 *recon.sh*。*.sh* 扩展名是 shell 脚本的常见扩展名。确保终端的工作目录与存储脚本的目录相同，可以通过运行命令
    `cd /``location``/``of``/``your``/``script` 来确认。然后在终端中执行此命令来运行脚本：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You might see a message like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到类似以下的消息：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is because the current user doesn’t have permission to execute the script.
    For security purposes, most files aren’t executable by default. You can correct
    this behavior by adding executing rights for everyone by running this command
    in the terminal:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当前用户没有执行脚本的权限。出于安全考虑，大多数文件默认不能执行。你可以通过在终端中运行以下命令，向所有人添加执行权限来修正这个问题：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `chmod` command edits the permissions for a file, and `+x` indicates that
    we want to add the permission to execute for all users. If you’d like to grant
    executing rights for the owner of the script only, use this command instead:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`chmod` 命令用于修改文件权限，`+x` 表示我们要为所有用户添加执行权限。如果你只想为脚本的所有者授予执行权限，可以改用以下命令：'
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now run the script as we did before. Try passing in *scanme.nmap.org* as the
    first argument. You should see the output of the Nmap and Dirsearch printed out:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在像之前一样运行脚本。尝试将 *scanme.nmap.org* 作为第一个参数传入。你应该会看到 Nmap 和 Dirsearch 的输出：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Saving Tool Output to a File
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将工具输出保存到文件
- en: 'To analyze the recon results later, you may want to save your scripts’ output
    in a separate file. This is where input and output redirection come into play.
    *Input redirection*is using the content of a file, or the output of another program,
    as the input to your script. *Output redirection* is redirecting the output of
    a program to another location, such as to a file or another program. Here are
    some of the most useful redirection operators:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以后分析 recon 结果，你可能想将脚本的输出保存到一个单独的文件中。这时，输入和输出重定向就派上用场了。*输入重定向*是使用文件的内容或另一个程序的输出作为脚本的输入。*输出重定向*是将程序的输出重定向到另一个位置，比如文件或另一个程序。以下是一些最常用的重定向操作符：
- en: '`PROGRAM` `>` `FILENAME` Writes the program’s output into the file with that
    name. (It will clear any content from the file first. It will also create the
    file if the file does not already exist.)'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PROGRAM` `>` `FILENAME` 将程序的输出写入具有该名称的文件中。（它会首先清空文件中的任何内容。如果文件不存在，它还会创建该文件。）'
- en: '`PROGRAM` `>>` `FILENAME` Appends the output of the program to the end of the
    file, without clearing the file’s original content.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PROGRAM` `>>` `FILENAME` 将程序的输出追加到文件末尾，而不清除文件的原始内容。'
- en: '`PROGRAM` `<` `FILENAME` Reads from the file and uses its content as the program
    input.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PROGRAM` `<` `FILENAME` 从文件读取内容，并将其用作程序的输入。'
- en: '`PROGRAM1` `|` `PROGRAM2` Uses the output of `PROGRAM1` as the input to `PROGRAM2`.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PROGRAM1` `|` `PROGRAM2` 将`PROGRAM1`的输出作为`PROGRAM2`的输入。'
- en: 'We could, for example, write the results of the Nmap and Dirsearch scans into
    different files:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将Nmap和Dirsearch扫描的结果分别写入不同的文件：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `echo` command 1 prints a message to the terminal. Next, `mkdir` creates
    a directory with the name *DOMAIN_recon* 2. We store the results of `nmap` into
    a file named *nmap* in the newly created directory 3. Dirsearch’s `simple-report`
    flag 4 generates a report in the designated location. We store the results of
    Dirsearch to a file named *dirsearch* in the new directory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`命令1将消息打印到终端。接下来，`mkdir`创建一个名为*DOMAIN_recon*的目录2。我们将`nmap`的结果存储到新创建的目录3中的名为*nmap*的文件中。Dirsearch的`simple-report`标志4将在指定位置生成报告。我们将Dirsearch的结果存储到新目录中的名为*dirsearch*的文件中。'
- en: 'You can make your script more manageable by introducing variables to reference
    files, names, and values. Variables in bash can be assigned using the following
    syntax: `VARIABLE_NAME``=``VARIABLE_VALUE`. Note that there should be no spaces
    around the equal sign. The syntax for referencing variables is `$``VARIABLE_NAME`.
    Let’s implement these into the script:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过引入变量来引用文件、名称和值，使脚本更易管理。在bash中，可以使用以下语法为变量赋值：`VARIABLE_NAME``=``VARIABLE_VALUE`。注意等号两边不要有空格。引用变量的语法是`$``VARIABLE_NAME`。让我们将这些实现到脚本中：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We use `${DOMAIN}_recon` instead of `$DOMAIN_recon` 1 because, otherwise, bash
    would recognize the entirety of `DOMAIN_recon` as the variable name. The curly
    brackets tell bash that `DOMAIN` is the variable name, and `_recon` is the plaintext
    we’re appending to it. Notice that we also stored the path to Dirsearch in a variable
    to make it easy to change in the future 2.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`${DOMAIN}_recon`而不是`$DOMAIN_recon`1，因为否则bash会将`DOMAIN_recon`的整体识别为变量名。大括号告诉bash，`DOMAIN`是变量名，`_recon`是我们附加的纯文本。注意，我们还将Dirsearch的路径存储在一个变量中，以便将来可以轻松更改2。
- en: Using redirection, you can now write shell scripts that run many tools in a
    single command and save their outputs in separate files.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重定向，现在你可以编写运行多个工具的Shell脚本，并将它们的输出保存在不同的文件中。
- en: Adding the Date of the Scan to the Output
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将扫描日期添加到输出中
- en: Let’s say you want to add the current date to your script’s output, or select
    which scans to run, instead of always running both Nmap and Dirsearch. If you
    want to write tools with more functionalities like this, you have to understand
    some advanced shell scripting concepts.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想将当前日期添加到脚本的输出中，或选择要运行的扫描，而不是总是运行Nmap和Dirsearch。如果你想编写具有更多功能的工具，像这样，你需要了解一些高级Shell脚本概念。
- en: 'For example, a useful one is *command substitution*, or operating on the output
    of a command. Using `$()` tells Unix to execute the command surrounded by the
    parentheses and assign its output to the value of a variable. Let’s practice using
    this syntax:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个有用的功能是*命令替换*，即对命令的输出进行操作。使用`$()`会告诉Unix执行括号内的命令，并将其输出赋值给变量的值。让我们练习使用这个语法：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At 1, we assign the output of the `date` command to the variable `TODAY`. The
    `date` command displays the current date and time. This lets us output a message
    indicating the day on which we performed the scan 2.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我们将`date`命令的输出赋值给变量`TODAY`。`date`命令显示当前的日期和时间。这样我们可以输出一条信息，指示我们执行扫描的日期2。
- en: Adding Options to Choose the Tools to Run
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加选项以选择要运行的工具
- en: 'Now, to selectively run only certain tools, you need to use conditionals. In
    bash, the syntax of an `if` statement is as follows. Note that the conditional
    statement ends with the `fi` keyword, which is `if` backward:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了选择性地运行某些工具，你需要使用条件语句。在bash中，`if`语句的语法如下。注意，条件语句以`fi`关键字结束，即`if`的反向拼写：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s say that we want users to be able to specify the scan `MODE`, as such:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望用户能够指定扫描的`MODE`，像这样：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can implement this functionality like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样实现这个功能：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the user specifies `nmap-only` 1, we run `nmap` only and store the results
    to a file named *nmap* 2. If the user specifies `dirsearch-only` 3, we execute
    and store the results of Dirsearch only 4. If the user specifies neither 5, we
    run both scans 6.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户指定了`nmap-only` 1，我们只运行`nmap`并将结果存储到名为*nmap* 2的文件中。如果用户指定了`dirsearch-only`
    3，我们只执行并存储Dirsearch的结果4。如果用户没有指定任何选项5，我们运行两个扫描6。
- en: 'Now you can make your tool run only the Nmap or Dirsearch commands by specifying
    one of these in the command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过在命令中指定其中一个来让工具只运行Nmap或Dirsearch命令：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Running Additional Tools
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行附加工具
- en: 'What if you want the option of retrieving information from the crt.sh tool,
    as well? For example, you want to switch between these three modes or run all
    three recon tools at once:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从crt.sh工具获取信息的选项呢？例如，你想在这三种模式之间切换，或者一次运行所有三个侦察工具：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We could rewrite the `if-else` statements to work with three options: first,
    we check if `MODE` is `nmap-only`. Then we check if `MODE` is `dirsearch-only`,
    and finally if `MODE` is `crt-only`. But that’s a lot of `if-else` statements,
    making the code complicated.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写`if-else`语句来处理三种选项：首先，我们检查`MODE`是否为`nmap-only`。然后检查`MODE`是否为`dirsearch-only`，最后检查`MODE`是否为`crt-only`。但是这会有很多`if-else`语句，使得代码变得复杂。
- en: 'Instead, let’s use bash’s `case` statements, which allow you to match several
    values against one variable without going through a long list of `if-else` statements.
    The syntax of `case` statements looks like this. Note that the statement ends
    with `esac`, or `case` backward:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使用bash的`case`语句，它允许你将多个值与一个变量进行匹配，而无需遍历冗长的`if-else`语句列表。`case`语句的语法如下所示。请注意，语句以`esac`结束，或者说是`case`的反向写法：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can improve our script by implementing the functionality with `case` statements
    instead of multiple `if-else` statements:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`case`语句来改进我们的脚本，而不是使用多个`if-else`语句：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `curl` command 1 downloads the content of a page. We use it here to download
    data from crt.sh. And `curl`’s `-o` option lets you specify an output file. But
    notice that our code has a lot of repetition! The sections of code that run each
    type of scan repeat twice. Let’s try to reduce the repetition by using functions.
    The syntax of a bash function looks like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`命令1用于下载页面内容。我们在这里使用它从crt.sh下载数据。而`curl`的`-o`选项让你指定输出文件。但注意，我们的代码有很多重复！每种类型的扫描代码重复了两次。让我们通过使用函数来减少重复。bash函数的语法如下所示：'
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After you’ve declared a function, you can call it like any other shell command
    within the script. Let’s add functions to the script:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在你声明了一个函数之后，可以像调用其他shell命令一样在脚本中调用它。让我们为脚本添加函数：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can see that we’ve simplified our code. We created three functions, `nmap_scan`
    1, `dirsearch_scan` 2, and `crt_scan` 3. We put the `scan` and `echo` commands
    in these functions so we can call them repeatedly without writing the same code
    over and over 4. This simplification might not seem like much here, but reusing
    code with functions will save you a lot of headaches when you write more complex
    programs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们简化了代码。我们创建了三个函数，`nmap_scan` 1、`dirsearch_scan` 2 和 `crt_scan` 3。我们将`scan`和`echo`命令放入这些函数中，这样我们就可以反复调用它们，而无需一遍又一遍地写相同的代码4。这种简化在这里可能看起来不多，但通过函数重用代码，当你编写更复杂的程序时，它将为你节省大量麻烦。
- en: 'Keep in mind that all bash variables are *global* except for input parameters
    like `$1`, `$2`, and `$3`. This means that variables like `$DOMAIN`, `$DIRECTORY`,
    and `$PATH_TO_DIRSEARCH` become available throughout the script after we’ve declared
    them, even if they’re declared within functions. On the other hand, parameter
    values like `$1`, `$2`, and `$3` can refer only to the values the function is
    called with, so you can’t use a script’s input arguments within a function, like
    this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有bash变量都是*全局*的，除了输入参数如`$1`、`$2`和`$3`。这意味着像`$DOMAIN`、`$DIRECTORY`和`$PATH_TO_DIRSEARCH`这样的变量在我们声明它们后将可以在整个脚本中使用，即使它们是在函数内声明的。另一方面，像`$1`、`$2`和`$3`这样的参数值只能指代函数调用时传入的值，因此你不能在函数内使用脚本的输入参数，如下所示：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, the `$1` in the function refers to the first argument that `nmap_scan`
    was called with, not the argument our *recon.sh* script was called with. Since
    `nmap_scan` wasn’t called with any arguments, `$1` is blank.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，函数中的`$1`指的是`nmap_scan`被调用时传入的第一个参数，而不是我们的*recon.sh*脚本被调用时传入的参数。由于`nmap_scan`没有传入任何参数，`$1`是空的。
- en: Parsing the Results
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析结果
- en: Now we have a tool that performs three types of scans and stores the results
    into files. But after the scans, we’d still have to manually read and make sense
    of complex output files. Is there a way to speed up this process too?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个执行三种类型扫描并将结果存储到文件中的工具。但扫描之后，我们仍然需要手动读取并理解复杂的输出文件。有没有办法加速这个过程呢？
- en: 'Let’s say you want to search for a certain piece of information in the output
    files. You can use *Global Regular Expression Print* *(*`grep`*)* to do that.
    This command line utility is used to perform searches in text, files, and command
    outputs. A simple `grep` command looks like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在输出文件中搜索某些信息。你可以使用*全局正则表达式打印*（*`grep`*）来完成。这个命令行工具用于在文本、文件和命令输出中执行搜索。一个简单的`grep`命令如下所示：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This tells `grep` to search for the string `password` in the file *file.txt*,
    then print the matching lines in standard output. For example, we can quickly
    search the Nmap output file to see if the target has port 80 open:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉`grep`在文件*file.txt*中搜索字符串`password`，然后在标准输出中打印匹配的行。例如，我们可以快速搜索Nmap输出文件，查看目标是否开放了80端口：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can also make your search more flexible by using regular expressions in
    your search string. A *regular expression*, or *regex*, is a special string that
    describes a search pattern. It can help you display only specific parts of the
    output. For example, you may have noticed that the output of the Nmap command
    looks like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在搜索字符串中使用正则表达式来使搜索更加灵活。*正则表达式*，或*regex*，是一种描述搜索模式的特殊字符串。它可以帮助你仅显示输出的特定部分。例如，你可能已经注意到，Nmap命令的输出如下所示：
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You might want to trim the irrelevant messages from the file so it looks more
    like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望从文件中剔除不相关的消息，使其更像这样：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use this command to filter out the messages at the start and end of Nmap’s
    output and keep only the essential part of the report:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令过滤掉Nmap输出开始和结尾的消息，只保留报告的核心部分：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `-E` flag tells `grep` you’re using a regex. A regex consists of two parts:
    constants and operators. *Constants* are sets of strings, while *operators* are
    symbols that denote operations over these strings. These two elements together
    make regex a powerful tool of pattern matching. Here’s a quick overview of regex
    operators that represent characters:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`-E`标志告诉`grep`你正在使用正则表达式。正则表达式由两部分组成：常量和运算符。*常量*是字符串集，而*运算符*是表示对这些字符串进行操作的符号。这两种元素结合起来，使正则表达式成为强大的模式匹配工具。以下是表示字符的正则表达式运算符的快速概述：'
- en: '`\d` matches any digit.'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\d`匹配任何数字。'
- en: '`\w` matches any character.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\w`匹配任何字符。'
- en: '`\s` matches any whitespace, and `\S` matches any non-whitespace.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\s`匹配任何空白字符，而`\S`匹配任何非空白字符。'
- en: '`.` matches with any single character.'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.`匹配任何单个字符。'
- en: '`\` escapes a special character.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\`转义特殊字符。'
- en: '`^` matches the start of the string or line.'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`^`匹配字符串或行的开头。'
- en: '`$` matches the end of the string or line.'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$`匹配字符串或行的结尾。'
- en: 'Several operators also specify the number of characters to match:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个运算符指定要匹配的字符数量：
- en: '`*` matches the preceding character zero or more times.'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*`匹配前一个字符零次或多次。'
- en: '`+` matches the preceding character one or more times.'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`+`匹配前一个字符一次或多次。'
- en: '`{3}` matches the preceding character three times.'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{3}`匹配前一个字符三次。'
- en: '`{1, 3}` matches the preceding character one to three times.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{1, 3}`匹配前一个字符一次到三次。'
- en: '`{1, }` matches the preceding character one or more times.'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{1, }`匹配前一个字符一次或多次。'
- en: '`[``abc``]` matches one of the characters within the brackets.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[``abc``]`匹配括号中的一个字符。'
- en: '`[``a``-``z``]` matches one of the characters within the range of `a` to `z`.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[``a``-``z``]`匹配`a`到`z`范围内的一个字符。'
- en: '`(``a``|``b``|``c``)` matches either `a` or `b` or `c`.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(``a``|``b``|``c``)`匹配`a`、`b`或`c`。'
- en: 'Let’s take another look at our regex expression here. Remember how `\s` matches
    any whitespace, and `\S` matches any non-whitespace? This means `\s+` would match
    any whitespace one or more characters long, and `\S+` would match any non-whitespace
    one or more characters long. This regex pattern specifies that we should extract
    lines that contain three strings separated by two whitespaces:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一遍这里的正则表达式。记住`\s`匹配任何空白字符，而`\S`匹配任何非空白字符吗？这意味着`\s+`将匹配一个或多个空白字符，而`\S+`将匹配一个或多个非空白字符。这个正则表达式模式指定我们应提取包含三个字符串并由两个空格分隔的行：
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The filtered output will look like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤后的输出将如下所示：
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To account for extra whitespaces that might be in the command output, let’s
    add two more optional spaces around our search string:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理命令输出中可能存在的额外空格，让我们在搜索字符串周围再添加两个可选的空格：
- en: '[PRE53]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can use many more advanced regex features to perform more sophisticated
    matching. However, this simple set of operators serves well for our purposes.
    For a complete guide to regex syntax, read RexEgg’s cheat sheet ([https://www.rexegg.com/regex-quickstart.html](https://www.rexegg.com/regex-quickstart.html)).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用更多高级的正则表达式特性来进行更复杂的匹配。然而，这一组简单的操作符足以满足我们的需求。要了解完整的正则表达式语法，请阅读RexEgg的备忘单([https://www.rexegg.com/regex-quickstart.html](https://www.rexegg.com/regex-quickstart.html))。
- en: Building a Master Report
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建主报告
- en: 'What if you want to produce a master report from all three output files? You
    need to parse the JSON file from crt.sh. You can do this with `jq`, a command
    line utility that processes JSON. If we examine the JSON output file from crt.sh,
    we can see that we need to extract the `name_value` field of each certificate
    item to extract domain names. This command does just that:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从所有三个输出文件生成一个主报告怎么办？你需要解析来自crt.sh的JSON文件。你可以使用`jq`来完成这项任务，`jq`是一个处理JSON的命令行工具。如果我们检查来自crt.sh的JSON输出文件，我们可以看到需要提取每个证书项的`name_value`字段来获取域名。这个命令正是这么做的：
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `-r` flag tells `jq` to write the output directly to standard output rather
    than format it as JSON strings. The `.[]` iterates through the array within the
    JSON file, and `.name_value` extracts the `name_value` field of each item. Finally,
    `$DOMAIN/crt` is the input file to the `jq` command. To learn more about how `jq`
    works, read its manual ([https://stedolan.github.io/jq/manual/](https://stedolan.github.io/jq/manual/)).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`-r`标志告诉`jq`将输出直接写入标准输出，而不是将其格式化为JSON字符串。`.[]`遍历JSON文件中的数组，`.name_value`提取每个项的`name_value`字段。最后，`$DOMAIN/crt`是`jq`命令的输入文件。要了解更多关于`jq`的工作原理，请阅读它的手册([https://stedolan.github.io/jq/manual/](https://stedolan.github.io/jq/manual/))。'
- en: 'To combine all output files into a master report, write a script like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要将所有输出文件合并为主报告，可以编写一个像这样的脚本：
- en: '[PRE55]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: First, we create a new file named *report* and write today’s date into it 1
    to keep track of when the report was generated. We then append the results of
    the `nmap` and `dirsearch` commands into the report file 2. The `cat` command
    prints the contents of a file to standard output, but we can also use it to redirect
    the content of the file into another file 3. Finally, we extract domain names
    from the crt.sh report and append it to the end of the report file 4.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为*report*的新文件，并将今天的日期写入文件1，以跟踪报告生成的时间。然后，我们将`nmap`和`dirsearch`命令的结果追加到报告文件中2。`cat`命令将文件内容打印到标准输出，但我们也可以用它将文件的内容重定向到另一个文件3。最后，我们从crt.sh报告中提取域名，并将其追加到报告文件的末尾4。
- en: Scanning Multiple Domains
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扫描多个域名
- en: 'What if we want to scan multiple domains at once? When reconning a target,
    we might start with several of the organization’s domain names. For example, we
    know that Facebook owns both *facebook.com* and *fbcdn.net*. But our current script
    allows us to scan only one domain at a time. We need to write a tool that can
    scan multiple domains with a single command, like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想一次扫描多个域名怎么办？在侦察目标时，我们可能会从组织的多个域名开始。例如，我们知道Facebook拥有*facebook.com*和*fbcdn.net*两个域名。但是我们当前的脚本只允许一次扫描一个域名。我们需要编写一个能够通过单个命令扫描多个域名的工具，像这样：
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When we scan multiple domains like this, we need a way to distinguish which
    arguments specify the scan `MODE` and which specify target domains. As you’ve
    already seen from the tools I introduced, most tools allow users to modify the
    behavior of a tool by using command line *option**s* or *flags*, such as `-u`
    and `--simple-report`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们像这样扫描多个域名时，我们需要一种方式来区分哪些参数指定扫描`MODE`，哪些指定目标域名。正如你已经从我介绍的工具中看到的，大多数工具都允许用户通过使用命令行*选项*或*标志*来修改工具的行为，例如`-u`和`--simple-report`。
- en: 'The `getopts` tool parses options from the command line by using single-character
    flags. Its syntax is as follows, where `OPTSTRING` specifies the option letters
    that `getopts` should recognize. For example, if it should recognize the options
    `-m` and `-i`, you should specify `mi`. If you want an option to contain argument
    values, the letter should be followed by a colon, like this: `m:i`. The `NAME`
    argument specifies the variable name that stores the option letter.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`getopts` 工具通过使用单字符标志从命令行解析选项。它的语法如下，其中 `OPTSTRING` 指定 `getopts` 应该识别的选项字母。例如，如果它应该识别选项
    `-m` 和 `-i`，你应该指定 `mi`。如果你希望一个选项包含参数值，该字母后面应该跟一个冒号，像这样：`m:i`。`NAME` 参数指定存储选项字母的变量名。'
- en: '[PRE57]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To implement our multiple-domain scan functionality, we can let users use an
    `-m` flag to specify the scan mode and assume that all other arguments are domains.
    Here, we tell `getopts` to recognize an option if the option flag is `-m` and
    that this option should contain an input value. The `getopts` tool also automatically
    stores the value of any options into the `$OPTARG` variable. We can store that
    value into a variable named `MODE:`
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的多域扫描功能，我们可以让用户使用 `-m` 标志来指定扫描模式，并假设所有其他参数都是域名。在这里，我们告诉 `getopts` 当选项标志是
    `-m` 时识别该选项，并且该选项应包含一个输入值。`getopts` 工具还会自动将任何选项的值存储到 `$OPTARG` 变量中。我们可以将该值存储到名为
    `MODE` 的变量中：
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now if you run the shell script with an `-m` flag, the script will know that
    you’re specifying a scan `MODE`! Note that `getopts` stops parsing arguments when
    it encounters an argument that doesn’t start with the `-` character, so you’ll
    need to place the scan mode before the domain arguments when you run the script:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行带有 `-m` 标志的 shell 脚本，脚本就会知道你指定了扫描 `MODE`！注意，当 `getopts` 遇到一个不以 `-` 字符开头的参数时，它会停止解析参数，因此在运行脚本时，你需要将扫描模式放在域名参数之前：
- en: '[PRE59]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we’ll need a way to read every domain argument and perform scans on them.
    Let’s use loops! Bash has two types of loops: the `for` loop and the `while` loop.
    The `for` loop works better for our purposes, as we already know the number of
    values we are looping through. In general, you should use `for` loops when you
    already have a list of values to iterate through. You should use `while` loops
    when you’re not sure how many values to loop through but want to specify the condition
    in which the execution should stop.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法来读取每个域名参数并对它们进行扫描。我们可以使用循环！Bash 有两种类型的循环：`for` 循环和 `while` 循环。`for`
    循环更适合我们的目的，因为我们已经知道我们正在循环的值的数量。一般来说，当你已经有一个值的列表需要遍历时，你应该使用 `for` 循环。当你不确定需要遍历多少个值，但希望指定执行停止的条件时，你应该使用
    `while` 循环。
- en: 'Here’s the syntax of a `for` loop in bash. For every item in `LIST_OF_VALUES`,
    bash will execute the code between `do` and `done` once:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 bash 中 `for` 循环的语法。对于 `LIST_OF_VALUES` 中的每一项，bash 会执行 `do` 和 `done` 之间的代码一次：
- en: '[PRE60]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now let’s implement our functionality by using a `for` loop:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过使用 `for` 循环来实现我们的功能：
- en: '[PRE61]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We create an array 1 that contains every command line argument, besides the
    ones that are already parsed by `getopts`, which stores the index of the first
    argument after the options it parses into a variable named `$OPTIND`. The characters
    `$@` represent the array containing all input arguments, while `$#` is the number
    of command line arguments passed in. `"${@:OPTIND:}"` slices the array so that
    it removes the `MODE` argument, like `nmap-only`, making sure that we iterate
    through only the domains part of our input. Array slicing is a way of extracting
    a subset of items from an array. In bash, you can slice arrays by using this syntax
    (note that the quotes around the command are necessary):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个数组 1，包含所有命令行参数，除了那些已经被 `getopts` 解析的参数，它会将解析后的第一个参数的索引存储到名为 `$OPTIND`
    的变量中。字符 `$@` 代表包含所有输入参数的数组，而 `$#` 是传入的命令行参数的数量。`"${@:OPTIND:}"` 通过切片数组来移除 `MODE`
    参数，比如 `nmap-only`，确保我们只遍历输入中的域名部分。数组切片是从数组中提取子集的一种方式。在 bash 中，你可以使用这种语法切片数组（注意命令周围的引号是必要的）：
- en: '[PRE62]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `$i` variable represents the current item in the argument array. We can
    then wrap the loop around the code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`$i` 变量代表参数数组中的当前项。然后我们可以将循环包裹在代码周围：'
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `for` loop starts with the `for` keyword 1 and ends with the `done` keyword
    5. Notice that we also added a few lines in the report section to see if we need
    to generate each type of report. We check whether the output file of an Nmap scan,
    a Dirsearch scan, or a crt.sh scan exist so we can determine if we need to generate
    a report for that scan type 2 3 4.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环以 `for` 关键字开始，并以 `done` 关键字结束。注意，我们还在报告部分添加了一些行，以查看是否需要为每种类型的扫描生成报告。我们检查
    Nmap 扫描、Dirsearch 扫描或 crt.sh 扫描的输出文件是否存在，以便确定是否需要为该扫描类型生成报告。'
- en: 'The brackets around a condition mean that we’re passing the contents into a`test`
    command: `[ -f $DIRECTORY/nmap ]` is equivalent to `test -f $DIRECTORY/nmap`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 括号包围的条件意味着我们将内容传递给 `test` 命令：`[ -f $DIRECTORY/nmap ]` 等同于 `test -f $DIRECTORY/nmap`。
- en: 'The `test` command evaluates a conditional and outputs either `true` or `false`.
    The `-f` flag tests whether a file exists. But you can test for more conditions!
    Let’s go through some useful test conditions. The `-eq` and -`ne` flags test for
    equality and inequality, respectively. This returns `true` if `$3` is equal to
    `1`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 命令评估一个条件并输出 `true` 或 `false`。`-f` 标志测试一个文件是否存在。但你可以测试更多条件！让我们来看看一些有用的测试条件。`-eq`
    和 `-ne` 标志分别测试相等和不等。如果 `$3` 等于 `1`，则返回 `true`：'
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This returns `true` if `$3` is not equal to `1`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `$3` 不等于 `1`，则返回 `true`：
- en: '[PRE65]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `-gt`, `-ge`, `-lt`, and `le` flags test for greater than, greater than
    or equal to, less than, and less than or equal to, respectively:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`-gt`、`-ge`、`-lt` 和 `-le` 标志分别测试大于、大于或等于、小于和小于或等于：'
- en: '[PRE66]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `-z` and `-n` flags test whether a string is empty. These conditions are
    both true:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`-z` 和 `-n` 标志测试一个字符串是否为空。这些条件都为真：'
- en: '[PRE67]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `-d`, `-f`, `-r`, `-w`, and `-x` flags check for directory and file statuses.
    You can use them to check the existence and permissions of a file before your
    shell script operates on them. For instance, this command returns `true` if */bin*
    is a directory that exists:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`、`-f`、`-r`、`-w` 和 `-x` 标志检查目录和文件状态。你可以使用它们检查文件的存在和权限，然后再让你的 shell 脚本操作它们。例如，这个命令如果
    */bin* 是一个存在的目录，则返回 `true`：'
- en: '[PRE68]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This one returns `true` if */bin/bash* is a file that exists:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 */bin/bash* 是一个存在的文件，这个命令返回 `true`：
- en: '[PRE69]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And this one returns `true` if */bin/bash* is a readable file:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 */bin/bash* 是一个可读文件，这个命令返回 `true`：
- en: '[PRE70]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'or a writable file:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 或可写文件：
- en: '[PRE71]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'or an executable file:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 或可执行文件：
- en: '[PRE72]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can also use `&&` and `||` to combine test expressions. This command returns
    `true` if both expressions are true:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `&&` 和 `||` 来组合测试表达式。这个命令只有在两个表达式都为真时才返回 `true`：
- en: '[PRE73]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And this one returns `true` if at least one of them is true:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中至少一个条件为真，则这个命令返回 `true`：
- en: '[PRE74]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You can find more comparison flags in the `test` command’s manual by running
    `man test`. (If you aren’t sure about the commands you’re using, you can always
    enter `man` followed by the command name in the terminal to access the command’s
    manual file.)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行 `man test` 在 `test` 命令的手册中找到更多的比较标志。（如果你不确定正在使用的命令，你可以在终端中输入 `man` 然后是命令名称，以访问该命令的手册文件。）
- en: Writing a Function Library
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个函数库
- en: 'As your codebase gets larger, you should consider writing a *function library*
    to reuse code. We can store all the commonly used functions in a separate file
    called *scan.lib*. That way, we can call these functions as needed for future
    recon tasks:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 随着代码库的扩大，你应该考虑编写一个 *函数库* 来重用代码。我们可以将所有常用的函数存储在一个名为 *scan.lib* 的单独文件中。这样，我们就可以根据需要在未来的侦查任务中调用这些函数：
- en: '[PRE75]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In another file, we can sourcethe library file in order to use all of its functions
    and variables. We source a script via the `source` command, followed by the path
    to the script:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个文件中，我们可以源文件库来使用其中的所有函数和变量。我们通过 `source` 命令并跟上脚本路径来源一个脚本：
- en: '[PRE76]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Using a library can be super useful when you’re building multiple tools that
    require the same functionalities. For example, you might build multiple networking
    tools that all require DNS resolution. In this case, you can simply write the
    functionality once and use it in all of your tools.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用库在构建多个需要相同功能的工具时非常有用。例如，你可能会构建多个网络工具，而它们都需要 DNS 解析。在这种情况下，你可以只编写一次功能，并在所有工具中使用它。
- en: Building Interactive Programs
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建交互式程序
- en: 'What if you want to build an interactive program that takes user input during
    execution? Let’s say that if users enter the command line option, `-i`, you want
    the program to enter an interactive mode that allows you to specify domains to
    scan as you go:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想构建一个交互式程序，在执行期间接受用户输入该怎么办？假设如果用户输入命令行选项`-i`，你希望程序进入一个交互模式，在此模式下，你可以在进行时指定要扫描的域名：
- en: '[PRE77]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'For that, you can use `read`. This command reads user input and stores the
    input string into a variable:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你可以使用`read`。该命令读取用户输入并将输入的字符串存储到一个变量中：
- en: '[PRE78]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: These commands will prompt the user to enter a domain, then store the input
    inside a variable named `$DOMAIN`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将提示用户输入一个域名，然后将输入存储在名为`$DOMAIN`的变量中。
- en: 'To prompt a user repeatedly, we need to use a `while` loop, which will keep
    printing the prompt asking for an input domain until the user exits the program.
    Here’s the syntax of a `while` loop. As long as the `CONDITION` is true, the `while`
    loop will execute the code between `do` and `done` repeatedly:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要反复提示用户，我们需要使用`while`循环，这将不断打印提示符，直到用户退出程序。下面是`while`循环的语法。只要`CONDITION`为真，`while`循环就会重复执行`do`和`done`之间的代码：
- en: '[PRE79]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can use a `while` loop to repeatedly prompt the user for domains until the
    user enters `quit`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`while`循环反复提示用户输入域名，直到用户输入`quit`：
- en: '[PRE80]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We also need a way for users to actually invoke the `-i` *option, and our* `getopts`
    *command isn’t currently doing that. We can use a* `while` *loop to parse options
    by using* `getopts` *repeatedly:*
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法，让用户实际调用`-i` *选项，而我们当前的* `getopts` *命令并没有做到这一点。我们可以使用* `while` *循环通过反复使用*
    `getopts` *来解析选项：*
- en: '[PRE81]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '*Here, we specify a* `while` *loop that gets command line options repeatedly.
    If the option flag is* `-m`*, we set the* `MODE` *variable to the scan mode that
    the user has specified. If the option flag is* `-i`*, we set the* `$INTERACTIVE`
    *variable to* `true`. Then, later in the script, we can decide whether to invoke
    the interactive mode by checking the value of the `$INTERACTIVE` *variable. Putting
    it all together, we get our final script:*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这里，我们指定了一个* `while` *循环，用于反复获取命令行选项。如果选项标志是* `-m` *，我们将* `MODE` *变量设置为用户指定的扫描模式。如果选项标志是*
    `-i` *，我们将* `$INTERACTIVE` *变量设置为* `true` *。然后，在脚本的后续部分，我们可以通过检查`$INTERACTIVE`
    *变量的值来决定是否启动交互模式。把这一切放在一起，我们得到最终的脚本：*'
- en: '[PRE82]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In this program, we first check if the user has selected the interactive mode
    by specifying the `-i` *option* 1*. We then repeatedly prompt the user for a domain
    by using a* `while` *loop* 2*. If the user input is not the keyword* `quit`*,
    we assume that they entered a target domain, so we scan and produce a report for
    that domain. The* `while` *loop will continue to run and ask the user for domains
    until the user enters* `quit`*, which will cause the* `while` *loop to exit and
    the program to terminate* 3*.*
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们首先检查用户是否通过指定`-i` *选项* 1* 选择了交互模式。然后，我们通过使用* `while` *循环* 2* 反复提示用户输入域名。如果用户输入的不是关键字*
    `quit` *，我们假定他们输入了一个目标域名，于是我们为该域名进行扫描并生成报告。* `while` *循环将继续运行，直到用户输入* `quit` *，这将导致*
    `while` *循环退出，程序终止* 3*。*
- en: Interactive tools can help your workflow operate more smoothly. For example,
    you can build testing tools that will let you choose how to proceed based on preliminary
    results.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式工具可以帮助你的工作流程更顺畅。例如，你可以构建测试工具，让你根据初步结果选择如何继续进行。
- en: Using Special Variables and Characters
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用特殊变量和字符
- en: You’re now equipped with enough bash knowledge to build many versatile tools.
    This section offers more tips that concern the particularities of shell scripts.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经掌握了足够的bash知识，可以构建许多多功能的工具。本节提供了一些关于Shell脚本特性的小贴士。
- en: 'In Unix, commands return `0` on success and a positive integer on failure.
    The variable `$?` contains the exit value of the last command executed. You can
    use these to test for execution successes and failures:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix中，命令成功时返回`0`，失败时返回一个正整数。变量`$?`包含上一个执行命令的退出值。你可以使用这些值来测试执行的成功与失败：
- en: '[PRE83]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Another special variable is `$$`, which contains the current process’s ID. This
    is useful when you need to create temporary files for the script. If you have
    multiple instances of the same script or program running at the same time, each
    might need its own temporary files. In this case, you can create temporary files
    named */tmp/script_name_$$* for every one of them.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特殊变量是`$$`，它包含当前进程的ID。当你需要为脚本创建临时文件时，这很有用。如果你有多个相同脚本或程序的实例同时运行，每个实例可能都需要自己的临时文件。在这种情况下，你可以为每个实例创建名为`/tmp/script_name_$$`的临时文件。
- en: 'Remember that we talked about variable scopes in shell scripts earlier in this
    chapter? Variables that aren’t input parameters are global to the entire script.
    If you want other programs to use the variable as well, you need to export the
    variable:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在本章早些时候谈到的 shell 脚本中的变量作用域吗？那些不是输入参数的变量对整个脚本是全局的。如果你希望其他程序也能使用这个变量，你需要导出这个变量：
- en: '[PRE84]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let’s say that in one of your scripts you set the variable `VAR`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在你的一个脚本中你设置了变量`VAR`：
- en: '[PRE85]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If you don’t export it or source it in another script, the value gets destroyed
    after the script exits. But if you export `VAR` in the first script and run that
    script before running a second script, the second script will be able to read
    `VAR`’s value.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不导出它或在另一个脚本中引用它，值将在脚本退出后被销毁。但是，如果你在第一个脚本中导出了`VAR`并在运行第二个脚本之前运行了第一个脚本，那么第二个脚本将能够读取`VAR`的值。
- en: 'You should also be aware of special characters in bash. In Unix, the wildcard
    character `*` stands for *all*. For example, this command will print out all the
    filenames in the current directory that have the file extension *.txt*:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意 Bash 中的特殊字符。在 Unix 中，通配符字符`*`表示*所有*。例如，以下命令将打印当前目录下所有扩展名为*.txt*的文件名：
- en: '[PRE86]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Backticks (`` ` ``) indicate command substitution. You can use both backticks
    and the `$()` command substitution syntax mentioned earlier for the same purpose.
    This `echo` command will print the output of the `whoami` command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号（`` ` ``）表示命令替换。你可以使用反引号和前面提到的`$()`命令替换语法来实现相同的目的。这个`echo`命令将打印`whoami`命令的输出：
- en: '[PRE87]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Most special characters, like the wildcard character or the single quote, aren’t
    interpreted as special when they are placed in double quotes. Instead, they’re
    treated as part of a string. For example, this command will echo the string `"abc
    ''*'' 123"`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数特殊字符，如通配符或单引号，在放入双引号中时不会被解释为特殊字符。相反，它们会被视为字符串的一部分。例如，以下命令将回显字符串`"abc '*'
    123"`：
- en: '[PRE88]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Another important special character is the backslash (`\`), the escape character
    in bash. It tells bash that a certain character should be interpreted literally,
    and not as a special character.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的特殊字符是反斜杠（`\`），它是 Bash 中的转义字符。它告诉 Bash 某个字符应被字面解释，而不是作为特殊字符。
- en: 'Certain special characters, like double quotes, dollar sign, backticks, and
    backslashes remain special even within double quotes, so if you want bash to treat
    them literally, you have to escape them by using a backslash:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 某些特殊字符，如双引号、美元符号、反引号和反斜杠，即使在双引号内依然是特殊字符，因此如果你希望 Bash 将它们视为字面意义，你必须通过反斜杠来转义它们：
- en: '[PRE89]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This command will echo:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将回显：
- en: '[PRE90]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: You can also use a backslash before a newline to indicate that the line of code
    has not ended. For example, this command
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在换行符前使用反斜杠，表示代码行尚未结束。例如，以下命令
- en: '[PRE91]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'is the same as this one:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这与下面的命令是相同的：
- en: '[PRE92]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Congratulations! You can now write bash scripts. Bash scripting may seem scary
    at first, but once you’ve mastered it, it will be a powerful addition to your
    hacking arsenal. You’ll be able to perform better recon, conduct more efficient
    testing, and have a more structured hacking workflow.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在可以编写 bash 脚本了。刚开始学习 Bash 脚本可能会觉得很吓人，但一旦掌握了它，它将成为你黑客武器库中的一个强大工具。你将能够执行更好的侦查工作，进行更高效的测试，并拥有更加结构化的黑客工作流程。
- en: If you plan on implementing a lot of automation, it’s a good idea to start organizing
    your scripts from the start. Set up a directory of scripts and sort your scripts
    by their functionality. This will become the start of developing your own hacking
    methodology. When you’ve collected a handful of scripts that you use on a regular
    basis, you can use scripts to run them automatically. For example, you might categorize
    your scripts into recon scripts, fuzzing scripts, automated reporting, and so
    on. This way, every time you find a script or tool you like, you can quickly incorporate
    it into your workflow in an organized fashion.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算实现大量自动化，最好从一开始就开始组织你的脚本。建立一个脚本目录，并按功能对脚本进行分类。这将成为你开发自己黑客方法论的起点。当你收集了一些常用脚本时，你可以使用脚本自动运行它们。例如，你可以将脚本分为侦查脚本、模糊测试脚本、自动化报告等。这样，每次你发现喜欢的脚本或工具时，就可以迅速将它们有序地整合到你的工作流程中。
- en: Scheduling Automatic Scans
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定时自动扫描
- en: Now let’s take your automation to the next level by building an alert system
    that will let us know if something interesting turns up in our scans. This saves
    us from having to run the commands manually and comb through the results over
    and over again.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将你的自动化提升到一个新的层次，通过构建一个警报系统，在扫描中发现有趣内容时及时通知我们。这将节省我们手动运行命令并反复检查结果的时间。
- en: We can use cron jobs to schedule our scans. *Cron* is a job scheduler on Unix-based
    operating systems. It allows you to schedule jobs to run periodically. For example,
    you can run a script that checks for new endpoints on a particular site every
    day at the same time. Or you can run a scanner that checks for vulnerabilities
    on the same target every day. This way, you can monitor for changes in an application’s
    behavior and find ways to exploit it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 cron 作业来安排我们的扫描。*Cron* 是一种基于 Unix 的操作系统上的作业调度器。它允许你安排作业定期运行。例如，你可以每天在同一时间运行一个检查特定网站新端点的脚本，或者每天运行一个扫描器检查相同目标上的漏洞。通过这种方式，你可以监控应用程序行为的变化，并找到可能的利用方式。
- en: 'You can configure Cron’s behavior by editing files called *crontabs*. Unix
    keeps different copies of crontabs for each user. Edit your own user’s crontab
    by running the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编辑名为 *crontab* 的文件来配置 Cron 的行为。Unix 为每个用户保留不同的 crontab 副本。通过运行以下命令来编辑你自己用户的
    crontab：
- en: '[PRE93]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'All crontabs follow this same syntax:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 crontab 都遵循相同的语法：
- en: '[PRE94]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Each line specifies a command to be run and the time at which it should run,
    using five numbers. The first number, from 0 to 59, specifies the minute when
    the command should run. The second number specifies the hour, and ranges from
    0 to 23\. The third and fourth numbers are the day and month the command should
    run. And the last number is the weekday when the command should run, which ranges
    from 0 to 7\. Both 0 and 7 mean that the command should run on Sundays; 1 means
    the command should run on Mondays; and so on.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都指定了一个命令以及它应该运行的时间，使用五个数字。第一个数字，范围从 0 到 59，指定命令应该运行的分钟。第二个数字指定小时，范围从 0 到
    23。第三个和第四个数字分别是命令应该运行的日期和月份。最后一个数字是命令应该运行的星期几，范围从 0 到 7。0 和 7 都表示命令应该在星期日运行；1
    表示命令应该在星期一运行，以此类推。
- en: 'For example, you can add this line to your crontab to run your recon script
    every day at 9:30 PM:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将这行添加到你的 crontab 中，每天晚上 9:30 运行你的侦查脚本：
- en: '[PRE95]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You can also batch-run the scripts within directories. The `run-parts` command
    in crontabs tells Cron to run all the scripts stored in a directory. For example,
    you can store all your recon tools in a directory and scan your targets periodically.
    The following line tells Cron to run all scripts in my security directory every
    day at 9:30 PM:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以批量运行目录中的脚本。crontab 中的 `run-parts` 命令告诉 Cron 运行存储在目录中的所有脚本。例如，你可以将所有的侦查工具存储在一个目录中，并定期扫描你的目标。以下行告诉
    Cron 每天晚上 9:30 运行我安全目录中的所有脚本：
- en: '[PRE96]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Next, `git diff` is a command that outputs the difference between two files.
    You need to install the Git program to use it. You can use `git diff` to compare
    scan results at different times, which quickly lets you see if the target has
    changed since you last scanned it:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`git diff` 是一个输出两个文件之间差异的命令。你需要安装 Git 程序才能使用它。你可以使用 `git diff` 来比较不同时间的扫描结果，这样你就能快速看到自上次扫描以来目标是否发生了变化：
- en: '[PRE97]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This will help you identify any new domains, subdomains, endpoints, and other
    new assets of a target. You could write a script like this to notify you of new
    changes on a target every day:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助你识别目标的新域名、子域名、端点和其他新资源。你可以编写类似这样的脚本，每天通知你目标上的新变化：
- en: '[PRE98]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'And schedule it with Cron:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 Cron 来安排它：
- en: '[PRE99]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: These automation techniques have helped me quickly find new JavaScript files,
    endpoints, and functionalities on targets. I especially like to use this technique
    to discover subdomain takeover vulnerabilities automatically. We’ll talk about
    subdomain takeovers in Chapter 20.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自动化技术帮助我快速找到目标上的新 JavaScript 文件、端点和功能。我特别喜欢用这种技术自动发现子域接管漏洞。我们将在第 20 章讨论子域接管。
- en: 'Alternatively, you can use GitHub to track changes. Set up a repository to
    store your scan results at [https://github.com/new/](https://github.com/new/).
    GitHub has a Notification feature that will tell you when significant events on
    a repository occur. It’s located at Settings▶Notifications on each repository’s
    page. Provide GitHub with an email address that it will use to notify you about
    changes. Then, in the directory where you store scan results, run these commands
    to initiate `git` inside the directory:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用 GitHub 来跟踪变化。设置一个仓库，将你的扫描结果存储在 [https://github.com/new/](https://github.com/new/)
    上。GitHub 有一个通知功能，它会告诉你仓库中的重要事件发生时。这个功能位于每个仓库页面的 Settings▶Notifications。提供一个电子邮件地址，GitHub
    会用它来通知你有关更改的内容。然后，在存储扫描结果的目录中，运行以下命令以在该目录中启动 `git`：
- en: '[PRE100]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Lastly, use Cron to scan the target and upload the files to GitHub periodically:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 Cron 定期扫描目标并将文件上传到 GitHub：
- en: '[PRE101]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: GitHub will then send you an email about the files that changed during the new
    scan.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 会向你发送一封电子邮件，通知你在新的扫描过程中发生了哪些文件变化。
- en: A Note on Recon APIs
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 Recon API 的说明
- en: Many of the tools mentioned in this chapter have APIs that allow you to integrate
    their services into your applications and scripts. We’ll talk about APIs more
    in Chapter 24, but for now, you can think of APIs as endpoints you can use to
    query a service’s database. Using these APIs, you can query recon tools from your
    script and add the results to your recon report without visiting their sites manually.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提到的许多工具都提供 API，允许你将其服务集成到你的应用程序和脚本中。我们将在第 24 章详细讨论 API，但现在你可以把 API 想象成可以用来查询服务数据库的端点。通过使用这些
    API，你可以从脚本中查询侦察工具并将结果添加到你的侦察报告中，而无需手动访问它们的网站。
- en: 'For example, Shodan has an API ([https://developer.shodan.io/](https://developer.shodan.io/)*)*
    that allows you to query its database. You can access a host’s scan results by
    accessing this URL: *https://api.shodan.io/shodan/host/{ip}?key={YOUR_API_KEY}*.
    You could configure your bash script to send requests to this URL and parse the
    results*.* LinkedIn also has an API ([https://www.linkedin.com/developers/](https://www.linkedin.com/developers/))
    that lets you query its database. For example, you can use this URL to access
    information about a user on LinkedIn: *https://api.linkedin.com/v2/people/{PERSON
    ID}.* The Censys API ([https://censys.io/api](https://censys.io/api)) allows you
    to access certificates by querying the endpoint *https://censys.io/api/v1*.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Shodan 有一个 API（[https://developer.shodan.io/](https://developer.shodan.io/)），允许你查询其数据库。你可以通过访问以下
    URL 获取主机的扫描结果：*https://api.shodan.io/shodan/host/{ip}?key={YOUR_API_KEY}*。你可以配置你的
    bash 脚本，将请求发送到该 URL 并解析结果。LinkedIn 也有一个 API（[https://www.linkedin.com/developers/](https://www.linkedin.com/developers/)），允许你查询其数据库。例如，你可以使用此
    URL 来获取 LinkedIn 上某个用户的信息：*https://api.linkedin.com/v2/people/{PERSON ID}*。Censys
    API（[https://censys.io/api](https://censys.io/api)）允许你通过查询端点 *https://censys.io/api/v1*
    来访问证书。
- en: Other tools mentioned in this chapter, like BuiltWith, Google search, and GitHub
    search, all have their own API services. These APIs can help you discover assets
    and content more efficiently by integrating third-party tools into your recon
    script. Note that most API services require you to create an account on their
    website to obtain an *API key*, which is how most API services authenticate their
    users. You can find information about how to obtain the API keys of popular recon
    services at [https://github.com/lanmaster53/recon-ng-marketplace/wiki/API-Keys/](https://github.com/lanmaster53/recon-ng-marketplace/wiki/API-Keys/).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提到的其他工具，如 BuiltWith、Google 搜索和 GitHub 搜索，都有自己的 API 服务。这些 API 可以帮助你通过将第三方工具集成到侦察脚本中，更高效地发现资产和内容。请注意，大多数
    API 服务要求你在其网站上创建一个账户，以获取 *API 密钥*，这是大多数 API 服务验证用户身份的方式。你可以在 [https://github.com/lanmaster53/recon-ng-marketplace/wiki/API-Keys/](https://github.com/lanmaster53/recon-ng-marketplace/wiki/API-Keys/)
    找到关于如何获取流行侦察服务的 API 密钥的信息。
- en: Start Hacking!
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始黑客攻击吧！
- en: Now that you’ve conducted extensive reconnaissance, what should you do with
    the data you’ve collected? Plan your attacks by using the information you’ve gathered!
    Prioritize your tests based on the functionality of the application and its technology.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经进行了广泛的侦察，那么接下来应该如何处理你收集的数据呢？利用你所收集的信息来规划你的攻击！根据应用程序的功能和技术优先安排你的测试。
- en: For example, if you find a feature that processes credit card numbers, you could
    first look for vulnerabilities that might leak the credit card numbers, such as
    IDORs (Chapter 10). Focus on sensitive features such as credit cards and passwords,
    because these features are more likely to contain critical vulnerabilities. During
    your recon, you should be able to get a good idea of what the company cares about
    and the sensitive data it’s protecting. Go after those specific pieces of information
    throughout your bug-hunting process to maximize the business impact of the issues
    you discover. You can also focus your search on bugs or vulnerabilities that affect
    that particular tech stack you uncovered, or on elements of the source code you
    were able to find.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你发现一个处理信用卡号码的功能，你可以首先寻找可能泄露信用卡号码的漏洞，比如 IDOR（第10章）。专注于敏感功能，如信用卡和密码，因为这些功能更可能包含关键漏洞。在你的侦察过程中，你应该能够大致了解公司关心什么以及它在保护什么敏感数据。在整个漏洞狩猎过程中，针对这些特定的信息进行攻击，以最大化你发现问题的商业影响。你还可以将搜索集中在影响你发现的特定技术栈的漏洞或错误上，或者集中在你能够找到的源代码元素上。
- en: And don’t forget, recon isn’t a one-time activity. You should continue to monitor
    your targets for changes. Organizations modify their system, technologies, and
    codebase constantly, so continuous recon will ensure that you always know what
    the attack surface looks like. Using a combination of bash, scheduling tools,
    and alerting tools, build a recon engine that does most of the work for you.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 而且别忘了，侦察不是一次性的活动。你应该继续监控你的目标，关注它们的变化。组织不断修改他们的系统、技术和代码库，因此持续的侦察可以确保你始终了解攻击面是什么样的。通过结合使用
    bash、调度工具和警报工具，建立一个侦察引擎，让它为你完成大部分工作。
- en: Tools Mentioned in This Chapter
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本章提到的工具
- en: In this chapter, I introduced many tools you can use in your recon process.
    Many more good tools are out there. The ones mentioned here are merely my personal
    preferences. I’ve included them here in chronological order for your reference.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了许多你可以在侦察过程中使用的工具。还有许多其他优秀的工具。这里提到的只是我个人的偏好。我已按时间顺序将它们列出，供你参考。
- en: Be sure to learn about how these tools work before you use them! Understanding
    the software you use allows you to customize it to fit your workflow.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些工具之前，一定要了解它们是如何工作的！理解你使用的软件可以让你根据自己的工作流程定制它。
- en: Scope Discovery
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围发现
- en: WHOIS looks for the owner of a domain or IP.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WHOIS 查找域名或 IP 的所有者。
- en: ViewDNS.info reverse WHOIS ([https://viewdns.info/reversewhois/](https://viewdns.info/reversewhois/))
    is a tool that searches for reverse WHOIS data by using a keyword.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ViewDNS.info 反向 WHOIS ([https://viewdns.info/reversewhois/](https://viewdns.info/reversewhois/))
    是一个通过使用关键词搜索反向 WHOIS 数据的工具。
- en: '`nslookup` queries internet name servers for IP information about a host.'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nslookup` 查询互联网域名服务器以获取有关主机的 IP 信息。'
- en: ViewDNS reverse IP ([https://viewdns.info/reverseip/](https://viewdns.info/reverseip/))
    looks for domains hosted on the same server, given an IP or domain.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ViewDNS 反向 IP ([https://viewdns.info/reverseip/](https://viewdns.info/reverseip/))
    根据 IP 或域名查找托管在同一服务器上的域名。
- en: crt.sh ([https://crt.sh/](https://crt.sh/)), Censys ([https://censys.io/](https://censys.io/)),
    and Cert Spotter ([https://sslmate.com/certspotter/](https://sslmate.com/certspotter/))
    are platforms you can use to find certificate information about a domain.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: crt.sh ([https://crt.sh/](https://crt.sh/))、Censys ([https://censys.io/](https://censys.io/))
    和 Cert Spotter ([https://sslmate.com/certspotter/](https://sslmate.com/certspotter/))
    是你可以用来查找域名证书信息的平台。
- en: Sublist3r ([https://github.com/aboul3la/Sublist3r/](https://github.com/aboul3la/Sublist3r/)),
    SubBrute ([https://github.com/TheRook/subbrute/](https://github.com/TheRook/subbrute/)),
    Amass ([https://github.com/OWASP/Amass/](https://github.com/OWASP/Amass/)), and
    Gobuster ([https://github.com/OJ/gobuster/](https://github.com/OJ/gobuster/))
    enumerate subdomains.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sublist3r ([https://github.com/aboul3la/Sublist3r/](https://github.com/aboul3la/Sublist3r/))、SubBrute
    ([https://github.com/TheRook/subbrute/](https://github.com/TheRook/subbrute/))、Amass
    ([https://github.com/OWASP/Amass/](https://github.com/OWASP/Amass/)) 和 Gobuster
    ([https://github.com/OJ/gobuster/](https://github.com/OJ/gobuster/)) 用于枚举子域名。
- en: Daniel Miessler’s SecLists ([https://github.com/danielmiessler/SecLists/](https://github.com/danielmiessler/SecLists/))
    is a list of keywords that can be used during various phases of recon and hacking.
    For example, it contains lists that can be used to brute-force subdomains and
    filepaths.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Daniel Miessler 的 SecLists ([https://github.com/danielmiessler/SecLists/](https://github.com/danielmiessler/SecLists/))
    是一个在侦察和黑客攻击的各个阶段中可以使用的关键词列表。例如，它包含可以用来暴力破解子域名和文件路径的列表。
- en: Commonspeak2 ([https://github.com/assetnote/commonspeak2/](https://github.com/assetnote/commonspeak2/))
    generates lists that can be used to brute-force subdomains and filepaths using
    publicly available data.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Commonspeak2 ([https://github.com/assetnote/commonspeak2/](https://github.com/assetnote/commonspeak2/))生成的列表可以用于利用公开数据进行子域名和文件路径的暴力破解。
- en: Altdns ([https://github.com/infosec-au/altdns](https://github.com/infosec-au/altdns))
    brute-forces subdomains by using permutations of common subdomain names.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Altdns ([https://github.com/infosec-au/altdns](https://github.com/infosec-au/altdns))通过使用常见子域名的排列组合进行子域名暴力破解。
- en: Nmap ([https://nmap.org/](https://nmap.org/)) and Masscan ([https://github.com/robertdavidgraham/masscan/](https://github.com/robertdavidgraham/masscan/))
    scan the target for open ports.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Nmap ([https://nmap.org/](https://nmap.org/))和Masscan ([https://github.com/robertdavidgraham/masscan/](https://github.com/robertdavidgraham/masscan/))扫描目标的开放端口。
- en: Shodan ([https://www.shodan.io/](https://www.shodan.io/)), Censys ([https://censys.io/](https://censys.io/)),
    and Project Sonar ([https://www.rapid7.com/research/project-sonar/](https://www.rapid7.com/research/project-sonar/))
    can be used to find services on targets without actively scanning them.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shodan ([https://www.shodan.io/](https://www.shodan.io/))、Censys ([https://censys.io/](https://censys.io/))和Project
    Sonar ([https://www.rapid7.com/research/project-sonar/](https://www.rapid7.com/research/project-sonar/))可以用来查找目标的服务，而无需主动扫描。
- en: Dirsearch ([https://github.com/maurosoria/dirsearch/](https://github.com/maurosoria/dirsearch/))
    and Gobuster ([https://github.com/OJ/gobuster](https://github.com/OJ/gobuster))
    are directory brute-forcers used to find hidden filepaths.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dirsearch ([https://github.com/maurosoria/dirsearch/](https://github.com/maurosoria/dirsearch/))和Gobuster
    ([https://github.com/OJ/gobuster](https://github.com/OJ/gobuster))是用于发现隐藏文件路径的目录暴力破解工具。
- en: EyeWitness ([https://github.com/FortyNorthSecurity/EyeWitness/](https://github.com/FortyNorthSecurity/EyeWitness/))
    and Snapper ([https://github.com/dxa4481/Snapper/](https://github.com/dxa4481/Snapper/))
    grab screenshots of a list of URLs. They can be used to quickly scan for interesting
    pages among a list of enumerated paths.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EyeWitness ([https://github.com/FortyNorthSecurity/EyeWitness/](https://github.com/FortyNorthSecurity/EyeWitness/))和Snapper
    ([https://github.com/dxa4481/Snapper/](https://github.com/dxa4481/Snapper/))能够抓取一系列URL的截图，可以用来快速扫描在枚举路径中有趣的页面。
- en: OWASP ZAP ([https://owasp.org/www-project-zap/](https://owasp.org/www-project-zap/))
    is a security tool that includes a scanner, proxy, and much more. Its web spider
    can be used to discover content on a web server.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OWASP ZAP ([https://owasp.org/www-project-zap/](https://owasp.org/www-project-zap/))是一个安全工具，包含了扫描器、代理等多种功能。其网页爬虫可用于发现Web服务器上的内容。
- en: GrayhatWarfare ([https://buckets.grayhatwarfare.com/](https://buckets.grayhatwarfare.com/))
    is an online search engine you can use to find public Amazon S3 buckets.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GrayhatWarfare ([https://buckets.grayhatwarfare.com/](https://buckets.grayhatwarfare.com/))是一个在线搜索引擎，您可以使用它查找公开的Amazon
    S3桶。
- en: Lazys3 ([https://github.com/nahamsec/lazys3/](https://github.com/nahamsec/lazys3/))
    and Bucket Stream ([https://github.com/eth0izzle/bucket-stream/](https://github.com/eth0izzle/bucket-stream/))
    brute-force buckets by using keywords.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lazys3 ([https://github.com/nahamsec/lazys3/](https://github.com/nahamsec/lazys3/))和Bucket
    Stream ([https://github.com/eth0izzle/bucket-stream/](https://github.com/eth0izzle/bucket-stream/))通过使用关键词进行桶的暴力破解。
- en: OSINT
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OSINT
- en: The Google Hacking Database ([https://www.exploit-db.com/google-hacking-database/](https://www.exploit-db.com/google-hacking-database/))
    contains useful Google search terms that frequently reveal vulnerabilities or
    sensitive files.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google Hacking数据库([https://www.exploit-db.com/google-hacking-database/](https://www.exploit-db.com/google-hacking-database/))包含了常用的Google搜索词，这些搜索词常常能揭示漏洞或敏感文件。
- en: KeyHacks ([https://github.com/streaak/keyhacks/](https://github.com/streaak/keyhacks/))
    helps you determine whether a set of credentials is valid and learn how to use
    them to access the target’s services.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: KeyHacks ([https://github.com/streaak/keyhacks/](https://github.com/streaak/keyhacks/))帮助您确定一组凭证是否有效，并学习如何使用它们访问目标服务。
- en: Gitrob ([https://github.com/michenriksen/gitrob/](https://github.com/michenriksen/gitrob/))
    finds potentially sensitive files that are pushed to public repositories on GitHub.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gitrob ([https://github.com/michenriksen/gitrob/](https://github.com/michenriksen/gitrob/))用于查找可能被推送到GitHub公开仓库中的敏感文件。
- en: TruffleHog ([https://github.com/trufflesecurity/truffleHog/](https://github.com/trufflesecurity/truffleHog/))
    specializes in finding secrets in public GitHub repositories by searching for
    string patterns and high-entropy strings.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TruffleHog ([https://github.com/trufflesecurity/truffleHog/](https://github.com/trufflesecurity/truffleHog/))专门通过搜索字符串模式和高熵字符串，在公开的GitHub仓库中查找密钥。
- en: PasteHunter ([https://github.com/kevthehermit/PasteHunter/](https://github.com/kevthehermit/PasteHunter/))
    scans online paste sites for sensitive information.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PasteHunter ([https://github.com/kevthehermit/PasteHunter/](https://github.com/kevthehermit/PasteHunter/))
    扫描在线粘贴站点以查找敏感信息。
- en: Wayback Machine ([https://archive.org/web/](https://archive.org/web/)) is a
    digital archive of internet content. You can use it to find old versions of sites
    and their files.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Wayback Machine ([https://archive.org/web/](https://archive.org/web/)) 是一个互联网内容的数字档案库。你可以使用它查找网站及其文件的旧版本。
- en: Waybackurls ([https://github.com/tomnomnom/waybackurls/](https://github.com/tomnomnom/waybackurls/))
    fetches URLs from the Wayback Machine.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Waybackurls ([https://github.com/tomnomnom/waybackurls/](https://github.com/tomnomnom/waybackurls/))
    从 Wayback Machine 获取 URL。
- en: Tech Stack Fingerprinting
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技术栈指纹识别
- en: The CVE database ([https://cve.mitre.org/cve/search_cve_list.html](https://cve.mitre.org/cve/search_cve_list.html))
    contains publicly disclosed vulnerabilities. You can use its website to search
    for vulnerabilities that might affect your target.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CVE 数据库 ([https://cve.mitre.org/cve/search_cve_list.html](https://cve.mitre.org/cve/search_cve_list.html))
    包含了公开披露的漏洞。你可以使用其网站来搜索可能影响目标的漏洞。
- en: Wappalyzer ([https://www.wappalyzer.com/](https://www.wappalyzer.com/)) identifies
    content management systems, frameworks, and programming languages used on a site.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Wappalyzer ([https://www.wappalyzer.com/](https://www.wappalyzer.com/)) 能识别网站上使用的内容管理系统、框架和编程语言。
- en: BuiltWith ([https://builtwith.com/](https://builtwith.com/)) is a website that
    shows you which web technologies a website is built with.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BuiltWith ([https://builtwith.com/](https://builtwith.com/)) 是一个展示网站使用哪些 web
    技术的网站。
- en: StackShare ([https://stackshare.io/](https://stackshare.io/)) is an online platform
    that allows developers to share the tech they use. You can use it to collect information
    about your target.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: StackShare ([https://stackshare.io/](https://stackshare.io/)) 是一个在线平台，允许开发者分享他们使用的技术。你可以用它收集关于目标的信息。
- en: Retire.js ([https://retirejs.github.io/retire.js/](https://retirejs.github.io/retire.js/))
    detects outdated JavaScript libraries and Node.js packages.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Retire.js ([https://retirejs.github.io/retire.js/](https://retirejs.github.io/retire.js/))
    检测过时的 JavaScript 库和 Node.js 包。
- en: Automation
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化
- en: Git ([https://git-scm.com/](https://git-scm.com/)) is an open sourced version-control
    system. You can use its `git diff` command to keep track of file changes.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Git ([https://git-scm.com/](https://git-scm.com/)) 是一个开源的版本控制系统。你可以使用其 `git
    diff` 命令来跟踪文件的更改。
- en: You should now have a solid understanding of how to conduct reconnaissance on
    a target. Remember to keep extensive notes throughout your recon process, as the
    information you collect can really balloon over time. Once you have a solid understanding
    of how to conduct recon on a target, you can try to leverage recon platforms like
    Nuclei ([https://github.com/projectdiscovery/nuclei/](https://github.com/projectdiscovery/nuclei/))
    or Intrigue Core ([https://github.com/intrigueio/intrigue-core/](https://github.com/intrigueio/intrigue-core/))
    to make your recon process more efficient. But when you’re starting out, I recommend
    that you do recon manually with individual tools or write your own automated recon
    scripts to learn about the process.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对如何对目标进行侦察有了扎实的理解。记得在整个侦察过程中保持详细的笔记，因为你收集的信息随着时间的推移可能会大幅增加。一旦你对如何对目标进行侦察有了全面的理解，你可以尝试利用像
    Nuclei ([https://github.com/projectdiscovery/nuclei/](https://github.com/projectdiscovery/nuclei/))
    或 Intrigue Core ([https://github.com/intrigueio/intrigue-core/](https://github.com/intrigueio/intrigue-core/))
    这样的侦察平台，使侦察过程更加高效。但在刚开始时，我建议你使用单个工具进行手动侦察，或者编写自己的自动化侦察脚本来了解这个过程。
