["```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n UIKit\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n SpriteKit\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass Skater: SKSpriteNode {\n\n ➊\n var\n velocity = CGPoint\n .zero\n\n ➋\n var\n minimumY: CGFloat\n = 0.0\n\n ➌\n var\n jumpSpeed: CGFloat\n = 20.0\n\n ➍\n var\n isOnGround = true\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport SpriteKit\n\nclass GameScene: SKScene {\n\n    // The hero of the game, the skater, is created here\n\n    let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n    override func didMove(to view: SKView) {\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n  override func didMove(to view: SKView) {\n\n  --\n *snip* \n --\n\n  }\n\n  func\n resetSkater() {\n\n      // Set the skater's starting position, zPosition, and minimumY\n\n   ➊\n let\n skaterX = frame\n .midX\n / 2.0\n\n   ➋\n let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n   ➌\n skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n   ➍\n skater\n .zPosition\n = 10\n\n   ➎\n skater\n .minimumY\n = skaterY\n\n  }\n\n  override func update(_ currentTime: TimeInterval) {\n\n      // Called before each frame is rendered\n\n  }\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    // Set up the skater and add her to the scene\n\n    resetSkater\n ()\n\n    addChild\n (skater\n )\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nimport\n SpriteKit\n\nclass\n GameScene: SKScene\n {\n\n   // The hero of the game, the skater, is created here\n\n   let\n skater = Skater\n (imageNamed: \"skater\"\n )\n\n   override\n func\n didMove(to view: SKView\n ) {\n\n       anchorPoint\n = CGPoint\n .zero\n\n       let\n background = SKSpriteNode\n (imageNamed: \"background\"\n )\n\n       let\n xMid = frame\n .midX\n\n       let\n yMid = frame\n .midY\n\n       background.position\n = CGPoint\n (x: xMid, y: yMid)\n\n       addChild\n (background)\n\n       // Set up the skater and add her to the scene\n\n       resetSkater\n ()\n\n       addChild\n (skater\n )\n\n   }\n\n   func\n resetSkater() {\n\n       // Set the skater's starting position, zPosition, and minimumY\n\n       let\n skaterX = frame\n .midX\n / 2.0\n\n       let\n skaterY = skater\n .frame\n .height\n / 2.0\n + 64.0\n\n       skater\n .position\n = CGPoint\n (x: skaterX, y: skaterY)\n\n       skater\n .zPosition\n = 10\n\n       skater\n .minimumY\n = skaterY\n\n   }\n\n   override\n func\n update(_\n currentTime: TimeInterval\n ) {\n\n       // Called before each frame is rendered\n\n   }\n\n}\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    // An array that holds all the current sidewalk bricks\n\n    var\n bricks = [SKSpriteNode\n ]()\n\n    // The hero of the game, the skater, is created here\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nclass GameScene: SKScene {\n\n    --\n *snip* \n --\n\n    var bricks = [SKSpriteNode]()\n\n    // The size of the sidewalk brick graphics used\n\n    var\n brickSize = CGSize\n .zero\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n    --\n *snip* \n --\n\n    var brickSize = CGSize.zero\n\n    // Setting for how fast the game is scrolling to the right\n\n    // This may increase as the user progresses in the game\n\n    var\n scrollSpeed: CGFloat\n = 5.0\n\n    // The hero of the game, the skater, is created here\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n➊\n func\n spawnBrick(atPosition position: CGPoint\n ) -> SKSpriteNode\n {\n\n      // Create a brick sprite and add it to the scene\n\n    ➋\n let\n brick = SKSpriteNode\n (imageNamed: \"sidewalk\"\n )\n\n    ➌\n brick.position\n = position\n\n    ➍\n brick.zPosition\n = 8\n\n    ➎\n addChild\n (brick)\n\n      // Update our brickSize with the real brick size\n\n    ➏\n brickSize\n = brick.size\n\n      // Add the new brick to the array of bricks\n\n    ➐\n bricks\n .append\n (brick)\n\n      // Return this new brick to the caller\n\n    ➑\n return\n brick\n\n  }\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc\n updateBricks(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n}\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    // Keep track of the greatest x-position of all the current bricks\n\n    var\n farthestRightBrickX: CGFloat\n = 0.0\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    var farthestRightBrickX: CGFloat = 0.0\n\n ➊\n for\n brick in\n bricks\n {\n\n    ➋\n let\n newX = brick.position\n .x\n - currentScrollAmount\n\n      // If a brick has moved too far left (off the screen), remove it\n\n    ➌\n if\n newX < -brickSize\n .width\n {\n\n       ➍\n brick.removeFromParent\n ()\n\n       ➎\n if\n let\n brickIndex = bricks\n .index\n (of:\n brick) {\n\n          ➏\n bricks\n .remove\n (at:\n brickIndex)\n\n         }\n\n    ➐\n } else\n {\n\n          // For a brick that is still onscreen, update its position\n\n        ➑\n brick.position\n = CGPoint\n (x:\n newX, y:\n brick.position\n .y\n )\n\n          // Update our farthest-right position tracker\n\n        ➒\n if\n brick.position\n .x\n > farthestRightBrickX {\n\n           ➓\n farthestRightBrickX = brick.position\n .x\n\n          }\n\n       }\n\n     }\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    for brick in bricks {\n\n        --\n *snip* \n --\n\n    }\n\n    // A while loop to ensure our screen is always full of bricks\n\n ➊\n while\n farthestRightBrickX < frame\n .width\n {\n\n    ➋\n var\n brickX = farthestRightBrickX + brickSize\n .width\n + 1.0\n\n    ➌\n let\n brickY = brickSize\n .height\n / 2.0\n\n   }\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n     let brickY = brickSize.height / 2.0\n\n     // Every now and then, leave a gap the player must jump over\n\n   ➊\n let\n randomNumber = arc4random_uniform\n (99\n )\n\n   ➋\n if\n randomNumber < 5\n {\n\n        // There is a 5 percent chance that we will\n\n        // leave a gap between bricks\n\n      ➌\n let\n gap = 20.0\n * scrollSpeed\n\n      ➍\n brickX += gap\n\n     }\n\n     // Spawn a new brick and update the rightmost brick\n\n   ➎\n let\n newBrick = spawnBrick\n (atPosition: CGPoint\n (x:\n brickX, y:\n brickY))\n\n   ➏\n farthestRightBrickX = newBrick.position\n .x\n\n  }\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// The timestamp of the last update method call\n\nvar\n lastUpdateTime: TimeInterval\n ?\n\n// The hero of the game, the skater, is created here\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Determine the elapsed time since the last update call\n\n ➊\n var\n elapsedTime: TimeInterval\n = 0.0\n\n ➋\n if\n let\n lastTimeStamp = lastUpdateTime\n {\n\n    ➌\n elapsedTime = currentTime - lastTimeStamp\n\n   }\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n        elapsedTime = currentTime - lastTimeStamp\n\n    }\n\n    lastUpdateTime\n = currentTime\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    lastUpdateTime = currentTime\n\n ➊\n let\n expectedElapsedTime: TimeInterval\n = 1.0\n / 60.0\n\n   // Here we calculate how far everything should move in this update\n\n ➋\n let\n scrollAdjustment = CGFloat\n (elapsedTime / expectedElapsedTime)\n\n ➌\n let\n currentScrollAmount = scrollSpeed\n * scrollAdjustment\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    let currentScrollAmount = scrollSpeed * scrollAdjustment\n\n    updateBricks\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(skater)\n\n    // Add a tap gesture recognizer to know when the user tapped the screen\n\n ➊\n let\n tapMethod = #selector\n (GameScene\n .handleTap\n (tapGesture:))\n\n ➋\n let\n tapGesture = UITapGestureRecognizer\n (target: self\n , action: tapMethod)\n\n ➌\n view.addGestureRecognizer\n (tapGesture)\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n handleTap(tapGesture: UITapGestureRecognizer\n ) {\n\n   // Make the skater jump if player taps while the skater is on the ground\n\n ➊\n if\n skater.isOnGround {\n\n      // Set the skater's y-velocity to the skater's initial jump speed\n\n    ➋\n skater.velocity = CGPoint(x: 0.0\n , y: skater.jumpSpeed)\n\n      // Keep track of the fact that the skater is no longer on the ground\n\n    ➌\n skater.isOnGround = false\n\n  }\n\n}\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nvar scrollSpeed: CGFloat = 5.0\n\n// A constant for gravity, or how fast objects will fall to Earth\n\nlet\n gravitySpeed: CGFloat\n = 1.5\n\n// The timestamp of the last update method call\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc\n updateSkater() {\n\n}\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateSkater() {\n\n ➊\n if\n !skater.isOnGround {\n\n      // Set the skater's new velocity as it is affected by \"gravity\"\n\n    ➋\n let\n velocityY = skater\n .velocity\n .y\n - gravitySpeed\n\n    ➌\n skater\n .velocity\n = CGPoint\n (x: skater\n .velocity\n .x\n , y: velocityY)\n\n      // Set the skater's new y-position based on her velocity\n\n    ➍\n let\n newSkaterY: CGFloat\n = skater\n .position\n .y\n + skater\n .velocity\n .y\n\n    ➎\n skater\n .position\n = CGPoint\n (x: skater\n .position\n .x\n , y: newSkaterY)\n\n   }\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\nfunc updateSkater() {\n\n    --\n *snip* \n --\n\n        skater.position = CGPoint(x: skater.position.x, y: newSkaterY)\n\n        // Check if the skater has landed\n\n     ➊\n if\n skater.position\n .y\n < skater.minimumY {\n\n        ➋\n skater\n .position\n .y\n = skater\n .minimumY\n\n        ➌\n skater\n .velocity\n = CGPoint\n .zero\n\n        ➍\n skater\n .isOnGround\n = true\n\n       }\n\n   }\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```", "```\n  updateBricks(withScrollAmount: currentScrollAmount)\n\n  updateSkater()\n\n}\n\n```"]