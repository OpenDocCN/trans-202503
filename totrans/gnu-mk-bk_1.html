<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;The Basics Revisited"><div class="titlepage"><div><div><h1 class="title"><a id="basics_revisited"/>Chapter 1. The Basics Revisited</h1></div></div></div><p><a id="iddle1247" class="indexterm"/><a id="iddle1299" class="indexterm"/><a id="iddle1506" class="indexterm"/><a id="iddle1586" class="indexterm"/>This chapter covers material that might be considered basic GNU <code class="literal">make</code> knowledge but covers it to highlight commonly misunderstood functionality and clarify some confusing parts of GNU <code class="literal">make</code>. It also covers the differences between GNU <code class="literal">make</code> versions 3.79.1, 3.81, 3.82, and 4.0. If you’re working with a version prior to 3.79.1, you should probably upgrade.</p><p>This chapter is in no way a replacement for the official GNU <code class="literal">make</code> manual (Free Software Foundation, 2004). I highly recommend owning a copy of it. You can also find the manual at <span class="emphasis"><em><a class="ulink" href="http://www.gnu.org/make/manual">http://www.gnu.org/make/manual</a></em></span>.</p><div class="sect1" title="Getting Environment Variables into GNU make"><div class="titlepage"><div><div><h1 class="title"><a id="getting_environment_variables_into_gnu_m"/>Getting Environment Variables into GNU make</h1></div></div></div><p>Any variable set in the environment when GNU <code class="literal">make</code> is started will be available as a GNU <code class="literal">make</code> variable inside the makefile. For example, consider the following simple makefile:</p><a id="pro_id00001"/><pre class="programlisting">$(info $(FOO))</pre><p><a id="iddle1121" class="indexterm"/><a id="iddle1124" class="indexterm"/><a id="iddle1232" class="indexterm"/><a id="iddle1293" class="indexterm"/><a id="iddle1591" class="indexterm"/><a id="iddle1875" class="indexterm"/>If <code class="literal">FOO</code> is set in the environment to <code class="literal">foo</code> when GNU <code class="literal">make</code> is run, this makefile will output <code class="literal">foo</code>, thus verifying that <code class="literal">FOO</code> was indeed set to <code class="literal">foo</code> inside the makefile. You can discover where <code class="literal">FOO</code> got that value by using GNU <code class="literal">make</code>’s <code class="literal">$(origin)</code> function. Try adding to the makefile as follows (the new part is in bold):</p><a id="pro_id00002"/><pre class="programlisting">$(info $(FOO) <span class="strong"><strong>$(origin FOO)</strong></span>)</pre><p>If a variable <code class="literal">FOO</code> is defined in the environment and automatically imported into GNU <code class="literal">make</code>, <code class="literal">$(origin FOO)</code> will have the value <code class="literal">environment</code>. When you run the makefile, it should give the output <code class="literal">foo environment</code>.</p><p>A variable imported from the environment can be overridden inside the makefile. Simply set its value:</p><a id="pro_id00003"/><pre class="programlisting"><span class="strong"><strong>FOO=bar</strong></span>
$(info $(FOO) $(origin FOO))</pre><p>This gives the output <code class="literal">bar file</code>. Notice how the value of <code class="literal">$(origin FOO)</code> has changed from <code class="literal">environment</code> to <code class="literal">file</code>, indicating that the variable got its value inside a makefile.</p><p>It’s possible to prevent a definition in a makefile from overriding the environment by specifying the <code class="literal">-e</code> (or <code class="literal">--environment-overrides</code>) option on the command line of GNU <code class="literal">make</code>. Running the preceding makefile with <code class="literal">FOO</code> set to <code class="literal">foo</code> in the environment and the <code class="literal">-e</code> command line option gives the output <code class="literal">foo environment override</code>. Notice here that <code class="literal">FOO</code> has the value from the environment (<code class="literal">foo</code>) and that the output of <code class="literal">$(origin FOO)</code> has changed to <code class="literal">environment override</code> to inform us that the variable came from the environment, even though it was redefined in the makefile. The word <code class="literal">override</code> appears only if a variable definition was actually overridden; the <code class="literal">$(origin)</code> function simply returns <code class="literal">environment</code> (no <code class="literal">override</code>) if the variable being tested was defined in the environment, but there was no attempt to redefine it in the makefile.</p><p>If all you care about is whether the variable got its value from the environment, then using <code class="literal">$(firstword $(origin VAR))</code> is always guaranteed to return the string <code class="literal">environment</code> if the variable <code class="literal">VAR</code> got its value from the environment, regardless of whether <code class="literal">-e</code> is specified or not.</p><p>Suppose you absolutely want to guarantee that the variable <code class="literal">FOO</code> gets its value inside the makefile, not from the environment. You can do this with the <code class="literal">override</code> directive:</p><a id="pro_id00004"/><pre class="programlisting"><span class="strong"><strong>override</strong></span> FOO=bar
$(info $(FOO) $(origin FOO))</pre><p>This will output <code class="literal">bar override</code> regardless of the value of <code class="literal">FOO</code> in the environment or whether you specify the <code class="literal">-e</code> command line option. Note that <code class="literal">$(origin)</code> tells you this is an override by returning <code class="literal">override</code>.</p><p><a id="iddle1143" class="indexterm"/><a id="iddle1883" class="indexterm"/>The other way to get around <code class="literal">-e</code> and set the value of a variable is by setting it on the GNU <code class="literal">make</code> command line. For example, revert your makefile to the following:</p><a id="pro_id00005"/><pre class="programlisting">FOO=bar
$(info $(FOO) $(origin FOO))</pre><p>Running <code class="literal">FOO=foo make -e FOO=fooey</code> on the command line will output <code class="literal">fooey command line</code>. Here <code class="literal">$(origin FOO)</code> returned <code class="literal">command line</code>. Now try adding the override command back into the makefile:</p><a id="pro_id00006"/><pre class="programlisting"><span class="strong"><strong>override</strong></span>
FOO=bar $(info $(FOO) $(origin FOO))</pre><p>If you run that same command on the command line (<code class="literal">FOO=foo make -e FOO=fooey</code>), now it outputs <code class="literal">bar override</code>.</p><p>Confused? A simple rule exists to help you keep it all straight: the <code class="literal">override</code> directive beats the command line, which beats environment overrides (the <code class="literal">-e</code> option), which beats variables defined in a makefile, which beats the original environment. Alternatively, you can always use <code class="literal">$(origin)</code> to find out what’s going on.</p></div><div class="sect1" title="Setting Variables from Outside the Makefile"><div class="titlepage"><div><div><h1 class="title"><a id="setting_variables_from_outside_the_makef"/>Setting Variables from Outside the Makefile</h1></div></div></div><p>It’s common to have options in a makefile that can be set on the command line when you start a build. For example, you might want to change the type of build being performed or specify a target architecture outside the makefile.</p><p>Perhaps the most common use case is a debug option to specify whether the build should create debuggable or release code. A simple way to handle this is with a makefile variable called <code class="literal">BUILD_DEBUG</code>, which is set to <code class="literal">yes</code> in the makefile and overridden on the command line when building the release version. For example, the makefile might have the line <code class="literal">BUILD_DEBUG := yes</code> somewhere near the start. The <code class="literal">BUILD_DEBUG</code> variable would then be used elsewhere in the makefile to decide how to set compiler debug options. Because <code class="literal">BUILD_DEBUG</code> is set to <code class="literal">yes</code> in the makefile, the default would be to do debug builds. Then, at release time, this default can be overridden from the command line:</p><a id="pro_id00007"/><pre class="programlisting">$ <span class="strong"><strong>make BUILD_DEBUG=no</strong></span></pre><p>Close to release time it might be tempting to set <code class="literal">BUILD_DEBUG</code> to <code class="literal">no</code> in the shell’s startup script (for example, in <code class="literal">.cshrc</code> or <code class="literal">.bashrc</code>) so that all builds are release rather than debug. Unfortunately, this doesn’t work because of how GNU <code class="literal">make</code> inherits variables from the environment and how variables inside a makefile override the environment.</p><p><a id="iddle1037" class="indexterm"/><a id="iddle1122" class="indexterm"/><a id="iddle1147" class="indexterm"/><a id="iddle1233" class="indexterm"/><a id="iddle1702" class="indexterm"/>Consider this simple makefile that prints the value of <code class="literal">BUILD_DEBUG</code>, which has been set to <code class="literal">yes</code> at the start of the makefile:</p><a id="pro_id00008"/><pre class="programlisting">BUILD_DEBUG := yes
.PHONY: all
all: ; @echo BUILD_DEBUG is $(BUILD_DEBUG)</pre><div class="note" title="Note"><h3 class="title"><a id="ch01note01"/>Note</h3><p><span class="emphasis"><em>In this example, the commands associated with the <code class="literal">all</code> target have been placed on the same line as the target name by using a semicolon. The alternative would be:</em></span></p><a id="pro_id00009"/><pre class="programlisting">BUILD_DEBUG := yes
.PHONY: all
all:
→ @echo BUILD_DEBUG is $(BUILD_DEBUG)</pre><p><span class="emphasis"><em>But that requires a tab to start the commands. When the commands fit on a single line, it’s clearer to use the semicolon format available in GNU <code class="literal">make</code>.</em></span></p></div><p>Now try running the makefile three times: once with no options, once setting <code class="literal">BUILD_DEBUG</code> on GNU <code class="literal">make</code>’s command line, and once with <code class="literal">BUILD_DEBUG</code> set in the environment:</p><a id="pro_id00010"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
BUILD_DEBUG is yes
$ <span class="strong"><strong>make BUILD_DEBUG=no</strong></span>
BUILD_DEBUG is no
$ <span class="strong"><strong>export BUILD_DEBUG=no</strong></span>
$ <span class="strong"><strong>make</strong></span>
BUILD_DEBUG is yes</pre><p>The last line shows that variables defined inside a makefile override values in the environment. But note that if <code class="literal">BUILD_DEBUG</code> had not been defined at all in the makefile, it would have been inherited from the environment and imported into the makefile automatically.</p><p>The problem with definitions in a makefile overriding imported environment variables can be <span class="emphasis"><em>solved</em></span> with a GNU <code class="literal">make</code> hammer: the <code class="literal">-e</code> switch, which makes the environment take precedence. But that affects <span class="emphasis"><em>every</em></span> variable.</p><a id="pro_id00011"/><pre class="programlisting">$ <span class="strong"><strong>export BUILD_DEBUG=no</strong></span>
$ <span class="strong"><strong>make</strong></span>
BUILD_DEBUG is yes
$ <span class="strong"><strong>make -e</strong></span>
BUILD_DEBUG is no
$ <span class="strong"><strong>make -e BUILD_DEBUG=maybe</strong></span>
BUILD_DEBUG is maybe</pre><p><a id="iddle1034" class="indexterm"/><a id="iddle1144" class="indexterm"/><a id="iddle1242" class="indexterm"/><a id="iddle1419" class="indexterm"/><a id="iddle1554" class="indexterm"/><a id="iddle1566" class="indexterm"/><a id="iddle1865" class="indexterm"/>The rule to remember is this: <span class="emphasis"><em>command line beats makefile beats environment</em></span>. A variable defined on the command line takes precedence over the same variable defined in a makefile, which will take precedence over the same variable defined in the environment.</p><p>It’s possible to have a <code class="literal">BUILD_DEBUG</code> variable that is set by default to <code class="literal">yes</code> and can be overridden <span class="emphasis"><em>either</em></span> on the command line or in the environment. GNU <code class="literal">make</code> provides two ways to achieve this, both of which rely on checking to see if the variable is already defined.</p><p>Here’s one way. Replace the setting of <code class="literal">BUILD_DEBUG</code> in the original makefile with this:</p><a id="pro_id00012"/><pre class="programlisting">ifndef BUILD_DEBUG
BUILD_DEBUG := yes
endif</pre><p>Now if <code class="literal">BUILD_DEBUG</code> has not already been set (that’s what <code class="literal">ndef</code> means: <span class="emphasis"><em>not defined</em></span>), it will be set to <code class="literal">yes</code>; otherwise, it is left unchanged. Because typing <code class="literal">ifndef SOME_VARIABLE</code> and <code class="literal">endif</code> is a bit unwieldy, GNU <code class="literal">make</code> provides a shorthand for this pattern in the form of the <code class="literal">?=</code> operator:</p><a id="pro_id00013"/><pre class="programlisting">BUILD_DEBUG ?= yes
.PHONY: all
all: ; @echo BUILD_DEBUG is $(BUILD_DEBUG)</pre><p>The <code class="literal">?=</code> operator tells GNU <code class="literal">make</code> to set <code class="literal">BUILD_DEBUG</code> to <code class="literal">yes</code> unless it is already defined, in which case leave it alone. Rerunning the test yields:</p><a id="pro_id00014"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
BUILD_DEBUG is yes
$ <span class="strong"><strong>make BUILD_DEBUG=no</strong></span>
BUILD_DEBUG is no
$ <span class="strong"><strong>export BUILD_DEBUG=no</strong></span>
$ <span class="strong"><strong>make</strong></span>
BUILD_DEBUG is no</pre><p>This technique provides the ultimate flexibility. A default setting in the makefile can be overridden in the environment and by a temporary override on the command line:</p><a id="pro_id00015"/><pre class="programlisting">$ <span class="strong"><strong>export BUILD_DEBUG=no</strong></span>
$ <span class="strong"><strong>make BUILD_DEBUG=aardvark</strong></span>
BUILD_DEBUG is aardvark</pre><div class="note" title="Note"><h3 class="title"><a id="ch01note02"/>Note</h3><p><span class="emphasis"><em>There’s actually a subtle difference between <code class="literal">ifndef</code> and <code class="literal">?=</code> in how they handle variables that are defined but set to an empty string. Whereas <code class="literal">ifndef</code> means</em></span> if not empty even if defined<span class="emphasis"><em>, the <code class="literal">?=</code> operator treats an empty, defined variable as defined. This difference is discussed in more detail in <a class="xref" href="ch04.html" title="Chapter 4. Pitfalls and Problems">Chapter 4</a>.</em></span></p></div></div><div class="sect1" title="The Environment Used by Commands"><div class="titlepage"><div><div><h1 class="title"><a id="environment_used_by_commands"/>The Environment Used by Commands</h1></div></div></div><p><a id="iddle1015" class="indexterm"/><a id="iddle1243" class="indexterm"/><a id="iddle1249" class="indexterm"/><a id="iddle1848" class="indexterm"/><a id="iddle1881" class="indexterm"/>The environment GNU <code class="literal">make</code> uses when it runs commands (such as commands in any rules it executes) is the environment GNU <code class="literal">make</code> started with, plus any variables <span class="emphasis"><em>exported</em></span> in the makefile—as well as a few variables GNU <code class="literal">make</code> adds itself.</p><p>Consider this simple makefile:</p><a id="pro_id00016"/><pre class="programlisting">FOO=bar

all: ; @echo FOO is $$FOO</pre><p>First, notice the double <code class="literal">$</code> sign: it’s an escaped <code class="literal">$</code> and means that the command passed to the shell by GNU <code class="literal">make</code> is <code class="literal">echo FOO is $FOO</code>. You can use a double <code class="literal">$</code> to get a single <code class="literal">$</code> into the shell.</p><p>If you run this makefile with <code class="literal">FOO</code> not defined in the environment, you’ll see the output <code class="literal">FOO is</code>. The value of <code class="literal">FOO</code> is not set because the makefile did not specifically export <code class="literal">FOO</code> into the environment used by GNU <code class="literal">make</code> to run commands. So when the shell runs the <code class="literal">echo</code> command for the <code class="literal">all</code> rule, <code class="literal">FOO</code> is not defined. If <code class="literal">FOO</code> had been set to <code class="literal">foo</code> in the environment before GNU <code class="literal">make</code> was run, you would see the output <code class="literal">FOO is bar</code>. This is because <code class="literal">FOO</code> was already present in the environment GNU <code class="literal">make</code> started with and then picked up the value <code class="literal">bar</code> inside the makefile.</p><a id="pro_id00017"/><pre class="programlisting">$ <span class="strong"><strong>export FOO=foo</strong></span>
$ <span class="strong"><strong>make</strong></span>
FOO is bar</pre><p>If you’re not sure whether <code class="literal">FOO</code> is in the environment but want to ensure that it makes its way into the environment used for commands, use the <code class="literal">export</code> directive. For example, you can ensure that <code class="literal">FOO</code> appears in the environment of subprocesses by modifying the makefile, like so:</p><a id="pro_id00018"/><pre class="programlisting"><span class="strong"><strong>export</strong></span> FOO=bar

all: ; @echo FOO is $$FOO</pre><p>Alternatively, you can just put <code class="literal">export FOO</code> on a line by itself. In both cases <code class="literal">FOO</code> will be exported into the environment of the commands run for the <code class="literal">all</code> rule.</p><p>You can remove a variable from the environment with <code class="literal">unexport</code>. To ensure that <code class="literal">FOO</code> is excluded from the subprocess environment, whether or not it was set in the parent environment, run the following:</p><a id="pro_id00019"/><pre class="programlisting">FOO=bar
<span class="strong"><strong>unexport FOO</strong></span>

all: ; @echo FOO is $$FOO</pre><p>You’ll see the output <code class="literal">FOO is</code>.</p><p><a id="iddle1244" class="indexterm"/><a id="iddle1268" class="indexterm"/><a id="iddle1514" class="indexterm"/><a id="iddle1516" class="indexterm"/><a id="iddle1535" class="indexterm"/><a id="iddle1731" class="indexterm"/>You might be wondering what happens if you <code class="literal">export</code> and <code class="literal">unexport</code> a variable. The answer is that the last directive wins.</p><p>The <code class="literal">export</code> directive can also be used with target-specific variables to modify the environment just for a particular rule. For example:</p><a id="pro_id00020"/><pre class="programlisting">export FOO=bar

all: export FOO=just for all

all: ; @echo FOO is $$FOO</pre><p>The makefile sets <code class="literal">FOO</code> to <code class="literal">just for all</code> for the <code class="literal">all</code> rule and <code class="literal">bar</code> for any other rule.</p><p>Note that you can’t remove <code class="literal">FOO</code> from the environment of a specific rule with a target-specific <code class="literal">unexport</code>. If you write <code class="literal">all: unexport FOO</code>, you’ll get an error.</p><p>GNU <code class="literal">make</code> also adds a number of variables to the subprocess environment—specifically, <code class="literal">MAKEFLAGS</code>, <code class="literal">MFLAGS</code>, and <code class="literal">MAKELEVEL</code>. The <code class="literal">MAKEFLAGS</code> and <code class="literal">MFLAGS</code> variables contain the flags specified on the command line: <code class="literal">MAKEFLAGS</code> contains the flags formatted for GNU <code class="literal">make</code>’s internal use and <code class="literal">MFLAGS</code> is only there for historical reasons. Never use <code class="literal">MAKEFLAGS</code> in a recipe. If you really need to, you can set <code class="literal">MFLAGS</code>. The <code class="literal">MAKELEVEL</code> variable contains the depth of recursive <code class="literal">make</code> calls, via <code class="literal">$(MAKE)</code>, starting at zero. For more detail on those variables, see the GNU <code class="literal">make</code> manual.</p><p>You can also ensure that every makefile variable gets exported, either by writing <code class="literal">export</code> on a line on its own or by specifying <code class="literal">.EXPORT_ALL_VARIABLES:</code>. But these shotgun approaches are probably a bad idea, because they fill the subprocess environment with useless—and perhaps harmful—variables.</p></div><div class="sect1" title="The $(shell) Environment"><div class="titlepage"><div><div><h1 class="title"><a id="dollarleft_parenthesisshellright_parenth"/>The $(shell) Environment</h1></div></div></div><p>You might expect that the environment used by a call to <code class="literal">$(shell)</code> would be the same as that used in the execution of a rule’s commands. In fact, it’s not. The environment used by <code class="literal">$(shell)</code> is exactly the same as the environment when GNU <code class="literal">make</code> was started, with nothing added or removed. You can verify this with the following makefile that gets the value of <code class="literal">FOO</code> from within a <code class="literal">$(shell)</code> call and a rule:</p><a id="pro_id00021"/><pre class="programlisting">export FOO=bar

$(info $(shell printenv | grep FOO))

all: ; @printenv | grep FOO</pre><p>That outputs:</p><a id="pro_id00022"/><pre class="programlisting">$ <span class="strong"><strong>export FOO=foo</strong></span>
$ <span class="strong"><strong>make</strong></span>
FOO=foo
FOO=bar</pre><p>No matter what you do, <code class="literal">$(shell)</code> gets the parent environment.</p><p>This is a bug in GNU <code class="literal">make</code> (bug #10593—see <span class="emphasis"><em><a class="ulink" href="http://savannah.gnu.org/bugs/?10593">http://savannah.gnu.org/bugs/?10593</a></em></span> for details). Part of the reason this hasn’t been fixed is that the obvious solution—just using the rule environment in <code class="literal">$(shell)</code>—has a rather nasty consequence. Consider this makefile:</p><a id="pro_id00023"/><pre class="programlisting">export FOO=$(shell echo fooey)
all: ; @echo FOO is $$FOO</pre><p>What’s the value of <code class="literal">FOO</code> in the rule for <code class="literal">all</code>? To get the value of <code class="literal">FOO</code> in the environment for <code class="literal">all</code>, the <code class="literal">$(shell)</code> has to be expanded, which requires getting the value of <code class="literal">FOO</code>—which requires expanding the <code class="literal">$(shell)</code> call, and so on, <span class="emphasis"><em>ad infinitum</em></span>.</p><p>In the face of this problem, GNU <code class="literal">make</code>’s developers opted for the easy way out: they just haven’t fixed the bug.</p><p>Given that this bug isn’t going away for the moment, a workaround is necessary. Luckily, most decent shells have a way to set an environment variable inline. So the first makefile in this section can be changed to:</p><a id="pro_id00024"/><pre class="programlisting">export FOO=bar

$(info $(shell <span class="strong"><strong>FOO=$(FOO)</strong></span> printenv | grep FOO))

all: ; @printenv | grep FOO</pre><p>This obtains the desired result:</p><a id="pro_id00025"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
FOO=bar
FOO=bar</pre><p>It works by setting the value of <code class="literal">FOO</code> within the shell used by the <code class="literal">$(shell)</code> function, using the <code class="literal">FOO=$(FOO)</code> syntax. Because the argument to <code class="literal">$(shell)</code> gets expanded before execution, that becomes <code class="literal">FOO=bar</code>, taking its value from the value of <code class="literal">FOO</code> set in the makefile.</p><p>The technique works fine if just one extra variable is needed in the environment. But if many are needed, it can be a bit problematic, because setting multiple shell variables on a single command line becomes messy.</p><p>A more comprehensive solution is to write a replacement for the <code class="literal">$(shell)</code> command that <span class="emphasis"><em>does</em></span> export variables. Here’s a function, <code class="literal">env_shell</code>, which does just that:</p><a id="pro_id00026"/><pre class="programlisting">env_file = /tmp/env
env_shell = $(shell rm -f $(env_file))$(foreach V,$1,$(shell echo export
$V=$($V) &gt;&gt; $(env_file)))$(shell echo '$2' &gt;&gt; $(env_file))$(shell /bin/bash -e
$(env_file))</pre><p>Before I explain how this works, here’s how to use it in the previous makefile. All you need to do is to change <code class="literal">$(shell)</code> to <code class="literal">$(call env_shell)</code>. The <a id="iddle1245" class="indexterm"/><a id="iddle1313" class="indexterm"/><a id="iddle1616" class="indexterm"/><a id="iddle1739" class="indexterm"/><a id="iddle1822" class="indexterm"/><a id="iddle1884" class="indexterm"/><a id="iddle1886" class="indexterm"/>first argument of <code class="literal">env_shell</code> is the list of variables that you need to add to the environment, whereas the second argument is the command to be executed. Here’s the updated makefile with <code class="literal">FOO</code> exported:</p><a id="pro_id00027"/><pre class="programlisting">export FOO=bar

$(info $(<span class="strong"><strong>call env_shell,FOO,printenv</strong></span> | grep FOO))

all: ; @printenv | grep FOO</pre><p>When you run this you’ll see the output:</p><a id="pro_id00028"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
FOO=bar
FOO=bar</pre><p>Now back to how <code class="literal">env_shell</code> works. First, it creates a shell script that adds all the variables from its first argument to the environment; then, it executes the command from its second argument. By default the shell script is stored in the file named in the <code class="literal">env_file</code> variable (which was set to <span class="emphasis"><em>/tmp/env</em></span> earlier).</p><p><span class="emphasis"><em>/tmp/env</em></span> ends up containing</p><a id="pro_id00029"/><pre class="programlisting">export FOO=bar
printenv | grep FOO</pre><p>We can break down the call to <code class="literal">env_shell</code> into four parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It deletes <span class="emphasis"><em>/tmp/env</em></span> with <code class="literal">$(shell rm -f $(env_file))</code>.</p></li><li class="listitem"><p>It adds lines containing the definition of each of the variables named in the first argument (<code class="literal">$1</code>) with the loop <code class="literal">$(foreach V,$1,$(shell echo export $V=$($V) &gt;&gt; $(env_file)))</code>.</p></li><li class="listitem"><p>It appends the actual command to execute, which is in the second argument (<code class="literal">$2</code>), with <code class="literal">$(shell echo '$2' &gt;&gt; $(env_file))</code>.</p></li><li class="listitem"><p>It runs <span class="emphasis"><em>/tmp/env</em></span> with a call to <code class="literal">shell</code> using the <code class="literal">-e</code> option: <code class="literal">$(shell /bin/bash -e $(env_file))</code>.</p></li></ul></div><p>It’s not a perfect solution; it would be nice if GNU <code class="literal">make</code> just figured out what should be in the environment. But it’s a workable solution until GNU <code class="literal">make</code>’s coders fix the bug.</p></div><div class="sect1" title="Target-Specific and Pattern-Specific Variables"><div class="titlepage"><div><div><h1 class="title"><a id="target-specific_and_pattern-specific_var"/>Target-Specific and Pattern-Specific Variables</h1></div></div></div><p>Every GNU <code class="literal">make</code> user is familiar with GNU <code class="literal">make</code> variables. And all GNU <code class="literal">make</code> users know that variables essentially have global scope. Once they are defined in a makefile, they can be used anywhere in the makefile. But how many GNU <code class="literal">make</code> users are familiar with GNU <code class="literal">make</code>’s locally scoped target-specific and pattern-specific variables? This section introduces target- and <a id="iddle1312" class="indexterm"/><a id="iddle1483" class="indexterm"/>pattern-specific variables, and shows how they can be used to selectively alter options within a build based on the name of a target or targets being built.</p><div class="sect2" title="Target-Specific Variables"><div class="titlepage"><div><div><h2 class="title"><a id="target-specific_variables"/>Target-Specific Variables</h2></div></div></div><p><a class="xref" href="ch01.html#example_makefile_with_four_phony_targets" title="Example 1-1. An example makefile with four phony targets">Example 1-1</a> shows a simple example makefile that illustrates the difference between global and local scope in GNU <code class="literal">make</code>:</p><div class="example"><a id="example_makefile_with_four_phony_targets"/><p class="title">Example 1-1. An example makefile with four phony targets</p><div class="example-contents"><pre class="programlisting">   .PHONY: all foo bar baz

➊ VAR = global scope

   all: foo bar
   all: ; @echo In $@ VAR is $(VAR)

   foo: ; @echo In $@ VAR is $(VAR)

➋ bar: VAR = local scope
   bar: baz
   bar: ; @echo In $@ VAR is $(VAR)

   baz: ; @echo In $@ VAR is $(VAR)</pre></div></div><p>This makefile has four targets: <code class="literal">all</code>, <code class="literal">foo</code>, <code class="literal">bar</code>, and <code class="literal">baz</code>. All four targets are phony; because we’re interested only in illustrating global and local scope for now, this makefile doesn’t actually make any files.</p><p>The <code class="literal">all</code> target requires that <code class="literal">foo</code> and <code class="literal">bar</code> be built, whereas <code class="literal">bar</code> depends on <code class="literal">baz</code>. The commands for each target do the same thing—they print the value of variable <code class="literal">VAR</code> using a shell <code class="literal">echo</code>.</p><p>The <code class="literal">VAR</code> variable is initially defined at ➊ to have the value <code class="literal">global scope</code>. That’s the value <code class="literal">VAR</code> will have anywhere in the makefile—unless, of course, that value is overridden using a target- or pattern-specific variable.</p><p>To illustrate local scope, <code class="literal">VAR</code> is redefined to <code class="literal">local scope</code> at ➋ for the rule that creates <code class="literal">bar</code>. A target-specific variable definition is exactly like a normal variable definition: it uses the same <code class="literal">=</code>, <code class="literal">:=</code>, <code class="literal">+=</code>, and <code class="literal">?=</code> operators, but it is preceded by the name of the target (and its colon) for which the variable should be defined.</p><p>If you run GNU <code class="literal">make</code> on this makefile, you’ll get the output shown in <a class="xref" href="ch01.html#output_from_listing_1-1_showing_globally" title="Example 1-2. Output from Example 1-1 showing globally and locally scoped variables">Example 1-2</a>.</p><div class="example"><a id="output_from_listing_1-1_showing_globally"/><p class="title">Example 1-2. Output from <a class="xref" href="ch01.html#example_makefile_with_four_phony_targets" title="Example 1-1. An example makefile with four phony targets">Example 1-1</a> showing globally and locally scoped variables</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
In foo VAR is global scope
In baz VAR is local scope
In bar VAR is local scope
In all VAR is global scope</pre></div></div><p>You can clearly see that GNU <code class="literal">make</code> follows its standard depth-first, left-to-right search pattern. First it builds <code class="literal">foo</code>, because it’s the first prerequisite of <code class="literal">all</code>. Then it builds <code class="literal">baz</code>, which is a prerequisite of <code class="literal">bar</code>, the second prerequisite of <code class="literal">all</code>. Then it builds <code class="literal">bar</code> and, finally, <code class="literal">all</code>.</p><p>Sure enough, within the rule for <code class="literal">bar</code> the value of <code class="literal">VAR</code> is <code class="literal">local scope</code>. And because there’s no local definition of <code class="literal">VAR</code> in either <code class="literal">all</code> or <code class="literal">foo</code>, <code class="literal">VAR</code> has the value <code class="literal">global scope</code> in those rules.</p><p>But what about <code class="literal">baz</code>? The makefile output shows that the value of <code class="literal">VAR</code> in <code class="literal">baz</code> is <code class="literal">local scope</code>, yet there was no explicit target-specific definition of <code class="literal">VAR</code> for <code class="literal">baz</code>. This is because <code class="literal">baz</code> is a prerequisite of <code class="literal">bar</code> and so has the same locally scoped variables as <code class="literal">bar</code>.</p><p>Target-specific variables apply not just to a target, but also to all that target’s prerequisites, as well as all <span class="emphasis"><em>their</em></span> prerequisites, and so on. A target-specific variable’s scope is the entire tree of targets, starting from the target for which the variable was defined.</p><p>Note that because <code class="literal">all</code>, <code class="literal">foo</code>, <code class="literal">bar</code>, and <code class="literal">baz</code> have exactly the same recipe, it’s possible to write them all on a single line, as shown here:</p><a id="pro_id00030"/><pre class="programlisting">all foo bar baz: ; @echo In $@ VAR is $(VAR)</pre><p>But in this section, I’ve avoided having multiple targets because this sometimes causes confusion (many GNU <code class="literal">make</code> users think that this line represents a single rule that would run once for <code class="literal">all</code>, <code class="literal">foo</code>, <code class="literal">bar</code>, and <code class="literal">baz</code>, but it is actually four separate rules).</p></div><div class="sect2" title="Pattern-Specific Variables"><div class="titlepage"><div><div><h2 class="title"><a id="pattern-specific_variables"/>Pattern-Specific Variables</h2></div></div></div><p>Pattern-specific variables work in a manner similar to target-specific variables. But instead of being defined for a target, they are defined for a pattern and are applied to all targets that match that pattern. The following example is similar to <a class="xref" href="ch01.html#example_makefile_with_four_phony_targets" title="Example 1-1. An example makefile with four phony targets">Example 1-1</a> but has been modified to include a pattern-specific variable:</p><a id="pro_id00031"/><pre class="programlisting">   .PHONY: all foo bar baz

   VAR = global scope

   all: foo bar
   all: ; @echo In $@ VAR is $(VAR)

   foo: ; @echo In $@ VAR is $(VAR)

   bar: VAR = local scope
   bar: baz
   bar: ; @echo In $@ VAR is $(VAR)

   baz: ; @echo In $@ VAR is $(VAR)

➊ f%: VAR = starts with f</pre><p><a id="iddle1614" class="indexterm"/><a id="iddle1794" class="indexterm"/>The last line ➊ sets <code class="literal">VAR</code> to the value <code class="literal">starts with f</code> for any target beginning with <code class="literal">f</code> and followed by anything else (that’s the <code class="literal">%</code> wildcard). (It is also possible to use multiple targets to accomplish this. But don’t worry about that for now.)</p><p>Now if you run <code class="literal">make</code>, you get the following output:</p><a id="pro_id00032"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
In foo VAR is starts with f
In baz VAR is local scope
In bar VAR is local scope
In all VAR is global scope</pre><p>This is the same as in <a class="xref" href="ch01.html#output_from_listing_1-1_showing_globally" title="Example 1-2. Output from Example 1-1 showing globally and locally scoped variables">Example 1-2</a>, except that in the rule for <code class="literal">foo</code> the value of <code class="literal">VAR</code> has been set to <code class="literal">starts with f</code> by the pattern-specific definition.</p><p>It’s worth noting that this is unrelated to GNU <code class="literal">make</code> pattern rules. You can use the pattern-specific variable definition to change the value of a variable in a normal rule. You can also use it with a pattern rule.</p><p>For example, imagine that a makefile uses the built-in <code class="literal">%.o: %.c</code> pattern rule:</p><a id="pro_id00033"/><pre class="programlisting">%.o: %.c
#  commands to execute (built-in):
→ $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><p>It would be possible to set a variable on every <code class="literal">.o</code> file that rule builds using a pattern-specific variable. Here’s how to add the <code class="literal">-g</code> option to <code class="literal">CFLAGS</code> for every <code class="literal">.o</code> file:</p><a id="pro_id00034"/><pre class="programlisting">%.o: CFLAGS += -g</pre><p>It’s not uncommon in a project to have a standard rule for compiling files and to need a slightly different version of that rule for a specific file, or set of files, that otherwise use the same command. For example, here’s a makefile that builds all the <code class="literal">.c</code> files in two subdirectories (<code class="literal">lib1</code> and <code class="literal">lib2</code>) using a pattern rule:</p><a id="pro_id00035"/><pre class="programlisting">   lib1_SRCS := $(wildcard lib1/*.c)
   lib2_SRCS := $(wildcard lib2/*.c)

   lib1_OBJS := $(lib1_SRCS:.c=.o)
   lib2_OBJS := $(lib2_SRCS:.c=.o)

   .PHONY: all
   all: $(lib1_OBJS) $(lib2_OBJS)

➊ %.o: %.c ; @$(COMPILE.C) -o $@ $&lt;</pre><p>First, the makefile gets the list of all <code class="literal">.c</code> files in <span class="emphasis"><em>lib1/</em></span> into the variable <code class="literal">lib1_SRCS</code>, and the C files in <span class="emphasis"><em>lib2/</em></span> into <code class="literal">lib2_SRCS</code>. Then it converts these to lists of object files using a substitution reference that changes <code class="literal">.c</code> to <code class="literal">.o</code> and stores <a id="iddle1271" class="indexterm"/><a id="iddle1357" class="indexterm"/><a id="iddle1519" class="indexterm"/><a id="iddle1894" class="indexterm"/>the results in <code class="literal">lib1_OBJS</code> and <code class="literal">lib2_OBJS</code>. The pattern rule in the last line ➊ uses the GNU <code class="literal">make</code> built-in variable <code class="literal">COMPILE.C</code> to run a compiler that compiles a <code class="literal">.c</code> file into a <code class="literal">.o</code> file. The makefile builds all the objects in <code class="literal">lib1_OBJS</code> and <code class="literal">lib2_OBJS</code> because they are prerequisites of <code class="literal">all</code>. Both <code class="literal">lib1_OBJS</code> and <code class="literal">lib2_OBJS</code> contain a list of <code class="literal">.o</code> files corresponding to <code class="literal">.c</code> files. When GNU <code class="literal">make</code> searches for the <code class="literal">.o</code> files (the prerequisites of <code class="literal">all</code>), it finds that they are missing but that it can use the <code class="literal">%.o: %.c</code> rule to build then.</p><p>This works fine if all the <code class="literal">.c</code> files have the same compilation options. But now suppose that the <code class="literal">.c</code> file <span class="emphasis"><em>lib1/special.c</em></span> requires the <code class="literal">-Wcomment</code> option to prevent the compiler from warning about an oddly written comment. Obviously, it would be possible to change the value of <code class="literal">CPPFLAGS</code> globally by adding the line <code class="literal">CPPFLAGS += -Wcomment</code> to the makefile. But this change would affect <span class="emphasis"><em>every</em></span> compilation, which is probably not what you want.</p><p>Fortunately, you can use a target-specific variable to just alter the value of <code class="literal">CPPFLAGS</code> for that single file, like so:</p><a id="pro_id00036"/><pre class="programlisting">lib1/special.o: CPPFLAGS += -Wcomment</pre><p>The line alters the value of <code class="literal">CPPFLAGS</code> just for the creation of <span class="emphasis"><em>lib1/special.o</em></span>.</p><p>Now suppose that an entire subdirectory requires a special <code class="literal">CPPFLAGS</code> option to maximize optimization for speed (the <code class="literal">-fast</code> option to <code class="literal">gcc</code>, for example). Here, a pattern-specific variable definition is ideal:</p><a id="pro_id00037"/><pre class="programlisting">lib1/%.o: CPPFLAGS += -fast</pre><p>This does the trick. Any <code class="literal">.o</code> files that are built in <span class="emphasis"><em>lib1/</em></span> will be built using the <code class="literal">-fast</code> command line option.</p></div></div><div class="sect1" title="Version Checking"><div class="titlepage"><div><div><h1 class="title"><a id="version_checking"/>Version Checking</h1></div></div></div><p>Because GNU <code class="literal">make</code> is regularly updated and new features are added all the time, it’s important to know the version of GNU <code class="literal">make</code> that’s running or whether a specific GNU <code class="literal">make</code> feature is available. You can do this in two ways: either look at the <code class="literal">MAKE_VERSION</code> variable or look in the <code class="literal">.FEATURES</code> variable (added in GNU <code class="literal">make</code> 3.81). It’s also possible to check for specific features, like <code class="literal">$(eval)</code>.</p><div class="sect2" title="MAKE_VERSION"><div class="titlepage"><div><div><h2 class="title"><a id="makeunderscoreversion"/>MAKE_VERSION</h2></div></div></div><p>The <code class="literal">MAKE_VERSION</code> variable contains the version number of GNU <code class="literal">make</code> that’s processing the makefile where <code class="literal">MAKE_VERSION</code> is referenced. Here’s an example makefile that prints the version of GNU <code class="literal">make</code> and stops:</p><a id="pro_id00038"/><pre class="programlisting">.PHONY: all
all: ; @echo $(MAKE_VERSION)</pre><p><a id="iddle1053" class="indexterm"/><a id="iddle1111" class="indexterm"/><a id="iddle1236" class="indexterm"/><a id="iddle1272" class="indexterm"/><a id="iddle1348" class="indexterm"/><a id="iddle1447" class="indexterm"/><a id="iddle1584" class="indexterm"/><a id="iddle1698" class="indexterm"/><a id="iddle1821" class="indexterm"/>And here’s the output generated when GNU <code class="literal">make</code> 3.80 parses this makefile:</p><a id="pro_id00039"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
3.80</pre><p>What if you want to determine that version 3.80 or later of GNU <code class="literal">make</code> is handling your makefile? If you assume the version number is always in the form <code class="literal">X.YY.Z</code> or <code class="literal">X.YY</code>, the following code fragment will set the <code class="literal">ok</code> variable to non-empty if the version mentioned in <code class="literal">need</code> is equal to or less than the running version of GNU <code class="literal">make</code>.</p><a id="pro_id00040"/><pre class="programlisting">need := 3.80
ok := $(filter $(need),$(firstword $(sort $(MAKE_VERSION) $(need))))</pre><p>If <code class="literal">ok</code> is not blank, the required version of GNU <code class="literal">make</code> or later is being used; if it’s blank, the version is too old. The code fragment works by creating a space-separated list of the running version of GNU <code class="literal">make</code> in <code class="literal">MAKE_VERSION</code> and the required version (from <code class="literal">need</code>), and sorting that list. Suppose the running version is 3.81. Then <code class="literal">$(sort $(MAKE_VERSION) $(need))</code> will be <code class="literal">3.80 3.81</code>. The <code class="literal">$(firstword)</code> of that is <code class="literal">3.80</code>, so the <code class="literal">$(filter)</code> call will keep <code class="literal">3.80</code>. Thus, <code class="literal">ok</code> will be non-empty.</p><p>Now suppose the running version is 3.79.1. Then <code class="literal">$(sort $(MAKE_VERSION) $(need))</code> will be <code class="literal">3.79.1 3.80</code>, and <code class="literal">$(firstword)</code> will return <code class="literal">3.79.1</code>. The <code class="literal">$(filter)</code> call will remove <code class="literal">3.79.1</code> and thus <code class="literal">ok</code> will be empty.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note03"/>Note</h3><p><span class="emphasis"><em>This fragment won’t work correctly with versions of GNU <code class="literal">make</code> starting at 10.01, because it assumes a single-digit major version number. Fortunately, that’s a long way off!</em></span></p></div></div><div class="sect2" title=".FEATURES"><div class="titlepage"><div><div><h2 class="title"><a id="dotfeatures"/>.FEATURES</h2></div></div></div><p>GNU <code class="literal">make</code> 3.81 introduced the <code class="literal">.FEATURES</code> default variable, which contains a list of supported features. In GNU <code class="literal">make</code> 3.81, seven features are listed and supported in <code class="literal">.FEATURES</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="archives"><span class="title"><strong><span class="strong"><strong><code class="literal">archives</code></strong></span></strong></span>. Archive (<code class="literal">ar</code>) files using the <code class="literal">archive(member)</code> syntax</p></li><li class="listitem"><p title="check-symlink"><span class="title"><strong><span class="strong"><strong><code class="literal">check-symlink</code></strong></span></strong></span>. The <code class="literal">-L</code> and <code class="literal">--check-symlink-times</code> flags</p></li><li class="listitem"><p title="else-if"><span class="title"><strong><span class="strong"><strong><code class="literal">else-if</code></strong></span></strong></span>. Else branches in the non-nested form <code class="literal">else if X</code></p></li><li class="listitem"><p title="jobserver"><span class="title"><strong><span class="strong"><strong><code class="literal">jobserver</code></strong></span></strong></span>. Building in parallel using the job server</p></li><li class="listitem"><p title="order-only"><span class="title"><strong><span class="strong"><strong><code class="literal">order-only</code></strong></span></strong></span>. <code class="literal">order-only</code> prerequisite support</p></li><li class="listitem"><p title="second-expansion"><span class="title"><strong><span class="strong"><strong><code class="literal">second-expansion</code></strong></span></strong></span>. Double expansion of prerequisite lists</p></li><li class="listitem"><p title="target-specific"><span class="title"><strong><span class="strong"><strong><code class="literal">target-specific</code></strong></span></strong></span>. Target-specific and pattern-specific variables</p></li></ul></div><p><a id="iddle1342" class="indexterm"/><a id="iddle1350" class="indexterm"/><a id="iddle1352" class="indexterm"/><a id="iddle1399" class="indexterm"/><a id="iddle1480" class="indexterm"/><a id="iddle1577" class="indexterm"/><a id="iddle1589" class="indexterm"/><a id="iddle1744" class="indexterm"/><a id="iddle1846" class="indexterm"/>GNU <code class="literal">make</code> 3.82 adds and supports the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="oneshell"><span class="title"><strong><span class="strong"><strong><code class="literal">oneshell</code></strong></span></strong></span>. The <code class="literal">.ONESHELL</code> special target</p></li><li class="listitem"><p title="shortest-stem"><span class="title"><strong><span class="strong"><strong><code class="literal">shortest-stem</code></strong></span></strong></span>. Using the shortest stem option when choosing between pattern rules that match a target</p></li><li class="listitem"><p title="undefine"><span class="title"><strong><span class="strong"><strong><code class="literal">undefine</code></strong></span></strong></span>. The <code class="literal">undefine</code> directive</p></li></ul></div><p>And GNU <code class="literal">make</code> 4.0 adds the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="guile"><span class="title"><strong><span class="strong"><strong><code class="literal">guile</code></strong></span></strong></span>. If GNU <code class="literal">make</code> was built with GNU Guile support, this will be present and the <code class="literal">$(guile)</code> function will be supported.</p></li><li class="listitem"><p title="load"><span class="title"><strong><span class="strong"><strong><code class="literal">load</code></strong></span></strong></span>. The ability to load dynamic objects to enhance the capabilities of GNU <code class="literal">make</code> is supported.</p></li><li class="listitem"><p title="output-sync"><span class="title"><strong><span class="strong"><strong><code class="literal">output-sync</code></strong></span></strong></span>. The <code class="literal">-O</code> (and <code class="literal">--</code><code class="literal">output-sync</code>) command line options are supported.</p></li></ul></div><p>You can find more details on these and many other features in <a class="xref" href="ch01.html#recent_gnu_make_versions_3dot81comma_3do" title="Recent GNU make Versions: 3.81, 3.82, and 4.0">Recent GNU make Versions: 3.81, 3.82, and 4.0</a>.</p><p>To check if a specific feature is available, you can use the following <code class="literal">is_feature</code> function: it returns <code class="literal">T</code> if the requested feature is supported or an empty string if the feature is missing:</p><a id="pro_id00041"/><pre class="programlisting">is_feature = $(if $(filter $1,$(.FEATURES)),T)</pre><p>For example, the following makefile uses <code class="literal">is_feature</code> to echo whether the <code class="literal">archives</code> feature is available:</p><a id="pro_id00042"/><pre class="programlisting">.PHONY: all
all: ; @echo archives are $(if $(call is_feature,archives),,not )available</pre><p>And here’s the output using GNU <code class="literal">make</code> 3.81:</p><a id="pro_id00043"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
archives are available</pre><p>If you want to check whether the <code class="literal">.FEATURES</code> variable is even supported, either use <code class="literal">MAKE_VERSION</code> as described in <a class="xref" href="ch01.html#makeunderscoreversion" title="MAKE_VERSION">MAKE_VERSION</a> or simply expand <code class="literal">.FEATURES</code> and see whether it’s empty. The following makefile fragment does just this, setting <code class="literal">has_features</code> to <code class="literal">T</code> (for true) if the <code class="literal">.FEATURES</code> variable is present and contains any features:</p><a id="pro_id00044"/><pre class="programlisting">has_features := $(if $(filter default,$(origin .FEATURES)),$(if $(.FEATURES),T))</pre><p>The fragment first uses <code class="literal">$(origin)</code> to check that the <code class="literal">.FEATURES</code> variable is a default variable; this way, <code class="literal">has_features</code> is not fooled if someone has defined <code class="literal">.FEATURES</code> in the makefile. If it is a default variable, the second <code class="literal">$(if)</code> checks whether or not <code class="literal">.FEATURES</code> is blank.</p></div><div class="sect2" title="Detecting $(eval)"><div class="titlepage"><div><div><h2 class="title"><a id="detecting_dollarleft_parenthesisevalrigh"/>Detecting $(eval)</h2></div></div></div><p><a id="iddle1083" class="indexterm"/><a id="iddle1239" class="indexterm"/><a id="iddle1261" class="indexterm"/><a id="iddle1264" class="indexterm"/><a id="iddle1413" class="indexterm"/><a id="iddle1417" class="indexterm"/>The <code class="literal">$(eval)</code> function is a powerful GNU <code class="literal">make</code> feature that was added in version 3.80. The argument to <code class="literal">$(eval)</code> is expanded and then parsed as if it were part of the makefile, allowing you to modify the makefile at runtime.</p><p>If you use <code class="literal">$(eval)</code>, it is important to check that the feature is available in the version of GNU <code class="literal">make</code> reading your makefile. You could use <code class="literal">MAKE_VERSION</code> as described earlier to check for version 3.80. Alternatively, you could use the following fragment of code that sets <code class="literal">eval_available</code> to <code class="literal">T</code> only if <code class="literal">$(eval)</code> is implemented:</p><a id="pro_id00045"/><pre class="programlisting">$(eval eval_available := T)</pre><p>If <code class="literal">$(eval)</code> is not available, GNU <code class="literal">make</code> will look for a variable called <code class="literal">eval eval_available := T</code> and try to get its value. This variable doesn’t exist, of course, so <code class="literal">eval_available</code> will be set to the empty string.</p><p>You can use <code class="literal">eval_available</code> with <code class="literal">ifneq</code> to generate a fatal error if <code class="literal">$(eval)</code> isn’t implemented.</p><a id="pro_id00046"/><pre class="programlisting">ifneq ($(eval_available),T)
$(error This makefile only works with a Make program that supports $$(eval))
endif</pre><p>The <code class="literal">eval_available</code> function is especially useful if you can’t check <code class="literal">MAKE_VERSION</code>—if, for example, your makefile is being run using a non-GNU <code class="literal">make</code> tool, such as <code class="literal">clearmake</code> or <code class="literal">emake</code>.</p></div></div><div class="sect1" title="Using Boolean Values"><div class="titlepage"><div><div><h1 class="title"><a id="using_boolean_values"/>Using Boolean Values</h1></div></div></div><p>Both GNU <code class="literal">make</code>’s <code class="literal">$(if)</code> function and <code class="literal">ifdef</code> construct treat the empty string and undefined variables as false, and anything else as true. But they differ subtly in how they evaluate their arguments.</p><p>The <code class="literal">$(if)</code> function—that is, <code class="literal">$(if</code> <span class="emphasis"><em><code class="literal">X</code></em></span><code class="literal">,</code><span class="emphasis"><em><code class="literal">if-part</code></em></span><code class="literal">,</code><span class="emphasis"><em><code class="literal">else-part</code></em></span><code class="literal">)</code>—expands <span class="emphasis"><em><code class="literal">if-part</code></em></span> if <span class="emphasis"><em><code class="literal">X</code></em></span> is not empty and <span class="emphasis"><em><code class="literal">else-part</code></em></span> otherwise. When using <code class="literal">$(if)</code>, the condition is expanded and the value <span class="emphasis"><em>after expansion</em></span> is tested for emptiness. The following code fragment reports that it took the <span class="emphasis"><em><code class="literal">else-part</code></em></span> branch:</p><a id="pro_id00047"/><pre class="programlisting">EMPTY =
VAR = $(EMPTY)
$(if $(VAR),$(info if-part),$(info else-part))</pre><p>Whereas the next fragment follows the <span class="emphasis"><em><code class="literal">if-part</code></em></span> branch, because <code class="literal">HAS_A_VALUE</code> has a non-empty value.</p><a id="pro_id00048"/><pre class="programlisting">HAS_A_VALUE = I'm not empty
$(if $(HAS_A_VALUE),$(info if-part),$(info else-part))</pre><p><a id="iddle1154" class="indexterm"/><a id="iddle1240" class="indexterm"/><a id="iddle1845" class="indexterm"/><a id="iddle1888" class="indexterm"/><a id="iddle1898" class="indexterm"/><a id="iddle1899" class="indexterm"/>The <code class="literal">ifdef</code> construct works slightly differently: its argument is the <span class="emphasis"><em>name</em></span> of a variable and is not expanded:</p><a id="pro_id00049"/><pre class="programlisting">ifdef VAR
if-part...
else
else-part...
endif</pre><p>The preceding example executes <span class="emphasis"><em><code class="literal">if-part</code></em></span> if the variable <code class="literal">VAR</code> is non-empty and <span class="emphasis"><em><code class="literal">else-part</code></em></span> if <code class="literal">VAR</code> is empty or undefined.</p><div class="sect2" title="Undefined Variables in Conditionals"><div class="titlepage"><div><div><h2 class="title"><a id="undefined_variables_in_conditionals"/>Undefined Variables in Conditionals</h2></div></div></div><p>Because GNU <code class="literal">make</code> treats an undefined variable as simply empty, <code class="literal">ifdef</code> should really be called <code class="literal">ifempty</code>—especially because it treats a defined-but-empty variable as undefined. For example, the following fragment reports that <code class="literal">VAR</code> is undefined:</p><a id="pro_id00050"/><pre class="programlisting">VAR =
ifdef VAR
$(info VAR is defined)
else
$(info VAR is undefined)
endif</pre><p>In an actual makefile, this might not have been the intended result. You can ask for warnings of undefined variables with the <code class="literal">--warn-undefined-variables</code> command line option.</p><p>One further nuance of <code class="literal">ifdef</code> is that it does not expand the variable <code class="literal">VAR</code>. It simply looks to see if it has been defined to a non-empty value. The following code reports that <code class="literal">VAR</code> is defined even though its value, when completely expanded, is an empty string:</p><a id="pro_id00051"/><pre class="programlisting">EMPTY =
VAR = $(EMPTY)
ifdef VAR
$(info VAR is defined)
else
$(info VAR is not defined)
endif</pre><p>GNU <code class="literal">make</code> 3.81 introduced yet another wrinkle to <code class="literal">ifdef</code>: its argument is expanded so that the name of the variable being tested can be computed. This has no effect on conditionals, such as <code class="literal">ifdef VAR</code>, but allows you to write</p><a id="pro_id00052"/><pre class="programlisting">VAR_NAME = VAR
VAR = some value
ifdef $(VAR_NAME)
$(info VAR is defined)
else
$(info VAR is not defined)
endif</pre><p><a id="iddle1054" class="indexterm"/><a id="iddle1561" class="indexterm"/><a id="iddle1761" class="indexterm"/><a id="iddle1842" class="indexterm"/><a id="iddle1903" class="indexterm"/><a id="iddle1908" class="indexterm"/>This is exactly the same as:</p><a id="pro_id00053"/><pre class="programlisting">VAR = some value
ifdef VAR
$(info VAR is defined)
else
$(info VAR is not defined)
endif</pre><p>In both cases <code class="literal">VAR</code> is examined to see whether it is empty, exactly as described earlier, and in both output <code class="literal">VAR is defined</code>.</p></div><div class="sect2" title="Consistent Truth Values"><div class="titlepage"><div><div><h2 class="title"><a id="consistent_truth_values"/>Consistent Truth Values</h2></div></div></div><p>GNU <code class="literal">make</code> treats any non-empty string as true. But if you work with truth values and <code class="literal">$(if)</code> a lot, it can be helpful to use just one consistent value for true. The following <code class="literal">make-truth</code> function turns any non-empty string into the value <code class="literal">T</code>:</p><a id="pro_id00054"/><pre class="programlisting">make-truth = $(if $1,T)</pre><p>Notice how we can drop the <code class="literal">else</code> part of the <code class="literal">$(if)</code>, because it’s empty. Throughout this book I’ll drop arguments that aren’t necessary rather than polluting makefiles with extraneous trailing commas. But there’s nothing to stop you from writing <code class="literal">$(if $1,T,)</code> if it makes you more comfortable.</p><p>All of the following <code class="literal">calls</code> to <code class="literal">make-truth</code> return <code class="literal">T</code>:</p><a id="pro_id00055"/><pre class="programlisting">➊ $(call make-truth, )
   $(call make-truth,true)
   $(call make-truth,a b c)</pre><p>Even ➊ returns <code class="literal">T</code>, because arguments to functions called using <code class="literal">$(call)</code> do not have any modifications made to them before being placed in <code class="literal">$1</code>, <code class="literal">$2</code>, and so on—not even the removal of leading or trailing space. So the second argument is a string with a single space in it, not the empty string.</p><p>All the following return an empty string (for false):</p><a id="pro_id00056"/><pre class="programlisting">➋ $(call make-truth,)
   EMPTY =
   $(call make-truth,$(EMPTY))
   VAR = $(EMPTY)
   $(call make-truth,$(VAR))</pre><p>Look carefully at the difference between ➊ and ➋: whitespace in GNU <code class="literal">make</code> can be very significant!</p></div></div><div class="sect1" title="Logical Operations Using Boolean Values"><div class="titlepage"><div><div><h1 class="title"><a id="logical_operations_using_boolean_values"/>Logical Operations Using Boolean Values</h1></div></div></div><p><a id="iddle1086" class="indexterm"/><a id="iddle1307" class="indexterm"/><a id="iddle1484" class="indexterm"/><a id="iddle1488" class="indexterm"/><a id="iddle1569" class="indexterm"/><a id="iddle1579" class="indexterm"/><a id="iddle1855" class="indexterm"/>GNU <code class="literal">make</code> had no built-in logical operators until version 3.81, when <code class="literal">$(or)</code> and <code class="literal">$(and)</code> were added. However, it’s easy to create user-defined functions that operate on Boolean values. These functions often use GNU <code class="literal">make</code>’s <code class="literal">$(if)</code> function to make decisions. <code class="literal">$(if)</code> treats any non-empty string as <code class="literal">'true'</code> and an empty string as <code class="literal">'false'</code>.</p><div class="sect2" title="User-Defined Logical Operators"><div class="titlepage"><div><div><h2 class="title"><a id="user-defined_logical_operators"/>User-Defined Logical Operators</h2></div></div></div><p>Let’s create a user-defined version of the simplest logical operator, <code class="literal">or</code>. If either parameter is true (that is, a non-empty string), the result should also be a non-empty string. We can achieve this by just concatenating the arguments:</p><a id="pro_id00057"/><pre class="programlisting">or = $1$2</pre><p>You can use the <code class="literal">make-truth</code> function in <a class="xref" href="ch01.html#consistent_truth_values" title="Consistent Truth Values">Consistent Truth Values</a> to clean up the result of the <code class="literal">or</code> so that it’s either <code class="literal">T</code> for true or an empty string for false:</p><a id="pro_id00058"/><pre class="programlisting">or = $(call make-truth,$1$2)</pre><p>Or for a more compact version you just can write:</p><a id="pro_id00059"/><pre class="programlisting">or = $(if $1$2,T).</pre><p>All the following return <code class="literal">T</code>:</p><a id="pro_id00060"/><pre class="programlisting">$(call or, , )
$(call or,T,)
$(call or, ,)
$(call or,hello,goodbye my friend)</pre><p>The only way to return false from <code class="literal">or</code> is to pass in two empty arguments:</p><a id="pro_id00061"/><pre class="programlisting">EMPTY=
$(call or,$(EMPTY),)</pre><p>Defining <code class="literal">and</code> is a little more complex, requiring two calls to <code class="literal">$(if)</code>:</p><a id="pro_id00062"/><pre class="programlisting">and = $(if $1,$(if $2,T))</pre><p>There’s no need to wrap this in <code class="literal">make-truth</code> because it always returns <code class="literal">T</code> if its arguments are non-empty and the empty string if either argument is empty.</p><p>Defining <code class="literal">not</code> is just a single <code class="literal">$(if)</code>:</p><a id="pro_id00063"/><pre class="programlisting">not = $(if $1,,T)</pre><p><a id="iddle1049" class="indexterm"/><a id="iddle1421" class="indexterm"/><a id="iddle1485" class="indexterm"/><a id="iddle1552" class="indexterm"/><a id="iddle1563" class="indexterm"/><a id="iddle1580" class="indexterm"/><a id="iddle1934" class="indexterm"/>With <code class="literal">and</code>, <code class="literal">or</code>, and <code class="literal">not</code> defined, you can quickly create other logical operators:</p><a id="pro_id00064"/><pre class="programlisting">nand = $(call not,$(call and,$1,$2)) nor = $(call not,$(call or,$1,$2))
xor = $(call and,$(call or,$1,$2),$(call not,$(call and,$1,$2)))</pre><p>These all also have simplified versions that just use <code class="literal">$(if)</code>:</p><a id="pro_id00065"/><pre class="programlisting">nand = $(if $1,$(if $2,,T),T)
nor = $(if $1$2,,T)
xor = $(if $1,$(if $2,,T),$(if $2,T))</pre><p>As an exercise, try writing an <code class="literal">xnor</code> function!</p></div><div class="sect2" title="Built-in Logical Operators (GNU make 3.81 and Later)"><div class="titlepage"><div><div><h2 class="title"><a id="built-in_logical_operators_left_parenthe"/>Built-in Logical Operators (GNU make 3.81 and Later)</h2></div></div></div><p>GNU <code class="literal">make</code> 3.81 and later has built-in <code class="literal">and</code> and <code class="literal">or</code> functions that are faster than the versions defined earlier, so it’s preferable to use those whenever possible. You should test whether the <code class="literal">and</code> and <code class="literal">or</code> functions already exist and only define your own if they don’t.</p><p>The easiest way to determine whether <code class="literal">and</code> and <code class="literal">or</code> are defined is to try using them:</p><a id="pro_id00066"/><pre class="programlisting">have_native_and := $(and T,T)
have_native_or := $(or T,T)</pre><p>These variables will be <code class="literal">T</code> only if built-in <code class="literal">and</code> and <code class="literal">or</code> functions are present. In versions of GNU <code class="literal">make</code> prior to 3.81 (or in GNU <code class="literal">make</code>-emulating programs like <code class="literal">clearmake</code>), <code class="literal">have_native_and</code> and <code class="literal">have_native_or</code> will be empty because GNU <code class="literal">make</code> will not find functions called <code class="literal">and</code> or <code class="literal">or</code>, nor will it find variables called <code class="literal">and T</code>, <code class="literal">T</code>, or <code class="literal">or T</code>, <code class="literal">T</code>!</p><p>You can examine the results of these calls using <code class="literal">ifneq</code> and define your own functions only if necessary, like so:</p><a id="pro_id00067"/><pre class="programlisting">ifneq ($(have_native_and),T)
and = $(if $1,$(if $2,T))
endif
ifneq ($(have_native_or),T)
or = $(if $1$2,T)
endif

$(info This will be T: $(call and,T,T))</pre><p>You may be concerned that you’ve written <code class="literal">$(call and,...)</code> and <code class="literal">$(call or,...)</code> everywhere, using <code class="literal">call</code> to invoke your own logic operators. Won’t you need to change all these to <code class="literal">$(and)</code> and <code class="literal">$(or)</code>—removing <code class="literal">call</code> to use the built-in operator?</p><p><a id="iddle1061" class="indexterm"/><a id="iddle1101" class="indexterm"/><a id="iddle1146" class="indexterm"/><a id="iddle1259" class="indexterm"/><a id="iddle1733" class="indexterm"/><a id="iddle1902" class="indexterm"/>That is not necessary. GNU <code class="literal">make</code> allows any built-in function to be called with the <code class="literal">call</code> keyword, so both <code class="literal">$(and...)</code> and <code class="literal">$(call and,...)</code> invoke the built-in operator. The opposite, however, is <span class="emphasis"><em>not</em></span> true: it’s not possible to call the <span class="emphasis"><em>user-defined</em></span> function <code class="literal">foo</code> by writing <code class="literal">$(foo arg1,arg2)</code>. You must write <code class="literal">$(call foo,arg1,arg2)</code>.</p><p>So defining your own <code class="literal">and</code> and <code class="literal">or</code> functions, and behaving gracefully in the presence of GNU <code class="literal">make</code> 3.81 or later, requires only the lines shown earlier to define <code class="literal">and</code> and <code class="literal">or</code>—no other changes are necessary.</p><p>Note that there’s an important difference between the built-in functions and user-defined versions. The built-in versions will not evaluate both arguments if the first argument fully determines their truth value. For example, <code class="literal">$(and $a,$b)</code> doesn’t need to look at the value of <code class="literal">$b</code> if <code class="literal">$a</code> is false; <code class="literal">$(or $a,$b)</code> doesn’t need to look at the value of <code class="literal">$b</code> if <code class="literal">$a</code> is true.</p><p>If you need that behavior, you can’t use the preceding user-defined versions because when you do a <code class="literal">$(call)</code> of a function, all the arguments are expanded. The alternative is to replace a <code class="literal">$(call and,X,Y)</code> with <code class="literal">$(if X,$(if Y,T))</code> and <code class="literal">$(call or,X,Y)</code> with <code class="literal">$(if X,T,$(if Y,T))</code>.</p></div></div><div class="sect1" title="Command Detection"><div class="titlepage"><div><div><h1 class="title"><a id="command_detection"/>Command Detection</h1></div></div></div><p>Sometimes it can be useful for a makefile to quickly return an error message if a specific piece of software is missing from the build system. For example, if the makefile needs the program <code class="literal">curl</code>, it can be helpful to determine at parse time, when the makefile is loaded by <code class="literal">make</code>, if <code class="literal">curl</code> is present on the system rather than waiting until partway through a build to discover that it’s not there.</p><p>The simplest way to find out if a command is available is to use the <code class="literal">which</code> command inside a <code class="literal">$(shell)</code> call. This returns an empty string if the command is not found and the path to the command if it is, which works well with <code class="literal">make</code>’s <span class="emphasis"><em>empty string means false, non-empty string means true</em></span> logic.</p><p>So, for example, the following sets <code class="literal">HAVE_CURL</code> to a non-empty string if <code class="literal">curl</code> is present:</p><a id="pro_id00068"/><pre class="programlisting">HAVE_CURL := $(shell which curl)</pre><p>Then you can use <code class="literal">HAVE_CURL</code> to stop the build and output an error if <code class="literal">curl</code> is missing:</p><a id="pro_id00069"/><pre class="programlisting">ifndef HAVE_CURL
$(error curl is missing)
endif</pre><p>The following <code class="literal">assert-command-present</code> function wraps this logic into a single handy function. Calling <code class="literal">assert-command-present</code> with the name of a command causes the build to immediately exit with an error if the <a id="iddle1010" class="indexterm"/><a id="iddle1022" class="indexterm"/><a id="iddle1187" class="indexterm"/><a id="iddle1254" class="indexterm"/><a id="iddle1869" class="indexterm"/>command is missing. The following example uses <code class="literal">assert-command-present</code> to check for the presence of a <code class="literal">curl</code> and a command called <code class="literal">curly</code>:</p><a id="pro_id00070"/><pre class="programlisting">assert-command-present = $(if $(shell which $1),,$(error '$1' missing and needed for this build))

$(call assert-command-present,curl)
$(call assert-command-present,curly)</pre><p>Here’s what happens if you run this code on a system that has <code class="literal">curl</code> but no <code class="literal">curly</code>:</p><a id="pro_id00071"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Makefile:4: *** 'curly' missing and needed for this build. Stop.</pre><p>If a command is used only by certain build targets, it can be useful to only use <code class="literal">assert-command-present</code> for the relevant target. The following makefile will check for the existence of <code class="literal">curly</code> only if the <code class="literal">download</code> target will actually be used as part of the build:</p><a id="pro_id00072"/><pre class="programlisting">all: ; @echo Do all...

download: export _check = $(call assert-command-present,curly)
download: ; @echo Download stuff...</pre><p>The first line of the download target sets a target-specific variable called <code class="literal">_check</code> and exports it to the result of the call to <code class="literal">assert-command-present</code>. This causes the <code class="literal">$(call)</code> to happen only if <code class="literal">download</code> is actually used as part of the build, because the value of <code class="literal">_check</code> will get expanded when it is being prepared for insertion into the environment of the recipe. For example, <code class="literal">make all</code> will not check for the presence of <code class="literal">curly</code>:</p><a id="pro_id00073"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Do all...
$ <span class="strong"><strong>make download</strong></span>
Makefile:5: *** 'curly' missing and needed for this build. Stop.</pre><p>Note that this makefile does define a variable called <code class="literal">_</code>, which you could access as <code class="literal">$(_)</code> or even <code class="literal">$_</code>. Using the underscore as a name is one way to indicate that the variable is just a placeholder, and its value should be ignored.</p></div><div class="sect1" title="Delayed Variable Assignment"><div class="titlepage"><div><div><h1 class="title"><a id="delayed_variable_assignment"/>Delayed Variable Assignment</h1></div></div></div><p>GNU <code class="literal">make</code> offers two ways to define a variable: the simple <code class="literal">:=</code> operator and the recursive <code class="literal">=</code> operator. The simple operator <code class="literal">:=</code> evaluates its right side immediately and uses the resulting value to set the value of a variable. For example:</p><a id="pro_id00074"/><pre class="programlisting">BAR = before
FOO := $(BAR) the rain
BAR = after</pre><p><a id="iddle1263" class="indexterm"/><a id="iddle1675" class="indexterm"/><a id="iddle1750" class="indexterm"/>This snippet results in <code class="literal">FOO</code> having the value <code class="literal">before the rain</code>, because at the time <code class="literal">FOO</code> was set using <code class="literal">:=</code>, <code class="literal">BAR</code> had the value <code class="literal">before</code>.</p><p>In contrast,</p><a id="pro_id00075"/><pre class="programlisting">BAR = before
FOO = $(BAR) the rain
BAR = after</pre><p>This results in <code class="literal">FOO</code> having the value <code class="literal">$(BAR) the rain</code>, and <code class="literal">$(FOO)</code> evaluates to <code class="literal">after the rain</code>. That happens because <code class="literal">=</code> defines a recursive variable (one that can contain references to other variables using the <code class="literal">$()</code> or <code class="literal">${}</code> syntax) whose value is determined every time the variable is used. In contrast, simple variables defined using <code class="literal">:=</code> have a single fixed value determined at the time they were defined by expanding all the variable references straight away.</p><p>Simple variables have a distinct speed advantage because they are fixed strings and don’t need to be expanded each time they are used. They can be tricky to use because it’s common for makefile writers to assume that variables can be set in any order since recursively defined variables (those set with <code class="literal">=</code>) get their final value only when they are used. Nevertheless, simple variables are usually faster to access than recursive variables, and I err on the side of always using <code class="literal">:=</code> if I can.</p><p>But what if you could have the best of both worlds? A variable that gets set only when it is first used but gets to set to a fixed value that doesn’t change. This would be useful if the variable’s value requires a lot of computation but needs to be computed only once at most, and perhaps not at all if the variable never gets used. It is possible to achieve this with the <code class="literal">$(eval)</code> function.</p><p>Consider the following definition:</p><a id="pro_id00076"/><pre class="programlisting">SHALIST = $(shell find . -name '*.c' | xargs shasum)</pre><p>The <code class="literal">SHALIST</code> variable will contain the name and SHA1 cryptographic hash of every <code class="literal">.c</code> file found in the current directory and all subdirectories. This could take a long time to evaluate. And defining <code class="literal">SHALIST</code> using <code class="literal">=</code> means that this expensive call occurs every time you use <code class="literal">SHALIST</code>. If you use it more than once, this could significantly slow down execution of the makefile.</p><p>On the other hand, if you define <code class="literal">SHALIST</code> using <code class="literal">:=</code>, the <code class="literal">$(shell)</code> would only be executed once—but it would happen every time the makefile is loaded. This might be inefficient if the value of <code class="literal">SHALIST</code> is not always needed, like when running <code class="literal">make clean</code>.</p><p>We want a way to define <code class="literal">SHALIST</code> so the <code class="literal">$(shell)</code> doesn’t happen if <code class="literal">SHALIST</code> is never used and is called only once if <code class="literal">SHALIST</code> is. Here’s how to do it:</p><a id="pro_id00077"/><pre class="programlisting">SHALIST = $(eval SHALIST := $(shell find . -name '*.c' | xargs shasum))$(SHALIST)</pre><p><a id="iddle1292" class="indexterm"/><a id="iddle1298" class="indexterm"/><a id="iddle1471" class="indexterm"/><a id="iddle1923" class="indexterm"/><a id="iddle1924" class="indexterm"/><a id="iddle1926" class="indexterm"/>If <code class="literal">$(SHALIST)</code> is ever evaluated, the <code class="literal">$(eval SHALIST := $(shell find . -name '*.c' | xargs shasum))</code> part gets evaluated. Because <code class="literal">:=</code> is being used here, it actually does the <code class="literal">$(shell)</code> and redefines <code class="literal">SHALIST</code> to be result of that call. GNU <code class="literal">make</code> then retrieves the value of <code class="literal">$(SHALIST)</code>, which has just been set by the <code class="literal">$(eval)</code>.</p><p>You can see what’s happening by creating a small makefile that uses the <code class="literal">$(value)</code> function (which shows the definition of a variable without expanding it) to examine the value of <code class="literal">SHALIST</code> without evaluating it:</p><a id="pro_id00078"/><pre class="programlisting">   SHALIST = $(eval SHALIST := $(shell find . -name '*.c' | xargs
   shasum))$(SHALIST)

   $(info Before use SHALIST is: $(value SHALIST))
➊ $(info SHALIST is: $(SHALIST))
   $(info After use SHALIST is: $(value SHALIST))</pre><p>Running that with a single <code class="literal">foo.c</code> file in the directory results in the following output:</p><a id="pro_id00079"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Before use SHALIST is: $(eval SHALIST := $(shell find . -name '*.c' | xargs
shasum))$(SHALIST)
SHALIST is: 3405ad0433933b9b489756cb3484698ac57ce821 ./foo.c
After use SHALIST is: 3405ad0433933b9b489756cb3484698ac57ce821 ./foo.c</pre><p>Clearly, <code class="literal">SHALIST</code> has changed value since the first time it was used at ➊.</p></div><div class="sect1" title="Simple List Manipulation"><div class="titlepage"><div><div><h1 class="title"><a id="simple_list_manipulation"/>Simple List Manipulation</h1></div></div></div><p>In GNU <code class="literal">make</code>, lists elements are separated by spaces. For example, <code class="literal">peter paul and mary</code> is a list with four elements, as is <code class="literal">C:\Documents And Settings\Local User</code>. GNU <code class="literal">make</code> has a several built-in functions for manipulating lists:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="$(firstword)"><span class="title"><strong><span class="strong"><strong><code class="literal">$(firstword)</code></strong></span></strong></span>. Gets the first word in a list.</p></li><li class="listitem"><p title="$(words)"><span class="title"><strong><span class="strong"><strong><code class="literal">$(words)</code></strong></span></strong></span>. Counts the number of list elements.</p></li><li class="listitem"><p title="$(word)"><span class="title"><strong><span class="strong"><strong><code class="literal">$(word)</code></strong></span></strong></span>. Extracts a word at a specific index (counting from 1).</p></li><li class="listitem"><p title="$(wordlist)"><span class="title"><strong><span class="strong"><strong><code class="literal">$(wordlist)</code></strong></span></strong></span>. Extracts a range of words from a list.</p></li><li class="listitem"><p title="$(foreach)"><span class="title"><strong><span class="strong"><strong><code class="literal">$(foreach)</code></strong></span></strong></span>. Lets you iterate over a list.</p></li></ul></div><p>Getting the first element of a list is trivial:</p><a id="pro_id00080"/><pre class="programlisting">MY_LIST = a program for directed compilation
$(info The first word is $(firstword $(MY_LIST)))</pre><p>That would output <code class="literal">The first word is a</code>.</p><p><a id="iddle1305" class="indexterm"/><a id="iddle1454" class="indexterm"/><a id="iddle1474" class="indexterm"/><a id="iddle1853" class="indexterm"/><a id="iddle1925" class="indexterm"/>You can get the last element by counting the number of words in the list, <span class="emphasis"><em>N</em></span>, and then taking the <span class="emphasis"><em>N</em></span>th word. Here’s a <code class="literal">lastword</code> function that returns the last word in a list:</p><a id="pro_id00081"/><pre class="programlisting">➊ lastword = $(if $1,$(word $(words $1),$1))
   MY_LIST = a program for directed compilation
   $(info The last word is $(call lastword,$(MY_LIST)))</pre><p>The <code class="literal">$(if)</code> at ➊ is necessary because if the list were empty, <code class="literal">$(words $1)</code> would be <code class="literal">0</code> and <code class="literal">$(word 0,$1)</code> would generate a fatal error. The preceding example outputs <code class="literal">The last word is compilation</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch01note04"/>Note</h3><p><span class="emphasis"><em>Versions 3.81 and later of GNU <code class="literal">make</code> have a built-in <code class="literal">lastword</code> function, which is quicker than the preceding implementation.</em></span></p></div><p>Chopping the first word off a list is simply a matter of returning a sublist range from the second element to the end. GNU <code class="literal">make</code>’s built-in <code class="literal">$(wordlist</code> <span class="emphasis"><em><code class="literal">S</code></em></span><code class="literal">,</code><span class="emphasis"><em><code class="literal">E</code></em></span><code class="literal">,</code><span class="emphasis"><em><code class="literal">LIST</code></em></span><code class="literal">)</code> function returns a range of list elements from <span class="emphasis"><em><code class="literal">LIST</code></em></span>, starting with the element at index <span class="emphasis"><em><code class="literal">S</code></em></span> and ending at index <span class="emphasis"><em><code class="literal">E</code></em></span> (inclusive):</p><a id="pro_id00082"/><pre class="programlisting">notfirst = $(wordlist 2,$(words $1),$1)
MY_LIST = a program for directed compilation
$(info $(call notfirst,$(MY_LIST)))</pre><p>You don’t have to worry about the empty list in the preceding example, because <code class="literal">$(wordlist)</code> doesn’t complain if its second argument isn’t a valid index. That example outputs <code class="literal">program for directed compilation</code>.</p><p>Chopping the last element off a list requires some more mental gymnastics, because there’s no simple way to do arithmetic in <code class="literal">make</code>: it’s not possible to just write <code class="literal">$(wordlist 1,$(words $1)–1, $1)</code>. Instead, we can define a <code class="literal">notlast</code> function that adds a dummy element to the start of the list and chops off the last element by using the <span class="emphasis"><em>original</em></span> list length as the end index for <code class="literal">$(wordlist)</code>. Then, because we added a dummy element, we need to remember to chop that off by setting the start index for <code class="literal">$(wordlist)</code> at <code class="literal">2</code>:</p><a id="pro_id00083"/><pre class="programlisting">notlast = $(wordlist 2,$(words $1),dummy $1)
MY_LIST = a program for directed compilation
$(info $(call notlast,$(MY_LIST)))</pre><p>And that outputs <code class="literal">a program for directed</code>.</p></div><div class="sect1" title="User-Defined Functions"><div class="titlepage"><div><div><h1 class="title"><a id="user-defined_functions"/>User-Defined Functions</h1></div></div></div><p>This section is about defining <code class="literal">make</code> functions within a makefile. In <a class="xref" href="ch05.html" title="Chapter 5. Pushing the Envelope">Chapter 5</a>, you’ll learn how to modify the source of GNU <code class="literal">make</code> to define even more complex functions using C. We’ve used plenty of user-defined functions in previous sections, but now we’ll take a closer look.</p><div class="sect2" title="The Basics"><div class="titlepage"><div><div><h2 class="title"><a id="basics"/>The Basics</h2></div></div></div><p><a id="iddle1055" class="indexterm"/><a id="iddle1587" class="indexterm"/><a id="iddle1646" class="indexterm"/><a id="iddle1797" class="indexterm"/>Here’s a very simple <code class="literal">make</code> function that takes three arguments and makes a date with them by inserting slashes between the three arguments:</p><a id="pro_id00084"/><pre class="programlisting">make_date = $1/$2/$3</pre><p>To use <code class="literal">make_date</code>, you <code class="literal">$(call)</code> it like this:</p><a id="pro_id00085"/><pre class="programlisting">today := $(call make_date,5,5,2014)</pre><p>That results in <code class="literal">today</code> containing <code class="literal">5/5/2014</code>.</p><p>The function uses the special variables <code class="literal">$1</code>, <code class="literal">$2</code>, and <code class="literal">$3</code>, which contain the arguments specified in the <code class="literal">$(call)</code>. There’s no maximum number of arguments, but if you use more than nine, you need parentheses—that is, you can’t write <code class="literal">$10</code> but instead must use <code class="literal">$(10)</code>. If the function is called with missing arguments, the content of those variables will be undefined and treated as an empty string.</p><p>The special argument <code class="literal">$0</code> contains the name of the function. In the preceding example, <code class="literal">$0</code> is <code class="literal">make_date</code>.</p><p>Because functions are essentially variables that reference some special variables that are created and filled in automatically by GNU <code class="literal">make</code> for you (if you use the <code class="literal">$(origin)</code> function on any of the argument variables [<code class="literal">$1</code>, etc.], they are classed as <code class="literal">automatic</code> just like <code class="literal">$@</code>), you can use built-in GNU <code class="literal">make</code> functions to build up complex functions.</p><p>Here’s a function that uses the <code class="literal">$(subst)</code> function to turn every <code class="literal">/</code> into a <code class="literal">\</code> in a path:</p><a id="pro_id00086"/><pre class="programlisting">unix_to_dos = $(subst /,\,$1)</pre><p>Don’t be worried about the use of <code class="literal">/</code> and <code class="literal">\</code> in this code. GNU <code class="literal">make</code> does very little escaping, and a literal <code class="literal">\</code> is most of the time an actual backslash character. You’ll read more about how <code class="literal">make</code> handles escaping in <a class="xref" href="ch04.html" title="Chapter 4. Pitfalls and Problems">Chapter 4</a>.</p></div><div class="sect2" title="Argument-Handling Gotchas"><div class="titlepage"><div><div><h2 class="title"><a id="argument-handling_gotchas"/>Argument-Handling Gotchas</h2></div></div></div><p><code class="literal">make</code> starts processing a <code class="literal">$(call)</code> by splitting the argument list on commas to set the variables <code class="literal">$1</code>, <code class="literal">$2</code>, and so on. The arguments are then expanded so that these variables are completely expanded before they are ever referenced. It’s as if <code class="literal">make</code> used <code class="literal">:=</code> to set them. If expanding an argument has a side effect, such as calling <code class="literal">$(shell)</code>, that side effect will always occur as soon as the <code class="literal">$(call)</code> is executed, even if the argument never gets used by the function being called.</p><p>One common problem is that the splitting of arguments can go wrong if an argument contains a comma. For example, here’s a simple function that swaps its two arguments:</p><a id="pro_id00087"/><pre class="programlisting">swap = $2 $1</pre><p><a id="iddle1094" class="indexterm"/><a id="iddle1103" class="indexterm"/><a id="iddle1303" class="indexterm"/><a id="iddle1469" class="indexterm"/><a id="iddle1520" class="indexterm"/><a id="iddle1642" class="indexterm"/>If you do <code class="literal">$(call swap,first,argument,second)</code>, <code class="literal">make</code> doesn’t have any way of knowing whether the first argument was meant to be <code class="literal">first,argument</code> or just <code class="literal">first</code>. It will assume the latter and ends up returning <code class="literal">argument first</code> instead of <code class="literal">second first,argument</code>.</p><p>You have two ways around this. First, you could simply hide the first argument inside a variable. Because <code class="literal">make</code> doesn’t expand the arguments until after splitting, a comma inside a variable will not cause any confusion:</p><a id="pro_id00088"/><pre class="programlisting">FIRST := first,argument
SWAPPED := $(call swap,$(FIRST),second)</pre><p>The other approach is to create a simple variable that contains just a comma and use that instead:</p><a id="pro_id00089"/><pre class="programlisting">c := ,
SWAPPED := $(call swap,first$cargument,second)</pre><p>Or even call that <code class="literal">,</code> variable and use it (with parentheses):</p><a id="pro_id00090"/><pre class="programlisting">, := ,
SWAPPED := $(call swap,first$(,)argument,second)</pre><p>As we’ll see in <a class="xref" href="ch04.html" title="Chapter 4. Pitfalls and Problems">Chapter 4</a>, giving variables clever names like <code class="literal">,</code> can be useful but also error prone.</p></div><div class="sect2" title="Calling Built-in Functions"><div class="titlepage"><div><div><h2 class="title"><a id="calling_built-in_functions"/>Calling Built-in Functions</h2></div></div></div><p>It’s possible to use the <code class="literal">$(call)</code> syntax with <code class="literal">make</code>’s built-in functions. For example, you could call <code class="literal">$(info)</code> like this:</p><a id="pro_id00091"/><pre class="programlisting">$(call info,message)</pre><p>This means that you can pass any function name as an argument to a user-defined function and <code class="literal">$(call)</code> it without needing to know whether it’s built in; therefore, it lets you create functions that act on functions. For example, you can create the classic <code class="literal">map</code> function from functional programming, which applies a function to every member of a list and returns the resulting list:</p><a id="pro_id00092"/><pre class="programlisting">map = $(foreach a,$2,$(call $1,$a))</pre><p>The first argument is the function to call, and the second is the list to iterate over. Here’s an example use of <code class="literal">map</code>—iterating over a list of variable names and printing out the defined value and the expanded value of each variable:</p><a id="pro_id00093"/><pre class="programlisting">print_variable = $(info $1 ($(value $1) -&gt; $($1)) )

print_variables = $(call map,print_variable,$1)
VAR1 = foo
VAR2 = $(VAR1)
VAR3 = $(VAR2) $(VAR1)

$(call print_variables,VAR1 VAR2 VAR3)</pre><p><a id="iddle1228" class="indexterm"/><a id="iddle1282" class="indexterm"/><a id="iddle1472" class="indexterm"/><a id="iddle1643" class="indexterm"/><a id="iddle1669" class="indexterm"/><a id="iddle1677" class="indexterm"/><a id="iddle1849" class="indexterm"/>The <code class="literal">print_variable</code> function takes the name of a variable as its first and only argument, and returns a string consisting of the name of the variable, its definition, and its value. The <code class="literal">print_variables</code> function simply applies <code class="literal">print_variable</code> to a list of variables using <code class="literal">map</code>. Here’s the output of the makefile snippet:</p><a id="pro_id00094"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
VAR1 (foo -&gt; foo) VAR2 ($(VAR1) -&gt; foo) VAR3 ($(VAR2) $(VAR1) -&gt; foo foo)</pre><p>Functions in <code class="literal">make</code> can also be recursive: it’s possible for a function to <code class="literal">$(call)</code> itself. The following is a recursive implementation of the <code class="literal">reduce</code> function from functional programming, which takes two arguments: a function that will be called by <code class="literal">reduce</code> and a list to process.</p><a id="pro_id00095"/><pre class="programlisting">reduce = $(if $(strip $2),$(call reduce,$1,$(wordlist 2,$(words $2),$2), \
$(call $1,$(firstword $2),$3)),$3)</pre><p>The first argument (the function) is repeatedly called with two arguments: the next element of the list is <code class="literal">reduce</code>’s second argument and the result of the previous call to the function.</p><p>To see this in action, here’s a <code class="literal">uniq</code> function that removes duplicates from a list:</p><a id="pro_id00096"/><pre class="programlisting">check_uniq = $(if $(filter $1,$2),$2,$2 $1)
uniq = $(call reduce,check_uniq,$1)
$(info $(call uniq,c b a a c c b a c b a))</pre><p>The output here is <code class="literal">c b a</code>. This works because <code class="literal">reduce</code> will call <code class="literal">check_uniq</code> with each member of the input list, building up a new list from the result of <code class="literal">check_uniq</code>. The <code class="literal">check_uniq</code> function just determines whether an element is present in the given list (using the built-in function <code class="literal">filter</code>) and, if not present, returns the list with the element appended.</p><p>To see that in action, here’s a modified version that uses <code class="literal">$(info)</code> to output the arguments sent to <code class="literal">check_uniq</code> on each invocation:</p><a id="pro_id00097"/><pre class="programlisting">check_uniq = $(info check_uniq ($1) ($2))$(if $(filter $1,$2),$2,$2 $1)
uniq = $(call reduce,check_uniq,$1)
$(info $(call uniq,c b a a c c b a c b a))</pre><p>And here’s the output:</p><a id="pro_id00098"/><pre class="programlisting">$ make
check_uniq (c) ()
check_uniq (b) ( c)
check_uniq (a) ( c b)
check_uniq (a) ( c b a)
check_uniq (c) ( c b a)
check_uniq (c) ( c b a)
check_uniq (b) ( c b a)
check_uniq (a) ( c b a)
check_uniq (c) ( c b a)
check_uniq (b) ( c b a)
check_uniq (a) ( c b a)
c b a</pre><p><a id="iddle1017" class="indexterm"/><a id="iddle1074" class="indexterm"/><a id="iddle1349" class="indexterm"/><a id="iddle1509" class="indexterm"/><a id="iddle1559" class="indexterm"/><a id="iddle1634" class="indexterm"/><a id="iddle1692" class="indexterm"/><a id="iddle1699" class="indexterm"/><a id="iddle1759" class="indexterm"/>If you don’t need to preserve order, then using the built-in <code class="literal">$(sort)</code> function will be faster than this user-defined function since it also removes duplicates.</p></div></div><div class="sect1" title="Recent GNU make Versions: 3.81, 3.82, and 4.0"><div class="titlepage"><div><div><h1 class="title"><a id="recent_gnu_make_versions_3dot81comma_3do"/>Recent GNU make Versions: 3.81, 3.82, and 4.0</h1></div></div></div><p>GNU <code class="literal">make</code> changes slowly, and new releases (both major and minor) become available only every few years. Because of this slow release cycle, it’s common to come across older versions of GNU <code class="literal">make</code> and useful to know the differences between them. This section assumes that the oldest common version in use is 3.79.1 (which was released on June 23, 2000) and highlights major changes in releases 3.81, 3.82, and 4.0.</p><div class="sect2" title="What’s New in GNU make 3.81"><div class="titlepage"><div><div><h2 class="title"><a id="whatapostrophes_new_in_gnu_make_3dot81"/>What’s New in GNU make 3.81</h2></div></div></div><p>GNU <code class="literal">make</code> 3.81 was released on April 1, 2006, three and a half years after the last version (GNU <code class="literal">make</code> 3.80), and it was packed with goodies: support for OS/2, a new command line option, new built-in variables, new conditionals, and new functions. For a complete list of changes, see the <span class="emphasis"><em>NEWS</em></span> file in the GNU <code class="literal">make</code> 3.81 source code distribution.</p><div class="sect3" title=".SECONDEXPANSION"><div class="titlepage"><div><div><h3 class="title"><a id="dotsecondexpansion"/>.SECONDEXPANSION</h3></div></div></div><p>One frustrating problem users of GNU <code class="literal">make</code> run into is that the automatic variables are valid and assigned only when a rule’s commands are run; they are not valid as part of the rule definition. For example, it’s not possible to write <code class="literal">foo: $@.c</code> to mean that <code class="literal">foo</code> should be made from <code class="literal">foo.c</code>, even though <code class="literal">$@</code> will have the value <code class="literal">foo</code> when that rule’s commands are executed. That’s frustrating, because it would be nice to not have to repeat yourself like this:</p><a id="pro_id00099"/><pre class="programlisting">foo:foo.c</pre><p>Before version 3.81, GNU <code class="literal">make</code> supported using <code class="literal">$$@</code> (note the two <code class="literal">$</code> signs) in the prerequisite list of a rule (this syntax comes from SysV <code class="literal">make</code>). For example, it was possible to say <code class="literal">foo: $$@.c</code>, and it was equivalent to <code class="literal">foo: foo.c</code>. That is, <code class="literal">$$@</code> had the value that <code class="literal">$@</code> has in the rule’s commands. To get that functionality in GNU <code class="literal">make</code> 3.81 and later, you must define <code class="literal">.SECONDEXPANSION</code> in the makefile. As a bonus, GNU <code class="literal">make</code> supports all the standard automatic variables in the rule definition (although note that automatic variables like <a id="iddle1112" class="indexterm"/><a id="iddle1235" class="indexterm"/><a id="iddle1456" class="indexterm"/><a id="iddle1856" class="indexterm"/><code class="literal">$$</code> will always be blank because they cannot be computed when the makefile is being parsed). This happens because GNU <code class="literal">make</code> will expand the prerequisite list of a rule twice: once when it reads the makefile and once again when searching for what to make.</p><p>You can use second expansion for more than just automatic variables. User-defined variables can also be <span class="emphasis"><em>second expanded</em></span>, and they’ll end up getting the last value to which they were defined in the makefile. For example, you can do the following:</p><a id="pro_id00100"/><pre class="programlisting">.SECONDEXPANSION:

FOO = foo

all: $$(FOO)
all: ; @echo Making $@ from $?

bar: ; @echo Making $@

FOO = bar</pre><p>This gives the following output:</p><a id="pro_id00101"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Making bar
Making all from bar</pre><p>When the makefile was read, <code class="literal">all: $$(FOO)</code> was expanded to <code class="literal">all: $(FOO)</code>. Later, when figuring out how to build <code class="literal">all</code>, <code class="literal">$(FOO)</code> was expanded to <code class="literal">bar</code>—that is, the value <code class="literal">FOO</code> had when makefile parsing ended. Note that if you enable <code class="literal">.SECONDEXPANSION</code> and have filenames with <code class="literal">$</code>s in them, the <code class="literal">$</code>s will need to be escaped by writing <code class="literal">$$</code>.</p><div class="sect4" title="else"><div class="titlepage"><div><div><h4 class="title"><a id="else"/>else</h4></div></div></div><p>Another feature introduced in GNU <code class="literal">make</code> 3.81 was support for non-nested <code class="literal">else</code> branches by having the conditional on the same line as the <code class="literal">else</code>. For example, it’s possible to write:</p><a id="pro_id00102"/><pre class="programlisting">ifdef FOO
$(info FOO defined)
else ifdef BAR
$(info BAR defined)
else
$(info BAR not defined)
endif</pre><p>That syntax will be familiar to anyone who has used a language that supports <code class="literal">else if</code>, <code class="literal">elseif</code>, or <code class="literal">elsif</code>. This is GNU <code class="literal">make</code>’s way of having <code class="literal">else</code> and <code class="literal">if</code> on the same line.</p><p><a id="iddle1206" class="indexterm"/><a id="iddle1270" class="indexterm"/><a id="iddle1273" class="indexterm"/>Previously, the code would have looked like this:</p><a id="pro_id00103"/><pre class="programlisting">ifdef FOO
$(info FOO defined)
else
ifdef BAR
$(info BAR defined)
else
$(info BAR not defined)
endif
endif</pre><p>That’s a lot messier and much harder to read than the version with nonnested <code class="literal">else</code> branches.</p></div><div class="sect4" title="The -L Command Line Option"><div class="titlepage"><div><div><h4 class="title"><a id="l_command_line_option"/>The -L Command Line Option</h4></div></div></div><p>The command line option <code class="literal">-L</code> (and its long equivalent, <code class="literal">--check-symlink-times</code>) causes <code class="literal">make</code> to consider the modification time of the symlink and the modification time of the file pointed to by the symlink as GNU <code class="literal">make</code> decides which files need to be remade. Whichever is more recent is taken as the modification time. This can be useful if a build uses symlinks to point to different versions of source files because changing the symlink will change the modification time and force a rebuild.</p></div></div><div class="sect3" title=".INCLUDE_DIRS"><div class="titlepage"><div><div><h3 class="title"><a id="dotincludeunderscoredirs"/>.INCLUDE_DIRS</h3></div></div></div><p>The <code class="literal">.INCLUDE_DIRS</code> variable contains the list of directories that <code class="literal">make</code> will search when looking for makefiles that are included using the <code class="literal">include</code> directive. This variable is set by the standard list of directories built into GNU <code class="literal">make</code> and can be modified by the <code class="literal">-I</code> command line option. Although it’s possible to change the value of <code class="literal">.INCLUDE_DIRS</code> in the actual makefile with <code class="literal">=</code> or <code class="literal">:=</code>, this has no effect on how GNU <code class="literal">make</code> searches for makefiles.</p><p>For example, running <code class="literal">make -I /usr/foo</code> on Linux with the following makefile outputs <code class="literal">/usr/foo /usr/local/include /usr/local/include /usr/include</code>:</p><a id="pro_id00104"/><pre class="programlisting">$(info $(.INCLUDE_DIRS))
all: ; @true</pre></div><div class="sect3" title=".FEATURES"><div class="titlepage"><div><div><h3 class="title"><a id="dotfeatures-id00001"/>.FEATURES</h3></div></div></div><p>The <code class="literal">.FEATURES</code> variable expands to a list of features that GNU <code class="literal">make</code> supports and can be used to determine if a specific feature is available. With GNU <code class="literal">make</code> 3.81 on Linux, the list of <code class="literal">.FEATURES</code> is <code class="literal">target-specific order-only second-expansion else-if archives jobserver check-symlink</code>. This means that GNU <code class="literal">make</code> 3.81 supports target- and pattern-specific variables, has orderonly prerequisites, supports second-expansion (<code class="literal">.SECONDEXPANSION</code>), supports <code class="literal">else if</code> non-nested conditionals, supports <code class="literal">ar</code> files, supports parallel making using the job server, and supports the new <code class="literal">-L</code> command line option for checking symlinks.</p><p><a id="iddle1095" class="indexterm"/><a id="iddle1184" class="indexterm"/><a id="iddle1283" class="indexterm"/><a id="iddle1430" class="indexterm"/><a id="iddle1518" class="indexterm"/><a id="iddle1782" class="indexterm"/>To test whether a specific feature is available, you can use <code class="literal">$(filter)</code>. For example:</p><a id="pro_id00105"/><pre class="programlisting">has-order-only := $(filter order-only,$(.FEATURES))</pre><p>This line sets <code class="literal">has-order-only</code> to true if the version of <code class="literal">make</code> running has order-only prerequisite support. This isn’t backward compatible, though; for example, <code class="literal">.FEATURES</code> would expand to an empty list in GNU <code class="literal">make</code> 3.80, indicating that target-specific variables are not available even though they are. A backward compatible check would first need to determine whether <code class="literal">.FEATURES</code> is present by seeing if it is non-blank.</p></div><div class="sect3" title=".DEFAULT_GOAL"><div class="titlepage"><div><div><h3 class="title"><a id="dotdefaultunderscoregoal"/>.DEFAULT_GOAL</h3></div></div></div><p>Normally, if no goal is specified on the command line, <code class="literal">make</code> will build the first target it sees in the first makefile it parses. It’s possible to override this behavior by setting the <code class="literal">.DEFAULT_GOAL</code> variable anywhere in a makefile. For example, the following makefile will build <code class="literal">all</code> when run with no goal on the command line, despite the fact that the first target encountered is called <code class="literal">fail</code>:</p><a id="pro_id00106"/><pre class="programlisting">fail: ; $(error wrong)
.DEFAULT_GOAL = all
all: ; $(info right)</pre><p>The <code class="literal">.DEFAULT_GOAL</code> variable can also be read to get the current default goal; if set to blank (<code class="literal">.DEFAULT_GOAL :=</code>), <code class="literal">make</code> will automatically pick the next target it encounters as the default goal.</p></div><div class="sect3" title="MAKE_RESTARTS"><div class="titlepage"><div><div><h3 class="title"><a id="makeunderscorerestarts"/>MAKE_RESTARTS</h3></div></div></div><p>The <code class="literal">MAKE_RESTARTS</code> variable is the count of the number of times that <code class="literal">make</code> has restarted while performing makefile <span class="emphasis"><em>remaking</em></span>. GNU <code class="literal">make</code> has a special feature that allows makefiles to be rebuilt by <code class="literal">make</code>. This remaking happens automatically when any makefile is included with <code class="literal">include</code>, as well as to the makefile <code class="literal">make</code> first started with, and any set with the <code class="literal">-f</code> command line option. <code class="literal">make</code> searches to see if there’s a rule to rebuild any of the makefiles. If it finds one, the makefile is rebuilt just like any other file <code class="literal">make</code> is capable of building, and GNU <code class="literal">make</code> restarts.</p><p>If GNU <code class="literal">make</code> has not restarted, <code class="literal">MAKE_RESTARTS</code> is blank, not <code class="literal">0</code>.</p><div class="sect4" title="New Functions"><div class="titlepage"><div><div><h4 class="title"><a id="new_functions"/>New Functions</h4></div></div></div><p>GNU <code class="literal">make</code> 3.81 also introduced a variety of built-in functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title="$(info text)"><span class="title"><strong><span class="strong"><strong><code class="literal">$(info</code> <span class="emphasis"><em><code class="literal">text</code></em></span><code class="literal">)</code></strong></span></strong></span>. This function is like the existing <code class="literal">$(warning)</code> function, but it prints the expanded <span class="emphasis"><em><code class="literal">text</code></em></span> argument to <code class="literal">STDOUT</code> without reporting the makefile and line number. For example, the following makefile generates the output <code class="literal">Hello, World!</code>:</p><a id="pro_id00107"/><pre class="programlisting">$(info Hello, World!)
all: ; @true</pre></li><li class="listitem"><p title="$(lastword LIST)"><span class="title"><strong><span class="strong"><strong><code class="literal">$(lastword</code> <span class="emphasis"><em><code class="literal">LIST</code></em></span><code class="literal">)</code></strong></span></strong></span>. <a id="iddle1041" class="indexterm"/><a id="iddle1051" class="indexterm"/><a id="iddle1295" class="indexterm"/><a id="iddle1452" class="indexterm"/><a id="iddle1455" class="indexterm"/><a id="iddle1560" class="indexterm"/><a id="iddle1583" class="indexterm"/><a id="iddle1660" class="indexterm"/><a id="iddle1874" class="indexterm"/>This function returns the last word of a GNU <code class="literal">make</code> list. Previously this was possible by writing <code class="literal">$(word $(words</code> <span class="emphasis"><em><code class="literal">LIST</code></em></span><code class="literal">),</code><span class="emphasis"><em><code class="literal">LIST</code></em></span><code class="literal">)</code>, but <code class="literal">$(lastword)</code> is more efficient. If you are using the GNU Make Standard Library (GMSL), there’s a function called <code class="literal">last</code>, which is the same as <code class="literal">$(lastword)</code>. If you are using GNU <code class="literal">make</code> 3.81 and GMSL 1.0.6 or later, <code class="literal">last</code> automatically uses the built-in <code class="literal">lastword</code> for speed.</p></li><li class="listitem"><p title="$(flavor VAR)"><span class="title"><strong><span class="strong"><strong><code class="literal">$(flavor</code> <span class="emphasis"><em><code class="literal">VAR</code></em></span><code class="literal">)</code></strong></span></strong></span>. This function returns the flavor of a variable (either <code class="literal">recursive</code> for recursively expanded or <code class="literal">simple</code> for simply expanded). For example, the following makefile prints that <code class="literal">REC</code> is recursive and <code class="literal">SIM</code> is simple:</p><a id="pro_id00108"/><pre class="programlisting">REC = foo
SIM := foo
$(info REC is $(flavor REC))
$(info SIM is $(flavor SIM))

all: ; @true</pre></li><li class="listitem"><p title="$(or arg1 arg2 ...) and $(and)"><span class="title"><strong><span class="strong"><strong><code class="literal">$(or</code> <span class="emphasis"><em><code class="literal">arg1 arg2</code></em></span> <code class="literal">...) and $(and)</code></strong></span></strong></span>. <code class="literal">$(or)</code> returns a non-blank string if any of its arguments is non-blank, whereas <code class="literal">$(and)</code> returns a non-blank string if and only if all of its arguments are non-blank. If you are using the GMSL, <code class="literal">and</code> and <code class="literal">or</code> functions are part of the library. If you are using GNU <code class="literal">make</code> 3.81 and GMSL 1.0.6 or later, the new built-in functions are <span class="emphasis"><em>not</em></span> overridden with the GMSL versions, which means that makefiles that use GMSL are fully backward- and forward-compatible with GNU <code class="literal">make</code> 3.81.</p></li><li class="listitem"><p title="$(abspath DIR)"><span class="title"><strong><span class="strong"><strong><code class="literal">$(abspath DIR)</code></strong></span></strong></span>. This function returns the absolute path of <code class="literal">DIR</code> relative to the directory that GNU <code class="literal">make</code> was started in (taking into account any <code class="literal">-C</code> command line options). The path has all <code class="literal">.</code> and <code class="literal">..</code> elements resolved and duplicate slashes removed. Note that GNU <code class="literal">make</code> does not check whether the path <span class="emphasis"><em>exists</em></span>; it just resolves the path elements to make an absolute path. For example, the following makefile prints <code class="literal">/home/jgc/bar</code> on my machine when it’s placed in <span class="emphasis"><em>/home/jgc</em></span>:</p><a id="pro_id00109"/><pre class="programlisting">$(info $(abspath foo/./..//////bar))

all: ; @true</pre></li><li class="listitem"><p title="$(realpath DIR)"><span class="title"><strong><span class="strong"><strong><code class="literal">$(realpath DIR)</code></strong></span></strong></span>. This function returns the same result as <code class="literal">$(abspath DIR)</code> except that any symbolic links are resolved. For example, if <code class="literal">bar</code> is symlinked to <code class="literal">over-here</code>, the following makefile would return <code class="literal">/home/jgc/ over-here</code> if read from <span class="emphasis"><em>/home/jgc</em></span>:</p><a id="pro_id00110"/><pre class="programlisting">$(info $(realpath ../jgc/./bar))

all: ; @true</pre></li></ul></div></div></div></div><div class="sect2" title="What’s New in GNU make 3.82"><div class="titlepage"><div><div><h2 class="title"><a id="whatapostrophes_new_in_gnu_make_3dot82"/>What’s New in GNU make 3.82</h2></div></div></div><p><a id="iddle1019" class="indexterm"/><a id="iddle1075" class="indexterm"/><a id="iddle1106" class="indexterm"/><a id="iddle1123" class="indexterm"/><a id="iddle1234" class="indexterm"/><a id="iddle1258" class="indexterm"/><a id="iddle1351" class="indexterm"/><a id="iddle1541" class="indexterm"/><a id="iddle1630" class="indexterm"/><a id="iddle1635" class="indexterm"/><a id="iddle1913" class="indexterm"/>GNU <code class="literal">make</code> 3.82 was released four years after 3.81 and introduced a number of new features—as well as several backward incompatibilities.</p><div class="sect3" title="Backward Incompatibilities"><div class="titlepage"><div><div><h3 class="title"><a id="backward_incompatibilities"/>Backward Incompatibilities</h3></div></div></div><p>The <span class="emphasis"><em>NEWS</em></span> file for GNU <code class="literal">make</code> 3.82 starts with seven backward-incompatibility warnings. Here’s a quick overview:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In GNU <code class="literal">make</code>, the shell that executes a rule’s commands is invoked with the <code class="literal">-c</code> command line option, which tells the shell to read the command to be executed from the first non-parameter argument to the shell. For example, when the following small rule is executed, <code class="literal">make</code> actually executes <code class="literal">execve("/bin/sh", ["/bin/sh", "-c", "echo \"hello\""], ...)</code>. To run the <code class="literal">echo "hello"</code>, <code class="literal">make</code> uses the shell <code class="literal">/bin/sh</code> and adds the <code class="literal">-c</code> command line option to it.</p><a id="pro_id00111"/><pre class="programlisting">all: ; @echo "hello"</pre><p>But the POSIX standard for <code class="literal">make</code> was changed in 2008 to require that <code class="literal">-e</code> must be specified on the shell command line. The default behavior of GNU <code class="literal">make</code> 3.82 and later is to not pass <code class="literal">-e</code> unless the <code class="literal">.POSIX</code> special target is specified. Anyone using this target in a makefile needs to watch out for this change.</p></li><li class="listitem"><p>The <code class="literal">$?</code> automatic variable includes the name of all prerequisites to a target that caused a rebuild, <span class="emphasis"><em>even if they do not exist</em></span>. Previously, any prerequisites that did not exist were not placed into <code class="literal">$?</code>.</p></li><li class="listitem"><p>The <code class="literal">$(wildcard)</code> function had always returned a sorted list of files, but this was never actually documented. This behavior changed in GNU <code class="literal">make</code> 3.82 so that any makefile relying on a sorted list from <code class="literal">$(wildcard)</code> needs to wrap it in a call to <code class="literal">$(sort)</code>; for example, do <code class="literal">$(sort $(wildcard *.c))</code> to get a sorted list of <code class="literal">.c</code> files.</p></li><li class="listitem"><p>It used to be possible to write a rule that mixed pattern targets and explicit targets, like this:</p><a id="pro_id00112"/><pre class="programlisting">myfile.out %.out: ; @echo Do stuff with $@</pre><p>This had been undocumented and was completely removed in GNU <code class="literal">make</code> 3.81, because it was never intended to work. It now results in an error message.</p></li><li class="listitem"><p>It’s no longer possible to have a prerequisite that contains an <code class="literal">=</code> sign, even when escaped with <code class="literal">\</code>. For example, the following no longer works:</p><a id="pro_id00113"/><pre class="programlisting">all: odd\=name

odd%: ; @echo Make $@</pre><p><a id="iddle1550" class="indexterm"/><a id="iddle1691" class="indexterm"/><a id="iddle1745" class="indexterm"/><a id="iddle1890" class="indexterm"/><a id="iddle1910" class="indexterm"/>If you need an equal sign in a target or prerequisite name, first define a variable that expands to <code class="literal">=</code>, like so:</p><a id="pro_id00114"/><pre class="programlisting">eq := =

all: odd$(eq)name
odd%: ; @echo Make $@</pre></li><li class="listitem"><p>Variable names can’t contain whitespace in GNU <code class="literal">make</code> 3.82. It was previously possible to do this:</p><a id="pro_id00115"/><pre class="programlisting">has space := variable with space in name
$(info $(has space))</pre><p>If you need a variable with a space in its name, first define another variable that contains just a space and use it as follows. But watch out; this sort of thing can be dangerous and hard to debug.</p><a id="pro_id00116"/><pre class="programlisting">sp :=
sp +=
has$(sp)space := variable with space in name

$(info $(has space))</pre></li><li class="listitem"><p>The order in which pattern rules and pattern-specific variables are applied used to be in the order in which they were found in the makefile. This changed in GNU <code class="literal">make</code> 3.82: they are now applied in <code class="literal">'shortest stem'</code> order. For example, the following makefile shows how different pattern rules are used with GNU <code class="literal">make</code> 3.81 and 3.82.</p><a id="pro_id00117"/><pre class="programlisting">all: output.o

out%.o: ; @echo Using out%.o rule
outp%.o: ; @echo Using outp%.o rule</pre><p>The <span class="emphasis"><em>stem</em></span> is the part of the pattern that is matched by the <code class="literal">%</code>. In GNU <code class="literal">make</code> 3.81 and earlier, the <code class="literal">out%.o</code> rule matches because it is defined first:</p><a id="pro_id00118"/><pre class="programlisting">$ make-3.81
Using out%.o rule</pre><p>In GNU <code class="literal">make</code> 3.82 and later, the <code class="literal">outp%.o</code> rule is used because the stem is shorter:</p><a id="pro_id00119"/><pre class="programlisting">$ make-3.82
Using outp%.o rule</pre><p>Similar behavior occurs with pattern-specific variables.</p></li></ul></div></div><div class="sect3" title="New Command Line Option: --eval"><div class="titlepage"><div><div><h3 class="title"><a id="new_command_line_option_--eval"/>New Command Line Option: --eval</h3></div></div></div><p><a id="iddle1262" class="indexterm"/><a id="iddle1578" class="indexterm"/><a id="iddle1665" class="indexterm"/><a id="iddle1735" class="indexterm"/><a id="iddle1738" class="indexterm"/><a id="iddle1808" class="indexterm"/><a id="iddle1876" class="indexterm"/><a id="iddle1909" class="indexterm"/>The new <code class="literal">--eval</code> command line option causes <code class="literal">make</code> to run its argument through <code class="literal">$(eval)</code> before parsing makefiles. For example, if you have this makefile and run <code class="literal">make --eval=FOO=bar</code>, you’ll see the output <code class="literal">FOO has value bar</code>.</p><a id="pro_id00120"/><pre class="programlisting">all: ; @echo FOO has value $(FOO)</pre><p>This is because before the makefile is parsed, the line <code class="literal">FOO=bar</code> is treated as if it were the first line in the makefile and it sets <code class="literal">FOO</code> to <code class="literal">bar.</code></p></div><div class="sect3" title="New Special Variables: .RECIPEPREFIX and .SHELLFLAGS"><div class="titlepage"><div><div><h3 class="title"><a id="new_special_variables_dotrecipeprefix_an"/>New Special Variables: .RECIPEPREFIX and .SHELLFLAGS</h3></div></div></div><p>GNU <code class="literal">make</code> 3.82 introduced two new special variables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p title=".RECIPEPREFIX"><span class="title"><strong><span class="strong"><strong><code class="literal">.RECIPEPREFIX</code></strong></span></strong></span>. GNU <code class="literal">make</code> uses a <code class="literal">TAB</code> character as significant whitespace to start the commands in a rule. You can change this with the <code class="literal">.RECIPEPREFIX</code> variable. (If <code class="literal">.RECIPEPREFIX</code> is an empty string, then <code class="literal">TAB</code> is used). For example:</p><a id="pro_id00121"/><pre class="programlisting">.RECIPEPREFIX = &gt;

all:
&gt; @echo Making all</pre><p>Also, <code class="literal">.RECIPEPREFIX</code> can be changed over and over again in a makefile as needed.</p></li><li class="listitem"><p title=".SHELLFLAGS"><span class="title"><strong><span class="strong"><strong><code class="literal">.SHELLFLAGS</code></strong></span></strong></span>. This variable contains the parameters sent to the shell when a rule’s commands are run. By default it is <code class="literal">-c</code> (or <code class="literal">-ec</code> if <code class="literal">.POSIX:</code> is specified in the makefile). It can be read or changed if a different shell is being used.</p></li></ul></div></div><div class="sect3" title="The .ONESHELL Target"><div class="titlepage"><div><div><h3 class="title"><a id="dotoneshell_target"/>The .ONESHELL Target</h3></div></div></div><p>When a rule’s commands are executed, each line is sent to the shell as a separate shell invocation. With GNU <code class="literal">make</code> 3.82, a new special target called <code class="literal">.ONESHELL</code> changes this behavior. If <code class="literal">.ONESHELL:</code> is set in the makefile, a single shell invocation is used for all the lines in a rule. For example:</p><a id="pro_id00122"/><pre class="programlisting">all:
→ @cd /tmp
→ @pwd</pre><p>This does not output <code class="literal">/tmp</code> (unless <code class="literal">make</code> was started in <span class="emphasis"><em>/tmp</em></span>) because each line is executed in a separate shell. But with the <code class="literal">.ONESHELL</code> special target, both lines are executed in the same shell and <code class="literal">pwd</code> will output <code class="literal">/tmp</code>.</p><a id="pro_id00123"/><pre class="programlisting">.ONESHELL:
all:
→ @cd /tmp
→ @pwd</pre></div><div class="sect3" title="Changing Variables with the private and undefine Keywords"><div class="titlepage"><div><div><h3 class="title"><a id="changing_variables_with_the_private_and"/>Changing Variables with the private and undefine Keywords</h3></div></div></div><p><a id="iddle1128" class="indexterm"/><a id="iddle1129" class="indexterm"/><a id="iddle1185" class="indexterm"/><a id="iddle1241" class="indexterm"/><a id="iddle1296" class="indexterm"/><a id="iddle1645" class="indexterm"/><a id="iddle1847" class="indexterm"/><a id="iddle1879" class="indexterm"/><a id="iddle1889" class="indexterm"/>A target-specific variable is normally defined for a target and all its prerequisites. But if the target-specific variable is prefixed with the keyword <code class="literal">private</code>, it is defined only for that target, <span class="emphasis"><em>not</em></span> its prerequisites.</p><p>In the following makefile, <code class="literal">DEBUG</code> is only set to <code class="literal">1</code> for the <code class="literal">foo.o</code> target because it is marked as <code class="literal">private:</code></p><a id="pro_id00124"/><pre class="programlisting">DEBUG=0

foo.o: private DEBUG=1
foo.o: foo.c
→ @echo DEBUG is $(DEBUG) for $@

foo.c: foo.in
→ @echo DEBUG is $(DEBUG) for $@</pre><p>Another new keyword in GNU <code class="literal">make</code> 3.82 is <code class="literal">undefine</code>, which makes it possible to undefine a variable:</p><a id="pro_id00125"/><pre class="programlisting">SPECIAL_FLAGS := xyz
$(info SPECIAL_FLAGS $(SPECIAL_FLAGS))
undefine SPECIAL_FLAGS
$(info SPECIAL_FLAGS $(SPECIAL_FLAGS))</pre><p>You can detect the difference between an empty variable and an undefined variable using the <code class="literal">$(flavor)</code> function. For example, the following outputs <code class="literal">simple</code> and then <code class="literal">undefined</code>:</p><a id="pro_id00126"/><pre class="programlisting">EMPTY :=
$(info $(flavor EMPTY))
undefine EMPTY
$(info $(flavor EMPTY))</pre><p>In versions of GNU <code class="literal">make</code> prior to 3.82, the <code class="literal">define</code> directive (which is used to define a multiline variable) would always create a recursively defined variable. For example, <code class="literal">COMMANDS</code> here would be a recursive variable, getting expanded at each use:</p><a id="pro_id00127"/><pre class="programlisting">FILE = foo.c

define COMMANDS
wc -l $(FILE)
shasum $(FILE)
endef</pre><p>In GNU 3.82 it’s possible to add an optional <code class="literal">=</code>, <code class="literal">:=</code>, or <code class="literal">+=</code> after the variable name in a <code class="literal">define</code> statement. The default behavior is for the new variable to be recursively expanded each time; this is the same as adding an <code class="literal">=</code>. Adding a <code class="literal">:=</code> creates a simple variable, expanding the body of the <code class="literal">define</code> at definition time. And adding <code class="literal">+=</code> appends multiple lines to an existing variable.</p><p><a id="iddle1231" class="indexterm"/><a id="iddle1340" class="indexterm"/><a id="iddle1343" class="indexterm"/><a id="iddle1353" class="indexterm"/><a id="iddle1398" class="indexterm"/><a id="iddle1400" class="indexterm"/><a id="iddle1467" class="indexterm"/><a id="iddle1481" class="indexterm"/><a id="iddle1590" class="indexterm"/><a id="iddle1864" class="indexterm"/>The following makefile creates a simple variable called <code class="literal">COMMANDS</code> and then adds lines to it:</p><a id="pro_id00128"/><pre class="programlisting">   FILE = foo.c

   define COMMANDS :=
   wc -l $(FILE)
   shasum $(FILE)
   endef

   define COMMANDS +=
➊
   wc -c $(FILE)
   endef
   $(info $(COMMANDS))</pre><p>Notice the extra blank line at ➊. It’s necessary for the <code class="literal">wc -c $(FILE)</code> to appear on a new line after the <code class="literal">shasum $(FILE)</code>. Without it the <code class="literal">wc -c $(FILE)</code> would get appended to <code class="literal">shasum $(FILE)</code> without a newline.</p></div></div><div class="sect2" title="What’s New in GNU make 4.0"><div class="titlepage"><div><div><h2 class="title"><a id="whatapostrophes_new_in_gnu_make_4dot0"/>What’s New in GNU make 4.0</h2></div></div></div><p>The release of GNU <code class="literal">make</code> 4.0 introduced two major features: integration with the GNU Guile language and an experimental option to dynamically load objects to expand <code class="literal">make</code>’s functionality at runtime. In addition, new command line options are especially helpful for debugging.</p><div class="sect3" title="GNU Guile"><div class="titlepage"><div><div><h3 class="title"><a id="gnu_guile"/>GNU Guile</h3></div></div></div><p>The biggest change in GNU <code class="literal">make</code> 4.0 is the new <code class="literal">$(guile)</code> function, whose argument is code written in the GNU Guile language. The code is executed and its return value is converted to a string, which gets returned by the <code class="literal">$(guile)</code> function.</p><p>The ability to drop into another language adds enormous functionality to GNU <code class="literal">make</code>. The following is a simple example of using Guile to check whether a file exists:</p><a id="pro_id00129"/><pre class="programlisting">$(if $(guile (access? "foo.c" R_OK)),$(info foo.c exists))</pre><p>Using GNU Guile inside GNU <code class="literal">make</code> is covered in further detail in <a class="xref" href="ch05.html" title="Chapter 5. Pushing the Envelope">Chapter 5</a>.</p></div><div class="sect3" title="Loading Dynamic Objects"><div class="titlepage"><div><div><h3 class="title"><a id="loading_dynamic_objects"/>Loading Dynamic Objects</h3></div></div></div><p>We don’t use the <code class="literal">load</code> operator in this book to define functions in C, but defining functions in C and loading dynamic objects are explained in <a class="xref" href="ch05.html" title="Chapter 5. Pushing the Envelope">Chapter 5</a>.</p></div><div class="sect3" title="Syncing Output with --output-sync"><div class="titlepage"><div><div><h3 class="title"><a id="syncing_output_with_--output-sync"/>Syncing Output with --output-sync</h3></div></div></div><p>If you use recursive <code class="literal">make</code> or use the job server to run rules in parallel, the output produced by <code class="literal">make</code> can be very hard to read because output from different rules and sub-makes gets intermingled.</p><p>Consider the following (slightly contrived) makefile:</p><a id="pro_id00130"/><pre class="programlisting">all: one two three four

one two:
→ @echo $@ line start
→ @sleep 0.1s
→ @echo $@ line middle
→ @echo $@ line finish

three four:
→ @echo $@ line start
→ @sleep 0.2s
→ @echo $@ line middle
→ @echo $@ line finish</pre><p>This makefile contains four targets: <code class="literal">one</code>, <code class="literal">two</code>, <code class="literal">three</code>, and <code class="literal">four</code>. The targets will be built in parallel if you use the <code class="literal">-j</code> option. Two calls to <code class="literal">sleep</code> have been added to simulate commands that get executed for different lengths of time.</p><p>When run with the <code class="literal">-j4</code> option, which runs four jobs in parallel, the output might look like this:</p><a id="pro_id00131"/><pre class="programlisting">$ <span class="strong"><strong>make -j4</strong></span>
one line start
three line start
four line start
two line start
one line middle
two line middle
one line finish
two line finish
four line middle
three line middle
three line finish
four line finish</pre><p>The output lines for each rule are mixed together, making it very hard to decipher which output goes with which rule. Specifying <code class="literal">-Otarget</code> (or <code class="literal">--output-sync=target</code>) causes <code class="literal">make</code> to keep track of which output is associated with which target and flush the output only when the rule is complete. Now the complete output for each target is clearly readable:</p><a id="pro_id00132"/><pre class="programlisting">$ <span class="strong"><strong>make -j4 -Otarget</strong></span>
two line start
two line middle
two line finish
one line start
one line middle
one line finish
four line start
four line middle
four line finish
three line start
three line middle
three line finish</pre><p><a id="iddle1140" class="indexterm"/><a id="iddle1693" class="indexterm"/><a id="iddle1829" class="indexterm"/>Specifying <code class="literal">--output-sync=recurse</code> handles recursive sub-makes—that is, rules that invoke <code class="literal">$(MAKE)</code>—by buffering the entire output of the rule <span class="emphasis"><em>including</em></span> the sub-make and outputting it all in one go. This prevents sub-make output from getting mixed together but can lead to long pauses in output from <code class="literal">make</code>.</p></div><div class="sect3" title="The --trace Command Line Option"><div class="titlepage"><div><div><h3 class="title"><a id="trace_command_line_option"/>The --trace Command Line Option</h3></div></div></div><p>You can use the new <code class="literal">--trace</code> option to trace the execution of rules in a makefile. When specified on the <code class="literal">make</code> command line, the commands for each rule that is executed are printed along with information about where the rule is defined and why it was executed.</p><p>For example, this simple makefile has four targets:</p><a id="pro_id00133"/><pre class="programlisting">all: part-one part-two

part-one: part-three
→ @echo Make $@

part-two:
→ @echo Make $@

part-three:
→ @echo Make $@</pre><p>Run it with <code class="literal">--trace</code>:</p><a id="pro_id00134"/><pre class="programlisting">$ <span class="strong"><strong>make --trace</strong></span>
makefile:10: target 'part-three' does not exist
echo Make part-three
Make part-three
makefile:4: update target 'part-one' due to: part-three
echo Make part-one
Make part-one
makefile:7: target 'part-two' does not exist
echo Make part-two
Make part-two</pre><p>This shows you why each rule was run, where it is in the makefile, and what commands were executed.</p></div><div class="sect3" title="New Assignment Operators: != and ::="><div class="titlepage"><div><div><h3 class="title"><a id="new_assignment_operators_exclamation_mar"/>New Assignment Operators: != and ::=</h3></div></div></div><p><a id="iddle1006" class="indexterm"/><a id="iddle1023" class="indexterm"/><a id="iddle1024" class="indexterm"/><a id="iddle1025" class="indexterm"/><a id="iddle1275" class="indexterm"/><a id="iddle1278" class="indexterm"/><a id="iddle1734" class="indexterm"/><a id="iddle1863" class="indexterm"/>You can use the <code class="literal">!=</code> operator to execute a shell command and set a variable to the output of the command in a similar manner to <code class="literal">$(shell)</code>. For example, the following line uses <code class="literal">!=</code> to get the current date and time into a variable:</p><a id="pro_id00135"/><pre class="programlisting">CURRENTLY != date</pre><p>An important subtlety with <code class="literal">!=</code> is that the resulting variable is recursive, so its value is expanded each time the variable is used. If the command executed (that is, the RHS of the <code class="literal">!=</code>) returns a <code class="literal">$</code>, it will be interpreted by <code class="literal">make</code> as a variable reference and expanded. For this reason it’s safer to use a <code class="literal">$(shell)</code> with <code class="literal">:=</code> instead of <code class="literal">!=</code>. (This was added for compatibility with BSD <code class="literal">make</code> and might also be added to POSIX.)</p><p>The <code class="literal">::=</code> operator is exactly like <code class="literal">:=</code> and was added for POSIX compatibility.</p></div><div class="sect3" title="The $(file) Function"><div class="titlepage"><div><div><h3 class="title"><a id="dollarleft_parenthesisfileright_parenthe"/>The $(file) Function</h3></div></div></div><p>You can use the new <code class="literal">$(file)</code> function to create or append to a file. The following makefile uses <code class="literal">$(file)</code> to create a file and append to it each time a rule is executed. It creates a log of the makefile’s execution:</p><a id="pro_id00136"/><pre class="programlisting">LOG = make.log

$(file &gt; $(LOG),Start)

all: part-one part-two

part-one: part-three
→ @$(file &gt;&gt; $(LOG),$@)
→ @echo Make $@

part-two:
→ @$(file &gt;&gt; $(LOG),$@)
→ @echo Make $@

part-three:
→ @$(file &gt;&gt; $(LOG),$@)
→ @echo Make $@</pre><p>The first <code class="literal">$(file)</code> creates the log file using the <code class="literal">&gt;</code> operator, and subsequent calls to <code class="literal">$(file)</code> use <code class="literal">&gt;&gt;</code> to append to the log:</p><a id="pro_id00137"/><pre class="programlisting">$ <span class="strong"><strong>make</strong></span>
Make part-three
Make part-one
Make part-two
$ <span class="strong"><strong>cat make.log</strong></span>
Start
part-three
part-one
part-two</pre><p><a id="iddle1237" class="indexterm"/><a id="iddle1356" class="indexterm"/>It’s easy to see that the <code class="literal">$(file)</code> function is a useful addition to GNU <code class="literal">make</code>.</p></div></div><div class="sect2" title="What’s New in GNU make 4.1"><div class="titlepage"><div><div><h2 class="title"><a id="whatapostrophes_new_in_gnu_make_4dot1"/>What’s New in GNU make 4.1</h2></div></div></div><p>The most recent version of GNU <code class="literal">make</code> (at the time of this writing) is 4.1. Released on October 5, 2014, it contains two useful changes and a large number of bug fixes and small improvements.</p><p>New variables <code class="literal">MAKE_TERMOUT</code> and <code class="literal">MAKE_TERMERR</code> have been introduced. These Boolean values are set to true (that is, they are not empty) if <code class="literal">make</code> believes that <code class="literal">stdout</code> and <code class="literal">stderr</code> (respectively) are being sent to the console.</p><p>The <code class="literal">$(file)</code> function has been modified so that it’s possible to open a file without writing anything to it. If no text argument is present, the file is simply opened and closed again; you can use that to create an empty file with <code class="literal">$(file &gt; $(MY_FILE))</code>.</p></div></div></div></body></html>