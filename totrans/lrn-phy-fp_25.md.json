["```\n{-# OPTIONS -Wall #-}\n\nmodule CoordinateSystems where\n\nimport SimpleVec\n    ( R, Vec, (^/), vec, xComp, yComp, zComp, iHat, jHat, kHat\n    , magnitude, sumV, zeroV )\nimport Mechanics3D ( orient, v3FromVec )\nimport MOExamples ( Table(..), Justification(..) )\nimport qualified Vis as V\nimport SpatialMath ( V3(..) )\nimport Diagrams.Prelude\n    ( Diagram, V2(..), PolyType(..), PolyOrientation(..), PolygonOpts(..)\n    , (#), (@@), dims, p2, r2, arrowAt, position, fc, black, white\n    , blend, none, lw, rotate, deg, rad, scale, polygon, sinA )\nimport Diagrams.Backend.Cairo ( B, renderCairo )\n```", "```\ndata Position = Cart R R R\n                deriving (Show)\n```", "```\ntype CoordinateSystem = (R,R,R) -> Position\n```", "```\ncartesian   :: CoordinateSystem\ncartesian (x,y,z)\n    = Cart x y z\n\ncylindrical :: CoordinateSystem\ncylindrical (s,phi,z)\n    = Cart (s * cos phi) (s * sin phi) z\n\nspherical   :: CoordinateSystem\nspherical (r,theta,phi)\n    = Cart (r * sin theta * cos phi)\n           (r * sin theta * sin phi)\n           (r * cos theta)\n```", "```\ncart :: R  -- x coordinate\n     -> R  -- y coordinate\n     -> R  -- z coordinate\n     -> Position\ncart = Cart\n\ncyl  :: R  -- s   coordinate\n     -> R  -- phi coordinate\n     -> R  -- z   coordinate\n     -> Position\ncyl s phi z = cylindrical (s,phi,z)\n\nsph  :: R  -- r    coordinate\n     -> R  -- theta coordinate\n     -> R  -- phi   coordinate\n     -> Position\nsph r theta phi = spherical (r,theta,phi)\n```", "```\norigin :: Position\norigin = cart 0 0 0\n```", "```\ncartesianCoordinates   :: Position -> (R,R,R)\ncartesianCoordinates   (Cart x y z) = (x,y,z)\n\ncylindricalCoordinates :: Position -> (R,R,R)\ncylindricalCoordinates (Cart x y z) = (s,phi,z)\n    where\n      s = sqrt(x**2 + y**2)\n      phi = atan2 y x\n\nsphericalCoordinates   :: Position -> (R,R,R)\nsphericalCoordinates   (Cart x y z) = (r,theta,phi)\n    where\n      r = sqrt(x**2 + y**2 + z**2)\n      theta = atan2 s z\n      s = sqrt(x**2 + y**2)\n      phi = atan2 y x\n```", "```\ntype Displacement = Vec\n```", "```\ndisplacement :: Position  -- source position\n             -> Position  -- target position\n             -> Displacement\ndisplacement (Cart x' y' z') (Cart x y z)\n    = vec (x-x') (y-y') (z-z')\n```", "```\nshiftPosition :: Displacement -> Position -> Position\nshiftPosition v (Cart x y z)\n   = Cart (x + xComp v) (y + yComp v) (z + zComp v)\n```", "```\ntype ScalarField = Position -> R\n```", "```\nxSF :: ScalarField\nxSF p = x\n    where\n      (x,_,_) = cartesianCoordinates p\n```", "```\nrSF :: ScalarField\nrSF p = r\n    where\n      (r,_,_) = sphericalCoordinates p\n```", "```\nfst3 :: (a,b,c) -> a\nfst3 (u,_,_) = u\n\nsnd3 :: (a,b,c) -> b\nsnd3 (_,u,_) = u\n\nthd3 :: (a,b,c) -> c\nthd3 (_,_,u) = u\n```", "```\nySF :: ScalarField\nySF = snd3 . cartesianCoordinates\n```", "```\ntype VectorField = Position -> Vec\n```", "```\nsHat   :: VectorField\nsHat   r = vec ( cos phi) (sin phi) 0\n    where\n      (_,phi,_) = cylindricalCoordinates r\n\nphiHat :: VectorField\nphiHat r = vec (-sin phi) (cos phi) 0\n    where\n      (_,phi,_) = cylindricalCoordinates r\n```", "```\nrHat :: VectorField\nrHat rv = let d = displacement origin rv\n          in if d == zeroV\n             then zeroV\n             else d ^/ magnitude d\n\nthetaHat :: VectorField\nthetaHat r = vec ( cos theta * cos phi)\n                 ( cos theta * sin phi)\n                 (-sin theta         )\n    where\n      (_,theta,phi) = sphericalCoordinates r\n```", "```\nxHat :: VectorField\nxHat = const iHat\n\nyHat :: VectorField\nyHat = const jHat\n\nzHat :: VectorField\nzHat = const kHat\n```", "```\nrVF :: VectorField\nrVF = displacement origin\n```", "```\naddScalarFields :: [ScalarField] -> ScalarField\naddScalarFields flds r = sum  [fld r | fld <- flds]\n\naddVectorFields :: [VectorField] -> VectorField\naddVectorFields flds r = sumV [fld r | fld <- flds]\n```", "```\nsf3D :: [Position]   -- positions to use\n     -> ScalarField  -- to display\n     -> IO ()\nsf3D ps sf\n    = V.display whiteBackground $ orient $\n      V.VisObjects [V.Text3d (show (round $ sf p :: Int))\n                    (v3FromPos p) V.Fixed9By15 V.black\n                        | p <- ps]\n```", "```\nv3FromPos :: Position -> V3 R\nv3FromPos p = V3 x y z\n    where\n      (x,y,z) = cartesianCoordinates p\n```", "```\nwhiteBackground :: V.Options\nwhiteBackground = V.defaultOpts {V.optBackgroundColor = Just V.white}\n```", "```\nwhiteBackground' :: V.Options\nwhiteBackground'\n    = V.defaultOpts {V.optBackgroundColor = Just V.white,\n                     V.optInitialCamera   = Just V.Camera0 {V.rho0   = 40.0,\n                                                            V.theta0 = 45.0,\n                                                            V.phi0   = 20.0}}\n```", "```\nySF3D :: IO ()\nySF3D = sf3D [cart x y z | x <- [-6,-2..6]\n                         , y <- [-6,-2..6]\n                         , z <- [-6,-2..6]] ySF\n```", "```\nsfTable :: ((R,R) -> Position)\n        -> [R]  -- horizontal\n        -> [R]  -- vertical\n        -> ScalarField\n        -> Table Int\nsfTable toPos ss ts sf\n    = Table RJ [[round $ sf $ toPos (s,t) | s <- ss] | t <- reverse ts]\n```", "```\nPrelude> :l CoordinateSystems\n[1 of 7] Compiling Newton2          ( Newton2.hs, interpreted )\n[2 of 7] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )\n[3 of 7] Compiling SimpleVec        ( SimpleVec.hs, interpreted )\n[4 of 7] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )\n[5 of 7] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )\n[6 of 7] Compiling MOExamples       ( MOExamples.hs, interpreted )\n[7 of 7] Compiling CoordinateSystems ( CoordinateSystems.hs, interpreted )\nOk, 7 modules loaded.\n*CoordinateSystems> sfTable (\\(x,y) -> cart x y 0) [-6,-2..6] [-6,-2..6] ySF\n  6  6  6  6\n  2  2  2  2\n -2 -2 -2 -2\n -6 -6 -6 -6\n```", "```\nvf3D :: R            -- scale factor, vector field units per meter\n     -> [Position]   -- positions to show the field\n     -> VectorField  -- vector field to display\n     -> IO ()\nvf3D unitsPerMeter ps vf\n    = V.display whiteBackground $ orient $\n      V.VisObjects [V.Trans (v3FromPos p) $\n                    visVec V.black (vf p ^/ unitsPerMeter)\n                        | p <- ps]\n```", "```\nvisVec :: V.Color -> Vec -> V.VisObject R\nvisVec color v = let vmag = magnitude v\n                 in V.Arrow (vmag,20*vmag) (v3FromVec v) color\n```", "```\nphiHat3D :: IO ()\nphiHat3D = vf3D 1 [cyl r ph z | r  <- [1,2,3]\n                              , ph <- [0,pi/4..2*pi]\n                              , z  <- [-2..2]] phiHat\n```", "```\nvfPNG :: ((R,R) -> Position)\n      -> (Vec -> (R,R))\n      -> FilePath    -- file name\n      -> R           -- scale factor in units per meter\n      -> [(R,R)]     -- positions to use\n      -> VectorField\n      -> IO ()\nvfPNG toPos fromVec fileName unitsPerMeter pts vf\n    = let vf2d = r2 . fromVec . (^/ unitsPerMeter) . vf . toPos\n          pic  = mconcat [arrowAt (p2 pt) (vf2d pt) | pt <- pts]\n      in renderCairo fileName (dims (V2 1024 1024)) pic\n```", "```\nvfPNGxy :: FilePath    -- file name\n        -> R           -- scale factor\n        -> [(R,R)]     -- positions to use\n        -> VectorField\n        -> IO ()\nvfPNGxy = vfPNG (\\(x,y) -> cart x y 0) (\\v -> (xComp v, yComp v))\n```", "```\nphiHatPNG :: IO ()\nphiHatPNG\n    = vfPNGxy \"phiHatPNG.png\" 1\n      [(r * cos ph, r * sin ph) | r  <- [1,2]\n                                , ph <- [0,pi/4..2*pi]] phiHat\n```", "```\nrVFpng :: IO ()\nrVFpng\n    = vfPNGxy \"rVFpng.png\" 2\n      [(r * cos ph, r * sin ph) | r  <- [1,2]\n                                , ph <- [0,pi/4..2*pi]] rVF\n```", "```\nvfGrad :: (R -> R)\n       -> ((R,R) -> Position)\n       -> (Vec -> (R,R))\n       -> FilePath\n       -> Int    -- n for n x n\n       -> VectorField\n       -> IO ()\nvfGrad curve toPos fromVec fileName n vf\n ➊ = let step = 2 / fromIntegral n\n       ➋ xs = [-1+step/2, -1+3*step/2 .. 1-step/2]\n       ➌ pts = [(x, y) | x <- xs, y <- xs]\n       ➍ array = [(pt,magRad $ fromVec $ vf $ toPos pt) | pt <- pts]\n       ➎ maxMag = maximum (map (fst . snd) array)\n       ➏ scaledArrow m th = scale step $ arrowMagRad (curve (m/maxMag)) th\n       ➐ pic = position [(p2 pt, scaledArrow m th) | (pt,(m,th)) <- array]\n    ➑ in renderCairo fileName (dims (V2 1024 1024)) pic\n```", "```\nmagRad :: (R,R) -> (R,R)\nmagRad (x,y) = (sqrt (x*x + y*y), atan2 y x)\n```", "```\n-- magnitude from 0 to 1\narrowMagRad :: R  -- magnitude\n            -> R  -- angle in radians, counterclockwise from x axis\n            -> Diagram B\narrowMagRad mag th\n    = let r      = sinA (15 @@ deg) / sinA (60 @@ deg)\n          myType = PolyPolar [120 @@ deg, 0 @@ deg, 45 @@ deg, 30 @@ deg,\n                              45 @@ deg, 0 @@ deg, 120 @@ deg]\n                   [1,1,r,1,1,r,1,1]\n          myOpts = PolygonOpts myType NoOrient (p2 (0,0))\n      in scale 0.5 $ polygon myOpts # lw none # fc (blend mag black white) #\n         rotate (th @@ rad)\n```", "```\nrVFGrad :: IO ()\nrVFGrad = vfGrad id\n          (\\(x,y) -> cart x y 0)\n          (\\v -> (xComp v,yComp v))\n          \"rVFGrad.png\" 20\n          rVF\n```", "```\nthetaSF :: ScalarField\nthetaSF = undefined\n```", "```\nthetaHat3D :: IO ()\nthetaHat3D = undefined\n```", "```\nthetaHatGrad :: IO ()\nthetaHatGrad = vfGrad id undefined undefined \"thetaHatGrad.png\" 20 thetaHat\n```", "```\nphiHatGrad :: IO ()\nphiHatGrad = undefined\n```"]