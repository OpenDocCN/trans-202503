<html><head></head><body>
<p id="filepos554179" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">8</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">AUTOMATING CUCKOO SANDBOX</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">Cuckoo Sandbox is an open source project that allows you to run malware samples within the safety of virtual machines, and then analyze and report on how the malware behaved in a virtual sandbox without the threat of the malware infecting your real machine. Written in Python, Cuckoo Sandbox also offers a REST API that allows a programmer using any language to fully automate many of Cuckoo’s features, such as spinning up sandboxes, running malware, and grabbing reports. In this chapter, we’ll do all of this with easy-to-use C# libraries and classes. However, there is a lot of work to do, like setting up the virtual environment for Cuckoo to use, before we can begin testing and running malware samples with C#. You can find more information about and download Cuckoo Sandbox at <a href="https://www.cuckoosandbox.org/"><span class="italic">https://www.cuckoosandbox.org/</span></a>.</p><p id="filepos555386" class="calibre_10"><span class="calibre3"><span class="bold"> Setting Up Cuckoo Sandbox</span></span></p><p class="calibre_11">We won’t cover setting up Cuckoo Sandbox in this chapter because the instructions can vary greatly between different operating systems—and even based on which version of Windows you use as the virtual machine sandbox. This chapter will assume that you correctly set up Cuckoo Sandbox with a Windows guest and that Cuckoo is completely functional. Be sure to follow the directions on the main Cuckoo Sandbox website (<a href="http://docs.cuckoosandbox.org/en/latest/installation/"><span class="italic">http://docs.cuckoosandbox.org/en/latest/installation/</span></a>), which provides up-to-date and thorough documentation on setting up and configuring the software.</p><p class="calibre_6">In the <span class="italic">conf/cuckoo.conf</span> file that ships with Cuckoo Sandbox, I recommend making an adjustment to the default timeout configuration so that it is shorter (I set mine to 15 seconds) before you begin working with the API. This will make things easier and faster during testing. In your <span class="italic">cuckoo.conf</span> file, you will see a section toward the bottom that looks like <a href="#filepos557059">Listing 8-1</a>.</p><blockquote class="calibre_14"><span class="calibre4">[timeouts]</span><br class="calibre5"/><span class="calibre4"># Set the default analysis timeout expressed in seconds. This value will be</span><br class="calibre5"/><span class="calibre4"># used to define after how many seconds the analysis will terminate unless</span><br class="calibre5"/><span class="calibre4"># otherwise specified at submission.</span><br class="calibre5"/><span class="calibre4">default = ➊120</span></blockquote><p id="filepos557059" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-1: The default timeout configuration section in</span></span><span class="calibre4"> cuckoo.conf</span></p><p class="calibre_6">The default timeout for Cuckoo testing is set to 120 seconds ➊. A long timeout can make you quite impatient to see if you fixed a problem during debugging, since you must wait for the timeout to be reached before a report is ready, but setting this value between 15 and 30 seconds should be good for our purposes.</p><p id="filepos557587" class="calibre_10"><span class="calibre3"><span class="bold">Manually Running the Cuckoo Sandbox API</span></span></p><p class="calibre_11">Like Nessus, the Cuckoo Sandbox follows a REST pattern (see the description of REST in <a href="index_split_010.html#filepos420379">Chapter 5</a> if you need a refresher). However, the Cuckoo Sandbox API is far simpler than the Nessus API, since we only need to communicate with a couple of API endpoints. To do this, we’ll continue to use the session/manager pattern and implement the <span class="calibre4">CuckooSession</span> class first, which encompasses how we will communicate with the Cuckoo Sandbox API. Let’s check whether you set up Cuckoo Sandbox correctly, though, before we get started writing code.</p><p id="filepos558335" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Starting the API</span></span></span></p><p class="calibre_11">With Cuckoo Sandbox successfully installed, you should be able to start it locally with the command <span class="calibre4"><span class="bold">./cuckoo.py</span></span>, as in <a href="#filepos559846">Listing 8-2</a>. If you receive an error, ensure the VM you’re using for testing is running.</p><blockquote class="calibre_14"><span class="calibre4"> $ </span><span class="calibre4"><span class="bold">./cuckoo.py</span></span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> eeee e e eeee e e eeeee eeeee</span><br class="calibre5"/><span class="calibre4"> 8 8 8 8 8 8 8 8 8 88 8 88</span><br class="calibre5"/><span class="calibre4"> 8e 8e 8 8e 8eee8e 8 8 8 8</span><br class="calibre5"/><span class="calibre4"> 88 88 8 88 88 8 8 8 8 8</span><br class="calibre5"/><span class="calibre4"> 88e8 88ee8 88e8 88 8 8eee8 8eee8</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Cuckoo Sandbox 2.0-rc2</span><br class="calibre5"/><span class="calibre4"> www.cuckoosandbox.org</span><br class="calibre5"/><span class="calibre4"> Copyright (c) 2010-2015</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Checking for updates...</span><br class="calibre5"/><span class="calibre4"> Good! You have the latest version available.</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">2016-05-19 16:17:06,146 [lib.cuckoo.core.scheduler] INFO: Using "virtualbox" as machine manager</span><br class="calibre5"/><span class="calibre4">2016-05-19 16:17:07,484 [lib.cuckoo.core.scheduler] INFO: Loaded 1 machine/s</span><br class="calibre5"/><span class="calibre4">2016-05-19 16:17:07,495 [lib.cuckoo.core.scheduler] INFO: Waiting for analysis tasks...</span></blockquote><p id="filepos559846" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-2: Starting the Cuckoo Sandbox manager</span></span></p><p class="calibre_6">Starting Cuckoo successfully should yield a fun ASCII art banner, followed by quick informational lines about how many VMs have been loaded. After starting the main Cuckoo script, you need to start the API that we’ll communicate with. Both of these Python scripts must be running at the same time! The <span class="italic">cuckoo.py</span> Python script is the engine behind Cuckoo Sandbox. If we start the <span class="italic">api.py</span> script without starting the <span class="italic">cuckoo.py</span> script, as in <a href="#filepos561051">Listing 8-3</a>, then our API requests won’t do anything. For us to use the Cuckoo Sandbox from the API, both <span class="italic">cuckoo.py</span> and <span class="italic">api.py</span> must be running. By default, the Cuckoo Sandbox API listens on port 8090, as <a href="#filepos561051">Listing 8-3</a> shows.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">utils/api.py</span></span><span class="calibre4"> ➊</span><span class="calibre4"><span class="bold">-H 0.0.0.0</span></span><br class="calibre5"/><span class="calibre4"> * Running on ➋http://0.0.0.0:8090/ (Press CTRL+C to quit)</span></blockquote><p id="filepos561051" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-3: Running the HTTP API for Cuckoo Sandbox</span></span></p><p class="calibre_6">To specify an IP address to listen on (the default is localhost), you can pass the <span class="italic">utils/api.py</span> script the <span class="calibre4">-H</span> argument ➊, which tells the API which IP address to use when listening for API requests. In this case, we have set 0.0.0.0 as the IP address to listen on, which means all network interfaces (both internal and external IP addresses for the system) will have port 8090 available for communication since we are using the default port. The URL that the Cuckoo API is listening on is also printed to the screen ➋ after starting. This URL is how we’ll communicate with the API to drive Cuckoo Sandbox in the rest of the chapter.</p><p id="filepos561892" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Checking Cuckoo’s Status</span></span></span></p><p class="calibre_11">We can test the API to ensure it has been set up correctly using the curl command line tool, as we have in previous chapters for other APIs. Later in the chapter, we make similar API requests to create a task, watch the task until completed, and report on the file to see how it behaved when it ran. But to get started, <a href="#filepos564120">Listing 8-4</a> shows how to use curl to retrieve the Cuckoo Sandbox status information in JSON format with the HTTP API.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">curl http://127.0.0.1:8090/cuckoo/status</span></span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> "cpuload": [</span><br class="calibre5"/><span class="calibre4"> 0.0,</span><br class="calibre5"/><span class="calibre4"> 0.02,</span><br class="calibre5"/><span class="calibre4"> 0.05</span><br class="calibre5"/><span class="calibre4"> ],</span><br class="calibre5"/><span class="calibre4"> "diskspace": {</span><br class="calibre5"/><span class="calibre4"> "analyses": {</span><br class="calibre5"/><span class="calibre4"> "free": 342228357120,</span><br class="calibre5"/><span class="calibre4"> "total": 486836101120,</span><br class="calibre5"/><span class="calibre4"> "used": 144607744000</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"> "binaries": {</span><br class="calibre5"/><span class="calibre4"> "free": 342228357120,</span><br class="calibre5"/><span class="calibre4"> "total": 486836101120,</span><br class="calibre5"/><span class="calibre4"> "used": 144607744000</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"> "hostname": "fdsa-E7450",</span><br class="calibre5"/><span class="calibre4"> ➊"machines": {</span><br class="calibre5"/><span class="calibre4"> "available": 1,</span><br class="calibre5"/><span class="calibre4"> "total": 1</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"> "memory": 82.06295645686164,</span><br class="calibre5"/><span class="calibre4"> ➋"tasks": {</span><br class="calibre5"/><span class="calibre4"> "completed": 0,</span><br class="calibre5"/><span class="calibre4"> "pending": 0,</span><br class="calibre5"/><span class="calibre4"> "reported": 3,</span><br class="calibre5"/><span class="calibre4"> "running": 0,</span><br class="calibre5"/><span class="calibre4"> "total": 13</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"> ➌"version": "2.0-rc2"</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos564120" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-4: Using curl to retrieve the Cuckoo Sandbox status via the HTTP API</span></span></p><p class="calibre_6">The status information is quite useful, detailing many aspects of the Cuckoo Sandbox system. Of note is the aggregate task information ➋, with the number of tasks that have been run or are running by Cuckoo, listed by status. A task could be analyzing a file that is running or opening a web page with a URL, though we’ll only cover submitting a file for analysis in this chapter. You can also see the number of VMs you have available for analysis ➊ and the current version of Cuckoo ➌.</p><p class="calibre_6">Great, the API is up and running! We’ll use this same status API endpoint later to test our code as we write it and to discuss the JSON it returns more thoroughly. At the moment, we only need to confirm the API is up and running.</p><p id="filepos565093" class="calibre_10"><span class="calibre3"><span class="bold"> Creating the CuckooSession Class</span></span></p><p class="calibre_11">Now that we know the API works and we can make HTTP requests and get the JSON responses, we can start writing our code to drive Cuckoo Sandbox programmatically. Once we have the base classes built, we can submit a file that will be analyzed as it runs and then report on the results. We’ll start with the <span class="calibre4">CuckooSession</span> class, which begins in <a href="#filepos566180">Listing 8-5</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class ➊CuckooSession</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public CuckooSession➋(string host, int port)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.Host = host;</span><br class="calibre5"/><span class="calibre4"> this.Port = port;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public string ➌Host { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int ➍Port { get; set; }</span></blockquote><p id="filepos566180" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-5: Starting the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">CuckooSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">Keeping things simple to start with, we create the <span class="calibre4">CuckooSession</span> class ➊ as well as the <span class="calibre4">CuckooSession</span> constructor. The constructor takes two arguments ➋. The first is the host to connect to, and the second is the port on the host on which the API will be listening. In the constructor, the two values passed as arguments are assigned to their respective properties, <span class="calibre4">Host</span> ➌ and <span class="calibre4">Port</span> ➍, which are defined below the constructor. Next, we need to implement the methods available for the <span class="calibre4">CuckooSession</span> class.</p><p id="filepos567070" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Writing the ExecuteCommand() Methods to Handle HTTP Requests</span></span></span></p><p class="calibre_11">Cuckoo expects two kinds of HTTP requests when API requests are made: a traditional HTTP request and a more complex HTTP multipart form request used for sending files to Cuckoo for analysis. We’ll implement two <span class="calibre4">ExecuteCommand()</span> methods to cover these types of requests: first, we’ll use a simpler <span class="calibre4">ExecuteCommand()</span> method that accepts two arguments for the traditional request, and then we’ll overload it with an <span class="calibre4">ExecuteCommand()</span> method that takes three arguments for the multipart request. Creating two methods with the same name but with different arguments, or <span class="italic">method overloading</span>, is allowed in C#. This is a good example of when you would use method overloading instead of a single method that accepts optional arguments because the methods for each request are relatively different, despite sharing the same name. <a href="#filepos569112">Listing 8-6</a> details the simpler <span class="calibre4">ExecuteCommand()</span> method.</p><blockquote class="calibre_14"><span class="calibre4"> public JObject ➊ExecuteCommand(string uri, string method)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> HttpWebRequest req = (HttpWebRequest)WebRequest</span><br class="calibre5"/><span class="calibre4"> .➋Create("http://" + this.Host + ":" + this.Port + uri);</span><br class="calibre5"/><span class="calibre4"> req.➌Method = method;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string resp = string.Empty;</span><br class="calibre5"/><span class="calibre4"> using (Stream str = req.GetResponse().GetResponseStream())</span><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new StreamReader(str))</span><br class="calibre5"/><span class="calibre4"> resp = rdr.➍ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> JObject obj = JObject.➎Parse(resp);</span><br class="calibre5"/><span class="calibre4"> return obj;</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos569112" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-6: The simpler</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ExecuteCommand()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method that accepts just a URI and the HTTP method as arguments</span></span></p><p class="calibre_6">The first <span class="calibre4">ExecuteCommand()</span> method ➊ takes two arguments: the URI to request and the HTTP method to use (<span class="calibre4">GET</span>, <span class="calibre4">POST</span>, <span class="calibre4">PUT</span>, and so on). After using <span class="calibre4">Create()</span> ➋ to build a new HTTP request and setting the <span class="calibre4">Method</span> property ➌ of the request, we make the HTTP request and read ➍ the response into a string. Finally, we parse ➎ the returned string as JSON and return the new JSON object.</p><p class="calibre_6">The overloaded <span class="calibre4">ExecuteCommand()</span> method takes three arguments: the URI to request, the HTTP method, and a dictionary of parameters that will be sent in an HTTP multipart request. Multipart requests allow you to send more complex data such as binary files along with other HTTP parameters to a web server, which is exactly how we’ll use it. A full multipart request is shown later in <a href="#filepos580411">Listing 8-9</a>. How to send this type of request is detailed in <a href="#filepos571955">Listing 8-7</a>.</p><blockquote class="calibre_14"><span class="calibre4"> public JObject ➊ExecuteCommand(string uri, string method, IDictionary&lt;string, object&gt; parms)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> HttpWebRequest req = (HttpWebRequest)WebRequest</span><br class="calibre5"/><span class="calibre4"> .➋Create("http://" + this.Host + ":" + this.Port + uri);</span><br class="calibre5"/><span class="calibre4"> req.➌Method = method;</span><br class="calibre5"/><span class="calibre4"> string boundary = ➍String.Format("----------{0:N}", Guid.NewGuid());</span><br class="calibre5"/><span class="calibre4"> byte[] data = ➎GetMultipartFormData(parms, boundary);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> req.ContentLength = data.Length;</span><br class="calibre5"/><span class="calibre4"> req.ContentType = ➏"multipart/form-data; boundary=" + boundary;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> using (Stream parmStream = req.GetRequestStream())</span><br class="calibre5"/><span class="calibre4"> parmStream.➐Write(data, 0, data.Length);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string resp = string.Empty;</span><br class="calibre5"/><span class="calibre4"> using (Stream str = req.GetResponse().GetResponseStream())</span><br class="calibre5"/><span class="calibre4"> using (StreamReader rdr = new StreamReader(str))</span><br class="calibre5"/><span class="calibre4"> resp = rdr.➑ReadToEnd();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> JObject obj = JObject.➒Parse(resp);</span><br class="calibre5"/><span class="calibre4"> return obj;</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos571955" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-7: The overloaded</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ExecuteCommand()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method, which makes a multipart/form-data HTTP request</span></span></p><p class="calibre_6">The second, more complex <span class="calibre4">ExecuteCommand()</span> method ➊ takes three arguments, as outlined earlier. After instantiating a new request ➋ and setting the HTTP method ➌, we create a boundary that will be used to separate the HTTP parameters in the multipart form request using <span class="calibre4">String.Format()</span> ➍. Once the boundary is created, we call <span class="calibre4">GetMultipartFormData()</span> ➎ (which we will implement shortly) to convert the dictionary of parameters passed as the third argument into a multipart HTTP form with the new boundary.</p><p class="calibre_6">After building the multipart HTTP data, we need to set up the HTTP request by setting the <span class="calibre4">ContentLength</span> and <span class="calibre4">ContentType</span> request properties based on the multipart HTTP data. For the <span class="calibre4">ContentType</span> property, we also append the boundary that will be used to separate the HTTP parameters ➏. Finally, we can write ➐ the multipart form data to the HTTP request stream and read ➑ the response from the server. With the final response from the server, we parse ➒ the response as JSON and then return the JSON object.</p><p class="calibre_6">Both of these <span class="calibre4">ExecuteCommand()</span> methods will be used to execute API calls against the Cuckoo Sandbox API. But before we can start calling the API endpoints, we need to write a bit more code.</p><p id="filepos573743" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating Multipart HTTP Data with the GetMultipartFormData() Method</span></span></span></p><p class="calibre_11">Although the <span class="calibre4">GetMultipartFormData()</span> method is core to communicating with Cuckoo Sandbox, I’m not going to go over it line by line. This method is actually a good example of a small weakness in the core libraries for C# because it shouldn’t be this complicated to make a multipart HTTP request. Unfortunately, there is no easy-to-use class available that allows us to do this, so we need to create this method to build the HTTP multipart request from scratch. The raw technical details of building multipart HTTP requests are a bit out of scope for what we are looking to accomplish, so I’ll only gloss over the general flow of this method. The method in full (shown in <a href="#filepos577748">Listing 8-8</a>, minus in-line comments) was written by Brian Grinstead,<sup class="calibre8"><small id="filepos574731" class="calibre9"><a href="index_split_025.html#filepos1129476"><span class="calibre10">1</span></a></small></sup> whose work was then incorporated into the RestSharp client (<a href="http://restsharp.org/"><span class="italic">http://restsharp.org/</span></a>).</p><blockquote class="calibre_14"><span class="calibre4"> private byte[] ➊GetMultipartFormData(IDictionary&lt;string, object&gt; postParameters, string boundary)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> System.Text.Encoding encoding = System.Text.Encoding.ASCII;</span><br class="calibre5"/><span class="calibre4"> Stream formDataStream = new System.IO.MemoryStream();</span><br class="calibre5"/><span class="calibre4"> bool needsCLRF = false;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> foreach (var param in postParameters)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (needsCLRF)</span><br class="calibre5"/><span class="calibre4"> formDataStream.Write(encoding.GetBytes("\r\n"), 0, encoding.GetByteCount("\r\n"));</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> needsCLRF = true;</span><br class="calibre5"/><span class="calibre4"> if (param.Value is FileParameter)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> FileParameter fileToUpload = (FileParameter)param.Value;</span><br class="calibre5"/><span class="calibre4"> string header = string.Format("--{0}\r\nContent-Disposition: form-data; name=\"{1}\";" +</span><br class="calibre5"/><span class="calibre4"> "filename=\"{2}\";\r\nContent-Type: {3}\r\n\r\n",</span><br class="calibre5"/><span class="calibre4"> boundary,</span><br class="calibre5"/><span class="calibre4"> param.Key,</span><br class="calibre5"/><span class="calibre4"> fileToUpload.FileName ?? param.Key,</span><br class="calibre5"/><span class="calibre4"> fileToUpload.ContentType ?? "application/octet-stream");</span><br class="calibre5"/><span class="calibre4"> formDataStream.Write(encoding.GetBytes(header), 0, encoding.GetByteCount(header));</span><br class="calibre5"/><span class="calibre4"> formDataStream.Write(fileToUpload.File, 0, fileToUpload.File.Length);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string postData = string.Format("--{0}\r\nContent-Disposition: form-data;" +</span><br class="calibre5"/><span class="calibre4"> "name=\"{1}\"\r\n\r\n{2}",</span><br class="calibre5"/><span class="calibre4"> boundary,</span><br class="calibre5"/><span class="calibre4"> param.Key,</span><br class="calibre5"/><span class="calibre4"> param.Value);</span><br class="calibre5"/><span class="calibre4"> formDataStream.Write(encoding.GetBytes(postData), 0, encoding.GetByteCount(postData));</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string footer = "\r\n--" + boundary + "--\r\n";</span><br class="calibre5"/><span class="calibre4"> formDataStream.Write(encoding.GetBytes(footer), 0, encoding.GetByteCount(footer));</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> formDataStream.Position = 0;</span><br class="calibre5"/><span class="calibre4"> byte[] formData = new byte[formDataStream.Length];</span><br class="calibre5"/><span class="calibre4"> formDataStream.Read(formData, 0, formData.Length);</span><br class="calibre5"/><span class="calibre4"> formDataStream.Close();</span><br class="calibre5"/><span class="calibre4"> return formData;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos577748" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-8: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetMultipartFormData()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">In the <span class="calibre4">GetMultipartFormData()</span> method ➊, we start by accepting two arguments: the first is the dictionary of parameters and their respective values that we’ll turn into a multipart form, and the second is the string that we’ll use to separate the file parameters in the request so they can be parsed out. This second argument is called <span class="calibre4">boundary</span>, and we use it to tell the API to split the HTTP request body using this boundary, and then use each section as a separate parameter and value in the request. This can be hard to visualize, so <a href="#filepos580411">Listing 8-9</a> details a sample HTTP multipart form request.</p><blockquote class="calibre_14"><span class="calibre4">POST / HTTP/1.1</span><br class="calibre5"/><span class="calibre4">Host: localhost:8000</span><br class="calibre5"/><span class="calibre4">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:29.0) Gecko/20100101 Firefox/29.0</span><br class="calibre5"/><span class="calibre4">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br class="calibre5"/><span class="calibre4">Accept-Language: en-US,en;q=0.5</span><br class="calibre5"/><span class="calibre4">Accept-Encoding: gzip, deflate</span><br class="calibre5"/><span class="calibre4">Connection: keep-alive</span><br class="calibre5"/><span class="calibre4">Content-Type: ➊multipart/form-data;</span><br class="calibre5"/><span class="calibre4">boundary➋=------------------------9051914041544843365972754266</span><br class="calibre5"/><span class="calibre4">Content-Length: 554</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">--------------------------9051914041544843365972754266➌</span><br class="calibre5"/><span class="calibre4">Content-Disposition: form-data; ➍name="text"</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">text default➎</span><br class="calibre5"/><span class="calibre4">--------------------------9051914041544843365972754266➏</span><br class="calibre5"/><span class="calibre4">Content-Disposition: form-data; name="file1"; filename="a.txt"</span><br class="calibre5"/><span class="calibre4">Content-Type: text/plain</span><br class="calibre5"/><span class="calibre4"> Content of a.txt.</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">--------------------------9051914041544843365972754266➐</span><br class="calibre5"/><span class="calibre4">Content-Disposition: form-data; name="file2"; filename="a.html"</span><br class="calibre5"/><span class="calibre4">Content-Type: text/html</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">&lt;!DOCTYPE html&gt;&lt;title&gt;Content of a.html.&lt;/title&gt;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">--------------------------9051914041544843365972754266--➑</span></blockquote><p id="filepos580411" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-9: A sample HTTP multipart form request</span></span></p><p class="calibre_6">This HTTP request looks a lot like what we are trying to build, so let’s point out the important parts that were mentioned in <span class="calibre4">GetMultipartFormData()</span>. First, note the <span class="calibre4">Content-Type</span> header is <span class="calibre4">multipart/form-data</span> ➊ with a <span class="calibre4">boundary</span> ➋, just like the one we set in <a href="#filepos571955">Listing 8-7</a>. This boundary is used throughout the HTTP request (➌, ➏, ➐, ➑) to separate each HTTP parameter. Each parameter also has a parameter name ➍ and value ➎. The <span class="calibre4">GetMultipartFormData()</span> method takes the parameter names and values we pass in the <span class="calibre4">Dictionary</span> argument and the boundary and then turns them into a similar HTTP request using the given boundary to separate each parameter.</p><p id="filepos581404" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Processing File Data with the FileParameter Class</span></span></span></p><p class="calibre_11">In order to send Cuckoo the file or malware we want to analyze, we need to create a class we can use to store the data for the file, such as the file type, filename, and actual content of the file. The simple <span class="calibre4">FileParameter</span> class wraps a bit of the information we need for the <span class="calibre4">GetMultipartFormData()</span> method. It’s shown in <a href="#filepos582712">Listing 8-10</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class ➊FileParameter</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public byte[] File { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string FileName { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string ContentType { get; set; }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public ➋FileParameter(byte[] file, string filename, string contenttype)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➌File = file;</span><br class="calibre5"/><span class="calibre4"> ➍FileName = filename;</span><br class="calibre5"/><span class="calibre4"> ➎ContentType = contenttype;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos582712" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-10: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">FileParameter</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">The <span class="calibre4">FileParameter</span> class ➊ represents the data we need to build an HTTP parameter that will contain the file to be analyzed. The constructor ➋ for the class accepts three arguments: the byte array containing the file contents, the name of the file, and the content type. Each argument is then assigned to the respective class property (➌, ➍, ➎).</p><p id="filepos583349" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">Testing the CuckooSession and Supporting Classes</span></span></span></p><p class="calibre_11">We can test what we have written so far with a short and simple <span class="calibre4">Main()</span> method that requests the status of Cuckoo Sandbox using the API. We did this manually in “<a href="#filepos561892">Checking Cuckoo’s Status</a>” on <a href="#filepos554179">page 149</a>. <a href="#filepos584418">Listing 8-11</a> shows how we can do this using the new <span class="calibre4">CuckooSession</span> class.</p><blockquote class="calibre_14"><span class="calibre4">public static void ➊Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> CuckooSession session = new ➋CuckooSession("127.0.0.1", 8090);</span><br class="calibre5"/><span class="calibre4"> JObject response = session.➌ExecuteCommand("/cuckoo/status", "GET");</span><br class="calibre5"/><span class="calibre4"> Console.➍WriteLine(response.ToString());</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos584418" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-11:</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method for retrieving the Cuckoo Sandbox status</span></span></p><p class="calibre_6">With a new <span class="calibre4">Main()</span> method ➊, we first create a <span class="calibre4">CuckooSession</span> object ➋ by passing the IP address and the port that Cuckoo Sandbox is running on. If the API is running on your local machine, then 127.0.0.1 for the IP should be fine. The IP and port (8090 by default) should have been set up when we started the API in <a href="#filepos561051">Listing 8-3</a>. Using the new session, we call the <span class="calibre4">ExecuteCommand()</span> method ➌, passing the URI <span class="italic">/cuckoo/status</span> as the first argument and the HTTP method <span class="calibre4">GET</span> as the second method. The response is then printed to the screen using <span class="calibre4">WriteLine()</span> ➍.</p><p class="calibre_6">Running the <span class="calibre4">Main()</span> method should print a JSON dictionary to the screen with status information about Cuckoo, as detailed in <a href="#filepos587213">Listing 8-12</a>.</p><blockquote class="calibre_14"><span class="calibre4"><span class="bold">$ ./ch8_automating_cuckoo.exe</span></span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> "cpuload": [</span><br class="calibre5"/><span class="calibre4"> 0.0,</span><br class="calibre5"/><span class="calibre4"> 0.03,</span><br class="calibre5"/><span class="calibre4"> 0.05</span><br class="calibre5"/><span class="calibre4"> ],</span><br class="calibre5"/><span class="calibre4"> "diskspace": {</span><br class="calibre5"/><span class="calibre4"> "analyses": {</span><br class="calibre5"/><span class="calibre4"> "free": 342524416000,</span><br class="calibre5"/><span class="calibre4"> "total": 486836101120,</span><br class="calibre5"/><span class="calibre4"> "used": 144311685120</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"> "binaries": {</span><br class="calibre5"/><span class="calibre4"> "free": 342524416000,</span><br class="calibre5"/><span class="calibre4"> "total": 486836101120,</span><br class="calibre5"/><span class="calibre4"> "used": 144311685120</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"> "hostname": "fdsa-E7450",</span><br class="calibre5"/><span class="calibre4"> "machines": {</span><br class="calibre5"/><span class="calibre4"> "available": 1,</span><br class="calibre5"/><span class="calibre4"> "total": 1</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"> "memory": 85.542549616647932,</span><br class="calibre5"/><span class="calibre4"> "tasks": {</span><br class="calibre5"/><span class="calibre4"> "completed": 0,</span><br class="calibre5"/><span class="calibre4"> "pending": 0,</span><br class="calibre5"/><span class="calibre4"> "reported": 2,</span><br class="calibre5"/><span class="calibre4"> "running": 0,</span><br class="calibre5"/><span class="calibre4"> "total": 12</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"> "version": "2.0-rc2"</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos587213" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-12: Testing the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">CuckooSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class to print the current status information for the Cuckoo Sandbox</span></span></p><p class="calibre_6">You can see that the JSON information printed here is the same as when we ran the API command manually earlier to check Cuckoo’s status.</p><p id="filepos587683" class="calibre_10"><span class="calibre3"><span class="bold">writing the CuckooManager Class</span></span></p><p class="calibre_11">With the <span class="calibre4">CuckooSession</span> class and other supporting classes implemented, we can move on to the <span class="calibre4">CuckooManager</span> class, which will wrap a few easy API calls. To start off the <span class="calibre4">CuckooManager</span> class, we need the constructor shown in <a href="#filepos588590">Listing 8-13</a>.</p><blockquote class="calibre_14"><span class="calibre4">public class ➊CuckooManager : ➋IDisposable</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> CuckooSession ➌_session = null;</span><br class="calibre5"/><span class="calibre4"> public ➍CuckooManager(CuckooSession session)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➎_session = session;</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos588590" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-13: Starting the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">CuckooManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">The <span class="calibre4">CuckooManager</span> class ➊ starts by implementing the <span class="calibre4">IDisposable</span> interface ➋, which we’ll use to dispose of our private <span class="calibre4">_session</span> variable ➌ when we are finished with the <span class="calibre4">CuckooManager</span> class. The class constructor ➍ takes only a single argument: the session to use when communicating with the Cuckoo Sandbox instance. The private <span class="calibre4">_session</span> variable is assigned with the argument passed to the constructor ➎ so that the methods we will write shortly can use the session to make their specific API calls.</p><p id="filepos589482" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Writing the CreateTask() Method</span></span></span></p><p class="calibre_11">The first method in the <span class="calibre4">CuckooManager</span> class is <span class="calibre4">CreateTask()</span>, the most complicated manager method we’ll write. The <span class="calibre4">CreateTask()</span> method implements the HTTP call that will create a new task by determining the type of task we are creating and then making the correct HTTP call, as shown in <a href="#filepos592106">Listing 8-14</a>.</p><blockquote class="calibre_14"><span class="calibre4"> public int ➊CreateTask(Task task)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string param = null, uri = "/tasks/create/";</span><br class="calibre5"/><span class="calibre4"> object val = null;</span><br class="calibre5"/><span class="calibre4"> if ➋(task is FileTask)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> byte[] data;</span><br class="calibre5"/><span class="calibre4"> using (FileStream str = new ➌FileStream((task as FileTask).Filepath,</span><br class="calibre5"/><span class="calibre4"> FileMode.Open,</span><br class="calibre5"/><span class="calibre4"> FileAccess.Read))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> data = new byte[str.Length];</span><br class="calibre5"/><span class="calibre4"> str.➍Read(data, 0, data.Length);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> param = "file";</span><br class="calibre5"/><span class="calibre4"> uri += param;</span><br class="calibre5"/><span class="calibre4"> val = new ➎FileParameter(data, (task as FileTask).Filepath,</span><br class="calibre5"/><span class="calibre4"> "application/binary");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> IDictionary&lt;string, object&gt; ➏parms = new Dictionary&lt;string, object&gt;();</span><br class="calibre5"/><span class="calibre4"> parms.Add(param, val);</span><br class="calibre5"/><span class="calibre4"> parms.Add("package", task.Package);</span><br class="calibre5"/><span class="calibre4"> parms.Add("timeout", task.Timeout.ToString());</span><br class="calibre5"/><span class="calibre4"> parms.Add("options", task.Options);</span><br class="calibre5"/><span class="calibre4"> parms.Add("machine", ➐task.Machine);</span><br class="calibre5"/><span class="calibre4"> parms.Add("platform", task.Platform);</span><br class="calibre5"/><span class="calibre4"> parms.Add("custom", task.Custom);</span><br class="calibre5"/><span class="calibre4"> parms.Add("memory", task.EnableMemoryDump.ToString());</span><br class="calibre5"/><span class="calibre4"> parms.Add("enforce_timeout", task.EnableEnforceTimeout.ToString());</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> JObject resp = _session.➑ExecuteCommand(uri, "POST", parms);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return ➒(int)resp["task_id"];</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos592106" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-14: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">CreateTask()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The <span class="calibre4">CreateTask()</span> method ➊ starts by first checking whether the task passed in is a <span class="calibre4">FileTask</span> class ➋ (the class for describing a file or malware to be analyzed). Because Cuckoo Sandbox supports more than just analyzing files (such as URLs), the <span class="calibre4">CreateTask()</span> method can easily be extended to create different types of tasks this way. If the task is a <span class="calibre4">FileTask</span>, we open the file to send to Cuckoo Sandbox with a new <span class="calibre4">FileStream()</span> ➌ and then read the file into a byte array. Once the file has been read ➍, we create a new <span class="calibre4">FileParameter</span> class ➎ with the filename, the file bytes, and the content type <span class="calibre4">application/binary</span>.</p><p class="calibre_6">Then we set up the HTTP parameters we’ll be sending to Cuckoo Sandbox in a new <span class="calibre4">Dictionary</span> ➏. The HTTP parameters are specified in the Cuckoo Sandbox API documentation and should contain the information required to create a task. These parameters allow us to change default configuration items such as which VM to use ➐. Finally, we create the new task by calling <span class="calibre4">ExecuteCommand()</span> ➑ with the parameters in the dictionary and then return ➒ the new task ID.</p><p id="filepos593701" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">The Task Details and Reporting Methods</span></span></span></p><p class="calibre_11">A few more API calls need to be supported in order for us to submit our file to be analyzed and reported on, but they are much simpler than <span class="calibre4">CreateTask()</span>, as <a href="#filepos595416">Listing 8-15</a> details. We just create a method to show the task details, two methods to report on our tasks, and a method to clean up our sessions.</p><blockquote class="calibre_14"><span class="calibre4"> public Task ➊GetTaskDetails(int id)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string uri = ➋"/tasks/view/" + id;</span><br class="calibre5"/><span class="calibre4"> JObject resp = _session.➌ExecuteCommand(uri, "GET");</span><br class="calibre5"/><span class="calibre4"> ➍return TaskFactory.CreateTask(resp["task"]);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public JObject ➎GetTaskReport(int id)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return GetTaskReport(id, ➏"json");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public JObject ➐GetTaskReport(int id, string type)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string uri = ➑"/tasks/report/" + id + "/" + type;</span><br class="calibre5"/><span class="calibre4"> return _session.➒ExecuteCommand(uri, "GET");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public void ➓Dispose()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> _session = null;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos595416" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-15: Supporting methods for retrieving task information and reports</span></span></p><p class="calibre_6">The first method we implement is the <span class="calibre4">GetTaskDetails()</span> method ➊, which takes a task ID for the variable <span class="calibre4">id</span> as its only argument. We first create the URI we’ll make the HTTP request to by appending the ID argument to <span class="calibre4">/tasks/view</span> ➋, and then we call <span class="calibre4">ExecuteCommand()</span> ➌ with the new URI. This endpoint returns some information about the task, such as the name of the VM running the task and the task’s current status, which we can use to watch the task until it is finished. Finally, we use the <span class="calibre4">TaskFactory.CreateTask()</span> method ➍ to turn the JSON task returned by the API into a C# <span class="calibre4">Task</span> class, which we’ll create in the next section.</p><p class="calibre_6">The second method is a simple convenience method ➎. Because Cuckoo Sandbox supports multiple types of reports (JSON, XML, and so on), there are two <span class="calibre4">GetTaskReport()</span> methods, and the first is used only for JSON reports. It just accepts the ID of the task you want a report for as an argument and calls its overloaded sister method with the same ID passed, but with a second argument specifying that a JSON ➏ report should be returned. In the second <span class="calibre4">GetTaskReport()</span> method ➐, the task ID and report type are passed as arguments and then used to build the URI ➑ that will be requested in the API call. The new URI is passed to the <span class="calibre4">ExecuteCommand()</span> method ➒, and the report from Cuckoo Sandbox is returned.</p><p class="calibre_6"> Finally, the <span class="calibre4">Dispose()</span> method ➓, which completes the <span class="calibre4">IDisposable</span> interface, is implemented. This method cleans up the session that we used to communicate with the API, assigning <span class="calibre4">null</span> to the private <span class="calibre4">_session</span> variable.</p><p id="filepos597568" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating the Task Abstract Class</span></span></span></p><p class="calibre_11">Supporting the <span class="calibre4">CuckooSession</span> and <span class="calibre4">CuckooManager</span> classes is the <span class="calibre4">Task</span> class, an abstract class that stores most of the relevant information for a given task so that the information can easily be accessed as properties. <a href="#filepos601085">Listing 8-16</a> details the abstract <span class="calibre4">Task</span> class.</p><blockquote class="calibre_14"><span class="calibre4">public abstract class ➊Task</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> protected ➋Task(JToken token)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (token != null)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.AddedOn = ➌DateTime.Parse((string)token["added_on"]);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (token["completed_on"].Type != JTokenType.Null)</span><br class="calibre5"/><span class="calibre4"> this.CompletedOn = ➍DateTime.Parse(token["completed_on"].ToObject&lt;string&gt;());</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.Machine = (string)token["machine"];</span><br class="calibre5"/><span class="calibre4"> this.Errors = token["errors"].ToObject&lt;ArrayList&gt;();</span><br class="calibre5"/><span class="calibre4"> this.Custom = (string)token["custom"];</span><br class="calibre5"/><span class="calibre4"> this.EnableEnforceTimeout = (bool)token["enforce_timeout"];</span><br class="calibre5"/><span class="calibre4"> this.EnableMemoryDump = (bool)token["memory"];</span><br class="calibre5"/><span class="calibre4"> this.Guest = token["guest"];</span><br class="calibre5"/><span class="calibre4"> this.ID = (int)token["id"];</span><br class="calibre5"/><span class="calibre4"> this.Options = token["options"].ToString();</span><br class="calibre5"/><span class="calibre4"> this.Package = (string)token["package"];</span><br class="calibre5"/><span class="calibre4"> this.Platform = (string)token["platform"];</span><br class="calibre5"/><span class="calibre4"> this.Priority = (int)token["priority"];</span><br class="calibre5"/><span class="calibre4"> this.SampleID = (int)token["sample_id"];</span><br class="calibre5"/><span class="calibre4"> this.Status = (string)token["status"];</span><br class="calibre5"/><span class="calibre4"> this.Target = (string)token["target"];</span><br class="calibre5"/><span class="calibre4"> this.Timeout = (int)token["timeout"];</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public string Package { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int Timeout { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Options { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Machine { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Platform { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Custom { get; set; }</span><br class="calibre5"/><span class="calibre4"> public bool EnableMemoryDump { get; set; }</span><br class="calibre5"/><span class="calibre4"> public bool EnableEnforceTimeout { get; set; }</span><br class="calibre5"/><span class="calibre4"> public ArrayList Errors { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Target { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int SampleID { get; set; }</span><br class="calibre5"/><span class="calibre4"> public JToken Guest { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int Priority { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Status { get; set;}</span><br class="calibre5"/><span class="calibre4"> public int ID { get; set; }</span><br class="calibre5"/><span class="calibre4"> public DateTime AddedOn { get; set; }</span><br class="calibre5"/><span class="calibre4"> public DateTime CompletedOn { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos601085" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-16: The abstract</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Task</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">Although the abstract <span class="calibre4">Task</span> class ➊ looks complex at first, all the class has is a constructor and a dozen or so properties. The constructor ➋ accepts a <span class="calibre4">JToken</span> as an argument, which is a special JSON class like <span class="calibre4">JObject</span>. The <span class="calibre4">JToken</span> is used to assign all the task details from the JSON to C# properties in the class. The first property we assign with a value in the constructor is the <span class="calibre4">AddedOn</span> property. Using <span class="calibre4">DateTime.Parse()</span> ➌, the timestamp for when the task was created is parsed from a string to a <span class="calibre4">DateTime</span> class, which is assigned to <span class="calibre4">AddedOn</span>. The same is done for the <span class="calibre4">CompletedOn</span> property, also using <span class="calibre4">DateTime.Parse()</span> ➍, if the task has been completed. The rest of the properties are assigned directly using values from the JSON that was passed as the argument to the constructor.</p><p id="filepos602356" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Sorting and Creating Different Class Types</span></span></span></p><p class="calibre_11">Cuckoo Sandbox supports more than one type of task, even though we are only implementing one (the file analysis task). The <span class="calibre4">FileTask</span> class will inherit from the abstract <span class="calibre4">Task</span> class, but it adds a new property that stores the path of the file we want to send to Cuckoo to analyze. The other type of task supported by Cuckoo is a URL task that opens a given URL in a web browser and analyzes what happens (in case there is a drive-by exploit or other malware on the site).</p><p class="calibre_10"><span class="calibre3"><span class="bold">Creating the FileTask Class to Make File Analysis Tasks</span></span></p><p class="calibre_11">The <span class="calibre4">FileTask</span> class will be used to store the information we need to kick off an analysis of a file. It’s short and sweet, as <a href="#filepos603915">Listing 8-17</a> shows, since it inherits most of its properties from the <span class="calibre4">Task</span> class we just implemented.</p><blockquote class="calibre_14"><span class="calibre4">public class ➊FileTask : Task</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public ➋FileTask() : base(null) { }</span><br class="calibre5"/><span class="calibre4"> public ➌FileTask(JToken dict) : base(dict) { }</span><br class="calibre5"/><span class="calibre4"> public ➍string Filepath { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos603915" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-17: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">FileTask</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class that inherits from</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Task</span></span></p><p class="calibre_6">The simple <span class="calibre4">FileTask</span> class ➊, which inherits from the previous <span class="calibre4">Task</span> class, uses some advanced inheritance techniques available in C#. The class implements two different constructors, both of which pass their arguments to the base <span class="calibre4">Task</span> constructor as well. For instance, the first constructor ➋ accepts no arguments and passes a null value to the base class constructor. This allows us to keep a default constructor for the class that doesn’t require any arguments. The second constructor ➌, which accepts a single <span class="calibre4">JToken</span> class as its only argument, passes the JSON argument straight to the base constructor, which will populate the properties the <span class="calibre4">FileTask</span> class inherits from <span class="calibre4">Task</span>. This makes it easy to set up a <span class="calibre4">FileTask</span> using the JSON returned from the Cuckoo API. The only thing we have in the <span class="calibre4">FileTask</span> class that we don’t have in the generic <span class="calibre4">Task</span> class is the <span class="calibre4">Filepath</span> property ➍, which is only useful for submitting file analysis tasks.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Using the TaskFactory Class to Determine the Task Type to Create</span></span></p><p class="calibre_11">Java developers or others familiar with object-oriented programming may already know about the factory pattern used in object-oriented development. It is a flexible way to have a single class manage the creation of many similar but ultimately different types of classes (usually all inheriting from the same base class, but they could also all be implementing the same interface). The <span class="calibre4">TaskFactory</span> class (shown in <a href="#filepos607196">Listing 8-18</a>) is used to turn a JSON task returned by Cuckoo Sandbox in an API response into our C# <span class="calibre4">Task</span> class, be it a <span class="calibre4">FileTask</span> or otherwise—that is, if you choose to go the extra step and implement the URL task we described for homework!</p><blockquote class="calibre_14"><span class="calibre4">public static class ➊TaskFactory</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public static Task ➋CreateTask(JToken dict)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Task task = null;</span><br class="calibre5"/><span class="calibre4"> ➌switch((string)dict["category"])</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> case ➍"file":</span><br class="calibre5"/><span class="calibre4"> task = new ➎FileTask(dict);</span><br class="calibre5"/><span class="calibre4"> break;</span><br class="calibre5"/><span class="calibre4"> default:</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Don't know category: " + dict["category"]);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return ➏task;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos607196" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-18: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">TaskFactory</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">static class, which implements a very simple factory pattern commonly used in object-oriented programming</span></span></p><p class="calibre_6">The final class for us to implement is the <span class="calibre4">TaskFactory</span> static class ➊. This class is the glue that lets us turn JSON tasks from Cuckoo Sandbox into C# <span class="calibre4">FileTask</span> objects—and, if you choose to implement other task types in the future, you can also use <span class="calibre4">TaskFactory</span> to handle the creation of those tasks. The <span class="calibre4">TaskFactory</span> class has only a single static method called <span class="calibre4">CreateTask()</span> ➋, which accepts a <span class="calibre4">JToken</span> as its only argument. In the <span class="calibre4">CreateTask()</span> method, we use a <span class="calibre4">switch</span> statement ➌ to test the value of the task category. If the category is a <span class="calibre4">file</span> task ➍, we pass the <span class="calibre4">JToken</span> task to the <span class="calibre4">FileTask</span> constructor ➎ and then return the new C# task ➏. Although we won’t use other file types in this book, you can use this <span class="calibre4">switch</span> statement to create a different type of <span class="calibre4">Task</span>, such as a <span class="calibre4">url</span> task based on the <span class="calibre4">category</span>, and then return the result.</p><p id="filepos608734" class="calibre_10"><span class="calibre3"><span class="bold"> Putting It Together</span></span></p><p class="calibre_11">Finally, we have the scaffolding in place to start automating some malware analysis. <a href="#filepos611008">Listing 8-19</a> demonstrates using the <span class="calibre4">CuckooSession</span> and <span class="calibre4">CuckooManager</span> classes to create a file analysis task, watch the task until completion, and print the task’s JSON report to the console.</p><blockquote class="calibre_14"><span class="calibre4">public static void ➊Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> CuckooSession session = new ➋CuckooSession("127.0.0.1", 8090);</span><br class="calibre5"/><span class="calibre4"> using (CuckooManager manager = new ➌CuckooManager(session))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> FileTask task = new ➍FileTask();</span><br class="calibre5"/><span class="calibre4"> task.➎Filepath = "/var/www/payload.exe";</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> int taskID = manager.➏CreateTask(task);</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Created task: " + taskID);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> task = (FileTask)manager.➐GetTaskDetails(taskID);</span><br class="calibre5"/><span class="calibre4"> while(task.Status == "pending" || task.Status == "running")</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Waiting 30 seconds..."+task.Status);</span><br class="calibre5"/><span class="calibre4"> System.Threading.Thread.Sleep(30000);</span><br class="calibre5"/><span class="calibre4"> task = (FileTask)manager.GetTaskDetails(taskID);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (task.➑Status == "failure")</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> Console.Error.WriteLine("There was an error:");</span><br class="calibre5"/><span class="calibre4"> foreach (var error in task.Errors)</span><br class="calibre5"/><span class="calibre4"> Console.Error.WriteLine(error);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string report = manager.➒GetTaskReport(taskID).ToString();</span><br class="calibre5"/><span class="calibre4"> Console.➓WriteLine(report);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos611008" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-19: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method bringing the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">CuckooSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">and</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">CuckooManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">classes together</span></span></p><p class="calibre_6">In the <span class="calibre4">Main()</span> method ➊, we first create a new <span class="calibre4">CuckooSession</span> instance ➋, passing the IP address and the port to connect to when making API requests. With the new session created, in the context of a <span class="calibre4">using</span> statement, we create a new <span class="calibre4">CuckooManager</span> object ➌ and a new <span class="calibre4">FileTask</span> object ➍ as well. We also set the <span class="calibre4">Filepath</span> property ➎ on the task to a path on the filesystem with an executable we want to analyze. For testing purposes, you can generate payloads with Metasploit’s <span class="calibre4">msfvenom</span> (as we did in <a href="index_split_009.html#filepos344540">Chapter 4</a>) or use some of the payloads we wrote in <a href="index_split_009.html#filepos344540">Chapter 4</a>. With the <span class="calibre4">FileTask</span> set up with the file to scan, we pass the task to the manager’s <span class="calibre4">CreateTask()</span> method ➏ and store the ID returned for later use.</p><p class="calibre_6"> Once the task has been created, we call <span class="calibre4">GetTaskDetails()</span> ➐ and pass the task ID returned by <span class="calibre4">CreateTask()</span>. When we call <span class="calibre4">GetTaskDetails()</span>, a status is returned by the method. In this case, we are interested only in two statuses: <span class="calibre4">pending</span> and <span class="calibre4">failure</span>. As long as <span class="calibre4">GetTaskDetails()</span> returns a <span class="calibre4">pending</span> status, we print a friendly message to the user that the task is not done yet and have the application sleep for 30 seconds before calling <span class="calibre4">GetTaskDetails()</span> for the task status again. Once the status is no longer <span class="calibre4">pending</span>, we check whether the status is <span class="calibre4">failure</span> ➑ in case something went wrong during analysis. If the status of the task is <span class="calibre4">failure</span>, we print the error message returned by Cuckoo Sandbox.</p><p class="calibre_6">However, if the status is not <span class="calibre4">failure</span>, we can assume the task successfully completed analysis, and we can create a new report from Cuckoo Sandbox with the findings. We call the <span class="calibre4">GetTaskReport()</span> method ➒, passing the task ID as the only argument, and then print the report to the console screen with <span class="calibre4">WriteLine()</span> ➓.</p><p id="filepos613915" class="calibre_10"><span class="calibre3"><span class="bold">Testing the Application</span></span></p><p class="calibre_11">With the automation out of the way, we can finally drive our Cuckoo Sandbox instance to run and analyze a potentially nefarious Windows executable and then retrieve a report of the task that was run, as shown in <a href="#filepos617041">Listing 8-20</a>. Remember to run the instance as an administrator.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./ch8_automating_cuckoo.exe</span></span><br class="calibre5"/><span class="calibre4">Waiting 30 seconds...pending</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> "info": {</span><br class="calibre5"/><span class="calibre4"> "category": "file",</span><br class="calibre5"/><span class="calibre4"> "score": 0.0,</span><br class="calibre5"/><span class="calibre4"> "package": "",</span><br class="calibre5"/><span class="calibre4"> "started": "2016-05-19 15:56:44",</span><br class="calibre5"/><span class="calibre4"> "route": "none",</span><br class="calibre5"/><span class="calibre4"> "custom": "",</span><br class="calibre5"/><span class="calibre4"> "machine": {</span><br class="calibre5"/><span class="calibre4"> "status": "stopped",</span><br class="calibre5"/><span class="calibre4"> "name": "➊cuckoo1",</span><br class="calibre5"/><span class="calibre4"> "label": "cuckoo1",</span><br class="calibre5"/><span class="calibre4"> "manager": "VirtualBox",</span><br class="calibre5"/><span class="calibre4"> "started_on": "2016-05-19 15:56:44",</span><br class="calibre5"/><span class="calibre4"> "shutdown_on": "2016-05-19 15:57:09"</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"> "ended": "2016-05-19 15:57:09",</span><br class="calibre5"/><span class="calibre4"> "version": "2.0-rc2",</span><br class="calibre5"/><span class="calibre4"> "platform": "",</span><br class="calibre5"/><span class="calibre4"> "owner": "",</span><br class="calibre5"/><span class="calibre4"> "options": "",</span><br class="calibre5"/><span class="calibre4"> "id": 13,</span><br class="calibre5"/><span class="calibre4"> "duration": 25</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"> "signatures": [],</span><br class="calibre5"/><span class="calibre4"> "target": {</span><br class="calibre5"/><span class="calibre4"> "category": "file",</span><br class="calibre5"/><span class="calibre4"> "file": {</span><br class="calibre5"/><span class="calibre4"> "yara": [],</span><br class="calibre5"/><span class="calibre4"> "sha1": "f145181e095285feeb6897c9a6bd2e5f6585f294",</span><br class="calibre5"/><span class="calibre4"> "name": "bypassuac-x64.exe",</span><br class="calibre5"/><span class="calibre4"> "type": "PE32+ executable (console) x86-64, for MS Windows",</span><br class="calibre5"/><span class="calibre4"> "sha256": "➋2a694038d64bc9cfcd8caf6af35b6bfb29d2cb0c95baaeffb2a11cd6e60a73d1",</span><br class="calibre5"/><span class="calibre4"> "urls": [],</span><br class="calibre5"/><span class="calibre4"> "crc32": "26FB5E54",</span><br class="calibre5"/><span class="calibre4"> "path": "/home/bperry/tmp/cuckoo/storage/binaries/2a694038d2cb0c95baaeffb2a11cd6e60a73d1",</span><br class="calibre5"/><span class="calibre4"> "ssdeep": null,</span><br class="calibre5"/><span class="calibre4"> "size": 501248,</span><br class="calibre5"/><span class="calibre4"> "sha512":</span><br class="calibre5"/><span class="calibre4">"4b09f243a8fcd71ec5bf146002519304fdbaf99f1276da25d8eb637ecbc9cebbc49b580c51e36c96c8548a41c38cc76</span><br class="calibre5"/><span class="calibre4">595ad1776eb9bd0b96cac17ca109d4d88",</span><br class="calibre5"/><span class="calibre4"> "md5": "46a695c9a3b93390c11c1c072cf9ef7d"</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> },</span><br class="calibre5"/><span class="calibre4"><span class="italic">--snip--</span></span></blockquote><p id="filepos617041" class="calibre_15"><span class="calibre4"><span class="italic">Listing 8-20: The Cuckoo Sandbox analysis JSON report</span></span></p><p class="calibre_6">The analysis report from Cuckoo Sandbox is <span class="italic">huge</span>. It contains highly detailed information about what happened on the Windows system while your executable was running. The listing shows the basic metadata about the analysis, such as what machine ran the analysis ➊ and common hashes of the executable ➋. Once this report is dumped, we can begin to see what the malware did on an infected system and put together a plan for remediation and cleanup.</p><p class="calibre_6">Note that only part of the report is included here. What is not shown is the immense number of Windows API and system calls that were made, the files on the filesystem that were touched, and other incredibly detailed system information that allows you to more quickly determine what a malware sample may have done on a client’s machine. More information can be found on what exactly is reported and how to use it on the official Cuckoo Sandbox documentation site: <a href="http://docs.cuckoosandbox.org/en/latest/usage/results/"><span class="italic">http://docs.cuckoosandbox.org/en/latest/usage/results/</span></a>.</p><p class="calibre_6">As an exercise, you can save the full report to a file instead of printing to the console screen, since an output file might be more desirable for future malware analysis!</p><p id="filepos618536" class="calibre_10"><span class="calibre3"><span class="bold"> Conclusion</span></span></p><p class="calibre_11">The Cuckoo Sandbox is a powerful framework for malware analysis, and with the API feature, it can be easily integrated into work processes, infrastructures such as email servers, or even incident response playbooks. With the ability to run both files and arbitrary websites within a sandboxed and contained environment, security professionals can easily and quickly determine whether an attacker may have breached the network with a payload or drive-by exploit.</p><p class="calibre_6">In this chapter, we were able to drive this functionality of Cuckoo Sandbox programmatically using core C# classes and libraries. We created a handful of classes to communicate with the API and then created tasks and reported on them when they were finished. However, we only implemented support for doing file-based malware analysis. The classes we built, though, are meant to be extensible so that new types of tasks can be added and supported, such as a task that submits a URL to be opened in the web browser.</p><p class="calibre_6">With such a high-quality and useful framework available freely for all to use, anyone could add this functionality to their organization’s security-critical infrastructure and thus easily cut down the time it takes to discover and remediate potential breaches on home or enterprise networks.</p><div class="mbp_pagebreak" id="calibre_pb_13"/>
</body></html>