<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch1"><span epub:type="pagebreak" id="page_1"/><span class="big">1</span><br/>GO FUNDAMENTALS</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">This chapter will guide you through the process of setting up your Go development environment and introduce you to the language’s syntax. People have written entire books on the fundamental mechanics of the language; this chapter covers the most basic concepts you’ll need in order to work through the code examples in the following chapters. We’ll cover everything from primitive data types to implementing concurrency. For readers who are already well versed in the language, you’ll find much of this chapter to be a review.</p>&#13;
<h3 class="h3" id="ch1lev1sec1">Setting Up a Development Environment</h3>&#13;
<p class="noindent">To get started with Go, you’ll need a functional development environment. In this section, we’ll walk you through the steps to download Go and set up your workspace and environment variables. We’ll discuss various options for your integrated development environment and some of the standard tooling that comes with Go.</p>&#13;
<h4 class="h4" id="ch1lev2sec1"><span epub:type="pagebreak" id="page_2"/>Downloading and Installing Go</h4>&#13;
<p class="noindent">Start by downloading the Go binary release most appropriate to your operating system and architecture from <a href="https://golang.org/dl/"><em>https://golang.org/dl/</em></a>. Binaries exist for Windows, Linux, and macOS. If you’re using a system that doesn’t have an available precompiled binary, you can download the Go source code from that link.</p>&#13;
<p class="indent">Execute the binary and follow the prompts, which will be minimal, in order to install the entire set of Go core packages. <em>Packages</em>, called <em>libraries</em> in most other languages, contain useful code you can use in your Go programs.</p>&#13;
<h4 class="h4" id="ch1lev2sec2">Setting GOROOT to Define the Go Binary Location</h4>&#13;
<p class="noindent">Next, the operating system needs to know how to find the Go installation. In most instances, if you’ve installed Go in the default path, such as <em>/usr/local/go</em> on a *Nix/BSD-based system, you don’t have to take any action here. However, in the event that you’ve chosen to install Go in a nonstandard path or are installing Go on Windows, you’ll need to tell the operating system where to find the Go binary.</p>&#13;
<p class="indent">You can do this from your command line by setting the reserved <span class="literal">GOROOT</span> environment variable to the location of your binary. Setting environment variables is operating-system specific. On Linux or macOS, you can add this to your <em>~/.profile</em>:</p>&#13;
<pre><span class="codestrong1">set GOROOT=</span><span class="codeitalicst">/path/to/go</span></pre>&#13;
<p class="indent">On Windows, you can add this environment variable through the System (Control Panel), by clicking the <strong>Environment Variables</strong> button.</p>&#13;
<h4 class="h4" id="ch1lev2sec3">Setting GOPATH to Determine the Location of Your Go Workspace</h4>&#13;
<p class="noindent">Unlike setting your <span class="literal">GOROOT</span>, which is necessary in only certain installation scenarios, you must always define an environment variable named <span class="literal">GOPATH</span> to instruct the Go toolset where your source code, third-party libraries, and compiled programs will exist. This can be any location of your choosing. Once you’ve chosen or created this base workspace directory, create the following three subdirectories within: <em>bin</em>, <em>pkg</em>, and <em>src</em> (more on these directories shortly). Then, set an environment variable named <span class="literal">GOPATH</span> that points to your base workspace directory. For example, if you want to place your projects in a directory called <em>gocode</em> located within your home directory on Linux, you set <span class="literal">GOPATH</span> to the following:</p>&#13;
<pre>GOPATH=$HOME/gocode</pre>&#13;
<p class="indent">The <em>bin</em> directory will contain your compiled and installed Go executable binaries. Binaries that are built and installed will be automatically placed into this location. The <em>pkg</em> directory stores various package objects, including third-party Go dependencies that your code might rely on. For <span epub:type="pagebreak" id="page_3"/>example, perhaps you want to use another developer’s code that more elegantly handles HTTP routing. The <em>pkg</em> directory will contain the binary artifacts necessary to consume their implementation in your code. Finally, the <em>src</em> directory will contain all the evil source code you’ll write.</p>&#13;
<p class="indent">The location of your workspace is arbitrary, but the directories within must match this naming convention and structure. The compilation, build, and package management commands you’ll learn about later in this chapter all rely on this common directory structure. Without this important setup, Go projects won’t compile or be able to locate any of their necessary dependencies!</p>&#13;
<p class="indent">After configuring the necessary <span class="literal">GOROOT</span> and <span class="literal">GOPATH</span> environment variables, confirm that they’re properly set. You can do this on Linux and Windows via the <span class="literal">set</span> command. Also, check that your system can locate the binary and that you’ve installed the expected Go version with the <span class="literal">go version</span> command:</p>&#13;
<pre>$ <span class="codestrong1">go version</span>&#13;
go version go1.11.5 linux/amd64</pre>&#13;
<p class="indent">This command should return the version of the binary you installed.</p>&#13;
<h4 class="h4" id="ch1lev2sec4">Choosing an Integrated Development Environment</h4>&#13;
<p class="noindent">Next, you’ll probably want to select an integrated development environment (IDE) in which to write your code. Although an IDE isn’t required, many have features that help reduce errors in your code, add version-control shortcuts, aid in package management, and more. As Go is still a fairly young language, there may not be as many mature IDEs as for other languages.</p>&#13;
<p class="indent">Fortunately, advancements over the last few years leave you with several, full-featured options. We’ll review some of them in this chapter. For a more complete list of IDE or editor options, check out the Go wiki page at <a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins/"><em>https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins/</em></a>. This book is IDE/editor agnostic, meaning we won’t force you into any one solution.</p>&#13;
<h5 class="h5">Vim Editor</h5>&#13;
<p class="noindent">The <em>Vim</em> text editor, available in many operating-system distributions, provides a versatile, extensible, and completely open source development environment. One appealing feature of Vim is that it lets users run everything from their terminal without fancy GUIs getting in the way.</p>&#13;
<p class="indent">Vim contains a vast ecosystem of plug-ins through which you can customize themes, add version control, define snippets, add layout and code-navigation features, include autocomplete, perform syntax highlighting and linting, and much, much more. Vim’s most common plug-in management systems include Vundle and Pathogen.</p>&#13;
<p class="indent">To use Vim for Go, install the <span class="literal">vim-go</span> plug-in (<a href="https://github.com/fatih/vim-go/"><em>https://github.com/fatih/vim-go/</em></a>) shown in <a href="ch01.xhtml#ch1fig1">Figure 1-1</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_4"/><img src="Images/01fig01.jpg" alt="Image" width="925" height="463"/></div>&#13;
<p class="figcap" id="ch1fig1"><em>Figure 1-1: The <span class="literal">vim-go</span> plug-in</em></p>&#13;
<p class="indent">Of course, to use Vim for Go development, you’ll have to become comfortable with Vim. Further, customizing your development environment with all the features you desire might be a frustrating process. If you use Vim, which is free, you’ll likely need to sacrifice some of the conveniences of commercial IDEs.</p>&#13;
<h5 class="h5">GitHub Atom</h5>&#13;
<p class="noindent">GitHub’s IDE, called <em>Atom</em> (<em><a href="https://atom.io/">https://atom.io/</a></em>), is a hackable text editor with a large offering of community-driven packages. Unlike Vim, Atom provides a dedicated IDE application rather than an in-terminal solution, as shown in <a href="ch01.xhtml#ch1fig2">Figure 1-2</a>.</p>&#13;
<div class="image"><img src="Images/01fig02.jpg" alt="Image" width="925" height="531"/></div>&#13;
<p class="figcap" id="ch1fig2"><em>Figure 1-2: Atom with Go support</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_5"/>Like Vim, Atom is free. It provides tiling, package management, version control, debugging, autocomplete, and a myriad of additional features out of the box or through the use of the <span class="literal">go-plus</span> plug-in, which provides dedicated Go support (<em><a href="https://atom.io/packages/go-plus/">https://atom.io/packages/go-plus/</a></em>).</p>&#13;
<h5 class="h5">Microsoft Visual Studio Code</h5>&#13;
<p class="noindent">Microsoft’s <em>Visual Studio Code</em>, or <em>VS Code</em> (<em><a href="https://code.visualstudio.com">https://code.visualstudio.com</a></em>), is arguably one of the most feature-rich and easiest IDE applications to configure. VS Code, shown in <a href="ch01.xhtml#ch1fig3">Figure 1-3</a>, is completely open source and distributed under an MIT license.</p>&#13;
<div class="image"><img src="Images/01fig03.jpg" alt="Image" width="927" height="443"/></div>&#13;
<p class="figcap" id="ch1fig3"><em>Figure 1-3: The VS Code IDE with Go support</em></p>&#13;
<p class="indent">VS Code supports a diverse set of extensions for themes, versioning, code completion, debugging, linting, and formatting. You can get Go integration with the <span class="literal">vscode-go</span> extension (<em><a href="https://github.com/Microsoft/vscode-go/">https://github.com/Microsoft/vscode-go/</a></em>).</p>&#13;
<h5 class="h5">JetBrains GoLand</h5>&#13;
<p class="noindent">The JetBrains collection of development tools are efficient and feature-rich, making both professional development and hobbyist projects easy to accomplish. <a href="ch01.xhtml#ch1fig4">Figure 1-4</a> shows what the JetBrains GoLand IDE looks like.</p>&#13;
<p class="indent"><em>GoLand</em> is the JetBrains commercial IDE dedicated to the Go language. Pricing for GoLand ranges from free for students, to $89 annually for individuals, to $199 annually for organizations. GoLand offers all the expected features of a rich IDE, including debugging, code completion, version control, linting, formatting, and more. Although paying for a product may not sound appealing, commercial products such as GoLand typically have official support, documentation, timely bug fixes, and some of the other assurances that come with enterprise software.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_6"/><img src="Images/01fig04.jpg" alt="Image" width="925" height="433"/></div>&#13;
<p class="figcap" id="ch1fig4"><em>Figure 1-4: The GoLand commercial IDE</em></p>&#13;
<h4 class="h4" id="ch1lev2sec5">Using Common Go Tool Commands</h4>&#13;
<p class="noindent">Go ships with several useful commands that simplify the development process. The commands themselves are commonly included in IDEs, making the tooling consistent across development environments. Let’s take a look at some of these commands.</p>&#13;
<h5 class="h5">The go run Command</h5>&#13;
<p class="noindent">One of the more common commands you’ll execute during development, <span class="literal">go run</span> will compile and execute the <em>main package</em>—your program’s entry point.</p>&#13;
<p class="indent">As an example, save the following code under a project directory within <em>$GOPATH/src</em> (remember, you created this workspace during installation) as <em>main.go</em>:</p>&#13;
<pre>package main&#13;
import (&#13;
    "fmt"&#13;
)&#13;
func main() {&#13;
    fmt.Println("Hello, Black Hat Gophers!")&#13;
}</pre>&#13;
<p class="indent">From the command line, within the directory containing this file, execute <span class="literal">go run main.go</span>. You should see <span class="literal">Hello, Black Hat Gophers!</span> printed to your screen.</p>&#13;
<h5 class="h5">The go build Command</h5>&#13;
<p class="noindent">Note that <span class="literal">go run</span> executed your file, but it didn’t produce a standalone binary file. That’s where <span class="literal">go build</span> comes in. The <span class="literal">go build</span> command compiles your application, including any packages and their dependencies, <span epub:type="pagebreak" id="page_7"/>without installing the results. It creates a binary file on disk but doesn’t execute your program. The files it creates follow reasonable naming conventions, but it’s not uncommon to change the name of the created binary file by using the <span class="literal">-o output</span> command line option.</p>&#13;
<p class="indent">Rename <em>main.go</em> from the previous example to <em>hello.go</em>. In a terminal window, execute <span class="literal">go build hello.go</span>. If everything goes as intended, this command should create an executable file with the name <em>hello</em>. Now enter this command:</p>&#13;
<pre>$ <span class="codestrong1">./hello</span>&#13;
Hello, Black Hat Gophers!</pre>&#13;
<p class="indent">This should run the standalone binary file.</p>&#13;
<p class="indent">By default, the produced binary file contains debugging information and the symbol table. This can bloat the size of the file. To reduce the file size, you can include additional flags during the build process to strip this information from the binary. For example, the following command will reduce the binary size by approximately 30 percent:</p>&#13;
<pre>$ <span class="codestrong1">go build -ldflags "-w -s"</span></pre>&#13;
<p class="indent">Having a smaller binary will make it more efficient to transfer or embed while pursuing your nefarious endeavors.</p>&#13;
<h5 class="h5">Cross-Compiling</h5>&#13;
<p class="noindent">Using <span class="literal">go build</span> works great for running a binary on your current system or one of identical architecture, but what if you want to create a binary that can run on a different architecture? That’s where cross-compiling comes in. <em>Cross-compiling</em> is one of the coolest aspects of Go, as no other language can do it as easily. The <span class="literal">build</span> command allows you to cross-compile your program for multiple operating systems and architectures. Reference the official Go documentation at <em><a href="https://golang.org/doc/install/source#environment/">https://golang.org/doc/install/source#environment/</a></em> for further details regarding allowable combinations of compatible operating system and architecture compilation types.</p>&#13;
<p class="indent">To cross-compile, you need to set a <em>constraint</em>. This is just a means to pass information to the <span class="literal">build</span> command about the operating system and architecture for which you’d like to compile your code. These constraints include <span class="literal">GOOS</span> (for the operating system) and <span class="literal">GOARCH</span> (for the architecture).</p>&#13;
<p class="indent">You can introduce build constraints in three ways: via the command line, code comments, or a file suffix naming convention. We’ll discuss the command line method here and leave the other two methods for you to research if you wish.</p>&#13;
<p class="indent">Let’s suppose that you want to cross-compile your previous <em>hello.go</em> program residing on a macOS system so that it runs on a Linux 64-bit <span epub:type="pagebreak" id="page_8"/>architecture. You can accomplish this via the command line by setting the <span class="literal">GOOS</span> and <span class="literal">GOARCH</span> constraints when running the <span class="literal">build</span> command:</p>&#13;
<pre>$ <span class="codestrong1">GOOS="linux" GOARCH="amd64" go build hello.go</span>&#13;
$ <span class="codestrong1">ls</span>&#13;
hello  hello.go&#13;
$ <span class="codestrong1">file hello</span>&#13;
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped</pre>&#13;
<p class="indent">The output confirms that the resulting binary is a 64-bit ELF (Linux) file.</p>&#13;
<p class="indent">The cross-compilation process is much simpler in Go than in just about any other modern programming language. The only real “gotcha” happens when you try to cross-compile applications that use native C bindings. We’ll stay out of the weeds and let you dig into those challenges independently. Depending on the packages you import and the projects you develop, you may not have to worry about that very often.</p>&#13;
<h5 class="h5">The go doc Command</h5>&#13;
<p class="noindent">The <span class="literal">go doc</span> command lets you interrogate documentation about a package, function, method, or variable. This documentation is embedded as comments through your code. Let’s take a look at how to obtain details about the <span class="literal">fmt.Println()</span> function:</p>&#13;
<pre>$ <span class="codestrong1">go doc fmt.Println</span>&#13;
func Println(a ...interface{}) (n int, err error)&#13;
    Println formats using the default formats for its operands and writes to&#13;
    standard output. Spaces are always added between operands and a newline&#13;
    is appended. It returns the number of bytes written and any write error&#13;
    encountered.</pre>&#13;
<p class="indent">The output that <span class="literal">go doc</span> produces is taken directly out of the source code comments. As long as you adequately comment your packages, functions, methods, and variables, you’ll be able to automatically inspect the documentation via the <span class="literal">go doc</span> command.</p>&#13;
<h5 class="h5">The go get Command</h5>&#13;
<p class="noindent">Many of the Go programs that you’ll develop in this book will require third-party packages. To obtain package source code, use the <span class="literal">go get</span> command. For instance, let’s assume you’ve written the following code that imports the <span class="literal">stacktitan/ldapauth</span> package:</p>&#13;
<pre>   package main&#13;
&#13;
   import (&#13;
   "fmt"&#13;
   "net/http"&#13;
&#13;
<span class="ent">❶</span> "github.com/stacktitan/ldapauth"&#13;
   )</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_9"/>Even though you’ve imported the <span class="literal">stacktitan/ldapauth</span> package <span class="ent">❶</span>, you can’t access the package quite yet. You first have to run the <span class="literal">go get</span> command. Using <span class="literal">go get github.com/stacktitan/ldapauth</span> downloads the actual package and places it within the <em>$GOPATH/src</em> directory.</p>&#13;
<p class="indent">The following directory tree illustrates the placement of the <span class="literal">ldapauth</span> package within your <span class="literal">GOPATH</span> workspace:</p>&#13;
<pre>   $ <span class="codestrong1">tree src/github.com/stacktitan/</span>&#13;
<span class="ent">❶</span> src/github.com/stacktitan/&#13;
   └── ldapauth&#13;
       ├── LICENSE&#13;
       ├── README.md&#13;
       └── ldap_auth.go</pre>&#13;
<p class="indent">Notice that the path <span class="ent">❶</span> and the imported package name are constructed in a way that avoids assigning the same name to multiple packages. Using <span class="literal">github.com/stacktitan</span> as a preface to the actual package name <span class="literal">ldapauth</span> ensures that the package name remains unique.</p>&#13;
<p class="indent">Although Go developers traditionally install dependencies with <span class="literal">go get</span>, problems can arise if those dependent packages receive updates that break backward compatibility. Go has introduced two separate tools—<span class="literal">dep</span> and <span class="literal">mod</span>—to lock dependencies in order to prevent backward compatibility issues. However, this book almost exclusively uses <span class="literal">go get</span> to pull down dependencies. This will help avoid inconsistencies with ongoing dependency management tooling and hopefully make it easier for you to get the examples up and running.</p>&#13;
<h5 class="h5">The go fmt Command</h5>&#13;
<p class="noindent">The <span class="literal">go fmt</span> command automatically formats your source code. For example, running <span class="literal">go fmt</span> <span class="codeitalic">/path/to/your/package</span> will style your code by enforcing the use of proper line breaks, indentation, and brace alignment.</p>&#13;
<p class="indent">Adhering to arbitrary styling preferences might seem strange at first, particularly if they differ from your habits. However, you should find this consistency refreshing over time, as your code will look similar to other third-party packages and feel more organized. Most IDEs contain hooks that will automatically run <span class="literal">go fmt</span> when you save your file, so you don’t need to explicitly run the command.</p>&#13;
<h5 class="h5">The golint and go vet Commands</h5>&#13;
<p class="noindent">Whereas <span class="literal">go fmt</span> changes the syntactical styling of your code, <span class="literal">golint</span> reports style mistakes such as missing comments, variable naming that doesn’t follow conventions, useless type specifications, and more. Notice that <span class="literal">golint</span> is a standalone tool, and not a subcommand of the main <span class="literal">go</span> binary. You’ll need to install it separately by using <span class="literal">go get -u golang.org/x/lint/golint</span>.</p>&#13;
<p class="indent">Similarly, <span class="literal">go vet</span> inspects your code and uses heuristics to identify suspicious constructs, such as calling <span class="literal">Printf()</span> with the incorrect format string <span epub:type="pagebreak" id="page_10"/>types. The <span class="literal">go vet</span> command attempts to identify issues, some of which might be legitimate bugs, that a compiler might miss.</p>&#13;
<h5 class="h5">Go Playground</h5>&#13;
<p class="noindent">The <em>Go Playground</em> is an execution environment hosted at <a href="https://play.golang.org/"><em>https://play.golang.org/</em></a> that provides a web-based frontend for developers to quickly develop, test, execute, and share snippets of Go code. The site makes it easy to try out various Go features without having to install or run Go on your local system. It’s a great way to test snippets of code before integrating them within your projects.</p>&#13;
<p class="indent">It also allows you to simply play with various nuances of the language in a preconfigured environment. It’s worth noting that the Go Playground restricts you from calling certain dangerous functions to prevent you from, for example, executing operating-system commands or interacting with third-party websites.</p>&#13;
<h5 class="h5">Other Commands and Tools</h5>&#13;
<p class="noindent">Although we won’t explicitly discuss other tools and commands, we encourage you to do your own research. As you create increasingly complex projects, you’re likely to run into a desire to, for example, use the <span class="literal">go test</span> tool to run unit tests and benchmarks, <span class="literal">cover</span> to check for test coverage, <span class="literal">imports</span> to fix import statements, and more.</p>&#13;
<h3 class="h3" id="ch1lev1sec2">Understanding Go Syntax</h3>&#13;
<p class="noindent">An exhaustive review of the entire Go language would take multiple chapters, if not an entire book. This section gives a brief overview of Go’s syntax, particularly relative to data types, control structures, and common patterns. This should act as a refresher for casual Go coders and an introduction for those new to the language.</p>&#13;
<p class="indent">For an in-depth, progressive review of the language, we recommend that you work through the excellent <em>A Tour of Go</em> (<em><a href="https://tour.golang.org/">https://tour.golang.org/</a></em>) tutorial. It’s a comprehensive, hands-on discussion of the language broken into bite-sized lessons that use an embedded playground to enable you to try out each of the concepts.</p>&#13;
<p class="indent">The language itself is a much cleaner version of C that removes a lot of the lower-level nuances, resulting in better readability and easier adoption.</p>&#13;
<h4 class="h4" id="ch1lev2sec6">Data Types</h4>&#13;
<p class="noindent">Like most modern programming languages, Go provides a variety of primitive and complex data types. <em>Primitive types</em> consist of the basic building blocks (such as strings, numbers, and booleans) that you’re accustomed to in other languages. Primitives make up the foundation of all information used within a program. <em>Complex data types</em> are user-defined structures composed of a combination of one or more primitive or other complex types.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_11"/>Primitive Data Types</h5>&#13;
<p class="noindent">The primitive types include <span class="literal">bool</span>, <span class="literal">string</span>, <span class="literal">int</span>, <span class="literal">int8</span>, <span class="literal">int16</span>, <span class="literal">int32</span>, <span class="literal">int64</span>, <span class="literal">uint</span>, <span class="literal">uint8</span>, <span class="literal">uint16</span>, <span class="literal">uint32</span>, <span class="literal">uint64</span>, <span class="literal">uintptr</span>, <span class="literal">byte</span>, <span class="literal">rune</span>, <span class="literal">float32</span>, <span class="literal">float64</span>, <span class="literal">complex64</span>, and <span class="literal">complex128</span>.</p>&#13;
<p class="indent">You typically declare a variable’s type when you define it. If you don’t, the system will automatically infer the variable’s data type. Consider the following examples:</p>&#13;
<pre>var x = "Hello World"&#13;
z := int(42)</pre>&#13;
<p class="indent">In the first example, you use the keyword <span class="literal">var</span> to define a variable named <span class="literal">x</span> and assign to it the value <span class="literal">"Hello World"</span>. Go implicitly infers <span class="literal">x</span> to be a <span class="literal">string</span>, so you don’t have to declare that type. In the second example, you use the <span class="literal">:=</span> operator to define a new variable named <span class="literal">z</span> and assign to it an integer value of 42. There really is no difference between the two operators. We’ll use both throughout this book, but some people feel that the <span class="literal">:=</span> operator is an ugly symbol that reduces readability. Choose whatever works best for you.</p>&#13;
<p class="indent">In the preceding example, you explicitly wrap the 42 value in an <span class="literal">int</span> call to force a type on it. You could omit the <span class="literal">int</span> call but would have to accept whatever type the system automatically uses for that value. In some cases, this won’t be the type you intended to use. For instance, perhaps you want 42 to be represented as an unsigned integer, rather than an <span class="literal">int</span> type, in which case you’d have to explicitly wrap the value.</p>&#13;
<h5 class="h5">Slices and Maps</h5>&#13;
<p class="noindent">Go also has more-complex data types, such as slices and maps. <em>Slices</em> are like arrays that you can dynamically resize and pass to functions more efficiently. <em>Maps</em> are associative arrays, unordered lists of key/value pairs that allow you to efficiently and quickly look up values for a unique key.</p>&#13;
<p class="indent">There are all sorts of ways to define, initialize, and work with slices and maps. The following example demonstrates a common way to define both a slice <span class="literal">s</span> and a map <span class="literal">m</span> and add elements to both:</p>&#13;
<pre>var s = make([]string, 0)&#13;
var m = make(map[string]string)&#13;
s = append(s, "some string")&#13;
m["some key"] = "some value"</pre>&#13;
<p class="indent">This code uses the two built-in functions: <span class="literal">make()</span> to initialize each variable and <span class="literal">append()</span> to add a new item to a slice. The last line adds the key/value pair of <span class="literal">some key</span> and <span class="literal">some value</span> to the map <span class="literal">m</span>. We recommend that you read the official Go documentation to explore all the methods for defining and using these data types.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_12"/>Pointers, Structs, and Interfaces</h5>&#13;
<p class="noindent">A <em>pointer</em> points to a particular area in memory and allows you to retrieve the value stored there. As you do in C, you use the <span class="literal">&amp;</span> operator to retrieve the address in memory of some variable, and the <span class="literal">*</span> operator to dereference the address. The following example illustrates this:</p>&#13;
<pre><span class="ent">❶</span> var count = int(42)&#13;
<span class="ent">❷</span> ptr := &amp;count&#13;
<span class="ent">❸</span> fmt.Println(*ptr)&#13;
<span class="ent">❹</span> *ptr = 100&#13;
<span class="ent">❺</span> fmt.Println(count)</pre>&#13;
<p class="indent">The code defines an integer, <span class="literal">count</span> <span class="ent">❶</span>, and then creates a pointer <span class="ent">❷</span> by using the <span class="literal">&amp;</span> operator. This returns the address of the <span class="literal">count</span> variable. You dereference the variable <span class="ent">❸</span> while making a call to <span class="literal">fmt.Println()</span> to log the value of <span class="literal">count</span> to stdout. You then use the <span class="literal">*</span> operator <span class="ent">❹</span> to assign a new value to the memory location pointed to by <span class="literal">ptr</span>. Because this is the address of the <span class="literal">count</span> variable, the assignment changes the value of that variable, which you confirm by printing it to the screen <span class="ent">❺</span>.</p>&#13;
<p class="indent">You use the <em>struct</em> type to define new data types by specifying the type’s associated fields and methods. For example, the following code defines a <span class="literal">Person</span> type:</p>&#13;
<pre><span class="ent">❶</span> type Person struct {&#13;
    <span class="ent">❷</span> Name string&#13;
    <span class="ent">❸</span> Age int&#13;
   }&#13;
<span class="ent">❹</span> func (p *Person) SayHello() {&#13;
       fmt.Println("Hello,", p.Name<span class="ent">❺</span>)&#13;
   }&#13;
   func main() {&#13;
       var guy =  new<span class="ent">❻</span>(Person)&#13;
    <span class="ent">❼</span> guy.Name = "Dave"&#13;
    <span class="ent">❽</span> guy.SayHello()&#13;
   }</pre>&#13;
<p class="indent">The code uses the <span class="literal">type</span> keyword <span class="ent">❶</span> to define a new struct containing two fields: a <span class="literal">string</span> named <span class="literal">Name</span> <span class="ent">❷</span> and an <span class="literal">int</span> named <span class="literal">Age</span> <span class="ent">❸</span>.</p>&#13;
<p class="indent">You define a method, <span class="literal">SayHello()</span>, on the <span class="literal">Person</span> type assigned to variable <span class="literal">p</span> <span class="ent">❹</span>. The method prints a greeting message to stdout by looking at the struct, <span class="literal">p</span> <span class="ent">❺</span>, that received the call. Think of <span class="literal">p</span> as a reference to <span class="literal">self</span> or <span class="literal">this</span> in other languages. You also define a function, <span class="literal">main()</span>, which acts as the program’s entry point. This function uses the <span class="literal">new</span> keyword <span class="ent">❻</span> to initialize a new <span class="literal">Person</span>. It assigns the name <span class="literal">Dave</span> to the person <span class="ent">❼</span> and then tells the person to <span class="literal">SayHello()</span> <span class="ent">❽</span>.</p>&#13;
<p class="indent">Structs lack scoping modifiers—such as private, public, or protected—that are commonly used in other languages to control access to their members. Instead, Go uses capitalization to determine scope: types and fields that begin with a capital letter are exported and accessible outside <span epub:type="pagebreak" id="page_13"/>the package, whereas those starting with a lowercase letter are private, accessible only within the package.</p>&#13;
<p class="indent">You can think of Go’s <em>interface</em> type as a blueprint or a contract. This blueprint defines an expected set of actions that any concrete implementation must fulfill in order to be considered a type of that interface. To define an interface, you define a set of methods; any data type that contains those methods with the correct signatures fulfills the contract and is considered a type of that interface. Let’s take a look at an example:</p>&#13;
<pre><span class="ent">❶</span> type Friend interface {&#13;
    <span class="ent">❷</span> SayHello()&#13;
   }</pre>&#13;
<p class="indent">In this sample, you’ve defined an interface called <span class="literal">Friend</span> <span class="ent">❶</span> that requires one method to be implemented: <span class="literal">SayHello()</span> <span class="ent">❷</span>. That means that any type that implements the <span class="literal">SayHello()</span> method is a <span class="literal">Friend</span>. Notice that the <span class="literal">Friend</span> interface doesn’t actually implement that function—it just says that if you’re a <span class="literal">Friend</span>, you need to be able to <span class="literal">SayHello()</span>.</p>&#13;
<p class="indent">The following function, <span class="literal">Greet()</span>, takes a <span class="literal">Friend</span> interface as input and says hello in a <span class="literal">Friend</span>-specific way:</p>&#13;
<pre>func Greet<span class="ent">❶</span> (f Friend<span class="ent">❷</span>) {&#13;
    f.SayHello()&#13;
}</pre>&#13;
<p class="indent">You can pass any <span class="literal">Friend</span> type to the function. Luckily, the <span class="literal">Person</span> type used in the previous example can <span class="literal">SayHello()</span>—it’s a <span class="literal">Friend</span>. Therefore, if a function named <span class="literal">Greet()</span> <span class="ent">❶</span>, as shown in the preceding code, expects a <span class="literal">Friend</span> as an input parameter <span class="ent">❷</span>, you can pass it a <span class="literal">Person</span>, like this:</p>&#13;
<pre>func main() {&#13;
    var guy = new(Person)&#13;
    guy.Name = "Dave"&#13;
    Greet(guy)&#13;
}</pre>&#13;
<p class="indent">Using interfaces and structs, you can define multiple types that you can pass to the same <span class="literal">Greet()</span> function, so long as these types implement the <span class="literal">Friend</span> interface. Consider this modified example:</p>&#13;
<pre><span class="ent">❶</span> type Dog struct {}&#13;
   func (d *Dog) SayHello()<span class="ent">❷</span> {&#13;
       fmt.Println("Woof woof")&#13;
   }&#13;
   func main() {&#13;
       var guy = new(Person)&#13;
       guy.Name = "Dave"&#13;
    <span class="ent">❸</span> Greet(guy)&#13;
       var dog = new(Dog)&#13;
    <span class="ent">❹</span> Greet(dog)&#13;
   }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_14"/>The example shows a new type, <span class="literal">Dog</span> <span class="ent">❶</span>, that is able to <span class="literal">SayHello()</span> <span class="ent">❷</span> and, therefore, is a <span class="literal">Friend</span>. You are able to <span class="literal">Greet()</span> both a <span class="literal">Person</span> <span class="ent">❸</span> and a <span class="literal">Dog</span> <span class="ent">❹</span>, since both are capable of <span class="literal">SayHello()</span>.</p>&#13;
<p class="indent">We’ll cover interfaces multiple times throughout the book to help you better understand the concept.</p>&#13;
<h4 class="h4" id="ch1lev2sec7">Control Structures</h4>&#13;
<p class="noindent">Go contains slightly fewer control structures than other modern languages. Despite that, you can still accomplish complex processing, including conditionals and loops, with Go.</p>&#13;
<p class="indent">Go’s primary conditional is the if/else structure:</p>&#13;
<pre>if x == 1 {&#13;
    fmt.Println("X is equal to 1")&#13;
} else {&#13;
    fmt.Println("X is not equal to 1")&#13;
}</pre>&#13;
<p class="indent">Go’s syntax deviates slightly from the syntax of other languages. For instance, you don’t wrap the conditional check—in this case, <span class="literal">x == 1</span>—in parentheses. You must wrap all code blocks, even the preceding single-line blocks, in braces. Many other modern languages make the braces optional for single-line blocks, but they’re required in Go.</p>&#13;
<p class="indent">For conditionals involving more than two choices, Go provides a <span class="literal">switch</span> statement. The following is an example:</p>&#13;
<pre>switch x<span class="ent">❶</span> {&#13;
    case "foo"<span class="ent">❷</span>:&#13;
        fmt.Println("Found foo")&#13;
    case "bar"<span class="ent">❸</span>:&#13;
        fmt.Println("Found bar")&#13;
    default<span class="ent">❹</span>:&#13;
        fmt.Println("Default case")&#13;
}</pre>&#13;
<p class="indent">In this example, the <span class="literal">switch</span> statement compares the contents of a variable <span class="literal">x</span> <span class="ent">❶</span> against various values—<span class="literal">foo</span> <span class="ent">❷</span> and <span class="literal">bar</span> <span class="ent">❸</span>—and logs a message to stdout if <span class="literal">x</span> matches one of the conditions. This example includes a <span class="literal">default</span> case <span class="ent">❹</span>, which executes in the event that none of the other conditions match.</p>&#13;
<p class="indent">Note that, unlike many other modern languages, your cases don’t have to include <span class="literal">break</span> statements. In other languages, execution often continues through each of the cases until the code reaches a <span class="literal">break</span> statement or the end of the <span class="literal">switch</span>. Go will execute no more than one matching or default case.</p>&#13;
<p class="indent">Go also contains a special variation on the <span class="literal">switch</span> called a <em>type switch</em> that performs type assertions by using a <span class="literal">switch</span> statement. Type switches are useful for trying to understand the underlying type of an interface. <span epub:type="pagebreak" id="page_15"/>For example, you might use a type switch to retrieve the underlying type of an interface called <span class="literal">i</span>:</p>&#13;
<pre>func foo(i<span class="ent">❶</span> interface{}) {&#13;
    switch v := i.(type)<span class="ent">❷</span> {&#13;
    case int:&#13;
        fmt.Println("I'm an integer!")&#13;
    case string:&#13;
        fmt.Println("I'm a string!")&#13;
    default:&#13;
        fmt.Println("Unknown type!")&#13;
    }&#13;
}</pre>&#13;
<p class="indent">This example uses special syntax, <span class="literal">i.(type)</span> <span class="ent">❷</span>, to retrieve the type of the <span class="literal">i</span> <span class="literal">interface</span> variable <span class="ent">❶</span>. You use this value in a <span class="literal">switch</span> statement in which each case matches against a specific type. In this example, your cases check for <span class="literal">int</span> or <span class="literal">string</span> primitive types, but you could very well check for pointers or user-defined struct types, for instance.</p>&#13;
<p class="indent">Go’s last flow control structure is the <span class="literal">for</span> loop. The <span class="literal">for</span> loop is Go’s exclusive construct for performing iteration or repeating sections of code. It might seem odd to not have conventions such as <span class="literal">do</span> or <span class="literal">while</span> loops at your disposal, but you can re-create them by using variations of the <span class="literal">for</span> loop syntax. Here’s one variation of a <span class="literal">for</span> loop:</p>&#13;
<pre>for i := 0; i &lt; 10; i++ {&#13;
    fmt.Println(i)&#13;
}</pre>&#13;
<p class="indent">The code loops through numbers 0 to 9, printing each number to stdout. Notice the semicolons in the first line. Unlike many other languages, which use semicolons as line delimiters, Go uses them for various control structures to perform multiple distinct, but related, subtasks in a single line of code. The first line uses the semicolons to separate the initialization logic (<span class="literal">i := 0</span>), the conditional expression (<span class="literal">i &lt; 10</span>), and the post statement (<span class="literal">i++</span>). This structure should be very, very familiar to anyone who has coded in any modern language, as it closely follows the conventions of those languages.</p>&#13;
<p class="indent">The following example shows a slight variation of the <span class="literal">for</span> loop that loops over a collection, such as a slice or a map:</p>&#13;
<pre><span class="ent">❶</span> nums := []int{2,4,6,8}&#13;
   for idx<span class="ent">❷</span>, val<span class="ent">❸</span> := range<span class="ent">❹</span> nums {&#13;
       fmt.Println(idx, val)&#13;
   }</pre>&#13;
<p class="indent">In this example, you initialize a slice of integers named <span class="literal">nums</span> <span class="ent">❶</span>. You then use the keyword <span class="literal">range</span> <span class="ent">❹</span> within the <span class="literal">for</span> loop to iterate over the slice. The <span class="literal">range</span> keyword returns two values: the current index <span class="ent">❷</span> and a copy of the current value <span class="ent">❸</span> at that index. If you don’t intend to use the index, you could replace <span class="literal">idx</span> in the <span class="literal">for</span> loop with an underscore to tell Go you won’t need it.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_16"/>You can use this exact same looping logic with maps as well to return each key/value pair.</p>&#13;
<h4 class="h4" id="ch1lev2sec8">Concurrency</h4>&#13;
<p class="noindent">Much like the control structures already reviewed, Go has a much simpler concurrency model than other languages. To execute code concurrently, you can use <em>goroutines</em>, which are functions or methods that can run simultaneously. These are often described as <em>lightweight threads</em> because the cost of creating them is minimal when compared to actual threads.</p>&#13;
<p class="indent">To create a goroutine, use the <span class="literal">go</span> keyword before the call to a method or function you wish to run concurrently:</p>&#13;
<pre><span class="ent">❶</span> func f() {&#13;
       fmt.Println("f function")&#13;
   }&#13;
&#13;
   func main() {&#13;
    <span class="ent">❷</span> go f()&#13;
       time.Sleep(1 * time.Second)&#13;
       fmt.Println("main function")&#13;
   }</pre>&#13;
<p class="indent">In this example, you define a function, <span class="literal">f()</span> <span class="ent">❶</span>, that you call in your <span class="literal">main()</span> function, the program’s entry point. You preface the call with the keyword <span class="literal">go</span> <span class="ent">❷</span>, meaning that the program will run function <span class="literal">f()</span> concurrently; in other words, the execution of your <span class="literal">main()</span> function will continue without waiting for <span class="literal">f()</span> to complete. You then use a <span class="literal">time.Sleep(1 * time.Second)</span> to force the <span class="literal">main()</span> function to pause temporarily so that <span class="literal">f()</span> can complete. If you didn’t pause the <span class="literal">main()</span> function, the program would likely exit prior to the completion of function <span class="literal">f()</span>, and you would never see its results displayed to stdout. Done correctly, you’ll see messages printed to stdout indicating that you’ve finished executing both the <span class="literal">f()</span> and <span class="literal">main()</span> functions.</p>&#13;
<p class="indent">Go contains a data type called <em>channels</em> that provide a mechanism through which goroutines can synchronize their execution and communicate with one another. Let’s look at an example that uses channels to display the length of different strings and their sum simultaneously:</p>&#13;
<pre><span class="ent">❶</span> func strlen(s string, c chan int) {&#13;
    <span class="ent">❷</span> c &lt;- len(s)&#13;
   }&#13;
&#13;
   func main() {&#13;
    <span class="ent">❸</span> c := make(chan int)&#13;
    <span class="ent">❹</span> go strlen("Salutations", c)&#13;
       go strlen("World", c)&#13;
    <span class="ent">❺</span> x, y := &lt;-c, &lt;-c&#13;
       fmt.Println(x, y, x+y)&#13;
   }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_17"/>First, you define and use a variable <span class="literal">c</span> of type <span class="literal">chan int</span>. You can define channels of various types, depending on the type of data you intend to pass via the channel. In this case, you’ll be passing the lengths of various strings as integer values between goroutines, so you should use an <span class="literal">int</span> channel.</p>&#13;
<p class="indent">Notice a new operator: <span class="literal">&lt;-</span>. This operator indicates whether the data is flowing to or from a channel. You can think of this as the equivalent of placing items into a bucket or removing items from a bucket.</p>&#13;
<p class="indent">The function you define, <span class="literal">strlen()</span> <span class="ent">❶</span>, accepts a word as a string, as well as a channel that you’ll use for synchronizing data. The function contains a single statement, <span class="literal">c &lt;- len(s)</span> <span class="ent">❷</span>, which uses the built-in <span class="literal">len()</span> function to determine the length of the string, and then puts the result into the <span class="literal">c</span> channel by using the <span class="literal">&lt;-</span> operator.</p>&#13;
<p class="indent">The <span class="literal">main()</span> function pieces everything together. First, you issue a call to <span class="literal">make(chan int)</span> <span class="ent">❸</span> to create the integer channel. You then issue multiple concurrent calls to the <span class="literal">strlen()</span> function by using the <span class="literal">go</span> keyword <span class="ent">❹</span>, which spins up multiple goroutines. You pass to the <span class="literal">strlen()</span> function two string values, as well as the channel into which you want the results placed. Lastly, you read data from the channel by using the <span class="literal">&lt;-</span> operator <span class="ent">❺</span>, this time with data flowing from the channel. This means you’re taking items out of your bucket, so to speak, and assigning those values to the variables <span class="literal">x</span> and <span class="literal">y</span>. Note that execution blocks at this line until adequate data can be read from the channel.</p>&#13;
<p class="indent">When the line completes, you display the length of each string as well as their sum to stdout. In this example, it produces the following output:</p>&#13;
<pre>5 11 16</pre>&#13;
<p class="indent">This may seem overwhelming, but it’s key to highlight basic concurrency patterns, as Go shines in this area. Because concurrency and parallelism in Go can become rather complicated, feel free to explore on your own. Throughout this book, we’ll talk about more realistic and complicated implementations of concurrency as we introduce buffered channels, wait groups, mutexes, and more.</p>&#13;
<h4 class="h4" id="ch1lev2sec9">Error Handling</h4>&#13;
<p class="noindent">Unlike most other modern programming languages, Go does not include syntax for try/catch/finally error handling. Instead, it adopts a minimalistic approach that encourages you to check for errors where they occur rather than allowing them to “bubble up” to other functions in the call chain.</p>&#13;
<p class="indent">Go defines a built-in error type with the following <span class="literal">interface</span> declaration:</p>&#13;
<pre>type error interface {&#13;
    Error() string&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_18"/>This means you can use any data type that implements a method named <span class="literal">Error()</span>, which returns a <span class="literal">string</span> value, as an <span class="literal">error</span>. For example, here’s a custom error you could define and use throughout your code:</p>&#13;
<pre><span class="ent">❶</span> type MyError string&#13;
   func (e MyError) Error() string<span class="ent">❷</span> {&#13;
       return string(e)&#13;
   }</pre>&#13;
<p class="indent">You create a user-defined string type named <span class="literal">MyError</span> <span class="ent">❶</span> and implement an <span class="literal">Error() string</span> method <span class="ent">❷</span> for the type.</p>&#13;
<p class="indent">When it comes to error handling, you’ll quickly get accustomed to the following pattern:</p>&#13;
<pre>func foo() error {&#13;
    return errors.New("Some Error Occurred")&#13;
}&#13;
func main() {&#13;
    if err := foo()<span class="ent">❶</span>;err != nil<span class="ent">❷</span> {&#13;
        // Handle the error&#13;
    }&#13;
}</pre>&#13;
<p class="indent">You’ll find that it’s fairly common for functions and methods to return at least one value. One of these values is almost always an <span class="literal">error</span>. In Go, the <span class="literal">error</span> returned may be a value of <span class="literal">nil</span>, indicating that the function generated no error and everything seemingly ran as expected. A non-<span class="literal">nil</span> value means something broke in the function.</p>&#13;
<p class="indent">Thus, you can check for errors by using an <span class="literal">if</span> statement, as shown in the <span class="literal">main()</span> function. You’ll typically see multiple statements, separated by a semicolon. The first statement calls the function and assigns the resulting error to a variable <span class="ent">❶</span>. The second statement then checks whether that <span class="literal">error</span> is <span class="literal">nil</span> <span class="ent">❷</span>. You use the body of the <span class="literal">if</span> statement to handle the error.</p>&#13;
<p class="indent">You’ll find that philosophies differ on the best way to handle and log errors in Go. One of the challenges is that, unlike other languages, Go’s built-in error type doesn’t implicitly include a stack trace to help you pinpoint the error’s context or location. Although you can certainly generate one and assign it to a custom type in your application, its implementation is left up to the developers. This can be a little annoying at first, but you can manage it through proper application design.</p>&#13;
<h4 class="h4" id="ch1lev2sec10">Handling Structured Data</h4>&#13;
<p class="noindent">Security practitioners will often write code that handles <em>structured data</em>, or data with common encoding, such as JSON or XML. Go contains standard packages for data encoding. The most common packages you’re likely to use include <span class="literal">encoding/json</span> and <span class="literal">encoding/xml</span>.</p>&#13;
<p class="indent">Both packages can marshal and unmarshal arbitrary data structures, which means they can turn strings to structures, and structures to strings. <span epub:type="pagebreak" id="page_19"/>Let’s look at the following sample, which serializes a structure to a byte slice and then subsequently deserializes the byte slice back to a structure:</p>&#13;
<pre><span class="ent">❶</span> type Foo struct {&#13;
       Bar string&#13;
       Baz string&#13;
   }&#13;
&#13;
   func main() {&#13;
    <span class="ent">❷</span> f := Foo{"Joe Junior", "Hello Shabado"}&#13;
       b, _<span class="ent">❸</span> := json.Marshal<span class="ent">❹</span>(f<span class="ent">❺</span>)&#13;
    <span class="ent">❻</span> fmt.Println(string(b))&#13;
       json.Unmarshal(b<span class="ent">❼</span>, &amp;f<span class="ent">❽</span>)&#13;
   }</pre>&#13;
<p class="indent">This code (which deviates from best practices and ignores possible errors) defines a <span class="literal">struct</span> type named <span class="literal">Foo</span> <span class="ent">❶</span>. You initialize it in your <span class="literal">main()</span> function <span class="ent">❷</span> and then make a call to <span class="literal">json.Marshal()</span> <span class="ent">❹</span>, passing it the <span class="literal">Foo</span> instance <span class="ent">❺</span>. This <span class="literal">Marshal()</span> method encodes the <span class="literal">struct</span> to JSON, returning a <span class="literal">byte</span> slice <span class="ent">❸</span> that you subsequently print to stdout <span class="ent">❻</span>. The output, shown here, is a JSON-encoded string representation of our <span class="literal">Foo</span> struct:</p>&#13;
<pre>{"Bar":"Joe Junior","Baz":"Hello Shabado"}</pre>&#13;
<p class="indent">Lastly, you take that same <span class="literal">byte</span> slice <span class="ent">❼</span> and decode it via a call to <span class="literal">json.Unmarshal(b, &amp;f)</span>. This produces a <span class="literal">Foo</span> struct instance <span class="ent">❽</span>. Dealing with XML is nearly identical to this process.</p>&#13;
<p class="indent">When working with JSON and XML, you’ll commonly use <em>field tags</em>, which are metadata elements that you assign to your struct fields to define how the marshaling and unmarshaling logic can find and treat the affiliated elements. Numerous variations of these field tags exist, but here is a short example that demonstrates their usage for handling XML:</p>&#13;
<pre>type Foo struct {&#13;
    Bar     string    `xml:"id,attr"`&#13;
    Baz     string    `xml:"parent&gt;child"`&#13;
}</pre>&#13;
<p class="indent">The string values, wrapped in backticks and following the struct fields, are field tags. <em>Field tags</em> always begin with the tag name (<span class="literal">xml</span> in this case), followed by a colon and the directive enclosed in double quotes. The <em>directive</em> defines how the fields should be handled. In this case, you are supplying directives that declare that <span class="literal">Bar</span> should be treated as an attribute named <span class="literal">id</span>, not an element, and that <span class="literal">Baz</span> should be found in a subelement of <span class="literal">parent</span>, named <span class="literal">child</span>. If you modify the previous JSON example to now encode the structure as XML, you would see the following result:</p>&#13;
<pre>&lt;Foo id="Joe Junior"&gt;&lt;parent&gt;&lt;child&gt;Hello Shabado&lt;/child&gt;&lt;/parent&gt;&lt;/Foo&gt;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_20"/>The XML encoder reflectively determines the names of elements, using the tag directives, so each field is handled according to your needs.</p>&#13;
<p class="indent">Throughout this book, you’ll see these field tags used for dealing with other data serialization formats, including ASN.1 and MessagePack. We’ll also discuss some relevant examples of defining your own custom tags, specifically when you learn how to handle the Server Message Block (SMB) Protocol.</p>&#13;
<h3 class="h3" id="ch1lev1sec3">Summary</h3>&#13;
<p class="noindent">In this chapter, you set up your Go environment and learned about the fundamental aspects of the Go language. This is not an exhaustive list of all Go’s characteristics; the language is far too nuanced and large for us to cram it all into a single chapter. Instead, we included the aspects that will be most useful in the chapters that follow. We’ll now turn our attention to practical applications of the language for security practitioners and hackers. Here we Go!</p>&#13;
</div>



  </body></html>