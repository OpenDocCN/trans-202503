- en: '12'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: AUTOMATING ARACHNI
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化 Arachni
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: Arachni is a powerful web application black-box security scanner written in
    Ruby. It features support for many types of web application vulnerabilities, including
    many of the OWASP Top 10 vulnerabilities (such as XSS and SQL injection); a highly
    scalable distributed architecture that allows you to spin up scanners in a cluster
    dynamically; and full automation through both a remote procedure call (RPC) interface
    and a representational state transfer (REST) interface. In this chapter, you’ll
    learn how to drive Arachni with its REST API and then with its RPC interface to
    scan a given URL for web application vulnerabilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni 是一个强大的 Web 应用程序黑盒安全扫描工具，使用 Ruby 编写。它支持多种 Web 应用程序漏洞的检测，包括许多 OWASP 十大漏洞（如
    XSS 和 SQL 注入）；具有高度可扩展的分布式架构，可以动态启动集群中的扫描器；并通过远程过程调用（RPC）接口和表现性状态转移（REST）接口实现完全自动化。在本章中，你将学习如何使用
    Arachni 的 REST API，然后使用其 RPC 接口扫描给定 URL 中的 Web 应用程序漏洞。
- en: Installing Arachni
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Arachni
- en: The Arachni website ([http://www.arachni-scanner.com/](http://www.arachni-scanner.com/))
    gives you the current download package for Arachni across multiple operating systems.
    You can use these installers to set up Arachni on your own system. Once you’ve
    downloaded it, you can test it by running Arachni against a server designed to
    test for web vulnerabilities, as shown in [Listing 12-1](#filepos816231). Although
    this command isn’t using the RPC to drive Arachni just yet, you can see what kind
    of output we will get when scanning for potential XSS or SQL injection vulnerabilities.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni 网站（[http://www.arachni-scanner.com/](http://www.arachni-scanner.com/)）提供了适用于多个操作系统的
    Arachni 下载包。你可以使用这些安装程序在自己的系统上安装 Arachni。下载后，你可以通过运行 Arachni 来测试针对 Web 漏洞的服务器，正如
    [Listing 12-1](#filepos816231) 中所示。虽然此命令尚未使用 RPC 来驱动 Arachni，但你可以看到在扫描潜在的 XSS
    或 SQL 注入漏洞时会得到什么样的输出。
- en: $ arachni --checks xss*,sql* --scope-auto-redundant 2 \
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ arachni --checks xss*,sql* --scope-auto-redundant 2 \
- en: '"http://demo.testfire.net/default.aspx"'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"http://demo.testfire.net/default.aspx"'
- en: 'Listing 12-1: Running Arachni against an intentionally vulnerable website'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-1: 使用 Arachni 扫描一个故意易受攻击的网站'
- en: This command uses Arachni to check for XSS and SQL vulnerabilities in the website
    [http://demo.testfire.net/default.aspx](http://demo.testfire.net/default.aspx).
    We limit the scope of the pages it will follow by setting --scope-auto-redundant
    to 2. Doing so makes Arachni follow URLs with the same parameters but with different
    parameter values up to twice before moving on to a new URL. Arachni can scan more
    quickly when a lot of links with the same parameters are available but all go
    to the same page.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用 Arachni 检查网站 [http://demo.testfire.net/default.aspx](http://demo.testfire.net/default.aspx)
    中的 XSS 和 SQL 漏洞。我们通过设置 --scope-auto-redundant 为 2 限制其跟踪的页面范围。这样，Arachni 会在继续扫描新
    URL 之前，最多跟踪带有相同参数但不同参数值的 URL 两次。当有很多带有相同参数的链接指向同一页面时，Arachni 扫描的速度会更快。
- en: NOTE
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a full introduction to and documentation of the supported vulnerability
    checks in Arachni, visit the Arachni GitHub page detailing the command line arguments:
    [https://www.github.com/Arachni/arachni/wiki/Command-line-user-interface#checks/](https://www.github.com/Arachni/arachni/wiki/Command-line-user-interface#checks/).'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要全面了解 Arachni 中支持的漏洞检测及相关文档，请访问 Arachni 的 GitHub 页面，其中详细介绍了命令行参数：[https://www.github.com/Arachni/arachni/wiki/Command-line-user-interface#checks/](https://www.github.com/Arachni/arachni/wiki/Command-line-user-interface#checks/)。
- en: Within just a few minutes (depending on your internet speed), Arachni should
    report back a handful of XSS and SQL injection vulnerabilities in the website.
    Don’t worry—they’re supposed to be there! This website was built to be vulnerable.
    Later in the chapter, when testing our custom C# automation, you can use this
    list of XSS, SQL injection, and other vulnerabilities to ensure your automation
    is returning the correct results.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在几分钟内（取决于你的互联网速度），Arachni 应该会报告该网站中一些 XSS 和 SQL 注入漏洞。别担心——它们是故意存在的！这个网站是专门设计为易受攻击的。稍后，在测试我们的自定义
    C# 自动化时，你可以使用这个 XSS、SQL 注入和其他漏洞的列表，确保你的自动化程序返回正确的结果。
- en: But let’s say you want to automatically run Arachni against an arbitrary build
    of your web application as part of a secure software development life cycle (SDLC).
    Running it by hand isn’t very efficient, but we can easily automate Arachni to
    kick off scan jobs so it can work with any continuous integration system to pass
    or fail builds depending on the results of the scans. That’s where the REST API
    comes in.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想将 Arachni 自动运行在你的 web 应用的任意版本上，作为安全软件开发生命周期（SDLC）的一部分。手动运行并不高效，但我们可以轻松地自动化
    Arachni，以便启动扫描任务，这样它就可以与任何持续集成系统配合使用，根据扫描结果来决定构建是否通过或失败。这就是 REST API 的作用所在。
- en: The Arachni REST API
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni REST API
- en: Recently, a REST API was introduced so that simple HTTP requests can be used
    to drive Arachni. [Listing 12-2](#filepos819464) shows how to start this API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Arachni 引入了一个 REST API，可以通过简单的 HTTP 请求来驱动 Arachni。[列表 12-2](#filepos819464)
    展示了如何启动这个 API。
- en: $ arachni_rest_server
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ arachni_rest_server
- en: Arachni - Web Application Security Scanner Framework v2.0dev
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Arachni - 网络应用安全扫描框架 v2.0dev
- en: 'Author: Tasos "Zapotek" Laskos <tasos.laskos@arachni-scanner.com>'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '作者: Tasos "Zapotek" Laskos <tasos.laskos@arachni-scanner.com>'
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (With the support of the community and the Arachni Team.)
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （在社区和 Arachni 团队的支持下。）
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Website: http://arachni-scanner.com'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '网站: http://arachni-scanner.com'
- en: 'Documentation: http://arachni-scanner.com/wiki'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '文档: http://arachni-scanner.com/wiki'
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➊[*] Listening on http://127.0.0.1:7331
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊[*] 正在监听 http://127.0.0.1:7331
- en: 'Listing 12-2: Running the Arachni REST server'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 12-2: 运行 Arachni REST 服务器'
- en: When you start the server, Arachni will output some information about itself,
    including the IP address and port it is listening on ➊. Once you know the server
    is working, you can start using the API.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动服务器时，Arachni 会输出一些关于它的信息，包括它监听的 IP 地址和端口 ➊。一旦你确认服务器工作正常，就可以开始使用 API。
- en: With the REST API, you can start a simple scan using any common HTTP utility
    such as curl or even netcat. In this book, we’ll use curl as we have in previous
    chapters. Our first scan is shown in [Listing 12-3](#filepos820821).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 REST API，你可以使用任何常见的 HTTP 工具，如 curl 或 netcat，启动一个简单的扫描。在本书中，我们将继续使用 curl，和之前的章节一样。我们的第一次扫描如
    [列表 12-3](#filepos820821) 所示。
- en: $ curl -X POST --data '{"url":"http://demo.testfire.net/default.aspx"}'➊ \
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ curl -X POST --data '{"url":"http://demo.testfire.net/default.aspx"}'➊ \
- en: http://127.0.0.1:7331/scans
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: http://127.0.0.1:7331/scans
- en: '{"id":"b139f787f2d59800fc97c34c48863bed"}➋'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{"id":"b139f787f2d59800fc97c34c48863bed"}➋'
- en: $ curl http://127.0.0.1:7331/scans/b139f787f2d59800fc97c34c48863bed➌
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ curl http://127.0.0.1:7331/scans/b139f787f2d59800fc97c34c48863bed➌
- en: '{"status":"done","busy":false,"seed":"676fc9ded9dc44b8a32154d1458e20de",'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{"status":"done","busy":false,"seed":"676fc9ded9dc44b8a32154d1458e20de",'
- en: --snip--
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: --省略--
- en: 'Listing 12-3: Testing the REST API with curl'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 12-3: 使用 curl 测试 REST API'
- en: To kick off a scan, all we need to do is make a POST request with some JSON
    in the request body ➊. We start a new Arachni scan by passing JSON with the URL
    to scan using the --data argument from curl and send that to the /scans endpoint.
    The ID of the new scan is returned in the HTTP response ➋. After creating the
    scan, we can also retrieve the current scan status and results with a simple HTTP
    GET request (the default request type for curl) ➌. We do this by calling on the
    IP address and port Arachni is listening on and appending the ID we obtained when
    creating the scan for the scans request to the /scans/ URL endpoint. After the
    scan finishes, the scan log will contain any vulnerabilities found during scanning,
    such as XSS, SQL injection, and other common web application vulnerabilities.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动扫描，我们需要做的就是发送一个带有 JSON 数据的 POST 请求 ➊。我们通过 curl 的 --data 参数传递包含扫描 URL 的 JSON，发送到
    /scans 端点，从而启动一个新的 Arachni 扫描。新扫描的 ID 会在 HTTP 响应中返回 ➋。创建扫描后，我们还可以通过一个简单的 HTTP
    GET 请求（curl 的默认请求类型）检索当前扫描的状态和结果 ➌。我们通过调用 Arachni 所监听的 IP 地址和端口，并附加在创建扫描时获得的 ID，将其添加到
    /scans/ URL 端点来完成这个请求。扫描完成后，扫描日志将包含扫描过程中发现的任何漏洞，如 XSS、SQL 注入和其他常见的 web 应用漏洞。
- en: Once this is done and we have an idea of how the REST API works, we can start
    writing the code that will allow us to use the API to scan any site we have an
    address for.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们就能了解 REST API 的工作原理，然后可以开始编写代码，使我们能够使用 API 扫描任何有地址的网站。
- en: Creating the ArachniHTTPSession Class
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 ArachniHTTPSession 类
- en: As in previous chapters, we will implement both a session and a manager class
    to interact with the Arachni API. Currently, these classes are relatively simple,
    but breaking them out now allows greater flexibility should the API require authentication
    or extra steps in the future. [Listing 12-4](#filepos824524) details the ArachniHTTPSession
    class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前章节所述，我们将实现一个会话类和一个管理器类，以便与 Arachni API 进行交互。目前，这些类相对简单，但现在将它们拆开可以在未来如果 API
    需要身份验证或额外步骤时提供更大的灵活性。 [Listing 12-4](#filepos824524) 详细说明了 ArachniHTTPSession
    类。
- en: public class ArachniHTTPSession
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class ArachniHTTPSession
- en: '{'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public ➊ArachniHTTPSession(string host, int port)
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➊ArachniHTTPSession(string host, int port)
- en: '{'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Host = host;
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Host = host;
- en: this.Port = port;
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Port = port;
- en: '}'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Host { get; set; }
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Host { get; set; }
- en: public int Port { get; set; }
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int Port { get; set; }
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject ➋ExecuteRequest(string method, string uri, JObject data = null)
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject ➋ExecuteRequest(string method, string uri, JObject data = null)
- en: '{'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string url = "http://" + this.Host + ":" + this.Port.ToString() + uri;
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string url = "http://" + this.Host + ":" + this.Port.ToString() + uri;
- en: HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
- en: request.Method = method;
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.Method = method;
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (data != null)
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (data != null)
- en: '{'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string dataString = data.ToString();
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string dataString = data.ToString();
- en: byte[] dataBytes = System.Text.Encoding.UTF8.GetBytes(dataString);
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] dataBytes = System.Text.Encoding.UTF8.GetBytes(dataString);
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: request.ContentType = "application/json";
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.ContentType = "application/json";
- en: request.ContentLength = dataBytes.Length;
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.ContentLength = dataBytes.Length;
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: request.GetRequestStream().Write(dataBytes, 0, dataBytes.Length);
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.GetRequestStream().Write(dataBytes, 0, dataBytes.Length);
- en: '}'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string resp = string.Empty;
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string resp = string.Empty;
- en: using (StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream()))
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream()))
- en: resp = reader.ReadToEnd();
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = reader.ReadToEnd();
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return JObject.Parse(resp);
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return JObject.Parse(resp);
- en: '}'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 12-4: The  ArachniHTTPSession  class'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-4: ArachniHTTPSession 类'
- en: At this point in the book, the ArachniHTTPSession class should be fairly simple
    to read and understand, so we won’t go too deep into the code. We create a constructor
    ➊ that accepts two arguments—the host and port to connect to—and assigns the values
    to the corresponding properties. We then create a method to execute a generic
    HTTP request ➋ based on the parameters passed to the method. The ExecuteRequest()
    method should return a JObject with any data that will be returned by a given
    API endpoint. Because the ExecuteRequest() method can be used to make any API
    call against Arachni, the only thing we can expect is that the response will be
    JSON that can be parsed from the server’s response into a JObject.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，ArachniHTTPSession 类应该比较容易理解，因此我们不会过于深入代码。我们创建了一个构造函数 ➊，该构造函数接受两个参数——要连接的主机和端口，并将这些值分配给相应的属性。然后，我们创建一个方法来执行基于传递给该方法的参数的通用
    HTTP 请求 ➋。ExecuteRequest() 方法应该返回一个 JObject，其中包含由给定 API 端点返回的任何数据。由于 ExecuteRequest()
    方法可以用于对 Arachni 发起任何 API 调用，我们唯一可以预期的是响应将是 JSON，可以从服务器的响应解析为 JObject。
- en: Creating the ArachniHTTPManager Class
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 ArachniHTTPManager 类
- en: The ArachniHTTPManager class should also seem simple at this point, as [Listing
    12-5](#filepos827045) shows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ArachniHTTPManager 类此时应该看起来非常简单，如 [Listing 12-5](#filepos827045) 所示。
- en: public class ArachniHTTPManager
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class ArachniHTTPManager
- en: '{'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ArachniHTTPSession _session;
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ArachniHTTPSession _session;
- en: public ➊ArachniHTTPManager(ArachniHTTPSession session)
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ➊ArachniHTTPManager(ArachniHTTPSession session)
- en: '{'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: _session = session;
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _session = session;
- en: '}'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public JObject ➋StartScan(string url, JObject options = ➌null)
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject ➋StartScan(string url, JObject options = ➌null)
- en: '{'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: JObject data = new JObject();
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject data = new JObject();
- en: data["url"] = url;
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: data["url"] = url;
- en: data.Merge(options);
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: data.Merge(options);
- en: ''
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return _session.ExecuteRequest("POST", "/scans", data);
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.ExecuteRequest("POST", "/scans", data);
- en: '}'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject ➍GetScanStatus(Guid id)
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public JObject ➍GetScanStatus(Guid id)
- en: '{'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.ExecuteRequest("GET", "/scans/" + id.ToString ("N"));
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.ExecuteRequest("GET", "/scans/" + id.ToString("N"));
- en: '}'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 12-5: The  ArachniHTTPManager  class'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-5: ArachniHTTPManager 类'
- en: 'Our ArachniHTTPManager constructor ➊ accepts a single argument—the session
    to use for executing requests—and then assigns the session to a local private
    variable for use later. We then create two methods: StartScan() ➋ and GetScanStatus()
    ➍. These methods are all we need to create a small tool to scan and report on
    a URL.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 ArachniHTTPManager 构造函数 ➊ 接受一个参数——用于执行请求的会话，并将该会话分配给本地私有变量，以便稍后使用。然后我们创建了两个方法：StartScan()
    ➋ 和 GetScanStatus() ➍。这些方法是我们创建一个扫描并报告 URL 的小工具所需的一切。
- en: The StartScan() method accepts two arguments, one of which is optional with
    a default value of null ➌. By default, you can just specify a URL with no scan
    options to StartScan(), and Arachni will simply spider the site without checking
    for vulnerabilities—a feature that could give you an idea of how much surface
    area the web application has (that is, how many pages and forms there are to test).
    However, we actually want to specify extra arguments to tune the Arachni scan,
    so we’ll go ahead and merge those options into our data JObject, and then we’ll
    POST the scan details to the Arachni API and return the JSON sent back. The GetScanStatus()
    method makes a simple GET request, using the ID of the scan passed into the method
    in the URL of the API, and then returns the JSON response to the caller.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: StartScan()方法接受两个参数，其中一个是可选的，默认值为null ➌。默认情况下，您只需指定一个URL而不传入扫描选项，StartScan()方法会让Arachni仅爬取站点而不检查漏洞——这一特性可以帮助您了解Web应用程序的表面面积（即有多少页面和表单需要测试）。然而，我们实际上希望指定额外的参数来调整Arachni扫描，因此我们将这些选项合并到我们的数据JObject中，然后将扫描详情POST到Arachni
    API并返回JSON响应。GetScanStatus()方法通过简单的GET请求，使用扫描ID作为URL中的API参数，并返回JSON响应给调用者。
- en: Putting the Session and Manager Classes Together
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将Session和Manager类结合起来
- en: With both of the classes implemented, we can start scanning, as [Listing 12-6](#filepos830456)
    shows.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了这两个类后，我们就可以开始扫描了，正如[Listing 12-6](#filepos830456)所示。
- en: public static void Main(string[] args)
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ArachniHTTPSession session = new ArachniHTTPSession("127.0.0.1", 7331);
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ArachniHTTPSession session = new ArachniHTTPSession("127.0.0.1", 7331);
- en: ArachniHTTPManager manager = new ArachniHTTPManager(session);
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ArachniHTTPManager manager = new ArachniHTTPManager(session);
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➊JObject scanOptions = new JObject();
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊JObject scanOptions = new JObject();
- en: scanOptions["checks"] = new JArray() { "xss*", "sql*" } ;
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scanOptions["checks"] = new JArray() { "xss*", "sql*" };
- en: scanOptions["audit"] = new JObject();
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scanOptions["audit"] = new JObject();
- en: scanOptions["audit"]["elements"] = new JArray() { "links", "forms" };
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scanOptions["audit"]["elements"] = new JArray() { "links", "forms" };
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string url = "http://demo.testfire.net/default.aspx";
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string url = "http://demo.testfire.net/default.aspx";
- en: JObject scanId = manager.➋StartScan(url, scanOptions);
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject scanId = manager.➋StartScan(url, scanOptions);
- en: Guid id = Guid.Parse(scanId["id"].ToString());
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Guid id = Guid.Parse(scanId["id"].ToString());
- en: JObject scan = manager.➌GetScanStatus(id);
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject scan = manager.➌GetScanStatus(id);
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: while (scan["status"].ToString() != "done")
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: while (scan["status"].ToString() != "done")
- en: '{'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Console.WriteLine("Sleeping a bit until scan is finished");
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("稍等片刻，直到扫描完成");
- en: System.Threading.Thread.Sleep(10000);
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: System.Threading.Thread.Sleep(10000);
- en: scan = manager.GetScanStatus(id);
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: scan = manager.GetScanStatus(id);
- en: '}'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➍Console.WriteLine(scan.ToString());
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➍Console.WriteLine(scan.ToString());
- en: '}'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 12-6: Driving Arachni with the  ArachniHTTPSession  and  ArachniHTTPManager  classes'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-6: 使用ArachniHTTPSession和ArachniHTTPManager类驱动Arachni'
- en: After instantiating our session and manager classes, we create a new JObject
    ➊ to store our scan options in. These options directly correlate with the command
    line options you see from the Arachni tool when running arachni –help (there’s
    a lot). By storing a JArray with the values xss* and sql* in the checks option
    key, we tell Arachni to run XSS and SQL injection tests against the website, rather
    than simply spidering the application and finding all possible pages and forms.
    The audit option key just below that tells Arachni to audit links it finds and
    any HTML forms for checks we tell it to run.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化我们的会话（session）和管理器（manager）类之后，我们创建了一个新的JObject ➊来存储我们的扫描选项。这些选项与您在运行`arachni
    --help`时看到的命令行选项直接相关（有很多）。通过在“checks”选项键中存储包含xss*和sql*值的JArray，我们告诉Arachni对网站进行XSS和SQL注入测试，而不仅仅是爬取应用程序并查找所有可能的页面和表单。下面的“audit”选项键则告诉Arachni审核它找到的链接以及我们要求它运行的任何HTML表单。
- en: After setting up the scan options, we start the scan by calling the StartScan()
    method ➋ and passing our test URL as the argument. Using the ID returned by StartScan(),
    we retrieve the current scan status with GetScanStatus() ➌ and then loop until
    the scan is finished, checking every second for a new scan status. Once this is
    finished, we print the JSON scan results to the screen ➍.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完扫描选项后，我们通过调用StartScan()方法➋并传入我们的测试URL作为参数来启动扫描。使用StartScan()返回的ID，我们通过GetScanStatus()
    ➌获取当前扫描状态，然后循环检查直到扫描完成，每秒检查一次新的扫描状态。扫描完成后，我们将JSON格式的扫描结果打印到屏幕上 ➍。
- en: The Arachni REST API is simple and easily accessible to most security engineers
    or hobbyists since it can be used with basic command line tools. It is also highly
    automatable using the most common C# libraries, and it should be an easy introduction
    for an SDLC or for general automatic use on your own websites for weekly or monthly
    scans. For some extra fun, try running Arachni with your automation against previous
    web applications from the book with known vulnerabilities, such as BadStore. Now
    that we’ve looked at the Arachni API, we can discuss how to automate its RPC.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni REST API简单且易于大多数安全工程师或爱好者访问，因为它可以使用基本的命令行工具。它也非常容易通过常见的C#库进行自动化，应该是SDLC或在你自己的网站上进行每周或每月扫描的一个轻松入门。为了增加一些趣味，尝试使用你的自动化工具将Arachni与书中已知漏洞的前Web应用程序（如BadStore）一起运行。现在我们已经了解了Arachni
    API，可以讨论如何自动化它的RPC。
- en: The Arachni RPC
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni RPC
- en: 'The Arachni RPC protocol is a bit more advanced than the API, but it’s also
    more powerful. Although also powered by MSGPACK, just like Metasploit’s RPC, Arachni’s
    protocol has a twist. The data is sometimes Gzip compressed and is only communicated
    over a regular TCP socket, not HTTP. This complexity has its benefits: the RPC
    is blazingly fast without the HTTP overhead, and it gives you more scanner management
    power than the API, including the abilities to spin scanners up and down at will
    and create distributed scanning clusters, thus allowing clusters of Arachni to
    balance scanning across multiple instances. Long story short, the RPC is very
    powerful, but expect more development focus and support for the REST API because
    it is more accessible to most developers.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni RPC协议比API更为先进，但也更强大。虽然和Metasploit的RPC一样也由MSGPACK支持，Arachni的协议却有些不同。数据有时会进行Gzip压缩，并且只能通过常规的TCP套接字进行通信，而不是HTTP。这种复杂性有其优点：RPC没有HTTP开销，因此速度极快，而且它比API提供了更多的扫描器管理功能，包括随时启动和停止扫描器的能力，并能够创建分布式扫描集群，从而允许多个Arachni实例之间进行扫描负载均衡。简而言之，RPC非常强大，但预计REST
    API将会获得更多的开发关注和支持，因为它对大多数开发者更加易于接触。
- en: Manually Running the RPC
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 手动运行RPC
- en: To start an RPC listener, we use the simple script arachni_rpcd, as shown in
    [Listing 12-7](#filepos834772).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个RPC监听器，我们使用简单的脚本arachni_rpcd，如[示例 12-7](#filepos834772)所示。
- en: $ arachni_rpcd
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ arachni_rpcd
- en: Arachni - Web Application Security Scanner Framework v2.0dev
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Arachni - Web应用程序安全扫描框架 v2.0dev
- en: 'Author: Tasos "Zapotek" Laskos <tasos.laskos@arachni-scanner.com>'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作者：Tasos "Zapotek" Laskos <tasos.laskos@arachni-scanner.com>
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (With the support of the community and the Arachni Team.)
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （在社区和Arachni团队的支持下。）
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Website: http://arachni-scanner.com'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网站：http://arachni-scanner.com
- en: 'Documentation: http://arachni-scanner.com/wiki'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 文档： http://arachni-scanner.com/wiki
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I,[2016-01-16T18:23:29.000746 #18862] INFO - System: RPC Server started.'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '我，[2016-01-16T18:23:29.000746 #18862] 信息 - 系统：RPC服务器已启动。'
- en: 'I,[2016-01-16T18:23:29.000834 #18862] INFO - System: Listening on ➊127.0.0.1:7331'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '我，[2016-01-16T18:23:29.000834 #18862] 信息 - 系统：监听地址 ➊127.0.0.1:7331'
- en: 'Listing 12-7: Running the Arachni RPC server'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-7：运行Arachni RPC服务器
- en: Now we can test the listener using another script shipped with Arachni called
    arachni_rpc. Note the dispatcher URL ➊ in the output of the listening RPC server.
    We’ll need it next. The arachni_rpc script that ships with Arachni allows you
    to interface with the RPC listener from the command line. After starting the arachni_rpcd
    listener, open another terminal and change to the Arachni project root directory;
    then kick off a scan using the arachni_rpc script, as shown in [Listing 12-8](#filepos835803).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用另一个随Arachni一起提供的脚本来测试监听器，叫做arachni_rpc。注意在RPC服务器的输出中显示的调度器URL ➊。接下来我们需要用到它。随Arachni一起提供的arachni_rpc脚本允许你通过命令行与RPC监听器进行交互。在启动arachni_rpcd监听器后，打开另一个终端，切换到Arachni项目的根目录；然后使用arachni_rpc脚本启动扫描，如[示例
    12-8](#filepos835803)所示。
- en: $ arachni_rpc --dispatcher-url 127.0.0.1:7331 \
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ arachni_rpc --dispatcher-url 127.0.0.1:7331 \
- en: '"http://demo.testfire.net/default.aspx"'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"http://demo.testfire.net/default.aspx"'
- en: 'Listing 12-8: Running an Arachni scan of the same intentionally vulnerable
    website via the RPC'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-8：通过RPC运行Arachni扫描同一个故意存在漏洞的网站
- en: This command will drive Arachni to use the MSGPACK RPC, just as our C# code
    will do soon. If this is successful, you should see a nice text-based UI updating
    you on the status of the current scan with a nice report at the end, as [Listing
    12-9](#filepos839265) shows.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将驱动Arachni使用MSGPACK RPC，就像我们接下来将在C#代码中做到的那样。如果成功，你应该会看到一个基于文本的用户界面，实时更新当前扫描的状态，并在扫描结束时显示漂亮的报告，正如[示例
    12-9](#filepos839265)所示。
- en: Arachni - Web Application Security Scanner Framework v2.0dev
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Arachni - Web应用程序安全扫描框架 v2.0dev
- en: 'Author: Tasos "Zapotek" Laskos <tasos.laskos@arachni-scanner.com>'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作者：Tasos "Zapotek" Laskos <tasos.laskos@arachni-scanner.com>
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (With the support of the community and the Arachni Team.)
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （在社区和 Arachni 团队的支持下。）
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Website: http://arachni-scanner.com'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网站： http://arachni-scanner.com
- en: 'Documentation: http://arachni-scanner.com/wiki'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 文档： http://arachni-scanner.com/wiki
- en: '[~] 10 issues have been detected.'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 已检测到 10 个问题。'
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[+] 1 | Cross-Site Scripting (XSS) in script context at'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[+] 1 | 在脚本上下文中的 Cross-Site Scripting (XSS) 在'
- en: http://demo.testfire.net/search.aspx in form input `txtSearch` using GET.
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: http://demo.testfire.net/search.aspx 中的表单输入 `txtSearch` 使用 GET。
- en: '[+] 2 | Cross-Site Scripting (XSS) at http://demo.testfire.net/search.aspx'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[+] 2 | 在 http://demo.testfire.net/search.aspx 的 Cross-Site Scripting (XSS)'
- en: in form input `txtSearch` using GET.
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在表单输入 `txtSearch` 中使用 GET。
- en: '[+] 3 | Common directory at http://demo.testfire.net/PR/ in server.'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[+] 3 | 在服务器的 http://demo.testfire.net/PR/ 中找到常见目录。'
- en: '[+] 4 | Backup file at http://demo.testfire.net/default.exe in server.'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[+] 4 | 在服务器的 http://demo.testfire.net/default.exe 中备份文件。'
- en: '[+] 5 | Missing ''X-Frame-Options'' header at http://demo.testfire.net/default.aspx
    in server.'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[+] 5 | 在 http://demo.testfire.net/default.aspx 的服务器中缺少 ''X-Frame-Options''
    头。'
- en: '[+] 6 | Common administration interface at http://demo.testfire.net/admin.aspx
    in server.'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[+] 6 | 在服务器的 http://demo.testfire.net/admin.aspx 中找到常见的管理界面。'
- en: '[+] 7 | Common administration interface at http://demo.testfire.net/admin.htm
    in server.'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[+] 7 | 在服务器的 http://demo.testfire.net/admin.htm 中找到常见的管理界面。'
- en: '[+] 8 | Interesting response at http://demo.testfire.net/default.aspx in server.'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[+] 8 | 在服务器的 http://demo.testfire.net/default.aspx 收到有趣的响应。'
- en: '[+] 9 | HttpOnly cookie at http://demo.testfire.net/default.aspx in cookie
    with inputs'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[+] 9 | 在 http://demo.testfire.net/default.aspx 的 cookie 中有 HttpOnly cookie
    和输入'
- en: '`amSessionId`.'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`amSessionId`。'
- en: '[+] 10 | Allowed HTTP methods at http://demo.testfire.net/default.aspx in server.'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[+] 10 | 在服务器的 http://demo.testfire.net/default.aspx 中允许的 HTTP 方法。'
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[~] Status: Scanning'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 状态：扫描中'
- en: '[~] Discovered 3 pages thus far.'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 迄今为止发现了 3 个页面。'
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[~] Sent 1251 requests.'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 已发送 1251 个请求。'
- en: '[~] Received and analyzed 1248 responses.'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 收到并分析了 1248 个响应。'
- en: '[~] In 00:00:45'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 在 00:00:45'
- en: '[~] Average: 39.3732270014467 requests/second.'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 平均值：39.3732270014467 请求/秒。'
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[~] Currently auditing http://demo.testfire.net/default.aspx'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 当前正在审计 http://demo.testfire.net/default.aspx'
- en: '[~] Burst response time sum 72.511066 seconds'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 突发响应时间总和 72.511066 秒'
- en: '[~] Burst response count total 97'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 突发响应总数 97'
- en: '[~] Burst average response time 0.747536762886598 seconds'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 突发平均响应时间 0.747536762886598 秒'
- en: '[~] Burst average 20.086991167522193 requests/second'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 突发平均 20.086991167522193 请求/秒'
- en: '[~] Timed-out requests 0'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 超时请求 0'
- en: '[~] Original max concurrency 20'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 原始最大并发数 20'
- en: '[~] Throttled max concurrency 20'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] 限制的最大并发数 20'
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[~] (''Ctrl+C'' aborts the scan and retrieves the report) Listing 12-9: The  arachni_rpc  command
    line scanning UI'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[~] (''Ctrl+C'' 中止扫描并获取报告) Listing 12-9:  arachni_rpc 命令行扫描 UI'
- en: The ArachniRPCSession Class
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ArachniRPCSession 类
- en: To run a scan using the RPC framework and C#, we’ll implement the session/manager
    pattern again, starting with the Arachni RPC session class. With the RPC framework,
    you get a little bit more intimate with the actual Arachni architecture because
    you need to deal with dispatchers and instances at a granular level. When you
    connect to the RPC framework for the first time, you are connected to a dispatcher.
    You can interact with this dispatcher to create and manage instances, which do
    the actual scanning and work, but these scanning instances end up dynamically
    listening on a different port than the dispatcher. In order to provide an easy-to-use
    interface for both dispatchers and instances, we can create a session constructor
    that allows us to gloss over these distinctions a little bit, as shown in [Listing
    12-10](#filepos841495).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 RPC 框架和 C# 运行扫描，我们将再次实现 session/manager 模式，从 Arachni RPC 会话类开始。通过 RPC 框架，您将与
    Arachni 架构有更多的接触，因为您需要在更细粒度的层面上处理调度器和实例。当您首次连接到 RPC 框架时，您会连接到一个调度器。您可以与这个调度器交互来创建和管理实例，这些实例进行实际的扫描和工作，但这些扫描实例最终会动态地监听与调度器不同的端口。为了为调度器和实例提供一个易于使用的接口，我们可以创建一个会话构造函数，让我们能够稍微忽略这些区别，如
    [Listing 12-10](#filepos841495) 所示。
- en: 'public class ArachniRPCSession : IDisposable'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public class ArachniRPCSession : IDisposable'
- en: '{'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: SslStream _stream = null;
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SslStream _stream = null;
- en: public ArachniRPCSession(➊string host, int port,
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ArachniRPCSession(➊string host, int port,
- en: bool ➋initiateInstance = false)
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bool ➋initiateInstance = false)
- en: '{'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Host = host;
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Host = host;
- en: this.Port = port;
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Port = port;
- en: ➌GetStream(host, port);
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌GetStream(host, port);
- en: this.IsInstanceStream = false;
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.IsInstanceStream = false;
- en: ''
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (initiateInstance)
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (initiateInstance)
- en: '{'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.InstanceName = ➍Guid.NewGuid().ToString();
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.InstanceName = ➍Guid.NewGuid().ToString();
- en: MessagePackObjectDictionary resp =
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MessagePackObjectDictionary resp =
- en: this.ExecuteCommand("dispatcher.dispatch"➎,
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ExecuteCommand("dispatcher.dispatch"➎,
- en: 'new object[] { this.InstanceName }).AsDictionary(); Listing 12-10: The first
    half of the  ArachniRPCSession  constructor'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: new object[] { this.InstanceName }).AsDictionary(); 列表 12-10：ArachniRPCSession
    构造函数的前半部分
- en: The constructor accepts three arguments ➊. The first two—the host to connect
    to and the port on the host—are required. The third one, which is optional ➋ (with
    a default value of false), allows the programmer to automatically create a new
    scanning instance and connect to it, instead of having to create the new instance
    manually via the dispatcher.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受三个参数 ➊。前两个——连接的主机和主机上的端口——是必需的。第三个参数是可选的 ➋（默认为 false），它允许程序员自动创建一个新的扫描实例并连接到它，而无需通过调度器手动创建新实例。
- en: After assigning the Host and Port properties the values of the first two arguments
    passed to the constructor, respectively, we connect to the dispatcher using GetStream()
    ➌. If a true value is passed in as the third argument, instantiateInstance (which
    is false by default), we create a unique name for the instance we want to dispatch
    using a new Guid ➍ and then run the dispatcher.dispatch ➎ RPC command to create
    a new scanner instance that returns a new port (and potentially new host if you
    have a cluster of scanner instances). [Listing 12-11](#filepos844220) shows the
    rest of the constructor.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在分别将 Host 和 Port 属性赋值为传递给构造函数的前两个参数后，我们使用 GetStream() ➌ 连接到调度器。如果第三个参数传入 true（默认为
    false），实例化实例时（默认值为 false），我们使用新的 Guid 创建一个唯一的实例名称，并运行 dispatcher.dispatch ➎ RPC
    命令来创建一个新的扫描器实例，该实例返回一个新的端口（如果你有多个扫描器实例集群，可能还会返回新的主机）。[列表 12-11](#filepos844220)
    显示了构造函数的其余部分。
- en: string[] url = ➊resp["url"].AsString().Split(':');
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string[] url = ➊resp["url"].AsString().Split(':');
- en: ''
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.InstanceHost = url[0];
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.InstanceHost = url[0];
- en: this.InstancePort = int.Parse(url[1]);
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.InstancePort = int.Parse(url[1]);
- en: this.Token = ➋resp["token"].AsString();
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Token = ➋resp["token"].AsString();
- en: ''
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌GetStream(this.InstanceHost, this.InstancePort);
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌GetStream(this.InstanceHost, this.InstancePort);
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: bool aliveResp = this.➍ExecuteCommand("service.alive?", new object[] { },
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bool aliveResp = this.➍ExecuteCommand("service.alive?", new object[] { },
- en: this.Token).AsBoolean();
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Token).AsBoolean();
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.IsInstanceStream = aliveResp;
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.IsInstanceStream = aliveResp;
- en: '}'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➎public string Host { get; set; }
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➎public string Host { get; set; }
- en: public int Port { get; set; }
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int Port { get; set; }
- en: public string Token { get; set; }
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Token { get; set; }
- en: public bool IsInstanceStream { get; set; }
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public bool IsInstanceStream { get; set; }
- en: public string InstanceHost { get; set; }
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string InstanceHost { get; set; }
- en: public int InstancePort { get; set; }
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int InstancePort { get; set; }
- en: public string InstanceName { get; set; }
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string InstanceName { get; set; }
- en: 'Listing 12-11: The second half of the  ArachniRPCSession  constructor and its
    properties'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-11：ArachniRPCSession 构造函数的后半部分及其属性
- en: At ➊, we split the scanner instance URL (for example, 127.0.0.1:7331) into the
    IP address and the port (127.0.01 and 7331, respectively). Once we have the instance
    host and port we will use to drive the actual scan, we assign the values to our
    InstanceHost and InstancePort properties, respectively. We also save the authentication
    token ➋ returned by the dispatcher so we can make authenticated RPC calls later
    on the scanner instance. This authentication token is automatically generated
    by the Arachni RPC when we dispatch a new instance so that only we can use the
    new scanner with the token.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将扫描器实例的 URL（例如 127.0.0.1:7331）拆分为 IP 地址和端口（分别为 127.0.0.1 和 7331）。一旦我们获取到用于实际扫描的实例主机和端口后，我们将它们分别赋值给
    InstanceHost 和 InstancePort 属性。我们还会保存调度器返回的认证令牌 ➋，以便稍后对扫描器实例进行认证的 RPC 调用。该认证令牌是
    Arachni RPC 在我们调度新实例时自动生成的，这样只有我们能使用这个新扫描器及其令牌。
- en: We connect to the scanner instance using GetStream() ➌, which provides direct
    access to the scanning instance. If the connection is successful and the scanning
    instance is alive ➍, we assign the IsInstanceStream property to true so that we
    know whether we are driving a dispatcher or a scanning instance (which determines
    the RPC calls we can make to Arachni, such as creating a scanner or performing
    a scan) later when we implement the ArachniRPCManager class. After the constructor,
    we define the properties ➎ for the session class, all of which are used in the
    constructor.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用GetStream() ➌连接到扫描实例，它提供了对扫描实例的直接访问。如果连接成功且扫描实例处于活动状态 ➍，我们将IsInstanceStream属性设置为true，这样我们就能知道自己是在驱动调度器还是扫描实例（这决定了我们稍后在实现ArachniRPCManager类时可以对Arachni进行哪些RPC调用，比如创建扫描器或执行扫描）。在构造函数之后，我们定义了会话类的属性
    ➎，所有这些属性在构造函数中都会用到。
- en: The Supporting Methods for ExecuteCommand()
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ExecuteCommand的辅助方法
- en: Before we implement ExecuteCommand(), we need to implement the supporting methods
    for ExecuteCommand(). We’re almost there! [Listing 12-12](#filepos849252) shows
    the methods we need in order to finish up the ArachniRPCSession class.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现ExecuteCommand()之前，我们需要实现ExecuteCommand()的辅助方法。我们快完成了！[第12-12页](#filepos849252)显示了我们需要的方法，以便完成ArachniRPCSession类的实现。
- en: public byte[] DecompressData(byte[] inData)
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public byte[] 解压数据(byte[] inData)
- en: '{'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (MemoryStream outMemoryStream = new MemoryStream())
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (MemoryStream outMemoryStream = new MemoryStream())
- en: '{'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (➊ZOutputStream outZStream = new ZOutputStream(outMemoryStream))
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (➊ZOutputStream outZStream = new ZOutputStream(outMemoryStream))
- en: '{'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: outZStream.Write(inData, 0, inData.Length);
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: outZStream.Write(inData, 0, inData.Length);
- en: return outMemoryStream.ToArray();
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return outMemoryStream.ToArray();
- en: '}'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private byte[] ➋ReadMessage(SslStream sslStream)
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private byte[] ➋ReadMessage(SslStream sslStream)
- en: '{'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: byte[] sizeBytes = new byte[4];
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] sizeBytes = new byte[4];
- en: sslStream.Read(sizeBytes, 0, sizeBytes.Length);
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sslStream.Read(sizeBytes, 0, sizeBytes.Length);
- en: ''
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (BitConverter.IsLittleEndian)
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (BitConverter.IsLittleEndian)
- en: Array.Reverse(sizeBytes);
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Array.Reverse(sizeBytes);
- en: ''
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: uint size = BitConverter.➌ToUInt32(sizeBytes, 0);
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: uint size = BitConverter.➌ToUInt32(sizeBytes, 0);
- en: byte[] buffer = new byte[size];
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] buffer = new byte[size];
- en: sslStream.Read(buffer, 0, buffer.Length);
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sslStream.Read(buffer, 0, buffer.Length);
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return buffer;
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return buffer;
- en: '}'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void ➍GetStream(string host, int port)
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ➍获取流(string host, int port)
- en: '{'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: TcpClient client = new TcpClient(host, port);
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TcpClient client = new TcpClient(host, port);
- en: ''
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _stream = new SslStream(client.GetStream(), false,
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _stream = new SslStream(client.GetStream(), false,
- en: new RemoteCertificateValidationCallback(➎ValidateServerCertificate),
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: new RemoteCertificateValidationCallback(➎验证服务器证书),
- en: (sender, targetHost, localCertificates,
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (sender, targetHost, localCertificates,
- en: remoteCertificate, acceptableIssuers)
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: remoteCertificate, acceptableIssuers)
- en: => null);
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: => null);
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _stream.AuthenticateAsClient("arachni", null, SslProtocols.Tls, false);
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _stream.AuthenticateAsClient("arachni", null, SslProtocols.Tls, false);
- en: '}'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private bool ValidateServerCertificate(object sender, X509Certificate certificate,
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private bool 验证服务器证书(object sender, X509Certificate certificate,
- en: X509Chain chain, SslPolicyErrors sslPolicyErrors)
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: X509Chain chain, SslPolicyErrors sslPolicyErrors)
- en: '{'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return true;
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return true;
- en: '}'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public void ➏Dispose()
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public void ➏Dispose()
- en: '{'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (this.IsInstanceStream && _stream != null)
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (this.IsInstanceStream && _stream != null)
- en: this.ExecuteCommand(➐"service.shutdown", new object[] { }, this.Token);
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.ExecuteCommand(➐"service.shutdown", new object[] { }, this.Token);
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (_stream != null)
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (_stream != null)
- en: _stream.Dispose();
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _stream.Dispose();
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _stream = null;
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _stream = null;
- en: '}'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 12-12: The supporting methods for the  ArachniRPCSession  class'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 第12-12页：ArachniRPCSession类的辅助方法
- en: Most of the support methods for the RPC session class are relatively simple.
    The DecompressData() method creates a new output stream from the zlib library
    available in NuGet, called ZOutputStream ➊. This returns the decompressed data
    as a byte array. In the ReadMessage() method ➋, we read the first 4 bytes from
    the stream and then convert the bytes into a 32-bit unsigned integer ➌ that represents
    the length of the rest of the data. Once we have the length, we read the rest
    of the data from the stream and return the data as a byte array.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数RPC会话类的辅助方法相对简单。DecompressData()方法使用NuGet中提供的zlib库创建一个新的输出流，名为ZOutputStream
    ➊。它返回解压后的数据作为字节数组。在ReadMessage()方法 ➋中，我们从流中读取前4个字节，然后将这些字节转换为一个32位无符号整数 ➌，表示其余数据的长度。一旦知道数据长度，我们就从流中读取剩余数据，并将其作为字节数组返回。
- en: The GetStream() method ➍ is also very similar to the code we used to create
    a network stream in the OpenVAS library. We create a new TcpClient and wrap the
    stream in an SslStream. We use the ValidateServerCertificate() method ➎ to trust
    all SSL certificates by returning true all the time. This allows us to connect
    to the RPC instances with self-signed certificates. Finally, Dispose() ➏ is required
    by the IDisposable interface that the ArachniRPCSession class implements. If we’re
    driving a scanning instance instead of a dispatcher (set in the constructor when
    the ArachniRPCSession was created), we send the instance a shutdown command ➐
    to clean up the scanning instance but leave the dispatcher running.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetStream()`方法➍与我们在OpenVAS库中用于创建网络流的代码非常相似。我们创建一个新的`TcpClient`并将流包装在`SslStream`中。我们使用`ValidateServerCertificate()`方法➎通过始终返回`true`来信任所有SSL证书。这允许我们连接到具有自签名证书的RPC实例。最后，`Dispose()`
    ➏是`ArachniRPCSession`类实现的`IDisposable`接口所要求的。如果我们正在驱动一个扫描实例而不是调度器（在创建`ArachniRPCSession`时的构造函数中设置），我们发送一个关闭命令➐给该实例，以清理扫描实例，但保持调度器运行。'
- en: The ExecuteCommand() Method
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteCommand()`方法'
- en: The ExecuteCommand() method shown in [Listing 12-13](#filepos852474) wraps all
    the functionality required to send commands and receive responses from the Arachni
    RPC.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单12-13](#filepos852474)所示，`ExecuteCommand()`方法封装了所有必需的功能，用于发送命令并接收来自Arachni
    RPC的响应。
- en: public MessagePackObject ➊ExecuteCommand(string command, object[] args,
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public MessagePackObject ➊ExecuteCommand(string command, object[] args,`'
- en: string token = null)
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`string token = null)`'
- en: '{'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➋Dictionary<string, object> = new Dictionary<string, object>();
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋`Dictionary<string, object> = new Dictionary<string, object>();`
- en: ➌message["message"] = command;
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌`message["message"] = command;`
- en: message["args"] = args;
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`message["args"] = args;`'
- en: ''
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (token != null)
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`if (token != null)`'
- en: ➍message["token"] = token;
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➍`message["token"] = token;`
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] packed;
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`byte[] packed;`'
- en: using (MemoryStream stream = new ➎MemoryStream())
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`using (MemoryStream stream = new ➎MemoryStream())`'
- en: '{'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Packer packer = Packer.Create(stream);
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Packer packer = Packer.Create(stream);`'
- en: packer.PackMap(message);
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`packer.PackMap(message);`'
- en: packed = stream.ToArray();
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`packed = stream.ToArray();`'
- en: '}'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 12-13: The first half of the  ExecuteCommand()  method in the  ArachniRPCSession  class'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-13：`ArachniRPCSession`类中`ExecuteCommand()`方法的前半部分
- en: 'The ExecuteCommand() method ➊ accepts three arguments: the command to execute,
    an object of the arguments to use with the command, and an optional argument for
    a token if an authentication token was provided. The method will mostly be used
    by the ArachniRPCManager class later. We start the method by creating a new dictionary
    called request to hold our command data (the command to run and the arguments
    for the RPC command) ➋. We then assign the message key ➌ in the dictionary the
    first argument passed to the ExecuteCommand() method, which is the command to
    run. We also assign the args key in the dictionary with the second argument passed
    to the method, which are the options for the command to be run. Arachni will look
    at these keys when we send our message, run the RPC command with the given arguments,
    and then return a response. If the third argument, which is optional, is not null,
    we assign the token key ➍ the authentication token passed to the method. These
    three dictionary keys (message, args, and token) are all that Arachni will look
    at when you send the serialized data to it.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteCommand()`方法➊接受三个参数：要执行的命令、与命令一起使用的参数对象，以及一个可选的身份验证令牌参数（如果提供了身份验证令牌）。该方法稍后将主要由`ArachniRPCManager`类使用。我们通过创建一个新的字典来开始该方法，名为`request`，用于保存我们的命令数据（要运行的命令和RPC命令的参数）➋。然后，我们将字典中的`message`键➌赋值为传递给`ExecuteCommand()`方法的第一个参数，即要运行的命令。接着，我们将字典中的`args`键赋值为传递给方法的第二个参数，即要运行命令的选项。当我们发送消息时，Arachni将查看这些键，使用给定的参数运行RPC命令，并返回响应。如果第三个参数（可选）不为`null`，我们将`token`键
    ➍ 赋值为传递给方法的身份验证令牌。这三个字典键（`message`、`args`和`token`）是Arachni在接收到序列化数据时将查看的内容。'
- en: Once we have set up the request dictionary with the information we want to send
    to Arachni, we create a new MemoryStream() ➎ and use the same Packer class from
    the Metasploit bindings in [Chapter 11](index_split_016.html#filepos761301) to
    serialize the request dictionary into a byte array. Now that we have prepared
    the data to send to Arachni to run an RPC command, we need to send the data and
    read the response from Arachni. That takes place in the second half of the ExecuteCommand()
    method, shown in [Listing 12-14](#filepos856102).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置好包含要发送给 Arachni 的信息的请求字典，我们就创建一个新的 MemoryStream() ➎ 并使用 Metasploit 绑定中的相同
    Packer 类，在[第 11 章](index_split_016.html#filepos761301)中将请求字典序列化为字节数组。现在，我们已经准备好发送数据给
    Arachni 执行 RPC 命令，接下来我们需要发送数据并读取 Arachni 的响应。这发生在 ExecuteCommand() 方法的后半部分，见[清单
    12-14](#filepos856102)。
- en: byte[] packedLength = ➊BitConverter.GetBytes(packed.Length);
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] packedLength = ➊BitConverter.GetBytes(packed.Length);
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (BitConverter.IsLittleEndian)
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (BitConverter.IsLittleEndian)
- en: Array.Reverse(packedLength);
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Array.Reverse(packedLength);
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➋_stream.Write(packedLength);
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋_stream.Write(packedLength);
- en: ➌_stream.Write(packed);
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌_stream.Write(packed);
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] respBytes = ➍ReadMessage(_stream);
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] respBytes = ➍ReadMessage(_stream);
- en: ''
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: MessagePackObjectDictionary resp = null;
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MessagePackObjectDictionary resp = null;
- en: try
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: resp = Unpacking.UnpackObject(respBytes).Value.AsDictionary();
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = Unpacking.UnpackObject(respBytes).Value.AsDictionary();
- en: '}'
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ➎catch
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➎catch
- en: '{'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: byte[] decompressed = DecompressData(respBytes);
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] decompressed = DecompressData(respBytes);
- en: resp = Unpacking.UnpackObject(decompressed).Value.AsDictionary();
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = Unpacking.UnpackObject(decompressed).Value.AsDictionary();
- en: '}'
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'return resp.ContainsKey("obj") ? resp["obj"] : resp["exception"];'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'return resp.ContainsKey("obj") ? resp["obj"] : resp["exception"];'
- en: '}'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 12-14: The second half of the  ExecuteCommand()  method in the  ArachniRPCSession  class'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-14：ArachniRPCSession 类中 ExecuteCommand() 方法的后半部分
- en: Since the Arachni RPC stream uses a simple protocol to communicate, we can easily
    send our MSGPACK data to Arachni, but we need to send Arachni two pieces of information,
    not just the MSGPACK data. We first need to send Arachni the size of the MSGPACK
    data as a 4-byte integer in front of the MSGPACK data. This integer is the length
    of the serialized data in each message and tells the receiving host (in this case,
    Arachni) how much of the stream needs to be read in as part of the message segment.
    We need to get the bytes for the length of the data, so we use BitConverter.GetBytes()
    ➊ to get the 4-byte array. The length of the data and the data itself need to
    be written to the Arachni stream in a certain order. We first write the 4 bytes
    representing the data’s length to the stream ➋ and then write the full serialized
    message to the stream ➌.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Arachni RPC 流使用简单协议进行通信，我们可以轻松地将 MSGPACK 数据发送给 Arachni，但我们需要向 Arachni 发送两个信息，而不仅仅是
    MSGPACK 数据。我们首先需要将 MSGPACK 数据的大小作为一个 4 字节的整数发送给 Arachni，紧跟在 MSGPACK 数据之前。这个整数表示每个消息中序列化数据的长度，告诉接收方（在本例中为
    Arachni）需要读取多少字节作为消息的一部分。我们需要获取数据长度的字节，因此使用 BitConverter.GetBytes() ➊ 获取 4 字节数组。数据的长度和数据本身需要按照特定顺序写入
    Arachni 流中。我们首先将表示数据长度的 4 字节写入流中 ➋，然后写入完整的序列化消息 ➌。
- en: Next, we need to read the response from Arachni and return the response to the
    caller. Using the ReadMessage() method ➍, we take the raw bytes of the message
    from the response and attempt to unpack them into a MessagePackObjectDictionary
    in a try/catch block. If the first attempt is unsuccessful, that means the data
    is compressed using Gzip, so the catch block ➎ takes over. We decompress the data
    and then unpack the decompressed bytes into a MessagePackObjectDictionary. Finally,
    we return either the full response from the server or an exception if an error
    has occurred.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要读取来自 Arachni 的响应并将其返回给调用者。使用 ReadMessage() 方法 ➍，我们从响应中获取消息的原始字节，并尝试在
    try/catch 块中将其解包成 MessagePackObjectDictionary。如果第一次尝试失败，这意味着数据使用 Gzip 压缩，因此 catch
    块 ➎ 会接管。我们解压缩数据，然后将解压后的字节解包成 MessagePackObjectDictionary。最后，我们返回服务器的完整响应，或者如果发生错误，则返回异常。
- en: The ArachniRPCManager Class
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ArachniRPCManager 类
- en: The ArachniRPCManager class is considerably simpler than the ArachniRPCSession
    class, as shown in [Listing 12-15](#filepos861121).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ArachniRPCManager 类比 ArachniRPCSession 类要简单得多，见[清单 12-15](#filepos861121)。
- en: 'public class ArachniRPCManager : IDisposable'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'public class ArachniRPCManager : IDisposable'
- en: '{'
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ArachniRPCSession _session;
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ArachniRPCSession _session;
- en: public ArachniRPCManager(➊ArachniRPCSession session)
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public ArachniRPCManager(➊ArachniRPCSession session)
- en: '{'
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (!session.IsInstanceStream)
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (!session.IsInstanceStream)
- en: throw new Exception("Session must be using an instance stream");
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new Exception("Session 必须使用实例流");
- en: ''
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _session = session;
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: _session = session;
- en: '}'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public MessagePackObject ➋StartScan(string url, string checks = "*")
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public MessagePackObject ➋StartScan(string url, string checks = "*")
- en: '{'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Dictionary<string, object>args = new Dictionary<string, object>();
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dictionary<string, object>args = new Dictionary<string, object>();
- en: args["url"] = url;
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: args["url"] = url;
- en: args["checks"] = checks;
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: args["checks"] = checks;
- en: args["audit"] = new Dictionary<string, object>();
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: args["audit"] = new Dictionary<string, object>();
- en: ((Dictionary<string, object>)args["audit"])["elements"] = new object[] { "links",
    "forms" };
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ((Dictionary<string, object>)args["audit"])["elements"] = new object[] { "links",
    "forms" };
- en: ''
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return _session.ExecuteCommand(➌"service.scan", new object[] { args }, _session.Token);
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.ExecuteCommand(➌"service.scan", new object[] { args }, _session.Token);
- en: '}'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public MessagePackObject ➍GetProgress(List<uint> digests = null)
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public MessagePackObject ➍GetProgress(List<uint> digests = null)
- en: '{'
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Dictionary<string, object>args = new Dictionary<string, object>();
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dictionary<string, object>args = new Dictionary<string, object>();
- en: args["with"] = "issues";
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: args["with"] = "issues";
- en: if (digests != null)
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 digests 不为空
- en: '{'
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: args["without"] = new Dictionary<string, object>();
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: args["without"] = new Dictionary<string, object>();
- en: ((Dictionary<string, object>)args["without"])["issues"] = digests.ToArray();
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ((Dictionary<string, object>)args["without"])["issues"] = digests.ToArray();
- en: '}'
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: return _session.➎ExecuteCommand("service.progress", new object[] { args }, _session.Token);
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.➎ExecuteCommand("service.progress", new object[] { args }, _session.Token);
- en: '}'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public MessagePackObject ➏IsBusy()
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public MessagePackObject ➏IsBusy()
- en: '{'
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: return _session.ExecuteCommand("service.busy?", new object[] { }, _session.Token);
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: return _session.ExecuteCommand("service.busy?", new object[] { }, _session.Token);
- en: '}'
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public void Dispose()
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public void Dispose()
- en: '{'
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➐_session.Dispose();
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➐_session.Dispose();
- en: '}'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 12-15: The  ArachniRPCManager  class'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-15：ArachniRPCManager 类
- en: First, the ArachniRPCManager constructor accepts an ArachniRPCSession ➊ as its
    only argument. Our manager class will only implement methods for a scanning instance,
    not a dispatcher, so if the session passed in is not a scanning instance, we throw
    an exception. Otherwise, we assign the session to a local class variable for use
    in the rest of the methods.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，ArachniRPCManager 构造函数接受一个 ArachniRPCSession ➊ 作为唯一参数。我们的管理器类只会实现扫描实例的方法，而不是调度器，因此，如果传入的会话不是扫描实例，我们会抛出异常。否则，我们将会话分配给本地类变量，以便在其他方法中使用。
- en: The first method we create in the ArachniRPCManager class is the StartScan()
    method ➋, which accepts two arguments. The first argument, which is required,
    is a string of the URL Arachni will scan. The second argument, which is optional,
    defaults to running all checks (such as XSS, SQL injection, and path traversal,
    for example), but it can be changed if the user wants to specify different checks
    in the options passed to StartScan(). To determine which checks are run, we build
    a new message to send to Arachni by instantiating a new dictionary using the url
    and checks arguments passed to the StartScan() method and audit, which Arachni
    will look at to determine what kind of scan to perform when we send the message.
    Finally, we send the message using the service.scan command ➌ and return the response
    to the caller.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 ArachniRPCManager 类中创建的第一个方法是 StartScan() 方法 ➋，它接受两个参数。第一个参数是必需的，是 Arachni
    将要扫描的 URL 字符串。第二个参数是可选的，默认会运行所有检查（例如 XSS、SQL 注入和路径遍历等），但如果用户希望在传递给 StartScan()
    的选项中指定不同的检查，它可以被更改。为了确定运行哪些检查，我们通过实例化一个新的字典并使用传递给 StartScan() 方法的 url 和 checks
    参数以及 Arachni 将查看的 audit 来构建一个新的消息，Arachni 根据这个消息来确定执行何种扫描。最后，我们使用 service.scan
    命令 ➌ 发送该消息并将响应返回给调用者。
- en: 'The GetProgress() method ➍ accepts a single optional argument: a list of integers
    that Arachni uses to identify reported issues. We’ll talk more about how Arachni
    reports issues in the next section. Using this argument, we build a small dictionary
    and pass it to the service.progress command ➎, which will return the current progress
    and status of the scan. We send the command to Arachni and then return the result
    to the caller.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: GetProgress() 方法 ➍ 接受一个可选的单一参数：一个整数列表，Arachni 用它来标识报告的问题。我们将在下一节中详细讨论 Arachni
    如何报告问题。使用此参数，我们构建一个小字典并将其传递给 service.progress 命令 ➎，该命令将返回扫描的当前进度和状态。我们将命令发送给 Arachni，然后将结果返回给调用者。
- en: The last important method, IsBusy() ➏, simply tells us whether the current scanner
    is performing a scan. Finally, we clean it all up with Dispose() ➐.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个重要的方法，IsBusy() ➏，简单地告诉我们当前的扫描器是否正在进行扫描。最后，我们通过 Dispose() ➐ 清理所有内容。
- en: Putting It All Together
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 综合起来
- en: Now we have the building blocks to drive Arachni’s RPC to scan a URL and report
    the results in real time. [Listing 12-16](#filepos866078) shows how we glue all
    the parts together to scan a URL with the RPC.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了驱动Arachni的RPC来扫描URL并实时报告结果的基本构件。[清单12-16](#filepos866078)展示了如何将所有部分组合在一起，使用RPC扫描一个URL。
- en: public static void Main(string[] args)
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (ArachniRPCSession session = new ➊ArachniRPCSession("127.0.0.1",
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (ArachniRPCSession session = new ➊ArachniRPCSession("127.0.0.1",
- en: 7331, true))
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7331, true))
- en: '{'
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (ArachniRPCManager manager = new ArachniRPCManager(session))
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (ArachniRPCManager manager = new ArachniRPCManager(session))
- en: '{'
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.➋WriteLine("Using instance: " + session.InstanceName);'
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.➋WriteLine("正在使用实例: " + session.InstanceName);'
- en: manager.StartScan("http://demo.testfire.net/default.aspx");
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: manager.StartScan("http://demo.testfire.net/default.aspx");
- en: bool isRunning = manager.IsBusy().AsBoolean();
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: bool isRunning = manager.IsBusy().AsBoolean();
- en: List<uint> issues = new List<uint>();
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: List<uint> issues = new List<uint>();
- en: DateTime start = DateTime.Now;
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DateTime start = DateTime.Now;
- en: Console.WriteLine("Starting scan at " + start.ToLongTimeString());
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("扫描开始时间: " + start.ToLongTimeString());'
- en: ➌while (isRunning)
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌while (isRunning)
- en: '{'
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: Thread.Sleep(10000);
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Thread.Sleep(10000);
- en: var progress = manager.GetProgress(issues);
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: var progress = manager.GetProgress(issues);
- en: foreach (MessagePackObject p in
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (MessagePackObject p in
- en: progress.AsDictionary()["issues"].AsEnumerable())
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: progress.AsDictionary()["issues"].AsEnumerable())
- en: '{'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: MessagePackObjectDictionary dict = p.AsDictionary();
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MessagePackObjectDictionary dict = p.AsDictionary();
- en: 'Console.➍WriteLine("Issue found: " + dict["name"].AsString());'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.➍WriteLine("发现问题: " + dict["name"].AsString());'
- en: issues.Add(dict["digest"].AsUInt32());
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: issues.Add(dict["digest"].AsUInt32());
- en: '}'
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: isRunning = manager.➎IsBusy().AsBoolean();
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: isRunning = manager.➎IsBusy().AsBoolean();
- en: '}'
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: DateTime end = DateTime.Now;
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DateTime end = DateTime.Now;
- en: ➏Console.WriteLine("Finishing scan at " + end.ToLongTimeString() +
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '➏Console.WriteLine("扫描结束时间: " + end.ToLongTimeString() +'
- en: '". Scan took " + ((end - start).ToString()) + ".");'
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '". 扫描花费时间: " + ((end - start).ToString()) + ")。'
- en: '}'
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 12-16: Driving Arachni with the RPC classes'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '清单12-16: 使用RPC类驱动Arachni'
- en: We start the Main() method by creating a new ArachniRPCSession ➊, passing the
    host and port for the Arachni dispatcher, as well as true as the third argument
    to automatically get a new scanning instance. Once we have the session and manager
    classes and are connected to Arachni, we print our current instance name ➋, which
    should just be the unique ID we generated when we created the scanning instance
    to connect to it. We then start the scan by passing the test URL to the StartScan()
    method.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个新的ArachniRPCSession ➊来启动Main()方法，传递Arachni调度器的主机和端口，并将true作为第三个参数自动获取一个新的扫描实例。一旦我们拥有了会话和管理器类，并且连接到Arachni，我们打印当前的实例名称
    ➋，它应该就是我们在创建扫描实例时生成的唯一ID。接着，我们通过将测试URL传递给StartScan()方法来启动扫描。
- en: Once the scan is started, we can watch it until it’s finished and then print
    the final report. After creating a few variables such as an empty list, which
    we’ll use to store the issues that Arachni reports back, and the time when the
    scan started, we begin a while loop ➌, which will loop until isRunning is false.
    Within the while loop, we call GetProgress() to get the current progress of our
    scan; then we print ➍ and store any new issues found since we last called GetProgress().
    We finally sleep for 10 seconds and then call IsBusy() ➎ again. We then start
    the process all over again until the scan is finished. When all is said and done,
    we print a small summary ➏ of how long the scan took. If you look at the vulnerabilities
    reported by your automation (my truncated results are shown in [Listing 12-17](#filepos868851))
    and the original Arachni scans we performed by hand at the beginning of the chapter,
    they should match up!
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦扫描开始，我们可以观察它直到完成，然后打印最终报告。在创建几个变量（如一个空的列表，用来存储Arachni回传的报告问题）和扫描开始的时间后，我们开始一个while循环
    ➌，它会持续运行直到isRunning为false。在while循环中，我们调用GetProgress()来获取扫描的当前进度，然后打印 ➍并存储自上次调用GetProgress()以来发现的任何新问题。我们最终暂停10秒，然后再次调用IsBusy()
    ➎。接着我们重新开始这个过程，直到扫描完成。所有步骤完成后，我们打印一个简短的总结 ➏，说明扫描花费的时间。如果你查看自动化报告的漏洞（我截断的结果见[清单12-17](#filepos868851)）以及我们在章节开始时手动执行的原始Arachni扫描，它们应该是一致的！
- en: $ mono ./ch12_automating_arachni.exe
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ mono ./ch12_automating_arachni.exe
- en: 'Using instance: 1892413b-7656-4491-b6c0-05872396b42f'
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '使用实例: 1892413b-7656-4491-b6c0-05872396b42f'
- en: Starting scan at 8:58:12 AM
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '扫描开始时间: 8:58:12 AM'
- en: 'Issue found: Cross-Site Scripting (XSS)➊'
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '发现问题: 跨站脚本（XSS）➊'
- en: 'Issue found: Common directory'
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '发现问题: 常见目录'
- en: 'Issue found: Backup file➋'
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '发现问题: 备份文件➋'
- en: 'Issue found: Missing ''X-Frame-Options'' header'
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '发现问题: 缺少 ''X-Frame-Options'' 头部'
- en: 'Issue found: Interesting response'
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 发现的问题：有趣的响应
- en: 'Issue found: Allowed HTTP methods'
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 发现的问题：允许的 HTTP 方法
- en: 'Issue found: Interesting response'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 发现的问题：有趣的响应
- en: 'Issue found: Path Traversal➌'
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 发现的问题：路径遍历 ➌
- en: --snip--
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: --snip--
- en: 'Listing 12-17: Running the Arachni C# classes to scan and report on a sample
    URL'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-17：运行 Arachni C# 类扫描并报告示例 URL
- en: 'Because we are running Arachni with all the checks enabled, this site will
    report a lot of vulnerabilities! In just the first 10 or so lines, Arachni reported
    an XSS vulnerability ➊, a backup file with potentially sensitive information ➋,
    and a path traversal weakness ➌. If you wanted to limit the checks Arachni performs
    to just an XSS vulnerability scan, you could pass a second argument to StartScan
    with the string xss* (the default value for the argument is *, which means “all
    checks”), and Arachni would only check for and report any XSS vulnerabilities
    found. The command would end up looking like the following line of code: manager.StartScan("http://demo.testfire.net/default.aspx",
    "xss*"); Arachni supports a wide variety of checks, including SQL and command
    injection, so I encourage you to read the documentation on the supported checks.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们启用了所有检查项来运行 Arachni，这个站点将报告大量的漏洞！仅在前十行左右，Arachni 就报告了一个 XSS 漏洞 ➊，一个可能包含敏感信息的备份文件
    ➋，以及一个路径遍历弱点 ➌。如果你只想限制 Arachni 执行 XSS 漏洞扫描，你可以将一个第二个参数传递给 StartScan，值为 xss*（该参数的默认值是
    *，表示“所有检查”），Arachni 就只会检查并报告找到的任何 XSS 漏洞。该命令最终看起来像以下这行代码：manager.StartScan("http://demo.testfire.net/default.aspx",
    "xss*"); Arachni 支持多种检查，包括 SQL 和命令注入，因此我鼓励你阅读文档，了解支持的检查项。
- en: Conclusion
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 结论
- en: Arachni is an incredibly powerful and versatile web application scanner that
    should be a tool in any serious security engineer or pentester’s arsenal. As you
    have seen in this chapter, you can easily drive it in both simple and complex
    scenarios. If you only need to scan a single application regularly, the HTTP API
    might be enough for you. However, if you find yourself constantly scanning new
    and different applications, the ability to spin up scanners at will may be the
    best way for you to distribute your scans and prevent bottlenecking.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: Arachni 是一款非常强大且多功能的 web 应用程序扫描器，是任何认真从事安全工程或渗透测试工作的工程师工具箱中的必备工具。正如你在本章中所看到的，你可以轻松地在简单和复杂的场景中使用它。如果你只需要定期扫描单一应用程序，HTTP
    API 可能就足够了。然而，如果你发现自己不断扫描新的和不同的应用程序，那么随时启动扫描器的能力可能是分发扫描并避免瓶颈的最佳方式。
- en: We first implemented a set of simple classes that interfaced with the Arachni
    REST API in order to kick off, watch, and report on a scan. Using the base HTTP
    libraries in our toolset, we were able to easily build modular classes to drive
    Arachni.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现了一组简单的类，与 Arachni REST API 接口，以便启动、监控并报告扫描结果。利用我们工具集中基础的 HTTP 库，我们能够轻松构建模块化的类来驱动
    Arachni。
- en: Once we finished the simpler REST API, we took Arachni a step further to drive
    it via the MSGPACK RPC. Using a couple of open source third-party libraries, we
    were able to drive Arachni with some of its more powerful features. We used its
    distributed model to create a new scanning instance with the RPC dispatcher, and
    then we scanned a URL and reported the results in real time.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成了更简单的 REST API 后，我们将 Arachni 推进了一步，通过 MSGPACK RPC 来驱动它。使用几个开源第三方库，我们能够使用
    Arachni 的一些更强大的功能。我们利用其分布式模型，通过 RPC 调度器创建了一个新的扫描实例，然后扫描了一个 URL 并实时报告了结果。
- en: Using either of these building blocks, you can incorporate Arachni into any
    SDLC or continuous integration system to ensure the quality and security of the
    web applications being used or built by you or your organization.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些构建块中的任何一个，你都可以将 Arachni 集成到任何 SDLC 或持续集成系统中，以确保你或你的组织使用或构建的 web 应用程序的质量和安全性。
