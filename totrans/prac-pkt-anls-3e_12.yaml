- en: '**12**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12**'
- en: '**PACKET ANALYSIS FOR SECURITY**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全的报文分析**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Although most of this book focuses on using packet analysis for network troubleshooting,
    a considerable amount of real-world packet analysis is done for security purposes.
    For example, an intrusion analyst might review network traffic from potential
    intruders, or a forensic investigator might attempt to ascertain the extent of
    a malware infection on a compromised host.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书的大部分内容侧重于使用报文分析进行网络故障排除，但相当一部分实际的报文分析是出于安全目的进行的。例如，入侵分析师可能会审查来自潜在入侵者的网络流量，或者取证调查员可能会尝试确定在被攻陷主机上恶意软件感染的程度。
- en: Performing packet analysis while investigating security incidents is always
    a challenging scenario because it involves the unknown element of an attacker-controlled
    device. You can’t walk over to the attacker’s cubicle to ask a question or baseline
    their normal traffic; all you have to work with is the interaction you can capture
    between their system and yours. Fortunately, for an attacker to breach one of
    your systems remotely, they have to interact with the network in some form. Of
    course, they know that too, so they aren’t lacking in tricks to obfuscate their
    techniques.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查安全事件时进行报文分析总是一个具有挑战性的场景，因为它涉及到一个攻击者控制的未知设备。你无法走到攻击者的工作区提问或基准测试他们的正常流量；你只能依赖于你可以捕获到的他们的系统和你系统之间的交互。幸运的是，为了远程入侵你的系统，攻击者必须以某种形式与网络互动。当然，他们也知道这一点，所以他们不缺少用来混淆技术的手段。
- en: In this chapter, we’ll take the viewpoint of a security practitioner as we examine
    different aspects of a system compromise at the network level. We’ll cover network
    reconnaissance, malicious traffic redirection, and common malware techniques.
    In some cases, we’ll take on the role of intrusion analyst as we dissect traffic
    based on alerts from an intrusion-detection system (IDS). Reading this chapter
    will provide you with insight into network security that may prove critical, even
    if you are not presently in a security-focused role.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从安全实践者的角度出发，检查系统在网络层面的不同方面被攻陷的情况。我们将讨论网络侦察、恶意流量重定向和常见的恶意软件技术。在某些情况下，我们将扮演入侵分析师的角色，根据入侵检测系统（IDS）发出的警报分析流量。阅读本章将为你提供关于网络安全的深刻见解，即使你目前不在一个专注于安全的角色中，这些知识也可能至关重要。
- en: '**Reconnaissance**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**侦察**'
- en: An attacker’s first step is often to perform in-depth research on the target
    system. This step, commonly referred to as *footprinting*, is frequently accomplished
    using various publicly available resources, such as the target company’s website
    or Google. Once this research is completed, the attacker will typically begin
    scanning the IP address (or DNS name) of their target for open ports or running
    services.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者的第一步通常是对目标系统进行深入的研究。这个步骤通常被称为*信息收集*，通常通过各种公开可用的资源来完成，例如目标公司的官方网站或谷歌。一旦完成这项研究，攻击者通常会开始扫描他们目标的IP地址（或DNS名称），以寻找开放的端口或正在运行的服务。
- en: Scanning allows the attacker to determine whether the target is alive and reachable.
    For example, consider a scenario in which bank robbers are planning to steal from
    the largest bank in the city, located at 123 Main Street. They spend weeks planning
    an elaborate heist, only to find out upon arrival at the address that the bank
    has moved to 555 Vine Street. Worse yet, imagine that the robbers plan to walk
    into the bank during normal business hours, intending to steal from the vault,
    only to get to the bank and discover it’s closed that day. Whether robbing a bank
    or attacking a network, ensuring that the target is alive and accessible is the
    first hurdle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描可以让攻击者判断目标是否存活且可达。例如，考虑一个场景，其中银行劫匪计划从城市最大的银行——位于123 Main Street的银行——进行盗窃。他们花了几周时间策划精密的抢劫计划，结果一到地址就发现银行已经搬到了555
    Vine Street。更糟糕的是，假设这些劫匪计划在正常营业时间进入银行，打算从金库里偷东西，结果一到银行才发现当天银行关门了。无论是抢劫银行还是攻击网络，确保目标存活且可达是第一道难关。
- en: Scanning also tells the attacker on which ports the target is listening. Returning
    to our bank robbers analogy, consider what would happen if the robbers showed
    up at the bank with absolutely no knowledge of the building’s physical layout.
    They would have no idea how to gain access to the vault because they wouldn’t
    know the weak points in the bank’s physical security.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描还可以告诉攻击者目标在哪些端口上进行监听。回到我们的银行抢劫者比喻，假设抢劫者来到银行，完全不了解大楼的物理布局。他们根本不知道如何进入金库，因为他们不知道银行物理安全的薄弱环节。
- en: In this section, we’ll discuss a few of the more common scanning techniques
    used to identify hosts, their open ports, and vulnerabilities on a network.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些常见的扫描技术，用于识别网络上的主机、开放端口和漏洞。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*So far, this book has referred to the sides of a connection as the* transmitter
    *and* receiver *or as the* client *and* server*. This chapter refers to each side
    of the communication as either the* attacker *or the* target.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，本书提到的连接双方分别是* 发送方 *和* 接收方 *，或是* 客户端 *和* 服务器*。本章则将通信的每一方称为* 攻击者 *或* 目标*。'
- en: '***SYN Scan***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SYN 扫描***'
- en: '*synscan.pcapng*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*synscan.pcapng*'
- en: 'The type of scanning often done first against a system is a *TCP SYN scan*,
    also known as a *stealth scan* or a *half-open scan*. A SYN scan is the most common
    type for several reasons:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 针对系统进行的常见扫描类型之一是 *TCP SYN 扫描*，也称为 *隐身扫描* 或 *半开放扫描*。SYN 扫描之所以是最常见的类型，原因有几个：
- en: •     It is very fast and reliable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: •      它非常快速且可靠。
- en: •     It is accurate on all platforms, regardless of TCP stack implementation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: •      它在所有平台上都非常准确，无论 TCP 堆栈实现如何。
- en: •     It is less noisy than other scanning techniques.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: •      它比其他扫描技术更不容易被察觉。
- en: The TCP SYN scan relies on the three-way handshake process to determine which
    ports are open on a target host. The attacker sends a TCP SYN packet to a range
    of ports on the target, as if trying to establish a channel for normal communication
    on the ports. Once this packet is received by the target, one of several things
    may happen, as shown in [Figure 12-1](ch12.xhtml#ch12fig1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: TCP SYN 扫描依赖于三次握手过程来确定目标主机上哪些端口是开放的。攻击者向目标的多个端口发送一个 TCP SYN 数据包，仿佛是在尝试为正常通信在这些端口上建立一个通道。一旦目标收到这个数据包，可能会发生几种不同的情况，如[图12-1](ch12.xhtml#ch12fig1)所示。
- en: '![image](../images/f259-01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f259-01.jpg)'
- en: '*Figure 12-1: Possible results of a TCP SYN scan*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：TCP SYN 扫描的可能结果*'
- en: If a service on the target’s machine is listening on a port that receives the
    SYN packet, it will reply to the attacker with a TCP SYN/ACK packet, the second
    part of the TCP handshake. Now the attacker knows that port is open and a service
    is listening on it. Under normal circumstances, a final TCP ACK would be sent
    to complete the connection handshake. In this case, however, the attacker doesn’t
    want that to happen since they won’t be communicating with the host further at
    this point, so the attacker doesn’t attempt to complete the TCP handshake.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标机器上的某个服务正在监听接收 SYN 数据包的端口，它将通过一个 TCP SYN/ACK 数据包回应攻击者，这是 TCP 三次握手的第二部分。此时，攻击者就知道该端口是开放的，并且有服务在监听。正常情况下，最终会发送一个
    TCP ACK 数据包来完成连接的握手。然而，在这种情况下，攻击者并不希望发生这种情况，因为此时他们不会与主机进一步通信，因此攻击者不会尝试完成 TCP 握手。
- en: If no service is listening on a scanned port, the attacker will not receive
    a SYN/ACK. Depending on the configuration of the target’s operating system, the
    attacker could receive an RST packet in return, indicating that the port is closed.
    Alternatively, the attacker may receive no response at all. No response could
    mean that the port is filtered by an intermediate device, such as a firewall or
    the host itself. On the other hand, it could just be that the response was lost
    in transit. Thus, while this result typically indicates that the port is closed,
    it is ultimately inconclusive.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在扫描的端口上没有服务在监听，攻击者将不会收到 SYN/ACK 数据包。根据目标操作系统的配置，攻击者可能会收到一个 RST 数据包，表示该端口已关闭。或者，攻击者可能根本没有收到任何响应。没有响应可能意味着该端口被中间设备（如防火墙或主机本身）过滤。另一方面，也有可能是响应在传输过程中丢失。因此，虽然这种结果通常表示端口已关闭，但最终仍无法得出结论。
- en: The file *synscan.pcapng* provides a great example of a SYN scan performed with
    the Nmap tool. Nmap is a robust network-scanning application developed by Gordon
    “Fyodor” Lyon. It can perform just about any kind of scan you can imagine. You
    can download Nmap for free from *[http://www.nmap.com/download.html](http://www.nmap.com/download.html)*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *synscan.pcapng* 提供了一个使用 Nmap 工具执行 SYN 扫描的良好示例。Nmap 是一款功能强大的网络扫描应用程序，由 Gordon
    “Fyodor” Lyon 开发。它几乎可以执行你能想象的任何类型的扫描。你可以从 *[http://www.nmap.com/download.html](http://www.nmap.com/download.html)*
    免费下载 Nmap。
- en: Our sample capture contains roughly 2,000 packets, telling us that this scan
    is of a reasonable size. One of the best ways to ascertain the scope of a scan
    of this nature is to view the Conversations window, as shown in [Figure 12-2](ch12.xhtml#ch12fig2).
    There, you should see only one IPv4 conversation ➊ between the attacker (172.16.0.8)
    and the target (64.13.134.52). You will also see that there are 1,994 TCP conversations
    between these two hosts ➋—basically a new conversation for every port pairing
    involved in the communications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例捕获包含大约 2,000 个数据包，这告诉我们这个扫描的规模是合理的。确定此类扫描范围的最佳方法之一是查看对话窗口，如[图 12-2](ch12.xhtml#ch12fig2)所示。在那里，你应该只看到一条
    IPv4 对话 ➊，它是攻击者（172.16.0.8）与目标（64.13.134.52）之间的通信。你还会看到这两个主机之间有 1,994 个 TCP 对话
    ➋——基本上每个涉及通信的端口配对都会生成一个新的对话。
- en: '![image](../images/f260-01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f260-01.jpg)'
- en: '*Figure 12-2: The Conversations window shows the variety of TCP communications
    taking place.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-2：对话窗口显示了各种 TCP 通信。*'
- en: The scanning is occurring very quickly, so scrolling through the capture file
    isn’t the best way to find the response associated with each initial SYN packet.
    Several more packets might be sent before a response to the original packet is
    received. Fortunately, we can create filters to help us find the right traffic.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描进行得非常快，所以滚动查看捕获文件并不是找到每个初始 SYN 数据包响应的最佳方式。在收到原始数据包的响应之前，可能会发送几个其他数据包。幸运的是，我们可以创建过滤器来帮助我们找到正确的流量。
- en: '**Using Filters with SYN Scans**'
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用过滤器进行 SYN 扫描**'
- en: 'As an example of filtering, let’s consider the first packet in the capture,
    which is a SYN packet sent to the target on port 443 (HTTPS). To see whether there
    was a response to this packet, we can create a filter to show all traffic to and
    from port 443\. Here’s how to do this quickly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为过滤的示例，我们来看捕获中的第一个数据包，它是发送到目标端口 443（HTTPS）的 SYN 数据包。为了查看是否有响应此数据包的流量，我们可以创建一个过滤器，显示所有往返于端口
    443 的流量。以下是如何快速完成此操作：
- en: Select the first packet in the capture file.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择捕获文件中的第一个数据包。
- en: Expand the TCP header in the Packet Details pane.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开数据包详细信息窗格中的 TCP 头部。
- en: Right-click the **Destination Port** field, select **Prepare as Filter**, and
    click **Selected**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**目标端口**字段，选择**准备为过滤器**，然后点击**选定**。
- en: This will place a filter in the filter dialog for all packets with the destination
    port of 443\. Now, because we also want all packets from the source port of 443,
    click in the filter dialog at the top of the screen and erase the *dst* portion
    of the filter.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将为所有目标端口为 443 的数据包在过滤器对话框中设置一个过滤器。现在，因为我们还需要所有源端口为 443 的数据包，点击屏幕顶部的过滤器对话框，并删除过滤器中的
    *dst* 部分。
- en: The resulting filter will yield two packets, which are both TCP SYN packets
    sent from attacker to target, as shown in [Figure 12-3](ch12.xhtml#ch12fig3).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果过滤器将显示两个数据包，它们都是从攻击者到目标发送的 TCP SYN 数据包，如[图 12-3](ch12.xhtml#ch12fig3)所示。
- en: '![image](../images/f261-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f261-01.jpg)'
- en: '*Figure 12-3: Two attempts to establish a connection with SYN packets*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-3：使用 SYN 数据包建立连接的两次尝试*'
- en: '**NOTE**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this section, packets are shown using the time display format Seconds Since
    Previous Displayed Packet.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本节中，数据包使用自上一个显示的数据包以来的秒数格式进行显示。*'
- en: Since there is no response to either of these packets, it’s possible that the
    response is being filtered by the target host or an intermediary device or that
    the port is closed. Ultimately, the result of the scan against port 443 is inconclusive.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个数据包没有收到响应，可能是响应被目标主机或中间设备过滤，或者端口已关闭。最终，对端口 443 的扫描结果是不确定的。
- en: We can attempt this same technique on another packet to see whether we get different
    results. To do so, clear your previous filter and select packet 9 in the list.
    This is a SYN packet to port 53, commonly associated with DNS. Using the method
    outlined in the previous steps or by modifying your last filter, create a filter
    that will show all TCP port 53 traffic. When you apply this filter, you should
    see five packets, as shown in [Figure 12-4](ch12.xhtml#ch12fig4).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试对另一个数据包使用相同的技术，看是否得到不同的结果。为此，清除之前的过滤器并选择列表中的数据包9。这是发送到端口53的SYN数据包，通常与DNS相关。使用前述步骤中的方法，或者通过修改最后一个过滤器，创建一个过滤器，显示所有TCP端口53的流量。当你应用这个过滤器时，你应该看到五个数据包，如[图
    12-4](ch12.xhtml#ch12fig4)所示。
- en: '![image](../images/f261-02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f261-02.jpg)'
- en: '*Figure 12-4: Five packets indicating a port is open*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-4：表示端口开放的五个数据包*'
- en: The first of these packets is the SYN we selected at the beginning of the capture
    (packet 9). The second is a response from the target. It’s a TCP SYN/ACK—the response
    expected when setting up the three-way handshake. Under normal circumstances,
    the next packet would be an ACK from the host that sent the initial SYN. However,
    in this case, our attacker doesn’t want to complete the connection and doesn’t
    send a response. As a result, the target retransmits the SYN/ACK three more times
    before giving up. Since a SYN/ACK response is received when attempting to communicate
    with the host on port 53, it’s safe to assume that a service is listening on that
    port.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据包中的第一个是我们在捕获开始时选择的SYN（数据包9）。第二个是目标的响应。这是一个TCP SYN/ACK——在建立三次握手时预期的响应。在正常情况下，下一个数据包将是发送初始SYN的主机的ACK。然而，在这种情况下，我们的攻击者并不希望完成连接，因此没有发送响应。结果，目标在放弃之前重新传输了三次SYN/ACK。由于在尝试与端口53上的主机通信时收到了SYN/ACK响应，因此可以安全地假设该端口上有服务在监听。
- en: Let’s rinse and repeat this process one more time for packet 13\. This is a
    SYN packet sent to port 113, which is commonly associated with the Ident protocol,
    often used for IRC identification and authentication services. If you apply the
    same type of filter to the port listed in this packet, you will see four packets,
    as shown in [Figure 12-5](ch12.xhtml#ch12fig5).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再重复这个过程一次，针对数据包13。这是发送到端口113的SYN数据包，通常与Ident协议相关，常用于IRC身份验证和认证服务。如果对这个数据包中列出的端口应用相同类型的过滤器，你将看到四个数据包，如[图
    12-5](ch12.xhtml#ch12fig5)所示。
- en: '![image](../images/f261-03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f261-03.jpg)'
- en: '*Figure 12-5: A SYN followed by an RST, indicating the port is closed*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-5：一个SYN后跟一个RST，表示端口关闭*'
- en: The first packet is the initial SYN, which is followed immediately by an RST
    from the target. This is an indication that the target is not accepting connections
    on the targeted port and that a service is most likely not running on it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据包是初始SYN，紧接着是目标的RST。这表示目标没有在目标端口上接受连接，并且很可能没有服务在该端口上运行。
- en: '**Identifying Open and Closed Ports**'
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**识别开放和关闭的端口**'
- en: Now that you understand the different types of responses a SYN scan can elicit,
    you’ll want to find a fast method of identifying which ports are open or closed.
    The answer lies within the Conversations window once again. In this window, you
    can sort the TCP conversations by packet number, with the highest values at the
    top, by clicking the Packets column header until the arrow points downward, as
    shown in [Figure 12-6](ch12.xhtml#ch12fig6).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你理解了SYN扫描可以引发的不同类型的响应，你将希望找到一种快速的方法来识别哪些端口是开放的，哪些是关闭的。答案再次存在于会话窗口中。在这个窗口中，你可以通过点击“数据包”列标题，按数据包编号对TCP会话进行排序，直到箭头指向下方，如[图
    12-6](ch12.xhtml#ch12fig6)所示。
- en: '![image](../images/f262-01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f262-01.jpg)'
- en: '*Figure 12-6: Finding open ports with the Conversations window*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-6：使用会话窗口查找开放端口*'
- en: Three scanned ports include five packets in each of their conversations ➊. We
    know that ports 53, 80, and 22 are open, because these five packets represent
    the initial SYN, the corresponding SYN/ACK, and the retransmitted SYN/ACKs from
    the target.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 三个扫描端口在它们的每个会话中包含五个数据包➊。我们知道端口53、80和22是开放的，因为这五个数据包代表了初始SYN、相应的SYN/ACK以及目标的重传SYN/ACK。
- en: For five ports, only two packets were involved in the communication ➋. The first
    is the initial SYN, and the second is the RST from the target. These results indicate
    that ports 113, 25, 31337, 113, and 70 are closed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对五个端口，只有两个数据包参与了通信➋。第一个是初始SYN，第二个是目标的RST。这些结果表明端口113、25、31337、113和70是关闭的。
- en: The remaining entries in the Conversations window include only one packet, meaning
    that the target host never responded to the initial SYN. These remaining ports
    are most likely closed, but we’re not sure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对话窗口中的剩余条目仅包括一个数据包，意味着目标主机从未对初始的SYN做出响应。这些端口很可能是关闭的，但我们不确定。
- en: This technique of counting packets worked for this host, but it won’t be consistent
    for all hosts you might scan, so you shouldn’t rely on it exclusively. Instead,
    focus on learning what normal stimulus and response looks like and what abnormal
    responses to normal stimuli can mean.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通过计数数据包的技术在这个主机上有效，但并不适用于你可能扫描的所有主机，因此你不应完全依赖它。相反，应该专注于学习什么是正常的刺激和响应，以及对正常刺激的异常响应可能意味着什么。
- en: '***Operating System Fingerprinting***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***操作系统指纹识别***'
- en: An attacker puts a great deal of value on knowing the target’s operating system.
    Knowledge of the operating system helps the attacker configure all their methods
    of attack correctly for that system. It also allows the attacker to know the location
    of certain critical files and directories within the target file system, should
    they succeed in accessing the system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者非常重视了解目标操作系统的情况。了解操作系统有助于攻击者正确配置所有攻击方法，以适应该系统。它还允许攻击者知道目标文件系统中某些关键文件和目录的位置，如果他们成功访问系统的话。
- en: '*Operating system fingerprinting* is the name given to a group of techniques
    used to determine the operating system running on a system without having physical
    access to that system. There are two types of operating system fingerprinting:
    passive and active.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作系统指纹识别*是指一组技术，用于在没有物理访问权限的情况下确定系统上运行的操作系统。有两种类型的操作系统指纹识别：被动和主动。'
- en: '**Passive Fingerprinting**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**被动指纹识别**'
- en: '*passiveosfinger printing.pcapng*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*passiveosfinger printing.pcapng*'
- en: Using *passive fingerprinting*, you examine certain fields within packets sent
    from the target to determine the operating system in use. The technique is considered
    passive because you listen to only the packets the target host is sending and
    don’t actively send any packets to the host yourself. This type of operating system
    fingerprinting is ideal for attackers because it allows them to be stealthy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*被动指纹识别*，你可以检查从目标发送的某些数据包字段，以确定正在使用的操作系统。该技术被认为是被动的，因为你只监听目标主机发送的数据包，而不是主动向主机发送任何数据包。这种类型的操作系统指纹识别非常适合攻击者，因为它使他们能够保持隐蔽。
- en: That said, how can we determine which operating system a host is running based
    on nothing but the packets it sends? This feat is possible due to the lack of
    standardized values in the specifications defined by protocol RFCs. Although the
    various fields contained in TCP, UDP, and IP headers are very specific, default
    values are typically not defined for every field. This means that the TCP/IP stack
    implementation in each operating system must define its own default values for
    these fields. [Table 12-1](ch12.xhtml#ch12tab1) lists some of the more common
    fields and the default values that can be used to link them to various operating
    systems. Keep in mind that these values are subject to change with new OS version
    releases.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们如何仅凭目标主机发送的数据包来确定其操作系统呢？这项技术之所以可能，是因为协议RFC中定义的规范没有标准化的值。尽管TCP、UDP和IP头中的各种字段非常具体，但通常并未为每个字段定义默认值。这意味着每个操作系统中的TCP/IP堆栈实现必须为这些字段定义自己的默认值。[表12-1](ch12.xhtml#ch12tab1)列出了部分常见字段及其默认值，这些默认值可以用来将它们与不同的操作系统关联。请记住，这些值可能会随着新的操作系统版本发布而发生变化。
- en: '**Table 12-1:** Common Passive Fingerprinting Values'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-1：** 常见的被动指纹识别值'
- en: '| **Protocol header** | **Field** | **Default value** | **Platform** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **协议头** | **字段** | **默认值** | **平台** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| IP | Initial time to live | 64 | NMap, BSD, OS X, Linux |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| IP | 初始生存时间 | 64 | NMap, BSD, OS X, Linux |'
- en: '|  |  | 128 | Novell, Windows |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 128 | Novell, Windows |'
- en: '|  |  | 255 | Cisco IOS, Palm OS, Solaris |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 255 | Cisco IOS, Palm OS, Solaris |'
- en: '| IP | Don’t fragment flag | Set | BSD, OS X, Linux, Novell, Windows, Palm
    OS, Solaris |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| IP | 不分段标志 | 设置 | BSD, OS X, Linux, Novell, Windows, Palm OS, Solaris |'
- en: '|  |  | Not set | Nmap, Cisco IOS |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 未设置 | Nmap, Cisco IOS |'
- en: '| TCP | Maximum segment size | 0 | Nmap |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| TCP | 最大报文段大小 | 0 | Nmap |'
- en: '|  |  | 1440–1460 | Windows, Novell |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 1440–1460 | Windows, Novell |'
- en: '|  |  | 1460 | BSD, OS X, Linux, Solaris |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 1460 | BSD, OS X, Linux, Solaris |'
- en: '| TCP | Window size | 1024–4096 | Nmap |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| TCP | 窗口大小 | 1024–4096 | Nmap |'
- en: '|  |  | 65535 | BSD, OS X |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 65535 | BSD, OS X |'
- en: '|  |  | Variable | Linux |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 变量 | Linux |'
- en: '|  |  | 16384 | Novell |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 16384 | Novell |'
- en: '|  |  | 4128 | Cisco IOS |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 4128 | Cisco IOS |'
- en: '|  |  | 24820 | Solaris |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 24820 | Solaris |'
- en: '|  |  | Variable | Windows |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 可变 | Windows |'
- en: '| TCP | SackOK | Set | Linux, Windows, OS X, OpenBSD |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| TCP | SackOK | 设置 | Linux, Windows, OS X, OpenBSD |'
- en: '|  |  | Not set | Nmap, FreeBSD, Novell, Cisco IOS, Solaris |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 未设置 | Nmap, FreeBSD, Novell, Cisco IOS, Solaris |'
- en: The packets contained in the file *passiveosfingerprinting.pcapng* are great
    examples of this technique. There are two packets in this file. Both are TCP SYN
    packets sent to port 80, but they come from different hosts. Using only the values
    contained in these packets and referring to [Table 12-1](ch12.xhtml#ch12tab1),
    we should be able to determine the operating system architecture in use on each
    host. The details of each packet are shown in [Figure 12-7](ch12.xhtml#ch12fig7).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在文件*passiveosfingerprinting.pcapng*中的数据包是这种技术的绝佳示例。文件中有两个数据包，两个都是发送到端口 80
    的 TCP SYN 数据包，但它们来自不同的主机。仅使用这些数据包中包含的值，并参考[表 12-1](ch12.xhtml#ch12tab1)，我们应该能够确定每个主机上使用的操作系统架构。每个数据包的详细信息见[图
    12-7](ch12.xhtml#ch12fig7)。
- en: Using [Table 12-1](ch12.xhtml#ch12tab1) as a reference, we can create [Table
    12-2](ch12.xhtml#ch12tab2), which is a breakdown of the relevant fields in these
    packets.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[表 12-1](ch12.xhtml#ch12tab1)作为参考，我们可以创建[表 12-2](ch12.xhtml#ch12tab2)，它是这些数据包中相关字段的细分。
- en: '**Table 12-2:** Breakdown of the Operating System Fingerprinting Packets'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-2：** 操作系统指纹识别数据包细分'
- en: '| **Protocol header** | **Field** | **Packet 1 value** | **Packet 2 value**
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **协议头** | **字段** | **数据包 1 值** | **数据包 2 值** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| IP | Initial time to live | 128 | 64 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| IP | 初始生存时间 | 128 | 64 |'
- en: '| IP | Don’t fragment flag | Set | Set |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| IP | 不分片标志 | 设置 | 设置 |'
- en: '| TCP | Maximum segment size | 1,440 bytes | 1,460 bytes |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| TCP | 最大段大小 | 1,440 字节 | 1,460 字节 |'
- en: '| TCP | Window size | 64,240 bytes | 2,920 bytes |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| TCP | 窗口大小 | 64,240 字节 | 2,920 字节 |'
- en: '| TCP | SackOK | Set | Set |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| TCP | SackOK | 设置 | 设置 |'
- en: Based on these values, we can conclude that packet 1 was most likely sent by
    a device running Windows and packet 2 was most likely sent by a device running
    Linux.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些值，我们可以得出结论，数据包 1 很可能是由运行 Windows 的设备发送的，而数据包 2 很可能是由运行 Linux 的设备发送的。
- en: Keep in mind that the list of common passive fingerprinting identifying fields
    in [Table 12-1](ch12.xhtml#ch12tab1) is by no means exhaustive. There are many
    quirks that may result in deviations from these expected values. Therefore, you
    cannot fully rely on the results gained from passive operating system fingerprinting.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，[表 12-1](ch12.xhtml#ch12tab1)中列出的常见被动指纹识别标识字段并非详尽无遗。还有许多特殊情况可能导致这些预期值的偏差。因此，你不能完全依赖被动操作系统指纹识别得到的结果。
- en: '![image](../images/f265-01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f265-01.jpg)'
- en: '*Figure 12-7: These packets can tell us which operating system they were sent
    from.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-7：这些数据包可以告诉我们它们是从哪个操作系统发送的。*'
- en: '**NOTE**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In many cases, attackers rely on automated tools to passively identify the
    operating system of a target. One tool that uses operating system fingerprinting
    techniques is p0f. This tool analyzes relevant fields in a packet capture and
    outputs the suspected operating system. Using tools like p0f, you can get not
    only the operating system architecture but sometimes even the version or patch
    level of the OS. You can download p0f from* [http://lcamtuf.coredump.cx/p0f.shtml](http://lcamtuf.coredump.cx/p0f.shtml).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*在许多情况下，攻击者依赖自动化工具来被动识别目标的操作系统。使用操作系统指纹识别技术的一个工具是 p0f。该工具分析数据包捕获中的相关字段并输出疑似的操作系统。通过使用像
    p0f 这样的工具，你不仅可以获取操作系统架构，有时甚至可以得到操作系统的版本或补丁级别。你可以从* [http://lcamtuf.coredump.cx/p0f.shtml](http://lcamtuf.coredump.cx/p0f.shtml)
    下载 p0f。'
- en: '**Active Fingerprinting**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**主动指纹识别**'
- en: '*activeosfingerprinting.pcapng*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*activeosfingerprinting.pcapng*'
- en: When passively monitoring traffic doesn’t yield the desired results, a more
    direct approach—*active fingerprinting*—may be required. Now the attacker actively
    sends specially crafted packets to the target to elicit replies that will reveal
    the operating system on the target’s machine. Of course, since this approach involves
    communicating directly with the target, it is not the least bit stealthy, but
    it can be highly effective.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当被动监控流量未能获得预期结果时，可能需要采取更直接的方法——*主动指纹识别*。在这种方法中，攻击者主动向目标发送特别构造的数据包，以引发回复，从而揭示目标机器上的操作系统。当然，由于这种方法涉及直接与目标通信，因此并不隐蔽，但它可以非常有效。
- en: The file *activeosfingerprinting.pcapng* contains an example of an active operating
    system fingerprinting scan initiated with the Nmap scanning utility. Several packets
    in this file are the result of Nmap’s sending different probes designed to elicit
    responses that will allow for operating system identification. Nmap records the
    responses to these probes and builds a fingerprint, which it compares to a database
    of values to make a determination.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*activeosfingerprinting.pcapng*包含了一个使用 Nmap 扫描工具发起的主动操作系统指纹识别扫描的示例。该文件中的多个数据包是
    Nmap 发送的不同探测包的结果，旨在引发响应，从而识别操作系统。Nmap 会记录这些探测包的响应，并构建指纹，随后与数据库中的值进行比对，以做出判断。
- en: '**NOTE**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The techniques used by Nmap to actively fingerprint an operating system are
    quite complex. To learn more about how Nmap performs active operating system finger-printing,
    read the definitive guide to Nmap,* Nmap Network Scanning *(2008), by the tool’s
    author, Gordon “Fyodor” Lyon.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*Nmap 用于主动指纹识别操作系统的技术相当复杂。要了解 Nmap 如何执行主动操作系统指纹识别，请阅读该工具作者 Gordon “Fyodor”
    Lyon 的权威指南，《Nmap 网络扫描》（2008）。*'
- en: '**Traffic Manipulation**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**流量操控**'
- en: One of the key points I’ve tried to show throughout this book is that you can
    learn a lot about a system or its users by examining the right packets. Thus,
    it should come as no surprise that attackers often seek to capture these packets
    themselves. By examining the packets generated by a system, an attacker can learn
    about the operating system, the applications in use, authentication credentials,
    and much more.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我一直尝试展示的一个关键点是，通过分析正确的数据包，你可以了解一个系统或其用户的许多信息。因此，攻击者通常会自己捕获这些数据包，这一点并不奇怪。通过分析系统生成的数据包，攻击者可以了解操作系统、使用的应用程序、身份验证凭证等等。
- en: 'In this section, we’ll examine two techniques at the packet level: how an attacker
    can use ARP cache poisoning to intercept and capture target traffic and how they
    can intercept HTTP cookies to perform session-hijacking attacks.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将讨论两种数据包级别的技术：攻击者如何利用 ARP 缓存中毒拦截和捕获目标流量，以及他们如何拦截 HTTP cookies 进行会话劫持攻击。
- en: '***ARP Cache Poisoning***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ARP 缓存中毒***'
- en: '*arppoison.pcapng*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*arppoison.pcapng*'
- en: In [Chapter 7](ch07.xhtml#ch07), we discussed how the ARP protocol is used to
    allow devices to map IP addresses to MAC addresses inside of a network, and, in
    [Chapter 2](ch02.xhtml#ch02), we discussed how ARP cache poisoning can be a useful
    technique for tapping into the wire and intercepting traffic from hosts whose
    packets you need to analyze. When used for legitimate purposes, ARP cache poisoning
    is very helpful for troubleshooting. However, when this technique is used with
    malicious intent, it is a lethal form of the *man-in-the-middle (MITM) attack*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 7 章](ch07.xhtml#ch07)中，我们讨论了 ARP 协议如何允许设备在网络内部将 IP 地址映射到 MAC 地址；在[第 2 章](ch02.xhtml#ch02)中，我们讨论了
    ARP 缓存中毒如何成为一个有用的技术，可以帮助我们接入网络并拦截需要分析的主机流量。当用于合法目的时，ARP 缓存中毒对故障排除非常有帮助。然而，当该技术被用于恶意目的时，它将成为一种致命的*中间人攻击
    (MITM)*。
- en: In a MITM attack, an attacker redirects traffic between two hosts in order to
    intercept or modify data in transit. There are many forms of MITM attacks, including
    DNS spoofing and SSL hijacking. In ARP cache poisoning, specially crafted ARP
    packets trick two hosts into thinking they are communicating with each other when,
    in fact, they are communicating with a third party who is relaying packets as
    an intermediary. In this way, the illegitimate use of a protocol’s normal functionality
    can be used for malicious purposes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MITM 攻击中，攻击者会重定向两个主机之间的流量，以便拦截或修改传输中的数据。MITM 攻击有很多种形式，包括 DNS 欺骗和 SSL 劫持。在
    ARP 缓存中毒中，特殊构造的 ARP 数据包使得两台主机误认为它们在彼此之间通信，实际上它们是在与第三方通信，第三方充当中介转发数据包。通过这种方式，协议的正常功能被不正当使用，进而被用作恶意目的。
- en: The file *arppoison.pcapng* contains an example of ARP cache poisoning. When
    you open it, you’ll see that this traffic appears normal at first glance. However,
    if you follow the packets, you’ll see our target, 172.16.0.107, browsing to Google
    and performing a search. As a result of this search, there is quite a bit of HTTP
    traffic with some DNS queries mixed in.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*arppoison.pcapng*包含了一个 ARP 缓存中毒的示例。当你打开它时，你会发现这些流量乍看之下是正常的。然而，如果你跟踪数据包，你会看到我们的目标
    172.16.0.107 正在浏览 Google 并进行搜索。由于这次搜索，产生了大量的 HTTP 流量，并夹杂了一些 DNS 查询。
- en: 'We know that ARP cache poisoning is a technique that occurs at layer 2, so
    if we just casually peruse the packets in the Packet List pane, it may be hard
    to see any foul play. To give us a leg up, we’ll add a couple of columns to the
    Packet List pane, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，ARP缓存中毒是一种发生在第二层的技术，因此如果我们只是随便浏览数据包列表窗格，可能很难看到任何恶意行为。为了帮助我们识别这些，我们将在数据包列表窗格中添加几个列，如下所示：
- en: Select **Edit** ▶ **Preferences**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**编辑** ▶ **首选项**。
- en: Click **Columns** on the left side of the Preferences window.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击首选项窗口左侧的**列**。
- en: Click the plus (+) button to add a new column.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击加号（+）按钮以添加一个新列。
- en: In the Title area, type Source MAC and press ENTER.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标题区域，输入源MAC并按ENTER键。
- en: In the Type drop-down list, select **Hw src addr (resolved)**.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类型下拉列表中，选择**Hw src addr (resolved)**。
- en: Click the newly added entry and drag it so that it is directly after the Source
    column.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击新添加的条目并拖动它，使其紧接在源列后面。
- en: Click the plus (+) button to add a new column.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击加号（+）按钮以添加一个新列。
- en: In the Title area, type Dest MAC and press ENTER.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标题区域，输入目标MAC并按ENTER键。
- en: In the Type drop-down list, select **Hw dest addr (resolved)**.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类型下拉列表中，选择**Hw dest addr (resolved)**。
- en: Click the newly added entry and drag it so that it is directly after the Destination
    column.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击新添加的条目并拖动它，使其紧接在目标列后面。
- en: Click **OK** to apply the changes.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以应用更改。
- en: When you have completed these steps, your screen should look like [Figure 12-8](ch12.xhtml#ch12fig8).
    You should now have two additional columns showing the source and destination
    MAC addresses of the packets.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这些步骤后，屏幕应该会像[图 12-8](ch12.xhtml#ch12fig8)所示。此时，你应该有两列额外显示数据包的源MAC地址和目标MAC地址。
- en: '![image](../images/f268-01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f268-01.jpg)'
- en: '*Figure 12-8: The column configuration screen with newly added columns for
    source and destination hardware addresses*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-8：添加了源和目标硬件地址的新列配置屏幕*'
- en: If you still have MAC name resolution turned on, you should see that the communicating
    devices have MAC addresses that indicate Dell and Cisco hardware. This is very
    important to remember because as we scroll through the capture, we’ll see that
    this changes at packet 54, where we see some peculiar ARP traffic occurring between
    the Dell host (our target) and a newly introduced HP host (the attacker), as shown
    in [Figure 12-9](ch12.xhtml#ch12fig9).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然开启了MAC名称解析，你应该能看到通信设备的MAC地址，标示出Dell和Cisco硬件。记住这一点非常重要，因为当我们浏览捕获的数据时，会看到在第54个数据包处发生了变化，此时我们看到Dell主机（我们的目标）与新引入的HP主机（攻击者）之间发生了某些奇怪的ARP流量，如[图
    12-9](ch12.xhtml#ch12fig9)所示。
- en: '![image](../images/f268-02.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f268-02.jpg)'
- en: '*Figure 12-9: Strange ARP traffic between the Dell device and an HP device*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-9：Dell设备与HP设备之间的奇怪ARP流量*'
- en: Before proceeding further, note the endpoints involved in this communication,
    which are listed in [Table 12-3](ch12.xhtml#ch12tab3).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续操作之前，请注意此通信中涉及的端点，这些端点列在[表 12-3](ch12.xhtml#ch12tab3)中。
- en: '**Table 12-3:** Endpoints Being Monitored'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-3:** 正在监控的端点'
- en: '| **Role** | **Device type** | **IP address** | **MAC address** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **角色** | **设备类型** | **IP地址** | **MAC地址** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Target | Dell | 172.16.0.107 | 00:21:70:c0:56:f0 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 目标 | Dell | 172.16.0.107 | 00:21:70:c0:56:f0 |'
- en: '| Router | Cisco | 172.16.0.1 | 00:26:0b:31:07:33 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 路由器 | Cisco | 172.16.0.1 | 00:26:0b:31:07:33 |'
- en: '| Attacker | HP | Unknown | 00:25:b3:bf:91:ee |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 攻击者 | HP | 未知 | 00:25:b3:bf:91:ee |'
- en: 'But what makes this traffic strange? Recall from our discussion of ARP in [Chapter
    7](ch07.xhtml#ch07) that there are two primary types of ARP packets: a request
    and a response. The request packet is sent as a broadcast to all hosts on the
    network in order to find the machine that has the MAC address associated with
    a particular IP address. Then the machine that replies to the requesting device
    sends a response as a unicast packet. Given this background, we can identify a
    few peculiar things in this communication sequence, referring to [Figure 12-9](ch12.xhtml#ch12fig9).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，是什么让这段流量显得奇怪呢？回顾我们在[第7章](ch07.xhtml#ch07)中关于ARP的讨论，ARP数据包有两种主要类型：请求和响应。请求数据包作为广播发送到网络中的所有主机，以便找到与特定IP地址关联的MAC地址。然后，回复请求设备的主机发送一个单播数据包作为响应。根据这些背景信息，我们可以识别出此通信序列中的一些异常，参考[图
    12-9](ch12.xhtml#ch12fig9)。
- en: First, packet 54 is an ARP request sent from the attacker (MAC address 00:25:b3:bf:91:ee)
    as a unicast packet directly to the target (MAC address 00:21:70:c0:56:f0) ➊.
    This type of request should be broadcast to all hosts on the network, but this
    one singles out the target. Also, notice that although this packet is sent from
    the attacker and includes the attacker’s MAC address in the ARP header, it lists
    the router’s IP address rather than its own.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，数据包54是一个ARP请求，由攻击者（MAC地址00:25:b3:bf:91:ee）作为单播数据包直接发送到目标（MAC地址00:21:70:c0:56:f0）➊。这种类型的请求应该广播给网络上的所有主机，但这个请求仅仅指向了目标。同时，注意到尽管这个数据包是由攻击者发送，并且在ARP头中包含了攻击者的MAC地址，但它列出了路由器的IP地址，而不是攻击者自己的。
- en: This packet is followed by a response from the target to the attacker containing
    its MAC address information ➋. The real voodoo here occurs in packet 56, in which
    the attacker sends a packet to the target with an unsolicited ARP reply telling
    it that 172.16.0.1 is located at its MAC address, 00:25:b3:bf:91:ee ➌. The problem
    is that MAC address 172.16.0.1 isn’t 00:25:b3:bf:91:ee but is 00:26:0b:31:07:33\.
    We know this because we saw the router at 172.16.0.1 communicating with the target
    earlier in the packet capture. Since the ARP protocol is inherently insecure (it
    accepts unsolicited updates to its ARP table), the target will now be sending
    traffic that should be going to the router to the attacker instead.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，目标向攻击者回应了一个包含其MAC地址信息的数据包➋。真正的“巫术”发生在数据包56中，攻击者向目标发送了一个未经请求的ARP回复，告诉目标172.16.0.1位于其MAC地址00:25:b3:bf:91:ee处➌。问题是，MAC地址172.16.0.1并不是00:25:b3:bf:91:ee，而是00:26:0b:31:07:33。我们之所以知道这一点，是因为我们在之前的数据包捕获中看到了路由器与目标之间的通信。由于ARP协议本身不安全（它接受未经请求的ARP表更新），目标现在会把本应发送给路由器的流量发送给攻击者。
- en: '**NOTE**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because this packet capture was taken from the target’s machine, you don’t
    actually see the entire picture. For this attack to work, the attacker must send
    the same sequence of packets to the router in order to trick it into thinking
    the attacker is actually the target, but we would need to take another packet
    capture from the router (or the attacker) to see those packets.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于这个数据包捕获来自目标的机器，因此你实际上并没有看到整个情况。为了让这次攻击生效，攻击者必须向路由器发送相同的包序列，以让路由器认为攻击者实际上就是目标，但我们需要从路由器（或攻击者）获取另一个数据包捕获，才能看到那些数据包。*'
- en: Once both target and router have been duped, the communication between them
    flows through the attacker, as illustrated in [Figure 12-10](ch12.xhtml#ch12fig10).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦目标和路由器都被欺骗，二者之间的通信就会通过攻击者进行传输，如[图12-10](ch12.xhtml#ch12fig10)所示。
- en: '![image](../images/f270-01.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f270-01.jpg)'
- en: '*Figure 12-10: ARP cache poisoning as an MITM attack*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-10：作为MITM攻击的ARP缓存中毒*'
- en: Packet 57 confirms the success of this attack. When you compare this packet
    to one sent before the mysterious ARP traffic, such as packet 40 (see [Figure
    12-11](ch12.xhtml#ch12fig11)), you will see that the IP address of the remote
    server (Google) remains the same ➋ but the target MAC address has changed ➊. This
    change in MAC address tells us that the traffic is now being routed through the
    attacker before it gets to the router.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包57确认了此次攻击的成功。通过将这个数据包与神秘ARP流量之前发送的一个数据包进行对比，比如数据包40（见[图12-11](ch12.xhtml#ch12fig11)），你会发现远程服务器（Google）的IP地址保持不变➋，但目标的MAC地址发生了变化➊。MAC地址的变化告诉我们，流量现在正在通过攻击者进行路由，直到到达路由器。
- en: Because this attack is so subtle, it’s very difficult to detect. To find it,
    you typically need the aid of an IDS configured specifically to address it or
    software running on devices designed to detect sudden changes in ARP table entries.
    Since you’ll most likely use ARP cache poisoning to capture packets on networks
    you are analyzing, it’s important to know how this technique can be used against
    you as well.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此攻击非常隐蔽，因此很难检测。为了发现它，通常需要借助专门配置的IDS（入侵检测系统），或者是运行在设备上的软件，用于检测ARP表条目的突变。由于你很可能会使用ARP缓存中毒来捕获你正在分析的网络上的数据包，因此了解这种技术如何被用于攻击你是很重要的。
- en: '![image](../images/f271-01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f271-01.jpg)'
- en: '*Figure 12-11: The change in target MAC address shows this attack was a success.*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-11：目标MAC地址的变化表明此次攻击成功。*'
- en: '***Session Hijacking***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***会话劫持***'
- en: '*sessionhijacking.pcapng*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*sessionhijacking.pcapng*'
- en: 'Now that you know how ARP cache poisoning can be used maliciously, I want to
    demonstrate a technique that can take advantage of it: *session hijacking*. In
    session hijacking, an attacker compromises an HTTP session cookie, which we’ll
    learn about soon, and uses it to impersonate another user. To accomplish this,
    an attacker can use ARP cache poisoning to intercept a target’s traffic and find
    relevant session cookie information. The attacker can then use that information
    to access the target web application as the target user.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了 ARP 缓存中毒可以被恶意利用，我想展示一种可以利用它的技术：*会话劫持*。在会话劫持中，攻击者获取一个 HTTP 会话 cookie，稍后我们将学习它，并用它冒充另一个用户。为了实现这一点，攻击者可以利用
    ARP 缓存中毒来拦截目标的流量并找到相关的会话 cookie 信息。然后，攻击者可以使用这些信息以目标用户的身份访问目标 web 应用程序。
- en: This scenario begins with the file *sessionhijacking.pcapng*. This capture contains
    the traffic of a target (172.16.16.164) communicating with a web application (172.16.16.181).
    Unbeknownst to the target, they have fallen prey to an attacker (172.16.16.154)
    who is actively intercepting their communications. These packets were collected
    from the perspective of the web server, which is likely the same viewpoint a defender
    would have if a session-hijacking attack were used against their server infrastructure.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本场景从文件 *sessionhijacking.pcapng* 开始。该捕获文件包含了一个目标（172.16.16.164）与一个 web 应用程序（172.16.16.181）之间的通信流量。在目标不知情的情况下，他们已经成为攻击者（172.16.16.154）的受害者，攻击者正在积极拦截他们的通信。这些数据包是从
    web 服务器的角度收集的，这很可能是防御者在针对其服务器基础设施实施会话劫持攻击时所拥有的视角。
- en: '**NOTE**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The web application being accessed here is called Damn Vulnerable Web Application
    (DVWA). It is intentionally vulnerable to many types of attacks and is used frequently
    as a teaching tool. If you’d like to learn more about web application attacks
    or investigate packets associated with them, you can learn more about DVWA at*
    [http://www.dvwa.co.uk/](http://www.dvwa.co.uk/).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里访问的 web 应用程序名为 Damn Vulnerable Web Application (DVWA)。它故意存在许多类型的漏洞，常被用作教学工具。如果你想了解更多关于
    web 应用攻击的信息或分析与这些攻击相关的数据包，可以在* [http://www.dvwa.co.uk/](http://www.dvwa.co.uk/)
    *了解更多关于 DVWA 的内容。*'
- en: The traffic in this capture consists primarily of two conversations. The first
    is the communication from the target to web server, which can be isolated with
    the filter ip.addr == 172.16.16.164 && ip.addr == 172.16.16.181. This communication
    represents normal web-browsing traffic and isn’t particularly special. Of particular
    interest is the cookie value in the requests. For instance, if you look at a `GET`
    request such as the one in packet 14, you will find the cookie listed in the Packet
    Details window, as shown in [Figure 12-12](ch12.xhtml#ch12fig12). In this case,
    the cookie identifies the session ID with a PHPSESSID value of `ncobrqrb7fj2a2sinddtk567q4`
    ➊.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该捕获中的流量主要包含两次对话。第一次是目标与 web 服务器之间的通信，可以通过过滤器 ip.addr == 172.16.16.164 && ip.addr
    == 172.16.16.181 来隔离。这种通信表示正常的 web 浏览流量，没有特别之处。特别值得关注的是请求中的 cookie 值。例如，如果你查看第
    14 包中的 `GET` 请求，你会在数据包详细信息窗口中找到 cookie，如 [图12-12](ch12.xhtml#ch12fig12) 所示。在这种情况下，cookie
    通过一个 PHPSESSID 值 `ncobrqrb7fj2a2sinddtk567q4` ➊ 来标识会话 ID。
- en: '![image](../images/f272-01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f272-01.jpg)'
- en: '*Figure 12-12: Viewing the target’s session cookie*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-12：查看目标的会话 cookie*'
- en: Websites use cookies to maintain session awareness for individual hosts. When
    a new visitor comes to a website, they are issued a session ID that uniquely identifies
    them (the PHPSESSID). For authentication, many applications wait until a user
    with a session ID has successfully authenticated to the app, and then they create
    a database record recognizing that ID as being representative of an authenticated
    session. Any user with that ID will be able to access the app with that authentication.
    Of course, developers want to believe that only a single user would have a specific
    ID because the IDs are uniquely generated. This method of handling session IDs
    is insecure, however, because it allows a malicious user to steal another user’s
    ID and use it to impersonate them. There are methods that can be used to prevent
    session-hijacking techniques, but many websites, including DVWA, are still vulnerable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 网站使用 cookies 来维持对单独主机的会话识别。当新访客访问网站时，系统会为其分配一个唯一的会话 ID（即 PHPSESSID）。为了进行身份验证，许多应用会等待具有会话
    ID 的用户成功登录应用后，才会创建一个数据库记录，识别该 ID 为已验证会话的代表。任何拥有该 ID 的用户都可以使用该身份验证访问应用。当然，开发者通常认为只有单一用户拥有特定的
    ID，因为这些 ID 是唯一生成的。然而，这种处理会话 ID 的方法并不安全，因为它允许恶意用户窃取其他用户的 ID 并冒充他们。虽然有方法可以防止会话劫持技术，但许多网站，包括
    DVWA，仍然容易受到攻击。
- en: The target doesn’t realize that their traffic is being intercepted by an attacker
    or that the attacker has access to the session cookie, as shown in [Figure 12-12](ch12.xhtml#ch12fig12).
    All the attacker has to do is communicate with the web server using that cookie
    value. This task can be accomplished with certain types of proxy servers, but
    it is made even easier by using browser plugins like Cookie Manager for Chrome.
    Using this plugin, the attacker can specify the PHPSESSID value obtained from
    the target’s traffic, as shown in [Figure 12-13](ch12.xhtml#ch12fig13).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 目标并没有意识到他们的流量正被攻击者拦截，或者攻击者已经获取到会话 cookie，如[图 12-12](ch12.xhtml#ch12fig12)所示。攻击者所要做的，就是使用该
    cookie 值与 Web 服务器进行通信。这项任务可以通过某些类型的代理服务器来完成，但使用像 Chrome 的 Cookie 管理器这样的浏览器插件会更轻松。通过这个插件，攻击者可以指定从目标流量中获取的
    PHPSESSID 值，如[图 12-13](ch12.xhtml#ch12fig13)所示。
- en: '![image](../images/f273-01.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f273-01.jpg)'
- en: '*Figure 12-13: Using the Cookie Manager plugin to impersonate the target*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-13：使用 Cookie 管理器插件模拟目标身份*'
- en: If you clear the filter previously applied to the capture file and start scrolling
    down, eventually you’ll see the attacker’s IP address communicating with the web
    server. You can limit your view to this communication using the filter ip.addr
    == 172.16.16.154 && ip.addr == 172.16.16.181.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你清除之前应用于捕获文件的过滤器并开始向下滚动，最终会看到攻击者的 IP 地址与 Web 服务器进行通信。你可以通过过滤器 ip.addr == 172.16.16.154
    && ip.addr == 172.16.16.181 来限制视图，只显示这些通信。
- en: Before we dig into this further, let’s add a column to show the cookie values
    in the Packet List pane. If you added columns as part of the previous section
    on ARP cache poisoning, you should remove those first. Then proceed to use the
    instructions from the ARP cache-poisoning section to add the new custom column
    field based on the field name http.cookie_pair. Once you’ve added the column,
    position it after the Destination field. Your screen should look like [Figure
    12-14](ch12.xhtml#ch12fig14).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步探讨之前，先在数据包列表窗格中添加一列来显示 cookie 值。如果你在上一节的 ARP 缓存投毒部分已经添加了列，应该先移除这些列。然后，按照
    ARP 缓存投毒部分的说明，基于字段名 http.cookie_pair 添加新的自定义列。一旦添加完成，将该列放置在目标字段后面。你的屏幕应该如[图 12-14](ch12.xhtml#ch12fig14)所示。
- en: '![image](../images/f274-01.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f274-01.jpg)'
- en: '*Figure 12-14: Configuring columns to investigate session hijacking*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-14：配置列以调查会话劫持*'
- en: With the new columns configured, modify the display filter to show only HTTP
    requests, as TCP communication isn’t useful here. The new filter is (ip.addr==172.16.16.154
    && ip.addr==172.16.16.181) && (http.request.method || http.response.code). The
    resulting packets are shown in [Figure 12-15](ch12.xhtml#ch12fig15).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好新的列后，修改显示过滤器，只显示 HTTP 请求，因为 TCP 通信在这里没有用处。新的过滤器是 (ip.addr==172.16.16.154
    && ip.addr==172.16.16.181) && (http.request.method || http.response.code)。结果包如[图
    12-15](ch12.xhtml#ch12fig15)所示。
- en: '![image](../images/f274-02.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f274-02.jpg)'
- en: '*Figure 12-15: The attacker impersonating the target user*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-15：攻击者冒充目标用户*'
- en: You are now looking at communication between the attacker and the server. In
    the first four packets, the attacker requests the */dvwa/* directory ➊ and receives
    a 302 response code in return, which is a normal method web servers use to redirect
    visitors to different URLs on a server. In this case, the attacker gets redirected
    to the login page at */dvwa/login.php* ➋. The attacker’s machine requests the
    login page ➌, which is returned successfully ➍. Both requests use the session
    ID *lup70ajeuodkrhrvbmsjtgrd71*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在查看攻击者与服务器之间的通信。在前四个数据包中，攻击者请求 */dvwa/* 目录 ➊，并收到302响应代码，这是 web 服务器用来将访客重定向到不同
    URL 的正常方法。在这种情况下，攻击者被重定向到了登录页面 */dvwa/login.php* ➋。攻击者的机器请求了登录页面 ➌，并成功返回 ➍。这两个请求都使用了会话
    ID *lup70ajeuodkrhrvbmsjtgrd71*。
- en: Following that, there is a new request for the */dvwa/* directory, but this
    time, take note of the different session ID ➎. The session ID is now *ncobrqrb7fj2a2sinddtk567q4*,
    which is the same one the target used earlier. This indicates the attacker has
    manipulated the traffic to use the stolen ID. Instead of being redirected to the
    login page, the request is met with an HTTP 200 status code, and the page is delivered
    as the authenticated target would see it ➏. The attacker browses to another page,
    *dvwa/setup.php*, using the target’s ID ➐, and that page also returns successfully
    ➑. The attacker is browsing the DVWA website as though they were authenticated
    as the target. This is all without knowing the target’s username or password.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，发出了新的请求来访问 */dvwa/* 目录，但这次请注意不同的会话 ID ➎。会话 ID 现在是 *ncobrqrb7fj2a2sinddtk567q4*，与目标先前使用的相同。这表明攻击者已经操控了流量，使用了被盗的
    ID。请求没有被重定向到登录页面，而是返回了 HTTP 200 状态码，并且页面以目标认证后的样子被呈现 ➏。攻击者使用目标的 ID 浏览了另一个页面 *dvwa/setup.php*
    ➐，该页面也成功返回 ➑。攻击者像目标一样浏览 DVWA 网站，而无需知道目标的用户名或密码。
- en: This is just one example of how an attacker can turn packet analysis into an
    offensive tool. In general, it’s safe to assume that if an attacker can see the
    packets associated with your communication, some type of malicious activity can
    result. This is one reason security professionals advocate for protecting data
    in transit through encryption.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个例子，展示了攻击者如何将数据包分析转化为攻击工具。一般来说，可以安全地假设，如果攻击者能够看到与你的通信相关的数据包，那么就有可能导致某种类型的恶意活动。这也是安全专业人士主张通过加密保护传输数据的原因之一。
- en: '**Malware**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**恶意软件**'
- en: While perfectly legitimate software can be used for malicious purposes, *malware*
    is a term usually reserved for code that is written specifically with malicious
    intent. Malware can take many shapes and forms, including worms that are self-propagating
    and trojan horses that masquerade as legitimate software. From a network defender’s
    view, most malware is undiscovered and unknown until it can be captured and analyzed.
    This analysis involves multiple steps, including one focused on a behavioral analysis
    of the malware’s network communication patterns. In some cases, analysis occurs
    in a forensic malware reverse-engineering lab, but more often, it occurs in the
    wild when a security analyst discovers a device on their network that has become
    infected.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管完全合法的软件也可以用于恶意目的，*恶意软件*通常是指专门为了恶意意图而编写的代码。恶意软件可以有多种形态，包括自我传播的蠕虫和伪装成合法软件的特洛伊木马。从网络防御者的角度来看，大多数恶意软件在被捕获和分析之前是无法发现和未知的。这个分析过程涉及多个步骤，其中一个步骤是专注于恶意软件的网络通信模式的行为分析。在某些情况下，分析发生在法医恶意软件反向工程实验室中，但更多时候，它发生在野外，当安全分析师发现他们的网络中某个设备被感染时。
- en: In this section, we will look at a few examples of real malware and its behavior,
    as observed through packets.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将通过数据包观察几个真实的恶意软件及其行为示例。
- en: '***Operation Aurora***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***奥罗拉行动***'
- en: '*aurora.pcapng*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*aurora.pcapng*'
- en: In January 2010, Operation Aurora was discovered to have exploited an as of
    then unknown vulnerability in Internet Explorer. This vulnerability allowed attackers
    to gain remote control of targeted machines at Google, among other companies.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年1月，发现奥罗拉行动利用了 Internet Explorer 中一个当时尚未被发现的漏洞。这个漏洞使得攻击者能够远程控制 Google 等公司内部的目标机器。
- en: For this malicious code to be executed, a user simply needed to visit a website
    using a vulnerable version of Internet Explorer. The attackers then had immediate
    access to the user’s machine with the same privileges as the logged-in user. *Spear
    phishing*, in which attackers send an email message designed to get recipients
    to click a link leading to a malicious site, was used to lure the targets.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这些恶意代码，用户只需访问一个使用易受攻击版本的Internet Explorer的网页。攻击者随后便能够直接访问用户的机器，并且拥有与已登录用户相同的权限。*鱼叉式钓鱼*攻击通过向受害者发送设计用来诱使他们点击链接访问恶意网站的电子邮件来吸引目标。
- en: In the case of Aurora, we pick up this story as soon as the targeted user clicks
    the link in the spear-phishing email. The resulting packets are contained in the
    file *aurora.pcapng*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Aurora案例中，我们从目标用户点击鱼叉式钓鱼邮件中的链接开始跟踪此事件。生成的数据包包含在文件*aurora.pcapng*中。
- en: This capture begins with a three-way handshake between the target (192.168.100.206)
    and the attacker (192.168.100.202). The initial connection is to port 80, which
    would lead us to believe this is HTTP traffic. That assumption is confirmed in
    the fourth packet, which is an HTTP `GET` request for */info* ➊, as shown in [Figure
    12-16](ch12.xhtml#ch12fig16).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该捕获过程开始于目标（192.168.100.206）与攻击者（192.168.100.202）之间的三次握手。初始连接是通过80端口，这让我们认为这是HTTP流量。这个假设在第四个数据包中得到了证实，该数据包是一个针对*/info*的HTTP
    `GET`请求 ➊，如[图 12-16](ch12.xhtml#ch12fig16)所示。
- en: As shown in [Figure 12-17](ch12.xhtml#ch12fig17), the attacker’s machine acknowledges
    receipt of the `GET` request and reports a response code of 302 (Moved Temporarily)
    in packet 6 ➊, the status code commonly used to redirect a browser to another
    page, as is the case here. Along with the 302 response code, a Location field
    specifies the location */info?rFfWELUjLJHpP* ➋.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 12-17](ch12.xhtml#ch12fig17)所示，攻击者的机器确认收到了`GET`请求，并在数据包6 ➊中报告了302（暂时移动）响应代码，这是常用的重定向浏览器到另一个页面的状态码，正如本例所示。除了302响应代码外，Location字段指定了位置*/info?rFfWELUjLJHpP*
    ➋。
- en: '![image](../images/f276-01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f276-01.jpg)'
- en: '*Figure 12-16: The target makes a `GET` request for* /info.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-16：目标发起了对* /info的`GET`请求。'
- en: '![image](../images/f276-02.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f276-02.jpg)'
- en: '*Figure 12-17: The client browser is redirected with this packet.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-17：客户端浏览器通过此数据包被重定向。*'
- en: After receiving the HTTP 302 packet, the client initiates another `GET` request
    to the */info?rFfWELUjLJHpP* URL in packet 7, for which an ACK is received in
    packet 8\. Following the ACK, the next several packets represent data being transferred
    from the attacker to the target. To take a closer look at that data, right-click
    one of the packets in the stream, such as packet 9, and select **Follow** ▶ **TCP
    Stream**. In this stream output, we see the initial `GET` request, the 302 redirection,
    and the second `GET` request, as shown in [Figure 12-18](ch12.xhtml#ch12fig18).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 收到HTTP 302数据包后，客户端发起了对*/info?rFfWELUjLJHpP* URL的另一个`GET`请求，该请求在数据包7中出现，并且在数据包8中收到ACK。接着，下一些数据包代表着攻击者向目标传输的数据。要查看这些数据，右键点击流中的一个数据包，比如数据包9，然后选择**跟踪**
    ▶ **TCP 流**。在此流输出中，我们可以看到最初的`GET`请求、302重定向以及第二个`GET`请求，如[图 12-18](ch12.xhtml#ch12fig18)所示。
- en: After this, things start getting really strange. The attacker responds to the
    `GET` request with some very odd-looking content, the first section of which is
    shown in [Figure 12-19](ch12.xhtml#ch12fig19).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，事情开始变得非常奇怪。攻击者用一些看起来非常奇怪的内容响应了`GET`请求，其中的第一部分如[图 12-19](ch12.xhtml#ch12fig19)所示。
- en: '![image](../images/f277-01.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f277-01.jpg)'
- en: '*Figure 12-18: The data stream being transmitted to the client*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-18：数据流被传输到客户端*'
- en: '![image](../images/f277-02.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f277-02.jpg)'
- en: '*Figure 12-19: This scrambled content within a `<script>` tag appears to be
    encoded.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-19：`<script>`标签内的这段混淆内容似乎经过了编码处理。*'
- en: This content appears to be a series of random numbers and letters inside a `<script>`
    tag ➊. The `<script>` tag is used within HTML to denote the use of a higher-level
    client-side scripting language whose code is executed on the HTTP client. Within
    this tag, you normally see various scripting statements. But the gibberish here
    indicates that the content may be encoded to hide it from detection. Since we
    know this is exploit traffic, we can assume that this obfuscated section of text
    contains the hexadecimal padding and shellcode used to exploit the vulnerable
    service.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该内容看起来是一串随机的数字和字母，位于 `<script>` 标签内 ➊。`<script>` 标签用于 HTML 中，表示使用一种高级的客户端脚本语言，其代码在
    HTTP 客户端上执行。在这个标签内，通常可以看到各种脚本语句。但这里的乱码表示内容可能已经被编码，以隐藏其真实信息。由于我们知道这是攻击流量，可以推测这段被混淆的文本包含了用于利用易受攻击服务的十六进制填充和
    Shellcode。
- en: '**NOTE**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Script obfuscation is a common technique used by malware to evade detection
    and hide malicious content. While deobfuscating scripts is beyond the scope of
    this book, it’s a skill you’ll develop if you continue to examine malware communication.
    Many skilled malware analysts can recognize malicious scripts instantly with a
    quick visual inspection. If you want to challenge yourself, try to manually deobfuscate
    the script found in this example.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*脚本混淆是恶意软件常用的一种技术，用于规避检测并隐藏恶意内容。虽然本书不涉及脚本去混淆，但如果你继续研究恶意软件通信，这将是你会掌握的技能。许多经验丰富的恶意软件分析师可以通过快速的视觉检查立刻识别出恶意脚本。如果你想挑战自己，试着手动去混淆本例中找到的脚本。*'
- en: In the second portion of the content sent from the attacker, shown in [Figure
    12-20](ch12.xhtml#ch12fig20), we finally see some text that is readable. Even
    without extensive programming knowledge, we can see that this text appears to
    do some string parsing based on a few variables. This is the last bit of text
    before the closing `</script>` tag.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在攻击者发送的第二部分内容中，如 [图 12-20](ch12.xhtml#ch12fig20) 所示，我们最终看到了可以读取的文本。即使没有广泛的编程知识，我们也能看出，这段文本似乎基于一些变量进行字符串解析。这是
    `</script>` 标签关闭之前的最后一段文本。
- en: '![image](../images/f278-01.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f278-01.jpg)'
- en: '*Figure 12-20: This portion of the content sent from the server contains readable
    text and a suspicious iframe.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-20：这部分从服务器发送的内容包含可读文本和一个可疑的 iframe。*'
- en: The last section of data sent from attacker to client, also shown in [Figure
    12-20](ch12.xhtml#ch12fig20), has two parts. The first is the `<span id="vhQYFCtoDnOzUOuxAflDS
    zVMIHYhjJojAOCHNZtQdlxSPFUeEthCGdRtiIY">` section ➊. The second, contained within
    the `<span></span>` tags, is `<iframe src="/infowTVeeGDYJWNfsrdrvXiYApnuPoC MjRrSZuKtbVgwuZCXwxKjtEclbPuJPPctcflhsttMRrSyxl.gif"
    onload="WisgEgTNEfaONekE qaMyAUALLMYW(event)" />` ➋. Once again, this content
    may be a sign of malicious activity due to the suspiciously long and random strings
    of unreadable and potentially obfuscated text.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从攻击者发送到客户端的最后一部分数据，如 [图 12-20](ch12.xhtml#ch12fig20) 所示，分为两部分。第一部分是 `<span id="vhQYFCtoDnOzUOuxAflDS
    zVMIHYhjJojAOCHNZtQdlxSPFUeEthCGdRtiIY">` 部分 ➊。第二部分，包含在 `<span></span>` 标签内，是
    `<iframe src="/infowTVeeGDYJWNfsrdrvXiYApnuPoC MjRrSZuKtbVgwuZCXwxKjtEclbPuJPPctcflhsttMRrSyxl.gif"
    onload="WisgEgTNEfaONekE qaMyAUALLMYW(event)" />` ➋。再一次，这段内容可能是恶意活动的迹象，原因是其中有异常长且随机的无法读取、可能已混淆的文本。
- en: The portion of the code contained within the `<span>` tag is an *iframe*, which
    is a common method used by attackers to embed additional unexpected content into
    an HTML page. The `<iframe>` tag creates an inline frame that can go undetected
    by the user. In this case, the `<iframe>` tag references an oddly named GIF file.
    As shown in [Figure 12-21](ch12.xhtml#ch12fig21), when the target’s browser sees
    the reference to this file, it makes a `GET` request for it in packet 21 ➊, and
    the GIF is sent immediately following that ➋.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在 `<span>` 标签内的部分代码是一个 *iframe*，这是攻击者常用的一种方法，用来将额外的意外内容嵌入到 HTML 页面中。`<iframe>`
    标签创建了一个内联框架，用户通常无法察觉。在这种情况下，`<iframe>` 标签引用了一个命名奇怪的 GIF 文件。如 [图 12-21](ch12.xhtml#ch12fig21)
    所示，当目标的浏览器看到这个文件的引用时，它会在第 21 包中发出一个 `GET` 请求 ➊，然后 GIF 文件会紧接着被发送 ➋。
- en: '![image](../images/f279-01.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f279-01.jpg)'
- en: '*Figure 12-21: The GIF specified in the iframe is requested and downloaded
    by the target.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-21：iframe 中指定的 GIF 被目标请求并下载。*'
- en: The most peculiar part of this capture occurs at packet 25, when the target
    initiates a connection back to the attacker on port 4321\. Viewing this second
    stream of communication from the Packet Details pane doesn’t yield much information,
    so we will once again view the TCP stream to get a clearer picture of the data
    being communicated. [Figure 12-22](ch12.xhtml#ch12fig22) shows the Follow TCP
    Stream window output.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此捕获中最奇怪的部分发生在数据包 25，当时目标发起了一个回连接到攻击者的端口 4321。查看来自数据包详细信息窗格的这第二个通信流没有提供太多信息，因此我们将再次查看
    TCP 流，以便更清晰地了解正在传输的数据。 [图 12-22](ch12.xhtml#ch12fig22) 显示了跟踪 TCP 流的窗口输出。
- en: 'In this display, we see something that should set off immediate alarms: a Windows
    command shell ➊. This shell is sent from the target to the server, indicating
    that the attacker’s exploit attempt succeeded and the payload was dropped. The
    client transmitted a command shell back to the attacker once the exploit was launched.
    In this capture, we can even see the attacker interacting with the target by entering
    the `dir` command ➋ to view a directory listing on the target’s machine ➌.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在此显示中，我们看到一些应该立即引起警报的内容：一个 Windows 命令行 ➊。此命令行从目标发送到服务器，表明攻击者的漏洞利用尝试成功，并且有效负载已被投放。一旦漏洞被启动，客户端便将命令行传回给攻击者。在此捕获中，我们甚至能看到攻击者通过输入
    `dir` 命令 ➋ 来查看目标机器上的目录列表 ➌。
- en: Assuming the exploit has compromised a process running as an administrator or
    migrated into one, the attacker can do virtually anything they wish to the target’s
    machine. With just a single click, in a matter of seconds, the target has given
    complete control of their computer to an attacker.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设漏洞已经利用并感染了以管理员身份运行的进程，或者已迁移至其中，攻击者几乎可以对目标机器做任何他们想做的事情。仅需点击一下，在几秒钟内，目标就将其计算机的完全控制权交给了攻击者。
- en: Exploits like this are typically encoded to be unrecognizable when going across
    the wire to prevent them from being picked up by the network IDS. As such, without
    prior knowledge of this exploit or even a sample of the exploit code, it might
    be difficult to tell exactly what is happening on the target’s system without
    further analysis. Luckily, we were able to pick out some tell-tale signs of malicious
    code in this packet capture. This includes the obfuscated text in the `<script>`
    tags, the peculiar iframe, and the command shell seen in plaintext.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的漏洞利用通常会被编码以在传输过程中变得无法识别，以防止被网络 IDS 拦截。因此，在没有事先了解此漏洞或漏洞代码样本的情况下，可能很难确定目标系统上发生了什么，除非进行进一步的分析。幸运的是，我们能够从此数据包捕获中找出一些恶意代码的明显迹象。这包括
    `<script>` 标签中的混淆文本、奇怪的 iframe 以及以明文显示的命令行。
- en: '![image](../images/f280-01.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f280-01.jpg)'
- en: '*Figure 12-22: The attacker is interacting with a command shell through this
    connection.*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-22：攻击者通过此连接与命令行进行交互。*'
- en: 'Here is a summary of how the Aurora exploit worked here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Aurora 漏洞在这里如何工作的总结：
- en: •     The target receives an email from the attacker that appears to be legitimate,
    clicks a link within it, and sends a `GET` request to the attacker’s malicious
    site.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: •     目标接收到攻击者发送的看似合法的电子邮件，点击其中的链接，并向攻击者的恶意站点发送 `GET` 请求。
- en: •     The attacker’s web server issues a 302 redirection to the target, and
    the target’s browser automatically issues a `GET` request to the redirected URL.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: •     攻击者的 Web 服务器向目标发出 302 重定向，目标的浏览器自动向重定向的 URL 发出 `GET` 请求。
- en: •     The attacker’s web server transmits a web page containing obfuscated JavaScript
    code to the client that includes a vulnerability exploit and an iframe containing
    a link to a GIF image, which is requested.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: •     攻击者的 Web 服务器向客户端传输一个包含混淆 JavaScript 代码的网页，代码中包含一个漏洞利用程序和一个包含指向 GIF 图像的链接的
    iframe，后者被请求。
- en: •     The JavaScript code transmitted earlier is deobfuscated when the page
    is rendered in the target’s browser, and the code executes on their machine, exploiting
    a vulnerability in Internet Explorer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: •     之前传输的 JavaScript 代码在目标的浏览器中渲染页面时被去混淆，并在他们的机器上执行，利用了 Internet Explorer
    中的漏洞。
- en: •     Once the vulnerability is exploited, the payload hidden within the obfuscated
    code is executed, opening a new session from the target to the attacker on port
    4321.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: •     一旦漏洞被利用，隐藏在混淆代码中的有效负载将被执行，打开一个新的会话，从目标连接到攻击者的端口 4321。
- en: •     A command shell is spawned from the payload and shoveled back to the attacker,
    so that they may interact with it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: •     从有效负载中生成命令行并返回给攻击者，以便他们与其交互。
- en: From a defender’s point of view, we can use this capture file to create a signature
    for our IDS that might help detect further occurrences of this attack. For example,
    we might filter on a nonobfuscated part of the capture, such as the plaintext
    code at the end of the obfuscated text in the `<script>` tag. Another idea might
    be to write a signature for all HTTP traffic with a 302 redirection to a site
    with *info* in the URL. This signature would need some additional tuning to be
    viable in a production environment, but it’s a good start. Of course, it’s also
    important to remember that signatures can be defeated. If the attacker simply
    changes a few of the strings we’ve observed here or delivers the exploit through
    another mechanism, our signatures could be rendered useless. Thus is waged the
    eternal struggle between attackers and defenders.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从防御者的角度来看，我们可以使用这个捕获文件为我们的IDS（入侵检测系统）创建一个签名，帮助检测未来可能发生的类似攻击。例如，我们可以过滤捕获文件中的一个未加密部分，比如`<script>`标签中加密文本结尾的明文代码。另一个思路是为所有带有302重定向到URL中含有*info*的站点的HTTP流量编写签名。这个签名需要进行一些额外的调整才能在生产环境中可行，但它是一个不错的开始。当然，值得记住的是，签名是可以被绕过的。如果攻击者只是更改了我们观察到的几个字符串，或者通过其他机制发送了这个漏洞，我们的签名可能会失效。因此，攻击者和防御者之间的永恒斗争依然在继续。
- en: '**NOTE**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The ability to create traffic signatures based on malicious traffic samples
    is a crucial step for someone attempting to defend a network against unknown threats.
    Analyzing captures such as the one described here are a great way to develop skills
    in writing those signatures. To learn more about intrusion detection and attack
    signatures, visit the Snort project at* [http://www.snort.org/](http://www.snort.org/).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于恶意流量样本创建流量签名是防御网络未知威胁的关键步骤。分析像这里描述的捕获文件是学习如何编写这些签名的好方法。要了解更多关于入侵检测和攻击签名的信息，请访问Snort项目：*
    [http://www.snort.org/](http://www.snort.org/).'
- en: '***Remote-Access Trojan***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***远程访问木马***'
- en: '*ratinfected.pcapng*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*ratinfected.pcapng*'
- en: So far, we’ve examined security events with some prior knowledge of what is
    going on. This is a great way to learn what attacks look like, but it’s not very
    real world. In most real-world scenarios, people tasked with defending a network
    won’t examine every packet that goes across the network. Instead, they will use
    some form of IDS to alert them to anomalies in network traffic that warrant further
    examination based on a predefined attack signature.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在一定了解攻击背景的情况下分析了安全事件。这是学习攻击样式的好方法，但它并不完全贴近现实。在大多数实际的网络防御场景中，负责防守网络的人不会检查网络上每一个传输的数据包。相反，他们会使用某种形式的IDS来提醒他们网络流量中的异常情况，依据的是预定义的攻击签名。
- en: 'In the next example, we’ll begin with a simple alert, as if we’re the real-world
    analyst. In this case, our IDS generates this alert:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将从一个简单的警报开始，假设我们是现实世界中的分析师。在这种情况下，我们的IDS触发了以下警报：
- en: '[PRE0]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our next step is to view the signature rule that triggered this alert:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是查看触发此警报的签名规则：
- en: '[PRE1]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This rule is set to alert whenever it sees a packet from any network entering
    the internal network with the hexadecimal content `41 4E 41 42 49 4C 47 49 7C`,
    which converts to *ANA BILGI* in human-readable ASCII. When it is detected, an
    alert fires, signifying the possible presence of the CyberEYE *remote-access trojan
    (RAT)*. RATs are malicious programs that run silently on a target’s computer and
    provide a means for the attacker to remotely access the target’s machine.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则设置为当它检测到任何来自外部网络进入内部网络的数据包，其中包含十六进制内容`41 4E 41 42 49 4C 47 49 7C`时触发警报，这些内容转换为人类可读的ASCII字符*ANA
    BILGI*。当检测到时，警报触发，表示可能存在CyberEYE *远程访问木马（RAT）*。RAT是一种在目标计算机上悄悄运行的恶意程序，为攻击者提供远程访问目标计算机的手段。
- en: '**NOTE**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*CyberEYE is a once popular Turkish-born tool used to create RAT executables
    and administer compromised hosts. Ironically, the Snort rule seen here fires on
    the string ANA BILGI, which is Turkish for BASIC INFORMATION.*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*CyberEYE是曾经流行的土耳其工具，用于创建RAT可执行文件并管理被攻陷的主机。具有讽刺意味的是，Snort规则在这里触发的是字符串ANA BILGI，这个词在土耳其语中表示“基本信息”。*'
- en: 'Now we’ll look at some traffic associated with the alert in *ratinfected.pcapng*.
    This Snort alert would typically capture only the single packet that triggered
    the alert, but fortunately we have the entire communication sequence between the
    hosts. To skip to the punch line, search for the hexadecimal string mentioned
    in the Snort rule, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下与*ratinfected.pcapng*中的警报相关的流量。这个Snort警报通常只会捕获触发警报的单个数据包，但幸运的是，我们拥有两台主机之间的整个通信序列。为了跳到重点，按照以下方式搜索Snort规则中提到的十六进制字符串：
- en: Select **Edit** ▶ **Find Packet** or press CTRL-F.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Edit** ▶ **Find Packet**，或按CTRL-F。
- en: Select the **Hex Value** option from the drop-down menu.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**Hex Value**选项。
- en: Enter the value 41 4E 41 42 49 4C 47 49 7C into the text area.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本区域中输入值41 4E 41 42 49 4C 47 49 7C。
- en: Click **Find**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Find**。
- en: As shown in [Figure 12-23](ch12.xhtml#ch12fig23), you should now see the first
    occurrence of the hexadecimal string in the data portion of packet 4 ➊.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图12-23](ch12.xhtml#ch12fig23)所示，你现在应该能看到数据部分中包4 ➊中首次出现的十六进制字符串。
- en: '![image](../images/f282-01.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f282-01.jpg)'
- en: '*Figure 12-23: The content string in the Snort alert is first seen here in
    packet 4.*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-23：在数据包4中首次看到Snort警报中的内容字符串。*'
- en: If you select **Find** several more times, you will see that this string also
    occurs in packets 5, 10, 32, 156, 280, 405, 531, and 652\. Although all of the
    communication in this capture file is between the attacker (172.16.0.111) and
    target (172.16.0.114), it appears as though some instances of the string occur
    in different conversations. While packets 4 and 5 are communicating using ports
    4433 and 6641, most of the other instances occur between port 4433 and other randomly
    selected ephemeral ports. We can confirm that multiple conversations exist by
    looking at the TCP tab of the Conversations window, as shown in [Figure 12-24](ch12.xhtml#ch12fig24).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择多次点击**Find**，你会发现这个字符串也出现在包5、10、32、156、280、405、531和652中。尽管这个捕获文件中的所有通信都是在攻击者（172.16.0.111）和目标（172.16.0.114）之间进行的，但似乎有些字符串实例出现在不同的对话中。虽然包4和包5使用端口4433和6641进行通信，但其他大多数实例发生在端口4433和其他随机选择的临时端口之间。我们可以通过查看对话窗口的TCP选项卡来确认存在多个对话，如[图12-24](ch12.xhtml#ch12fig24)所示。
- en: 'We can visually separate the different conversations in this capture file by
    colorizing them, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为不同的对话着色来在这个捕获文件中直观地区分它们，如下所示：
- en: In the filter dialog above the Packet List pane, type the filter (tcp.flags.syn
    == 1) && (tcp.flags.ack == 0). Then press ENTER. This will select the initial
    SYN packet for each conversation in the traffic.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包列表窗格上方的过滤器对话框中，输入过滤器(tcp.flags.syn == 1) && (tcp.flags.ack == 0)。然后按ENTER。这将选中流量中每个对话的初始SYN包。
- en: Right-click the first packet and select **Colorize Conversation**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击第一个包并选择**Colorize Conversation**。
- en: Select **TCP** and then select a color.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**TCP**，然后选择一个颜色。
- en: Repeat this process for the remaining SYN packets, choosing a different color
    for each.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对剩余的SYN包重复此过程，为每个包选择不同的颜色。
- en: When finished, click **X** to remove the filter.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击**X**以移除过滤器。
- en: '![image](../images/f283-01.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f283-01.jpg)'
- en: '*Figure 12-24: Three individual conversations exist between the attacker and
    target.*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-24：攻击者和目标之间存在三个独立的对话。*'
- en: Having colorized the conversations, we can clear the filter to see how they
    relate to each other, helping us to track the communication process between the
    two hosts. The first conversation (ports 6641/4433) is where the communication
    between the two hosts begins, so it’s a good place to start. Right-click any packet
    within the conversation and select **Follow TCP Stream** to see the data that
    was transferred, as shown in [Figure 12-25](ch12.xhtml#ch12fig25).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为对话着色后，我们可以清除过滤器，查看它们之间的关系，帮助我们跟踪两台主机之间的通信过程。第一个对话（端口6641/4433）是两台主机开始通信的地方，因此是一个很好的起点。右键点击对话中的任何数据包，选择**Follow
    TCP Stream**查看传输的数据，如[图12-25](ch12.xhtml#ch12fig25)所示。
- en: '![image](../images/f283-02.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f283-02.jpg)'
- en: '*Figure 12-25: The first conversation yields interesting results.*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-25：第一个对话产生了有趣的结果。*'
- en: Immediately, we see that the text string `ANABILGI|556` is sent from the attacker
    to the target ➊. As a result, the target responds with some basic system information,
    including the computer name (`CSANDERS-6F7F77`) and the operating system in use
    (`Windows XP Service Pack 3`) ➋, and begins repeatedly transmitting the string
    `BAGLIMI?` back to the attacker ➌. The only communication back from the attacker
    is the string `CAPSCREEN60` ➍, which appears six times.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 随即，我们看到攻击者向目标发送了文本字符串 `ANABILGI|556` ➊。因此，目标响应了一些基本的系统信息，包括计算机名称（`CSANDERS-6F7F77`）和正在使用的操作系统（`Windows
    XP Service Pack 3`） ➋，并开始反复将字符串 `BAGLIMI?` 发送回攻击者 ➌。攻击者唯一的回馈是字符串 `CAPSCREEN60`
    ➍，该字符串出现了六次。
- en: This `CAPSCREEN60` string returned by the attacker is interesting, so let’s
    see where it leads. To do so, make sure you’ve cleared any display filters and
    search for the text string `CAPSCREEN60` within the packets using the search dialog,
    specifying the **String** option and ensuring the **Packet bytes** option is selected
    for where to perform the search.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者返回的这个`CAPSCREEN60`字符串很有趣，接下来我们看看它指向哪里。为此，请确保你已经清除了任何显示过滤器，并使用搜索对话框在数据包中搜索文本字符串`CAPSCREEN60`，选择
    **字符串** 选项并确保已选择 **数据包字节** 选项来执行搜索。
- en: Upon performing this search, we find the first instance of the string in packet
    27\. The intriguing thing about this bit of information is that as soon as the
    string is sent from the attacker to the client, the client acknowledges receipt
    of the packet, and a new conversation is started in packet 29\. You should be
    able to more easily notice the new conversation starting because of the coloring
    rules that were applied earlier.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此搜索后，我们在第 27 个数据包中找到了第一个 `CAPSCREEN60` 字符串。这个信息的有趣之处在于，当字符串从攻击者发送到客户端时，客户端确认接收到数据包，并在第
    29 个数据包中启动了一个新会话。你应该能更容易地注意到新会话的开始，因为之前应用的着色规则会帮助你辨认。
- en: Now, if we follow the TCP stream output of this new conversation (shown in [Figure
    12-26](ch12.xhtml#ch12fig26)), we see the familiar string `ANABILGI|12`, followed
    by the string `SH|556` and, finally, the string `CAPSCREEN|C:\WINDOWS\jpgevhook.dat|84972`
    ➊. Notice the file path specified after the `CAPSCREEN` string, which is followed
    by unreadable text. The most intriguing thing here is that the unreadable text
    is prepended by the string `JFIF` ➋, which a quick Google search will tell you
    is commonly found at the beginning of JPG files.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们跟踪这个新会话的 TCP 流输出（如[图 12-26](ch12.xhtml#ch12fig26)所示），我们看到熟悉的字符串`ANABILGI|12`，接着是`SH|556`，最后是`CAPSCREEN|C:\WINDOWS\jpgevhook.dat|84972`
    ➊。注意 `CAPSCREEN` 字符串后面指定的文件路径，后面跟着一些无法读取的文本。最引人注目的是，这段无法读取的文本前面有一个字符串 `JFIF` ➋，快速
    Google 搜索会告诉你，它通常出现在 JPG 文件的开头。
- en: '![image](../images/f284-01.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f284-01.jpg)'
- en: '*Figure 12-26: The attacker appears to be initiating a request for a JPG file.*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-26：攻击者似乎正在发起请求以获取 JPG 文件。*'
- en: 'At this point, it’s safe to conclude that the attacker initiated the request
    to transfer this JPG image. But even more importantly, we are beginning to see
    a command structure evolve from the traffic. It appears that `CAPSCREEN` is a
    command sent by the attacker to initiate the transfer of this JPG. In fact, whenever
    the `CAPSCREEN` command is sent, the result is the same. To verify this, view
    the TCP stream of each conversation where the `CAPSCREEN` command is present or
    try using Wireshark’s IO graphing feature as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们可以安全地得出结论，攻击者发起了请求以传输这张 JPG 图片。但更重要的是，我们开始看到流量中出现了命令结构。似乎 `CAPSCREEN`
    是攻击者用来启动 JPG 文件传输的命令。事实上，每当发送 `CAPSCREEN` 命令时，结果都是相同的。为了验证这一点，可以查看每个包含 `CAPSCREEN`
    命令的会话的 TCP 流，或者尝试使用 Wireshark 的 IO 图形功能，如下所示：
- en: Select **Statistics** ▶ **IO Graph**.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **统计信息** ▶ **IO 图形**。
- en: Click the plus (+) button to add five lines.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击加号（+）按钮以添加五行。
- en: Insert the filters tcp.stream eq 2, tcp.stream eq 3, tcp.stream eq 4, tcp.stream
    eq 5, and tcp.stream eq 6, respectively, into the Display Filter of the five newly
    added lines. Give each one a name as well.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别将过滤器 tcp.stream eq 2、tcp.stream eq 3、tcp.stream eq 4、tcp.stream eq 5 和 tcp.stream
    eq 6 插入到显示过滤器中，并为每个过滤器命名。
- en: Change the y-axis scale for each entry to **Bytes/s**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个条目的 y 轴刻度更改为 **字节/秒**。
- en: Click the **Graph 1**, **Graph 2**, **Graph 3**, **Graph 4**, and **Graph 5**
    buttons to enable the data points for the filters specified.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **图表 1**、**图表 2**、**图表 3**、**图表 4** 和 **图表 5** 按钮以启用为指定过滤器显示的数据点。
- en: '[Figure 12-27](ch12.xhtml#ch12fig27) shows the resulting graph.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-27](ch12.xhtml#ch12fig27) 显示了结果图。'
- en: '![image](../images/f285-01.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f285-01.jpg)'
- en: '*Figure 12-27: This graph shows that similar activity appears to repeat.*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-27：此图表显示了类似的活动似乎在重复出现。*'
- en: Based on this graph, it appears as though each conversation contains roughly
    the same amount of data and occurs for the same amount of time. We can now conclude
    that this activity repeats several times.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这张图表，看起来每个会话大致包含相同数量的数据，并且持续时间相同。我们现在可以得出结论，这一活动多次重复。
- en: 'You may already have some ideas regarding the content of the JPG image being
    transferred, so let’s see if we can view one of these files. To extract the JPG
    data from Wireshark, perform the following steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经对传输中的JPG图像的内容有一些想法，那么让我们看看能否查看其中一个文件。要从Wireshark提取JPG数据，执行以下步骤：
- en: First, follow the TCP stream of the appropriate packets as we did with [Figure
    12-25](ch12.xhtml#ch12fig25). Packet 29 is a good choice.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，像我们在[图 12-25](ch12.xhtml#ch12fig25)中做的那样，跟踪适当数据包的TCP流。数据包29是一个不错的选择。
- en: The communication must be isolated so that we see only the stream of data sent
    from the target to the attacker. Do this by selecting the arrow next to the drop-down
    that says Entire Conversation (85033 bytes). Be sure to select the appropriate
    directional traffic, which is 172.16.0.114:6643 --> 172.16.0.111:4433 (85 kB).
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须将通信隔离，以便我们只看到从目标发送到攻击者的数据流。通过选择下拉菜单旁边的箭头（标记为“整个会话 (85033 字节)”）来执行此操作。确保选择正确的方向流量，即172.16.0.114:6643
    --> 172.16.0.111:4433（85 KB）。
- en: In the **Show data as** drop-down, choose **RAW**.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**显示数据为**下拉菜单中，选择**RAW**。
- en: Save the data by clicking the **Save As** button, ensuring that you save the
    file with a *.jpg* file extension.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**另存为**按钮保存数据，确保以*.jpg*文件扩展名保存文件。
- en: If you try to open the image now, you may be surprised to find that it won’t
    open. That’s because we have one more step to perform. Unlike the scenario in
    [Chapter 10](ch10.xhtml#ch10) where we extracted a file cleanly from FTP traffic,
    the traffic here added some additional content to the data. In this case, the
    first two lines seen in the TCP stream are actually part of the malware’s command
    sequence, not part of the data that makes up the JPG (see [Figure 12-28](ch12.xhtml#ch12fig28)).
    When we saved the stream, this extraneous data was also saved. As a result, the
    file viewer that is looking for a JPG file header is seeing content that doesn’t
    match what it is expecting, and therefore it can’t open the image.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在尝试打开图像，你可能会惊讶地发现它无法打开。这是因为我们还需要执行最后一步。与在[第10章](ch10.xhtml#ch10)中从FTP流量中干净提取文件的情况不同，这里的流量向数据中添加了一些额外的内容。在这种情况下，TCP流中的前两行实际上是恶意软件的命令序列的一部分，而不是构成JPG的实际数据（参见[图
    12-28](ch12.xhtml#ch12fig28)）。当我们保存流时，这些多余的数据也被保存了。因此，文件查看器在寻找JPG文件头时看到的内容与它期望的内容不匹配，因此无法打开图像。
- en: '![image](../images/f286-01.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f286-01.jpg)'
- en: '*Figure 12-28: The extraneous data added by the malware prevents the file from
    being opened correctly.*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-28：恶意软件添加的多余数据阻止文件正确打开。*'
- en: 'Fixing this issue is a painless process, requiring a bit of manipulation with
    a hex editor. This process is called *file carving*. To carve this file from the
    exported data, complete the following process:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题是一个简单的过程，只需使用十六进制编辑器稍微操作一下。这一过程称为*文件雕刻*。要从导出的数据中雕刻出这个文件，请完成以下过程：
- en: While viewing the TCP Stream in [Figure 12-28](ch12.xhtml#ch12fig28), click
    the **Save as** button. Choose a memorable filename and save the file to a location
    where you can access it again shortly.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查看[图 12-28](ch12.xhtml#ch12fig28)中的TCP流时，点击**另存为**按钮。选择一个容易记住的文件名，并将文件保存到一个你稍后可以再次访问的位置。
- en: Download and then install WinHex from *[https://www.x-ways.net/winhex/](https://www.x-ways.net/winhex/)*.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*[https://www.x-ways.net/winhex/](https://www.x-ways.net/winhex/)*下载并安装WinHex。
- en: Execute WinHex and open the file you just saved from Wireshark.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行WinHex并打开刚刚从Wireshark保存的文件。
- en: Use your mouse to select all the extraneous data at the beginning of the file.
    This should be everything occurring before, but not including, the bytes `FF D8
    FF E0`, which signify the start of a new JPG file. The bytes to select are highlighted
    in [Figure 12-29](ch12.xhtml#ch12fig29).
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鼠标选择文件开头的所有多余数据。这应该包括所有在`FF D8 FF E0`字节之前的内容，这些字节表示新JPG文件的开始。要选择的字节在[图 12-29](ch12.xhtml#ch12fig29)中已突出显示。
- en: '![image](../images/f287-01.jpg)'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f287-01.jpg)'
- en: '*Figure 12-29: Removing the extraneous bytes from the JPG file*'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 12-29：从JPG文件中移除多余的字节*'
- en: Press the **Delete** key to remove the selected data.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**删除**键以删除选定的数据。
- en: Click the **Save** button in WinHex’s main toolbar to save your changes.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 WinHex 主工具栏中的**保存**按钮以保存您的更改。
- en: '**NOTE**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I like WinHex for performing this task on Windows, but any hex editor you’re
    familiar with will do.*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*我喜欢在 Windows 上使用 WinHex 来执行这项任务，但任何您熟悉的十六进制编辑器都可以。*'
- en: With the unneeded bytes of data removed, you should now be able to open the
    file. It should be clear that the trojan is taking screen captures of the target’s
    desktop and transmitting them back to the attacker ([Figure 12-30](ch12.xhtml#ch12fig30)).
    After these communication sequences have completed, the communication ends with
    a normal TCP teardown sequence.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 去除不需要的数据字节后，您现在应该能够打开文件。应该清楚地看到木马正在捕获目标桌面的屏幕截图并将其传回攻击者（[图 12-30](ch12.xhtml#ch12fig30)）。在这些通信序列完成后，通信通过正常的
    TCP 断开序列结束。
- en: 'This scenario is a prime example of the thought process an intrusion analyst
    would follow when analyzing traffic based on an IDS alert:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景是入侵分析员在分析基于 IDS 警报的流量时所遵循的思维过程的典型例子：
- en: •     Examine the alert and the signature that generated it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: •     检查警报以及生成它的签名。
- en: •     Confirm whether the signature match was in the traffic in the proper context.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: •     确认签名匹配是否在正确的上下文中出现。
- en: •     Examine traffic to find out what the attacker did with the compromised
    machine.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: •     检查流量以了解攻击者在受感染机器上做了什么。
- en: •     Begin containment of the issue before any more sensitive information leaks
    from the compromised target.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: •     在更多敏感信息从受感染目标泄露之前，开始对问题进行遏制。
- en: '![image](../images/f288-01.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f288-01.jpg)'
- en: '*Figure 12-30: The JPG being transferred is a screen capture of the target’s
    computer.*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-30：传输的 JPG 是目标计算机的屏幕截图。*'
- en: '**Exploit Kit and Ransomware**'
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**漏洞利用工具包和勒索软件**'
- en: '*cryptowall4_c2.pcapng, ek_to_cryptowall4.pcapng*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*cryptowall4_c2.pcapng，ek_to_cryptowall4.pcapng*'
- en: In our final scenario, we’ll look at another investigation that begins with
    an alert from an IDS. We’ll explore the live packets being generated from the
    infected system and then attempt to trace the source of the compromise. This example
    will utilize real malware that you would be likely to find infecting a device
    in your network.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一个场景中，我们将查看另一个始于 IDS 警报的调查。我们将探索从感染系统生成的实时数据包，然后尝试追踪入侵的源头。这个例子将利用真实的恶意软件，您可能会在您的网络中发现它感染了设备。
- en: The story beings with an IDS alert generated from Snort in the Sguil console,
    shown in [Figure 12-31](ch12.xhtml#ch12fig31). Sguil is a tool used to manage,
    view, and investigate IDS alerts from one or more sensors. It doesn’t provide
    the most attractive user interface, but it’s been around for a while and is a
    very popular tool for security analysts.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 故事始于 Sguil 控制台中由 Snort 生成的 IDS 警报，如[图 12-31](ch12.xhtml#ch12fig31)所示。Sguil 是一个用于管理、查看和调查来自一个或多个传感器的
    IDS 警报的工具。它的用户界面并不最为吸引人，但它已经存在一段时间，并且是安全分析员非常流行的工具。
- en: There is a lot of information about this alert available in Sguil. The upper
    window ➊ shows a summary of the alert. Here you see the time the alert was generated,
    the source and destination IP addresses and ports, the protocol, and the event
    message generated from the matching IDS signature. In this case, 192.168.122.145,
    the local friendly system, is communicating with an unknown external system at
    184.170.149.44 over port 80, which is commonly associated with HTTP traffic. The
    external system is assumed to be hostile since it has shown up in relation to
    a signature indicating malicious communication and very little is known about
    it. The signature that matched this traffic is representative of check-in traffic
    from the CryptoWall malware family, suggesting that a strain of this malware is
    installed on the friendly system.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sguil 中有大量关于此警报的信息可供查看。上方窗口 ➊ 显示了警报的摘要。在这里，您可以看到警报生成的时间、源和目标 IP 地址及端口、协议以及匹配的
    IDS 签名生成的事件信息。在此案例中，192.168.122.145 是本地友好系统，它通过端口 80 与外部未知系统 184.170.149.44 进行通信，而端口
    80 通常与 HTTP 流量相关。由于该系统在与指示恶意通信的签名相关时出现，因此假设外部系统是恶意的，并且对它知之甚少。匹配此流量的签名代表了 CryptoWall
    恶意软件家族的注册流量，表明该恶意软件的某个变种已经安装在友好系统上。
- en: '![image](../images/f289-01.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f289-01.jpg)'
- en: '*Figure 12-31: This IDS alert indicates a CryptoWall 4 infection.*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-31：此 IDS 警报表明存在 CryptoWall 4 感染。*'
- en: The Sguil console provides the syntax of the matching rule ➋ and the individual
    packet data that matched the rule ➌. Notice that the packet information is broken
    down into protocol header and data sections, similar to how packet information
    is presented in Wireshark. Unfortunately, Sguil only provides information about
    a single packet that matched, and we need to dig deeper. The next step is to examine
    the traffic associated with this alert in Wireshark to attempt to validate the
    traffic and see what’s going on. That traffic is contained in the file *cryptowall4_c2.pcapng*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Sguil控制台提供了匹配规则的语法 ➋ 和匹配该规则的单个数据包数据 ➌。请注意，数据包信息被分解为协议头和数据部分，类似于Wireshark中展示数据包信息的方式。不幸的是，Sguil只提供匹配的单个数据包信息，我们需要深入挖掘。下一步是使用Wireshark检查与此警报相关的流量，尝试验证流量并查看发生了什么。该流量包含在文件*cryptowall4_c2.pcapng*中。
- en: This packet capture contains the communication that was happening around the
    time of the alert, and it isn’t overly complex. The first conversation occurs
    in packets 1 through 16, and we can view it easily by following the TCP stream
    of that conversation ([Figure 12-32](ch12.xhtml#ch12fig32)). At the start of the
    capture, the local system opens a TCP connection to the hostile host on port 80
    and makes a `POST` request to the URL *[http://homealldaylong.com/76N1Lm.php?x4tk7t4jo6](http://homealldaylong.com/76N1Lm.php?x4tk7t4jo6)*
    ➊ containing a small amount of alphanumeric data ➋. The hostile host responds
    with an alphanumeric string ➍ and an `HTTP 200 OK` response code ➌ before the
    connection is terminated gracefully.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据包捕获包含了在警报发生时进行的通信，并且并不复杂。第一次通信发生在数据包1至16之间，我们可以通过跟踪该通信的TCP流轻松查看它（[图12-32](ch12.xhtml#ch12fig32)）。在捕获开始时，本地系统打开一个TCP连接到敌对主机的80端口，并向URL
    *[http://homealldaylong.com/76N1Lm.php?x4tk7t4jo6](http://homealldaylong.com/76N1Lm.php?x4tk7t4jo6)*
    ➊ 发出一个`POST`请求，内容包含少量的字母数字数据 ➋。敌对主机以一个字母数字字符串 ➍ 和一个`HTTP 200 OK`响应代码 ➌ 回应，随后连接被正常终止。
- en: '![image](../images/f290-01.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f290-01.jpg)'
- en: '*Figure 12-32: A small amount of data is being transferred between these hosts
    via HTTP.*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-32：这些主机之间通过HTTP传输少量数据。*'
- en: If you look through the rest of the capture file, you’ll see that the same sequence
    repeats between these hosts, with varying amounts of data being transferred each
    time. Use the filter http.request.method == "POST" to see three different connections
    with a similar URL structure ([Figure 12-33](ch12.xhtml#ch12fig33)).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看捕获文件的其余部分，你会看到在这些主机之间相同的序列重复出现，每次传输的数据量不同。使用过滤器`http.request.method ==
    "POST"`可以查看三个具有相似URL结构的不同连接（[图12-33](ch12.xhtml#ch12fig33)）。
- en: '![image](../images/f290-02.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f290-02.jpg)'
- en: '*Figure 12-33: The URL structure shows different data being passed to the same
    page.*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-33：URL结构显示不同的数据传递到相同的页面。*'
- en: 'The *76N1Lm.php* portion (the web page) remains the same, but the rest of the
    content (the parameter and data being passed to the page) varies. The repeating
    communication sequence combined with the structure of the requests is consistent
    with command and control (C2) behavior for malware and the signature that generated
    the alert. It’s therefore likely that the local system is infected with CryptoWall,
    as the signature suggests. You can further verify this by examining a similar
    sample on the popular CryptoWall Tracker research page: *[https://www.cryptowalltracker.org/cryptowall-4.html#networktraffic](https://www.cryptowalltracker.org/cryptowall-4.html#networktraffic)*.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*76N1Lm.php*部分（网页）保持不变，但其余内容（传递给页面的参数和数据）则有所不同。重复的通信序列以及请求的结构与恶意软件的命令与控制（C2）行为一致，并且与生成警报的特征匹配。因此，本地系统很可能感染了CryptoWall，就像特征所暗示的那样。你可以通过检查流行的CryptoWall
    Tracker研究页面上的类似样本进一步验证这一点：* [https://www.cryptowalltracker.org/cryptowall-4.html#networktraffic](https://www.cryptowalltracker.org/cryptowall-4.html#networktraffic)。'
- en: '**NOTE**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Deciphering the data being communicated between the friendly and hostile system
    during the C2 sequence would be a little complex for this book. But if you’re
    interested, you can read more about that process here:* [https://www.cryptowalltracker.org/communication-protocol.html](https://www.cryptowalltracker.org/communication-protocol.html).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*解密友好系统与敌对系统在C2序列中通信的数据对于本书来说可能有些复杂。但如果你感兴趣，可以在这里阅读更多相关内容：* [https://www.cryptowalltracker.org/communication-protocol.html](https://www.cryptowalltracker.org/communication-protocol.html)。'
- en: Now that you’ve verified that malware-based C2 communication is taking place,
    it’s a good idea to remediate the issue and address the infected machine. This
    is especially important when malware such as CryptoLocker is involved, because
    it attempts to encrypt the user’s data and provides the decryption key only if
    that user pays a hefty ransom—thus, the term *ransom-ware* for such malware. The
    steps to remediate the problem are beyond the scope of this book, but in a real-world
    scenario, those would be the security analyst’s next actions.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经确认了基于恶意软件的C2通信正在发生，接下来最好处理这个问题并修复受感染的机器。特别是当涉及到像CryptoLocker这样的恶意软件时，这一点尤为重要，因为它试图加密用户的数据，并且只有在用户支付了高额赎金后才会提供解密密钥——因此，类似的恶意软件被称为*勒索软件*。修复问题的步骤超出了本书的范围，但在实际的场景中，这些将是安全分析师接下来的行动。
- en: A common follow-up question is how the friendly machine got infected in the
    first place. If this can be determined, you might find other devices that have
    been infected with other malware in a similar way, or you may be able to develop
    protection or detection mechanisms to prevent future infection.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的后续问题是，友好的机器是如何最初感染的。如果能够确定这一点，你可能会发现其他设备也以类似的方式感染了其他恶意软件，或者你可能能够开发保护或检测机制以防止未来的感染。
- en: The alert packets only showed the active C2 sequence after the infection. In
    networks performing security monitoring and continuous packet capture, many network
    sensors are configured to store packet data for a few extra hours or days for
    forensic investigations. After all, not every organization is equipped to respond
    to alerts the second they happen. Temporary storage of packets allows us to look
    at the packet data from the friendly host just before it started the C2 sequence
    we saw earlier. Those packets are included in the file *ek_to_cryptowall4.pcapng*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 警报数据包仅在感染后显示了活跃的C2序列。在执行安全监控和持续数据包捕获的网络中，许多网络传感器被配置为存储数据包数据几个小时或几天，以便进行取证调查。毕竟，并不是每个组织都能够在警报发生的瞬间做出响应。临时存储数据包使我们能够查看友好主机在启动之前看到的C2序列的数据包。这些数据包包含在文件*ek_to_cryptowall4.pcapng*中。
- en: A cursory scroll through this packet capture tells us we have a lot more packets
    to look through, but they are all HTTP. Since we know how HTTP works already,
    let’s cut to the chase and limit the visible packets to only the requests by using
    the display filter `http.request`. This shows 11 HTTP requests originating from
    the friendly host ([Figure 12-34](ch12.xhtml#ch12fig34)).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览该数据包捕获文件的初步查看告诉我们，还有很多包需要查看，但它们都是HTTP请求。既然我们已经知道HTTP的工作原理，那么让我们直奔主题，使用显示过滤器`http.request`仅显示请求数据包。这将显示来自友好主机的11个HTTP请求（[图12-34](ch12.xhtml#ch12fig34)）。
- en: '![image](../images/f291-01.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f291-01.jpg)'
- en: '*Figure 12-34: There are 11 HTTP requests from the friendly host.*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-34：来自友好主机的11个HTTP请求*'
- en: The first request is from the friendly host 192.168.122.145 to an unknown external
    host 113.20.11.49\. An examination of the HTTP portion of this packet ([Figure
    12-35](ch12.xhtml#ch12fig35)) tells us that the user requested the page *[http://www.sydneygroup.com.au/index.php/services/](http://www.sydneygroup.com.au/index.php/services/)*
    ➊ and was referred from a Bing search for *[sydneygroup.com.au](http://sydneygroup.com.au)*
    ➋. So far, this looks normal.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个请求来自友好的主机192.168.122.145，目标是一个未知的外部主机113.20.11.49。通过检查该数据包的HTTP部分（[图12-35](ch12.xhtml#ch12fig35)），我们得知用户请求了页面*[http://www.sydneygroup.com.au/index.php/services/](http://www.sydneygroup.com.au/index.php/services/)*
    ➊，并且是从Bing搜索* [sydneygroup.com.au](http://sydneygroup.com.au) * ➋跳转过来的。到目前为止，这看起来是正常的。
- en: Next, the friendly host makes four requests to another unknown external host
    at 45.32.238.202 in packets 35, 39, 123, and 130\. As you’ve seen in earlier examples,
    it’s common for a browser to retrieve content from additional hosts when viewing
    a web page that stores embedded content or advertisements on third-party servers.
    This by itself is not worrisome, although the domain in these requests looks somewhat
    random and suspicious.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，友好的主机向另一个未知的外部主机45.32.238.202发出了四个请求，分别位于数据包35、39、123和130中。正如你在之前的示例中看到的，浏览器在查看存储了嵌入内容或广告的网页时，通常会从其他主机检索内容。这本身并不令人担忧，尽管这些请求中的域名看起来有些随机且可疑。
- en: '![image](../images/f292-01.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f292-01.jpg)'
- en: '*Figure 12-35: An HTTP request to an unknown external host*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-35：一个HTTP请求到未知的外部主机*'
- en: Things get interesting in the `GET` request at packet 39\. Following the TCP
    stream of this exchange ([Figure 12-36](ch12.xhtml#ch12fig36)), you’ll notice
    that a file named *bXJkeHFlYXhmaA* is requested ➊. The name of this file is a
    little odd, and it doesn’t include a file extension either.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包 39 的 `GET` 请求中，事情变得有趣了。跟踪此交换的 TCP 流（[图 12-36](ch12.xhtml#ch12fig36)），你会注意到请求了一个名为
    *bXJkeHFlYXhmaA* 的文件 ➊。这个文件的名称有些奇怪，并且没有包含文件扩展名。
- en: '![image](../images/f292-02.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f292-02.jpg)'
- en: '*Figure 12-36: An oddly named Flash file is downloaded.*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-36：下载了一个名字奇怪的 Flash 文件。*'
- en: Upon closer inspection, we see that the web server identifies the content of
    this file as *x-shockwave-flash* ➋. Flash is a popular plugin used for streaming
    media within a browser. It’s not abnormal to see Flash content downloaded by a
    device, but it’s worth noting that Flash is notorious for having software vulnerabilities,
    and it often goes unpatched. The Flash file is downloaded successfully following
    the request.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 经过仔细检查，我们看到 web 服务器将该文件的内容识别为 *x-shockwave-flash* ➋。Flash 是一种在浏览器中用于流媒体播放的流行插件。看到设备下载
    Flash 内容并不异常，但值得注意的是，Flash 以其软件漏洞而臭名昭著，且这些漏洞经常得不到修复。Flash 文件在请求后成功下载。
- en: After the Flash file is downloaded, there is a request for another similarly
    named file in packet 130\. Following this TCP stream ([Figure 12-37](ch12.xhtml#ch12fig37)),
    you see a request for a file named *enVjZ2dtcnpz* ➊. The file type isn’t identified
    here with an extension or by the server. The request is followed by the client’s
    downloading a 358,400-byte chunk of unreadable data ➋.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flash 文件下载后，数据包 130 中又有一个请求，要求下载一个类似命名的文件。跟踪这个 TCP 流（[图 12-37](ch12.xhtml#ch12fig37)），你会看到请求了一个名为
    *enVjZ2dtcnpz* 的文件 ➊。此处没有通过扩展名或服务器识别文件类型。请求后，客户端下载了一个 358,400 字节的无法读取的数据块 ➋。
- en: '![image](../images/f293-01.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f293-01.jpg)'
- en: '*Figure 12-37: Another oddly named file is downloaded, but no file type is
    identified.*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-37：又下载了一个名字奇怪的文件，但未识别出文件类型。*'
- en: Less than 20 seconds after that file is downloaded, you should see something
    familiar in the list of HTTP requests from [Figure 12-34](ch12.xhtml#ch12fig34).
    Beginning with packet 441, the friendly host starts making HTTP `POST` requests
    to two different servers using the same C2 pattern observed earlier. It’s likely
    we’ve identified the source of the infection. The two files that were downloaded
    were responsible. The first file from the request in packet 39 delivered a Flash
    exploit, and the second file from the request in packet 130 delivered the malware.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载该文件不到 20 秒后，你应该在 [图 12-34](ch12.xhtml#ch12fig34) 中看到一些熟悉的内容。从数据包 441 开始，友好的主机开始向两个不同的服务器发送
    HTTP `POST` 请求，使用之前观察到的相同 C2 模式。我们很可能已经找到了感染的源头。下载的两个文件是罪魁祸首。第一个文件来自数据包 39 的请求，交付了
    Flash 漏洞，第二个文件来自数据包 130 的请求，交付了恶意软件。
- en: '**NOTE**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can use malware analysis techniques to decode and analyze the files contained
    in the packet capture. If you’re interested in learning more about reverse engineering
    malware, I recommend* Practical Malware Analysis *(2012) by Michael Sikorski and
    Andrew Honig, another No Starch Press book and a personal favorite of mine.*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以使用恶意软件分析技术来解码和分析数据包捕获中的文件。如果你对逆向工程恶意软件感兴趣，我推荐 Michael Sikorski 和 Andrew
    Honig 的《实用恶意软件分析》（2012年），这是一本来自 No Starch Press 的书，也是我个人的最爱。*'
- en: This scenario represents one of the most common infection techniques. A user
    was browsing the internet and stumbled onto a site that had been infected with
    malicious redirection code from an exploit kit. These kits infect legitimate servers
    and are designed to fingerprint clients to determine their vulnerabilities. The
    infected page is known as the *kit’s landing page*, and its purpose is to redirect
    the client to another site containing an exploit the kit has determined will be
    effective against the system.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景代表了最常见的感染技巧之一。用户正在浏览互联网时，偶然进入了一个被恶意重定向代码感染的网站，这些代码来自一个利用工具包。这些工具包感染合法服务器，旨在识别客户端以确定其漏洞。被感染的页面被称为
    *工具包的着陆页*，其目的是将客户端重定向到另一个包含该工具包已确定有效的漏洞的站点。
- en: The packets you’ve just seen are from the Angler exploit kit, which is perhaps
    the most frequently observed kit of 2015 and 2016\. When the user reached a site
    that had been infected by Angler, the kit determined the user would be vulnerable
    to a specific Flash vulnerability. The Flash file was delivered, the system was
    exploited, and a secondary payload of the CryptoWall malware was downloaded and
    installed on the host. This entire sequence is depicted in [Figure 12-38](ch12.xhtml#ch12fig38).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到的这些数据包来自于Angler利用工具包，它可能是2015年和2016年最常见的工具包。当用户访问一个被Angler感染的网站时，该工具包会判断用户会受到特定Flash漏洞的攻击。Flash文件被传送，系统被利用，CryptoWall恶意软件的二次负载被下载并安装到主机上。整个过程如[图12-38](ch12.xhtml#ch12fig38)所示。
- en: '![image](../images/f294-01.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f294-01.jpg)'
- en: '*Figure 12-38: The exploit kit infection sequence*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-38：利用工具包感染序列*'
- en: '**Final Thoughts**'
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最终思考**'
- en: Entire books could be written on breaking down packet captures in security-related
    scenarios, analyzing common attacks, and responding to IDS alerts. In this chapter,
    we’ve examined some common scanning and enumeration techniques, a common MITM
    attack, and a couple of examples of how a system might be exploited and what might
    happen as a result.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在与安全相关的场景中分析数据包捕获、分析常见攻击以及响应IDS警报，完全可以写成整本书。在本章中，我们考察了一些常见的扫描和枚举技术、一种常见的MITM攻击，以及一些关于系统如何被利用以及可能会发生什么的例子。
