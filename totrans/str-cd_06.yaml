- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: FORTH
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: FORTH
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: Forth is the quintessential minimalist programming language. Parsing Forth is
    nothing more than extracting tokens separated by whitespace. There is no interpretation
    of formulas and everything is a discrete word operating on the stack. Programs
    are a collection of functions, called *words*, that are compiled, function by
    function, to an ever expanding memory space known as the *dictionary*. Words are
    executed when encountered, or compiled to the dictionary when defined. This is
    in contrast to languages like Python, C++, or Java, which require sophisticated
    parsers and compilers and a rigid structure, and are well-abstracted from the
    hardware of the computer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 是一种典型的极简编程语言。解析 Forth 仅仅是提取由空白字符分隔的符号。没有公式的解释，一切都是在栈上操作的离散单词。程序是由称为*单词*的函数组成，这些单词被逐个编译到一个不断扩展的内存空间中，这个空间被称为*字典*。单词在遇到时执行，或者在定义时编译到字典中。这与像
    Python、C++ 或 Java 这样的语言不同，它们需要复杂的解析器和编译器，并且具有严格的结构，且与计算机硬件有很大的抽象。
- en: In this chapter, we’ll install Forth, discuss the origins and philosophy behind
    the language, and then dive into the language itself. We’ll include some examples
    along the way and end with a discussion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将安装 Forth，讨论该语言的起源和哲学，然后深入探讨语言本身。我们将一路展示一些示例，并最后进行讨论。
- en: '**Installation**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安装**'
- en: Installing Forth is particularly easy.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Forth 特别简单。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Forth runs interactively. To see if our installation is working, we can type
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 是交互式运行的。为了查看我们的安装是否正常工作，我们可以输入：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Forth is quietly waiting for us to type something. Forth interprets tokens
    separated by one or more spaces. If the token is a known word, that is, a defined
    function, it is executed. If the token is a number, then it’s pushed on the stack.
    Input lines are executed when you press ENTER. Try the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 安静地等待我们输入内容。Forth 解释由一个或多个空格分隔的符号。如果符号是已知的单词，也就是已定义的函数，它会被执行。如果符号是数字，那么它会被推送到栈上。按下回车键时，输入行会被执行。尝试以下命令：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will tell Forth to move to the next line (`cr`), push 1 on the stack followed
    by 2, and then add (`+`) the 1 and the 2, leaving 3 on the stack. Next, we push
    another 3 on the stack and multiply them (`*`). Lastly, the period (`.`) prints
    the top stack value, which is now 9\. Forth signals it’s ready for more commands
    with the `ok` prompt. To exit, enter bye.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉 Forth 移动到下一行（`cr`），将 1 推送到栈上，然后是 2，接着将 1 和 2 相加（`+`），结果将 3 留在栈上。接下来，我们将另一个
    3 推送到栈上，并将它们相乘（`*`）。最后，句点（`.`）打印栈顶的值，现在是 9。Forth 通过 `ok` 提示符表示它准备接受更多命令。要退出，输入
    bye。
- en: Forth uses *postfix notation*, meaning the operator comes after the operands.
    To get 1 + 2, we entered `1 2 +`. Postfix notation was developed by Jan Łukasiewicz
    in 1924 and, because of his nationality, is often known as *reverse Polish notation*
    or *RPN*. Some early desk calculators also used postfix notation. The nice thing
    about postfix is that it never requires parentheses.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 使用*后缀表示法*，意味着操作符位于操作数之后。为了得到 1 + 2，我们输入了`1 2 +`。后缀表示法是由 Jan Łukasiewicz
    在 1924 年提出的，由于他的国籍，这种表示法通常被称为*逆波兰表示法*或*RPN*。一些早期的桌面计算器也使用了后缀表示法。后缀表示法的优点是它永远不需要括号。
- en: '**Origins and Philosophy**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**起源与哲学**'
- en: Forth was created by Charles “Chuck” Moore and evolved through the 1960s, coming
    of age in the early 1970s. As an interactive system in an age of punch cards,
    Forth was ahead of the curve. One of its primary uses early on was telescope control.
    Over time, Forth found its niche in small systems, though full-blown, object-oriented
    Forths appeared for personal computers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 是由 Charles “Chuck” Moore 创建的，并在 1960 年代逐渐发展，到了 1970 年代初期逐渐成熟。作为一种交互式系统，Forth
    在打孔卡片的时代走在了前面。早期的主要用途之一是天文望远镜控制。随着时间的推移，Forth 在小型系统中找到了自己的定位，尽管面向对象的 Forth 也出现了并应用于个人计算机。
- en: Forth, originally spelled FORTH, was meant as a fourth-generation programming
    language, but the assembler only allowed five-character names. So instead of “FOURTH,”
    it was “FORTH,” and later “Forth.” The term *fourth generation* dates to when
    programming languages were grouped by the vague concept of a generation. The first
    generation was machine code and the second was assembly. Languages like C were
    the third generation. And that’s where the term *generation* started to falter—most
    languages were third generation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Freedom to the programmer sums up Forth’s philosophy. The extreme openness of
    the language includes extending the compiler itself, which is functionality seldom
    seen in other languages. We’ll see how to do this later in the chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Forth conceives of programs as documents written in a custom language using
    words (functions) compiled into a dictionary. The dictionary stores all the words
    needed to implement the program, along with all necessary data. Each new word
    or block of data is added to the end of the dictionary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Historically, the Forth community frowned upon code reuse. Building a library
    for later use was deemed a recipe for disaster. The modern approach of pulling
    pieces from many different libraries of pre-built code, like the standard modules
    of Python or the standard template library of C++, was alien to Forth and considered
    distasteful. A “good” Forth programmer developed the appropriate set of words
    to implement the specified task: no more and no less. If done well, the code itself
    reads much like a document. Good Forth is self documenting.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'I ran across an email signature many moons ago, source long lost, that read:
    “C makes you think it is the best programming language in the world. Forth makes
    you think you are the best programmer in the world.” This captures the philosophy
    of Forth quite nicely. Instead of only using what the language designers gave,
    the Forth programmer manipulates the raw material of Forth, turning it into the
    ideal language for the task at hand.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**The Language**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Forth is, in essence, a system and not simply a compiler or interpreter. Early
    Forths *were* the operating system. They accessed disks in 1024-byte blocks—there
    was no filesystem—and they compiled code from those blocks. There is a top-level
    *REPL* (read, evaluate, print, loop) that, by convention, uses `ok` as the prompt.
    Forth programs are a sequence of tokens separated by whitespace. In most Forths,
    any combination of characters, excluding space, tab, and newline, is a valid token.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Tokens are evaluated as encountered. If the token is found in the dictionary,
    it is executed. If the token is not in the dictionary, Forth tries to interpret
    it as a number. If Forth fails at this, Forth throws an error message and returns
    to the `ok` prompt.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Executing a word when encountered makes sense. But what does Forth do with numbers?
    Forth pushes them on the *stack*. All operations use the stack, either pulling
    arguments from or pushing results onto the stack. Tokens interpreted as numbers
    are pushed onto the stack. Words often pull values from the stack, operate on
    them, and push new values onto the stack.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The stack is central to Forth and several of the esolangs we’ll encounter later
    in the book, so let’s spend a bit of time understanding what a stack is and how
    to work with one.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding the Stack***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Stacks are basic computer science data structures, often referred to as *last
    in, first out*, or *LIFO*, data structures. They are the opposite of a queue,
    which is a *first in, first out*, or *FIFO*, data structure. I think of the stack
    of trays at a buffet. When trays are put on the stack, the first tray is set down,
    then the second, then the third, and so on. When someone takes a tray, they don’t
    take the first tray; they take the last one put on the stack. In contrast, the
    first thing out of the queue is the first thing put into it, not the last.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages use stacks. An example is the return stack for function
    calls. Forth uses a stack for data and, as we’ll see below, a separate one for
    returning from function calls. It’s the data stack that Forth programmers use
    most frequently, though they can temporarily use the return stack with care.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-1](ch04.xhtml#ch04fig1) illustrates the operation of the stack.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/04fig01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Pushing values on the Forth stack (top), and popping values off
    (bottom)*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through [Figure 4-1](ch04.xhtml#ch04fig1), beginning with the top
    row going from left to right. We have three values—1, 2, and 3—and an empty stack.
    Next, we *push* 1 on the stack. The top item on the stack is marked with an arrow.
    Then we push 2 on the stack, which is now on top of 1 and is thus the new top
    stack item. Lastly, we push 3 on the stack, making it the top stack item.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: To remove items from the stack, we *pop* them. This is shown in the bottom row
    of [Figure 4-1](ch04.xhtml#ch04fig1). Again, moving from left to right, we pop
    the stack to get 3\. Notice that 3 was the *last* item pushed onto the stack,
    so it is the first item popped off of the stack. We then pop the stack again to
    get 2, and pop one last time to get 1, leaving the stack empty. Attempting to
    pop an empty stack is a common Forth error. You’ll make it yourself, eventually.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the Stack***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Manipulating the stack is perhaps the most frustrating part of Forth. However,
    Forth comes with many intrinsic words to help you control the stack. Let’s introduce
    some of them and see how they work. We’ll start with a simple example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we push 1, then 2, then 3 on the stack. To pop the stack and print the
    popped value, use a period (`.`). Doing so gives us 3, the last item pushed on
    the stack. Popping and printing the stack two more times gives us 2 and then 1,
    leaving the stack empty. To exit Forth, enter bye. Forth is case insensitive,
    so `BYE` works just as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-1](ch04.xhtml#ch04tab1) introduces several words and an essential
    Forth convention.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-1:** Stack Manipulation Words'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '| **Word** | **Effect** | **Description** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| `dup` | `( a -- a a )` | Duplicate the top stack item |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `drop` | `( a b -- a )` | Drop the top of stack item |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| `swap` | `( a b -- b a )` | Swap the top two stack items |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| `2dup` | `( a b -- a b a b )` | Duplicate the top two stack items |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| `2drop` | `( a b c -- a )` | Drop the top two stack items |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| `over` | `( a b -- a b a )` | Copy the next to top of stack item |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| `rot` | `( a b c -- b c a )` | Rotate the top three stack items |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| `nip` | `( a b c -- a c )` | Drop the next to top of stack item |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| `.s` | `( -- )` | Print the stack without altering it |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: The words are somewhat descriptive, and Forth is case insensitive, but the Effect
    column is important. The Effect column contains *stack-effect comments*, which
    we’ll describe below. Forth comments begin with a left parenthesis, `(`, and end
    with a right parenthesis, `)`. Note that a space after the `(` is required. Forth
    ignores anything after `(` until the first `)`. Comments may not be nested. Many
    Forth systems, including ours, use `\` as a comment running to the end of the
    line, like `//` in C++.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The comment itself illustrates how the word affects the stack. On the left is
    the stack as the word expects it with the top stack item on the right, next to
    the dashes. On the right of the dashes is the stack as the word leaves it, again
    with the top stack item on the right. There are conventions for the characters
    used, though they are more like guidelines than actual rules.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: For example, `dup` duplicates the top stack item, so `a` becomes `a a`. If the
    word does not affect the stack, the empty `( -- )` comment is used. By convention,
    every word definition has a stack-effect comment after its name, much like the
    convention of adding a documentation string after the definition of a function
    in Python.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-1](ch04.xhtml#ch04tab1) includes the word `.s` to print the contents
    of the stack without changing it. As you work with Forth, especially when getting
    a feel for the stack words, you’ll use `.s` often. It’s a good idea to use it
    to check that your words are not leaving extra junk on the stack.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the stack some more.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The example above ends by calling `2drop` to remove the remaining two stack
    items, which is why `.s` shows no items on the stack (`<0>`). Work with the stack
    until you feel comfortable with the stack manipulation words.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'All Forth systems support integer arithmetic using the expected operators:
    addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`), and modulo
    (`mod`). Many Forth systems, including gforth, work with floating-point numbers
    as well.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Forth 系统都支持使用常见的运算符进行整数运算：加法（`+`）、减法（`-`）、乘法（`*`）、除法（`/`）和取模（`mod`）。许多 Forth
    系统，包括 gforth，也支持浮点数运算。
- en: 'As practice, you might try implementing the following expressions using the
    standard arithmetic words:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以尝试使用标准算术运算词汇实现以下表达式：
- en: '| (1200 × 3) ÷ 4 | (ans: 900) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| (1200 × 3) ÷ 4 | （答案：900） |'
- en: '| 8 × (127 *–* 9) ÷ 11 | (ans: 85) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 8 × (127 *–* 9) ÷ 11 | （答案：85） |'
- en: '| 8 × (127 *–* 9) mod 11 | (ans: 9) |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 8 × (127 *–* 9) mod 11 | （答案：9） |'
- en: '| ((33 *–* 45) ÷ (7 + 9)) × 3 | (ans: -3) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| ((33 *–* 45) ÷ (7 + 9)) × 3 | （答案：-3） |'
- en: 'You’ll need to convert the expressions into postfix, meaning instead of *a*
    + *b* you’ll write *a* *b* +, and so on. Leave subexpression values on the stack
    and combine them with operations later: (*a* + *b*) × (*c* + *d*) becomes *a*
    *b* + *c* *d* + ×.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将表达式转换为后缀表达式，意味着你不再写 *a* + *b*，而是写 *a* *b* +，以此类推。将子表达式的值保留在栈上，稍后与操作符结合：(*a*
    + *b*) × (*c* + *d*) 变为 *a* *b* + *c* *d* + ×。
- en: 'To use floating-point with gforth, you must do two things. First, enter floating-point
    constants using scientific notation. So to push 3.1415 on the floating-point stack,
    separate from the data stack, which is integer only, use `3.1415e0`. For example,
    to calculate 1/1,121 using first integer then floating-point math, enter the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 gforth 中使用浮点数，您需要做两件事。首先，使用科学计数法输入浮点常量。比如要将 3.1415 推入浮点栈（与数据栈分开，数据栈仅支持整数），使用
    `3.1415e0`。例如，要计算 1/1,121，可以先进行整数运算再进行浮点运算，输入如下：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For simplicity, we’ll stick with integer operations for the remainder of this
    chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，接下来我们将继续使用整数运算。
- en: '**FORTHS NOT FORTH**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**FORTHS 不是 Forth**'
- en: You’ve likely noticed by now that I’ve referred several times to “Forths” instead
    of just “Forth.” There is a reason for that. The “freedom to the programmer” philosophy
    extends to Forth itself. Excluding the minor differences between versions, there
    is only one Python. Similarly, C++ is C++ and Java is Java. In contrast, there
    are, or were, legions of Forths. Most are now forgotten or virtually unusable
    because the computers they were written for are long gone. For example, few have
    ever heard of QForth for the Apple II, let alone the Jupiter ACE, the only 1980s-era
    personal computer to run Forth instead of BASIC. Because of this proliferation
    of Forth systems, what works nicely on one Forth implementation often fails on
    another. In 1994, ANSI standard Forth was defined (see ANSI X3.215-1994). Gforth
    follows this standard; however, the standard seems to have had little effect overall,
    as there are many homegrown Forth systems still in existence, most of which are
    non-standard and often highly customized.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我多次提到“Forths”而不是单单“Forth”。这有原因。所谓“赋予程序员自由”的哲学也延伸到了 Forth 本身。除了各版本之间的细微差异外，Python
    只有一个版本。类似地，C++ 就是 C++，Java 就是 Java。相比之下，Forth 有很多变种。大多数现在已经被遗忘或几乎无法使用，因为它们最初运行的计算机早已不存在。例如，几乎没人听说过
    Apple II 上的 QForth，更不用说 Jupiter ACE——这是唯一一台在 1980 年代运行 Forth 而不是 BASIC 的个人计算机。由于
    Forth 系统的泛滥，某个 Forth 实现上运行良好的程序在另一个实现上往往无法正常工作。1994 年，ANSI 标准 Forth 被定义（参见 ANSI
    X3.215-1994）。Gforth 遵循该标准；然而，这个标准似乎总体上影响不大，因为仍有许多本土的 Forth 系统存在，其中大多数是非标准的，并且通常经过高度定制。
- en: Now let’s learn how to define our own Forth words.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们学习如何定义我们自己的 Forth 词汇。
- en: '***Words and Loops***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***词汇和循环***'
- en: “Hello, world!” in Forth is
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Forth 中的“Hello, world!”是
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we’ve defined our own word to print `Hello, world!`. Word definitions
    begin with a colon (`:`), followed by the name of the word, which in this case
    is `hi`. Next comes the stack-effect comment, which isn’t required, but strongly
    encouraged.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了自己的词汇来打印 `Hello, world!`。词汇定义以冒号（`:`）开始，后跟词汇名称，在本例中为 `hi`。接下来是栈效应注释，虽然不是必需的，但强烈建议添加。
- en: 'The word `hi` consumes nothing from the stack and leaves nothing on the stack,
    so the comment is empty: `( -- )`. The next token is `."` which begins compiling
    a string to print. Don’t forget the space after `."`; it’s required. The string
    ends with a double quote (`"`), followed by `cr` to move to the next line. The
    definition ends with a semicolon (`;`). We just defined our first word. To use
    it, enter hi at the `ok` prompt. Not too exciting, but it’s a start.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we are feeling particularly happy today and want to greet the world
    repeatedly? That’s easy to do as well. We just need a word that knows how to say
    `hi` many times:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The new word, `hello`, uses a `do` loop. This is Forth’s version of a `for`
    loop, and may only be used within a word definition.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The general form of a `do` loop is
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the ending and starting values are on the stack, with the ending value
    first, then the starting value, followed by the word `do`, the body of the loop,
    and the word `loop` to end the loop. Why so convoluted? It has to do with how
    Forth works. Comments about Forth being the exposed core of a compiler aren’t
    all that far from the truth. The words `do` and `loop` are not keywords, but rather
    words that execute immediately when encountered by Forth. Their action sets up
    the code to make the loop. All of Forth’s flow control words operate this way.
    The core Forth compiling words are no different from those a programmer might
    create, which is why the Forth compiler can be extended on the fly if desired.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Some Forth systems, especially those implemented in C, define most of Forth
    in Forth using a small core set of words to build the rest of the system. For
    example, `lbForth` (*[https://gist.github.com/lbruder/10007431/](https://gist.github.com/lbruder/10007431/)*)
    is one such C-based Forth in the public domain. Here’s how it defines `do` and
    `loop` in terms of other Forth words.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Many of the words in these definitions will not make sense right now, but they
    will over time if you continue to work with Forth. The `immediate` tag after `;`
    marks the word to make sure it is executed when encountered, even when defining
    another word. Also, the single quote (`'`) takes the next token, looks up its
    execution address in the dictionary, and places that address on the stack. The
    comma (`,`) adds the top-of-stack number to the end of the dictionary, which in
    this case is the address of the word before it. The word `here` places the address
    of the end of the dictionary on the stack. Thus, `do`’s net effect is to put the
    current end of the dictionary address on the stack and then compile references
    to order and store the loop limits that are already on the stack on the return
    stack. That’s `swap >r >r`. I mentioned above that the return stack, which holds
    the address of where to go after the current word ends, is available to programmers
    if they are careful and remove anything they place on it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Notice how `loop` pulls the limits from the return stack with `r>` and orders
    them, after which it increments the lower limit and compares it with the upper
    limit. If the limits are not equal, a branch back to the initial starting address
    placed on the stack by `do` happens courtesy of `0branch`. The number of bytes
    to branch backward is calculated with `here @ -`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `loop` 如何通过 `r>` 从返回栈中拉取限制值并排序，然后它会增加下限并与上限进行比较。如果限制值不相等，`0branch` 会通过栈中由
    `do` 放置的初始起始地址跳转回去。计算回跳所需的字节数通过 `here @ -` 来实现。
- en: A firm understanding of how these words operate isn’t required. I’ve only highlighted
    them so we notice how even the compiler itself is Forth. The openness that allows
    flow control words like `do` and `loop` to be implemented in Forth is available
    to all Forth programmers. I know of no other programming language that is so open
    in this way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些词语的操作理解并非必需。我之所以提到它们，是为了让我们注意到甚至编译器本身也是 Forth。Forth 所允许的像 `do` 和 `loop` 这样的流程控制词语的开放性是所有
    Forth 程序员都可以使用的。我不知道其他编程语言能像这样开放。
- en: 'The loop of `hello` above ran 10 times even though the limits were 0 and 10\.
    This is because the upper limit is not included, making the `do` loop act like
    a C `for` loop:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上面 `hello` 的循环执行了10次，即使限制是0到10。这是因为上限不包括在内，使得 `do` 循环像 C 语言中的 `for` 循环一样。
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The C code above used `i` as the loop counter. In Forth, the word `i` supplies
    the loop counter. Consider the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上面 C 代码使用 `i` 作为循环计数器。在 Forth 中，词语 `i` 提供了循环计数器。请看以下示例：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, note that `do` uses `i` to access the current value of the
    loop counter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，注意 `do` 使用 `i` 来访问当前的循环计数器值。
- en: There are times when incrementing by one isn’t sufficient. Forth uses `+loop`
    in those cases, with the increment on the stack. The following example counts
    by threes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时单纯增加1并不够。在这种情况下，Forth 使用 `+loop`，其中增量值在栈上。以下示例每次增加3。
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is also possible to use the index as the increment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用索引作为增量。
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Nested `do` loops are allowed. Use `i` to access the counter of the inner-most
    loop and `j` to access the counter of the next outer loop.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 允许嵌套 `do` 循环。使用 `i` 来访问最内层循环的计数器，使用 `j` 来访问下一个外层循环的计数器。
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, `i` refers to the counter of the inner loop and `j` the outer.
    The word `space` prints a blank, as you likely surmised from the output. Note
    that we’re writing the double loop in one line for simplicity. Forth is quite
    happy if you split up the code in a way that is easier to read.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`i` 代表内循环的计数器，`j` 代表外循环的计数器。`space` 打印一个空白，正如你从输出中可能已经推测出来的那样。注意，我们将双重循环写在一行中，以简化代码。如果你将代码拆分成更易读的格式，Forth
    也完全没有问题。
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s experiment a bit more with `i` and `j`. Consider the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做些实验，看看 `i` 和 `j` 的效果。请看以下示例：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Look at the definition of `nested1`. There are two `do` loops here. The first
    loop goes from 1 up to, but not including, 5\. The inner loop runs from 0 up to,
    but not including, the current value of `i`. The output reflects the counter of
    the outer loop and runs the inner loop that many times: first once, then twice,
    then three times, and so on, each time printing the value of the outer loop because
    of `j`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 `nested1` 的定义。这里有两个 `do` 循环。第一个循环从1开始，一直到5，但不包括5。内循环从0开始，一直到当前 `i` 的值（不包括当前值）。输出反映了外循环的计数器，并运行那么多次内循环：第一次执行一次，然后两次，接着三次，依此类推，每次都会打印外循环的值（即
    `j`）。
- en: Now, look at `nested2`. In this case, the inner loop references `i`, which is
    the counter of the inner loop. Therefore, the first pass of the outer loop sets
    `i` to 1, causing the inner loop to iterate one time from 0\. This explains the
    first 0\. On the next pass, `i` is 2 in the outer loop, thereby causing the inner
    loop to run twice. The inner loop then references `i` as well; however, this time,
    the second `i` refers to the *inner* loop counter, which is why the output, on
    separate lines, is
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下 `nested2`。在这种情况下，内循环引用 `i`，即内循环的计数器。因此，外循环的第一次迭代将 `i` 设置为1，从而使内循环从0开始执行一次。这也就解释了第一个0。下一次迭代时，外循环的
    `i` 为2，导致内循环执行两次。内循环此时也会引用 `i`；然而，这时第二个 `i` 是指*内*循环的计数器，这也是为什么输出会分成两行的原因。
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What if you have three or more nested loops? How do you get the outer-most counter?
    There is no Forth word for that, so you’d need to stash the counter with `i` before
    starting the next two nested loops and access it that way. You can either leave
    it on the stack, push it to the return stack, or dump it to a variable and reference
    it when needed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '***What Is Truth?***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Forth is unusual, so it should come as no surprise that Forth’s definition of
    truth is unusual as well. In most languages, if there is no explicit Boolean data
    type, like `False` and `True` in Python, 0 is false and 1 (or not 0) is true.
    In Forth, false is 0, but true is *–*1\. Forth also supports the usual comparison
    operators such as `<` and `>`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The above tells us that 1 < 2, *–* 123 < 321, and 45 > 3 but not 3 > 45.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: To test for equal and not equal, use `=` and `<>`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Forth works with both signed and unsigned integers, but the comparison operators
    above work only with signed integers. However, Forth also supports unsigned versions,
    indicated with a letter `u` before the operator.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first result makes sense, but the second might not; however, it is correct.
    The unsigned comparison looks only at the bit pattern representing *–*123\. In
    two’s complement format, assuming 16-bit integers even though our Forth system
    uses 64-bit integers, the bit pattern for *–*123 is 1111111110000101 whereas the
    bit pattern for 321 is 0000000101000001\. This means that *–*123 is greater than
    321 when using an unsigned comparison.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Forth wouldn’t be of much use without some form of conditional expression. Thankfully,
    it supports `if`, `else`, and `then`. The general format for a conditional expression
    is
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `<condition>` is a condition flag on the stack, with 0 indicating false
    and *–*1 indicating true. If true, the words in `<true_instructions>` are executed.
    If there is an `else` and the condition is false, the words in `<false_instructions>`
    are executed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Goldilocks might want to know something about the state of the
    bowl of porridge she’s just stumbled upon based on its temperature. In Python,
    she might write the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In Forth, she might write what’s shown in [Listing 4-1](ch04.xhtml#ch04list1).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 4-1: Too cold, too hot, or just right*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'She’d then test her Forth code like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let’s walk through the example in [Listing 4-1](ch04.xhtml#ch04list1). The word
    `porridge` expects a number on the stack, which in this case is the porridge’s
    temperature in degrees Fahrenheit. With the temperature still on the stack, `porridge`
    prints the first part of the output sentence. Note that there is no `cr`, so by
    default, the output does not move to the next line.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the set of nested `if` statements. Let’s start with the first one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The word `dup` duplicates the temperature. This is necessary, as `<` will consume
    it along with 90 to test *n* < 90\. The result, either 0 or *–*1, is then pushed
    onto the stack. The value is consumed in this test, so if the first `if` fails,
    the nested second `if` will need a copy of *n* for its test.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the stack contains *n* and the output of `<`. Next, `if` consumes
    the 0 or *–*1\. If –1, `porridge` prints the rest of the sentence: too cold. What’s
    the `drop` doing there? Because *n* was duplicated to preserve it in case the
    first `if` failed, it’s still on the stack. Therefore, it must be dropped before
    `porridge` exits.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The second `if` is like the first; it checks to see if *n* is less than 100\.
    If so, the porridge is just right; otherwise, it’s too hot. Note that there is
    no `dup` before the second `if` as *n* is not needed after the comparison, so
    it’s consumed by `<`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The way [Listing 4-1](ch04.xhtml#ch04list1) is written follows classic Forth
    convention. As mentioned, early Forths accessed disks in 1024-byte blocks, so
    writing compact code was essential. The Forth editor split the 1024 bytes of a
    block, a *screen*, into 16 lines of 64 characters each.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Modern Forth is more flexible. The following code works just as well as [Listing
    4-1](ch04.xhtml#ch04list1).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Some Forth systems, including gforth, support a `case` selection structure that
    mirrors `switch` in C. For example, in a menu-driven program, the proper action
    to take depends on which option the user selects—a natural place to use `case`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that `case` expects the option to be on the stack when the word is executed.
    Forth then searches through the cases looking for a match. If a match is found,
    Forth executes the case’s body, which consists of the words between `of` and `endof`.
    If no case matches, Forth can use a default case (“bad option”).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Control Structures***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Forth’s remaining control structures include a top-tested loop, a bottom-tested
    loop, and an infinite loop.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first two are similar to `while` and `do-while` in C, but the last one
    is a bit curious. It’s an infinite loop, which is easily written in other languages
    by making the `while` condition always true. However, when considering Forth implemented
    in Forth, it’s easy to see why `begin-again` might exist:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Both `begin` and `again` are immediate words, that is, those that execute even
    when defining a word; `begin` places the current end-of-dictionary value on the
    stack, and `again` branches backward from the end of the dictionary to the location
    that `begin` initially placed on the stack. The branch is backward because `again`
    happens after the body of the loop, so `here` will report a higher address than
    the address placed on the stack by `begin`. I won’t show it here, but with a little
    imagination, one can guess how `while`, `repeat`, and `until` might be implemented
    as Forth words.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: A simple example of `begin-again` is
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The word `infinity` places 0 on the stack, duplicates it so it can be printed,
    and then increments it and starts repeating until you press CTRL-C or the power
    goes out.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Of more immediate utility are the top- and bottom-tested loops. A top-tested
    loop, the `while` loop, tests its condition before executing the body of the loop.
    Therefore, the body of the loop might never execute if the condition fails initially.
    For a bottom-tested loop, the body executes at least once to get to `until`. Let’s
    see `while` in action.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: One way to estimate the square root of a number using integer operations is
    to start at 0, square 0, and ask if that result is equal to or greater than the
    number. If it isn’t, move on to try 1, then 2, 3, 4, and so on. Eventually, we’ll
    get to the point where the number squared is equal to or greater than the given
    number. [Listing 4-2](ch04.xhtml#ch04list2) implements this inefficient algorithm
    with `*while*` .
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 4-2: A brute-force square root word*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: We’ll call the word `dsqr` for “dumb square root” because it implements the
    simplest algorithm possible. The word pushes an initial 0, which is the counter,
    and then starts the loop with `begin`. Note that the number we want the square
    root of, *n*, is already on the stack.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two pieces to the `while` loop: the condition and the body. Here
    the condition is `2dup dup * >`. We have the given number and 0 on the stack for
    `2dup` to duplicate. Next, `dup` duplicates the counter so it can be multiplied
    by itself to square it. This sets up `>`, which leaves a 0 or *–*1 on the stack.
    Remember, because of `2dup`, the given number and counter are still on the stack.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Next, `while` uses the condition’s state to decide whether or not to execute
    the body of the loop, `1+`, which increments the counter still on the top of the
    stack. The `repeat` word does nothing as far as the loop is concerned, but again,
    we’ve seen enough of the internals of Forth to know that `repeat` is calculating
    how far back in the dictionary to branch to start again at `begin`. The word completes
    once the square root is found by removing the given number, the second-to-top
    stack item (`nip`).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: As dumb as it is, `dsqr` works and is exact for perfect squares (but not for
    other numbers). Later, we’ll implement a different integer square root algorithm,
    one that is surely less computationally demanding (we think).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In Forth, `begin-until` loops always execute the body of the loop at least once.
    For example, here’s a word that plays a little guessing game.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Execute `guess` and press keys on the keyboard. The game ends when the lowest
    four bits of the ASCII character code for the key are 7\. The counter is initially
    0 and placed on the stack before `begin`. It is immediately incremented (`1+`)
    as there will always be at least one guess. Next, a keystroke is read and placed
    on the stack with `key`. The lowest four bits of the key’s character code are
    kept by `and`ing with 15 (0xF = 1111 in binary). That’s `15 and`. If the result
    is 7, `=` leaves *–*1 on the stack for `until`. If the result isn’t 7, `until`
    branches back to `begin`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, I said that `begin-until` is similar to `do-while` in C; however,
    there is an important difference. Consider the C equivalent of `guess`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This program uses `do-while`, but the condition on the `while` part is written
    so it is *true* if the low-order nibble (that is, the lowest four bits) of the
    key entered is not 7\. The Forth loop condition is *false* until the condition
    is met. In C, the logic is reversed: the `do-while` loop continues while the condition
    is true and the `begin-until` loop continues while the condition is false. Note
    that `key()` is not a standard C library function; it’s just a stand-in for a
    function that waits for a keystroke and returns the ASCII key code without requiring
    a newline.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: This example introduced `key` to wait for a character from the keyboard. We’ll
    examine other Forth input and output functions later in the chapter. For now,
    let’s get a handle on how Forth works with memory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '***How Forth Uses Memory***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Forth relies heavily on its stack, but that’s not the only means it has to work
    with data. Forth supports constants and variables natively, and can allocate space
    on the dictionary for any use. Let’s see how.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**Variables and Constants**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To define constants and variables, use code like what’s shown in [Listing 4-3](ch04.xhtml#ch04list3).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 4-3: Variables and constants in Forth*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines define variables `f` and `c`. The next line defines a constant,
    `b`, which is set to the top stack value, in this case 32.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Two short definitions come next. The first converts Celsius to Fahrenheit, *F*
    = (9/5)*C* + 32, and the second does the opposite, *C* = (5/9)(*F –* 32). Both
    definitions use the variables `f` and `c` instead of the stack—a very *un*-Forth-like
    thing to do. As an exercise, rewrite `c2f` and `f2c` to use the stack.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The word definitions in [Listing 4-3](ch04.xhtml#ch04list3) have strange `@`
    and `!` characters in them. When a Forth variable is referenced, the value of
    the variable is *not* placed on the stack; only the address of the variable goes
    on the stack. To get at the value, the address must be dereferenced, just like
    in C, where a pointer must be dereferenced to get at the thing it points to. Therefore,
    the expression `c @` first places the address of `c` on the stack, then executes
    `@`, which is the word that takes an address and returns the 64-bit integer at
    that address. Equivalent C code for `c @` is `*&c`, assuming that `c` is declared
    to be an `int`. First, use `&` to get the address of `c`, then use `*` to return
    the contents of `c`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Look again at the definition of `c2f` in [Listing 4-3](ch04.xhtml#ch04list3).
    The definition ends with `f !`. As you’ve likely already guessed, `!` stores values
    at the address on the top of the stack, in this case the Fahrenheit temperature.
    The stack effect for `!` is `( n a -- )` to store value *n* at address *a*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: There is an elegance to how Forth handles variables, as other data areas also
    leave their address on the stack. However, all the `@` and `!` characters flying
    around quickly become distracting. For example, to increment a variable `x` by
    1, use `x @ 1+ x !`, which isn’t particularly easy to read. Note that `1+` is
    not a typo. Incrementing the top stack item is common enough that Forth implements
    a special word for it that executes faster than `1+` will. In truth, though, I’m
    being a bit unfair here. Forth does have the word `+!`, which adds a value to
    a variable. So `x @ 1+ x !` might be written as `1 x +!`, which is slightly more
    readable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Forth supplies, at a minimum, two other words for memory access: `c@` and `c!`.
    Here the `c` refers to “character,” meaning old 8-bit ASCII. These words access
    *bytes*, not 64-bit integers. Consider this code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we define `x` as a variable. Then, we assign a value to `x` by introducing
    a new word, `hex`, to place Forth in hexadecimal mode. All numbers will be interpreted
    as base-16 until `decimal` is executed to restore base-10\. So the second and
    third lines when written in C become
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What of all the lines with `c@` in them? As `x` pushes the *address* of `x`
    on the stack, using `c@` returns the first *byte* at that address. Because Intel
    machines are little-endian, the first byte at the address of `x` is the lowest-order
    byte, `0x88` (to use C notation). Adding 1 to the address of `x` before accessing
    it moves to the next byte in memory to return `0x77`, and so on for all eight
    bytes of `x`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'This freedom makes it easy to modify memory in interesting ways. For example,
    the following code defines `x` as before, but then uses `c!` to modify the low-order
    byte of `x`, changing it from `88` to `ee`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Constants are just that: constants. Once fixed, they cannot be changed. Forth
    enforces this rule as well. However, consider these words:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Not every Forth system will allow this, but gforth does. What on Earth is happening?
    Recall what Forth does when it encounters a token on input. If it finds the token
    in the dictionary, it executes it; otherwise, it interprets it as a number and
    pushes it on the stack. The first two lines above define constants, `2` and `1`.
    In this case, the constants’ names really are “2” and “1” as characters. The value
    of the constant “2” is 1, and the value of the constant “1” is 4.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: So the next time “2” is encountered, Forth first searches the dictionary, finds
    a constant with that name, and dutifully executes it to place a 1 on the stack.
    The same is true for “1” to place a 4 on the stack. Therefore, while confusing,
    Forth is perfectly correct to present output that seems to us to say 1 + 1 = 8
    and 2 × 2 = 1.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a historical reason for allowing such shenanigans. Let’s face it:
    old computers were slow. Programmers were always on the lookout for tricks to
    speed things up. When dealing with a new token, Forth scans the dictionary from
    beginning to end, so many Forth programs started with strange definitions like
    `0 CONSTANT 0` because it was faster to look up zero as a word than scan the entire
    dictionary and then interpret the token as a number.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**Allocating Memory**'
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll introduce several new words in this section. There will be a table at
    the end that contains all of them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Forth puts all new data at the end of the dictionary. This includes word definitions,
    variables, and constants. To allocate arbitrary amounts of dictionary space, say
    for a buffer or a sequence of data structures of some kind, Forth provides several
    useful words: `create`, `does>`, `allot`, `cells`, a comma (`,`), and `c,`. Let’s
    see how they work.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The word `create` defines a word that does nothing more than place its address
    on the stack. For memory allocation, `create` is often followed by `allot`, like
    so:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The word `buf` is created, and immediately following it, 1,000 bytes of dictionary
    space are allocated. Effectively, this means there is a 1,000-byte buffer at the
    end of the dictionary, and the first byte of the buffer is the address that `buf`
    leaves on the stack when executed. This alone is already useful, as shown next.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The first three lines store byte values 1, 2, and 3 in the first three bytes
    of the 1,000-byte buffer pointed to by `buf`. We’re using `buf` as an array of
    bytes. Continuing with the example above, try the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first line stores a 64-bit value beginning at byte 4 of `buf`. The next
    line shows that the second byte of `buf` is still 2, as we set it above, and the
    third line that there is still a 64-bit value beginning at byte 4 of the buffer.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it’s definitely possible to work with a block of memory byte by byte,
    it’s tedious and error prone. [Listing 4-4](ch04.xhtml#ch04list4) shows how `create`
    works with `allot` and `does>` to create a word that defines 1D arrays:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 4-4: Defining a byte array*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The first line defines `bArray`, which expects a number on the stack, which
    is the number of bytes to `allot`. First, `create` makes the new word and leaves
    the stack untouched. Next, `allot` reserves *n* bytes of dictionary space. So
    far, this makes sense; we saw this above. However, things get interesting when
    `does>` is executed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The word `bArray` has two parts. The first part uses `create` and `allot` to
    reserve dictionary space for the byte array. This happens when `bArray` is executed.
    However, the `does>` portion is *not* executed just yet. The word `does>` details
    what happens when a word defined by `bArray` is itself executed. Additionally,
    when the word is executed, it pushes its address on the stack, after which `does>`
    the rest of the definition. Let’s walk through it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The second line, `100 bArray x`, creates a byte array word, `x`. The `create`
    and `allot` words have executed to create `x` and reserve 100 bytes of dictionary
    space. When `x` itself is executed, its address is pushed on the stack, and the
    remainder of the definition of `bArray`, the part after `does>`, is also executed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'For `bArray`, there is a plus (`+`) after `does>`. The address of the word,
    `x`, is on the top of the stack, so the `+` adds the address to the value just
    below it on the stack `( n a -- a+n )`, with *a* representing the address and
    *n* the value below, that is, an offset. Adding an offset to a base address is
    precisely how almost all programming languages index into arrays stored in contiguous
    memory. So if we supply an index before `x`, after `x` is executed, the stack
    contains the address of an element in the byte array assigned to `x`. Now the
    `c!` and `c@` lines in [Listing 4-4](ch04.xhtml#ch04list4) make sense: `125 2
    x c!` is equivalent to `x[2] = 125` in other languages. Likewise, `2 x c@ .` is
    `print(x[2])`, if using Python. The combination of `create` and `does>` has allowed
    us to create words that implement byte arrays. Excellent. But what if we want
    not an array of bytes, but an array of integers? The word `array` does what we
    want:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The only difference between `bArray` and `array` is the appearance of `cells`.
    In Forth, the basic unit of memory is a *cell*. For gforth, a cell is 64 bits
    or 8 bytes. If we want an array to store 100 values, we should allocate 800 bytes.
    Likewise, to index the array, we need addresses that are not just the base plus
    the index, but the base plus the index times the size of a cell. The word `cells`
    expects a number on the stack and returns the number of bytes in that many cells:
    `100 cells .` returns `800`.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: So adding `cells` after `create` simply calculates the number of bytes `allot`
    should reserve at the end of the dictionary. When we index, the part after `does>`,
    we first convert the index from cells to bytes and add the result to the base
    address. That’s what `swap cells +` accomplishes. After these changes, `array`
    works just like `bArray`, but one should use `!` and `@` to set and get values
    from the array.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, allocating the array isn’t all that we want. We also want to initialize
    it at the same time. The Forth way to do this uses a comma (`,`) or `c,`. These
    words compile the top stack item into the dictionary, either as a 64-bit integer
    or a byte. For example,
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: creates `ABCDEF` and allocates six values, the ASCII values for ABCDEF. The
    same is true if using the comma, but instead of bytes, it allocates cells (64-bit
    integers). These words are useful for setting up tables of constants or even arrays
    of words.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This example introduces two new words: single quote (`''`) and `execute`. The
    first takes the execution address of the next token, a word, and places it on
    the stack. The next word, `execute`, runs the word whose execution address is
    on the stack. So `tbl` is an array of three “function pointers” as it were, to
    use C terminology. Once the proper offset to `tbl` is known, and the execution
    address is on the stack courtesy of `@`, `execute` calls the word.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-2](ch04.xhtml#ch04tab2) summarizes the words we introduced in this
    section.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-2:** Forth Words for Manipulating Memory'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '| **Word** | **Effect** | **Description** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| `@` | `( a -- n )` | Get the 64-bit integer at address *a* |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| `!` | `( n a -- )` | Store a 64-bit integer in address *a* |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| `,` | `( n -- )` | Compile an integer into the dictionary |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| `c@` | `( a -- b )` | Get the byte at address *a* |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| `c!` | `( b a -- )` | Store a byte in address *a* |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| `c,` | `( b -- )` | Compile a byte to the dictionary |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| `create` | `( -- )` | Create a new word |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| `does>` | `( -- a )` | Define the word’s behavior |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| `allot` | `( b -- )` | Allocate dictionary space (bytes) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| `cells` | `( n -- b )` | Convert cells to bytes |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: Let’s set memory aside for now and investigate Forth’s input and output mechanisms.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '***Input and Output***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A programming language without input or output is essentially useless. Forth,
    of course, has words for basic input and output, to say nothing of low-level I/O
    via serial and other mechanisms. We saw `key` in the `begin-until` example above.
    Modern Forth, like gforth, also has file access words as part of its interface
    to the operating system. We’ll ignore those here to save space. Additionally,
    we already mentioned classic Forth’s block-level disk access. Surprisingly, gforth
    emulates this, if desired, using a disk file as a representation of the disk itself.
    Therefore, if you care to explore it, gforth will let you relive the classic Forth
    experience.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know `.`, which prints the top stack item as a signed integer. To
    print the top stack value as an unsigned integer, use `u.`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This example works in hexadecimal to make it easier to understand what is happening.
    We push `-0xAA` on the stack, duplicate it, and print it twice, once with `.`
    as a signed integer and again with `u.` as an unsigned integer.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: As expected, `.` produces `-AA`. However, `u.` produces `FFFFFFFFFFFFFF56`,
    a large, positive number, which is the value found by interpreting the signed
    64-bit binary value as a positive number.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Forth grew up in an age of terminals and teletypes. Therefore, it supports
    many words that are variations of `.` and `u.`, including words for highly structured
    formatting. One useful variation is `u.r`. It prints right-justified unsigned
    numbers `(n d -- )`, with *n* the number and *d* the width of the field. For example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we create a small array, `x`, with five numbers. Next, we define `aligned`
    to iterate through the array using `u.r` to display each number.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The word `key` reads a key from the user and pushes its character code on the
    stack. The analogous output word is `emit`, which takes the character code on
    the stack and displays it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The word `alpha` displays the alphabet using `emit` to output the characters.
    We’ve also introduced `[char]`, which is used during compilation to take the next
    character token, which here is `A`, and push its code on the stack. We could just
    as easily have used `65` instead of `[char] A`, as that is the ASCII code for
    “A.”
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a string of input from the user, use `accept`, which expects two values
    on the stack: the address of where the string should go and the maximum number
    of characters to input.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`accept` returns the number of characters actually entered. The buffer, `str`
    , now holds the text. To see it, use `type`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This also expects the address and count on the stack.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Creating a special buffer for input is a bit tedious, so Forth provides `pad`,
    a pre-allocated buffer of at least 84 characters (for gforth). Let’s use `pad`
    to learn how to input numbers instead of strings.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first line reads a character string of up to 80 characters and puts it in
    `pad`. Recall that `accept` returns the actual number of characters read, which
    is used in the next line.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The second line puts the address of `pad` on the stack, swaps to make the number
    of characters entered the top stack item, and calls `evaluate` to interpret the
    string as a number.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: We could spend many more pages describing all the various, sometimes quirky,
    input and output options Forth provides, but the examples discussed so far are
    a good start.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**Square Root Redux**'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll make good on a promise made earlier in the chapter. While
    discussing `dsqr` above, we said we’d develop a better method for finding integer
    square roots. To see that we can, let’s do it now.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '`dsqr` found the square root of an integer by testing all options to see which
    one was the square root. Although this approach works, it’s at first blush quite
    computationally inefficient. Instead, let’s try an implementation based on Equation
    4.1:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/04eqa01.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: This equation says that the sum of the first *n* odd numbers is *n*². Therefore,
    if we count the number of times an increasing odd number can be subtracted from
    another number, we’ll have an estimate of the square root of that number.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-5](ch04.xhtml#ch04list5) implements the algorithm implied by Equation
    4.1.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 4-5: Integer square root in Forth*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The stack contains *n*, the number whose square root is sought, and *x*, an
    ever-increasing odd number, first 1, then 3, 5, 7, and so on. Each iteration sets
    *n* ←*n – x* and *x* ←*x* + 2\. When *n* is less than or equal to 0, the loop
    ends. To get the square root, we count the number of passes through the loop and
    use the return stack to hold the counter, initializing it with `0 >r` and incrementing
    it with `r> 1+ >r`. When the loop ends, *n* and *x* are dropped, and the count
    is returned.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: A few examples demonstrate that `sqrt` works as advertised (with 7 as the estimated
    square root of 42).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Surely, `sqrt` is a better option than `dsqr` from [Listing 4-2](ch04.xhtml#ch04list2).
    Let’s set up a test and see. The code we want is in the *examples* directory in
    the file *sqrt.4th*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Listing 4-6: Testing sqrt and dsqr*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-6](ch04.xhtml#ch04list6) presents the relevant portion of *sqrt.4th*.
    The file first defines `sqrt` and `dsqr` (not shown) before defining a simple
    32-bit linear congruential pseudorandom number generator. The word `random` takes
    an upper limit, which is never returned, and replies with a random integer in
    the range [0, *n*).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Gforth uses `utime` to return a double-precision (128-bit) time value, the lower
    64 bits of which become the seed for the random number generator. A copy of the
    seed is kept in `X` as well so we can repeat the sequence later.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Two short words come next: `run0` and `run1`. Both calculate the square root
    of 100,000 random values in [1,10⁶], each of which is a perfect square. We don’t
    actually want the answers; we’re only interested in how long the calculation takes,
    so each square root is immediately discarded (`drop`). Next, `run0` uses `sqrt`
    and `run1` uses `dsqr`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The `main` word grabs the start time, leaving it on the stack, calls `run0`,
    and prints the time it takes to run in microseconds (`2swap d- d.`). It then resets
    the pseudorandom seed and repeats the calculation using `run1`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Executing *sqrt.4th* 10 times (`gforth sqrt.4th`) gives us the following mean
    runtimes for the two square root methods.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Time is now in seconds. Clearly, our intuition was incorrect. The more elegant
    algorithm takes about 1.5 times longer to execute, on average, than the brute-force
    method. This reminds me of physicist Ludwig Boltzmann’s famous quote: “If you
    are out to describe the truth, leave elegance to the tailor.” In this case, elegance
    loses out to raw computing power. It is simply faster to check all possibilities
    compared to the number of calculations and stack manipulations necessary to implement
    the subtraction method.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Is this the final word, though? There is one more algorithm we can try: Newton’s
    method. Newton’s method finds the roots of equations, the values of *x* that make
    the equation zero. If the equation is *x*² *– n*, then it’s clear this equation
    is zero when ![Image](Images/f00120.jpg).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Newton’s method is iterative based on an initial guess. It is powerful and converges
    quickly. Equation 4.2 shows us how to iterate with
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/04eqa02.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: for some initial guess, *x*[0] = *n*/2.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The code we need, also in *sqrt.4th*, is
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The word `step` performs one update step (Equation 4.2) with *n* and *x*[*i*]
    on the stack as input and *n*, *x*[*i*], *x*[*i*+1] as output. The `if` handles
    things if *x*[*i*] is 0.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '`newton` performs the iterations for as long as *x*[*i*+1] < *x*[*i*]. The
    first `dup 2/` sets the initial guess, *x*[0]. The body of the loop keeps *x*[*i*+1]
    as the new *x*[*i*] and then takes another step. After the loop, the last *x*[*i*+1]
    is dropped, along with *n*, leaving only *x*[*i*] as the answer.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Running `newton` 10 times lets us complete our list of average runtimes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We have a clear winner. Newton’s method is, on average, an order of magnitude
    faster than the brute force method. Boltzmann is wrong in this case; elegance
    and truth do go together.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What should we make of Forth? It’s definitely a curious language, but with its
    own charm. However, it seems best suited to a computing environment that is largely
    bygone. Figuring out how to manipulate the stack to accomplish what can be done
    in a simple statement or two in other languages is both frustrating and rewarding,
    but not particularly practical for day-to-day use. Forth’s learning curve is rather
    high, though experts can do amazing things with it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Because the code can be difficult to read, Forth is often characterized as a
    “write-only” programming language. Expert practitioners will disagree, and strict
    adherence to Forth style guidelines might mitigate some of the effects, but the
    charge is not without merit.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Back in the Introduction, you can see [Figure 1](ch00.xhtml#ch00fig1), which
    shows a functional brain imaging system I wrote in Forth for the Macintosh nearly
    25 years ago. It worked well, and I used it often. Now, some 25 years later, thanks
    to the power of open source emulators like BasiliskII, I was able to run the code
    and pull out the source. Here’s the code for accessing a single pixel of what
    amounts to a 3D block of data, a time series of magnetic resonance images.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'I agree that this probably deserves the label of write-only code. The comments
    explain what is happening, but I doubt anyone would say it’s easy to read. For
    comparison purposes, here’s how to do the same thing in Python with NumPy: `n
    = images[z,x,y]`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Lest readers think me unfair in my criticism, I still use Forth for different
    projects, usually to simulate the small microcontrollers that a larger system
    communicates with via RS-232 serial. Forth works well in this case, even on old
    Apple II computers.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The Forth words of this chapter took time and some effort with pen and paper
    to work out. However, that adds to the charm of achieving success with the language,
    even as it subtracts from the practical utility.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Forth’s popularity has definitely waned in recent years. However, the embedded
    development world still holds a place for Forth. There are small, single-board
    computers that run Forth as well as C, but they are few and far between. Increasingly,
    the embedded world is moving to tiny computers supporting more modern languages.
    Later in this book, for example, we’ll use the BBC micro:bit, which uses Python
    as its primary language, though hobbyists have developed a version of Forth that
    runs on the micro:bit. Full-blown Linux environments for small boards, like the
    Raspberry Pi Zero and BeagleBoard, are common. The world that motivated the development
    of Forth has changed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: So why consider Forth?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Forth is a perfect exemplar for what this book intends to present to
    you: an opportunity to look at programming in a new light.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: To succeed with Forth, you must think not only at the higher level of algorithm,
    though that is still necessary, but also at the lower level of *how* each algorithm
    step can be implemented, in minute detail.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Forth is close to what the computer is doing and not abstracted away from it
    like Python or Java. Bytes, addresses, order of operations on a stack, and how
    much limited dictionary memory is available all require a different kind of thinking,
    a more parsimonious approach to programming.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Those bitten by the Forth bug seldom recover. I recall many times reading posts
    on the old comp.lang.forth newsgroup (remember those?) that were almost spiritual
    in their expression of the joy one might feel when working with Forth. A tad excessive,
    perhaps, but there is definitely a joy to using Forth. Please do continue to play
    with the language.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced Forth, a unique language with a long history. We explored
    the language, how it works, its programming model, and its philosophy. We looked
    at some examples and saw that Forth is often implemented in Forth, building itself
    by pulling itself up by its bootstraps.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Thinking in Forth takes time and effort. Indeed, *Thinking FORTH* is the name
    of a classic Forth text by Leo Brodie (*[http://thinking-forth.sourceforge.net/](http://thinking-forth.sourceforge.net/)*).
    Take a look. If you want, you might also take a gander at Brodie’s *Starting FORTH*
    (*[http://www.exemark.com/FORTH/StartingFORTHfromForthWebsitev9_2013_12_24.pdf](http://www.exemark.com/FORTH/StartingFORTHfromForthWebsitev9_2013_12_24.pdf)*).
    Between these two books, you’ll get a thorough understanding of what it means
    to work with Forth.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time for something completely different. We leave the low-level world
    of Forth behind and move into the oddly wonderful world of text processing with
    SNOBOL.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
