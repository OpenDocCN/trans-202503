<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch5"><span epub:type="pagebreak" id="page_51"/><span class="big">5</span><br/>WORKING WITH LISTS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">People naturally make lists. Whether it’s a bucket list, shopping list, or list of top ten favorite books, an ordered sequence of items that share something in common sits easy on the brain. The history of functional programming is entwined with that of lists. The early functional language Lisp even has a name that is short for “list processor.” In Haskell, lists are just as important because the way we think about iteration in functional programming is often in terms of constructing a list and then using it to produce the result we want.</p>&#13;
<p class="indent">In this chapter, we’ll learn about lists and the functions that work with them. We’ll start off with list basics, such as how to construct a list, how to select a particular element of a list, and how to concatenate lists. We’ll then see how to give a type to a list. Lists of numbers have a special role to play. There is special syntax for arithmetic sequences, and there are multiple Prelude functions for working with lists of numbers. After that, we’ll introduce the idea of type variables. We’ll take a short diversion to talk about type conversion before introducing list comprehension, a very useful way to form <span epub:type="pagebreak" id="page_52"/>new lists from old. We’ll end the chapter with pattern matching, identifying the data constructors for the list type.</p>&#13;
<h3 class="h3" id="ch5lev1">List Basics</h3>&#13;
<p class="noindent">A <em>list</em> in Haskell is an ordered sequence of data, all with the same type. Here is an example of a list:</p>&#13;
<pre>physicists :: [String]&#13;
physicists = ["Einstein","Newton","Maxwell"]</pre>&#13;
<p class="indent">The type <code>[String]</code> indicates that <code>physicists</code> is a list of <code>String</code>s.</p>&#13;
<p class="indent">Square brackets around the type indicate a list. A list with type <code>[String]</code> can have any number of items (including zero), but each item must have type <code>String</code>. In the second line, we define physicists by enclosing its elements in square brackets and separating the elements by commas. The empty list is denoted as [].</p>&#13;
<p class="indent">Using the type synonym</p>&#13;
<pre>type R = Double</pre>&#13;
<p class="noindent">here is a list of real numbers:</p>&#13;
<pre>velocities :: [R]&#13;
velocities = [0,-9.8,-19.6,-29.4]</pre>&#13;
<h4 class="h4" id="ch5lev2">Selecting an Element from a List</h4>&#13;
<p class="noindent">The list element operator !! can be used to learn the value of an individual element of a list. We use the operator between the list and the place, or <em>index</em>, of the element we want. The first element of a list is considered to be element number 0.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l Lists.hs</span>&#13;
[1 of 1] Compiling Main            ( Lists.hs, interpreted )&#13;
Ok, one module loaded.&#13;
*Main&gt; <span class="codestrong1">velocities !! 0</span>&#13;
0.0&#13;
*Main&gt; <span class="codestrong1">velocities !! 1</span>&#13;
-9.8&#13;
*Main&gt; <span class="codestrong1">velocities !! 3</span>&#13;
-29.4</pre>&#13;
<p class="indent">The first command loads the file <em>Lists.hs</em>, which contains the code in this chapter. This file, along with code files for other chapters, is available at <a href="https://lpfp.io">https://lpfp.io</a>. After the file is loaded, we can make reference to velocities, a name that would be unknown to GHCi before we loaded the file.</p>&#13;
<h4 class="h4" id="ch5lev3"><span epub:type="pagebreak" id="page_53"/>Concatenating Lists</h4>&#13;
<p class="noindent">Lists of the same type can be concatenated with the ++ operator shown in <a href="ch01.xhtml#ch1tab2">Table 1-2</a>. For example, if we have another list that has type <code>[R]</code>,</p>&#13;
<pre>moreVelocities :: [R]&#13;
moreVelocities = [-39.2,-49.0]</pre>&#13;
<p class="noindent">we can concatenate <code>velocities</code> with this list:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">velocities ++ moreVelocities</span>&#13;
[0.0,-9.8,-19.6,-29.4,-39.2,-49.0]&#13;
*Main&gt; <span class="codestrong1">:t velocities ++ moreVelocities</span>&#13;
velocities ++ moreVelocities :: [R]</pre>&#13;
<p class="indent">Notice that the concatenation has the same type that each component list has, in this case <code>[R]</code>.</p>&#13;
<p class="indent">Attempting to concatenate lists with different underlying types produces an error. For example, <code>physicists ++ velocities</code> gives an error.</p>&#13;
<pre>   *Main&gt; <span class="codestrong1">physicists ++ velocities</span>&#13;
&#13;
<span class="ent">➊</span> &lt;interactive&gt;:7:15: error:&#13;
   <span class="ent">➋</span> • Couldn't match type Double with [Char]&#13;
     <span class="ent">➌</span> Expected type: [String]&#13;
       <span class="ent">➍</span> Actual type: [R]&#13;
   <span class="ent">➎</span> • In the second argument of (++), namely velocities&#13;
        In the expression: physicists ++ velocities&#13;
        In an equation for it: it = physicists ++ velocities</pre>&#13;
<p class="indent">This sort of error is called a <em>type error</em>. While <code>physicists</code> has a well-defined type, namely <code>[String]</code>, and <code>velocities</code> has a well-defined type, namely <code>[R]</code>, the expression <code>physicists ++ velocities</code> cannot be given a well-defined type. A type error results when we attempt to apply a function (in this case, the function is the concatenation operator <code>++</code>) that expects input of one type to a value that actually has a different type. The concatenation operator expects its second argument to have type <code>[String]</code> because <code>physicists</code> has type <code>[String]</code>. However, we gave a second argument of <code>velocities</code>, which has type <code>[R]</code> and thus does not match <code>[String]</code>. In <a href="ch06.xhtml">Chapter 6</a>, we will discuss the type of the concatenation operator.</p>&#13;
<p class="indent">Let’s try to understand the error message. The word “interactive” <span class="ent">➊</span> indicates that the error occurred at the GHCi prompt, rather than in a source code file. The numbers <span class="ent">➊</span> are the line number and column number where the error occurred. This is useful information for an error in a source code file, but it is not really needed for an error at the GHCi prompt. The text “Couldn’t match type” <span class="ent">➋</span> indicates a type error. The types that don’t match are <code>Double</code> and <code>[Char]</code> <span class="ent">➋</span>. Since <code>R</code> is a type synonym for <code>Double</code> and <code>String</code> is a type synonym for <code>[Char]</code>, as we will see later in the chapter, the compiler tells us that <code>R</code> and <code>String</code> do not match.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_54"/>Next, the compiler tells us that a function expected an expression with type <code>[String]</code> (the “Expected type”) <span class="ent">➌</span> but was actually given an expression with type <code>[R]</code> (the “Actual type”) <span class="ent">➍</span>. The error message then tells us that the location of this discrepancy is the second argument of the <code>++</code> operator <span class="ent">➎</span>. It’s useful to be able to read type errors like this. There is no shame in making such an error. The compiler is helping us by checking that what we say makes sense. In physics, we can use Haskell’s type system to great advantage by assigning different types to different conceptual entities. We know, for example, that it makes no sense to add a number to a vector. By giving numbers and vectors different types, we engage Haskell’s type system to help us ensure that the code we write does not attempt to add a number to a vector.</p>&#13;
<p class="indent">Any number of lists of the same type can be concatenated with the <code>concat</code> function. If we define a list of strings,</p>&#13;
<pre>shortWords :: [String]&#13;
shortWords = ["am","I","to"]</pre>&#13;
<p class="noindent">then we can make the following concatenation:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">concat [shortWords,physicists,shortWords]</span>&#13;
["am","I","to","Einstein","Newton","Maxwell","am","I","to"]</pre>&#13;
<h4 class="h4" id="ch5lev4">Arithmetic Sequences</h4>&#13;
<p class="noindent">An <em>arithmetic sequence</em> is a list formed with two dots (..), like so:</p>&#13;
<pre>ns :: [Int]&#13;
ns = [0..10]</pre>&#13;
<p class="indent">The list ns contains the integers from 0 to 10. I chose the name ns because it looks like the plural of the name n, which seems like a good name for an integer. It is a common style in Haskell programs to use names that end in s for lists, but it is by no means necessary.</p>&#13;
<p class="indent">If we enter a list into GHCi, GHCi will evaluate each element and return the list of evaluated elements:</p>&#13;
<pre>*Main&gt;  [0,2,5+3]&#13;
[0,2,8]</pre>&#13;
<p class="indent">If we give GHCi an arithmetic sequence, GHCi will expand the sequence for us:</p>&#13;
<pre>*Main&gt;  [0..10]&#13;
[0,1,2,3,4,5,6,7,8,9,10]</pre>&#13;
<p class="indent">A second form of arithmetic sequence allows us to increment from one term to the next with a value that is different from 1:</p>&#13;
<pre>*Main&gt;  [-2,-1.5..1]&#13;
[-2.0,-1.5,-1.0,-0.5,0.0,0.5,1.0]</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_55"/>In this second form, we specify the first, second, and last entries of the desired list. We can even do a decreasing list:</p>&#13;
<pre>*Main&gt;  [10,9.5..8]&#13;
[10.0,9.5,9.0,8.5,8.0]</pre>&#13;
<h4 class="h4" id="ch5lev5">List Types</h4>&#13;
<p class="noindent"><em>List types</em> are a second way to form a new type from an existing type (the first way being function types, as we saw in “Function Types” in <a href="ch03.xhtml">Chapter 3</a>). Given any type <code>a</code> (<code>Int</code>, <code>Integer</code>, <code>Double</code>, and so on), there is a type <code>[a]</code> for lists with elements of type <code>a</code>.</p>&#13;
<p class="indent">You can, for example, make a list of functions. Recall the square function we defined in <a href="ch02.xhtml">Chapter 2</a>.</p>&#13;
<pre>square :: R -&gt; R&#13;
square x = x**2</pre>&#13;
<p class="indent">We can define the following list, where cos and sin are functions defined in the Haskell Prelude:</p>&#13;
<pre>funcs :: [R -&gt; R]&#13;
funcs = [cos,square,sin]</pre>&#13;
<p class="indent">Why would we want a list of functions? One reason will show up in <a href="ch11.xhtml">Chapter 11</a> when we meet a function that takes a list of functions and plots them all on the same set of axes. A second reason appears in <a href="ch14.xhtml">Chapter 14</a> when the forces that act on an object are functions of time or velocity. Our function for solving Newton’s second law will take a list of these force functions to describe the forces that act on the object.</p>&#13;
<h4 class="h4" id="ch5lev6">Functions for Lists of Numbers</h4>&#13;
<p class="noindent">Haskell has a few Prelude functions that work with lists of numbers. The first two are <code>sum</code> and <code>product</code>, shown in <a href="ch05.xhtml#ch5tab1">Table 5-1</a>. As you might expect from its name, <code>sum</code> returns the sum of the items in a list, returning <code>0</code> for the empty list. The function <code>product</code> returns the product of the items in a list, returning <code>1</code> for the empty list. The functions <code>maximum</code> and <code>minimum</code> return the largest and smallest items in a list, respectively, producing errors if you give them the empty list.</p>&#13;
<p class="tabcap" id="ch5tab1"><strong>Table 5-1:</strong> Functions for Lists of Numbers</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expression</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Evaluates to</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>sum [3,4,5]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>12</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>sum []</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>product [3,4,5]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>60</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>product []</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>maximum [4,5,-2,1]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>5</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>minimum [4,5,-2,1]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>-2</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch5lev7"><span epub:type="pagebreak" id="page_56"/>When Not to Use a List</h4>&#13;
<p class="noindent">There will be times when you want to “bundle together” expressions of different types. For example, we may wish to form pairs composed of a person’s name (a <code>String</code>) and age (an <code>Int</code>). A list is not the right structure to use for this job. All elements of a list must have the same type. In <a href="ch09.xhtml">Chapter 9</a>, we’ll learn about <em>tuples</em>, which are a good way to bundle together items of different types.</p>&#13;
<h3 class="h3" id="ch5lev8">Type Variables</h3>&#13;
<p class="noindent">In the previous section, we saw how the list element operator <code>!!</code> returns a specified element of a list. The list element operator doesn’t care what type of elements the list contains. We would write <code>physicists !! 2</code> to get the number-two element of <code>physicists</code> in the same way that we would write <code>velocities !! 2</code> to get the number-two element of velocities, even though the former list has type <code>[String]</code> while the latter list has type <code>[R]</code>.</p>&#13;
<p class="indent">There are other functions that also don’t care what element type a list has. <a href="ch05.xhtml#ch5tab2">Table 5-2</a> shows several such functions from the Prelude. The types of these functions are expressed in terms of a <em>type variable</em> (<code>a</code> in this case). A type variable must start with a lowercase letter and can stand for any type.</p>&#13;
<p class="tabcap" id="ch5tab2"><strong>Table 5-2:</strong> Some Prelude Functions for Working with Lists</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>head</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>[a] -&gt; a</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Returns first item of list</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>tail</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>[a] -&gt; [a]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Returns all but first item of list</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>last</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>[a] -&gt; a</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Returns last item of list</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>init</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>[a] -&gt; [a]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Returns all but last item of list</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>reverse</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>[a] -&gt; [a]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Reverses order of list</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>repeat</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> <code>a</code> <code>-&gt; [a]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Infinite list of a single item</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>cycle</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>::</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba"><code>[a] -&gt; [a]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">Infinite list repeating given list</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The function head returns the first element of a list. You can see some uses of head, as well as the other list functions, in <a href="ch05.xhtml#ch5tab3">Table 5-3</a>.</p>&#13;
<p class="tabcap" id="ch5tab3"><strong>Table 5-3:</strong> Use of List Functions</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Expression</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Evaluates to</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>head ["Gal","Jo","Isaac","Mike"]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>"Gal"</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>head [1, 2, 4, 8, 16]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>tail ["Gal","Jo","Isaac","Mike"]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>["Jo","Isaac","Mike"]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>tail [1, 2, 4, 8, 16]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>[2,4,8,16]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>last ["Gal","Jo","Isaac","Mike"]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>"Mike"</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>last [1, 2, 4, 8, 16]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>16</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>init ["Gal","Jo","Isaac","Mike"]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>["Gal","Jo","Isaac"]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>init [1, 2, 4, 8, 16]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>[1,2,4,8]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>length ["Gal","Jo","Isaac","Mike"]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>4</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>length [1, 2, 4, 8, 16]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">⇝</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>5</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_57"/>The function head can accept a list of type <code>[Double]</code>, a list of type <code>[Char]</code>, or a list of type <code>[Int]</code>. Because <code>head</code> doesn’t care about the type of the payload, the best way of expressing the type of input <code>head</code> takes is by using a type variable <code>a</code> to say that <code>head</code> accepts an input of type <code>[a]</code>. The same type variable <code>a</code> appears also in the output; the return type of <code>head</code> is <code>a</code>.</p>&#13;
<p class="indent">You can see a type variable if you ask GHCi for the type of the empty list.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t []</span>&#13;
[] :: [a]</pre>&#13;
<p class="indent">Let’s look at a few more of the functions from <a href="ch05.xhtml#ch5tab2">Table 5-2</a>. The tail function returns everything but the first element of a list. The function last returns the last element of a list. The function init returns everything except the last element. The book <em>Learn You a Haskell for Great Good!</em> has a cute picture of a caterpillar (<a href="http://learnyouahaskell.com/starting-out#an-intro-to-lists">http://learnyouahaskell.com/starting-out#an-intro-to-lists</a>) that visually explains these list functions. <a href="ch05.xhtml#ch5tab2">Table 5-2</a> gives the types of these functions, and <a href="ch05.xhtml#ch5tab3">Table 5-3</a> shows some examples of how to use them.</p>&#13;
<p class="indent">Having introduced type variables, we are in a good position to take a short diversion into type conversion.</p>&#13;
<h3 class="h3" id="ch5lev9">Type Conversion</h3>&#13;
<p class="noindent">GHCi appears to allow a <code>Double</code> to be divided by an <code>Int</code>:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">0.4 / 4</span>&#13;
0.1</pre>&#13;
<p class="indent">However, that is not what is happening here. The number <code>0.4</code> can be a <code>Float</code> or a <code>Double</code>. The number <code>4</code> can be an <code>Int</code>, <code>Integer</code>, <code>Float</code>, or <code>Double</code>. The division operator demands that the types of the two numbers being divided are the same. In this case, both must be interpreted as <code>Float</code> or both as <code>Double</code>. Addition, subtraction, multiplication, and division require that the two expressions being combined have the same type. In terms of the type variables we introduced earlier, addition, subtraction, multiplication, and division all have type <code>a -&gt; a -&gt; a</code>, meaning that each of the two numbers being combined must have the same type <code>a</code>, and then the result of the operation will also have type <code>a</code>. (The full story of the types of arithmetic operations like addition is more complex. You can’t add two <code>String</code>s, but a function with type <code>a -&gt; a -&gt; a</code> must be able to accept two <code>String</code>s as input and produce a <code>String</code> as output. The missing piece involves the idea of type classes, which we’ll discuss in <a href="ch08.xhtml">Chapter 8</a>.)</p>&#13;
<p class="indent">The Haskell compiler will refuse to divide a <code>Double</code> by an <code>Int</code>. If we give explicit types to some numbers,</p>&#13;
<pre>oneDouble :: Double&#13;
oneDouble = 1&#13;
&#13;
twoInt :: Int&#13;
twoInt = 2</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_58"/>we can see the error the compiler produces:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">oneDouble / twoInt</span>&#13;
&#13;
&lt;interactive&gt;:42:13: error:&#13;
    • Couldn't match expected type Double with actual type Int&#13;
    • In the second argument of (/), namely twoInt&#13;
      In the expression: oneDouble / twoInt&#13;
      In an equation for it: it = oneDouble / twoInt</pre>&#13;
<p class="indent">This is another example of a type error. The first input to the division is a <code>Double</code>, so the “expected type” for the second argument of division is also <code>Double</code>. The “actual type” we supplied is <code>Int</code>, which doesn’t match. The compiler will similarly refuse to add a <code>Float</code> to a <code>Double</code>.</p>&#13;
<p class="indent">The fact that division can occur only between numbers with the same type can be irritating, especially if we expect the compiler to automatically convert one type into another. The solution is to use a type-conversion function to convert, say, an <code>Int</code> to a <code>Double</code>.</p>&#13;
<p class="indent">There are two important type-conversion functions you may need to use from time to time. The first is <code>fromIntegral</code>, which converts an <code>Int</code> or <code>Integer</code> to some other kind of number. The compiler can usually figure out which type to convert to, but it demands your explicit permission through the use of this function. The second conversion function is <code>realToFrac</code>, which converts a <code>Float</code> to a <code>Double</code> or a <code>Double</code> to a <code>Float</code>. Again, you do not usually need to explicitly specify the type to convert to; you just need to give permission for the conversion to be done. Here is an example:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">oneDouble / fromIntegral twoInt</span>&#13;
0.5</pre>&#13;
<p class="indent">The rationale behind the requirement for conversion is that, in Haskell, most errors are type errors. Type errors often indicate that we haven’t completely thought through the code we’ve written. It could be that dividing a <code>Double</code> by an <code>Int</code> is not what we intended and we are grateful to the type checker for producing an error rather than quietly converting the <code>Int</code> to a <code>Double</code>.</p>&#13;
<p class="indent">This concludes our diversion into type conversion. We can now return to our regularly scheduled program, namely lists.</p>&#13;
<h3 class="h3" id="ch5lev10">The Length of Lists</h3>&#13;
<p class="noindent">The Prelude provides a function length that returns the number of items in a list.</p>&#13;
<pre>*Main&gt; <span class="codestrong1">length velocities</span>&#13;
4&#13;
*Main&gt; <span class="codestrong1">length ns</span>&#13;
11&#13;
&#13;
*Main&gt; <span class="codestrong1">length funcs</span>&#13;
3</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_59"/>In the early days of Haskell, length was a simple function with a simple type. The type of length was <code>[a] -&gt; Int</code>, meaning you could give length a list of anything, and it would give you back an integer. That was nice and simple. If we ask GHCi today for the type of length,</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t length</span>&#13;
length :: Foldable t =&gt; t a -&gt; Int</pre>&#13;
<p class="noindent">we see a more complex type. This type involves the idea of a <em>type class</em>, which we’ll explore in <a href="ch08.xhtml">Chapter 8</a>. But for now, we can make our own length function with the simple type <code>[a] -&gt; Int</code>:</p>&#13;
<pre>len :: [a] -&gt; Int&#13;
len = length</pre>&#13;
<p class="indent">If we look at the type of <code>len</code> in GHCi,</p>&#13;
<pre>*Main&gt; <span class="codestrong1">:t len</span>&#13;
len :: [a] -&gt; Int</pre>&#13;
<p class="noindent">we see the simple type that we want.</p>&#13;
<p class="indent">There is no great advantage to defining our own length function because we are free to use <code>length</code> even though it has a complicated type, but understanding the types of the functions we use gives us real insight into what we are doing. We want to understand the types of the functions we write and use, and we want them to be as simple as they can be. There will, of course, be trade-offs between simplicity and power. The decision of the Haskell designers to give the <code>length</code> function a more complicated type means that it can be used in a wider variety of situations. In this case, the designers made a decision favoring power over simplicity. We will often favor simplicity over power.</p>&#13;
<h3 class="h3" id="ch5lev11">A String Is a List of Characters</h3>&#13;
<p class="noindent">Now that I have introduced lists, I can tell you that a string in Haskell is nothing but a list of characters. In other words, the type <code>String</code> is exactly the same as the type <code>[Char]</code>; in fact, <code>String</code> is defined in the Haskell Prelude to be a type synonym for <code>[Char]</code> in exactly the same way that we defined <code>R</code> to be a type synonym for <code>Double</code>. Haskell provides some special syntax for strings, namely the ability to enclose a sequence of characters in double quotes to form a <code>String</code>. This is obviously more pleasant than requiring an explicit list of characters, such as <code>['W','h','y','?']</code>. You can ask GHCi whether this is the same as "Why?":</p>&#13;
<pre>*Main&gt;  <span class="codestrong1">['W','h','y','?'] == "Why?"</span>&#13;
True</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>GHCi responds with True, indicating that it regards these two expressions as identical.</p>&#13;
<p class="indent">The identity of the types <code>String</code> and <code>[Char]</code> also means that a string can be used in any function that expects a list of something. For example, we can use the function length on a string to tell us how many characters it has.</p>&#13;
<p class="indent">Readers who have some experience with programming may worry about the efficiency implications of representing strings as lists of characters. Rest assured that Haskell has some other options that are more efficient for programmers who need to process a lot of strings. However, for our purposes, we will not need to process a lot of strings, so the basic <code>String</code> type is just fine for us.</p>&#13;
<h3 class="h3" id="ch5lev12">List Comprehensions</h3>&#13;
<p class="noindent">Haskell offers a powerful way to make new lists out of old lists. Suppose you have a list of times (in seconds),</p>&#13;
<pre>ts :: [R]&#13;
ts = [0,0.1..6]</pre>&#13;
<p class="noindent">and you want to have a list of positions for a rock that you threw up in the air at 30 m/s, with each position corresponding to one of the times in the time list. In Exercise 2.2, you wrote a function <code>yRock30</code> to produce the position of the rock when given the time. Perhaps your function looked something like the following:</p>&#13;
<pre>yRock30 :: R -&gt; R&#13;
yRock30 t = 30 * t - 0.5 * 9.8 * t**2</pre>&#13;
<p class="indent">The code below produces the desired list of positions:</p>&#13;
<pre>xs :: [R]&#13;
xs = [yRock30 t | t &lt;- ts]</pre>&#13;
<p class="indent">The definition of <code>xs</code> is an example of a <em>list comprehension</em>. The syntax for a list comprehension consists of square brackets, a vertical bar, and a left arrow, as follows:</p>&#13;
<div class="imagec">[ function of <em>item</em> | <em>item</em> &gt;- <em>list</em> ]</div>&#13;
<p class="indent">This means that, given a function and a list, Haskell will compute that function for each item in the list and then form a list of the resulting values. In our example above, for each <code>t</code> in <code>ts</code>, Haskell will compute <code>yRock30 t</code> and form a list of these values. The list <code>xs</code> of positions will be the same length as the original list <code>ts</code> of times.</p>&#13;
<p class="indent">List comprehensions, in conjunction with the <code>sum</code> and <code>product</code> functions, allow us to write elegant Haskell expressions that mimic the sigma and pi notation in mathematics for sums and products. <a href="ch05.xhtml#ch5tab4">Table 5-4</a> shows the correspondence between mathematical and Haskell notations.</p>&#13;
<p class="tabcap" id="ch5tab4"><strong>Table 5-4:</strong> Sum and Product Notation in Haskell</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Mathematical notation</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Haskell notation</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"> <img class="inline" src="Images/061equ01.jpg" alt="Image" width="54" height="58"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>sum [f(i) | i &lt;- [m..n]]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"> <img class="inline" src="Images/061equ02.jpg" alt="Image" width="50" height="58"/></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>product [f(i) | i &lt;- [m..n]]</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch5lev13"><span epub:type="pagebreak" id="page_61"/>Infinite Lists</h3>&#13;
<p class="noindent">Haskell is a lazy language, meaning that it does not always evaluate everything in the order you might expect. Instead, it waits to see if values are needed before doing any actual work. Haskell’s laziness allows for the possibility of infinite lists. Of course, Haskell never actually creates an infinite list, but you can think of the list as infinite because Haskell is willing to continue down the list as far as it needs to. The list [1..] is an example of an infinite list. If you ask GHCi to show you this list, it will go on indefinitely. You can enter CTRL-C or something similar to stop the endless printing of numbers.</p>&#13;
<p class="indent">An infinite list can be convenient when you don’t know in advance exactly how much of a list you will want or need. For example, we might want to compute a list of positions of a particle at 0.01 s time increments. We may not know in advance the length of time over which we want this information. If we write our function so that it returns an infinite list of positions, the function will be simpler because it doesn’t need to know the total number of positions to calculate.</p>&#13;
<p class="indent">A good way to view the first several elements of an infinite list is with the <code>take</code> function. Try the following in GHCi:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">take 10 [3..]</span>&#13;
[3,4,5,6,7,8,9,10,11,12]</pre>&#13;
<p class="indent">GHCi shows you the first 10 elements of the infinite list [3..].</p>&#13;
<p class="indent">Two Prelude functions from <a href="ch05.xhtml#ch5tab2">Table 5-2</a> create infinite lists. The function repeat takes a single expression and returns an infinite list with the expression repeated an infinite number of times. By itself, this function doesn’t seem very useful, but in combination with other functions and techniques we’ll learn about later, it can be useful.</p>&#13;
<p class="indent">The Prelude function cycle takes a (finite) list and returns the infinite list formed by cycling through the elements of the finite list over and over again. You can get an idea of what cycle does by asking GHCi to show you the first several elements of such a list, like the following:</p>&#13;
<pre>*Main&gt; <span class="codestrong1">take 10 (cycle [4,7,8])</span>&#13;
[4,7,8,4,7,8,4,7,8,4]</pre>&#13;
<h3 class="h3" id="ch5lev14"><span epub:type="pagebreak" id="page_62"/>List Constructors and Pattern Matching</h3>&#13;
<p class="noindent">The colon (<code>:</code>) operator (called <em>cons</em> for historical reasons having to do with the early functional programming language Lisp) from <a href="ch01.xhtml#ch1tab2">Table 1-2</a> can be used to attach a single item of type <code>a</code> to a list with type <code>[a]</code>. For example, 3:[<a href="bib.xhtml#bib4">4</a>,<a href="bib.xhtml#bib5">5</a>] is the same as [<a href="bib.xhtml#bib3">3</a>,<a href="bib.xhtml#bib4">4</a>,<a href="bib.xhtml#bib5">5</a>], and 3:[] is the same as [<a href="bib.xhtml#bib3">3</a>].</p>&#13;
<p class="indent">In <a href="ch03.xhtml">Chapter 3</a>, we saw how we could use pattern matching on the <code>Bool</code> type. The <code>Bool</code> type has two patterns, <code>False</code> and <code>True</code>. The list type also has two patterns. A list is either the empty list [] or the cons x:xs of an item x with a list xs. Every list is exactly one of these two mutually exclusive and exhaustive possibilities. In fact, Haskell internally regards lists as being formed out of the two <em>constructors</em> (also called <em>data constructors</em>,) [] and :. Each type in Haskell has one or more data constructors that are used to form expressions of that type. Therefore, a data constructor is a way of making an expression of a particular type. When we define our own types in <a href="ch10.xhtml">Chapter 10</a>, we will see that data constructors are an essential part of the definition for the type.</p>&#13;
<p class="indent">The list we think of as [<a href="bib.xhtml#bib13">13</a>,<a href="bib.xhtml#bib6">6</a>,<a href="bib.xhtml#bib4">4</a>] is represented internally as 13:6:4:[], which means 13:(6:(4:[])) when we allow for the right associativity of :. <a href="ch05.xhtml#ch5tab5">Table 5-5</a> shows the data constructors for the Boolean and list types.</p>&#13;
<p class="tabcap" id="ch5tab5"><strong>Table 5-5:</strong> Data Constructors for the Boolean and List Types</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Data constructors</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>Bool</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>False</code>, <code>True</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>[a]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>[]</code>, <code>:</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The fundamental mechanism for pattern matching in Haskell is the <code>case</code>-<code>of</code> construction. If we are pattern matching on a <code>Bool</code>, there will be two cases corresponding to the two data constructors <code>False</code> and <code>True</code> from which all values of type <code>Bool</code> are constructed. If we are pattern matching on a list, there will be two cases corresponding to the two data constructors <code>[]</code> and <code>:</code> from which all lists are constructed.</p>&#13;
<p class="indent">Let’s look at an example of defining a function on lists using pattern matching. Let’s define a function sndItem that returns the second element of a list, or gives an error if the list has fewer than two elements. The idea is that sndItem [<a href="bib.xhtml#bib8">8</a>,<a href="bib.xhtml#bib6">6</a>,<a href="bib.xhtml#bib7">7</a>,<a href="bib.xhtml#bib5">5</a>] should return 6. Our first definition uses the <code>case-of</code> construction:</p>&#13;
<pre>sndItem :: [a] -&gt; a&#13;
sndItem ys = case ys of&#13;
               []     -&gt; error "Empty list has no second element."&#13;
               (x:xs) -&gt; if null xs&#13;
                         then error "1-item list has no 2nd item."&#13;
                         else head xs</pre>&#13;
<p class="indent">In the case where <code>ys</code> is the empty list, we use the error function, which has type <code>[Char] -&gt; a</code>, meaning that it takes a string as input and can serve as <span epub:type="pagebreak" id="page_63"/>any type. The error function halts execution and returns the given string as a message.</p>&#13;
<p class="indent">In the case where the input is the cons of an item and a list, the notation <code>(x:xs)</code> indicates that the item will be assigned the name <code>x</code> and the list will be assigned the name <code>xs</code> for use in the body of the definition (the body is the expression to the right of the arrow). For example, if <code>ys</code> is the list <code>[1879,3,14]</code>, then <code>x</code> will be assigned the value <code>1879</code> and <code>xs</code> will be assigned the value <code>[3,14]</code>. This assignment of the names <code>x</code> and <code>xs</code> is <em>local</em>, meaning that it only holds in the body of the definition. Outside of the definition body, the names <code>x</code> and <code>xs</code> may have another meaning or no meaning at all.</p>&#13;
<p class="indent">The expression <code>null xs</code> returns <code>True</code> if <code>xs</code> is empty and <code>False</code> otherwise. If <code>xs</code> is empty, the original list <code>x:xs</code> had only one element, so we give the one-element error. If <code>xs</code> is not empty, its first element (its <code>head</code>) is the second element of the original list, and hence the value we should return.</p>&#13;
<p class="indent">If the value we are pattern matching (<code>ys</code> from earlier) is also an input to a function, we can do pattern matching directly on the input rather than using the <code>case-of</code> construction.</p>&#13;
<pre>sndItem2 :: [a] -&gt; a&#13;
sndItem2 []     = error "Empty list has no second element."&#13;
sndItem2 (x:xs) = if null xs&#13;
                  then error "1-item list has no 2nd item."&#13;
                  else head xs</pre>&#13;
<p class="indent">Notice that we no longer need the local variable <code>ys</code> in <code>sndItem2</code>.</p>&#13;
<p class="indent">In pattern matching on the input, the definition is expressed in parts, with one part for each data constructor of the input type. In this case, the input type is a list, and the data constructors for a list are the empty list and cons, so part 1 of the definition defines <code>sndItem2</code> for the empty list and part 2 of the definition defines the function for the cons of an item with a list.</p>&#13;
<p class="indent">We can make an even nicer function definition by going one step further and using additional pattern matching on the xs list in sndItem. Let’s define a function <code>sndItem3</code> that does the same thing as <code>sndItem</code> but uses even more pattern matching:</p>&#13;
<pre>sndItem3 :: [a] -&gt; a&#13;
sndItem3 ys = case ys of&#13;
                []      -&gt; error "Empty list has no second element."&#13;
                (x:[])  -&gt; error "1-item list has no 2nd item."&#13;
                (x:z:_) -&gt; z</pre>&#13;
<p class="indent">Case 1 of <code>sndItem</code> remains unchanged. Case 2 of <code>sndItem</code> splits into two subcases, depending on whether the <code>xs</code> in <code>sndItem</code> is the empty list or the cons of an item with a list.</p>&#13;
<p class="indent">Notice the underscore character (<code>_</code>) in the last line. Names that begin with an underscore in Haskell are names that we never intend to refer to. We could have written (x:z:zs) in place of <code>(x:z:_)</code>. The underscore means that we can’t be bothered to give the list a real name because we have no intention of using it or referring to it again. We make no reference to this <span epub:type="pagebreak" id="page_64"/>list in the definition body, so there is no motivation to give it a proper name. Sometimes it is helpful to the code reader (who might be you) to give a name to something that never gets used. If you want to give something a name <em>and</em> signal that it never gets used, you can use a name that begins with an underscore, such as <code>_zs</code>. Note finally that the cons operator (:) is right associative, so the expression <code>x:z:_</code> is read as <code>x:(z:_)</code>.</p>&#13;
<p class="indent">Because the value we are pattern matching is the input to our function, we can do pattern matching on the input rather than use the <code>case-of</code> construction.</p>&#13;
<pre>sndItem4 :: [a] -&gt; a&#13;
sndItem4 []      = error "Empty list has no second element."&#13;
sndItem4 (x:[])  = error "1-item list has no 2nd item."&#13;
sndItem4 (x:z:_) = z</pre>&#13;
<h3 class="h3" id="ch5lev15">Summary</h3>&#13;
<p class="noindent">This chapter introduced lists. Each member of a list must have the same type. Square brackets serve two roles for lists. A type enclosed in square brackets is a list type, and a sequence of items enclosed in square brackets and separated by commas forms a list. A type variable serves as a placeholder for any type. Several list functions have types with type variables because they don’t care about the underlying type of a list. Since addition, subtraction, multiplication, and division only work between numbers with the same type in Haskell, we introduced two type-conversion functions for situations in which conversion is necessary. A list comprehension is a method to form a new list from an existing list. Haskell allows for infinite lists because it is a lazy language. Lists are formed from two constructors: the empty list and the cons operator. Pattern matching can be used to define a function that takes a list as input. There are two patterns that a list may have: either it is the empty list or it is the cons of an element and another list.</p>&#13;
<h3 class="h3" id="ch5lev16">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 5.1.</strong> Give an abbreviation for the following list using the double dot (<code>..</code>) notation. Use GHCi to check that your expression does the right thing.</p>&#13;
<pre>numbers :: [R]&#13;
numbers = [-2.0,-1.2,-0.4,0.4,1.2,2.0]</pre>&#13;
<p class="noindentts"><strong>Exercise 5.2.</strong> Write a function <code>sndItem0 :: [a] -&gt; a</code> that does the same thing as sndItem but does not use any pattern matching.</p>&#13;
<p class="noindentts"><strong>Exercise 5.3.</strong> What is the type of the following expression?</p>&#13;
<pre>length "Hello, world!"</pre>&#13;
<p class="indent">What is the value of the expression?</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_65"/><strong>Exercise 5.4.</strong> Write a function with type <code>Int -&gt; [Int]</code> and describe in words what it does.</p>&#13;
<p class="noindentts"><strong>Exercise 5.5.</strong> Write a function <code>null'</code> that does the same thing as the Prelude function null. Use the Prelude function length in your definition of <code>null'</code> but do not use the function null.</p>&#13;
<p class="noindentts"><strong>Exercise 5.6.</strong> Write a function <code>last'</code> that does the same thing as the Prelude function last. Use the Prelude functions head and reverse in your definition of <code>last'</code> but do not use the function last.</p>&#13;
<p class="noindentts"><strong>Exercise 5.7.</strong> Write a function <code>palindrome :: String -&gt; Bool</code> that returns True if the input string is a palindrome (a word like <em>radar</em> that is spelled the same backward as it is forward) and False otherwise.</p>&#13;
<p class="noindentts"><strong>Exercise 5.8.</strong> What are the first five elements of the infinite list [9,1..]?</p>&#13;
<p class="noindentts"><strong>Exercise 5.9.</strong> Write a function <code>cycle'</code> that does the same thing as the Prelude function cycle. Use the Prelude functions repeat and concat in your definition of <code>cycle'</code> but do not use the function cycle.</p>&#13;
<p class="noindentts"><strong>Exercise 5.10.</strong> Which of the following are valid Haskell expressions? If an expression is valid, give its type. If an expression is not valid, say what is wrong with it.</p>&#13;
<p class="alphats">(a) <code>["hello",42]</code></p>&#13;
<p class="alphats">(b) <code>['h',"ello"]</code></p>&#13;
<p class="alphats">(c) <code>['a','b','c']</code></p>&#13;
<p class="alphats">(d) <code>length ['w','h','o']</code></p>&#13;
<p class="alphats">(e) <code>length "hello"</code></p>&#13;
<p class="alphats">(f) <code>reverse</code> (Hint: this is a valid Haskell expression, and it has a well-defined type, even though GHCi cannot print the expression.)</p>&#13;
<p class="noindentts"><strong>Exercise 5.11.</strong> In an arithmetic sequence, if the specified last element does not occur in the sequence,</p>&#13;
<pre>*Main&gt;  [0,3..8]&#13;
[0,3,6]&#13;
*Main&gt;  [0,3..8.0]&#13;
[0.0,3.0,6.0,9.0]</pre>&#13;
<p class="noindentts">the result seems to depend on whether you are using whole numbers. Explore this and try to find a general rule for where an arithmetic sequence will end.</p>&#13;
<p class="noindentts"><strong>Exercise 5.12.</strong> In the 1730s, Leonhard Euler showed that</p>&#13;
<div class="imagec"><img src="Images/065equ01.jpg" alt="Image" width="107" height="61"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_66"/>Write a Haskell expression to evaluate</p>&#13;
<div class="imagec"><img src="Images/066equ01.jpg" alt="Image" width="57" height="65"/></div>&#13;
<p class="noindentts"><strong>Exercise 5.13.</strong> The number <em>n</em>!, called “<em>n</em> factorial,” is the product of the positive integers less than or equal to <em>n</em>:</p>&#13;
<div class="imagec"><em>n</em>! = <em>n</em>(<em>n</em> – 1) . . . 1</div>&#13;
<p class="indent">Here’s an example:</p>&#13;
<div class="imagec">5! = 5 × 4 × 3 × 2 × 1 = 120</div>&#13;
<p class="indent">Using the <code>product</code> function, write a factorial function.</p>&#13;
<pre>fact :: Integer -&gt; Integer&#13;
fact n = undefined</pre>&#13;
<p class="noindentts"><strong>Exercise 5.14.</strong> The exponential function is equal to the following limit:</p>&#13;
<div class="imagec"><img src="Images/066equ02.jpg" alt="Image" width="206" height="40"/></div>&#13;
<p class="indent">Write a function</p>&#13;
<pre>expList :: R -&gt; [R]&#13;
expList x = undefined</pre>&#13;
<p class="noindentts">that takes a real number <em>x</em> as input and produces an infinite list of successive approximations to exp(<em>x</em>):</p>&#13;
<div class="imagec"><img src="Images/066equ03.jpg" alt="Image" width="317" height="50"/></div>&#13;
<p class="indent">How big does <em>n</em> need to be to get within 1 percent of the correct value for <em>x</em> = 1? How big does <em>n</em> need to be to get within 1 percent of the correct value for <em>x</em> = 10?</p>&#13;
<p class="noindentts"><strong>Exercise 5.15.</strong> The exponential function is equal to the following infinite series:</p>&#13;
<div class="imagec"><img src="Images/066equ04.jpg" alt="Image" width="136" height="60"/></div>&#13;
<p class="indent">Write a function</p>&#13;
<pre>expSeries :: R -&gt; [R]&#13;
expSeries x = undefined</pre>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_67"/>that takes a real number <em>x</em> as input and produces an infinite list of successive approximations to exp(<em>x</em>):</p>&#13;
<div class="imagec"><img src="Images/067equ01.jpg" alt="Image" width="198" height="63"/></div>&#13;
<p class="indent">How big does <em>n</em> need to be for</p>&#13;
<div class="imagec"><img src="Images/067equ02.jpg" alt="Image" width="58" height="60"/></div>&#13;
<p class="noindentts">to be within 1 percent of the correct value for <em>x</em> = 1? How big does <em>n</em> need to be to get within 1 percent of the correct value for <em>x</em> = 10? You may want to use the function <code>fromIntegral</code> here.<span epub:type="pagebreak" id="page_68"/></p>&#13;
</div></body></html>