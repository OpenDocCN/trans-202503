["```\n$ `echo $$`                             *Display the PID of the shell*\n400\n$ `find / 2> /dev/null | wc -l &`       *Creates 2 processes in background group*\n[1] 659\n$ `sort < longlist | uniq -c`           *Creates 2 processes in foreground group*\n```", "```\n#include <unistd.h>\n\npid_t `getpgrp`(void)\n```", "```\n#include <unistd.h>\n\nint `setpgid`(pid_t *pid*, pid_t *pgid*);\n```", "```\nsetpgid(0, 0);\nsetpgid(getpid(), 0);\nsetpgid(getpid(), getpid());\n```", "```\npid_t childPid;\n    pid_t pipelinePgid;         /* PGID to which processes in a pipeline\n                                    are to be assigned */\n    /* Other code */\n\n    childPid = fork();\n    switch (childPid) {\n    case -1: /* fork() failed */\n        /* Handle error */\n\n    case 0: /* Child */\n        if (setpgid(0, pipelinePgid) == -1)\n            /* Handle error */\n        /* Child carries on to exec the required program */\n\n    default: /* Parent (shell) */\n        if (setpgid(childPid, pipelinePgid) == -1 && errno != EACCES)\n            /* Handle error */\n        /* Parent carries on to do other things */\n    }\n```", "```\n#define _XOPEN_SOURCE 500\n#include <unistd.h>\n\npid_t `getsid`(pid_t *pid*);\n```", "```\n#include <unistd.h>\n\npid_t `setsid`(void);\n```", "```\n$ `ps -p $$ -o 'pid pgid sid command'`            *$$ is PID of shell*\n  PID  PGID   SID COMMAND\n12243 12243 12243 bash                          *PID, PGID, and SID of shell*\n$ `./t_setsid`\n$ PID=12352, PGID=12352, SID=12352\nERROR [ENXIO Device not configured] open /dev/tty\n```", "```\n`pgsjc/t_setsid.c`\n#define _XOPEN_SOURCE 500\n#include <unistd.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    if (fork() != 0)            /* Exit if parent, or on error */\n        _exit(EXIT_SUCCESS);\n\n    if (setsid() == -1)\n        errExit(\"setsid\");\n\n    printf(\"PID=%ld, PGID=%ld, SID=%ld\\n\", (long) getpid(),\n            (long) getpgrp(), (long) getsid(0));\n\n    if (open(\"/dev/tty\", O_RDWR) == -1)\n        errExit(\"open /dev/tty\");\n    exit(EXIT_SUCCESS);\n}\n     `pgsjc/t_setsid.c`\n```", "```\nif (ioctl(fd, TIOCSCTTY) == -1)\n    errExit(\"ioctl\");\n```", "```\n#include <stdio.h>            /* Defines L_ctermid constant */\n\nchar *`ctermid`(char **ttyname*);\n```", "```\n#include <unistd.h>\n\npid_t `tcgetpgrp`(int *fd*);\n```", "```\nint `tcsetpgrp`(int *fd*, pid_t *pgid*);\n```", "```\n`pgsjc/catch_SIGHUP.c`\n#define _XOPEN_SOURCE 500\n#include <unistd.h>\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\nstatic void\nhandler(int sig)\n{\n}\nint\nmain(int argc, char *argv[])\n{\n    pid_t childPid;\n    struct sigaction sa;\n\n    setbuf(stdout, NULL);       /* Make stdout unbuffered */\n\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sa.sa_handler = handler;\n    if (sigaction(SIGHUP, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    childPid = fork();\n    if (childPid == -1)\n        errExit(\"fork\");\n\n    if (childPid == 0 && argc > 1)\n        if (setpgid(0, 0) == -1)        /* Move to new process group */\n            errExit(\"setpgid\");\n\n    printf(\"PID=%ld; PPID=%ld; PGID=%ld; SID=%ld\\n\", (long) getpid(),\n            (long) getppid(), (long) getpgrp(), (long) getsid(0));\n\n    alarm(60);                 /* An unhandled SIGALRM ensures this process\n                                  will die if nothing else terminates it */\n    for(;;) {                  /* Wait for signals */\n        pause();\n        printf(\"%ld: caught SIGHUP\\n\", (long) getpid());\n    }\n}\n     `pgsjc/catch_SIGHUP.c`\n```", "```\n$ `echo $$`                                   *PID of shell is ID of session*\n5533\n$ `./catch_SIGHUP > samegroup.log 2>&1 &`\n$ `./catch_SIGHUP x > diffgroup.log 2>&1`\n```", "```\n$ `cat samegroup.log`\nPID=5612; PPID=5611; PGID=5611; SID=5533    *Child*\nPID=5611; PPID=5533; PGID=5611; SID=5533    *Parent*\n5611: caught SIGHUP\n5612: caught SIGHUP\n```", "```\n$ `cat diffgroup.log`\nPID=5614; PPID=5613; PGID=5614; SID=5533    *Child*\nPID=5613; PPID=5533; PGID=5613; SID=5533    *Parent*\n5613: caught SIGHUP                         *Parent was signaled, but not child*\n```", "```\n`pgsjc/disc_SIGHUP.c`\n    #define _GNU_SOURCE     /* Get strsignal() declaration from <string.h> */\n    #include <string.h>\n    #include <signal.h>\n    #include \"tlpi_hdr.h\"\n\n    static void             /* Handler for SIGHUP */\n    handler(int sig)\n    {\n    printf(\"PID %ld: caught signal %2d (%s)\\n\", (long) getpid(),\n                sig, strsignal(sig));\n                            /* UNSAFE (see Section 21.1.2) */\n    }\n        int\n    main(int argc, char *argv[])\n    {\n        pid_t parentPid, childPid;\n        int j;\n        struct sigaction sa;\n\n        if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s {d|s}... [ > sig.log 2>&1 ]\\n\", argv[0]);\n\n        setbuf(stdout, NULL);               /* Make stdout unbuffered */\n\n        parentPid = getpid();\n        printf(\"PID of parent process is:       %ld\\n\", (long) parentPid);\n        printf(\"Foreground process group ID is: %ld\\n\",\n                (long) tcgetpgrp(STDIN_FILENO));\n    for (j = 1; j < argc; j++) {        /* Create child processes */\n            childPid = fork();\n            if (childPid == -1)\n                errExit(\"fork\");\n\n            if (childPid == 0) {            /* If child... */\n            if (argv[j][0] == 'd')     /* 'd' --> to different pgrp */\n                    if (setpgid(0, 0) == -1)\n                        errExit(\"setpgid\");\n\n                sigemptyset(&sa.sa_mask);\n                sa.sa_flags = 0;\n                sa.sa_handler = handler;\n            if (sigaction(SIGHUP, &sa, NULL) == -1)\n                    errExit(\"sigaction\");\n                break;                      /* Child exits loop */\n            }\n        }\n\n        /* All processes fall through to here */\n    alarm(60);          /* Ensure each process eventually terminates */\n\n    printf(\"PID=%ld PGID=%ld\\n\", (long) getpid(), (long) getpgrp());\n        for (;;)\n        pause();        /* Wait for signals */\n      }\n          `pgsjc/disc_SIGHUP.c`\n```", "```\n$ `exec ./disc_SIGHUP d s s > sig.log 2>&1`\n```", "```\nPID of parent process is:       12733\nForeground process group ID is: 12733\nPID=12755 PGID=12755                *First child is in a different process group*\nPID=12756 PGID=12733                *Remaining children are in same PG as parent*\nPID=12757 PGID=12733\nPID=12733 PGID=12733                *This is the parent process*\nPID 12756: caught signal  1 (Hangup)\nPID 12757: caught signal  1 (Hangup)\n```", "```\n[1] 18932                           *Job 1: process running* *grep* *has PID 18932*\n$ `sleep 60 &`\n[2] 18934                           *Job 2: process running* *sleep* *has PID 18934*\n```", "```\n$ `jobs`\n[1]- Running        grep -r SIGHUP /usr/src/linux >x &\n[2]+ Running        sleep 60 &\n```", "```\n$ `fg %1`\ngrep -r SIGHUP /usr/src/linux >x\n```", "```\n*Type Control-Z*\n[1]+ Stopped        grep -r SIGHUP /usr/src/linux >x\n```", "```\n$ `bg %1`\n[1]+ grep -r SIGHUP /usr/src/linux >x &\n```", "```\n$ `kill -STOP %1`\n[1]+ Stopped        grep -r SIGHUP /usr/src/linux >x\n$ `jobs`\n[1]+ Stopped        grep -r SIGHUP /usr/src/linux >x\n[2]- Running        sleep 60 &\n$ `bg %1`                             *Restart job in background*\n[1]+ grep -r SIGHUP /usr/src/linux >x &\n```", "```\n*Press Enter to see a further shell prompt*\n[1]- Done           grep -r SIGHUP /usr/src/linux >x\n[2]+ Done           sleep 60\n$\n```", "```\n$ `cat > x.txt &`\n[1] 18947\n$\n*Press Enter once more in order to see*\n *job state changes displayed prior to next shell prompt*\n[1]+ Stopped        cat >x.txt\n$\n```", "```\n$ `stty tostop`                       *Enable* TOSTOP *flag for this terminal*\n$ `date &`\n[1] 19023\n$\n*Press Enter once more to see job state changes displayed prior to next shell prompt*\n[1]+ Stopped        date\n```", "```\n$ `fg`\ndate\nTue Dec 28 16:20:51 CEST 2010\n```", "```\n$ `./job_mon | ./job_mon | ./job_mon`\n```", "```\n`pgsjc/job_mon.c`\n    #define _GNU_SOURCE     /* Get declaration of strsignal() from <string.h> */\n    #include <string.h>\n    #include <signal.h>\n    #include <fcntl.h>\n    #include \"tlpi_hdr.h\"\n\n    static int cmdNum;              /* Our position in pipeline */\n\n    static void                     /* Handler for various signals */\n    handler(int sig)\n    {\n        /* UNSAFE: This handler uses non-async-signal-safe functions\n           (fprintf(), strsignal(); see Section 21.1.2) */\n        if (getpid() == getpgrp())          /* If process group leader */\n          fprintf(stderr, \"Terminal FG process group: %ld\\n\",\n                    (long) tcgetpgrp(STDERR_FILENO));\n    fprintf(stderr, \"Process %ld (%d) received signal %d (%s)\\n\",\n                    (long) getpid(), cmdNum, sig, strsignal(sig));\n\n        /* If we catch SIGTSTP, it won't actually stop us. Therefore we\n           raise SIGSTOP so we actually get stopped. */\n\n    if (sig == SIGTSTP)\n            raise(SIGSTOP);\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        struct sigaction sa;\n\n        sigemptyset(&sa.sa_mask);\n        sa.sa_flags = SA_RESTART;\n        sa.sa_handler = handler;\n    if (sigaction(SIGINT, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n        if (sigaction(SIGTSTP, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n        if (sigaction(SIGCONT, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n\n        /* If stdin is a terminal, this is the first process in pipeline:\n           print a heading and initialize message to be sent down pipe */\n\n    if (isatty(STDIN_FILENO)) {\n            fprintf(stderr, \"Terminal FG process group: %ld\\n\",\n                    (long) tcgetpgrp(STDIN_FILENO));\n        fprintf(stderr, \"Command   PID  PPID  PGRP   SID\\n\");\n            cmdNum = 0;\n\n        } else {            /* Not first in pipeline, so read message from pipe */\n        if (read(STDIN_FILENO, &cmdNum, sizeof(cmdNum)) <= 0)\n                fatal(\"read got EOF or error\");\n        }\n\n    cmdNum++;\n    fprintf(stderr, \"%4d    %5ld %5ld %5ld %5ld\\n\", cmdNum,\n                (long) getpid(), (long) getppid(),\n                (long) getpgrp(), (long) getsid(0));\n\n        /* If not the last process, pass a message to the next process */\n\n        if (!isatty(STDOUT_FILENO))   /* If not tty, then should be pipe */0\n        if (write(STDOUT_FILENO, &cmdNum, sizeof(cmdNum)) == -1)\n                errMsg(\"write\");\n\n    for(;;)             /* Wait for signals */\n            pause();\n    }\n\n           `pgsjc/job_mon.c`\n```", "```\n$ `echo $$`                       *Show PID of the shell*\n1204\n$ `./job_mon | ./job_mon &`                   *Start a job containing 2 processes*\n[1] 1227\nTerminal FG process group: 1204\nCommand   PID  PPID  PGRP   SID\n   1     1226  1204  1226  1204\n   2     1227  1204  1226  1204\n```", "```\n$ `./job_mon | ./job_mon | ./job_mon &`\n[2] 1230\nTerminal FG process group: 1204\nCommand   PID  PPID  PGRP   SID\n   1     1228  1204  1228  1204\n   2     1229  1204  1228  1204\n   3     1230  1204  1228  1204\n```", "```\n$ `fg`\n./job_mon | ./job_mon | ./job_mon\n*Type Control-C to generate* SIGINT *(signal2)*\nProcess 1230 (3) received signal 2 (Interrupt)\nProcess 1229 (2) received signal 2 (Interrupt)\nTerminal FG process group: 1228\nProcess 1228 (1) received signal 2 (Interrupt)\n```", "```\n*Type Control-Z to generate* SIGTSTP *(signal 20 on Linux/x86-32).*\nProcess 1230 (3) received signal 20 (Stopped)\nProcess 1229 (2) received signal 20 (Stopped)\nTerminal FG process group: 1228\nProcess 1228 (1) received signal 20 (Stopped)\n\n[2]+  Stopped       ./job_mon | ./job_mon | ./job_mon\n```", "```\n$ `bg`                                        *Resume job in background*\n[2]+ ./job_mon | ./job_mon | ./job_mon &\nProcess 1230 (3) received signal 18 (Continued)\nProcess 1229 (2) received signal 18 (Continued)\nTerminal FG process group: 1204             *The shell is in the foreground*\nProcess 1228 (1) received signal 18 (Continued)\n$ `kill %1 %2`                                *Weâ€™ve finished: clean up*\n[1]-  Terminated    ./job_mon | ./job_mon\n[2]+  Terminated    ./job_mon | ./job_mon | ./job_mon\n```", "```\n$ `./handling_SIGTSTP`\n*Type Control-Z, sending* SIGTSTP\nCaught SIGTSTP                 *This message is printed by* SIGTSTP *handler*\n\n[1]+  Stopped       ./handling_SIGTSTP\n$ `fg`                           *Sends* SIGCONT\n./handling_SIGTSTP\nExiting SIGTSTP handler        *Execution of handler continues; handler returns*\nMain                           *pause() call in main() was interrupted by handler*\n*Type Control-C to terminate the program*\n```", "```\n`pgsjc/handling_SIGTSTP.c`\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\nstatic void                             /* Handler for SIGTSTP */\ntstpHandler(int sig)\n{\n    sigset_t tstpMask, prevMask;\n    int savedErrno;\n    struct sigaction sa;\n\n    savedErrno = errno;                 /* In case we change 'errno' here */\n\n    printf(\"Caught SIGTSTP\\n\");         /* UNSAFE (see Section 21.1.2) */\n\n    if (signal(SIGTSTP, SIG_DFL) == SIG_ERR)\n        errExit(\"signal\");              /* Set handling to default */\n\n    raise(SIGTSTP);                     /* Generate a further SIGTSTP */\n\n    /* Unblock SIGTSTP; the pending SIGTSTP immediately suspends the program */\n\n    sigemptyset(&tstpMask);\n    sigaddset(&tstpMask, SIGTSTP);\n    if (sigprocmask(SIG_UNBLOCK, &tstpMask, &prevMask) == -1)\n        errExit(\"sigprocmask\");\n\n    /* Execution resumes here after SIGCONT */\n\n    if (sigprocmask(SIG_SETMASK, &prevMask, NULL) == -1)\n        errExit(\"sigprocmask\");         /* Reblock SIGTSTP */\n\n    sigemptyset(&sa.sa_mask);           /* Reestablish handler */\n    sa.sa_flags = SA_RESTART;\n    sa.sa_handler = tstpHandler;\n    if (sigaction(SIGTSTP, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    printf(\"Exiting SIGTSTP handler\\n\");\n    errno = savedErrno;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    struct sigaction sa;\n    /* Only establish handler for SIGTSTP if it is not being ignored */\n\n    if (sigaction(SIGTSTP, NULL, &sa) == -1)\n        errExit(\"sigaction\");\n\n    if (sa.sa_handler != SIG_IGN) {\n        sigemptyset(&sa.sa_mask);\n        sa.sa_flags = SA_RESTART;\n        sa.sa_handler = tstpHandler;\n        if (sigaction(SIGTSTP, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n    }\n\n    for (;;) {                          /* Wait for signals */\n        pause();\n        printf(\"Main\\n\");\n    }\n}\n      `pgsjc/handling_SIGTSTP.c`\n```", "```\nif (fork() != 0)                /* Exit if parent (or on error) */\n    exit(EXIT_SUCCESS);\n```", "```\n`pgsjc/orphaned_pgrp_SIGHUP.c`\n    #define _GNU_SOURCE     /* Get declaration of strsignal() from <string.h> */\n    #include <string.h>\n    #include <signal.h>\n    #include \"tlpi_hdr.h\"\n\n    static void             /* Signal handler */\n    handler(int sig)\n    {\n    printf(\"PID=%ld: caught signal %d (%s)\\n\", (long) getpid(),\n                sig, strsignal(sig));     /* UNSAFE (see Section 21.1.2) */\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        int j;\n        struct sigaction sa;\n\n        if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s {s|p} ...\\n\", argv[0]);\n\n        setbuf(stdout, NULL);               /* Make stdout unbuffered */\n\n        sigemptyset(&sa.sa_mask);\n        sa.sa_flags = 0;\n        sa.sa_handler = handler;\n    if (sigaction(SIGHUP, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n        if (sigaction(SIGCONT, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n\n        printf(\"parent: PID=%ld, PPID=%ld, PGID=%ld, SID=%ld\\n\",\n                (long) getpid(), (long) getppid(),\n                (long) getpgrp(), (long) getsid(0));\n\n        /* Create one child for each command-line argument */\n\n    for (j = 1; j < argc; j++) {\n            switch (fork()) {\n            case -1:\n                errExit(\"fork\");\n\n            case 0:         /* Child */\n                printf(\"child:  PID=%ld, PPID=%ld, PGID=%ld, SID=%ld\\n\",\n                        (long) getpid(), (long) getppid(),\n                        (long) getpgrp(), (long) getsid(0));\n\n                if (argv[j][0] == 's') {    /* Stop via signal */\n                    printf(\"PID=%ld stopping\\n\", (long) getpid());\n                    raise(SIGSTOP);\n                } else {                    /* Wait for signal */\n                    alarm(60);              /* So we die if not SIGHUPed */\n                    printf(\"PID=%ld pausing\\n\", (long) getpid());\n                pause();\n                }\n\n                _exit(EXIT_SUCCESS);\n\n            default:        /* Parent carries on round loop */\n                break;\n            }\n        }\n\n        /* Parent falls through to here after creating all children */\n\n    sleep(3);                           /* Give children a chance to start */\n        printf(\"parent exiting\\n\");\n    exit(EXIT_SUCCESS);                 /* And orphan them and their group */\n    }\n\n         `pgsjc/orphaned_pgrp_SIGHUP.c`\n```", "```\n$ `echo $$`                     *Display PID of shell, which is also the session ID*\n4785\n$ `./orphaned_pgrp_SIGHUP s p`\nparent: PID=4827, PPID=4785, PGID=4827, SID=4785\nchild:  PID=4828, PPID=4827, PGID=4827, SID=4785\nPID=4828 stopping\nchild:  PID=4829, PPID=4827, PGID=4827, SID=4785\nPID=4829 pausing\nparent exiting\n$ PID=4828: caught signal 18 (Continued)\nPID=4828: caught signal 1 (Hangup)\nPID=4829: caught signal 18 (Continued)\nPID=4829: caught signal 1 (Hangup)\n*Press Enter to get another shell prompt*\n$ `./orphaned_pgrp_SIGHUP p p`\nparent: PID=4830, PPID=4785, PGID=4830, SID=4785\nchild:  PID=4831, PPID=4830, PGID=4830, SID=4785\nPID=4831 pausing\nchild:  PID=4832, PPID=4830, PGID=4830, SID=4785\nPID=4832 pausing\nparent exiting\n```", "```\n    /* Call fork() to create a number of child processes, each of which\n       remains in same process group as the parent */\n\n    /* Sometime later... */\n    signal(SIGUSR1, SIG_IGN);     /* Parent makes itself immune to SIGUSR1 */\n\n    killpg(getpgrp(), SIGUSR1);   /* Send signal to children created earlier */\n    ```"]