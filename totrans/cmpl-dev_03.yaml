- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MODERN
    JAVASCRIPT</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 1](chapter1.xhtml), you used basic JavaScript to create a web server
    with Node.js. Now we’ll take a closer look at the language’s more advanced features
    and how you can effectively use them to create full-stack web applications.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll sometimes hear the term *ES.Next* used to refer to new versions of JavaScript.
    In this book, we use ES.Next as a broad label for modern JavaScript and its concepts.
    Most runtime environments have implemented the features covered here. Otherwise,
    you can transpile them with Babel.js, creating backward-compatible JavaScript
    that emulates the new features for older runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">ES.Next Modules</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ES.Next modules allow you to separate code into files to improve maintenance
    and testability. They encapsulate a piece of logic into easily reusable code,
    and because variables and functions are limited to the module’s scope, you can
    use the same variable name in different modules without running into conflicts.
    (We discuss the concept of scopes in “Declaring Variables” on page 17.)
  prefs: []
  type: TYPE_NORMAL
- en: The official ES.Next modules replaced various unofficial module formats, such
    as UMD and AMD, which you would load with a <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>
    statement. For example, you used <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>
    to include the Express.js package for the Node.js server code in [Chapter 1](chapter1.xhtml).
    Instead, ES.Next modules use <samp class="SANS_TheSansMonoCd_W5Regular_11">export</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statements to
    export functions from one module’s scope and import them for use somewhere else.
    In other words, modules allow you to create functions and variables and expose
    them to a new scope.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Named and Default
    Exports</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two kinds of Next.js exports: *named* and *default*. These exports
    use slightly different syntaxes when you import them later. Default exports require
    you to define new function names on import. For named exports, renaming is optional
    and done with the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> statement.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s considered a best practice to use named exports over default exports, because
    named exports define a clear and unique interface for the module’s functionality.
    When we use default exports, the user risks importing the same function under
    different names. TypeScript, which we’ll cover in [Chapter 3](chapter3.xhtml),
    recommends that we use default exports if the module has one clear purpose and
    a single export. In contrast, it recommends using named exports whenever the module
    exports more than one item.
  prefs: []
  type: TYPE_NORMAL
- en: You should know the syntax of default exports so that you can work with third-party
    modules that use them. Unlike named exports, there can be only one default export
    per file, marked by the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    keyword ([Listing 2-1](chapter2.xhtml#Lis2-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: Default exports'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we define an anonymous function and store it in the constant
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getFoo</samp>. Then we export the
    constant with the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    keyword to make it the module’s default export.
  prefs: []
  type: TYPE_NORMAL
- en: You can export named exports inline or at the end of the file, with curly brackets
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>). [Listing 2-2](chapter2.xhtml#Lis2-2)
    shows several named exports.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: Named exports'
  prefs: []
  type: TYPE_NORMAL
- en: Here we define an anonymous function, store it in the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">getFooBar</samp>,
    and immediately export it as <samp class="SANS_TheSansMonoCd_W5Regular_11">getFooBar</samp>.
    Then we define two more anonymous functions and export them as named exports in
    curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Importing Modules</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The syntax to import an ES.Next module depends on the type of export you created.
    Named exports do need to be imported using curly brackets, whereas default exports
    do not. In [Listing 2-3](chapter2.xhtml#Lis2-3), we import the default export
    <samp class="SANS_TheSansMonoCd_W5Regular_11">getFoo</samp> by using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">import</samp> statement followed by the
    local name we assign to it. Finally, we conclude the import with a reference to
    the file that contains the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-3: Importing default exports'
  prefs: []
  type: TYPE_NORMAL
- en: We follow a similar pattern for the named exports in [Listing 2-4](chapter2.xhtml#Lis2-4),
    except that we need to refer to the original function names inside curly brackets.
    To rename the functions locally, we would need to explicitly do so with an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">as</samp> statement, and there is usually
    no reason to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-4: Importing named exports'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use the imported functions in your code, as they are available in
    the scope to which you imported them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Declaring Variables</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript offers three different ways to declare a variable: <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>.
    This section discusses the use cases for each of them. Often, you’ll be given
    the advice to avoid <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> because
    it is “outdated.” You can rest assured that it’s not, and you must understand
    each of these variable declaration methods in order to choose the right tool for
    the job.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These variables differ in their *scope*, which defines the code area in which
    we can access and use them. JavaScript has multiple levels of scope: global, module,
    function, and block. *Block* scope, which applies to any block of code enclosed
    in curly brackets, is the smallest unit of scope. Every time you use curly brackets,
    you create a new block scope. In comparison, you make a *function* scope when
    you define a function. The scope is limited to the code area inside a specific
    function. The *module* scope applies only to a specific module, whereas the *global*
    scope applies to the entire program. Variables defined in the global scope are
    available in every part of your code.'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see in the following code listings, a variable is always available
    in its own scope and all of its child scopes. Hence, you should remember that,
    for example, a function scope can contain multiple block scopes. The same variable
    name can be defined twice in one program as long as each variable occurs in different
    scopes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Hoisted Variables</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Traditional JavaScript declares variables with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    keyword. The scope of these variables is the current execution context (usually
    the enclosing function). If declared outside any function, the variable’s scope
    is global, and the variable creates a property on the global object.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike for all other variables, the runtime environment moves, or *hoists*,
    the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> to
    the top of its scope upon execution. Therefore, you can call these variables in
    your code before you define them. [Listing 2-5](chapter2.xhtml#Lis2-5) shows a
    short example of hoisting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-5: Using a hoisted variable before it is defined'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we assign a value to a variable before declaring it in the
    following line. In languages like Java and C, we can’t use variables before we
    declare them, and any attempt to do so will throw an error. However, because of
    hoisting in JavaScript, the parser moves all variable declarations defined with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> keyword to the top
    of the scope. Thus, the code is equivalent to that in [Listing 2-6](chapter2.xhtml#Lis2-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-6: Defining a variable before using it'
  prefs: []
  type: TYPE_NORMAL
- en: Because of hoisting, block scope does not apply to variables declared with the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> keyword. They are always
    hoisted. To illustrate this, take a look at [Listing 2-7](chapter2.xhtml#Lis2-7),
    where we declare a global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>,
    a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> inside the
    function scope, and a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>
    inside a block scope, all with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-7: The scope of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">var</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We run the <samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp> function
    and see that <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">window.globalVar</samp> are the
    same; the parser hoists both variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>, to the top of the
    function scope. Thus, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>
    is available outside the block scope, and the function scope writes both variables’
    values, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>,
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Scope-Abiding Variables</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modern JavaScript introduced the <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>
    keyword to supplement <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>.
    With <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>, we can declare
    variables that are block-scoped and can be accessed only after they have been
    declared. For this reason, they are considered *non-hoisted* variables. Block-scoped
    variables are limited to the scope of the block statement inside which they are
    defined. Unlike global variables defined with <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>,
    a global <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp> variable isn’t
    added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">window</samp> object.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the scope of a variable declared with <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>.
    In [Listing 2-8](chapter2.xhtml#Lis2-8), we declare a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    inside a function scope, a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>
    inside a block scope, and a global variable <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-8: The scope of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">let</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each variable is available only in its respective scope. The parser does not
    hoist them, and therefore, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>
    is not available outside the block statement. If you try to reference it elsewhere,
    the parser will throw an error and notify you that <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>
    is not defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'We execute the function, and unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    code, it writes only the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    to the console. When we try to access <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>,
    we receive an error, <samp class="SANS_TheSansMonoCd_W5Regular_11">Uncaught ReferenceError:
    bar is not defined</samp>. For <samp class="SANS_TheSansMonoCd_W5Regular_11">globalVar</samp>,
    we see the value <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> printed
    on the console, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">window.globalVar</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">undefined</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constant-Like Data</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modern JavaScript introduced another new keyword, <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    for declaring constants such as data types. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> does not create properties
    of the global object when declared globally. They, too, are considered non-hoisted,
    as they cannot be accessed before being declared.
  prefs: []
  type: TYPE_NORMAL
- en: Constants in JavaScript are different from those in many other languages, where
    they function as immutable data types. In JavaScript, constants only *look* immutable.
    In fact, they are read-only references to their value. Therefore, you cannot directly
    reassign another value to the variable identifier for primitive data types. However,
    objects or arrays are non-primitive data types, so even when you use <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    you can mutate their values through methods or direct property access.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 2-9](chapter2.xhtml#Lis2-9), we declare both a primitive and a non-primitive
    data type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    keyword and try to change their content.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-9: Using <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">const</samp>
    to declare primitive and non-primitive types'
  prefs: []
  type: TYPE_NORMAL
- en: We declare and assign a value to two constant-like data structures. Now when
    we try to reassign a value to the primitive data structure, the runtime throws
    the error <samp class="SANS_TheSansMonoCd_W5Regular_11">Attempted to assign to
    readonly property</samp>. Because we used <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>,
    we cannot reassign its value. In contrast, we can modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">nonPrimitiveDataType</samp>
    array (done here with the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    method) and append a value without running into an error. The array should now
    contain one item with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>;
    hence, we see <samp class="SANS_TheSansMonoCd_W5Regular_11">[1]</samp> in the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Arrow Functions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern JavaScript introduced arrow functions as alternatives to regular functions.
    There are two concepts you need to know about arrow functions. First, they use
    a different syntax than regular functions. Defining an arrow function is much
    quicker, requiring just a few characters and one line of code. The second important,
    but not so obvious, change is that they use something called a lexical scope,
    making them more intuitive and less error prone.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing Arrow Functions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instead of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">function</samp>
    keyword to declare an arrow function, we use the equal-to and greater-than signs
    to form an arrow (<samp class="SANS_TheSansMonoCd_W5Regular_11">=></samp>). This
    syntax, also called the *fat arrow*, reduces noise and results in more compact
    code. Therefore, modern JavaScript prefers this syntax when passing functions
    as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if an arrow function has only one parameter and one statement,
    we can omit the curly brackets and the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    keyword. In this compact form, we call the function a *concise body* function.
    [Listing 2-10](chapter2.xhtml#Lis2-10) shows the definition of a traditional function
    followed by an arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-10: A traditional function and an arrow function with the concise
    body syntax'
  prefs: []
  type: TYPE_NORMAL
- en: We first define a standard function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">function</samp>
    keyword and familiar <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. Then we write the same functionality as an arrow function with the
    concise body syntax. Here we omit the curly brackets and use an implied <samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement, without the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding Lexical
    Scope</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike regular functions, arrow functions do not bind their scope to the object
    that calls the function. Instead, they use a *lexical scope*, in which the surrounding
    scope determines the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    keyword. Therefore, the scope to which <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    refers in an arrow function always represents the object *defining* the arrow
    function instead of the object *calling* the function. [Listing 2-11](chapter2.xhtml#Lis2-11)
    illustrates the concepts of lexical and defining scopes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-11: An arrow function’s scope'
  prefs: []
  type: TYPE_NORMAL
- en: We first declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp>
    property on the lexical scope ❶; this is the defining object. Then we create an
    object with a property of the same name inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">defining
    scope</samp> ❷. Next, we define two functions, both of which use <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    to return the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">this.scope</samp>
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Upon calling them, you can see the difference between the two references. Whereas
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this.scope</samp> in the arrow function
    refers to the property defined in the lexical scope, the traditional function’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> refers to the second
    property we defined. Consequently, the <samp class="SANS_TheSansMonoCd_W5Regular_11">scopeOf.traditional</samp>
    function outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">defining scope</samp>,
    whereas the <samp class="SANS_TheSansMonoCd_W5Regular_11">scopeOf.arrow</samp>
    function outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">lexical scope</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Practical
    Use Cases</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because functions are first-class citizens in JavaScript, we can pass them as
    arguments to other functions. In [Chapter 1](chapter1.xhtml), you used this pattern
    to define callbacks in Node.js or previously when you worked with event handlers
    in the browser. But when you use regular functions as callbacks, the code quickly
    gets cluttered with function statements and curly brackets, even if the actual
    code in the callback is quite simple. Arrow functions allow for a clean and simple
    syntax in callbacks. In [Listing 2-12](chapter2.xhtml#Lis2-12), we use a callback
    on the array <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp> method
    and define it as a traditional function and as an arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-12: Passing a fat arrow function as a parameter'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first version of the callback is a traditional function, whereas the second
    implementation uses an arrow function with a concise body syntax. Both return
    the same array: <samp class="SANS_TheSansMonoCd_W5Regular_11">[0, 1, 2]</samp>.
    We see that the actual functionality, to remove all negative numbers from the
    array, is a simple check to see if the current item is greater than or equal to
    zero. The traditional function is harder to understand, as it requires additional
    characters. Once you fully grasp the arrow syntax, you’ll enhance the readability
    of your code and, in turn, improve the code quality.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating Strings</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern JavaScript introduces untagged and tagged template literals. *Template
    literals* are a simple way to add variables and expressions to a string. This
    string interpolation can span multiple lines and include single and double quotation
    marks without requiring escaping. We enclose template literals in backticks (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">`</samp>) and indicate a variable or expression
    in the template by using a dollar sign (<samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp>)
    and curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: An *untagged* template literal is just a string enclosed in backticks. The parser
    interpolates the variables and expressions and returns a string. As a full-stack
    developer, you’ll use this pattern every time you want to add variables to a string
    or concatenate multiple strings. [Listing 2-13](chapter2.xhtml#Lis2-13) shows
    an example of an untagged template literal. They can span multiple lines without
    the need for any control characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-13: An untagged template literal'
  prefs: []
  type: TYPE_NORMAL
- en: The parser will substitute the placeholders and evaluate the expression in the
    template literal to the string <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as an expression precedes a template literal, it becomes *tagged*. In
    these cases, the function receives both a template literal and the substitution
    values as arguments and then performs an action with both of them before returning
    a value. This returned value can be of any primitive or non-primitive type. In
    [Listing 2-14](chapter2.xhtml#Lis2-14), we use a tagged template literal with
    a custom function to add or subtract numbers and explain the process using words.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-14: A basic tagged template literal'
  prefs: []
  type: TYPE_NORMAL
- en: Here the parser calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">tag</samp>
    expression and then passes the template literal and substitution values as arguments
    to the function. The function constructs a string from the parameters and returns
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a deeper look at our code. In our <samp class="SANS_TheSansMonoCd_W5Regular_11">tag</samp>
    expression, the first argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">literal</samp>,
    is an array that is split at the variables, like this: <samp class="SANS_TheSansMonoCd_W5Regular_11">[''What
    is '', '' minus '', ''?'']</samp>. The argument <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    is also an array, and it contains the values of the template literal variables
    we passed to the function: <samp class="SANS_TheSansMonoCd_W5Regular_11">[1, 2]</samp>.
    We use a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">switch/case</samp>
    statement to calculate the result based on the literal and values. Finally, we
    return a new string with the answer to the “question” and see <samp class="SANS_TheSansMonoCd_W5Regular_11">1
    plus 2 is 3</samp> on the console.'
  prefs: []
  type: TYPE_NORMAL
- en: With their simple interface for complex string substitutions, tagged template
    literals provide an elegant way to create a *domain-specific language (DSL)* in
    JavaScript. A DSL is a language targeted to solve a particular task in a particular
    domain. It’s in contrast to a general-purpose language, such as JavaScript, which
    we can use to solve a wide array of software-related problems. A familiar example
    of a DSL is HTML, which we use in the web development domain to mark up text but
    which we cannot use for mathematical operations or reading file contents. You
    will define your own DSL for full-stack development with GraphQL schemas. When
    you define your first GraphQL schema in [Chapter 6](chapter6.xhtml), you’ll understand
    that its DSL is nothing more than a tagged template literal.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Asynchronous Scripts</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript is single-threaded, which means that it can run only one task at
    a time. Therefore, long-running tasks can block the application. A simple solution
    is *asynchronous* programming, a pattern where you start a long-running task without
    blocking the whole application. While your script waits for a result, the rest
    of the application can still respond to interactions or user interface events
    and perform other calculations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Avoiding Traditional
    Callbacks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Traditional JavaScript implements asynchronous code with callback functions
    executed after another function returns a result. You’ve probably already used
    callbacks when your code has needed to react to an event instead of running immediately.
    One common use case for this technique in full-stack web development is performing
    I/O operations in Node.js or calling remote APIs. [Listing 2-15](chapter2.xhtml#Lis2-15)
    provides an example of an I/O operation. We import the Node.js <samp class="SANS_TheSansMonoCd_W5Regular_11">fs</samp>
    module, which handles filesystem operations, and use a callback function to display
    the file’s contents as soon as the operation concludes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-15: Reading a file in Node.js with a callback function'
  prefs: []
  type: TYPE_NORMAL
- en: Reading a file is a common example of asynchronous scripting. We don’t want
    the application to be blocked while waiting for the file content to be ready;
    however, we also need to use the file’s content in a specific part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Here we create the callback function and pass it as a parameter to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fs.readFile</samp> function. This function
    reads a file from the filesystem and executes the callback as soon as the I/O
    operation fails or succeeds. The callback receives the file data and an optional
    error object, which we write to the console for now.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks are a clumsy solution to asynchronous scripting. As soon as you have
    multiple dependent callback functions, you end up in so-called callback hell,
    where every callback function takes another callback function as an argument.
    The result is a pyramid of functions that are difficult to read and prone to errors.
    Modern JavaScript introduced promises and <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp> as an alternative to callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Promises</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Promises* provide a much cleaner syntax for chainable asynchronous tasks.
    Similar to callbacks, they defer further tasks until a previous action has completed
    or failed. Essentially, promises are function calls that do not return an immediate
    result. Instead, they promise to return the result at some later point. If there
    is an error, the promise is rejected instead of resolved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp> object has
    two properties: the state and the result. When the state is pending, the result
    is undefined. However, as soon as the promise resolves, the state changes to fulfilled,
    and the result reflects the return value. If the promise is rejected instead,
    the state is also set to rejected, and the result contains an error object.'
  prefs: []
  type: TYPE_NORMAL
- en: Promises follow a unique syntax. To use them, you first create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp>
    or call a function that returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp>.
    Then you consume the <samp class="SANS_TheSansMonoCd_W5Regular_11">Promise</samp>
    object, and finally you clean up. This is done by registering the consuming functions
    <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp>. The promise
    initially calls <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> as soon
    as the state changes from pending to fulfilled and passes the returned data to
    it. Each following <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> method
    receives the return value of the previous one, allowing you to create a single
    task chain that works with and manipulates these return values.
  prefs: []
  type: TYPE_NORMAL
- en: The promise chain invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>
    method only if an error occurs either initially or later in the chain of tasks.
    In addition, a state change (of this particular promise) to <samp class="SANS_TheSansMonoCd_W5Regular_11">rejected</samp>
    also invokes it. In any case, the parser calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp>
    method after the stack of <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp>
    methods has completed or the <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>
    method was invoked. You use the <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp>
    method for cleanup tasks such as unlocking the user interface or closing database
    connections. It’s similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">finally</samp>
    call of a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> statement.
  prefs: []
  type: TYPE_NORMAL
- en: You can use promises in any function. In [Listing 2-16](chapter2.xhtml#Lis2-16),
    we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API
    to request JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-16: Fetching remote data with promises'
  prefs: []
  type: TYPE_NORMAL
- en: Like I/O operations on the filesystem, network requests are long-running tasks
    that block the application. Therefore, we should use asynchronous patterns to
    load remote datasets. As in [Listing 2-15](chapter2.xhtml#Lis2-15), we need to
    wait until the operation is complete before we can process the requested data
    or handle an error.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API is promise-based
    by default. As soon as the promise resolves and the state changes to fulfilled,
    the following <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> function
    receives the response object. We then parse the data and pass the JSON object
    to the next function in the *promise chain*, a sequence of functions connected
    with a dot (<samp class="SANS_TheSansMonoCd_W5Regular_11">.then</samp>). If there
    is an error, the promise is rejected. In this case, we <samp class="SANS_TheSansMonoCd_W5Regular_11">catch</samp>
    the error and write it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Simplifying Asynchronous
    Scripts</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Modern JavaScript introduces a new, simpler pattern for handling asynchronous
    requests: the <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp> keywords. Instead of relying
    on chained functions, we can write code whose structure is similar to regular
    synchronous code by employing these keywords.'
  prefs: []
  type: TYPE_NORMAL
- en: When using this pattern, you mark functions explicitly as asynchronous with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>. Then you use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp> instead of the promise-based
    syntax for your asynchronous code. In [Listing 2-17](chapter2.xhtml#Lis2-17),
    we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> API
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    to perform another long-running task and fetch JSON data from a remote location.
    This code is functionally the same as [Listing 2-16](chapter2.xhtml#Lis2-16),
    and you should see that its syntax is more intuitive and cleaner than the chain
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">then</samp> calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-17: Fetching remote data with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">await</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First we declare the function as <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>
    to enable the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> keyword
    inside the function. Then we use <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    to wait for the response of the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    call. Unlike the promise syntax we used before, <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    simplifies the code. It awaits the response object and returns it. Thus, the code
    block looks similar to regular synchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern requires us to handle errors manually. Unlike with promises, there
    is no default reject function. Therefore, we must wrap <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    statements in a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp>
    block to handle error states gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Looping Through an Array</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern JavaScript introduced a whole set of new array functions. The most important
    one for full-stack web development is <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>.
    It allows us to run a function on each array item and return a new array with
    the modified items, preserving the original array. Developers commonly use it
    in React to generate a list or populate JSX with datasets from arrays. You will
    use this pattern extensively once we introduce React in [Chapter 4](chapter4.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 2-18](chapter2.xhtml#Lis2-18), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>
    to iterate over an array of numbers and create an arrow function as a callback.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-18: Using <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">array.map</samp>
    to manipulate each item of an array'
  prefs: []
  type: TYPE_NORMAL
- en: We iterate over the array items and pass each of them to the callback function.
    Here we multiply each item by 10, and then <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>
    returns an array with the multiplied items.
  prefs: []
  type: TYPE_NORMAL
- en: When we log the initial array and the returned array, we see that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">original</samp> array still contains the
    actual, unchanged numbers (<samp class="SANS_TheSansMonoCd_W5Regular_11">1,2,3,4</samp>).
    Only the <samp class="SANS_TheSansMonoCd_W5Regular_11">multiplied</samp> array
    contains the new, modified items (<samp class="SANS_TheSansMonoCd_W5Regular_11">10,20,30,40</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dispersing Arrays and Objects</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern JavaScript’s spread operator is written as three dots (<samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp>).
    It *spreads out*, or expands, the values of an array or the properties of an object
    into their own variables or constants.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, the spread operator copies its content to variables that allocate
    their own memory. In [Listing 2-19](chapter2.xhtml#Lis2-19), we use the spread
    operator to assign the multiple values of an object to several constants. You’ll
    use this pattern in nearly all React code to access component properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-19: Dispersing an object into constants with the spread operator'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create an object with two properties, <samp class="SANS_TheSansMonoCd_W5Regular_11">fruit</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>. Then we use the
    spread operator to expand the object into variables and log them to the console.
    The variables’ names are the same as the object properties’ names. However, we
    can now access the values directly from the variables instead of referring to
    the object. We do so in the template literal and see <samp class="SANS_TheSansMonoCd_W5Regular_11">fruit:
    apple, color: green</samp> as the console output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, as these variables allocate their own memory, they are complete clones.
    Therefore, modifying the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp> won’t change the original
    value: <samp class="SANS_TheSansMonoCd_W5Regular_11">object.color</samp> still
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp> when we log
    both variables to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the spread operator to clone an array or object is useful because JavaScript
    treats arrays as references to its values. When you assign an array or object
    to a new variable or constant, this merely copies the reference to the original;
    it does not clone the array or object by allocating memory. Therefore, changing
    the copy also changes the original. Using spread instead of the equals operator
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>) allocates memory and
    keeps no reference to the original value. Hence, it’s an excellent solution for
    cloning an array or object, as shown in [Listing 2-20](chapter2.xhtml#Lis2-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-20: Cloning an array with the spread operator'
  prefs: []
  type: TYPE_NORMAL
- en: Here we use the spread operator to copy the values from the original array to
    the cloned array in the same operation. Then we modify the cloned array’s items.
    Finally, we write the two arrays to the console and see that the original array
    differs from the cloned array.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 2: Extend Express.js with
    Modern JavaScript</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Modern JavaScript provides the tools you need to write clean and efficient code.
    In [Part II](part2.xhtml), you’ll use it in the Food Finder application. For now,
    let’s apply your new knowledge to optimize the simple Express.js server you created
    in [Chapter 1](chapter1.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Editing the package.json
    File</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll replace the server’s <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>
    call with named modules for different routes. To do so, we need to explicitly
    specify that our project uses native modules. Otherwise, Node.js will throw an
    error. Modify your *package.json* file so that it looks like [Listing 2-21](chapter2.xhtml#Lis2-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-21: The modified package.json file'
  prefs: []
  type: TYPE_NORMAL
- en: Add the property <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> with
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">module</samp>. Also, you’ll
    want to install the *node-fetch* package to make an asynchronous API call in one
    of your routes. Run <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install
    node-fetch</samp> to do so.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing an ES.Next
    Module with Asynchronous Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create the file *routes.js* in the *sample-express* folder, next to the *index.js*
    file, and add the code in [Listing 2-22](chapter2.xhtml#Lis2-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-22: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">route</samp>
    module in the routes.js file'
  prefs: []
  type: TYPE_NORMAL
- en: First we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    module for making asynchronous requests. Then we create the first route, for our
    existing */hello* endpoint. Its behavior should be the same as before; using a
    fat arrow function with a concise body syntax, it returns the string <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    World!</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a route for a new */api/names* endpoint. This endpoint will
    add a page to our web server displaying a list of usernames and IDs. But first
    we explicitly define an <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>
    function so that we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    syntax for our <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> call.
    Then we define the API endpoint in a constant and another variable to store asynchronous
    data. We need to define these before we use them because the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    calls happen inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp>
    block, and these variables are block-scoped. If we defined them inside the block,
    we wouldn’t be able to use them later.
  prefs: []
  type: TYPE_NORMAL
- en: We call the API and await the response data, which we convert to JSON as soon
    as the call succeeds. The <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    variable now holds an array of objects. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>
    to iterate over the data and create the strings we want to display. Then we join
    all array items with break tags (<samp class="SANS_TheSansMonoCd_W5Regular_11"><br></samp>)
    to display them in rows and return the string.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we export the two routes under their names.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Modules
    to the Server</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modify the file *index.js* in the *sample-express* folder to match [Listing
    2-23](chapter2.xhtml#Lis2-23). We use native modules for importing the <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>
    module and the routes we created in [Listing 2-22](chapter2.xhtml#Lis2-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-23: The basic Express.js server with modern JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: First we import <samp class="SANS_TheSansMonoCd_W5Regular_11">routes</samp>
    with the syntax for named imports. Then we replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp>
    call for the *express* package with an <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>
    statement. The */hello* endpoint we created earlier calls the route we imported,
    and the server sends <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello World!</samp>
    as the response to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create a new endpoint, */api/names*, that contains asynchronous
    code. Therefore, we mark the handler as *async* and await the route inside a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">try...catch</samp> block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the server from your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now visit *http://localhost:3000/api/names* in your browser, as shown in [Figure
    2-1](#fig2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 2-1: The response the
    browser receives from the Node.js web server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You should see the new list of user IDs and names.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter taught you enough modern JavaScript and ES.Next to create a full-stack
    application. We covered how to use JavaScript modules to create maintainable packages
    and import and export code, the different ways to declare variables and constants,
    the arrow function, and tagged and untagged template literals. We wrote asynchronous
    code with promises and <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>/<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp>. We also covered <samp class="SANS_TheSansMonoCd_W5Regular_11">array.map</samp>,
    the spread operator, and their usefulness for your full-stack code. Finally, you
    used your new knowledge to update the sample Node.js server from [Chapter 1](chapter1.xhtml)
    with modern JavaScript concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Modern JavaScript has many more features than this chapter covers. From the
    freely available resources, I recommend the JavaScript tutorials at [*https://<wbr>www<wbr>.javascripttutorial<wbr>.net*](https://www.javascripttutorial.net).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we cover TypeScript, a superset of JavaScript with support
    for types.
  prefs: []
  type: TYPE_NORMAL
