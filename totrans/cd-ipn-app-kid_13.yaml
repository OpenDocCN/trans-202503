- en: '**11**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time to show off those birthdays! In [Chapter 10](text00021.html#ch10) , you
    created the Add Birthday view controller so that you could add new Birthday objects
    into your app with the Birthday class. In this chapter, you’ll create a Birthdays
    table view controller that can display your added birthdays in a *table view*
    , which shows a list of items the user can scroll through and select. Then you’ll
    learn how to make the Add Birthday view controller tell the Birthdays table view
    controller when a Birthday object is added so that the new birthday can be shown
    in the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE BIRTHDAY LIST**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s one thing to be able to add birthdays, but you’ll also want to display
    a list of birthdays. For that you need to create another class, BirthdaysTableViewController
    , which will subclass UITableViewController , a special kind of view controller
    with a table view. UITableViewController contains several built-in methods that
    allow you to code things like how many rows the table view should have and what
    should be displayed in each row. We’ll want to have as many rows as we have birthdays
    and to display one birthday in each row.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CONTROL -click the *BirthdayTracker* folder in the Project navigator and choose
    **New File…** from the menu. In [Chapter 10](text00021.html#ch10) , we created
    the Swift file *Birthday.swift* , which Xcode prepared for us with nearly nothing
    in it. To create a new file this time, we’ll tell Xcode we want to subclass an
    existing iOS class. Depending on the base class, Xcode will create a file containing
    some code that you’ll customize to your needs. To create the file, select **iOS**
    at the top of the window and then select the **Cocoa Touch Class** template, which
    will automatically format the new class file (see [Figure 11-1](text00022.html#ch11fig1)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00234.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: To subclass an existing class, choose* ***iOS*** *and then* ***Cocoa
    Touch Class.***'
  prefs: []
  type: TYPE_NORMAL
- en: When you choose this option, you’ll see a second dialog where you can name your
    new class and specify which class you’ll subclass. First, in the Subclass field
    (the second field in the dialog), type UITableViewController . This will automatically
    fill in the class field with the subclass name. Once that happens, type Birthdays
    in front of TableViewController so that the whole class name is BirthdaysTableViewController
    . This is a shortcut so you don’t have to type as much. Make sure to choose **Swift**
    in the Language drop-down menu as well, and then click **Next** . Then select
    **Create** in the final dialog to create your new file.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time to show off those birthdays! In [Chapter 10](text00021.html#ch10) , you
    created the Add Birthday view controller so that you could add new Birthday objects
    into your app with the Birthday class. In this chapter, you’ll create a Birthdays
    table view controller that can display your added birthdays in a *table view*
    , which shows a list of items the user can scroll through and select. Then you’ll
    learn how to make the Add Birthday view controller tell the Birthdays table view
    controller when a Birthday object is added so that the new birthday can be shown
    in the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE BIRTHDAY LIST**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s one thing to be able to add birthdays, but you’ll also want to display
    a list of birthdays. For that you need to create another class, BirthdaysTableViewController
    , which will subclass UITableViewController , a special kind of view controller
    with a table view. UITableViewController contains several built-in methods that
    allow you to code things like how many rows the table view should have and what
    should be displayed in each row. We’ll want to have as many rows as we have birthdays
    and to display one birthday in each row.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CONTROL -click the *BirthdayTracker* folder in the Project navigator and choose
    **New File…** from the menu. In [Chapter 10](text00021.html#ch10) , we created
    the Swift file *Birthday.swift* , which Xcode prepared for us with nearly nothing
    in it. To create a new file this time, we’ll tell Xcode we want to subclass an
    existing iOS class. Depending on the base class, Xcode will create a file containing
    some code that you’ll customize to your needs. To create the file, select **iOS**
    at the top of the window and then select the **Cocoa Touch Class** template, which
    will automatically format the new class file (see [Figure 11-1](text00022.html#ch11fig1)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00234.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: To subclass an existing class, choose* ***iOS*** *and then* ***Cocoa
    Touch Class.***'
  prefs: []
  type: TYPE_NORMAL
- en: When you choose this option, you’ll see a second dialog where you can name your
    new class and specify which class you’ll subclass. First, in the Subclass field
    (the second field in the dialog), type UITableViewController . This will automatically
    fill in the class field with the subclass name. Once that happens, type Birthdays
    in front of TableViewController so that the whole class name is BirthdaysTableViewController
    . This is a shortcut so you don’t have to type as much. Make sure to choose **Swift**
    in the Language drop-down menu as well, and then click **Next** . Then select
    **Create** in the final dialog to create your new file.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time to show off those birthdays! In [Chapter 10](text00021.html#ch10) , you
    created the Add Birthday view controller so that you could add new Birthday objects
    into your app with the Birthday class. In this chapter, you’ll create a Birthdays
    table view controller that can display your added birthdays in a *table view*
    , which shows a list of items the user can scroll through and select. Then you’ll
    learn how to make the Add Birthday view controller tell the Birthdays table view
    controller when a Birthday object is added so that the new birthday can be shown
    in the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE BIRTHDAY LIST**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s one thing to be able to add birthdays, but you’ll also want to display
    a list of birthdays. For that you need to create another class, BirthdaysTableViewController
    , which will subclass UITableViewController , a special kind of view controller
    with a table view. UITableViewController contains several built-in methods that
    allow you to code things like how many rows the table view should have and what
    should be displayed in each row. We’ll want to have as many rows as we have birthdays
    and to display one birthday in each row.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CONTROL -click the *BirthdayTracker* folder in the Project navigator and choose
    **New File…** from the menu. In [Chapter 10](text00021.html#ch10) , we created
    the Swift file *Birthday.swift* , which Xcode prepared for us with nearly nothing
    in it. To create a new file this time, we’ll tell Xcode we want to subclass an
    existing iOS class. Depending on the base class, Xcode will create a file containing
    some code that you’ll customize to your needs. To create the file, select **iOS**
    at the top of the window and then select the **Cocoa Touch Class** template, which
    will automatically format the new class file (see [Figure 11-1](text00022.html#ch11fig1)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00234.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: To subclass an existing class, choose* ***iOS*** *and then* ***Cocoa
    Touch Class.***'
  prefs: []
  type: TYPE_NORMAL
- en: When you choose this option, you’ll see a second dialog where you can name your
    new class and specify which class you’ll subclass. First, in the Subclass field
    (the second field in the dialog), type UITableViewController . This will automatically
    fill in the class field with the subclass name. Once that happens, type Birthdays
    in front of TableViewController so that the whole class name is BirthdaysTableViewController
    . This is a shortcut so you don’t have to type as much. Make sure to choose **Swift**
    in the Language drop-down menu as well, and then click **Next** . Then select
    **Create** in the final dialog to create your new file.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Time to show off those birthdays! In [Chapter 10](text00021.html#ch10) , you
    created the Add Birthday view controller so that you could add new Birthday objects
    into your app with the Birthday class. In this chapter, you’ll create a Birthdays
    table view controller that can display your added birthdays in a *table view*
    , which shows a list of items the user can scroll through and select. Then you’ll
    learn how to make the Add Birthday view controller tell the Birthdays table view
    controller when a Birthday object is added so that the new birthday can be shown
    in the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE BIRTHDAY LIST**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s one thing to be able to add birthdays, but you’ll also want to display
    a list of birthdays. For that you need to create another class, BirthdaysTableViewController
    , which will subclass UITableViewController , a special kind of view controller
    with a table view. UITableViewController contains several built-in methods that
    allow you to code things like how many rows the table view should have and what
    should be displayed in each row. We’ll want to have as many rows as we have birthdays
    and to display one birthday in each row.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CONTROL -click the *BirthdayTracker* folder in the Project navigator and choose
    **New File…** from the menu. In [Chapter 10](text00021.html#ch10) , we created
    the Swift file *Birthday.swift* , which Xcode prepared for us with nearly nothing
    in it. To create a new file this time, we’ll tell Xcode we want to subclass an
    existing iOS class. Depending on the base class, Xcode will create a file containing
    some code that you’ll customize to your needs. To create the file, select **iOS**
    at the top of the window and then select the **Cocoa Touch Class** template, which
    will automatically format the new class file (see [Figure 11-1](text00022.html#ch11fig1)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00234.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: To subclass an existing class, choose* ***iOS*** *and then* ***Cocoa
    Touch Class.***'
  prefs: []
  type: TYPE_NORMAL
- en: When you choose this option, you’ll see a second dialog where you can name your
    new class and specify which class you’ll subclass. First, in the Subclass field
    (the second field in the dialog), type UITableViewController . This will automatically
    fill in the class field with the subclass name. Once that happens, type Birthdays
    in front of TableViewController so that the whole class name is BirthdaysTableViewController
    . This is a shortcut so you don’t have to type as much. Make sure to choose **Swift**
    in the Language drop-down menu as well, and then click **Next** . Then select
    **Create** in the final dialog to create your new file.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING THE BIRTHDAY LIST**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s one thing to be able to add birthdays, but you’ll also want to display
    a list of birthdays. For that you need to create another class, BirthdaysTableViewController
    , which will subclass UITableViewController , a special kind of view controller
    with a table view. UITableViewController contains several built-in methods that
    allow you to code things like how many rows the table view should have and what
    should be displayed in each row. We’ll want to have as many rows as we have birthdays
    and to display one birthday in each row.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CONTROL -click the *BirthdayTracker* folder in the Project navigator and choose
    **New File…** from the menu. In [Chapter 10](text00021.html#ch10) , we created
    the Swift file *Birthday.swift* , which Xcode prepared for us with nearly nothing
    in it. To create a new file this time, we’ll tell Xcode we want to subclass an
    existing iOS class. Depending on the base class, Xcode will create a file containing
    some code that you’ll customize to your needs. To create the file, select **iOS**
    at the top of the window and then select the **Cocoa Touch Class** template, which
    will automatically format the new class file (see [Figure 11-1](text00022.html#ch11fig1)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00234.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: To subclass an existing class, choose* ***iOS*** *and then* ***Cocoa
    Touch Class.***'
  prefs: []
  type: TYPE_NORMAL
- en: When you choose this option, you’ll see a second dialog where you can name your
    new class and specify which class you’ll subclass. First, in the Subclass field
    (the second field in the dialog), type UITableViewController . This will automatically
    fill in the class field with the subclass name. Once that happens, type Birthdays
    in front of TableViewController so that the whole class name is BirthdaysTableViewController
    . This is a shortcut so you don’t have to type as much. Make sure to choose **Swift**
    in the Language drop-down menu as well, and then click **Next** . Then select
    **Create** in the final dialog to create your new file.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: It’s one thing to be able to add birthdays, but you’ll also want to display
    a list of birthdays. For that you need to create another class, BirthdaysTableViewController
    , which will subclass UITableViewController , a special kind of view controller
    with a table view. UITableViewController contains several built-in methods that
    allow you to code things like how many rows the table view should have and what
    should be displayed in each row. We’ll want to have as many rows as we have birthdays
    and to display one birthday in each row.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CONTROL -click the *BirthdayTracker* folder in the Project navigator and choose
    **New File…** from the menu. In [Chapter 10](text00021.html#ch10) , we created
    the Swift file *Birthday.swift* , which Xcode prepared for us with nearly nothing
    in it. To create a new file this time, we’ll tell Xcode we want to subclass an
    existing iOS class. Depending on the base class, Xcode will create a file containing
    some code that you’ll customize to your needs. To create the file, select **iOS**
    at the top of the window and then select the **Cocoa Touch Class** template, which
    will automatically format the new class file (see [Figure 11-1](text00022.html#ch11fig1)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00234.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: To subclass an existing class, choose* ***iOS*** *and then* ***Cocoa
    Touch Class.***'
  prefs: []
  type: TYPE_NORMAL
- en: When you choose this option, you’ll see a second dialog where you can name your
    new class and specify which class you’ll subclass. First, in the Subclass field
    (the second field in the dialog), type UITableViewController . This will automatically
    fill in the class field with the subclass name. Once that happens, type Birthdays
    in front of TableViewController so that the whole class name is BirthdaysTableViewController
    . This is a shortcut so you don’t have to type as much. Make sure to choose **Swift**
    in the Language drop-down menu as well, and then click **Next** . Then select
    **Create** in the final dialog to create your new file.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CONTROL -click the *BirthdayTracker* folder in the Project navigator and choose
    **New File…** from the menu. In [Chapter 10](text00021.html#ch10) , we created
    the Swift file *Birthday.swift* , which Xcode prepared for us with nearly nothing
    in it. To create a new file this time, we’ll tell Xcode we want to subclass an
    existing iOS class. Depending on the base class, Xcode will create a file containing
    some code that you’ll customize to your needs. To create the file, select **iOS**
    at the top of the window and then select the **Cocoa Touch Class** template, which
    will automatically format the new class file (see [Figure 11-1](text00022.html#ch11fig1)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00234.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: To subclass an existing class, choose* ***iOS*** *and then* ***Cocoa
    Touch Class.***'
  prefs: []
  type: TYPE_NORMAL
- en: When you choose this option, you’ll see a second dialog where you can name your
    new class and specify which class you’ll subclass. First, in the Subclass field
    (the second field in the dialog), type UITableViewController . This will automatically
    fill in the class field with the subclass name. Once that happens, type Birthdays
    in front of TableViewController so that the whole class name is BirthdaysTableViewController
    . This is a shortcut so you don’t have to type as much. Make sure to choose **Swift**
    in the Language drop-down menu as well, and then click **Next** . Then select
    **Create** in the final dialog to create your new file.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: CONTROL -click the *BirthdayTracker* folder in the Project navigator and choose
    **New File…** from the menu. In [Chapter 10](text00021.html#ch10) , we created
    the Swift file *Birthday.swift* , which Xcode prepared for us with nearly nothing
    in it. To create a new file this time, we’ll tell Xcode we want to subclass an
    existing iOS class. Depending on the base class, Xcode will create a file containing
    some code that you’ll customize to your needs. To create the file, select **iOS**
    at the top of the window and then select the **Cocoa Touch Class** template, which
    will automatically format the new class file (see [Figure 11-1](text00022.html#ch11fig1)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00234.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: To subclass an existing class, choose* ***iOS*** *and then* ***Cocoa
    Touch Class.***'
  prefs: []
  type: TYPE_NORMAL
- en: When you choose this option, you’ll see a second dialog where you can name your
    new class and specify which class you’ll subclass. First, in the Subclass field
    (the second field in the dialog), type UITableViewController . This will automatically
    fill in the class field with the subclass name. Once that happens, type Birthdays
    in front of TableViewController so that the whole class name is BirthdaysTableViewController
    . This is a shortcut so you don’t have to type as much. Make sure to choose **Swift**
    in the Language drop-down menu as well, and then click **Next** . Then select
    **Create** in the final dialog to create your new file.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00234.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: To subclass an existing class, choose* ***iOS*** *and then* ***Cocoa
    Touch Class.***'
  prefs: []
  type: TYPE_NORMAL
- en: When you choose this option, you’ll see a second dialog where you can name your
    new class and specify which class you’ll subclass. First, in the Subclass field
    (the second field in the dialog), type UITableViewController . This will automatically
    fill in the class field with the subclass name. Once that happens, type Birthdays
    in front of TableViewController so that the whole class name is BirthdaysTableViewController
    . This is a shortcut so you don’t have to type as much. Make sure to choose **Swift**
    in the Language drop-down menu as well, and then click **Next** . Then select
    **Create** in the final dialog to create your new file.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-1: To subclass an existing class, choose* ***iOS*** *and then* ***Cocoa
    Touch Class.***'
  prefs: []
  type: TYPE_NORMAL
- en: When you choose this option, you’ll see a second dialog where you can name your
    new class and specify which class you’ll subclass. First, in the Subclass field
    (the second field in the dialog), type UITableViewController . This will automatically
    fill in the class field with the subclass name. Once that happens, type Birthdays
    in front of TableViewController so that the whole class name is BirthdaysTableViewController
    . This is a shortcut so you don’t have to type as much. Make sure to choose **Swift**
    in the Language drop-down menu as well, and then click **Next** . Then select
    **Create** in the final dialog to create your new file.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: When you choose this option, you’ll see a second dialog where you can name your
    new class and specify which class you’ll subclass. First, in the Subclass field
    (the second field in the dialog), type UITableViewController . This will automatically
    fill in the class field with the subclass name. Once that happens, type Birthdays
    in front of TableViewController so that the whole class name is BirthdaysTableViewController
    . This is a shortcut so you don’t have to type as much. Make sure to choose **Swift**
    in the Language drop-down menu as well, and then click **Next** . Then select
    **Create** in the final dialog to create your new file.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In *BirthdaysTableViewController.swift* , Xcode has provided a template with
    several commented-out methods. You can clean up the code by getting rid of methods
    we won’t use. Delete just the comments in viewDidLoad() , and then delete the
    entire didReceiveMemoryWarning() method and the methods tableView(_:moveRowAt:to:)
    and tableView(_:canMoveRowAt:) , which have to do with moving rows in the table
    view. When you’re finished, the contents of BirthdaysTableViewController should
    look like [Figure 11-2](text00022.html#ch11fig2) . There are still several commented-out
    methods, but we’re keeping those to use later!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00235.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-2: The* BirthdaysTableViewController *cleaned up!*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to make the Birthdays table view controller the BirthdaysTableViewController
    class. To do this, go to *Main.storyboard* and select the **Birthdays** scene.
    Using the Identity Inspector in the right pane, change the class from UITableViewController
    to BirthdaysTableViewController , as shown in [Figure 11-3](text00022.html#ch11fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00236.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-3: Setting* BirthdaysTableViewController *as the class of the Birthdays
    scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the Birthdays table view controller set up in the storyboard,
    the next step is to make cells in your table that will display each birthday.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CELLS TO THE TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Each birthday will be displayed in a UITableViewCell in the Birthdays table
    view controller. A table has boxes organized into rows and columns that contain
    information. These boxes are called *cells* . Similarly, a table view also has
    cells that are all instances of, or a subclass of, the UITableViewCell class.
    We’ll put each birthday into its own cell in our table view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by creating those cells in the storyboard, and then we’ll fill them
    with our Birthday objects later. In the left outline menu, click the triangle
    by Birthdays and then click the triangle by Table View to open those sections.
    Then select **Table View Cell** ➊ , as shown in [Figure 11-4](text00022.html#ch11fig4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00237.jpg)![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00238.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-4: Creating a Subtitle style table view cell and setting its identifier*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Attributes Inspector. Using the drop-down menu under **Style**
    , set the cell’s style to **Subtitle** ➋ so that the cell now has a Title label
    and a Subtitle label. You’ll display each person’s name in the Title and birthday
    in the Subtitle.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, enter birthdayCellIdentifier in the Identifier field ➌ . You’ll use
    this identifier later when you fill in the cell contents.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve finished your work in the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we have just one cell in our table view in the storyboard
    when we’ll have more than one birthday to show in the list. If you look at [Figure
    11-4](text00022.html#ch11fig4) again, you’ll notice that the cell is labeled *Prototype
    Cells* . This means that the cell you just customized is a *template* for all
    the cells you want to appear in your table view. The identifier you gave the cell
    is how your code will tell the table view to produce each cell for you to put
    birthdays in. You’ll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**WORKING WITH DATES**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift has a special data type called Date that is used for storing date values.
    A Date object is actually a date and a time. Open your playground and enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00239.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve just assigned the current date and time the code was run to the variable
    today . When you print today , it’s in the format "2017-11-21 10:45:31 +0000\n"
    . What if you wanted it to display as Tuesday, November 21, 2017 , instead? Or
    just 11/21/17 ? To display a date in a particular way, you use a *date formatter*
    , which is a DateFormatter object that you create and give a date format style.
    DateFormatter is a helper object that is used to create a display string from
    any date, and a *date format style* is a property of DateFormatter that tells
    the formatter what style to use. You can create your own date format styles manually,
    but there are also styles that are included in Swift and ready to use. Add the
    following to your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00240.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ you create a formatter . Then at ➋ , you set the style of the formatter
    to Style.full , which will print the day of the week as well as the full month
    name, date, and year. Finally, you create a string from the date using the string(from:)
    method of the DateFormatter class ➌ . You can see that you now have turned the
    date into the nicely formatted string "Tuesday, November 21, 2017" . [Table 11-1](text00022.html#ch11tab1)
    shows the different strings that are created from the five DateFormatter.Style
    options available in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 11-1:** Date Formatter Styles and Their Date Strings'
  prefs: []
  type: TYPE_NORMAL
- en: '| DateFormatter.Style | **Date string** |'
  prefs: []
  type: TYPE_TB
- en: '| none | "" |'
  prefs: []
  type: TYPE_TB
- en: '| short | "11/21/17" |'
  prefs: []
  type: TYPE_TB
- en: '| medium | "Nov 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| long | "November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: '| full | "Tuesday, November 21, 2017" |'
  prefs: []
  type: TYPE_TB
- en: 'You can also specify your own custom way of displaying a date using the dateFormat
    property of the DateFormatter . Perhaps you only want the month and day. Or maybe
    you want a four-digit year displayed in the short style. Doing either is really
    easy, and you don’t even have to create a new DateFormatter —you can just change
    the dateFormat on formatter and then ask it for a new string. Add the following
    code to your playground to display dates with a specific format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00241.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➊ , you specify that you only want the month and the date in an MM/dd format—that
    is, a two-digit month followed by a two-digit date. If you want to display the
    month as three letters, then use MMM . To display the full name of the month,
    use MMMM . At ➋ , we change the date format to use a four-digit year. A two-digit
    year would be yy . Here are a few other ways to use a dateFormat to display a
    custom date string.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to include separators, you add them to your dateFormat string. For
    example, if you want periods as separators, then you can create a dateFormat like
    "MM.dd.yy" ➊ . To display an abbreviated day of the week, use EEE ➋ . For the
    full day, use EEEE ➌ . These are only a few examples. By using combinations of
    M , d , y , and E , you have an endless number of ways to display a date!
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE BIRTHDAYS TABLE VIEW CONTROLLER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Birthdays table view controller will display a list of all the birthdays
    stored in the app. Do you remember what you use to store a list of items? That’s
    right—an array! You’ll create an array in the BirthdaysTableViewController to
    store all the birthdays. To do this, give the BirthdaysTableViewController a birthdays
    property that is an array of Birthday objects. At the top of the class, right
    above the viewDidLoad() method, insert this line to add a variable array property
    called birthdays :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: This line creates an empty array of Birthday instances. It needs to be a variable
    and not a constant because you’ll want to add a saved Birthday to this array every
    time the user adds a Birthday with the Add Birthday view controller. You’ll see
    how to do that in “[Making the Birthdays Table View Controller Conform to Protocol](text00022.html#ch11lev3sec2)
    ” on [page 168](text00022.html#page_168) .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that the final versions of the project files are available from*
    [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The BirthdaysTableViewController will also need a dateFormatter property to
    display the birthdate as a nicely formatted string. Add a dateFormatter right
    underneath the birthdays array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the dateFormatter is a constant that is created with let . Even though
    you’ll change the dateFormatter ’s properties, like the dateStyle and timeStyle
    , you’ll never change the dateFormatter itself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need to set up the dateFormatter so that it will display the birthdates
    as fully formatted strings like "Tuesday, December 17, 2008" . As you saw in [Chapter
    10](text00021.html#ch10) , a good place to do this is the viewDidLoad() method,
    which is called when the Birthdays table view controller is loading its view.
    This is the perfect place to do any setup that is needed for this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , you set the dateStyle of the dateFormatter so that it will display a
    formatted date string for each Birthday . Did you notice how we just wrote .full
    instead of DateFormatter.Style.full ? Swift knows what type to expect for the
    dateStyle of a DateFormatter , so it lets us take this little shortcut. At ➋ ,
    you set the timeStyle of the dateFormatter to .none so that the time won’t be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING BIRTHDAYS IN A TABLE VIEW**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: The BirthdaysTableViewController class has a table view that is used to display
    a list of items in a single column. The table view has one or more sections containing
    rows, and each row contains a cell. A section in a table view is a grouping of
    rows that can be displayed with or without a header. An example of an app that
    shows a table view with several sections is the Settings app, as shown in [Figure
    11-5](text00022.html#ch11fig5) . It displays a list of rows that have been broken
    up into different sections.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Each section and row of a table view is identified with an index number. These
    numbers start at 0 and then increase by 1 as you go down the table view. For example,
    the Privacy line in the Settings app is found at section 0, row 1\. The News setting
    is at section 1, row 3.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle of the BirthdaysTableViewController class, there is a section
    called *Table view data source* with three methods. The table view controller
    uses these methods to determine what’s going to be displayed inside its table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: numberOfSections(in:) Tells the table view how many sections it should have
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:numberOfRowsInSection:) Tells the table view how many rows will
    be displayed in each section
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: tableView(_:cellForRowAt:) Sets up each cell that’s going to be displayed in
    each row of the table view
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-5: The Settings app uses sections to group rows of different device
    settings.*'
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: The table view data source methods are called by the table view controller every
    time the table view is reloaded. Xcode automatically gives you these method templates
    when you make a subclass of a UITableViewController . You need to implement all
    three methods for the app to work, even though you’ll never call them directly
    in your code. The UITableViewController class implements the UITableViewDataSource
    protocol, which comes with these data source methods, to determine what will be
    displayed inside the table view. We’ll discuss protocols in “[Delegation](text00022.html#ch11lev2sec5)
    ” on page 166\. For now, you just need to know that a UITableViewController uses
    these methods to display its content, and it automatically calls these methods
    so you don’t need to call them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the method numberOfSections(in:) . The Birthdays table view
    controller is a list that just displays Birthday instances, so it doesn’t need
    multiple sections. To set the number of sections in the table view, we just need
    to return 1 .
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method takes a UITableView called tableView as a parameter, which is the
    table view that uses this class as its data source. We don’t need to worry about
    making this connection because the UITableViewController comes with a built-in
    table view that is automatically hooked up to these methods. Each birthday will
    be displayed in its own row. So in tableView(_:numberOfRowsInSection:) , in order
    to have the right number of rows for all of your birthdays, you need to return
    the number of Birthday instances that you have in your birthdays array. Do you
    remember the count property of an array? It’s an integer that tells you how many
    items are in that array, and it’s perfect for this situation! Change this method
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the tableView parameter, tableView(_:numberOfRowsInSection:)
    also takes an Int called section . When the table view is loading itself, this
    method is called for each section in the table view. In our case, we have only
    one section, so we don’t need to bother checking which section of the table view
    is being displayed here. We know it’s section 0, and we want it to have as many
    rows as there are birthdays, so we write return birthdays.count .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to implement tableView(_:cellForRowAt:) so that the table
    view will know what to put inside each cell. Since this method is commented out,
    you need to uncomment it by deleting the /* and */ that surround it. (Be careful
    not to accidentally uncomment the other methods after it!) After you’ve done that,
    change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t call the method tableView(_:cellForRowAt:) . It’s called when the
    table view is loaded onto the screen. It’s called for each cell on the screen
    and takes two parameters, tableView and indexPath . You already know what the
    tableView parameter is for. An IndexPath is a Swift struct that’s used to represent
    a row’s position in a table view. An IndexPath instance has a section property
    and a row property. Since this method will be called many times (once for every
    row in the table), we need the indexPath to know which section and row we’re currently
    configuring. The indexPath.section property gives the section number, and the
    indexPath.row gives the row of the table view cell. The five lines of code inside
    tableView(_:cellForRowAt:) will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: • Create a UITableViewCell
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: • Figure out which Birthday in the birthdays array will be displayed inside
    the cell
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: • Make two labels to display the birthday person’s name and birthdate in the
    cell
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: • Return the cell ready for display in the table view
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: First, create the UITableViewCell . The code at ➊ does this using the method
    dequeueReusableCell(withIdentifier:for:) . Before you can start using this method
    on a cell, though, you need to tell the method which cell you want to use from
    the storyboard. Earlier, when you were in the storyboard, you gave your cell the
    identifier birthdayCellIdentifier (see [Figure 11-4](text00022.html#ch11fig4)
    ). This identifier links your code to the cell and tells your method that it’s
    using the right cell. The string for when you call this method needs to be exactly
    the same as the string you set in the storyboard, or you’ll get an error and the
    app will crash when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In the method dequeueReusableCell(withIdentifier:for:) , did you notice the
    words *Reusable Cell* ? The cells inside a table view are created once and then
    can be reused over and over. This helps everything run faster and smoother because
    creating the cell is what takes the most time. If you had 200 birthdays in your
    app, but only 10 would fit on your screen at one time, then you need only 10 cells
    to show your birthdays. When you scroll down to reveal more birthdays, the cells
    that scroll off the top of the screen are reused. They are filled with new information
    and show up again at the bottom of the screen. The UITableView automatically does
    this work. When the table view is loaded, tableView(_:cellForRowAt:) is called
    for every visible row. When the user scrolls to look at more cells, it’s called
    again for each row just as it is about to appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to find out which Birthday should be displayed inside the cell.
    We want to display one birthday from the birthdays array in each row. The first
    birthday, which is at birthdays[0] , should be displayed in row 0\. The second
    birthday, at birthdays[1] , should be displayed in row 1, and so on, which means
    the indexPath ’s row is the same as the position in the birthdays array that we
    want to access. The code at ➋ accesses the correct Birthday object from the birthdays
    array by using indexPath.row . Once we have the right Birthday object, we assign
    it to a constant named birthday so we can set up the labels in this cell.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re using let to assign the birthday to a constant instead of
    a variable. We can use let because each time tableView(_:cellForRowAt:) is called,
    a new birthday constant is created. Each cell gets its own birthday constant that
    is assigned its own Birthday object. Since we’re not going to change any of the
    birthday constants—we’re just going to read their properties—we don’t want to
    make them variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your cell and your birthday, it’s time to fill in the details.
    You need two labels for each cell to show the birthday person’s name and birthdate.
    You set the cell to the Subtitle style so that it has a Title label and a Subtitle
    label. Each cell will already contain these labels, so now you don’t have to create
    any labels yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: The labels exist as properties of UITableViewCell and are called textLabel and
    detailTextLabel . The code at ➌ sets the text of the textLabel to a string made
    up of the firstName and lastName of the birthday with a space between them. At
    ➍ , you use the string(from:) method of the dateFormatter to display the birthdate
    in the detailTextLabel .
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: When your cell is completely configured, tableView( _:cellForRowAt:) returns
    the cell at ➎ so that it can be displayed at that indexPath of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**PUTTING IT ALL TOGETHER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can add Birthday instances to the app using the Add Birthday view controller,
    and you have a table view to list each Birthday in the Birthdays table view controller.
    But when you try running the app and adding a Birthday , it doesn’t appear. To
    make each Birthday you add appear in the table view, you need to make the Add
    Birthday view controller communicate with the Birthdays table view controller.
    You do this by using *delegation* .
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**DELEGATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delegation can be used when one view controller needs to get information from
    another view controller. Say you have two view controllers: A and B. The first
    view controller, A, creates B and presents B on top of itself. A knows about B
    because it created and presented B, so A can pass information along to B. But
    B doesn’t know about A—it’s just popped into being and doesn’t know where it came
    from or how it got there. So how can B talk to A? Through delegation!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation is when someone gives a job or a task to someone else. A *delegate*
    is like a boss who tells a delegating employee what to do. When the delegating
    employee is done with their task, sometimes they’ll report information back to
    the delegate boss.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in Swift is pretty similar, but instead of having a boss and employee,
    we have a delegate and a delegating object. Since class B is the one being told
    what to do by class A, it’s the delegating object. We give class B a special property
    called a delegate to tell it who its delegate is—that way, it knows who to communicate
    with. The delegate can be any class that has a set of methods that have been defined
    in a *protocol* . A protocol is like an agreement between the two classes that
    tells them what the delegate can ask the delegating object to do. It has a list
    of method and property names that the delegate can use with the delegating object.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Class A creates class B, makes itself the delegate of class B, and gives class
    B a job to do that’s in the protocol. Once class B is done with its job, it reports
    back to class A. Let’s see how this works in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: The Birthdays table view controller is view controller A, and the Add Birthday
    view controller is view controller B. We’ll create a protocol called AddBirthdayViewControllerDelegate
    and a method for that protocol, addBirthdayViewController(_:didAddBirthday:) ,
    which the Add Birthday view controller will use to report back.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Figure 11-6](text00022.html#ch11fig6) . When the user taps the
    Add button ➊ , the Birthdays table view controller creates the Add Birthday view
    controller ➋ and sets itself as the Add Birthday view controller’s delegate.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-6: A new birthday is added and passed from the Add Birthday view
    controller to the Birthdays table view controller using delegation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: The AddBirthdayViewControllerDelegate protocol is defined to have one method,
    addBirthdayViewController(_:didAddBirthday:) . When the user taps Save ➌ , the
    Add Birthday view controller calls this method ➍ and passes the new birthday to
    its delegate, the Birthdays table view controller. The Birthdays table view controller
    takes that birthday, adds it to its birthdays array, and then reloads its table
    view ➎ so that the new birthday will show up in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll show you how to make an AddBirthdayViewControllerDelegate protocol with
    the method addBirthdayViewController(_:didAddBirthday:) that the Add Birthday
    view controller can call whenever a birthday is added to the app. The Birthdays
    table view controller will implement that protocol method so that whenever a birthday
    is added with the Add Birthday view controller, the Add Birthday view controller
    can just say to its delegate, “Hey! Someone just added this birthday,” and the
    Birthdays table view controller will hear the message and say, “Oh! I’ll add that
    to my list and refresh my display so the new one shows up.”
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: So now let’s do this in code!
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create the protocol. In the *AddBirthdayViewController.swift*
    file, *above* the AddBirthdayViewController class, add this code defining the
    AddBirthdayViewControllerDelegate protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: You define the protocol at ➊ by typing the keyword protocol followed by the
    name AddBirthdayViewControllerDelegate . That’s a long name, but Swift programmers
    usually name their protocols after the calling classes and add the word Delegate
    on the end. This is so you’ll be able to tell which class is using the protocol
    by looking at the protocol’s name. Since you’re a Swift programmer now, you should
    use the same naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In this protocol, addBirthdayViewController(_:didAddBirthday:) is the only function,
    and it’s used to pass the Birthday object back to the delegate class ➋ . Notice
    that you’re including AddBirthdayViewController as a parameter in this function.
    Again, Swift programmers do this based on convention when they implement protocol
    methods, so you should stick to doing it, too. It’s useful to know who sent back
    a message and for the delegate to have access to that object and its class.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: When the Add Birthday view controller calls this method, it will pass itself
    in as the addBirthdayViewController parameter. You’ll see how this is done very
    soon. The other thing to note is the external parameter name didAddBirthday .
    Many delegate protocol methods contain the words *did* and *will* because they’re
    used to describe something that the calling class has either just done or will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your protocol defined, you need to tell the Birthdays table
    view controller to adopt this protocol and use the protocol’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making the Birthdays Table View Controller Conform to Protocol**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To adopt the protocol, the Birthdays table view controller needs to make itself
    an AddBirthdayViewControllerDelegate . To allow for this, you need to add AddBirthdayViewControllerDelegate
    to the class definition right after the UITableViewController superclass. At the
    top of the class, add a comma after UITableViewController and then type AddBirthdayViewControllerDelegate
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you do that, a red error appears. This happens because BirthdaysTableViewController
    says it’s an AddBirthdayViewControllerDelegate , but it hasn’t implemented the
    protocol yet! In order to do that, it needs to implement the AddBirthdayViewControllerDelegate
    protocol definition. Not to worry—we’ll fix this soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note here that the BirthdaysTableViewController is subclassing
    the UITableViewController superclass. A class can have only one superclass, and
    that superclass name must be written before any protocols. But while a class can
    have only one superclass, it can adopt as many protocols as it wants—these will
    all be listed after the superclass and separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to conform to the AddBirthdayViewControllerDelegate protocol and fix the
    error, we need to add the addBirthdayViewController(_:didAddBirthday:) method
    to Birthdays TableViewController . A good place to add that is at the end of the
    class, right after the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: When you start typing the function name, Xcode autocomplete suggests this entire
    method declaration. This is because it knows this class adopts the AddBirthdayViewController
    Delegate protocol, and it’s expecting you to add this method. Note that unlike
    with a subclassed method, you don’t use the override keyword before addBirthdayViewController(_:didAddBirthday:)
    because there is no original method to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, you need to do two things. First, you need to add the Birthday
    that was passed in by the Add Birthday view controller to the birthdays array.
    You do this by using the append(_:) method for an array ➋ . Next, you need to
    refresh the table view so that it shows this new birthday by calling the reloadData()
    method on the tableView property ➌ . When reloadData() is called, the table view
    data source methods will be called again, and the newly added Birthday will be
    displayed at the bottom of the birthday list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we added a comment above the method to mark this
    section: // MARK: - AddBirthdayViewControllerDelegate ➊ . This isn’t necessary,
    but it’s good coding style to mark off different sections of your class, and it
    helps to keep your code clean and readable. The first part of the comment, MARK:
    - , is a special keyword that Xcode recognizes for code comments, and it adds
    the AddBirthdayViewControllerDelegate section to a drop-down table of contents
    menu that you can use at the top of your class. This drop-down menu helps you
    find methods and lets you jump to different places in your code. To use this menu,
    click Birthdays TableViewController at the top of the editor pane, as shown in
    [Figure 11-7](text00022.html#ch11fig7) .'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11-7: Your class has a built-in table of contents for quickly jumping
    to a section.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Giving the Add Birthday View Controller a Delegate**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'BirthdaysTableViewController has adopted the AddBirthdayViewControllerDelegate
    protocol. Now it’s time to make the Add Birthday view controller use the AddBirthdayViewControllerDelegate
    protocol to tell the Birthdays table view controller when it has added a birthday.
    To do this, the Add Birthday view controller first needs to define a delegate.
    We arrange for this by adding an optional delegate property of type AddBirthdayViewControllerDelegate
    to the AddBirthdayViewController class by inserting the following line right below
    the outlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*AddBirthdayViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: The delegate has to be an optional because you can’t set it until *after* the
    Add Birthday view controller has been created. You’ll learn where to set the delegate
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the Add Birthday view controller has a delegate, in the saveTapped(_:)
    method, you can pass a Birthday to the delegate using the addBirthdayViewController(_:didAddBirthday:)
    method. Change saveTapped(_:) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: After the birthday object is created, the code at ➊ passes it back to the delegate
    using addBirthdayViewController(_:didAddBirthday:) .
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’re done making changes to the Add Birthday view controller. It now
    has a delegate that will listen for the call that a Birthday was saved. Run the
    app to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Hmm . . . not much has changed. When you add a Birthday , you still aren’t seeing
    it show up in the Birthdays table view controller. What gives?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECTING THE TWO CONTROLLERS BY SETTING A DELEGATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one last thing you have to do. The Birthdays table view controller is
    an AddBirthdayViewControllerDelegate , and the Add Birthday view controller has
    an AddBirthdayViewControllerDelegate property that holds the delegate it talks
    to when a Birthday is saved. But we never specifically set the delegate property
    to be the Birthdays table view controller. So it’s time to connect the communication
    pipeline between our two view controllers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In the Navigation section of the BirthdaysTableViewController class, there’s
    a method that’s been commented out called prepare(for:sender:) . Uncomment that
    method by deleting the /* and */ that surround it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is automatically called whenever the Birthdays table view controller
    gives up its screen and the app transitions to another view controller using a
    storyboard segue. We’ll use this method to pass the Birthdays table view controller
    in to Add Birthday view controller to set itself as the Add Birthday view controller’s
    delegate. Write the following in the prepare(for:sender:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*BirthdaysTableViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: It takes three lines of code to set the Add Birthday view controller delegate
    to the Birthdays table view controller. First, you need to be able to get to the
    AddBirthdayViewController object from the segue parameter. Xcode has left in a
    comment hinting at how you can do that. A UIStoryboardSegue has a property called
    destination at the other end of the segue that is being prepared in this method,
    but the destination for this app isn’t the AddBirthdayViewController .
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](text00020.html#ch09) , you embedded the Add Birthday view controller
    into a navigation controller so you could have a navigation bar with Cancel and
    Save buttons. So you don’t expect to find the Add Birthday view controller at
    the other end of the segue. Instead, the destination is a UINavigationController
    that contains the Add Birthday view controller. The line at ➊ gets you navigationController
    . The code segue.destination will return a UIViewController , but since our navigationController
    is a specific type of ViewController , we need to typecast it to a UINavigationController
    using as .
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can get the Add Birthday view controller, which is the topViewController
    of the navigationController ➋ . The topViewController is just the view controller
    that’s being displayed in the navigationController , but its property is of type
    UIViewController , so this has to be typecast to an AddBirthdayViewController
    to indicate that this controller is a specific subclass of UIViewController .
    Finally, when you have an AddBirthdayViewController , you can set the delegate
    to self , which is currently the Birthdays table view controller ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the app and add some birthdays! What do you see in the Birthdays table
    view controller? Birthdays! Birthdays! Birthdays! We’re not quite done yet, though.
    If you quit the app and then run it again, the previous birthdays will disappear.
    We still need to save the birthdays to the device, which we’ll do in [Chapter
    12](text00023.html#ch12) .
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make a table view controller to display
    your list of birthdays. You also learned how to add a Birthday in the Add Birthday
    view controller, and then how to use a delegate to add the Birthday to the birthdays
    array in the Birthdays table view controller so that it could be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](text00023.html#ch12) , you’ll learn how to save the birthdays
    to your device so that they show up even after you quit the app and then run it
    again. To save the birthdays, you’ll use Core Data, which we set up at the very
    beginning of our project.
  prefs: []
  type: TYPE_NORMAL
