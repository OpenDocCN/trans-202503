- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**REVERSE ENGINEERING THE CAN BUS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**逆向工程 CAN 总线**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: In order to reverse engineer the CAN bus, we first have to be able to read the
    CAN packets and identify which packets control what. That said, we don’t need
    to be able to access the official diagnostic CAN packets because they’re primarily
    a read-only window. Instead, we’re interested in accessing *all* the other packets
    that flood the CAN bus. The rest of the nondiagnostic packets are the ones that
    the car actually uses to perform actions. It can take a long time to grasp the
    information contained in these packets, but that knowledge can be critical to
    understanding the car’s behavior.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逆向工程 CAN 总线，我们首先必须能够读取 CAN 数据包并识别每个数据包的控制功能。也就是说，我们不需要访问官方的诊断 CAN 数据包，因为它们主要是只读的窗口。相反，我们感兴趣的是访问
    *所有* 其他充斥在 CAN 总线上的数据包。其余的非诊断数据包才是汽车实际用来执行动作的。理解这些数据包所包含的信息可能需要很长时间，但这些知识对于理解汽车的行为至关重要。
- en: '**Locating the CAN Bus**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定位 CAN 总线**'
- en: 'Of course, before we can reverse the CAN bus, we need to locate the CAN. If
    you have access to the OBD-II connector, your vehicle’s connector pinout map should
    show you where the CAN is. (See [Chapter 2](ch02.html#ch02) for common locations
    of the OBD connectors and their pinouts.) If you don’t have access to the OBD-II
    connector or you’re looking for hidden CAN signals, try one of these methods:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们逆向分析 CAN 总线之前，首先需要定位 CAN 总线。如果您可以访问 OBD-II 接口，车辆的接头针脚图应该能告诉您 CAN 总线的位置。（有关
    OBD 接口和针脚图的常见位置，请参见[第 2 章](ch02.html#ch02)。）如果您无法访问 OBD-II 接口，或者正在寻找隐藏的 CAN 信号，请尝试以下方法：
- en: • Look for paired and twisted wires. CAN wires are typically two wires twisted
    together.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: • 寻找成对的扭绞线。CAN 总线通常由两根扭在一起的线组成。
- en: • Use a multimeter to check for a 2.5V baseline voltage. (This can be difficult
    to identify because the bus is often noisy.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用万用表检查 2.5V 基准电压。（这可能很难识别，因为总线通常很嘈杂。）
- en: • Use a multimeter to check for ohm resistance. The CAN bus uses a 120-ohm terminator
    on each end of the bus, so there should be 60 ohms between the two twisted-pair
    wires you suspect are CAN.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用万用表检查电阻值。CAN 总线在总线两端使用 120 欧姆的终端电阻，因此您怀疑是 CAN 的两根双绞线之间应该有 60 欧姆的电阻。
- en: • Use a two-channel oscilloscope and subtract the difference between the two
    suspected CAN wires. You should get a constant signal because the differential
    signals should cancel each other out. (Differential signaling is discussed in
    “[The CAN Bus](ch02.html#ch02lev1sec1)” on [page 16](ch02.html#page_16).)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用双通道示波器，并计算两个可疑 CAN 线之间的差值。您应该得到一个恒定的信号，因为差分信号应该会相互抵消。（差分信号的讨论请参见[《CAN 总线》](ch02.html#ch02lev1sec1)，[第
    16 页](ch02.html#page_16)）。
- en: '**NOTE**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If the car is turned off, the CAN bus is usually silent, but something as
    simple as inserting the car key or pulling up on the door handle will usually
    wake the vehicle and generate signals.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果汽车关闭，CAN 总线通常是静默的，但插入汽车钥匙或拉动车门把手这样简单的操作通常会唤醒汽车并生成信号。*'
- en: Once you’ve identified a CAN network, the next step is to start monitoring the
    traffic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您识别出 CAN 网络，下一步就是开始监控流量。
- en: '**Reversing CAN Bus Communications with can-utils and Wireshark**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 can-utils 和 Wireshark 逆向分析 CAN 总线通信**'
- en: First, you need to determine the type of communication running on the bus. You’ll
    often want to identify a certain signal or the way a certain component talks—for
    example, how the car unlocks or how the drivetrain works. In order to do so, locate
    the bus those target components use, and then reverse engineer the packets traveling
    on that bus to identify their purpose.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要确定总线上运行的通信类型。您通常需要识别某个特定的信号或某个组件的通信方式——例如，汽车是如何解锁的，或者传动系统是如何工作的。为此，找到目标组件使用的总线，然后逆向工程通过该总线传输的数据包，以识别它们的目的。
- en: To monitor the activity on your CAN, you need a device that can monitor and
    generate CAN packets, such as the ones discussed in [Appendix A](app01.html#app01).
    There are a *ton* of these devices on the market. The cheap OBD-II devices that
    sell for under $20 technically work, but their sniffers are slow and will miss
    a lot of packets. It’s always best to have a device that’s as open as possible
    because it’ll work with the majority of software tools—open source hardware and
    software is ideal. However, a proprietary device specifically designed to sniff
    CAN should still work. We’ll look at using `candump`, from the `can-utils` suite,
    and Wireshark to capture and filter the packets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要监视 CAN 上的活动，你需要一个可以监视和生成 CAN 数据包的设备，比如在[附录 A](app01.html#app01)中讨论的设备。市场上有*大量*这类设备。那些售价不到
    20 美元的便宜 OBD-II 设备在技术上是可行的，但它们的嗅探器速度很慢，很多数据包会被遗漏。最好使用尽可能开放的设备，因为它们与大多数软件工具兼容——开源硬件和软件是理想的选择。然而，专门设计用来嗅探
    CAN 的专有设备应该仍然有效。我们将使用 `candump`，来自 `can-utils` 套件，以及 Wireshark 来捕获和过滤数据包。
- en: Generic packet analysis won’t work for CAN because CAN packets are unique to
    each vehicle’s make and model. Also, because there’s so much noise on CAN, it’s
    too cumbersome to sort through every packet as it flows by in sequence.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的数据包分析方法对 CAN 无效，因为 CAN 数据包是针对每个车辆的品牌和型号独特的。而且，由于 CAN 上的噪声很大，逐个分析每个按顺序流过的数据包也太繁琐了。
- en: '***Using Wireshark***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Wireshark***'
- en: Wireshark (*[https://www.wireshark.org/](https://www.wireshark.org/)*) is a
    common network monitoring tool. If your background is in networking, your first
    instinct may be to use Wireshark to look at CAN packets. This technically works,
    but we will soon see why Wireshark is not the best tool for the job.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark (*[https://www.wireshark.org/](https://www.wireshark.org/)*) 是一个常用的网络监控工具。如果你有网络方面的背景，你的第一反应可能是使用
    Wireshark 来查看 CAN 数据包。技术上这是可行的，但我们很快就会看到，Wireshark 并不是这个任务的最佳工具。
- en: If you want to use Wireshark to capture CAN packets, you can do so together
    with SocketCAN. Wireshark can listen on both canX and vcanX devices, but not on
    slcanX because serial-link devices are not true netlink devices and they need
    a translation daemon in order for them to work. If you need to use a slcanX device
    with Wireshark, try changing the name from *slcanX* to *canX*. (I discuss CAN
    interfaces in detail [Chapter 2](ch02.html#ch02).)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 Wireshark 捕获 CAN 数据包，可以和 SocketCAN 一起使用。Wireshark 可以监听 canX 和 vcanX 设备，但不能监听
    slcanX，因为串行链路设备不是标准的 netlink 设备，它们需要一个翻译守护进程才能工作。如果你需要在 Wireshark 中使用 slcanX 设备，尝试将名称从
    *slcanX* 更改为 *canX*。（我在[第 2 章](ch02.html#ch02)中详细讨论了 CAN 接口。）
- en: If renaming the interface doesn’t work or you simply need to move CAN packets
    from an interface that Wireshark can’t read to one it can, you can bridge the
    two interfaces. You’ll need to use `candump` from the `can-utils` package in bridge
    mode to send packets from `slcan0` to `vcan0`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重命名接口不起作用，或者你只是需要将 CAN 数据包从 Wireshark 无法读取的接口移动到 Wireshark 可以读取的接口，你可以桥接这两个接口。你需要在桥接模式下使用
    `candump`，来自 `can-utils` 软件包，将数据包从 `slcan0` 发送到 `vcan0`。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice in [Figure 5-1](ch05.html#ch5fig1) that the data section isn’t decoded
    and is just showing raw hex bytes. This is because Wireshark’s decoder handles
    only the basic CAN header and doesn’t know how to deal with ISO-TP or UDS packets.
    The highlighted packet is a UDS request for VIN. (I’ve sorted the packets in the
    screen by identifier, rather than by time, to make it easier to read.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 [图 5-1](ch05.html#ch5fig1) 中，数据部分没有被解码，只显示原始的十六进制字节。这是因为 Wireshark 的解码器仅处理基本的
    CAN 头，并不知道如何处理 ISO-TP 或 UDS 数据包。突出显示的数据包是一个 UDS 请求 VIN。（我已将屏幕中的数据包按标识符排序，而不是按时间排序，以便更容易阅读。）
- en: '![image](graphics/f05-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-01.jpg)'
- en: '*Figure 5-1: Wireshark on the CAN bus*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：Wireshark 在 CAN 总线上的应用*'
- en: '***Using candump***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 candump***'
- en: As with Wireshark, `candump` doesn’t decode the data for you; that job is left
    up to you, as the reverse engineer. [Listing 5-1](ch05.html#ch5list1) uses `slcan0`
    as the sniffer device.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Wireshark 一样，`candump` 不会为你解码数据；这个任务留给你作为逆向工程师来完成。[列表 5-1](ch05.html#ch5list1)
    使用 `slcan0` 作为嗅探设备。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-1: `candump` of traffic streaming through a CAN bus*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：通过 CAN 总线传输的流量的 `candump`*'
- en: The columns are broken down to show the sniffer device ➊, the arbitration ID
    ➋, the size of the CAN packet ➌, and the CAN data itself ➍. Now you have some
    captured packets, but they aren’t the easiest to read. We’ll use filters to help
    identify the packets we want to analyze in more detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列被拆分显示了嗅探设备 ➊、仲裁 ID ➋、CAN 数据包的大小 ➌，以及 CAN 数据本身 ➍。现在你已经有了一些捕获的数据包，但它们并不是最容易阅读的。我们将使用过滤器来帮助识别我们想要更详细分析的数据包。
- en: '***Grouping Streamed Data from the CAN Bus***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分组来自CAN总线的数据流***'
- en: Devices on a CAN network are noisy, often pulsing at set intervals or when triggered
    by an event, such as a door unlocking. This noise can make it futile to stream
    data from a CAN network without a filter. Good CAN sniffer software will group
    changes to packets in a data stream based on their arbitration ID, highlighting
    only the portions of data that have changed since the last time the packet was
    seen. Grouping packets in this way makes it easier to spot changes that result
    directly from vehicle manipulation, allowing you to actively monitor the tool’s
    sniffing section and watch for color changes that correlate to physical changes.
    For example, if each time you unlock a door you see the same byte change in the
    data stream, you know that you’ve probably identified at least the byte that controls
    the door-unlocking functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CAN网络上的设备噪声很大，通常在设定的间隔或由事件（例如解锁门）触发时产生脉冲。这种噪声使得没有过滤器的情况下从CAN网络流式传输数据变得徒劳。好的CAN嗅探软件会根据数据流中的仲裁ID对数据包的变化进行分组，只突出显示自上次看到该数据包以来发生变化的数据部分。通过这种方式分组数据包，可以更容易地发现直接由车辆操作引起的变化，允许您积极监控工具的嗅探部分，并观察与物理变化相关的颜色变化。例如，如果每次解锁门时，您在数据流中看到相同的字节变化，您就知道您可能已经识别出了至少控制门解锁功能的字节。
- en: '**Grouping Packets with cansniffer**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用cansniffer分组数据包**'
- en: The `cansniffer` command line tool groups the packets by arbitration ID and
    highlights the bytes that have changed since the last time the sniffer looked
    at that ID. For example, [Figure 5-2](ch05.html#ch5fig2) shows the result of running
    `cansniffer` on the device `slcan0`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`cansniffer`命令行工具通过仲裁ID对数据包进行分组，并突出显示自上次嗅探器查看该ID以来发生变化的字节。例如，[图5-2](ch05.html#ch5fig2)显示了在设备`slcan0`上运行`cansniffer`的结果。'
- en: '![image](graphics/f05-02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-02.jpg)'
- en: '*Figure 5-2:* `cansniffer` *example output*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-2:* `cansniffer` *示例输出*'
- en: You can add the `-c` flag to colorize any changing bytes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加`-c`标志以对任何变化的字节进行着色。
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `cansniffer` tool can also remove repeating CAN traffic that isn’t changing,
    thereby reducing the number of packets you need to watch.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`cansniffer`工具还可以移除不发生变化的重复CAN流量，从而减少您需要监视的数据包数量。'
- en: '**Filtering the Packets Display**'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**过滤数据包显示**'
- en: 'One advantage of `cansniffer` is that you can send it keyboard input to filter
    results as they’re displayed in the terminal. (Note that you won’t see the commands
    you enter while `cansniffer` is outputting results.) For example, to see only
    IDs 301 and 308 as `cansniffer` collects packets, enter this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`cansniffer`的一个优点是您可以向它发送键盘输入，以便在终端中显示时过滤结果。（请注意，在`cansniffer`输出结果时，您不会看到您输入的命令。）例如，要在`cansniffer`收集数据包时仅查看ID
    301和308，请输入以下内容：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Entering `-000000` turns off all packets, and entering +`301` and +`308` filters
    out all except IDs 301 and 308.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`-000000`会关闭所有数据包，而输入+`301`和+`308`则会过滤掉所有除了ID 301和308的其他数据包。
- en: The `-000000` command uses a *bitmask*, which does a bit-level comparison against
    the arbitration ID. Any binary value of 1 used in a mask is a bit that has to
    be true, while a binary value of 0 is a wildcard that can match anything. A bitmask
    of all 0s tells `cansniffer` to match any arbitration ID. The minus sign (-) in
    front of the bitmask removes all matching bits, which is every packet.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`-000000`命令使用了*位掩码*，它对仲裁ID进行逐位比较。掩码中使用的任何二进制值为1的位是必须为真的位，而二进制值为0的位则是通配符，可以匹配任何内容。全为0的位掩码告诉`cansniffer`匹配任何仲裁ID。位掩码前面的减号（-）移除了所有匹配的位，即所有数据包。'
- en: You can also use a filter and a bitmask with `cansniffer` to grab a range of
    IDs. For example, the following command adds the IDs from 500 through 5FF to the
    display, where 500 is the ID applied to the bitmask of 700 to define the range
    we’re interested in.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用过滤器和位掩码与`cansniffer`一起抓取一系列ID。例如，以下命令将ID从500到5FF添加到显示中，其中500是应用于位掩码700的ID，以定义我们感兴趣的范围。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To display all IDs of 5*XX*, you’d use the following binary representation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示所有5*XX*的ID，您可以使用以下二进制表示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You could specify F00 instead of 700, but because the arbitration ID is made
    up of only 3 bits, a 7 is all that’s required.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定F00代替700，但由于仲裁ID仅由3个位组成，因此只需要一个7。
- en: Using 7FF as a mask is the same as not specifying a bitmask for an ID. For example
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用7FF作为掩码与未指定ID的位掩码相同。例如：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: is the same as
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与以下相同：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This mask uses binary math and performs an `AND` operation on the two numbers,
    0x301 and 0x7FF:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该掩码使用二进制运算，并对两个数字0x301和0x7FF执行`与`运算：
- en: ID    Binary Representation
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ID    二进制表示
- en: 301   011  0000  0001
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 301   011  0000  0001
- en: 7FF   111  1111  1111
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 7FF   111  1111  1111
- en: ______________________________
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ______________________________
- en: 011  0000  0001
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 011  0000  0001
- en: 3    0      1
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 3    0      1
- en: For those not familiar with `AND` operations, each binary bit is compared, and
    if *both* are a 1 then the output is a 1\. For instance, `1 AND 1 = 1`, while
    `1 AND 0 = 0`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉`AND`操作的人来说，每个二进制位都会被比较，如果*两个*都是1，那么输出就是1。例如，`1 AND 1 = 1`，而`1 AND 0 =
    0`。
- en: If you prefer to have a GUI interface, Kayak, which we discussed in “[Kayak](app01.html#app01lev2sec7)”
    on [page 46](ch03.html#page_46), is a CAN bus–monitoring application that also
    uses socketcand and will colorize its display of capture packets. Kayak won’t
    remove repeating packets the way `cansniffer` does, but it offers a few unique
    capabilities that you can’t easily get on the command line, such as documenting
    the identified packets in XML (*.kcd* files), which can be used by Kayak to display
    virtual instrument clusters and map data (see [Figure 5-3](ch05.html#ch5fig3)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用GUI界面，Kayak是一个CAN总线监控应用程序，它也使用socketcand，并将捕获的数据包显示为彩色。Kayak不会像`cansniffer`那样删除重复的数据包，但它提供了一些命令行上无法轻松获得的独特功能，例如将识别的数据包记录为XML（*.kcd*文件），这些文件可以被Kayak用于显示虚拟仪器集群和映射数据（参见[图5-3](ch05.html#ch5fig3)）。
- en: '![image](graphics/f05-03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-03.jpg)'
- en: '*Figure 5-3: Kayak GUI interface*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-3：Kayak GUI界面*'
- en: '***Using Record and Playback***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用记录和回放***'
- en: 'Once you’ve used `cansniffer` or a similar tool to identify certain packets
    to focus on, the next step is to record and play back packets so you can analyze
    them. We’ll look at two different tools to do this: `can-utils` and Kayak. They
    have similar functionality, and your choice of tool will depend on what you’re
    working on and your interface preferences.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用`cansniffer`或类似工具确定了需要关注的特定数据包，下一步就是记录和回放数据包，以便分析它们。我们将查看两种不同的工具来完成此操作：`can-utils`和Kayak。它们具有类似的功能，选择工具将取决于你正在处理的工作内容和你的界面偏好。
- en: The `can-utils` suite records CAN packets using a simple ASCII format, which
    you can view with a simple text editor, and most of its tools support this format
    for both recording and playback. For example, you can record with `candump`, redirect
    standard output or use the command line options to record to a file, and then
    use `canplayer` to play back recordings.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`can-utils`套件使用简单的ASCII格式记录CAN数据包，你可以通过简单的文本编辑器查看它，大多数工具都支持这种格式的记录和回放。例如，你可以使用`candump`记录，重定向标准输出或使用命令行选项将数据记录到文件中，然后使用`canplayer`回放记录。'
- en: '[Figure 5-4](ch05.html#ch5fig4) shows a view of the layout of Kayak’s equivalent
    to `cansniffer`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-4](ch05.html#ch5fig4)显示了Kayak与`cansniffer`等效的布局视图。'
- en: '![image](graphics/f05-04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-04.jpg)'
- en: '*Figure 5-4: Kayak recording to a logfile*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-4：Kayak记录到日志文件*'
- en: To record CAN packets with Kayak, first click the Play button in the Log files
    tab ➊. Then drag one or more buses from the Projects pane to the Busses field
    of the LogOutput Window tab ➋. Press the Record and Stop buttons at the bottom
    of the LogOutput window ➌ to start or stop recording. Once your packet capture
    is complete, the logging should show in the Log Directory drop-down menu (see
    [Figure 5-5](ch05.html#ch5fig5)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Kayak记录CAN数据包，首先点击日志文件选项卡中的播放按钮 ➊。然后将一个或多个总线从项目面板拖动到日志输出窗口选项卡的总线字段 ➋。按下日志输出窗口底部的记录和停止按钮
    ➌ 来开始或停止记录。一旦数据包捕获完成，日志应显示在日志目录下拉菜单中（见[图5-5](ch05.html#ch5fig5)）。
- en: If you open a Kayak logfile, you’ll see something like the code snippet in [Listing
    5-2](ch05.html#ch5list2). The values in this example won’t directly correlate
    to those in [Figure 5-4](ch05.html#ch5fig4) because the GUI groups by ID, as in
    `cansniffer`, but the log is sequential, as in `candump`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开Kayak日志文件，你将看到类似于[清单5-2](ch05.html#ch5list2)中的代码片段。这个例子中的值不会直接与[图5-4](ch05.html#ch5fig4)中的值一一对应，因为GUI按ID分组，类似于`cansniffer`，但日志是按顺序排列的，类似于`candump`。
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-2: Contents of Kayak’s logfile*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单5-2：Kayak日志文件的内容*'
- en: '![image](graphics/f05-05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-05.jpg)'
- en: '*Figure 5-5: Right pane of Log files tab settings*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-5：日志文件选项卡设置的右侧面板*'
- en: 'Other than some metadata (`PLATFORM`, `DESCRIPTION`, and `DEVICE_ALIAS`), the
    log is pretty much the same as the one captured by the `can-utils` package: ➊
    is the timestamp, ➋ is your bus, and ➌ is your arbitration ID and data separated
    by a `#` symbol. To play back the capture, right-click the **Log Description**
    in the right panel, and open the recording (see [Figure 5-5](ch05.html#ch5fig5)).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些元数据（`PLATFORM`、`DESCRIPTION`和`DEVICE_ALIAS`），日志基本上与`can-utils`包捕获的日志相同：➊是时间戳，➋是总线，➌是通过`#`符号分隔的仲裁ID和数据。要播放捕获的数据，右键单击右侧面板中的**日志描述**，然后打开录制（参见[图5-5](ch05.html#ch5fig5)）。
- en: '[Listing 5-3](ch05.html#ch5list3) shows the logfile created by `candump` using
    the `-l` command line option:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单5-3](ch05.html#ch5list3)展示了使用`candump`和`-l`命令行选项创建的日志文件：'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 5-3: `candump` logfile*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单5-3：`candump`日志文件*'
- en: Notice in [Listing 5-3](ch05.html#ch5list3) that the `candump` logfiles are
    almost identical to those displayed by Kayak in [Figure 5-4](ch05.html#ch5fig4).
    (For more details on different `can-utils` programs, see “[The CAN Utilities Suite](ch03.html#ch03lev1sec2)”
    on [page 41](ch03.html#page_41).)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[清单5-3](ch05.html#ch5list3)中的`candump`日志文件与[图5-4](ch05.html#ch5fig4)中Kayak展示的几乎完全相同。（有关不同`can-utils`程序的更多详情，请参见[《CAN工具套件》](ch03.html#ch03lev1sec2)，见[第41页](ch03.html#page_41)。）
- en: '***Creative Packet Analysis***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创意数据包分析***'
- en: Now that we’ve captured packets, it’s time to determine what each packet does
    so we can use it to unlock things or exploit the CAN bus. Let’s start with a simple
    action that’ll most likely toggle only a single bit—the code to unlock the doors—and
    see whether we can find the packet that controls that behavior.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经捕获了数据包，是时候确定每个数据包的作用了，这样我们就可以用它来解锁东西或利用CAN总线。让我们从一个简单的动作开始，这个动作最有可能只切换一个单一的比特——解锁车门的代码——并查看我们是否能找到控制该行为的数据包。
- en: '**Using Kayak to Find the Door-Unlock Control**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用Kayak查找解锁门控制**'
- en: 'There’s a ton of noise on the CAN bus, so finding a single-bit change can be
    very difficult, even with a good sniffer. But here’s a universal way to identify
    the function of a single CAN packet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: CAN总线上有大量噪音，因此即使有一个好的嗅探器，找到单个比特的变化也可能非常困难。但这里有一个通用的方法来识别单个CAN数据包的功能：
- en: Press **Record**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**录制**。
- en: Perform the physical action, such as unlocking a door.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行物理操作，比如解锁车门。
- en: Stop **Record**.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止**录制**。
- en: Press **Playback**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**播放**。
- en: See whether the action was repeated. For example, did the door unlock?
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看该操作是否被重复。例如，门是否解锁了？
- en: If pressing Playback didn’t unlock the door, a couple of things may have gone
    wrong. First, you may have missed the action in the recording, so try recording
    and performing the action again. If you still can’t seem to record and replay
    the action, the message is probably hardwired to the physical lock button, as
    is often the case with the driver’s-side door lock. Try unlocking the passenger
    door instead while recording. If that still doesn’t work, the message for the
    unlock action is either on a CAN bus other than the one you’re monitoring—you’ll
    need to find the correct one—or the playback may have caused a collision, resulting
    in the packet being stomped on. Try to replay the recording a few times to make
    sure the playback is working.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下播放没有解锁门，可能有几个地方出了问题。首先，你可能错过了录制中的动作，所以请尝试重新录制并执行该操作。如果你还是无法录制和回放该操作，消息可能是硬接入到物理锁按钮上的，通常情况下，驾驶员侧的门锁就是这样。尝试在录制时解锁乘客侧车门。如果这仍然无效，解锁动作的消息可能位于你正在监控的其他CAN总线上——你需要找到正确的总线——或者回放可能导致了冲突，导致数据包被覆盖。尝试多次回放录音，以确保回放正常工作。
- en: Once you have a recording that performs the desired action, use the method shown
    in [Figure 5-6](ch05.html#ch5fig6) to filter out the noise and locate the exact
    packet and bits that are used to unlock the door via the CAN bus.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了执行所需操作的录音，使用[图5-6](ch05.html#ch5fig6)中展示的方法，过滤噪音并定位用于通过CAN总线解锁车门的确切数据包和比特。
- en: Now, keep halving the size of the packet capture until you’re down to only one
    packet, at which point you should be able figure out which bit or bits are used
    to unlock the door. The quickest way to do this is to open your sniffer and filter
    on the arbitration ID you singled out. Unlock the door, and the bit or byte that
    changed should highlight. Now, try to unlock the car’s back doors, and see how
    the bytes change. You should be able to tell exactly which bit must be changed
    in order to unlock each door.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续将数据包捕获的大小减半，直到只剩一个数据包，此时你应该能够找出哪些比特位或字节用于解锁车门。最快的方法是打开你的嗅探器，并过滤掉你之前筛选出的仲裁
    ID。解锁车门，变化的比特位或字节应该会被高亮显示。现在，尝试解锁汽车的后车门，观察字节的变化。你应该能够准确判断出解锁每个车门需要改变哪个比特位。
- en: '![image](graphics/f05-06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-06.jpg)'
- en: '*Figure 5-6: Sample unlock reversing flow*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：解锁逆向流程示例*'
- en: '**Using can-utils to Find the Door-Unlock Control**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 can-utils 查找门解锁控制**'
- en: 'To identify packets via `can-utils`, you’d use `candump` to record and `canplayer`
    to play back the logfile, as noted earlier. Then, you’d use a text editor to whittle
    down the file before playback. Once you’re down to one packet, you can then determine
    which byte or bits control the targeted operation with the help of `cansend`.
    For instance, by removing different halves of a logfile, you can identify the
    one ID that triggers the door to unlock:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过 `can-utils` 来识别数据包，你可以使用 `candump` 来记录数据，并使用 `canplayer` 播放日志文件，正如前面所提到的。然后，使用文本编辑器缩减文件大小，再进行播放。缩减到只剩一个数据包时，你就可以通过
    `cansend` 来帮助你确定哪个字节或哪些比特位控制了目标操作。例如，通过移除日志文件的不同部分，你可以找出触发门解锁的那个 ID：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, you could edit each byte and play back the line, or you could use `cansniffer`
    with a filter of +300 to single out just the 300 arbitration ID and monitor which
    byte changes when you unlock the door. For example, if the byte that controls
    the door unlock is the sixth byte—0x0F in the preceding example—we know that when
    the sixth byte is 0x00, the doors unlock, and when it’s 0x0F, the doors lock.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以编辑每个字节并重新播放该行，或者你可以使用 `cansniffer`，并使用 +300 作为过滤器，仅筛选出 300 的仲裁 ID，监视在你解锁车门时哪个字节发生了变化。例如，如果控制门解锁的字节是第六个字节—在前面的示例中是
    0x0F—我们知道当第六个字节是 0x00 时，车门解锁；当它是 0x0F 时，车门锁定。
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This is a hypothetical example that assumes we’ve performed all the steps
    listed earlier in this chapter to identify this particular byte. The specifics
    will vary for each vehicle.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是一个假设的示例，假定我们已经按照本章之前列出的所有步骤找到了这个特定的字节。具体细节会因每辆车而异。*'
- en: 'We can verify our findings with `cansend`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `cansend` 来验证我们的发现：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If, after sending this, all the doors lock, we’ve successfully identified which
    packets control the door unlock.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发送此数据后，所有的门都锁上了，那么我们就成功地找到了控制门解锁的包。
- en: 'Now, what happens when you change the 0x0F? To find out, unlock the car and
    this time send a 0x01:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，改变 0x0F 会发生什么呢？要找出答案，解锁汽车，这次发送 0x01：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Observe that only the driver’s-side door locks and the rest stay open. If you
    repeat this process with a 0x02, only the front passenger’s-side door locks. When
    you repeat again with a 0x03, both the driver’s-side door and the front passenger’s-side
    door lock. But why did 0x03 control two doors and not a different third door?
    The answer may make more sense when you look at the binary representation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到只有驾驶员侧车门锁定，其余车门保持解锁。如果你重复这个过程并使用 0x02，那么只有前排乘客侧车门会锁定。当你再次使用 0x03 时，驾驶员侧车门和前排乘客侧车门都会锁定。但为什么
    0x03 控制的是两扇车门，而不是其他第三扇车门呢？当你查看其二进制表示时，答案可能会更加清晰：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first bit represents the driver’s-side door, and the second represents
    the front passenger’s-side door. When the bit is a 1, the door locks, and when
    it’s a 0, it unlocks. When you send an 0x0F, you’re setting all bits that could
    affect the door lock to a binary 1, thereby locking all doors:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个比特代表驾驶员侧车门，第二个比特代表前排乘客侧车门。当比特为 1 时，车门锁定；当比特为 0 时，车门解锁。当你发送 0x0F 时，意味着你将所有可能影响车门锁定的比特位设置为二进制
    1，从而锁定所有车门：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What about the remaining four bits? The best way to find out what they do is
    to simply set them to 1 and monitor the vehicle for changes. We already know that
    at least some of the 0x300 signal relates to doors, so it’s fairly safe to assume
    the other four bits will, too. If not, they might control different door-like
    behavior, such as unlatching the trunk.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的四个比特位怎么办？找出它们的作用的最佳方法就是将它们设置为 1，并监控车辆的变化。我们已经知道，至少部分 0x300 信号与车门相关，因此可以相对放心地假设其他四个比特也与车门相关。如果不是，它们可能控制不同的车门相关行为，例如打开行李厢。
- en: '**NOTE**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you don’t get a response when you toggle a bit, it may not be used at all
    and may simply be reserved.*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果在切换某个比特时没有得到响应，可能是该比特根本没有被使用，仅仅是被保留。*'
- en: '***Getting the Tachometer Reading***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取转速表读数***'
- en: Obtaining information on the tachometer (the vehicle’s speed) can be achieved
    in the same way as unlocking the doors. The diagnostic codes report the speed
    of a vehicle, but they can’t be used to set how the speed displays (and what fun
    is that?), so we need to find out what the vehicle is using to control the readings
    on the instrument cluster (IC).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 获取转速表（即车辆速度）信息的方法与解锁车门相同。诊断代码报告车辆的速度，但无法设置速度如何显示（这岂不是更有趣？），因此我们需要找出车辆控制仪表盘（IC）读数的方式。
- en: 'To save space, the RPM values won’t display as a hex equivalent of the reading;
    instead, the value is shifted such that 1000 RPM may look like 0xFA0\. This value
    is often referred to as “shifted” because in the code, the developers use bit
    shifting to perform the equivalent of multiplying or dividing. For the UDS protocol,
    this value is actually as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，转速值不会以读取值的十六进制形式显示；相反，值会进行移位，使得 1000 转速看起来像 0xFA0。这个值通常被称为“移位”，因为在代码中，开发人员使用位移操作来执行相当于乘法或除法的操作。对于
    UDS 协议，实际的值如下：
- en: '![image](graphics/f0079-01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f0079-01.jpg)'
- en: To make matters worse, you can’t monitor CAN traffic and query the diagnostic
    RPM to look for changing values at the same time. This is because vehicles often
    compress the RPM value using a proprietary method. Although the diagnostic values
    are set, they aren’t the actual packets and values that the vehicle is using,
    so we need to find the real value by reversing the raw CAN packets. (Be sure to
    put the car in park before you do this, and even lift the vehicle off the ground
    or put it on rollers first to avoid it starting suddenly and crushing you.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟的是，你无法同时监控 CAN 流量并查询诊断转速以寻找变化的值。这是因为车辆通常使用专有的方法压缩转速值。尽管诊断值已经设定，但它们并不是车辆实际使用的数据包和数值，因此我们需要通过反向解析原始
    CAN 数据包来找到实际值。（在做这项操作之前，一定要把车停在安全的位置，拉好手刹，最好将车抬起或者放在滚筒上，以防止车突然启动并将你压伤。）
- en: 'Follow the same steps that you used to find the door unlock control:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 按照你用于寻找解锁车门控制的步骤进行操作：
- en: Press **Record**.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**录制**。
- en: Press the gas pedal.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下油门踏板。
- en: Stop **Record**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止**录制**。
- en: Press **Playback**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**回放**。
- en: See whether the tachometer gauge has moved.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看转速表指示是否有所移动。
- en: You’ll probably find that a lot of engine lights flash and go crazy during this
    test because this packet is doing a lot more than just unlocking the car door.
    Ignore all the blinking warning lights, and follow the flowchart shown in [Figure
    5-6](ch05.html#ch5fig6) to find the arbitration ID that causes the tachometer
    to change. You’ll have a much higher chance of collisions this time than when
    trying to find the bit to unlock the doors because there’s a lot more going on.
    Consequently, you may have to play and record more traffic than before. (Remember
    the value conversions mentioned earlier, and keep in mind that more than one byte
    in this arbitration ID will probably control the reported speed.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此测试过程中，你可能会发现许多引擎指示灯闪烁并且变得疯狂，因为这个数据包做的远不止解锁车门。忽略所有闪烁的警告灯，按照[图 5-6](ch05.html#ch5fig6)中的流程图找到导致转速表变化的仲裁
    ID。这次发生碰撞的机会会比寻找解锁车门的比特时更大，因为涉及的内容更多。因此，你可能需要录制比之前更多的流量。（记住之前提到的数值转换，并且记住，这个仲裁
    ID 中可能有多个字节控制报告的速度。）
- en: '**Putting Kayak to Work**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 Kayak 工具**'
- en: To make things a bit easier, we’ll use Kayak’s GUI instead of `can-utils` to
    find the arbitration IDs that control the tachometer. Again, make sure that the
    car is immobilized in an open area, with the emergency brake on, and maybe even
    up on blocks or rollers. Start recording and give the engine a good rev. Then,
    stop recording and play back the data. The RPM gauge should move; if it doesn’t,
    you may be on the wrong bus and will need to locate the correct bus, as described
    earlier in this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化操作，我们将使用 Kayak 的图形界面而不是 `can-utils` 来寻找控制转速表的仲裁 ID。同样，确保车辆固定在开阔地带，紧急刹车已拉起，最好将车辆升起或放在滚筒上。开始录制并给引擎加点油。然后停止录制并回放数据。转速表应有所移动；如果没有，可能是你连接到了错误的总线，需要按照本章前面的说明找到正确的总线。
- en: Once you have the reaction you expect from the vehicle, repeat the halving process
    used to find the door unlock, with some additional Kayak options.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你从车辆获得预期的反应，重复使用找到车门解锁的二分法过程，并添加一些额外的Kayak选项。
- en: Kayak’s playback interface lets you set the playback to loop infinitely and,
    more importantly, set the “in” and “out” packets (see [Figure 5-7](ch05.html#ch5fig7)).
    The slider represents the number of packets captured. Use the slider to pick which
    packet you start and stop with during playback. You can quickly jump to the middle
    or other sections of the recording using the slider, which makes playing back
    half of a section very easy.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Kayak的回放界面允许你设置回放为无限循环，并且更重要的是，可以设置“输入”和“输出”数据包（见[图5-7](ch05.html#ch5fig7)）。滑动条表示捕获的数据包数量。使用滑动条可以选择回放时开始和停止的包。你可以通过滑动条快速跳转到录音的中间或其他部分，这使得回放一部分非常方便。
- en: '![image](graphics/f05-07.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-07.jpg)'
- en: '*Figure 5-7: Kayak playback interface*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-7：Kayak回放界面*'
- en: As for testing, you won’t be able to send only a single packet as you did when
    you tried to unlock the car because the vehicle is constantly reporting its current
    speed. To override this noise, you need to talk even faster than the normal communication
    to avoid colliding all the time. For instance, if you play your packets right
    after the real packet plays, then the last seen update will be the modified one.
    Reducing noise on the bus results in fewer collisions and cleaner demos. If you
    can send your fake packet immediately after the real packet, you often get better
    results than you would by simply flooding the bus.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 至于测试，你无法像解锁汽车时那样只发送一个数据包，因为车辆会不断报告其当前速度。为了克服这个噪声，你需要比正常通信更快地发送数据，以避免总是发生碰撞。例如，如果你在真实数据包播放之后立即播放你的数据包，那么最后看到的更新将是修改后的数据。减少总线上的噪声可以减少碰撞，并让演示更加干净。如果你能在真实数据包之后立即发送伪造的数据包，通常比单纯地洪水式发送数据包得到更好的结果。
- en: To send packets continuously with `can-utils`, you can use a `while` loop with
    `cansend` or `cangen`. (When using Kayak’s Send Frame dialog to transmit packets,
    make sure to check the Interval box.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`can-utils`持续发送数据包，你可以使用一个带有`cansend`或`cangen`的`while`循环。（当使用Kayak的发送帧对话框发送数据包时，请确保选中间隔框。）
- en: '**Creating Background Noise with the Instrument Cluster Simulator**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用仪表盘模拟器创建背景噪声**'
- en: The instrument cluster simulator (ICSim) is one of the most useful tools to
    come out of Open Garages, a group that fosters open collaboration between mechanics,
    performance tuners, and security researchers (see [Appendix A](app01.html#app01)).
    ICSim is a software utility designed to produce a few key CAN signals in order
    to provide a lot of seemingly “normal” background CAN noise—essentially, it’s
    designed to let you practice CAN bus reversing without having to tinker around
    with your car. (ICSim is Linux only because it relies on the virtual CAN devices.)
    The methods you’ll learn playing with ICSim will directly translate to your target
    vehicles. ICSim was designed as a safe way to familiarize yourself with CAN reversing
    so that the transition to an actual vehicle is as seamless as possible.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表盘模拟器（ICSim）是Open Garages推出的最有用的工具之一，Open Garages是一个促进机械师、性能调校师和安全研究人员之间开放合作的组织（见[附录A](app01.html#app01)）。ICSim是一个软件工具，旨在产生一些关键的CAN信号，以提供大量看似“正常”的背景CAN噪声——本质上，它是让你在不需要动你的车的情况下练习CAN总线逆向工程。（ICSim仅限Linux，因为它依赖于虚拟CAN设备。）你通过使用ICSim学到的方法可以直接应用到目标车辆上。ICSim设计为一种安全的方式，让你熟悉CAN逆向工程，以便过渡到实际车辆时能够尽可能无缝。
- en: '***Setting Up the ICSim***'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置ICSim***'
- en: Grab the source code for the ICSim from *[https://github.com/zombieCraig/ICSim](https://github.com/zombieCraig/ICSim)*
    and follow the README file supplied with the download to compile the software.
    Before you run ICSim, you should find a sample script in the README called *setup_vcan.sh*
    that you can run to set up a `vcan0` interface for the ICSim to use.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://github.com/zombieCraig/ICSim](https://github.com/zombieCraig/ICSim)*获取ICSim的源代码，并按照下载的README文件中的说明编译软件。在运行ICSim之前，你应该在README中找到一个名为*setup_vcan.sh*的示例脚本，运行它来设置一个`vcan0`接口供ICSim使用。
- en: 'ICSim comes with two components, `icsim` and `controls`, which talk to each
    other over a CAN bus. To use ICSim, first load the instrument cluster to the vcan
    device like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ICSim包括两个组件，`icsim`和`controls`，它们通过CAN总线互相通信。要使用ICSim，首先将仪表盘加载到vcan设备，如下所示：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In response, you should see the ICSim instrument cluster with turn signals,
    a speedometer, and a picture of a car, which will be used to show the car doors
    locking and unlocking (see [Figure 5-8](ch05.html#ch5fig8)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，你应该看到ICSim仪表盘，带有转向灯、速度表和一辆车的图片，这些会用于显示车门的锁定与解锁状态（见[图5-8](ch05.html#ch5fig8)）。
- en: '![image](graphics/f05-08.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-08.jpg)'
- en: '*Figure 5-8: ICSim instrument cluster*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-8：ICSim仪表盘*'
- en: 'The `icsim` application listens only for CAN signals, so when the ICSim first
    loads, you shouldn’t see any activity. In order to control the simulator, load
    the CANBus Control Panel like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`icsim`应用程序只监听CAN信号，因此当ICSim首次加载时，你不应该看到任何活动。为了控制模拟器，像这样加载CANBus控制面板：'
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The CANBus Control Panel shown in [Figure 5-9](ch05.html#ch5fig9) should appear.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会出现如[图5-9](ch05.html#ch5fig9)所示的CANBus控制面板。
- en: '![image](graphics/f05-09.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-09.jpg)'
- en: '*Figure 5-9: ICSim control interface*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-9：ICSim控制界面*'
- en: The screen looks like a game controller; in fact, you can plug in a USB game
    controller, and it should be supported by ICSim. (As of this writing, you can
    use `sixad` tools to connect a PS3 controller over Bluetooth as well.) You can
    use the controller to operate the ICSim in a method similar to driving a car using
    a gaming console, or you can control it by pressing the corresponding keys on
    your keyboard (see [Figure 5-9](ch05.html#ch5fig9)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕看起来像一个游戏控制器；事实上，你可以插入一个USB游戏控制器，它应该被ICSim支持。（截至本文撰写时，你也可以使用`sixad`工具通过蓝牙连接PS3控制器。）你可以使用控制器以类似于使用游戏主机驾驶汽车的方式操作ICSim，或者你可以通过按下键盘上的相应键来控制它（见[图5-9](ch05.html#ch5fig9)）。
- en: '**NOTE**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Once the control panel is loaded, you should see the speedometer idle just
    above 0 mph. If the needle is jiggling a bit, you know it’s working. The control
    application writes only to the CAN bus and has no other way to communicate with
    the* `icsim`. *The only way to control the virtual car is through the CAN.*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制面板加载后，你应该看到速度表在0 mph附近保持空闲。如果指针有些抖动，你就知道它在工作。控制应用程序仅向CAN总线写入数据，无法通过其他方式与`icsim`进行通信。控制虚拟汽车的唯一方式是通过CAN。*'
- en: 'The main controls on the CANBus Control Panel are as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: CANBus控制面板的主要控制项如下：
- en: '**Accelerate (up arrow)** Press this to make the speedometer go faster. The
    longer you hold the key down, the faster the virtual vehicle goes.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**加速（上箭头）** 按下此键使得速度表加速。你按住键的时间越长，虚拟车辆行驶得越快。'
- en: '**Turn (left/right arrows)** Hold down a turn direction to blink the turn signals.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**转向（左/右箭头）** 按住一个转向方向键以闪烁转向灯。'
- en: '**Lock (left SHIFT), Unlock (right SHIFT)** This one requires you to press
    two buttons at once. Hold down the left SHIFT and press a button (A, B, X, or
    Y) to lock a corresponding door. Hold down the right SHIFT and press one of the
    buttons to unlock a door. If you hold down left SHIFT and then press right SHIFT,
    it will *unlock* all the doors. If you hold down right SHIFT and press left SHIFT,
    you’ll *lock* all the doors.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**锁定（左SHIFT），解锁（右SHIFT）** 这个操作需要你同时按下两个按钮。按住左SHIFT并按下一个按钮（A、B、X或Y）来锁定相应的车门。按住右SHIFT并按下一个按钮来解锁车门。如果按住左SHIFT然后按右SHIFT，它将*解锁*所有车门。如果按住右SHIFT然后按左SHIFT，它将*锁定*所有车门。'
- en: Make sure you can fit both the ICSim and the CANBus Control Panel on the same
    screen so that you can see how they influence each other. Then, select the control
    panel so that it’s ready to receive input. Play around with the controls to make
    sure that the ICSim is responding properly. If you don’t see a response to your
    controls, ensure that the ICSim control window is selected and active.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你可以将ICSim和CANBus控制面板放在同一屏幕上，以便你可以看到它们如何相互影响。然后，选择控制面板，确保它准备好接收输入。玩一下这些控制项，确保ICSim能正确响应。如果你没有看到控制项的响应，请确保选择并激活了ICSim控制窗口。
- en: '***Reading CAN Bus Traffic on the ICSim***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在ICSim上读取CAN总线流量***'
- en: When you’re sure everything is working, fire up your sniffer of choice and take
    a look at the CAN bus traffic, as shown in [Figure 5-10](ch05.html#ch5fig10).
    Try to identify which packets control the vehicle, and create scripts to control
    ICSim without using the control panel.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确认一切正常工作时，启动你选择的嗅探器并查看CAN总线流量，如[图5-10](ch05.html#ch5fig10)所示。尝试识别哪些数据包控制着车辆，并创建脚本以在不使用控制面板的情况下控制ICSim。
- en: Most of the changing data you see in [Figure 5-10](ch05.html#ch5fig10) is caused
    by a replay file of a real CAN bus. You’ll have to sort through the messages to
    determine the proper packets. All methods of replay and packet sending will work
    with ICSim, so you can validate your findings.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[图 5-10](ch05.html#ch5fig10)中看到的大部分数据变化是由真实 CAN 总线的回放文件引起的。你需要筛选这些消息，以确定正确的数据包。所有回放和数据包发送方法都可以与
    ICSim 一起使用，因此你可以验证你的发现。
- en: '![image](graphics/f05-10.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f05-10.jpg)'
- en: '*Figure 5-10: Screen layout for using ICSim*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-10：使用 ICSim 的屏幕布局*'
- en: '***Changing the Difficulty of ICSim***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***改变 ICSim 的难度***'
- en: 'One of the great things about ICSim is that you can challenge yourself by making
    it harder to find the target CAN traffic. ICSim supports four difficulty levels—0
    through 3, with level 1 as the default. Level 0 is a super simple CAN packet that
    does the intended operation without any background noise, while level 3 randomizes
    all the bytes in the packet as well. To have the simulator choose different IDs
    and target byte positions, use ICSim’s randomize option:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ICSim 的一个优点是，你可以通过让目标 CAN 流量更难找到来挑战自己。ICSim 支持四个难度级别——0 到 3，级别 1 为默认值。级别 0 是一个超级简单的
    CAN 数据包，它执行预定的操作，没有任何背景噪音，而级别 3 会随机化数据包中的所有字节。要让模拟器选择不同的 ID 和目标字节位置，请使用 ICSim
    的随机化选项：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This option prints a randomized seed value to the console screen.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项将一个随机种子值打印到控制台屏幕上。
- en: 'Pass this value into the CANBus Control Panel along with your choice of difficulty
    level:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将此值与选择的难度级别一起传入 CANBus 控制面板：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can replay or share a specific seed value as well. If you find one you
    like or if you want to race your friends to see who can decipher the packets first,
    launch ICSim with a set seed value like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以回放或分享一个特定的种子值。如果你找到一个喜欢的，或者想与朋友竞赛看谁先解码数据包，可以使用类似这样的固定种子值启动 ICSim：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, launch the CANBus Control Panel using the same seed value to sync up the
    randomized control panel to the ICSim. If the seed values aren’t the same, they
    won’t be able to communicate.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用相同的种子值启动 CANBus 控制面板，将随机控制面板与 ICSim 同步。如果种子值不相同，它们将无法进行通信。
- en: It may take you a while to locate the proper packets the first time using ICSim,
    but after a few passes, you should be able to quickly identify which packets are
    your targets.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用 ICSim 时，可能需要一些时间来找到正确的数据包，但经过几次操作后，你应该能够迅速识别出哪些数据包是你的目标。
- en: 'Try to complete the following challenges in ICSim:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 ICSim 中完成以下挑战：
- en: Create “hazard lights.” Make both turn signals blink at the same time.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建“危险信号灯”。使两个转向信号灯同时闪烁。
- en: Create a command that locks only the back two doors.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个命令，仅锁定后面两个车门。
- en: Set the speedometer as close as possible to 220 mph.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将速度表尽可能设置为 220 mph。
- en: '**Reversing the CAN Bus with OpenXC**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 OpenXC 反向工程 CAN 总线**'
- en: Depending on your vehicle, one solution to reverse engineering the CAN bus is
    OpenXC, an open hardware and software standard that translates proprietary CAN
    protocols into an easy-to-read format. The OpenXC initiative was spearheaded by
    the Ford Motor Company—and as I write this, OpenXC is supported only by Ford—but
    it could work with any auto manufacturer that supports it. (Visit *[http://openxcplatform.com/](http://openxcplatform.com/)*
    for information on how to acquire a pre-made dongle.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的车辆，反向工程 CAN 总线的一种解决方案是 OpenXC，这是一个开放的硬件和软件标准，能够将专有的 CAN 协议转换为易于阅读的格式。OpenXC
    项目由福特汽车公司发起——目前，OpenXC 仅由福特支持——但它可以与任何支持该标准的汽车制造商兼容。（请访问 *[http://openxcplatform.com/](http://openxcplatform.com/)*
    获取如何获取预制加密狗的信息。）
- en: Ideally, open standards for CAN data such as OpenXC will remove the need for
    many applications to reverse engineer CAN traffic. If the rest of the automotive
    industry were to agree on a standard that defines how their vehicles work, it
    would greatly improve a car owner’s ability to tinker and build on new innovative
    tools.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，像 OpenXC 这样的 CAN 数据开放标准将消除许多应用程序需要反向工程 CAN 流量的需求。如果汽车行业其他公司能就一个定义如何工作标准达成一致，将极大地提升车主自己动手改装和开发创新工具的能力。
- en: '***Translating CAN Bus Messages***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***翻译 CAN 总线消息***'
- en: If a vehicle supports OpenXC, you can plug a vehicle interface (VI) in to the
    CAN bus, and the VI should translate the proprietary CAN messages and send them
    to your PC so you can read the supported packets without having to reverse them.
    In theory, OpenXC should allow access to any CAN packet via a standard API. This
    access could be read-only or allow you to transmit packets. If more auto manufacturers
    eventually support OpenXC, it could provide third-party tools with more raw access
    to a vehicle than they would have with standard UDS diagnostic commands.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果车辆支持 OpenXC，你可以将车辆接口（VI）插入 CAN 总线，VI 应该能够翻译专有的 CAN 消息并将它们发送到你的电脑，这样你就可以读取支持的数据包，而无需进行逆向工程。从理论上讲，OpenXC
    应该允许通过标准 API 访问任何 CAN 数据包。此访问可能是只读的，也可能允许你传输数据包。如果更多的汽车制造商最终支持 OpenXC，它可以为第三方工具提供比标准
    UDS 诊断命令更原始的车辆访问权限。
- en: '**NOTE**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*OpenXC supports Python and Android and includes tools such as* `openxc-dump`
    *to display CAN activity.*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*OpenXC 支持 Python 和 Android，并包括如* `openxc-dump` *等工具，用于显示 CAN 活动。*'
- en: 'The fields from OpenXC’s default API are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: OpenXC 默认 API 的字段如下：
- en: • `accelerator_pedal_position`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: • `accelerator_pedal_position`
- en: • `brake_pedal_status`
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: • `brake_pedal_status`
- en: • `button_event` (typically steering wheel buttons)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: • `button_event`（通常是方向盘按钮）
- en: • `door_status`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: • `door_status`
- en: • `engine_speed`
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: • `engine_speed`
- en: • `fuel_consumed_since_last_restart`
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: • `fuel_consumed_since_last_restart`
- en: • `fuel_level`
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: • `fuel_level`
- en: • `headlamp_status`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: • `headlamp_status`
- en: • `high_beam_status`
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: • `high_beam_status`
- en: • `ignition_status`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: • `ignition_status`
- en: • `latitude`
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: • `latitude`
- en: • `longitude`
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: • `longitude`
- en: • `odometer`
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: • `odometer`
- en: • `parking_brake_status`
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: • `parking_brake_status`
- en: • `steering_wheel_angle`
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: • `steering_wheel_angle`
- en: • `torque_at_transmission`
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: • `torque_at_transmission`
- en: • `transmission_gear_position`
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: • `transmission_gear_position`
- en: • `vehicle_speed`
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: • `vehicle_speed`
- en: • `windshield_wiper_status`
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: • `windshield_wiper_status`
- en: Different vehicles may support different signals than the ones listed here or
    no signals at all.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的车辆可能支持与这里列出的信号不同的信号，或者根本不支持任何信号。
- en: OpenXC also supports JSON trace output for recording vehicle journey. JSON provides
    a common data format that’s easy for most other modern languages to consume, as
    shown in [Listing 5-4](ch05.html#ch5list4).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: OpenXC 还支持用于记录车辆行程的 JSON 跟踪输出。JSON 提供了一种通用的数据格式，便于大多数其他现代编程语言使用，如 [列出 5-4](ch05.html#ch5list4)
    中所示。
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 5-4: Simple JSON file output*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 5-4：简单的 JSON 文件输出*'
- en: 'Notice how the metadata definitions in JSON make it fairly easy for both humans
    and a programming language to read and interpret. The above JSON listing is a
    definition file, so an API request would be even smaller. For example, when requesting
    the field `steering_wheel_angle`, the translated CAN packets would look like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JSON 中的元数据定义使得人类和编程语言都能相对容易地读取和解释。上述 JSON 列表是一个定义文件，所以 API 请求会更小。例如，当请求字段
    `steering_wheel_angle` 时，转换后的 CAN 数据包将如下所示：
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can interface with the OpenXC with OBD like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样通过 OBD 接口与 OpenXC 进行交互：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***Writing to the CAN Bus***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***写入 CAN 总线***'
- en: If you want to write back to the bus, you *might* be able to use something like
    the following line, which writes the steering wheel angle back to the vehicle,
    but you’ll find that the device will resend only a few messages to the CAN bus.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将数据写回总线，你*可能*可以使用如下的行，将方向盘角度写回车辆，但你会发现设备只会重新发送少量消息到 CAN 总线。
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Technically, OpenXC supports raw CAN writes, too, like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，OpenXC 也支持原始的 CAN 写入，如下所示：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This brings us back from translated JSON to raw CAN hacking, as described earlier
    in this chapter. However, if you want to write an app or embedded graphical interface
    to only read and react to your vehicle and you own a new Ford, then this may be
    the quickest route to those goals.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们从已翻译的 JSON 数据带回到原始的 CAN 黑客技术，正如本章前面所述。如果你想编写一个应用程序或嵌入式图形界面，只读取并响应你的车辆信息，并且你拥有一辆新款福特车，那么这可能是实现这些目标的最快途径。
- en: '***Hacking OpenXC***'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***黑客 OpenXC***'
- en: If you’ve done the work to reverse the CAN signals, you can even make your own
    VI OpenXC firmware. Compiling your own firmware means you don’t have any limitations,
    so you can read and write whatever you want and even create “unsupported” signals.
    For example, you could create a signal for `remote_engine_start` and add it to
    your own firmware in order to provide a simple interface to start your car. Hooray,
    open source!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了 CAN 信号的逆向工程工作，你甚至可以制作自己的 VI OpenXC 固件。编译你自己的固件意味着你没有任何限制，所以你可以随心所欲地读取和写入数据，甚至可以创建“未支持”的信号。例如，你可以创建一个
    `remote_engine_start` 信号，并将其添加到自己的固件中，从而提供一个简单的接口来启动你的车。太棒了，开源！
- en: Consider a signal that represents `engine_speed`. [Listing 5-5](ch05.html#ch5list5)
    will set a basic configuration to output the `engine_speed` signal. We’ll send
    RPM data with a 2-byte-long message ID 0x110 starting at the second byte.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个表示`engine_speed`的信号。[列表5-5](ch05.html#ch5list5)将设置一个基本配置来输出`engine_speed`信号。我们将发送一个2字节长、消息ID为0x110的RPM数据，从第二个字节开始。
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 5-5: Simple OpenXC config file to define* `engine_speed`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-5：定义`engine_speed`的简单OpenXC配置文件*'
- en: The OpenXC config files that you want to modify are stored in JSON. First, we
    define the bus by creating a JSON file with a text editor. In the example, we
    create a JSON config for a signal on the high-speed bus running at 500Kbps.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要修改的OpenXC配置文件存储在JSON中。首先，我们通过使用文本编辑器创建一个JSON文件来定义总线。在示例中，我们为一个在500Kbps运行的高速总线上的信号创建一个JSON配置。
- en: 'Once you have the JSON config defined, use the following code to compile it
    into a CPP file that can be compiled into the firmware:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了JSON配置文件，就可以使用以下代码将其编译成一个CPP文件，进而编译成固件：
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, recompile the VI firmware with these commands:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令重新编译VI固件：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If all goes well, you should have a *.bin* file that can be uploaded to your
    OpenXC-compatible device. The default bus is set up in raw read/write mode that
    sets the firmware to a cautionary read-only mode by default, unless signals or
    a whole bus is set up to support writing. To set those up, when defining the bus,
    you can add `raw_can_mode` or `raw_writable` and set them to true.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会得到一个*.bin*文件，可以上传到你的OpenXC兼容设备。默认总线设置为原始读/写模式，默认情况下将固件设置为警告性的只读模式，除非信号或整个总线被设置为支持写入。要设置这些，当定义总线时，你可以添加`raw_can_mode`或`raw_writable`并将其设置为true。
- en: By making your own config files for OpenXC, you can bypass the restrictions
    set up in prereleased firmware and support other vehicles besides Ford. Ideally,
    other manufacturers will begin to support OpenXC, but adoption has been slow,
    and the bus restrictions are so strict you’ll probably want to use custom firmware
    anyhow.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为OpenXC制作自己的配置文件，你可以绕过预发布固件中设置的限制，并支持除福特外的其他车辆。理想情况下，其他制造商会开始支持OpenXC，但采用进展缓慢，而且总线限制非常严格，你可能还是希望使用自定义固件。
- en: '**Fuzzing the CAN Bus**'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**CAN总线模糊测试**'
- en: Fuzzing the CAN bus can be a good way to find undocumented diagnostic methods
    or functions. Fuzzing takes a random, shotgun-like approach to reversing. When
    *fuzzing*, you send random-ish data to an input and look for unexpected behavior,
    which in the case of a vehicle could be physical changes, such as IC messages,
    or component crashes, such as shutdowns or reboots.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对CAN总线进行模糊测试是发现未记录的诊断方法或功能的好方法。模糊测试采取随机的、类似散弹枪的反向工程方法。在进行*模糊测试*时，你会向输入发送随机数据并观察是否有意外的行为，对于车辆来说，这可能是物理变化，比如IC消息，或者组件崩溃，比如关闭或重启。
- en: The good news is that it’s easy to make a CAN fuzzer. The bad news is that it’s
    rarely useful. Useful packets are often part of a collection of packets used to
    cause a particular change, such as a diagnostic service that is active only after
    a successful security token has been passed to it, so it’s difficult to tell which
    packet to focus on when fuzzing. Also, some CAN packets are visible only from
    within a moving vehicle, which would be very dangerous. Nevertheless, don’t rule
    out fuzzing as a potential method of attack because you can sometimes use it to
    locate undocumented services or crashes to a target component you want to spoof.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，制作一个CAN模糊测试器很容易。坏消息是，它很少有用。有效的数据包通常是用于引发特定变化的数据包集合的一部分，比如一个诊断服务，只有在成功传递安全令牌之后才会激活，因此很难在模糊测试时判断应该集中在哪个数据包上。此外，一些CAN数据包只有在移动的车辆内才可见，这会非常危险。尽管如此，不要排除将模糊测试作为潜在攻击方法，因为有时你可以用它来找到未记录的服务或导致目标组件崩溃的漏洞。
- en: Some sniffers support fuzzing directly—a feature usually found in the transmission
    section and represented by the tool’s ability to transmit packets with incrementing
    bytes in the data section. For example, in the case of SocketCAN, you can use
    `cangen` to generate random CAN traffic. Several other open source CAN sniffing
    solutions allow for easy scripting or programming with languages such as Python.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一些嗅探器直接支持模糊测试——这一特性通常出现在传输部分，表现为工具能够传输数据部分字节递增的数据包。例如，在SocketCAN的情况下，你可以使用`cangen`来生成随机的CAN流量。其他一些开源CAN嗅探解决方案也允许使用Python等语言进行轻松的脚本编写或编程。
- en: A good starting point for fuzzing is to look at the UDS commands, specifically
    the “undocumented” manufacturer commands. When fuzzing undocumented UDS modes,
    we typically look for any type of response from an unknown mode. For instance,
    when targeting the UDS diagnostics of the ECU, you might send random data to ID
    0x7DF and get an error packet from an unexpected mode. If you use brute-forcing
    tools such as CaringCaribou, however, there are often cleaner ways of accomplishing
    the same thing, such as monitoring or reversing the diagnostic tools themselves.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的模糊测试起点是查看UDS命令，特别是“未记录”的制造商命令。在进行未记录的UDS模式模糊测试时，我们通常会寻找来自未知模式的任何响应。例如，当针对ECU的UDS诊断时，你可能会向ID
    0x7DF发送随机数据，并从一个意外模式收到错误数据包。然而，如果你使用像CaringCaribou这样的暴力破解工具，通常会有更简洁的方法来实现相同的目标，比如监控或逆向诊断工具本身。
- en: '**Troubleshooting When Things Go Wrong**'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**问题解决指南**'
- en: The CAN bus and its components are fault-tolerant, which limits the damage you
    can do when reversing the CAN bus. However, if you’re fuzzing the CAN bus or replaying
    a large amount of CAN data back on a live CAN bus network, things can go wrong.
    Here are a few common problems and solutions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: CAN总线及其组件具有容错能力，这限制了逆向CAN总线时可能造成的损坏。然而，如果你正在对CAN总线进行模糊测试或在实时CAN总线网络中重播大量CAN数据，问题可能会出现。以下是一些常见问题及其解决方法。
- en: '**Flashing IC Lights**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**IC灯闪烁**'
- en: It’s common for the IC lights to flash when sending packets to the CAN bus,
    and you can usually reset them by restarting the vehicle. If restarting the vehicle
    still doesn’t fix the lights, try disconnecting and reconnecting the battery.
    If that still doesn’t fix the problem, make sure that your battery is properly
    charged since a low battery can also make the IC lights flash.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在向CAN总线发送数据包时，IC灯闪烁是很常见的，通常可以通过重启车辆来重置这些灯。如果重启车辆后问题仍未解决，尝试断开并重新连接电池。如果这样仍无法解决问题，确保电池充足电量，因为电池电量低也可能导致IC灯闪烁。
- en: '**Car Not Turning On**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**汽车无法启动**'
- en: If your car shuts off and won’t turn back on, it’s usually because you’ve drained
    the battery by working with the CAN bus while the car is not fully running. This
    can drain a battery much faster than you might think. To restart it, jump the
    vehicle with a spare battery.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果汽车关闭后无法重新启动，通常是因为你在汽车未完全运行的情况下与CAN总线进行操作，这样会快速消耗电池。为了重新启动，可以使用备用电池启动车辆。
- en: If you’ve tried jumping the vehicle and it still won’t turn on, you may need
    to pull a fuse and plug it back in to restart the car. Locate the engine fuses
    in the car’s manual and begin by pulling the ones you most suspect are the culprits.
    The fuse probably isn’t blown, so just pull it out and put it back in to force
    the problem device to restart. The fuses you choose to pull will depend on your
    type of vehicle, but if your engine isn’t starting, you will want to locate major
    components to disconnect and check. Look for main fuses around major electronics.
    The fuses that control the headlamps probably are not the culprits. Use a process
    of elimination to determine the device that is causing the issue.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经尝试使用跳线启动，但汽车仍无法启动，可能需要拔掉一个保险丝并重新插回去以重新启动汽车。查找汽车手册中的发动机保险丝，首先拔掉你最怀疑的保险丝。保险丝可能没有熔断，因此只需拔出并重新插回去，强制相关设备重新启动。你选择拔掉的保险丝将取决于你的汽车类型，但如果发动机无法启动，你将需要找到主要部件来断开并检查。寻找主要电子设备周围的保险丝。控制前大灯的保险丝可能不是罪魁祸首。通过排除法找出导致问题的设备。
- en: '**Car Not Turning Off**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**汽车无法关闭**'
- en: You might find that you’re unable to shut the car down. This is a bad, but fortunately
    rare, situation. First, check that you aren’t flooding the CAN bus with traffic;
    if you are, stop and disconnect from the CAN bus. If you’re already disconnected
    from the CAN bus and your car still won’t turn off, you’ll need to start pulling
    fuses until it does.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现无法关闭汽车。这是一个糟糕但幸运的罕见情况。首先，检查你是否在向CAN总线发送大量流量；如果是，停止并断开与CAN总线的连接。如果你已经与CAN总线断开连接，且汽车仍无法关闭，你需要开始拔掉保险丝，直到汽车能关闭为止。
- en: '**Vehicle Responding Recklessly**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**车辆反应失控**'
- en: This will only occur if you’re injecting packets in a moving vehicle, which
    is a terrible idea and should never be done! If you must audit a vehicle while
    it’s wheels are moving, raise it off the ground or on rollers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这只有在你在行驶中的车辆上注入数据包时才会发生，这是一个非常糟糕的主意，绝对不应这样做！如果你必须在车辆行驶时进行审计，应该将其抬离地面或放在滚筒上。
- en: '**Bricking**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**砖化**'
- en: Reverse engineering the CAN bus should never result in bricking—that is, breaking
    the vehicle so completely that it can do nothing. To brick a vehicle, you would
    need to mess around with the firmware, which would put the vehicle or component
    out of warranty and is done at your own risk.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程CAN总线绝不应导致“砖化”——即将车辆彻底损坏，以至于无法使用。要让车辆“砖化”，你需要修改固件，这样做会使车辆或组件失去保修，并且是自担风险。
- en: '**Summary**'
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned how to identify CAN wires from the jumble of wires
    under the dash, and how to use tools like `cansniffer` and Kayak to sniff traffic
    and identify what the different packets were doing. You also learned how to group
    CAN traffic to make changes easier to identify than they would be when using more
    traditional packet-sniffing tools, such as Wireshark.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何从仪表板下方杂乱的电缆中识别出CAN总线电缆，以及如何使用像`cansniffer`和Kayak这样的工具嗅探流量并识别不同数据包的作用。你还学习了如何将CAN流量分组，以便比使用传统的数据包嗅探工具（如Wireshark）时更容易识别更改。
- en: You should now be able to look at CAN traffic and identify changing packets.
    Once you identify these packets, you can write programs to transmit them, create
    files for Kayak to define them, or create translators for OpenXC to make it easy
    to use dongles to interact with your vehicle. You now have all the tools you need
    to identify and control the components of your vehicle that run on CAN.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够查看CAN流量并识别变化的数据包。一旦识别出这些数据包，你可以编写程序来传输它们，创建Kayak文件来定义它们，或者为OpenXC创建翻译器，方便使用加密狗与车辆进行交互。现在，你已经具备了识别和控制运行在CAN总线上的车辆组件所需的所有工具。
