["```\nnameScore :: (String,Int)\nnameScore = (\"Albert Einstein\", 79)\n```", "```\npythag :: (R,R) -> R\npythag (x,y) = sqrt (x**2 + y**2)\n```", "```\nPrelude> fst (\"Albert Einstein\", 79)\n\"Albert Einstein\"\n```", "```\nPrelude> :t fst\nfst :: (a, b) -> a\nPrelude> :t snd\nsnd :: (a, b) -> b\n```", "```\npythagCurried :: R -> R -> R\npythagCurried x y = sqrt (x**2 + y**2)\n```", "```\nPrelude> :l Tuples\n[1 of 1] Compiling Main            ( Tuples.lhs, interpreted )\nOk, one module loaded.\n```", "```\n*Main> :t pythagCurried\npythagCurried :: R -> R -> R\n*Main> :t curry pythag\ncurry pythag :: R -> R -> R\n```", "```\n*Main> :t pythag\npythag :: (R, R) -> R\n\n*Main> :t uncurry pythagCurried\nuncurry pythagCurried :: (R, R) -> R\n```", "```\n*Main> :t curry\ncurry :: ((a, b) -> c) -> a -> b -> c\n*Main> :t uncurry\nuncurry :: (a -> b -> c) -> (a, b) -> c\n```", "```\nfst3 :: (a,b,c) -> a\nfst3 (x,y,z) = x\n\nsnd3 :: (a,b,c) -> b\nsnd3 (_,y,_) = y\n\nthd3 :: (a,b,c) -> c\nthd3 (_x,_y,z) = z\n```", "```\nfindFirst :: (b -> Bool) -> [b] -> b\n```", "```\nfindFirstMaybe :: (b -> Bool) -> [b] -> Maybe b\n```", "```\nfindFirstMaybe p xs = case dropWhile (not . p) xs of\n                        []    -> Nothing\n                        (x:_) -> Just x\n```", "```\n*Main> :t zip\nzip :: [a] -> [b] -> [(a, b)]\n```", "```\n*Main> :t zipWith\nzipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\n```", "```\n*Main> :t unzip\nunzip :: [(a, b)] -> ([a], [b])\n```", "```\ngrades :: [(String, Int)]\ngrades = [ (\"Albert Einstein\", 89)\n         , (\"Isaac Newton\"   , 95)\n         , (\"Alan Turing\"    , 91)\n         ]\n```", "```\n*Main> :t lookup\nlookup :: Eq a => a -> [(a, b)] -> Maybe b\n*Main> lookup \"Isaac Newton\" grades\nJust 95\n*Main> lookup \"Richard Feynman\" grades\nNothing\n```", "```\ntxPairs :: [(R,R)]\ntxPairs = [(t,yRock30 t) | t <- [0,0.1..6]]\n\ntype R = Double\n```", "```\ntxPairs' :: [(R,R)]\ntxPairs' = map (\\t -> (t,yRock30 t)) [0,0.1..6]\n\nyRock30 :: R -> R\nyRock30 t = 30 * t - 0.5 * 9.8 * t**2\n```", "```\ntxPairsInAir :: [(R,R)]\ntxPairsInAir\n   = [(t,yRock30 t) | t <- [0,0.1..20], yRock30 t > 0]\n```", "```\ntxPairsInAir' :: [(R,R)]\ntxPairsInAir'\n   = map (\\t -> (t,yRock30 t)) $\n     filter (\\t -> yRock30 t > 0) [0,0.1..20]\n```", "```\ntxPairsInAir'' :: [(R,R)]\ntxPairsInAir''\n    = filter (\\(_t,y) -> y > 0) $\n      map (\\t -> (t,yRock30 t)) [0,0.1..20]\n```", "```\n*Main> :k R\nR :: *\n```", "```\n*Main> :k Maybe\nMaybe :: * -> *\n```", "```\n*Main> :k Maybe R\nMaybe R :: *\n```", "```\n*Main> :k Num\nNum :: * -> Constraint\n```", "```\ntype List a = [a]\ntype Function a b = a -> b\ntype Pair a b = (a,b)\ntype Triple a b c = (a,b,c)\n```", "```\noneStep :: R         -- time step\n        -> (R -> R)  -- function to integrate\n        -> (R,R)     -- current (t,y)\n        -> (R,R)     -- updated (t,y)\noneStep dt f (t,y) = let t' = t + dt\n                         y' = y + f t * dt\n                     in (t',y')\n```", "```\nintegral' :: R -> Integration\nintegral' dt f a b\n    = snd $ head $ dropWhile (\\(t,_) -> t < b) $\n      iterate (oneStep dt f) (a + dt/2,0)\n```", "```\ntype Integration = (R -> R)  -- function\n                 -> R        -- lower limit\n                 -> R        -- upper limit\n                 -> R        -- result\n```", "```\npolarToCart :: (R,R) -> (R,R)\n```", "```\nhead :: [a] -> a\n```", "```\nheadSafe :: [a] -> Maybe a\nheadSafe = undefined\n```", "```\nmaybeToList :: Maybe a -> [a]\nmaybeToList = undefined\n```", "```\nzip' :: ([a], [b]) -> [(a, b)]\nzip' = undefined\n```", "```\n   zip' . unzip :: [(a, b)] -> [(a, b)]\n```", "```\n   unzip . zip' :: ([a], [b]) -> ([a], [b])\n```", "```\ntvPairs :: [(R,R)]\ntvPairs = iterate tvUpdate (0,0)\n```", "```\ntvUpdate = undefined\n```", "```\nfibonacci :: [Int]\nfibonacci = undefined\n```", "```\nfibHelper :: [(Int,Int)]\nfibHelper = undefined\n```", "```\nfact :: Int -> Int\n```", "```\npick13 :: [(R,R,R)] -> [(R,R)]\npick13 triples = map (\\(x1,_,x3) -> (x1,x3)) triples\n```", "```\ntoTriple :: ((a,b),c) -> (a,b,c)\ntoTriple = undefined\n```"]