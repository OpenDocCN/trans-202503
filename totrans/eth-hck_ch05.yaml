- en: '**5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CRYPTOGRAPHY AND RANSOMWARE**
  prefs: []
  type: TYPE_NORMAL
- en: '*Unless you know the code, it has no meaning.*'
  prefs: []
  type: TYPE_NORMAL
- en: –John Connolly, *The Book of Lost Things*
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Ransomware* is malicious code that holds a machine hostage by encrypting its
    files. After encrypting the files, ransomware usually displays a window demanding
    money in exchange for the decrypted files. This chapter will show you how hackers
    write encryption ransomware to extort money from a company. However, before we
    do that, you must understand encryption algorithms and secure communications more
    generally. After reading this chapter, you should be able to encrypt a file with
    a block cipher, send an encrypted email using public-key cryptography, and design
    your own encryption ransomware.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine that Alice wants to prevent people from reading her diary, so she locks
    it in a safe and keeps the key. In computer systems, the analogous activity to
    placing a diary in a safe is to *encrypt* it by scrambling the data in some systematic
    way. If Alice encrypted her diary, anyone who stole it would have trouble recovering
    the information inside. Cryptographers refer to the original diary as *plaintext*,
    because everyone can plainly see what’s inside, and they refer to the encrypted
    diary as *cipher text*.
  prefs: []
  type: TYPE_NORMAL
- en: The *Caesar cipher* was one of the earliest encryption algorithms. It encrypts
    messages by replacing one letter with another. For example, the letter *a* might
    be replaced with *b* and the letter *c* would be replaced with the letter *d*,
    and so on. [Figure 5-1](ch05.xhtml#ch5fig1) shows an example of one possible mapping.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch05fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: Caesar cipher encryption mapping*'
  prefs: []
  type: TYPE_NORMAL
- en: Try using the mapping shown in [Figure 5-1](ch05.xhtml#ch5fig1) to decrypt the
    cipher text “dbu buubdl.” You should easily retrieve the message “cat attack.”
    However, the original plaintext message wouldn’t be obvious to someone who read
    the cipher text “dbu buubdl” unless they also knew the mapping. We refer to this
    mapping as the *key*. In our example, the key is 1, as we’ve shifted letters by
    one spot in the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice a weakness in the Caesar cipher: if messages can contain only 26 unique
    letters, there are only 26 possible keys. A hacker could merely try each key until
    they found one that unlocked the message. The number of possible keys is called
    the *key space*. Encryption algorithms with larger key spaces are more secure
    because hackers must test more keys. The Caesar cipher isn’t secure because its
    key space is too small.'
  prefs: []
  type: TYPE_NORMAL
- en: The most secure encryption algorithms make any possible mapping equally likely,
    creating the largest possible key space. An algorithm known as the *one-time pad*
    achieves this.
  prefs: []
  type: TYPE_NORMAL
- en: '***One-Time Pad***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The one-time pad algorithm encrypts a message by computing the *exclusive OR
    (XOR)* between the message and key. The XOR is a logic operation that outputs
    1 when the two input bits differ and 0 when they are the same. For example, 1
    XOR 0 = 1, whereas 1 XOR 1 = 0\. [Figure 5-2](ch05.xhtml#ch5fig2) shows an example
    of encrypting the word *SECRET* with the key `po7suq`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch05fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: The process of using a key to encrypt a message*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, each letter in the plaintext and key is converted to its binary representation
    using the ASCII mapping. The *American Standard Code for Information Interchange
    (ASCII)* is a standard that assigns natural language characters to binary codes.
    For example, the characters in the key `po7suq` map as follows: p = 0111000, o
    = 01101111, 7 = 00110111, s = 0110011, u = 001110101, and q = 00111001\. Next,
    the two binary values are XOR-ed and converted back into ASCII, resulting in the
    string `#*T!0%`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let’s consider the process of encrypting *S* with
    the key *p*. We convert the character *S* and *p* to their respective binary representations,
    01010011 and 01110000, and then compute the XOR for each pair of bits in *S* and
    *p* from left to right. This means that we XOR 0 with 0, 1 XOR 1, and so on, until
    we reach the final pair 1 XOR 0\. The resulting value is 00100011, which when
    converted back to ASCII yields the cipher text #.'
  prefs: []
  type: TYPE_NORMAL
- en: Unless an attacker knows the key, it will be impossible for them to recover
    the original message. This is because the one-time pad algorithm ensures that
    any possible mapping is equally likely. Each 0 or 1 in the cipher text is equally
    likely to have been 0 or 1 in the plaintext, assuming you’ve randomly chosen the
    values in your key. A cipher value 00 is equally likely to map to a plaintext
    value of 11, 10, 01, or 00\. This means that an *n*-bit plaintext has 2*^n* possible
    cipher values. Thus, our 48-bit plaintext `SECRET` has 281 trillion possible mappings.
    Now *that* is a large key space.
  prefs: []
  type: TYPE_NORMAL
- en: The one-time pad does leak some information. In this case, we know that the
    cipher text, key, and original message are all six characters long. However, this
    doesn’t tell us much given that the ciphertext is just as likely to correspond
    to the word *SECRET* as to any other six-character word, such as *puzzle*, *quacks*,
    or *hazmat*. This is because we could choose a six-character key that would map
    any of these words to the ciphertext. To decrypt the message, you’d need to XOR
    the cipher text with the key once again.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE MATH BEHIND THE ONE-TIME PAD**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how the one-time pad algorithm works, and how the same
    operation can both encrypt and decrypt data, consider the algebra behind it. Let’s
    begin by introducing some notation. Let *E*(*k*, *m*) represent the function that
    encrypts a message *m* by XOR-ing it with a key *k*. We’ll use the symbol *⊕*
    to represent the XOR operation and let *c* represent the cipher text. The following
    equation expresses these ideas mathematically:'
  prefs: []
  type: TYPE_NORMAL
- en: '*E*(*k*, *m*) = *m* ⊕ *k* = *c*'
  prefs: []
  type: TYPE_NORMAL
- en: '*D*(*c*, *k*) is the function that decrypts cipher text *c* by XOR-ing it with
    the same key, *k*. If you look at the encryption equation, you’ll see that we
    can substitute (*m* ⊕ *k*) for the cipher text *c*, which will result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*D*(*k*, *c*) = *c* ⊕ *k* = (*m* ⊕ *k*) ⊕ *k*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The XOR operator is associative, which means that the order of operations doesn’t
    matter. So we can rearrange the parentheses and rewrite the right-hand side of
    the equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: (*m* ⊕ *k*) ⊕ *k* = *m* ⊕ (*k* ⊕ *k*)
  prefs: []
  type: TYPE_NORMAL
- en: 'The XOR operator is also self-inversive, meaning that if we XOR a number with
    itself, the result will be 0\. This gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*m* ⊕ (*k* ⊕ *k*) = *m* ⊕ (0)'
  prefs: []
  type: TYPE_NORMAL
- en: The XOR operator also follows the identity element property, which means that
    XOR-ing a number with 0 simply returns the number.
  prefs: []
  type: TYPE_NORMAL
- en: '*m* ⊕ (0) = *m*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the preceding steps, I have shown that decrypting the cipher text by
    XOR-ing it with the key will give us the original message:'
  prefs: []
  type: TYPE_NORMAL
- en: '*D*(*k*, *c*) = *c* ⊕ *k* = (*m* ⊕ *k*) ⊕ *k* = *m*'
  prefs: []
  type: TYPE_NORMAL
- en: The one-time pad algorithm has two limitations. First, you can use each key
    only once. If the same key is used more than once, a hacker can discover information
    about the message by XOR-ing the two cipher texts. For instance, in [Figure 5-3](ch05.xhtml#ch5fig3),
    you can see that XOR-ing the bee and stop ciphers with each other is equivalent
    to XOR-ing the two plaintext messages.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch05fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: How a hacker can recover information from two messages encrypted
    with same key*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following equation outlines, in algebraic terms, how XOR-ing two ciphers
    (*c*[1] and *c*[2]) encrypted with same key *k* is equivalent to XOR-ing the two
    plaintext messages *m*[1] and *m*[2]. The self-inversive property (described in
    the box) causes the keys in both ciphers to cancel each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '*c*[1] ⊕ *c*[2] *⇒* (*m*[1] ⊕ *k*) ⊕ (*m*[2] ⊕ *k*) *⇒* (*m*[1] ⊕ *m*[2]) ⊕
    (*k* ⊕ *k*) *⇒* (*m*[1] ⊕ *m*[2])'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the random information that the key provides disappears when
    we XOR the two cipher texts. Also, encrypting the same message with the same key
    will always result in the same cipher text. This allows a hacker to detect that
    the same message was sent twice.
  prefs: []
  type: TYPE_NORMAL
- en: The key must also be the same length as the message; thus, long messages need
    long keys. This means that to encrypt a 250-word document, assuming an average
    word length of five characters, you’d need to remember a key that is 1,250 characters
    long.
  prefs: []
  type: TYPE_NORMAL
- en: What if you could convert shorter keys, like `tfkd`, into longer keys, like
    `qwedfagberw`? You could then use shorter keys to encrypt long messages. As it
    so happens, we can achieve this by using a pseudorandom generator.
  prefs: []
  type: TYPE_NORMAL
- en: '***Pseudorandom Generators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *pseudorandom generator (PRG)* is an algorithm that always generates the same
    random-looking output given the same key. This allows you to use a shorter password
    to create a key that is the same length as the message without having to remember
    the whole key. Discussions of randomness are always tricky. The results of PRGs
    look *statistically* random, even though they’re not sampled from a random source
    like atmospheric noise or radioactive decay. However, they cannot be truly statistically
    random because the PRG’s input is much shorter than its output. Nonetheless, no
    efficient algorithm will be able to tell the difference, so PRG output is as good
    as a statistically uniform string.
  prefs: []
  type: TYPE_NORMAL
- en: 'How is it possible to repeatedly generate the same pseudorandom sequence of
    numbers from a short key? One way is to use a *linear congruential* *generator
    (LCG)*. The details of this formula aren’t important, but the following equation
    describes it if you’re curious. Here, *X[n]* represents the *n*th number in the
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '*X[n]*[+1] = (*aX[n]* + *c*) mod *m*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the sequence’s length, you can select different values for *a*,
    *c*, and *m*. You can also choose the first number in the sequence, *X*[0], which
    is called the *seed*. Consider a case with parameters *m* = 9, *a* = 2, and *c*
    = 0, and a seed of 1 (that is, *X*[0] = 1). These parameters produce the following
    output: 2, 4, 8, 7, 5, 1\. [Table 5-1](ch05.xhtml#ch5tab1) shows how each number
    in the sequence is calculated.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** How the LCG Computes the Numbers in the Pseudorandom Sequence'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***X****[n+1]*** | (***aX****[n]** **+ c)*** mod ***m*** | ***X****[n]***
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 *** 1 + 0 mod 9 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 2 *** 2 + 0 mod 9 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 2 *** 4 + 0 mod 9 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 2 *** 8 + 0 mod 9 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 2 *** 7 + 0 mod 9 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 *** 5 + 0 mod 9 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 *** 1 + 0 mod 9 | 1 |'
  prefs: []
  type: TYPE_TB
- en: The sequence isn’t infinite, because it repeats. You can generate longer sequences
    by carefully choosing the parameters; however, all sequences eventually cycle
    back to the beginning. This process of generating longer keys from short ones
    is called *key derivation*.
  prefs: []
  type: TYPE_NORMAL
- en: The length of sequence before the cycle repeats is called its *period*. Repetition
    is not the only issue with LCGs. For instance, an LCG with an extremely large
    period is still insecure. Another issue is that the values are predictable (even
    without computing a full period). You should never use LCG algorithms in cryptographic
    applications. We recommend that you use the *Password-Based Key Derivation Function
    2 (PBKDF2)* whenever you need to derive keys.
  prefs: []
  type: TYPE_NORMAL
- en: '***Insecure Block Ciphers Modes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What if, instead of generating keys the same length as our message, we split
    the message into blocks? Then we could encrypt each block of the large file independently
    with a shorter key. This is the central idea behind *block cipher modes*. The
    *electronic code book (ECB)* cipher mode was one of the earliest, and although
    it isn’t secure, ECB illustrates the concept well.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-4](ch05.xhtml#ch5fig4) shows how ECB encrypts the binary sequence
    `00011011`. Notice how the binary sequence is split into four blocks, each of
    which is encrypted in parallel.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch05fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: An ECB block cipher mode encrypting the binary sequence* `*00011011*`'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the block implements a simple function that XORs the input
    with the key 01\. However, given the same key and input, ECB will always output
    the same cipher text, leaking information to the hacker. ECB also reuses the key
    for each block, which reduces the number of possible outcomes and makes it easier
    for a hacker to decrypt the message. For example, [Figure 5-5](ch05.xhtml#ch5fig5)
    shows an image that has been encrypted with ECB.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch05fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: The image on the left is the original image, whereas the image
    on right is an encrypted image.*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you can still see the outline of the atom in the encrypted file.
    This is due to information leakage from using the same key for each block. A similar
    amount of information would be leaked if the ECB cipher were used to encrypt text.
  prefs: []
  type: TYPE_NORMAL
- en: The subtle flaws of the Caesar cipher, one-time pad, and ECB should illustrate
    why you should never implement an encryption algorithm yourself. Encryption is
    very delicate, and small deviations from the specification could result in an
    insecure implementation. Always use secure algorithms from trusted libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '***Secure Block Ciphers Modes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take a look at a better encryption algorithm. [Figure 5-6](ch05.xhtml#ch5fig6)
    shows the design of the *counter mode block cipher (CTR)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch05fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: The design of the CTR*'
  prefs: []
  type: TYPE_NORMAL
- en: CTR overcomes two limitations of ECB. First, CTR generates a random number,
    called a *nonce* (a number used once), which it uses to create a unique pad every
    time the file is encrypted. It then attaches the nonce to a counter that uniquely
    identifies each block before sending it to the block. This ensures that each block
    receives unique information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example. We’ll use a 1-bit counter and 1-bit nonce value
    of 0\. The counter will cycle between 0 and 1\. When attached to the end of the
    nonce, this would result in the following inputs: 00 and 01\. The combination
    of nonce and counter is then fed to each block, which returns a block-specific
    pad. To encrypt the block, we XOR this block-specific pad with the plaintext in
    that block to create the final cipher text. [Figure 5-7](ch05.xhtml#ch5fig7) shows
    an example of encrypting the binary sequence 0000 using a CTR with a 1-bit counter{0,1}
    and a 1-bit nonce (coin flip heads:1, tails:0).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch05fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: Encrypting the binary sequence* `*0000*` *using a CTR with a 1-bit
    counter and a 1-bit nonce*'
  prefs: []
  type: TYPE_NORMAL
- en: The blocks in this example use the same key and mapping shown in [Figure 5-6](ch05.xhtml#ch5fig6).
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to distinguish between block ciphers and a block cipher mode
    of operation. A block cipher is a keyed function that takes a block of *n* bits
    and outputs a block of *n* bits. The output of a secure block cipher looks like
    a random permutation of the input block. Though we have been using the XOR function
    in our examples, the NSA recommends using the *Advanced Encryption Standard (AES)*
    cipher.
  prefs: []
  type: TYPE_NORMAL
- en: Block ciphers themselves are not an encryption scheme; however, you can use
    them in various “modes” to obtain an encryption scheme. ECB and CTR are examples
    of modes of operation. When we say that ECB is insecure, it’s the mode that is
    broken and not the underlying block cipher.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encrypting and Decrypting a File**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s use the CTR cipher to encrypt a file. Begin by opening a terminal on
    the Kali Linux virtual machine. Create a text file containing the message “Top
    Secret Code” by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the content of the file, run the `cat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use the `openssl` library, which includes several encryption algorithms
    and is preinstalled on Kali Linux. Encrypt the file by running the following command
    and entering a password when prompted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `enc -aes-256-ctr` flag specifies that you want to use the *aes-256-ctr*
    block cipher. The block cipher’s name is divided into three parts. The first section
    (`aes`) represents the mapping function used in each block, in this case the AES
    cipher mentioned earlier. The next section (`256`) represents the block size,
    which is 256 bits in this case. The last section (`ctr`) represents a CTR block
    cipher mode. The next option, `-pbkdf2`, represents the key derivation function,
    and the `-e` flag tells `openssl` to encrypt the file. The `-a` flag outputs an
    encrypted file in Base64 encoding instead of binary, which will make it easier
    for us to print the encrypted file in the terminal. Lastly, we use the options
    `-in` and `-out` to specify the file that we want to encrypt and the name of the
    output file, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the contents of your encrypted file, use the `cat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To decrypt the file, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `-d` flag instructs `openssl` to decrypt the file. Enter the password you
    used earlier. Like the one-time pad algorithm, the CTR decrypts cipher text by
    XORing it with the key output by the block, thereby reversing the encryption process.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a hacker who steals this encrypted file might not be able to decrypt
    it, but they can still corrupt it by changing the encrypted bits. In [Chapter
    6](ch06.xhtml#ch6), we’ll discuss an encryption algorithm that allows you to share
    encrypted files and detect a corrupted copy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Email Encryption**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve encrypted and decrypted a file, let’s tackle the challenge of
    sending an encrypted email over a public network, where you should assume that
    anyone can read any unencrypted messages you send. At first glance, correcting
    this problem doesn’t seem too difficult. You can create a key and send an encrypted
    message over the public network so those who intercept the message won’t be able
    to read it.
  prefs: []
  type: TYPE_NORMAL
- en: However, your recipient won’t be able to read the message either because they
    don’t have the key. Assuming that you’ll never meet in person to exchange keys,
    how can you get the key to your recipient without it being intercepted? You can
    use a technique called *publickey cryptography*, also known as *asymmetric cryptography*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Public-Key Cryptography***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of a single shared key, public-key cryptography uses two keys: a public
    key, which everyone can see, and a private key, which is never shared. These two
    keys are mathematically linked, so messages encrypted with the public key can
    be decrypted only by using the private key, and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: To see how public-key cryptography is useful for sending messages, let’s consider
    an analogy. What if you wanted to send Alice your diary through the mail, but
    you didn’t want anyone in the mail system to be able to read it? You could lock
    your diary in a box and send it to Alice, but Alice can’t open the box because
    she doesn’t have the key. Instead, what if Alice first sends you an open lock
    and keeps the key? The lock doesn’t protect any secret information, so it’s fine
    if everyone in the public mail system can see it.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of this lock as Alice’s public key. Now you can lock the diary
    in a box using the lock Alice sent you and send it through the mail to Alice.
    No one in the mail system would be able to open your box (not even you!) because
    only Alice has the key. When Alice receives the box, she unlocks it using her
    private key.
  prefs: []
  type: TYPE_NORMAL
- en: Actual public keys are a bit different than locks because they can both encrypt
    (like a lock) and decrypt (like a key). The same is true of private keys. If a
    message is encrypted using a public key, only the individual with the private
    key can decrypt it. But if a message is encrypted using the private key, anyone
    with the public key can decrypt it.
  prefs: []
  type: TYPE_NORMAL
- en: It might not be obvious at first why anyone would ever encrypt something with
    their private key since anyone with access to your public key could decrypt the
    message. But encrypting messages with your private key guarantees to others that
    the message came from you because you’re the only person with access to your private
    key. The process of encrypting messages with your private key is often referred
    to as *signing*. By signing a message, you guarantee that it came from you. For
    example, when you request a web page from your bank, the bank’s server will provide
    a signed certificate, proving its authenticity. We will discuss this topic in
    more detail in [Chapter 6](ch06.xhtml#ch6).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at one of the algorithms that makes public-key cryptography
    possible: Rivest–Shamir–Adleman.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Rivest–Shamir–Adleman Theory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instead of randomly generating a key, public-key cryptography creates the relationship
    between the two keys by computing them. Let’s develop some mathematical notation
    to help us discuss the *Rivest–Shamir–Adleman (RSA)* algorithm. We’ll denote the
    integer representing the public key as *e*, for encryption, and the integer representing
    the private key as *d* for decryption. (These were the variables used in the paper
    that first introduced RSA.) Before we discuss how these keys are generated, we’ll
    cover the encryption and decryption process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can represent a message *m* in binary, and these binary values can be interpreted
    as decimal numbers. For example, the ASCII character *A* corresponds to the binary
    value 1000001, which can be interpreted as the integer 65\. We can now encrypt
    the value 65 by defining a function that maps 65 to a new cipher value *c*. The
    following equation defines the encryption function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*E*(*e*, *m*, *n*) = *m^e* mod *n* ≡ *c*'
  prefs: []
  type: TYPE_NORMAL
- en: This encryption equation introduces a new public parameter, *n*. This parameter
    is created during the key generation process and we’ll discuss it later.
  prefs: []
  type: TYPE_NORMAL
- en: You might also be wondering why a hacker can’t decrypt a message by computing
    ![image](../images/077equ01.jpg). This is difficult to compute for large values
    of *m* and *e*, and is further complicated by the fact that you must account for
    the mod *n* operation. So how can Alice decrypt the message? The public key (*e*)
    and the private key (*d*) are designed so that if you raise the cipher text to
    the value of private key *d* and compute the modulus, you will get the original
    message back. (We commonly referred to features like these as *trapdoors*.)
  prefs: []
  type: TYPE_NORMAL
- en: '***The RSA Math***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s explain how this all works. Let’s begin by expressing the decryption
    process mathematically:'
  prefs: []
  type: TYPE_NORMAL
- en: '*D*(*d*, *c*, *n*) = *c^d* mod *n* ≡ *m*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we substitute the expression for *c* from the encryption equation into the
    decryption equation, we can rewrite the decryption equation so that it contains
    the public and private keys (*e*, *d*) and the generated parameter (*n*):'
  prefs: []
  type: TYPE_NORMAL
- en: (*m^e* mod *n*)*^d* mod *n* ≡ *m*
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then simplify the equation using the following mathematical property:'
  prefs: []
  type: TYPE_NORMAL
- en: (*a* mod *n*)*^d* mod *n* ≡ *a^d* mod *n*
  prefs: []
  type: TYPE_NORMAL
- en: 'Which allows us to rewrite it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*m^(ed)* mod *n* ≡ *m*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if only we could choose *e*, *d* values so that coefficient of *m* would
    be 1\. We could then show that *m^(ed)* mod *n* = *m* for all values of *m* smaller
    than *n*, as shown in the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*m^(ed)* mod *n* ≡ *m*¹ mod *n* ≡ *m*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could make this true if we set both integers *e* and *d* to 1\. But how
    could we rewrite the equation so that it’s true for other values? Consider the
    following property, which is true for any *x* and *y* value where *n* is the product
    of two primes: *p*, *q* and *z* = (*p* – 1)(*q* – 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '*x^y* mod *n* ≡ *x*^((*y* mod *z*)) mod *n*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we rewrite the previous equation using this property, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*m*^((*ed* mod *z*)) mod *n* ≡ *m*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use integer values other than 1 for *e* and *d*, as long as we ensure
    that *ed* mod *z* = 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do we programmatically discover the integer values for *e* and *d*?
    The key generator algorithm allows us to generate appropriate integer values for
    *e*, *d*, and *n*. The key generation algorithm consists of four key steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Select two large prime numbers (*p*, *q*) and keep them secret.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Compute *n* = *pq* and *z* = (*p* – 1)(*q* – 1).
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Compute the public key (*e*) by choosing an integer that is less than *n*
    and relatively prime to *z*, meaning that it has no factors in common with z.
    Algorithms often choose the value 65,537.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Use the *extended Euclidean* algorithm to compute the public key (*d*) by
    choosing an integer *d* such that *ed* mod *z* = 1.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have the values for *e*, *d*, and *n*.
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve focused solely on the RSA algorithm. But secure implementations
    of RSA must also use the *optimal asymmetric encryption padding (OAEP)* algorithm.
    For simplicity, I’ve delayed discussing the OAEP algorithm and will cover it later
    in the chapter. But don’t worry, we’ll include the `-oaep` flag when encrypting
    and decrypting files using `openssl`, so the commands shown here should be secure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encrypting a File with RSA**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you know the theory behind RSA, let’s use the `openssl` library to
    generate an encrypted email. To begin, generate a pair of public and private keys
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `genrsa` flag lets `openssl` know that you want to generate an RSA key,
    the `-out` flag specifies the name of the output file, and the value `1024` represents
    the length of the key. Longer keys are more secure. The NSA recommends RSA key
    lengths of 3,072 bits or longer. Remember: don’t share your private key with anyone.
    You can view the key pair you generated by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rsa` flag tells `openssl` to interpret the key as an RSA key and the `-text`
    flag displays the key in human-readable format. You should see output like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The labels in this output correspond to the theory we discussed earlier in this
    chapter, and the modulus is the value *n*. Remember that this is the product of
    the two prime factors *p* and *q*, which are labeled prime1 and prime2 in the
    output. The public exponent (public key) is the value *e*, whereas the private
    exponent (private key) is the value *d*. The section at the bottom represents
    the Base64-encoded version of the public–private key pair, with all of its components.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can extract the public key from this file by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-pubout` flag tells `openssl` to extract the public key from the file.
    You can view the public key by running the following command, in which the `-pubin`
    flag instructs `openssl` to treat the input as a public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can make your public key available by publishing it on your website. Notice
    that the public key also includes the modulus *n* required for decryption. Because
    *n* is the product of the two secret prime numbers (*p* and *q*), if a hacker
    were able to factor *n*, they could decrypt the RSA cipher text. However, no classical
    algorithms currently exist that would allow a hacker to efficiently factor *n*
    if the prime numbers are large. In 1994, Peter Shor proposed a *quantum algorithm*
    that could factor large numbers. The algorithm works, but we haven’t yet been
    able to create a quantum computer that can run it on large numbers. Until we have
    a capable quantum computer, RSA remains a safe form of encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to make use of your new public and private keys. Create a text file to
    encrypt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the RSA utility (`rsautl`), which is part of `openssl`, to create an encrypted
    binary file (*cipher.bin*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we included the `-oaep` flag. Secure implementations of RSA must
    also use the OAEP algorithm discussed in the next section. Whenever you’re encrypting
    and decrypting files using `openssl`, be sure to apply this flag to make the operations
    secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert the binary file to Base64 by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting the file from binary to Base64 encoding allows you to paste it into
    an email as text. You can view the Base64-encoded text using the `cat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Base64 encoding the file doesn’t really encrypt the file; it simply formats
    it. Always encrypt the file before Base64 encoding it. Decrypt the message by
    converting the Base64 text back into binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, decrypt the binary using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you can view the decrypted message using the `cat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see your original message: The cat is alive.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Optimal Asymmetric Encryption Padding***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Plain RSA isn’t secure because a message will always produce the same cipher
    text when encrypted with the same public key *e*. This is because the encryption
    process (*m^e* mod *n*) doesn’t include a random nonce, among other weaknesses.
    The OAEP preprocessing and postprocessing steps address these issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the OAEP algorithm, leaving some of mathematical details
    abstract. Before a message is encrypted, it is first run through an OAEP preprocessing
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: '*E*(*e*, *m*, *n*) = (OAEP-PRE(*m*))*^e* mod *n* ≡ *c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can represent this step using the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `pad()` function ➊ makes *m* a larger number by adding zeros to the end
    of its bit representation, and `Hash()` represents a hash function, like SHA-256\.
    Why do we need to make *m* a large number? If *m^e* is small, the encryption function
    *m^e* mod *n* doesn’t use the modulus, and computing ![image](../images/077equ01.jpg)
    is easy. OAEP is a padding algorithm that ensures small numbers are converted
    into larger ones that use the modulus.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OEAP postprocessing step recovers the original message and can be represented
    using the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because these encryption processes are so delicate, a hacker could easily break
    the encryption if they discovered flaws in how a software developer or system
    administrator used these encryption algorithms. For example, if a programmer used
    PKCS1 version 1.5 instead of OAEP for preprocessing, a hacker could decrypt the
    cipher text. So when attempting to break an encrypted message, an attacker should
    first examine the options used to encrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us combine these ideas to implement something a lot cooler: ransomware.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing Ransomware**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first ransomware systems used symmetric key cryptography and stored the
    keys in the ransomware itself, which allowed security researchers to extract the
    keys. Modern ransomware systems use a hybrid approach. They’ll still use a random
    symmetric key to encrypt files on the victim’s machine, but to prevent security
    researchers from extracting the key, they’ll encrypt the symmetric key with the
    hacker’s public key. [Figure 5-8](ch05.xhtml#ch5fig8) shows an overview of this
    process.
  prefs: []
  type: TYPE_NORMAL
- en: If the victim pays the ransom, usually by uploading Bitcoin and a copy of the
    encrypted symmetric key, the ransomware server will use the hacker’s private key
    to decrypt the symmetric key and return it to the victim. The victim uses this
    key to decrypt the files.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch05fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-8: How the ransomware protects the symmetric key by encrypting it
    using a hacker’s public key*'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the attacker could just accept the payment and ignore the victim,
    never decrypting the files nor sending the key. Once the victim pays, the attacker
    has little to gain from participating in the decryption process.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll write our own ransomware client in Python. So that we
    don’t encrypt all the files on the Kali Linux virtual machine, we’ll limit our
    ransomware client to encrypting only one file. However, you could easily extend
    the implementation to encrypt every file on a victim’s computer. First we’ll generate
    a random symmetric key and then use that key to encrypt the file. After the file
    has been encrypted, we’ll use our public key to encrypt the symmetric key and
    save it to a file on the Kali Linux machine. When the program terminates, it will
    delete the symmetric key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the pyca`/cryptography` library recommended by the Python Cryptography
    Authority. Install the library by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After you’ve installed the library, open a text editor such as Mousepad and
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Fernet` module ➊ provides a simple API for performing symmetrickey cryptography.
    We load the public key from a file by using the `with` keyword ➋, which is a better
    alternative to Python’s `try finally` keywords because it implicitly manages the
    resource. To see how, consider the following examples. The first example uses
    the `try` and `finally` keywords to open, edit, and close a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the second example uses the `with` keyword to implicitly manage
    the resource, resulting in shorter and more readable code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We then used the OAEP algorithm ➌. Because OAEP internally relies on a cryptographic
    hash function, we must select one to use. Here we select the SHA256 hash algorithm
    ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we write the encrypted key to a file in memory ➎ and then encrypt the
    file ➏. When the program terminates, the plaintext symmetric key will be erased
    from the computer’s memory.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how can an attacker in a coffee shop demand money from a company by uploading
    this encryption ransomware to the company’s systems? In [Chapter 2](ch02.xhtml#ch2),
    we discussed how an attacker could use an ARP spoofing attack to intercept a target’s
    web traffic. In [Chapter 3](ch03.xhtml#ch3), you learned how the attacker used
    Wireshark to extract the IP address of a server the target was visiting, and in
    [Chapter 4](ch04.xhtml#ch4), we looked at how the attacker used `nmap` to scan
    the server and discover a vulnerable FTP application running on port 21\. We also
    saw how an attacker could exploit the FTP application and upload a custom reverse
    shell. The attacker could then use this reverse shell to upload a copy of their
    own encryption ransomware to the web server. In [Chapters 7](ch07.xhtml#ch7) and
    [8](ch08.xhtml#ch8), we’ll discuss techniques that hackers could use if they can’t
    find other vulnerabilities in the server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Attempt the following exercises to deepen your understanding of encryption and
    ransomware. In the first exercise, you’ll write a ransomware server that decrypts
    the symmetric key and returns it to the client. In the second exercise, you’ll
    extend the client so that it sends a copy of the encrypted key to the server.
    In the final exercise, you’ll explore the solved and unsolved codes written on
    the Kryptos statue in front of Central Intelligence Agency (CIA) headquarters
    in Langley, Virginia.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Ransomware Server***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Implement a server that communicates with your ransomware client. Your server
    should be able to handle multiple client connections. Once a client connects to
    the server, the client will send the server an encrypted symmetric key. Your server
    should decrypt this key using its private key and then send it to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We began implementing the function that will decrypt the symmetric key and
    send it back to the client ➊. As an exercise, try modifying the function so that
    it decrypts the key and sends it back. Hint: read the RSA decryption section of
    the pyca/`cryptography` library documentation at *[https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html](https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html)*.
    Remember that you need to load the private key before you use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a new instance of the TCP server ➋, and then we start the server
    ➌. This is the same TCP server code you used in [Chapter 4](ch04.xhtml#ch4).
  prefs: []
  type: TYPE_NORMAL
- en: As an added challenge, try extending the ransomware server to check for the
    receipt of a Bitcoin payment before sending the decrypted key.
  prefs: []
  type: TYPE_NORMAL
- en: '***Extending the Ransomware Client***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Extend the ransomware client you built in this chapter to include the ability
    to decrypt the file after it receives the decrypted symmetric key from the ransomware
    server you built in the previous exercise. This client will need to send the ransomware
    server a copy of the encrypted symmetric key and read the decrypted symmetric
    key that the server sends back. It will then need to use the decrypted symmetric
    key to decrypt the file it encrypted earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We create a new socket and open the key file ➊. Then, you need to implement
    the code that sends the key file and waits for the decrypted result ➋. When you
    receive the decrypted key, pass it to the `decryptFile()` function ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that this function contains no code: I’ll leave it to you to implement
    the decryption function so that it uses the `Fernet` module to restore the file.
    Hint: read *[https://cryptography.io/en/latest/](https://cryptography.io/en/latest/)*
    for tips on how to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Unsolved Codes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Several codes remain unsolved, including the famous ones written on the Kryptos
    statue in front of CIA headquarters. The statue contains four encrypted messages,
    three of which have been solved. The first two codes were encrypted using an extension
    of the Caesar cipher called the *Vigenère cipher*. The third was encrypted using
    a technique called *transposition*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, no one has been able to decrypt the fourth code. The artist who created
    the statue, Jim Sanborn, has provided four hints, shown in [Table 5-2](ch05.xhtml#ch5tab2).
    Try solving the first three codes yourself. The first code was encrypted using
    a Vigenère cipher and the key: Kryptos, Palimpsest. If you use this key and a
    Vigenère table, you will be able decode it. Then, if you feel brave enough, try
    decoding the fourth, unsolved code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-2:** Four Hints from Jim Sanborn'
  prefs: []
  type: TYPE_NORMAL
- en: '| Position | Cipher text | Plaintext |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 64th–69th letters | “NYPVTT” | “BERLIN |'
  prefs: []
  type: TYPE_TB
- en: '| 70th–74th | “MZFPK” | “CLOCK” |'
  prefs: []
  type: TYPE_TB
- en: '| 26th–34th | “EFGHIJL0H” | “NORTHEAST” |'
  prefs: []
  type: TYPE_TB
- en: '| 22nd–25th | “FLRV” | “EAST” |'
  prefs: []
  type: TYPE_TB
- en: 'Following is a representation of the four encrypted messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
