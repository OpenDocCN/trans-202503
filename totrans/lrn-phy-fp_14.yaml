- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '13'
- en: CREATING 2D AND 3D ANIMATIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建二维和三维动画
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)'
- en: A picture that changes over time can be a good way to visualize many situations.
    The Haskell Prelude itself does not have any support for animation, but some good
    library packages are available at [https://hackage.haskell.org](https://hackage.haskell.org).
    For two-dimensional pictures and animations, we’ll use the `gloss` package. For
    three-dimensional pictures and animations, we’ll use a package named `not-gloss`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个随时间变化的图像可以很好地可视化许多情况。Haskell Prelude 本身并不支持动画，但在 [https://hackage.haskell.org](https://hackage.haskell.org)
    上有一些不错的库包可用。对于二维图像和动画，我们将使用 `gloss` 包。对于三维图像和动画，我们将使用一个名为 `not-gloss` 的包。
- en: 2D Animation
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二维动画
- en: 'The `gloss` package supplies the `Graphics.Gloss` module, which provides four
    main functions: display, animate, simulate, and play. The first is for still pictures,
    the second and third are for pictures that change with time, and the fourth is
    for pictures that change with time and user input. We are interested primarily
    in the first three functions. We’ll describe these functions in the next few sections.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`gloss` 包提供了 `Graphics.Gloss` 模块，其中包含四个主要函数：display、animate、simulate 和 play。第一个用于静态图像，第二和第三个用于随时间变化的图像，第四个用于随时间和用户输入变化的图像。我们主要关注前面三个函数。接下来的几节将详细描述这些函数。'
- en: Displaying a 2D Picture
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示二维图像
- en: The function `display` produces a static picture. Let’s ask GHCi for the type
    of `display`. Since `display` is not part of the Prelude, we must first load the
    module.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `display` 生成一个静态图像。让我们向 GHCi 查询 `display` 的类型。由于 `display` 不是 Prelude 的一部分，因此我们必须先加载该模块。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The types `Display`, `Color`, and `Picture` are defined by the `Graphics.Gloss`
    module, or perhaps by another module in the `gloss` package that is imported by
    `Graphics.Gloss`. The types `Display` and `Color` are for display mode and background
    color, respectively. The most interesting type is `Picture`, which represents
    the type of things that can be displayed. The `gloss` documentation on `Picture`
    describes the pictures we can make (lines, circles, polygons, and so on). You
    can find the documentation at [https://hackage.haskell.org/package/gloss](https://hackage.haskell.org/package/gloss)
    by clicking on `Graphics.Gloss`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `Display`、`Color` 和 `Picture` 是由 `Graphics.Gloss` 模块定义的，或者可能是由 `Graphics.Gloss`
    导入的 `gloss` 包中的另一个模块定义的。类型 `Display` 和 `Color` 分别用于显示模式和背景颜色。最有趣的类型是 `Picture`，它代表了可以显示的内容类型。`gloss`
    文档中关于 `Picture` 的描述说明了我们可以创建的图像（例如线条、圆形、多边形等）。你可以通过点击 `Graphics.Gloss` 在 [https://hackage.haskell.org/package/gloss](https://hackage.haskell.org/package/gloss)
    查阅文档。
- en: GHCi is not so good at showing the pictures that `gloss` creates, so it’s better
    to make a stand-alone program. Let’s write a program to get us familiar with the
    default coordinate system the `Graphics.Gloss` module uses. We’ll draw a red line
    segment from the origin to the point (100,0) and a green line segment from the
    origin to the point (0,100). Because `gloss` measures distance in pixels, we’ll
    use 100 so that the lines we produce will be long enough to see on the screen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GHCi 在显示 `gloss` 创建的图像方面不太理想，因此最好创建一个独立的程序。让我们编写一个程序，帮助我们熟悉 `Graphics.Gloss`
    模块使用的默认坐标系。我们将从原点绘制一条红色的线段，终点为（100,0），以及一条绿色的线段，终点为（0,100）。因为 `gloss` 是以像素为单位来测量距离的，我们使用
    100 这样线段就足够长，能够在屏幕上看到。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As usual, we turn on warnings. Then we import the `Graphics.Gloss` module. We
    need to do this because the code that follows uses the types `Display` and `Picture`;
    the data constructors `InWindow`, `Pictures`, `Color`, and `Line`; the constants
    `red`, `green`, and `black`; and the function `display`. These names are all defined
    in the `Graphics.Gloss` module. Without the `import` statement, we would get “Variable
    not in scope” errors every time we used each of those names.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，我们打开警告。然后导入 `Graphics.Gloss` 模块。我们需要这么做，因为接下来的代码使用了类型 `Display` 和 `Picture`；数据构造器
    `InWindow`、`Pictures`、`Color` 和 `Line`；常量 `red`、`green` 和 `black`；以及函数 `display`。这些名称都是在
    `Graphics.Gloss` 模块中定义的。如果没有 `import` 语句，每次使用这些名称时都会出现“变量不在作用域”错误。
- en: We define a constant `displayMode` to hold the value of type `Display` that
    the function `display` requires. We give the name “Axes” to the window that will
    be opened by the `display` function. We ask for the window to be 1,000 pixels
    wide and 700 pixels high, and we ask for it to be placed 10 pixels up and 10 pixels
    over from whatever the window system thinks is the origin.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个常量`displayMode`来保存`display`函数所需的`Display`类型的值。我们将窗口命名为“Axes”，该窗口将由`display`函数打开。我们请求窗口宽度为1000像素，高度为700像素，并要求将窗口位置设置为距原点10像素上方和10像素右侧。
- en: We define a constant called `axes` to hold the `Picture` we want to make. We
    produce the picture using the data constructor `Pictures`, which gives a way to
    combine a list of pictures into a single picture. We can ask GHCi for the types
    of some of the things that didn’t get explicit types in our code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`axes`的常量，用来保存我们想要制作的`Picture`。我们使用数据构造器`Pictures`来生成这幅图像，它提供了一种将图像列表组合成单一图像的方法。我们可以在GHCi中查看一些未明确指定类型的内容的类型。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `main` function here uses the function `display` to make the picture. We
    pass `display` our `displayMode`, the background color `black`, and our picture
    `axes`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`main`函数使用`display`函数来生成图像。我们将`displayMode`、背景色`black`和图像`axes`传递给`display`。
- en: When we compile and run the program above using one of the three methods described
    in [Chapter 12](ch12.xhtml), we should see a red horizontal line and a green vertical
    line. The default `gloss` orientation has the x-axis going toward the right and
    the y-axis going upward. Depending on your operating system, you might need to
    hit CTRL-C twice to close the graphics window.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用[第12章](ch12.xhtml)中描述的三种方法之一编译并运行上述程序时，我们应该能看到一条红色的水平线和一条绿色的垂直线。默认的`gloss`坐标系中，x轴朝右，y轴朝上。根据你的操作系统，可能需要按两次CTRL-C才能关闭图形窗口。
- en: The `gloss` package does not have a primitive disk, or filled circle, picture.
    As a second example of the `display` function, let’s make a picture of a blue
    circle and a red disk, side by side.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`gloss`包没有提供原生的圆盘或填充圆形图像。作为`display`函数的第二个示例，让我们制作一幅蓝色圆圈和红色圆盘并排的图像。'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we used the same warnings, import, and `displayMode` lines as before. The
    constant `blueCircle` is a blue circle with a radius of 100 pixels.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了与之前相同的警告、导入和`displayMode`行。常量`blueCircle`是一个半径为100像素的蓝色圆圈。
- en: Since `gloss` does not provide a function to make a disk, we’ll write our own.
    Our `disk` function uses `gloss`’s built-in `ThickCircle` function to make a disk.
    `ThickCircle` takes a radius and a thickness as inputs. Here we choose the radius
    of the thick circle to be half of the desired radius of the disk, and we choose
    the thickness to be the full desired radius of the disk. This circle is so thick
    that there is no hole left in the middle, making a disk.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`gloss`没有提供生成圆盘的函数，我们将自己编写一个。我们的`disk`函数使用`gloss`内建的`ThickCircle`函数来生成圆盘。`ThickCircle`接受半径和厚度作为输入。在这里，我们选择将厚圆的半径设置为圆盘所需半径的一半，并将厚度设置为圆盘的完整半径。这个圆圈非常厚，中心没有留下空洞，从而形成了一个圆盘。
- en: The constant `redDisk` is a red disk with a radius of 100 pixels. The constant
    `wholePicture` uses the `Translate` data constructor of the `Picture` type to
    shift the circle to the left and the disk to the right. The `main` function is
    very similar to that of the last program, except now we are displaying `wholePicture`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`redDisk`是一个半径为100像素的红色圆盘。常量`wholePicture`使用`Picture`类型的`Translate`数据构造器将圆圈向左移动，圆盘向右移动。`main`函数与上一个程序非常相似，只不过现在我们显示的是`wholePicture`。
- en: When we run the program, we should see a blue circle to the left of a red disk
    of the same size.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，我们应该能看到一个蓝色圆圈位于一个大小相同的红色圆盘的左侧。
- en: Making a 2D Animation
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建二维动画
- en: Given a picture as a function of time, the function `animate` produces an animation.
    Let’s ask GHCi the type of `animate`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个随时间变化的图像，`animate`函数可以生成动画。让我们在GHCi中查看`animate`的类型。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The difference in type compared to `display` is that `Picture` in `display`
    has been replaced by `Float -> Picture` in `animate`. The `animate` function uses
    a `Float` to describe time, so an expression of type `Float -> Picture` is a function
    from time to a picture, or a picture as a function of time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与`display`相比，类型的区别在于`display`中的`Picture`被`animate`中的`Float -> Picture`所替代。`animate`函数使用`Float`来描述时间，因此`Float
    -> Picture`类型的表达式是从时间到图像的函数，或者说是时间函数的图像。
- en: 'Here is an example of how to use `animate`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用`animate`的示例：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function `projectileMotion` takes a `Float` (the time) as input and produces
    a `Picture` by translating the red disk to the right by `xDisk t` and upward by
    `yDisk t`. The functions `xDisk` and `yDisk` are given explicitly as functions
    of time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: When we compile and run this code, we’ll see a red disk experiencing projectile
    motion. One meter is represented by one pixel, and one second of time in the real
    world is one second of time in the animation. The projectile starts with an initial
    x-component of velocity of 40 m/s and an initial y-component of velocity of 80
    m/s.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Making a 2D Simulation
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `gloss` package’s `simulate` function allows the user to make an animation
    when an explicit function describing a picture as a function of time is not available.
    Let’s ask GHCi the type of `simulate`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `simulate` function asks for six pieces of information. The first two, display
    mode (type `Display`) and background color (type `Color`), are the same as in
    `display` and `animate`. The third piece of information (an `Int`) is the rate,
    in updates per second, at which the simulation should run. The fourth piece of
    information has the type variable `model` instead of a concrete type. We can tell
    that `model` is a type variable because it starts with a lowercase letter; it
    cannot be a constant or a function because it sits in a type signature in the
    place where a type needs to sit. We, the users of the `simulate` function, get
    to decide what type to use for `model`. We need a type that can hold the *state*
    of the system we are simulating, which is the collection of information necessary
    to (1) produce a picture at any given moment of time and (2) determine what will
    happen next as time evolves. This notion of state will play a large role in the
    physics we describe in [Parts II](part02.xhtml) and [III](part03.xhtml) of the
    book. The value of type `model` that `simulate` needs is the initial state of
    the situation to be displayed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The fifth piece of information (type `model -> Picture`) is a function that
    describes what picture to produce given a value of type `model`. The sixth piece
    of information `simulate` needs is a function (type `Viewport -> Float ->` `model
    -> model`) that describes how the state of the system should advance in time.
    The `Float` represents a time step here, and we will not use the `Viewport`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-1](ch13.xhtml#ch13list1) gives a complete program that shows how
    to use the `simulate` function.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 13-1: Sample use of the simulate function from the gloss package*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The display mode and background color are the same as before. We define a constant
    `rate` to hold the simulation rate. For the type variable `model`, we’ve chosen
    `(Float,Float)` and given it the type synonym `State`. This state is meant to
    represent the (x, y) coordinates of the current location of the red disk. The
    initial value of the state is defined in `initialState`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The heart of the simulation is contained in the two functions `displayFunc`
    and `updateFunc`. The first tells how to make a picture from a state. In this
    case, we use the (x, y) coordinates in the state to translate the red disk over
    *x* and up *y*. The display function only cares about the current state of affairs
    (the current values of *x* and *y*). It has nothing to do with how the picture
    changes with time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The update function `updateFunc` explains how the state changes with time. We
    need to give a rule for what the new state will be in terms of the old state and
    a time step `dt`. In this case, we add 10 pixels/second to the x-value and subtract
    5 pixels/second from the y-value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: When we run the program, we should see the red disk move to the right and downward
    as the simulation evolves. The simulation will be jerky because we chose a rate
    of 2 updates/second, so you see each update as a discrete motion. Try increasing
    the rate to get a smoother animation. High definition TV uses 24–60 frames per
    second, so you shouldn’t need to go higher than that. If the lights in your building
    dim, you’ve picked a frame rate that’s too high.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: For one more example of the `simulate` function, let’s see how the projectile
    motion we did before with `animate` would look when done with `simulate`. The
    difference between constant velocity motion and projectile motion is that the
    velocity changes in projectile motion. To allow the velocity to change, we need
    to expand the information in the state to include velocity as well as the position
    of the red disk. For this purpose, we define the type synonyms `Position`, `Velocity`,
    and `State` in the code in [Listing 13-2](ch13.xhtml#ch13list2).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Our `initialState` now needs to contain both the initial position `(0,0)` and
    an initial velocity `(40,80)`. The initial x-component of velocity is 40 m/s,
    and the initial y-component is 80 m/s.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Our display function doesn’t need to change in meaning from the previous simulation.
    The display of the red disk still depends only on the position of the disk and
    not on the current velocity. However, the `displayFunc` function needs a little
    bit of syntactic revision since the type of the state has changed. The syntactic
    revision entails replacing the argument `(x,y)` with `((x,y),_)` to reflect the
    new type of state. If we left the function entirely unchanged, the compiler would
    think that the argument `(x,y)` meant x for position and y for velocity. We would
    get a type error complaining that the expected type of x is `Float` but its actual
    type is `Position`. The “actual type” of `Position` comes from the type signature
    of `displayFunc`, while the “expected type” of `Float` comes from the way x is
    used, as an argument to `Translate`, in the definition of `displayFunc`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement these changes; the result is in [Listing 13-2](ch13.xhtml#ch13list2).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 13-2: Sample use of the `simulate` function to produce projectile
    motion*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The update function is where all of the action happens. The components x and
    y of position get updated based on the current velocity. The velocity components
    vx and vy get updated based on the components of acceleration. The x-component
    of acceleration is 0, so the x-component of velocity stays the same. The y-component
    of acceleration is – 9.8 m/s², so we update the y-component of velocity using
    that, assuming that 1 meter represents 1 pixel in our simulation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更新函数是所有操作发生的地方。位置的x和y分量根据当前的速度更新。速度的x和y分量根据加速度的分量更新。加速度的x分量为0，所以速度的x分量保持不变。加速度的y分量为–9.8米/秒²，因此我们使用它更新速度的y分量，假设1米等于我们模拟中的1像素。
- en: When we run this program, the results should be the same as the projectile program
    we wrote with `animate`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，结果应该与我们用`animate`编写的抛体程序相同。
- en: Notice the difference in the information required to produce the projectile
    motion animation using `animate` compared to `simulate`. To use `animate`, we
    need to have explicit expressions for the position as a function of time. To use
    `simulate`, we provide equivalent information, but it seems like we’re providing
    less. The state update procedure is a powerful tool in numerically solving equations
    of motion. We’ll exploit this tool much more in [Parts II](part02.xhtml) and [III](part03.xhtml)
    of the book.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`animate`和`simulate`时，在生成抛体运动动画所需信息方面的差异。使用`animate`时，我们需要有明确的关于位置随时间变化的表达式。使用`simulate`时，我们提供了等效的信息，但看起来我们提供的更少。状态更新过程是数值求解运动方程的强大工具。在本书的[第二部分](part02.xhtml)和[第三部分](part03.xhtml)中，我们将更深入地利用这个工具。
- en: 3D Animation
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3D动画
- en: 'The `not-gloss` package provides four main functions whose names are identical
    to those in `gloss`: `display`, `animate`, `simulate`, and `play`. As in `gloss`,
    the first is for still pictures, the second and third are for pictures that change
    with time, and the fourth is for pictures that change with time and user input.
    We’re interested primarily in the first three functions. The types of these functions
    are different from those of the corresponding `gloss` functions, in part because
    the `not-gloss` package has a different author from the `gloss` package. There
    are similarities between the two packages, but there are also differences that
    we will point out.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`not-gloss`包提供了四个主要函数，它们的名称与`gloss`中的相同：`display`、`animate`、`simulate`和`play`。与`gloss`中一样，第一个用于静止图像，第二个和第三个用于随时间变化的图像，第四个用于随时间和用户输入变化的图像。我们主要关心前三个函数。这些函数的类型与`gloss`函数的类型不同，部分原因是`not-gloss`包的作者不同于`gloss`包的作者。两个包之间有相似之处，但也有我们将指出的差异。'
- en: Displaying a 3D Picture
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示3D图像
- en: Let’s check the type of `display`. Just as the `gloss` package has a module
    named `Graphics.Gloss` that must be imported before its functions can be used,
    the `not-gloss` package has a module named `Vis` that we must import.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下`display`的类型。正如`gloss`包中必须导入名为`Graphics.Gloss`的模块才能使用其函数一样，`not-gloss`包也有一个名为`Vis`的模块，我们必须导入它才能使用。
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we ask about the type class `Real`, we learn that `Real` is for numeric
    types that can be converted to rational numbers:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查询`Real`类型类，我们会发现`Real`适用于可以转换为有理数的数值类型：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our favorite instance of the `Real` type class is `R` (or `Double`). This will
    be our default choice unless there is a reason to choose something else. If the
    type variable `b` in the type of `display` is `R`, the type of `display` is the
    following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最喜欢的`Real`类型类实例是`R`（或`Double`）。除非有特别的理由选择其他类型，否则我们将默认选择它。如果`display`类型中的类型变量`b`是`R`，则`display`的类型如下：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The display function is asking us to provide two things: a thing with type
    `Options`, and the object to be displayed (type `VisObject R`). The return type
    `IO ()` means that the computer will *do* something (in this case display the
    object).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 显示函数要求我们提供两件事：一个类型为`Options`的对象，以及要显示的对象（类型`VisObject R`）。返回类型`IO ()`意味着计算机将执行某些操作（在这种情况下是显示对象）。
- en: What kinds of things are there that have type `VisObject R`? The `not-gloss`
    package provides a long list of possibilities, including spheres, cubes, lines,
    text, and more. You can find documentation at the [https://hackage.haskell.org](https://hackage.haskell.org)
    site by searching for `not-gloss`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些类型是`VisObject R`？`not-gloss`包提供了一个长长的列表，包括球体、立方体、线条、文本等等。你可以通过访问[https://hackage.haskell.org](https://hackage.haskell.org)并搜索`not-gloss`来查看文档。
- en: 'Here is an example that produces a blue cube:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个生成蓝色立方体的示例：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The constant `defaultOpts` is provided by the `Vis` module as a set of default
    options. You can compile this code into a stand-alone program as before. When
    you run the program, a display window containing a blue cube will open. After
    the display window opens, press e to zoom in and q to zoom out. You can also use
    the mouse to rotate the cube. These are standard features of `not-gloss` that
    we don’t need to program.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The next program will get us familiar with the default coordinate system the
    `Vis` module uses. We’ll draw a red line segment from the origin to the point
    (1, 0, 0), a green line segment from the origin to the point (0, 1, 0), and a
    blue line segment from the origin to the point (0, 0, 1).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we import the `Linear` module to have access to the `V3` constructor. The
    `Linear` module defines several kinds of vector; `V3` is the one used by the `Vis`
    module. The `Nothing` means to use the default line width (try (Just 5) in place
    of `Nothing` to get a thicker line width).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: When we compile and run the program just shown, we see axes for a three-dimensional
    coordinate system. We see that `not-gloss`’s default orientation has the x-axis
    going toward the right and toward the viewer, the y-axis going toward the left
    and toward the viewer, and the z-axis going downward.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Personally, I think having the positive z-axis point downward is disturbing
    and abhorrent. I like to think of myself as a flexible person, but this crosses
    a line. (Greg Horn, the author of `not-gloss`, tells me that the z-down convention
    is standard in much of the aerospace industry.) Fortunately, `not-gloss` has tools
    that allow us to rotate things the way we want. I like to have the x-axis coming
    mostly out of the page, the y-axis pointing toward the right, and the z-axis pointing
    upward. Here is a program that will do just that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We import `Vis` and `Linear` as before, but here we also import `SpatialMath`
    so we can use `Euler` to perform three-dimensional rotations using Euler angles.
    The `axes` picture has not changed. We define a function `orient` that takes a
    picture as input and gives back a reoriented picture as output. To do this, we
    perform a rotation specified by Euler angles using the `RotEulerDeg` data constructor
    of the `VisObject` type. In this case, the Euler angles mean we rotate first by
    0^∘ about the x-axis, then by 180^∘ about the y-axis, and then by 270^∘ about
    the z-axis. Equivalently, we can view this as a rotation first about the z-axis
    by 270^∘, then about the *rotated* y-axis by 180^∘, and then about the rotated
    x-axis by 0^∘.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we pass `orient axes` to `display` as the picture to be displayed.
    If you like this way of orienting the coordinate system, you could pass any picture
    to the function `orient` before displaying it as a way of using this coordinate
    system. You could even define your own display function that does the reorientation
    for you.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Making a 3D Animation
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at the type of `animate`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The type of `animate` is the same as the type of `display`, except that the
    `VisObject b` of `display` is replaced by `Float -> VisObject b` in `animate`.
    Instead of asking us to provide a picture, `animate` is asking us to provide a
    function from time to a picture. The `animate` function demands that we use `Float`
    for the real number representing time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The following animation of a rotating blue cube has the cube rotating counterclockwise
    about the x-axis in my favorite coordinate system (x-axis out of the screen, y-axis
    to the right, and z-axis up the screen):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note the use of function composition between `rotatingCube` and `orient`. The
    function `rotatingCube` takes a number as input and produces a picture as output.
    The function `orient` takes a picture as input and produces a (reoriented) picture
    as output. The composition `orient . rotatingCube` takes a number as input and
    produces a picture as output, which is just the type of function that `animate`
    wants.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Making a 3D Simulation
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `not-gloss` function `simulate` allows the user to make an animation when
    an explicit function describing a picture as a function of time is not available.
    Let’s ask GHCi the type of `simulate`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `simulate` function asks for five pieces of information. The first one
    (type `Options`) is the same as in `display` and `animate`. The second piece of
    information (a `Double`) is the time step, in seconds per update, between successive
    frames of the animated display. Note the difference with the `gloss` library:
    `gloss` asks for a rate in updates per second, but `not-gloss` asks for a time
    step in seconds per update.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The third piece of information is the initial state of the situation to be displayed.
    The type variable `world` stands for a type that the user chooses to describe
    the state of the situation, very much like the type variable `model` used in the
    `gloss` function `simulate`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The fourth piece of information (type `world -> VisObject b`) is a display function
    that describes what picture to produce given a value of type `world`. This display
    function is very much like the display function of `gloss`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the fifth piece of information needed by `simulate` is a function (type
    `Float -> world -> world`) that describes how the state of the system should advance
    in time. The `Float` in this type represents the total time elapsed since the
    beginning of the simulation. This is different from `gloss`, where the `Float`
    in the analogous term describes the time step since the previous frame.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-3](ch13.xhtml#ch13list3) demonstrates how the `simulate` function
    uses the update function that we provide as the fifth piece of information. The
    purpose of the code is to determine, experimentally, what the `simulate` function
    does with the function of type `Float -> world -> world` that we provide. If you’re
    not used to working with higher-order functions, this can seem like a weird question.
    Normally, we write functions for our own use, or we use functions that others
    have written. But when someone else writes a higher-order function for us to use,
    and that higher-order function takes a user-defined function as input, we might
    well wonder how the higher-order function intends to use the user-defined function
    that we provide. (We might read the code or the documentation of the higher-order
    function, but here we’re going to figure it out experimentally.)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: What’s weird is that we’re writing a function, `updateFunc` in [Listing 13-3](ch13.xhtml#ch13list3),
    but we are not going to use that function directly. We don’t decide what `Float`
    to send to `updateFunc`; another function, `simulate`, decides that.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 13-3: Use of the `simulate` function from the `not-gloss` library.
    The purpose of this code is to experimentally determine what `simulate` is doing
    with `updateFunc`.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We begin the code by importing the `Vis` module. For the type variable `world`,
    we choose a pair `(Int,[Float])` in which the `Int` is designed to hold the number
    of updates performed since the beginning of the simulation and the list of floats
    is intended to be a list of the time values passed to the update function `updateFunc`.
    We don’t choose those time values; `simulate` does.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: We set a time step called dt to be half of a second. The `displayFunc` tells
    how to produce a picture from a `State`. It uses the `Text2d` data constructor
    of the `VisObject` type, which you will find if you check out the documentation
    on `not-gloss`’s `simulate` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The update function `updateFunc` keeps track of two things: the number of times
    it has been called and the `Float` values it has been called with. Each time `updateFunc`
    is called, it increases the call count by one and tacks the most recent `Float`
    onto the front of the list.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: When we run this program, we can watch the number of updates increase at the
    rate of two per second and see that the times being passed in are increasing,
    confirming the assertion that the update function takes the time since simulation
    start as input.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we explored several ways to produce two-dimensional and three-dimensional
    graphics and animation. We gave code for programs exhibiting each of the graphics
    functions that we will use later in the book to provide visual support to our
    thinking and writing about physics.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, we have completed [Part I](part01.xhtml) of the book—an introduction
    to functional programming ideas in general and to the Haskell programming language
    in particular. In [Part II](part02.xhtml), we explore Newtonian mechanics, in
    which our goal is to predict the motion of one or more objects experiencing forces.
    The central principle of Newtonian mechanics is Newton’s second law, which is
    the subject of the next chapter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 13.1.** Consult the `gloss` documentation on the `Picture` type
    and make an interesting picture using the `display` function. Combine lines, circles,
    text, colors, and whatever you like. Be creative.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.2.** Use `animate` to make a simple animation. Be creative.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.3.** Use `animate` to make the red disk oscillate left and right.
    Then, change your code a little bit to make the red disk orbit in a circle. Can
    you make the red disk move in an ellipse?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.4.** Use `animate` to produce the same motion of the red disk
    that we achieved with `simulate` in [Listing 13-1](ch13.xhtml#ch13list1).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.5.** Use `simulate` to do something you think is interesting.
    Be creative.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.6.** In the 2D projectile motion example of [Listing 13-2](ch13.xhtml#ch13list2),
    one meter in the real world is represented by one pixel in the animation. Modify
    the code so that one meter is represented by 10 pixels. Feel free to change the
    initial velocity components so the projectile doesn’t speed off the screen right
    away.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.7.** Challenging exercise: Try to use `simulate` to make the
    red disk oscillate left and right without explicitly giving it an oscillating
    function like sin or cos. We will show how to do this in [Part II](part02.xhtml)
    of the book.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.8.** Rewrite the 3D axes code so that the x-axis points to the
    right, the y-axis points upward, and the z-axis points out of the page. This is
    my second-favorite coordinate system.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.9.** Modify the rotating cube animation to make the rotation
    occur clockwise about the x-axis instead of counterclockwise.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.10.** Write an experimental program, similar to [Listing 13-3](ch13.xhtml#ch13list3),
    using the `gloss` function `simulate` to understand how `gloss`’s `simulate` uses
    the update function. Use the same expressions for `updateFunc` and `State` that
    we used in [Listing 13-3](ch13.xhtml#ch13list3). You will need to change the values
    of `displayFunc` and `main`. Use a `rate` of 2 instead of a `dt` of 0.5\. When
    you run this, you should see that the times passed in by `gloss`’s `simulate`
    are time steps that are all close to 0.5.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
