- en: '13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CREATING 2D AND 3D ANIMATIONS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A picture that changes over time can be a good way to visualize many situations.
    The Haskell Prelude itself does not have any support for animation, but some good
    library packages are available at [https://hackage.haskell.org](https://hackage.haskell.org).
    For two-dimensional pictures and animations, we’ll use the `gloss` package. For
    three-dimensional pictures and animations, we’ll use a package named `not-gloss`.
  prefs: []
  type: TYPE_NORMAL
- en: 2D Animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `gloss` package supplies the `Graphics.Gloss` module, which provides four
    main functions: display, animate, simulate, and play. The first is for still pictures,
    the second and third are for pictures that change with time, and the fourth is
    for pictures that change with time and user input. We are interested primarily
    in the first three functions. We’ll describe these functions in the next few sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a 2D Picture
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The function `display` produces a static picture. Let’s ask GHCi for the type
    of `display`. Since `display` is not part of the Prelude, we must first load the
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The types `Display`, `Color`, and `Picture` are defined by the `Graphics.Gloss`
    module, or perhaps by another module in the `gloss` package that is imported by
    `Graphics.Gloss`. The types `Display` and `Color` are for display mode and background
    color, respectively. The most interesting type is `Picture`, which represents
    the type of things that can be displayed. The `gloss` documentation on `Picture`
    describes the pictures we can make (lines, circles, polygons, and so on). You
    can find the documentation at [https://hackage.haskell.org/package/gloss](https://hackage.haskell.org/package/gloss)
    by clicking on `Graphics.Gloss`.
  prefs: []
  type: TYPE_NORMAL
- en: GHCi is not so good at showing the pictures that `gloss` creates, so it’s better
    to make a stand-alone program. Let’s write a program to get us familiar with the
    default coordinate system the `Graphics.Gloss` module uses. We’ll draw a red line
    segment from the origin to the point (100,0) and a green line segment from the
    origin to the point (0,100). Because `gloss` measures distance in pixels, we’ll
    use 100 so that the lines we produce will be long enough to see on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we turn on warnings. Then we import the `Graphics.Gloss` module. We
    need to do this because the code that follows uses the types `Display` and `Picture`;
    the data constructors `InWindow`, `Pictures`, `Color`, and `Line`; the constants
    `red`, `green`, and `black`; and the function `display`. These names are all defined
    in the `Graphics.Gloss` module. Without the `import` statement, we would get “Variable
    not in scope” errors every time we used each of those names.
  prefs: []
  type: TYPE_NORMAL
- en: We define a constant `displayMode` to hold the value of type `Display` that
    the function `display` requires. We give the name “Axes” to the window that will
    be opened by the `display` function. We ask for the window to be 1,000 pixels
    wide and 700 pixels high, and we ask for it to be placed 10 pixels up and 10 pixels
    over from whatever the window system thinks is the origin.
  prefs: []
  type: TYPE_NORMAL
- en: We define a constant called `axes` to hold the `Picture` we want to make. We
    produce the picture using the data constructor `Pictures`, which gives a way to
    combine a list of pictures into a single picture. We can ask GHCi for the types
    of some of the things that didn’t get explicit types in our code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function here uses the function `display` to make the picture. We
    pass `display` our `displayMode`, the background color `black`, and our picture
    `axes`.
  prefs: []
  type: TYPE_NORMAL
- en: When we compile and run the program above using one of the three methods described
    in [Chapter 12](ch12.xhtml), we should see a red horizontal line and a green vertical
    line. The default `gloss` orientation has the x-axis going toward the right and
    the y-axis going upward. Depending on your operating system, you might need to
    hit CTRL-C twice to close the graphics window.
  prefs: []
  type: TYPE_NORMAL
- en: The `gloss` package does not have a primitive disk, or filled circle, picture.
    As a second example of the `display` function, let’s make a picture of a blue
    circle and a red disk, side by side.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here we used the same warnings, import, and `displayMode` lines as before. The
    constant `blueCircle` is a blue circle with a radius of 100 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Since `gloss` does not provide a function to make a disk, we’ll write our own.
    Our `disk` function uses `gloss`’s built-in `ThickCircle` function to make a disk.
    `ThickCircle` takes a radius and a thickness as inputs. Here we choose the radius
    of the thick circle to be half of the desired radius of the disk, and we choose
    the thickness to be the full desired radius of the disk. This circle is so thick
    that there is no hole left in the middle, making a disk.
  prefs: []
  type: TYPE_NORMAL
- en: The constant `redDisk` is a red disk with a radius of 100 pixels. The constant
    `wholePicture` uses the `Translate` data constructor of the `Picture` type to
    shift the circle to the left and the disk to the right. The `main` function is
    very similar to that of the last program, except now we are displaying `wholePicture`.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the program, we should see a blue circle to the left of a red disk
    of the same size.
  prefs: []
  type: TYPE_NORMAL
- en: Making a 2D Animation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given a picture as a function of time, the function `animate` produces an animation.
    Let’s ask GHCi the type of `animate`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The difference in type compared to `display` is that `Picture` in `display`
    has been replaced by `Float -> Picture` in `animate`. The `animate` function uses
    a `Float` to describe time, so an expression of type `Float -> Picture` is a function
    from time to a picture, or a picture as a function of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use `animate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The function `projectileMotion` takes a `Float` (the time) as input and produces
    a `Picture` by translating the red disk to the right by `xDisk t` and upward by
    `yDisk t`. The functions `xDisk` and `yDisk` are given explicitly as functions
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: When we compile and run this code, we’ll see a red disk experiencing projectile
    motion. One meter is represented by one pixel, and one second of time in the real
    world is one second of time in the animation. The projectile starts with an initial
    x-component of velocity of 40 m/s and an initial y-component of velocity of 80
    m/s.
  prefs: []
  type: TYPE_NORMAL
- en: Making a 2D Simulation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `gloss` package’s `simulate` function allows the user to make an animation
    when an explicit function describing a picture as a function of time is not available.
    Let’s ask GHCi the type of `simulate`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `simulate` function asks for six pieces of information. The first two, display
    mode (type `Display`) and background color (type `Color`), are the same as in
    `display` and `animate`. The third piece of information (an `Int`) is the rate,
    in updates per second, at which the simulation should run. The fourth piece of
    information has the type variable `model` instead of a concrete type. We can tell
    that `model` is a type variable because it starts with a lowercase letter; it
    cannot be a constant or a function because it sits in a type signature in the
    place where a type needs to sit. We, the users of the `simulate` function, get
    to decide what type to use for `model`. We need a type that can hold the *state*
    of the system we are simulating, which is the collection of information necessary
    to (1) produce a picture at any given moment of time and (2) determine what will
    happen next as time evolves. This notion of state will play a large role in the
    physics we describe in [Parts II](part02.xhtml) and [III](part03.xhtml) of the
    book. The value of type `model` that `simulate` needs is the initial state of
    the situation to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth piece of information (type `model -> Picture`) is a function that
    describes what picture to produce given a value of type `model`. The sixth piece
    of information `simulate` needs is a function (type `Viewport -> Float ->` `model
    -> model`) that describes how the state of the system should advance in time.
    The `Float` represents a time step here, and we will not use the `Viewport`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-1](ch13.xhtml#ch13list1) gives a complete program that shows how
    to use the `simulate` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-1: Sample use of the simulate function from the gloss package*'
  prefs: []
  type: TYPE_NORMAL
- en: The display mode and background color are the same as before. We define a constant
    `rate` to hold the simulation rate. For the type variable `model`, we’ve chosen
    `(Float,Float)` and given it the type synonym `State`. This state is meant to
    represent the (x, y) coordinates of the current location of the red disk. The
    initial value of the state is defined in `initialState`.
  prefs: []
  type: TYPE_NORMAL
- en: The heart of the simulation is contained in the two functions `displayFunc`
    and `updateFunc`. The first tells how to make a picture from a state. In this
    case, we use the (x, y) coordinates in the state to translate the red disk over
    *x* and up *y*. The display function only cares about the current state of affairs
    (the current values of *x* and *y*). It has nothing to do with how the picture
    changes with time.
  prefs: []
  type: TYPE_NORMAL
- en: The update function `updateFunc` explains how the state changes with time. We
    need to give a rule for what the new state will be in terms of the old state and
    a time step `dt`. In this case, we add 10 pixels/second to the x-value and subtract
    5 pixels/second from the y-value.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the program, we should see the red disk move to the right and downward
    as the simulation evolves. The simulation will be jerky because we chose a rate
    of 2 updates/second, so you see each update as a discrete motion. Try increasing
    the rate to get a smoother animation. High definition TV uses 24–60 frames per
    second, so you shouldn’t need to go higher than that. If the lights in your building
    dim, you’ve picked a frame rate that’s too high.
  prefs: []
  type: TYPE_NORMAL
- en: For one more example of the `simulate` function, let’s see how the projectile
    motion we did before with `animate` would look when done with `simulate`. The
    difference between constant velocity motion and projectile motion is that the
    velocity changes in projectile motion. To allow the velocity to change, we need
    to expand the information in the state to include velocity as well as the position
    of the red disk. For this purpose, we define the type synonyms `Position`, `Velocity`,
    and `State` in the code in [Listing 13-2](ch13.xhtml#ch13list2).
  prefs: []
  type: TYPE_NORMAL
- en: Our `initialState` now needs to contain both the initial position `(0,0)` and
    an initial velocity `(40,80)`. The initial x-component of velocity is 40 m/s,
    and the initial y-component is 80 m/s.
  prefs: []
  type: TYPE_NORMAL
- en: Our display function doesn’t need to change in meaning from the previous simulation.
    The display of the red disk still depends only on the position of the disk and
    not on the current velocity. However, the `displayFunc` function needs a little
    bit of syntactic revision since the type of the state has changed. The syntactic
    revision entails replacing the argument `(x,y)` with `((x,y),_)` to reflect the
    new type of state. If we left the function entirely unchanged, the compiler would
    think that the argument `(x,y)` meant x for position and y for velocity. We would
    get a type error complaining that the expected type of x is `Float` but its actual
    type is `Position`. The “actual type” of `Position` comes from the type signature
    of `displayFunc`, while the “expected type” of `Float` comes from the way x is
    used, as an argument to `Translate`, in the definition of `displayFunc`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement these changes; the result is in [Listing 13-2](ch13.xhtml#ch13list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-2: Sample use of the `simulate` function to produce projectile
    motion*'
  prefs: []
  type: TYPE_NORMAL
- en: The update function is where all of the action happens. The components x and
    y of position get updated based on the current velocity. The velocity components
    vx and vy get updated based on the components of acceleration. The x-component
    of acceleration is 0, so the x-component of velocity stays the same. The y-component
    of acceleration is – 9.8 m/s², so we update the y-component of velocity using
    that, assuming that 1 meter represents 1 pixel in our simulation.
  prefs: []
  type: TYPE_NORMAL
- en: When we run this program, the results should be the same as the projectile program
    we wrote with `animate`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the difference in the information required to produce the projectile
    motion animation using `animate` compared to `simulate`. To use `animate`, we
    need to have explicit expressions for the position as a function of time. To use
    `simulate`, we provide equivalent information, but it seems like we’re providing
    less. The state update procedure is a powerful tool in numerically solving equations
    of motion. We’ll exploit this tool much more in [Parts II](part02.xhtml) and [III](part03.xhtml)
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 3D Animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `not-gloss` package provides four main functions whose names are identical
    to those in `gloss`: `display`, `animate`, `simulate`, and `play`. As in `gloss`,
    the first is for still pictures, the second and third are for pictures that change
    with time, and the fourth is for pictures that change with time and user input.
    We’re interested primarily in the first three functions. The types of these functions
    are different from those of the corresponding `gloss` functions, in part because
    the `not-gloss` package has a different author from the `gloss` package. There
    are similarities between the two packages, but there are also differences that
    we will point out.'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a 3D Picture
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s check the type of `display`. Just as the `gloss` package has a module
    named `Graphics.Gloss` that must be imported before its functions can be used,
    the `not-gloss` package has a module named `Vis` that we must import.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ask about the type class `Real`, we learn that `Real` is for numeric
    types that can be converted to rational numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our favorite instance of the `Real` type class is `R` (or `Double`). This will
    be our default choice unless there is a reason to choose something else. If the
    type variable `b` in the type of `display` is `R`, the type of `display` is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The display function is asking us to provide two things: a thing with type
    `Options`, and the object to be displayed (type `VisObject R`). The return type
    `IO ()` means that the computer will *do* something (in this case display the
    object).'
  prefs: []
  type: TYPE_NORMAL
- en: What kinds of things are there that have type `VisObject R`? The `not-gloss`
    package provides a long list of possibilities, including spheres, cubes, lines,
    text, and more. You can find documentation at the [https://hackage.haskell.org](https://hackage.haskell.org)
    site by searching for `not-gloss`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that produces a blue cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The constant `defaultOpts` is provided by the `Vis` module as a set of default
    options. You can compile this code into a stand-alone program as before. When
    you run the program, a display window containing a blue cube will open. After
    the display window opens, press e to zoom in and q to zoom out. You can also use
    the mouse to rotate the cube. These are standard features of `not-gloss` that
    we don’t need to program.
  prefs: []
  type: TYPE_NORMAL
- en: The next program will get us familiar with the default coordinate system the
    `Vis` module uses. We’ll draw a red line segment from the origin to the point
    (1, 0, 0), a green line segment from the origin to the point (0, 1, 0), and a
    blue line segment from the origin to the point (0, 0, 1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we import the `Linear` module to have access to the `V3` constructor. The
    `Linear` module defines several kinds of vector; `V3` is the one used by the `Vis`
    module. The `Nothing` means to use the default line width (try (Just 5) in place
    of `Nothing` to get a thicker line width).
  prefs: []
  type: TYPE_NORMAL
- en: When we compile and run the program just shown, we see axes for a three-dimensional
    coordinate system. We see that `not-gloss`’s default orientation has the x-axis
    going toward the right and toward the viewer, the y-axis going toward the left
    and toward the viewer, and the z-axis going downward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Personally, I think having the positive z-axis point downward is disturbing
    and abhorrent. I like to think of myself as a flexible person, but this crosses
    a line. (Greg Horn, the author of `not-gloss`, tells me that the z-down convention
    is standard in much of the aerospace industry.) Fortunately, `not-gloss` has tools
    that allow us to rotate things the way we want. I like to have the x-axis coming
    mostly out of the page, the y-axis pointing toward the right, and the z-axis pointing
    upward. Here is a program that will do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We import `Vis` and `Linear` as before, but here we also import `SpatialMath`
    so we can use `Euler` to perform three-dimensional rotations using Euler angles.
    The `axes` picture has not changed. We define a function `orient` that takes a
    picture as input and gives back a reoriented picture as output. To do this, we
    perform a rotation specified by Euler angles using the `RotEulerDeg` data constructor
    of the `VisObject` type. In this case, the Euler angles mean we rotate first by
    0^∘ about the x-axis, then by 180^∘ about the y-axis, and then by 270^∘ about
    the z-axis. Equivalently, we can view this as a rotation first about the z-axis
    by 270^∘, then about the *rotated* y-axis by 180^∘, and then about the rotated
    x-axis by 0^∘.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we pass `orient axes` to `display` as the picture to be displayed.
    If you like this way of orienting the coordinate system, you could pass any picture
    to the function `orient` before displaying it as a way of using this coordinate
    system. You could even define your own display function that does the reorientation
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Making a 3D Animation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at the type of `animate`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The type of `animate` is the same as the type of `display`, except that the
    `VisObject b` of `display` is replaced by `Float -> VisObject b` in `animate`.
    Instead of asking us to provide a picture, `animate` is asking us to provide a
    function from time to a picture. The `animate` function demands that we use `Float`
    for the real number representing time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following animation of a rotating blue cube has the cube rotating counterclockwise
    about the x-axis in my favorite coordinate system (x-axis out of the screen, y-axis
    to the right, and z-axis up the screen):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of function composition between `rotatingCube` and `orient`. The
    function `rotatingCube` takes a number as input and produces a picture as output.
    The function `orient` takes a picture as input and produces a (reoriented) picture
    as output. The composition `orient . rotatingCube` takes a number as input and
    produces a picture as output, which is just the type of function that `animate`
    wants.
  prefs: []
  type: TYPE_NORMAL
- en: Making a 3D Simulation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `not-gloss` function `simulate` allows the user to make an animation when
    an explicit function describing a picture as a function of time is not available.
    Let’s ask GHCi the type of `simulate`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `simulate` function asks for five pieces of information. The first one
    (type `Options`) is the same as in `display` and `animate`. The second piece of
    information (a `Double`) is the time step, in seconds per update, between successive
    frames of the animated display. Note the difference with the `gloss` library:
    `gloss` asks for a rate in updates per second, but `not-gloss` asks for a time
    step in seconds per update.'
  prefs: []
  type: TYPE_NORMAL
- en: The third piece of information is the initial state of the situation to be displayed.
    The type variable `world` stands for a type that the user chooses to describe
    the state of the situation, very much like the type variable `model` used in the
    `gloss` function `simulate`.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth piece of information (type `world -> VisObject b`) is a display function
    that describes what picture to produce given a value of type `world`. This display
    function is very much like the display function of `gloss`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the fifth piece of information needed by `simulate` is a function (type
    `Float -> world -> world`) that describes how the state of the system should advance
    in time. The `Float` in this type represents the total time elapsed since the
    beginning of the simulation. This is different from `gloss`, where the `Float`
    in the analogous term describes the time step since the previous frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-3](ch13.xhtml#ch13list3) demonstrates how the `simulate` function
    uses the update function that we provide as the fifth piece of information. The
    purpose of the code is to determine, experimentally, what the `simulate` function
    does with the function of type `Float -> world -> world` that we provide. If you’re
    not used to working with higher-order functions, this can seem like a weird question.
    Normally, we write functions for our own use, or we use functions that others
    have written. But when someone else writes a higher-order function for us to use,
    and that higher-order function takes a user-defined function as input, we might
    well wonder how the higher-order function intends to use the user-defined function
    that we provide. (We might read the code or the documentation of the higher-order
    function, but here we’re going to figure it out experimentally.)'
  prefs: []
  type: TYPE_NORMAL
- en: What’s weird is that we’re writing a function, `updateFunc` in [Listing 13-3](ch13.xhtml#ch13list3),
    but we are not going to use that function directly. We don’t decide what `Float`
    to send to `updateFunc`; another function, `simulate`, decides that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-3: Use of the `simulate` function from the `not-gloss` library.
    The purpose of this code is to experimentally determine what `simulate` is doing
    with `updateFunc`.*'
  prefs: []
  type: TYPE_NORMAL
- en: We begin the code by importing the `Vis` module. For the type variable `world`,
    we choose a pair `(Int,[Float])` in which the `Int` is designed to hold the number
    of updates performed since the beginning of the simulation and the list of floats
    is intended to be a list of the time values passed to the update function `updateFunc`.
    We don’t choose those time values; `simulate` does.
  prefs: []
  type: TYPE_NORMAL
- en: We set a time step called dt to be half of a second. The `displayFunc` tells
    how to produce a picture from a `State`. It uses the `Text2d` data constructor
    of the `VisObject` type, which you will find if you check out the documentation
    on `not-gloss`’s `simulate` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The update function `updateFunc` keeps track of two things: the number of times
    it has been called and the `Float` values it has been called with. Each time `updateFunc`
    is called, it increases the call count by one and tacks the most recent `Float`
    onto the front of the list.'
  prefs: []
  type: TYPE_NORMAL
- en: When we run this program, we can watch the number of updates increase at the
    rate of two per second and see that the times being passed in are increasing,
    confirming the assertion that the update function takes the time since simulation
    start as input.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we explored several ways to produce two-dimensional and three-dimensional
    graphics and animation. We gave code for programs exhibiting each of the graphics
    functions that we will use later in the book to provide visual support to our
    thinking and writing about physics.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, we have completed [Part I](part01.xhtml) of the book—an introduction
    to functional programming ideas in general and to the Haskell programming language
    in particular. In [Part II](part02.xhtml), we explore Newtonian mechanics, in
    which our goal is to predict the motion of one or more objects experiencing forces.
    The central principle of Newtonian mechanics is Newton’s second law, which is
    the subject of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 13.1.** Consult the `gloss` documentation on the `Picture` type
    and make an interesting picture using the `display` function. Combine lines, circles,
    text, colors, and whatever you like. Be creative.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.2.** Use `animate` to make a simple animation. Be creative.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.3.** Use `animate` to make the red disk oscillate left and right.
    Then, change your code a little bit to make the red disk orbit in a circle. Can
    you make the red disk move in an ellipse?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.4.** Use `animate` to produce the same motion of the red disk
    that we achieved with `simulate` in [Listing 13-1](ch13.xhtml#ch13list1).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.5.** Use `simulate` to do something you think is interesting.
    Be creative.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.6.** In the 2D projectile motion example of [Listing 13-2](ch13.xhtml#ch13list2),
    one meter in the real world is represented by one pixel in the animation. Modify
    the code so that one meter is represented by 10 pixels. Feel free to change the
    initial velocity components so the projectile doesn’t speed off the screen right
    away.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.7.** Challenging exercise: Try to use `simulate` to make the
    red disk oscillate left and right without explicitly giving it an oscillating
    function like sin or cos. We will show how to do this in [Part II](part02.xhtml)
    of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.8.** Rewrite the 3D axes code so that the x-axis points to the
    right, the y-axis points upward, and the z-axis points out of the page. This is
    my second-favorite coordinate system.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.9.** Modify the rotating cube animation to make the rotation
    occur clockwise about the x-axis instead of counterclockwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 13.10.** Write an experimental program, similar to [Listing 13-3](ch13.xhtml#ch13list3),
    using the `gloss` function `simulate` to understand how `gloss`’s `simulate` uses
    the update function. Use the same expressions for `updateFunc` and `State` that
    we used in [Listing 13-3](ch13.xhtml#ch13list3). You will need to change the values
    of `displayFunc` and `main`. Use a `rate` of 2 instead of a `dt` of 0.5\. When
    you run this, you should see that the times passed in by `gloss`’s `simulate`
    are time steps that are all close to 0.5.'
  prefs: []
  type: TYPE_NORMAL
