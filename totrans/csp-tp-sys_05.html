<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch5" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch5">
<span class="CN"><span aria-label=" Page 139. " epub:type="pagebreak" id="pg_139" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">TYPES OF EQUALITY</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" height="191" src="../images/opener-img.png" width="191"/>
</figure>
<p class="COS">Programs frequently compare variables to see if their values are equal, although this operation is often overlooked because it’s done implicitly. Every type inherits the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class, so given any two values <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp> is always valid.</p>
<p class="TX">C# also provides <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, or the <i>equals-equals</i> operator, for explicitly checking equality of two values. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> for comparisons differs from using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method in multiple ways. In this chapter, we’ll look at why C# supports two techniques for equality comparison and how each is affected by the differences between types.</p>
<p class="TX">We’ll explore the following:</p>
<ul class="BL">
<li class="BL">How the differences between comparisons using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method versus <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> affect our programs</li>
<li class="BL">What support the compiler provides for comparisons, and what we must provide ourselves</li>
<li class="BL">Why equality comparisons and hash codes are so closely related</li>
<li class="BL"><span aria-label=" Page 140. " epub:type="pagebreak" id="pg_140" role="doc-pagebreak"/>When we need to customize equality comparisons for our own types</li>
<li class="BL">How a variable’s type affects equality behavior</li>
</ul>
<p class="TX">We’ll take a forensic approach to see how the compiler treats equality for different types and explore why there’s more to the topic of equality than just <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>. Having more than one way to compare values underscores just how important this most basic comparison is. First, let’s look at how equality works for the built-in types.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-106"/><samp class="SANS_Futura_Std_Bold_B_11">Built-in Equality</samp></h2>
<p class="TNI">In this section, we’ll look at the basics of equality comparisons between C#’s built-in types—including integers and floating-point numbers, reference variables, and arrays—and how some built-in types override the default behavior of equality.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>The convention</i> <span class="Roman">equals-equals</span><i>, or</i> <span class="Roman">double-equals</span> <i>as it’s sometimes known, is used by several languages to distinguish the comparison for equality from the assignment operator</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp><i>, which is just</i> <span class="Roman">equals</span><i>. JavaScript has a third variation,</i> <span class="Roman">equals-equals-equals</span><i>, to check that two variables have the same type</i> <span class="Roman">and</span> <i>value.</i></p>
<p class="TX">Because every type in C# inherits the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, we can compare any two variables with that method. However, using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare variables of the built-in types is more efficient and may even result in different behavior than using <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, as you’ll soon see.</p>
<p class="TX">Equality comparisons using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> are baked into the CLR for all the intrinsic types—that is, all the numeric types except <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> (which has built-in compiler support but isn’t a native CLR type), the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> types, and references. The CLR has a built-in instruction to compare two intrinsic values, so we can always compare those values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, and it’s as efficient as it could possibly be.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h-107"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Whole Numbers</samp></h3>
<p class="TNI">The built-in <i>integral</i> types—<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">byte</samp>—represent whole numbers, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type represents UTF-16 characters. They all have the same behavior for the purposes of equality comparison. Values of <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> type, while not strictly speaking numeric values, are compared the same way too. <a href="#list5-1">Listing 5-1</a> compares two integer values by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator.</p>
<pre id="list5-1"><code>int x = 10;&#13;
int y = x;&#13;
Assert.That(x == y, Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: Built-in numeric comparison</samp></p>
<p class="TX">Here, we copy the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> so that the two variables have identical values. The result is that they compare equal. If we look at <span aria-label=" Page 141. " epub:type="pagebreak" id="pg_141" role="doc-pagebreak"/>the CIL generated by the compiler, we see how these built-in types get special support at run time:</p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span><samp class="SANS_TheSansMonoCd_W5Regular_11"> L_0001: ldc.i4.s 10</samp>&#13;
L_0003: stloc.0  // x&#13;
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> L_0004: ldloc.0  // x&#13;
L_0006: stloc.1  // y&#13;
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> L_0007: ldloc.0  // x&#13;
L_0008: ldloc.1  // y&#13;
<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> L_0009: ceq</code></pre>
<p class="TX">CIL instructions all follow a similar low-level format. Each line has a label in the format <samp class="SANS_TheSansMonoCd_W5Regular_11">L_</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>, followed by the instruction itself and any arguments it needs. The first instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">ldc.i4.s</samp>, pushes its argument, the value <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>, onto the evaluation stack <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The next instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">stloc.0</samp>, has no arguments but pops the value at the top of the evaluation stack into the variable at location <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, which, as the decompiler helpfully tells us in a comment, is the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> variable. The outcome of these first two lines is that the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> variable is assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>.</p>
<p class="TX">Next, the previously stored value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is loaded and then stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Then, the values of both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are pushed back onto the evaluation stack so they can be interpreted by the next instruction <span aria-label="annotation3" class="CodeAnnotation">❸</span>. Lastly, the built-in instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> compares the two values on the top of the evaluation stack for equality <span aria-label="annotation4" class="CodeAnnotation">❹</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction corresponds directly with the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> comparison between two built-in values.</p>
<p class="TX">The way the comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> is performed is up to the JIT compiler, which translates CIL to machine code at run time, but we can think of it as a bitwise comparison between two numeric values. If they compare equal, the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, interpreted as the Boolean value <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, is pushed onto the evaluation stack; otherwise, a <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> is pushed and interpreted as <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.</p>
<p class="TX">The Boolean result is passed as the first argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assert.That</samp> method (not shown in the CIL listing). The test passes because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> have the same numeric value.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-108"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point Values</samp></h3>
<p class="TNI">The same <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction is used when we compare <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values with the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator. However, for floating-point numbers, this method of comparison doesn’t necessarily behave as we might expect. In C#, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values are represented in a binary format defined by the Standard for Floating-Point Arithmetic published by the Institute of Electrical and Electronics Engineers (IEEE). The IEEE-754 standard specifies a fixed precision for those types, with the result that many numbers can’t be represented exactly.</p>
<p class="TX">When a number has no exact representation, it’s rounded to the nearest number that can be exactly represented. The next nearest representable <span aria-label=" Page 142. " epub:type="pagebreak" id="pg_142" role="doc-pagebreak"/>number may be relatively larger or smaller than the original value. The difference between two neighboring exact representations is proportional to the magnitude of those numbers, so the rounding difference of a very large number will generally be much greater than that for a very small number. Calculations with multiple numbers that have been rounded will compound the resulting rounding error, a problem that isn’t restricted to either very large or very small numbers. <a href="#list5-2">Listing 5-2</a> compares two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values that we might intuitively expect to be equal.</p>
<pre id="list5-2"><code>double x = 0.3;&#13;
double y = 0.1 + 0.2;&#13;
Assert.That(x == y, Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: A simple floating-point calculation</samp></p>
<p class="TX">This test fails because none of the constant values can be represented exactly in the format of a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. The values given to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> will be rounded to the nearest representable value. On top of that, the result of the addition has an inexact representation and so is rounded again, producing a value that differs from the value assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. The test for equality between <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> fails because the values differ in their least significant digits.</p>
<p class="TX">Subtracting one floating-point number from another can also produce unexpected results: if the two numbers are nearly equal, the result will have values only in those least significant places, which is exactly where rounding will be noticeable. The consequence is that some or all of the significant digits in the result may be lost, a problem sometimes called <i>cancellation</i>.</p>
<p class="TX">Rounding and cancellation issues are inherent in the IEEE-754 representation of floating-point values and not specific to C#. It’s possible to alleviate some of the problems that arise from them, however, depending on exactly what we want to achieve.</p>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H3" id="sec4"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mitigating the Limitations of Rounding and Cancellation</samp></h4>
<p class="TNI">The magnitude of rounding is predictable, as it’s directly related to the precision of the binary representation. <i>Precision</i> here means the number of binary digits that can be stored in the type. Importantly, that means any number without an exact representation in a given type will always round the same way for the same type.</p>
<p class="TX">The compounded error caused by repeated calculations is harder to predict, and the order of operations in a calculation can significantly affect the result. Performing the same sequence of operations twice might even produce different results, depending on factors such as optimization and the location of the result being stored. A complete analysis of the different approaches to comparing floating-point numbers is far too large a topic to cover here, but in essence, rather than comparing floating-point numbers for exact equality, we can provide an implementation that determines whether two numbers are approximately equal.</p>
<p class="TX"><span aria-label=" Page 143. " epub:type="pagebreak" id="pg_143" role="doc-pagebreak"/>One approach is to compare whether two numbers are equal within a certain number of decimal places, as shown in <a href="#list5-3">Listing 5-3</a>.</p>
<pre id="list5-3"><code>public static bool ApproximatelyEqual(double x, double y)&#13;
    =&gt; Math.Round(Math.Abs(x - y), 7) == 0;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: A simple approximate comparison of floating-point numbers</samp></p>
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math.Round</samp> method to determine whether two values are equal within an absolute number of decimal places—seven digits, in this example. We might also consider passing the number of required decimal places as a parameter rather than relying on a hard-coded constant. Either way, this is a quick and simple method for comparing floating-point values. The disadvantage is that it’s insensitive to differences smaller than the number of decimal places we’ve specified and inaccurate when comparing very large numbers.</p>
<p class="TX">A second approach is to find out whether the difference between two numbers is smaller than a certain tolerance, like this:</p>
<pre><code>public static bool ApproximatelyEqual(double x, double y)&#13;
    =&gt; Math.Abs(x - y) &lt; Tolerance;</code></pre>
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp> method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if the absolute difference between two floating-point numbers is smaller than a predefined tolerance, but we need to define a sensible value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp>. Doing so isn’t straightforward, because the difference between two floating-point values can vary according to their magnitude. <a href="#list5-4">Listing 5-4</a> uses a value for tolerance that is weighted according to the magnitude of the smaller of the numbers being compared.</p>
<pre id="list5-4"><code>private const double Tolerance = 1E-15;&#13;
public static bool ApproximatelyEqual(double x, double y)&#13;
    =&gt; Math.Abs(x - y) &lt;&#13;
       Math.Max(Tolerance, Math.Min(x, y)) * Tolerance;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: Approximate comparison using a weighted tolerance</samp></p>
<p class="TX">We’ve added a <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp> constant to represent how sensitive we want our comparison to be, although we don’t use its unqualified value in the comparison. The rounding error for very large values has a far greater magnitude than the error for very small numbers, and our tolerance needs to be sensitive to that. Instead, we scale the tolerance according to the numbers being compared. We use the smaller of the two values for scaling because that’s probably where we’re most sensitive to the rounding error. As a compromise to avoid multiplying by 0, if the smallest value is smaller than <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp>, we scale <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp> by itself, which might cost us some precision in comparing tiny values.</p>
<p class="TX">The value chosen for <samp class="SANS_TheSansMonoCd_W5Regular_11">Tolerance</samp> here is sensitive enough to be able to distinguish differences within around 25 decimal places when the values <span aria-label=" Page 144. " epub:type="pagebreak" id="pg_144" role="doc-pagebreak"/>are close to 0. When the values are closer to 1.0, the scaling means that differences can be detected within 15 or 16 decimal places, and the sensitivity decreases as the size of the values increases. This approach to determining equality between floating-point numbers isn’t universally suitable, and specific applications may require a much more refined implementation.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H3" id="sec5"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Alternative Number Representations</samp></h4>
<p class="TNI">We must always keep in mind that floating-point numbers aren’t real numbers in the mathematical sense, inasmuch as many real numbers can’t be expressed as a floating-point value. Real numbers have infinite precision, but computer memory is finite, so the fixed and limited precision of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> values is a compromise.</p>
<p class="TX">Whether the imprecision of floating-point values matters will depend on our objective. One alternative is to use a different representation, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> type that’s represented in <i>decimal</i> rather than binary and has a greater precision than a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. In practice, a <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> can represent more real numbers exactly, because it has a greater number of significant digits with which to represent them. This means <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> values are less prone to rounding. However, each type has its own trade-offs, and <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> isn’t a general-purpose type: it’s intended for calculations that are most naturally represented in decimal, such as financial calculations. The representation of a <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> has a smaller range than either <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, so the largest positive and negative values are smaller than either <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent. Another consideration is that a <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> value requires more memory than a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.</p>
<p class="TX">As an example of the practical implications of choosing between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>, consider the trigonometry methods in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Math</samp> class, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cos</samp>, which take <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> as their parameter and don’t provide overloads taking <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> values. If our code uses these methods, we can’t substitute <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp>, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">decimal</samp> type is specifically designed for monetary values and thus can’t represent the results of trigonometric operations.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Invalid Numbers</samp></h4>
<p class="TNI">Another consequence of working with <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> values is that some operations can produce a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> (not a number) result, which has <i>no</i> numerical representation. When we’re using <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> values, we need to make sure we correctly identify when the result of a calculation is <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>, because <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> is viral: any calculation involving <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> produces <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> as its result. We would get a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>, for example, if we tried to divide 0.0 by 0.0.</p>
<p class="TX">We might expect that we could identify a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> with a direct comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, as in <a href="#list5-5">Listing 5-5</a>.</p>
<pre id="list5-5"><code>var x = 0.0 / 0.0;&#13;
Assert.That(x == double.NaN, Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: Comparing NaNs</samp></p>
<p class="TX"><span aria-label=" Page 145. " epub:type="pagebreak" id="pg_145" role="doc-pagebreak"/>Dividing 0.0 by 0.0 certainly produces a <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>, so many programmers would expect this equality test with <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> to pass, but it doesn’t. The IEEE-754 standard states that two <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> values don’t compare equal, so this test’s failure is correct behavior. Instead, C# provides the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp> static method, which we use like this:</p>
<pre><code>Assert.That(double.IsNaN(x), Is.True);</code></pre>
<p class="TX">As of C# v8.0, we can use a constant pattern to make the comparison more naturally:</p>
<pre><code>Assert.That(x is double.NaN, Is.True);</code></pre>
<p class="TX">The compiler translates the pattern expression into <samp class="SANS_TheSansMonoCd_W5Regular_11">double.IsNaN(x)</samp>, so there’s no comparison using either <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp> method will always give us the correct result. It also highlights one important difference between comparing floating-point values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">double.Equals</samp> method: the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method compares floating-point values with <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>, but, unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> also calls <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp> when the values are <i>not</i> equal. Consider the following test, where we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp> values by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method:</p>
<pre><code>var x = 0.0 / 0.0;&#13;
Assert.That(x.Equals(Double.NaN), Is.True);</code></pre>
<p class="TX">This test passes because, according to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> values compare equal when the values are exactly equal or are both <samp class="SANS_TheSansMonoCd_W5Regular_11">NaN</samp>. The result of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for floating-point numbers may therefore differ from the result of using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, which doesn’t compare the results of <samp class="SANS_TheSansMonoCd_W5Regular_11">IsNaN</samp>. Both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> ultimately make a strict comparison of <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values using <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>, so we shouldn’t rely on using either approach to compare floating-point numbers, because the result might not be what we expect.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>Some calculations can result in positive or negative</i> <span class="Roman">infinity</span><i>, represented as double.PositiveInfinity and double.NegativeInfinity, respectively. While either value may be an incorrect result, infinite values aren’t usually considered</i> <span class="Roman">invalid</span> <i>in the same way as NaN. We can compare a value with double.PositiveInfinity or double.NegativeInfinity in a constant pattern by using the is keyword, but values can also be directly compared using</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <i>with either kind of infinity.</i></p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h-109"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Equality</samp></h3>
<p class="TNI">As <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> explained, a reference is either <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> or an opaque handle to an object on the heap. An object can have several references to it, and two references to the same object compare equal. Every object instance has a unique identity, and the value of a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is the identity of the object to which it refers. To tell whether two references refer to the same object or different instances, then, we use an identity comparison.</p>
<p class="TX"><span aria-label=" Page 146. " epub:type="pagebreak" id="pg_146" role="doc-pagebreak"/>We might also be interested in whether a reference is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, so let’s look at the mechanics of comparing one reference with either another reference or the <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference.</p>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparing Two References</samp></h4>
<p class="TNI">If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are both references to the same object, they have the same identity and so compare equal via either <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. If they refer to different objects, even if those objects have the same state, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> won’t compare equal. In <a href="#list5-6">Listing 5-6</a> we use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare two reference variables.</p>
<pre id="list5-6"><code>public sealed class MusicTrack&#13;
{&#13;
}&#13;
var x = new MusicTrack();&#13;
var y = new MusicTrack();&#13;
Assert.That(x == y, Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: Comparing references</samp></p>
<p class="TX">These <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> reference variables aren’t equal because they refer to different objects, even though both objects have the same state. Rather than assigning constant values to two variables as we did in <a href="#list5-1">Listing 5-1</a>, we’re creating new objects on the heap, and the variables are references to those objects. When we examine the generated CIL, on the last line we can see that the two references are compared for equality by using the same <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction as in <a href="#list5-1">Listing 5-1</a>:</p>
<pre><code>IL_0001:  newobj    instance void MusicTrack::.ctor()&#13;
IL_0006:  stloc.0   // x&#13;
IL_0007:  newobj    instance void MusicTrack::.ctor()&#13;
IL_000c:  stloc.1   // y&#13;
IL_000d:  ldloc.0&#13;
IL_000e:  ldloc.1&#13;
IL_000f:  ceq</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">newobj</samp> instruction creates a new instance of a type and stores a reference to it on the evaluation stack. We create two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> on the heap, since <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> is a class, and store references to them in the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables, respectively. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> refer to different instances, the variables have different <i>values</i> and thus aren’t equal when compared using <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp>.</p>
<p class="TX">As far as the <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction is concerned, at run time a reference is just a sequence of bits, in much the same way as a number is represented as a sequence of bits. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction merely compares two bit patterns to determine whether they match. Two references to different object instances on the heap have different bit patterns, so they don’t compare equal.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H3" id="sec9"><span aria-label=" Page 147. " epub:type="pagebreak" id="pg_147" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparing with the null Reference</samp></h4>
<p class="TNI">The value of a reference variable is either a reference to an object on the heap or <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare any reference with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to determine whether it refers to an object. If the reference refers to an object, as in <a href="#list5-7">Listing 5-7</a>, the reference isn’t equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<pre id="list5-7"><code>var x = new MusicTrack();&#13;
Assert.That(x == null, Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: Comparing a reference with null</samp></p>
<p class="TX">This comparison also uses the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction:</p>
<pre><code>IL_0016: newobj    instance void MusicTrack::.ctor()&#13;
IL_001c: ldloc.1   // x&#13;
IL_001d: ldnull&#13;
IL_001e: ceq</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is a constant value pushed onto the evaluation stack by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ldnull</samp> instruction; <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> doesn’t have a type of its own but can be implicitly converted to <i>any</i> reference type. When we assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to a reference variable or pass it as an argument to a method, it’s converted automatically to the type of the target variable. Here we can compare <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> because the <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is compatible with the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> reference type.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Comparing Array Variables</samp></h4>
<p class="TNI">C# arrays are always reference types, so comparing array variables works the same way as comparing references. C# arrays are the built-in syntax for declaring and using a sequence of elements that are always allocated on the heap. An array variable is a reference to the elements of the array. In <a href="#list5-8">Listing 5-8</a>, we create two arrays with identical elements and use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare them.</p>
<pre id="list5-8"><code>int[] x = {10, 20};&#13;
int[] y = {10, 20};&#13;
Assert.That(x == y, Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: Implicitly initializing and comparing two arrays</samp></p>
<p class="TX">The compiler deduces the size of each array based on the values we use to initialize them. The two arrays have identical elements but compare unequal because comparing two arrays with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> performs a reference comparison using the intrinsic <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction. The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables in <a href="#list5-8">Listing 5-8</a> are references to different arrays and thus don’t compare equal, so the test passes.</p>
<p class="TX">When we compare two array variables, the comparison doesn’t consider the array elements; it uses only the identity of the two array variables, so two array references compare equal only if they refer to the <i>same</i> array instance. To check whether two arrays have the same elements, we must manually <span aria-label=" Page 148. " epub:type="pagebreak" id="pg_148" role="doc-pagebreak"/>compare each individual element or use a library facility such as <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enumerable.SequenceEqual</samp>.</p>
</section>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H2" id="sec11"><span id="h-110"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Strings and Value Equality</samp></h3>
<p class="TNI">Although <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> variables are references, when we compare them we’re usually more concerned with whether their contents are the same rather than whether they refer to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instance.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class overloads the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> to give strings value-like semantics. Comparing strings with either <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> performs a value-based rather than reference-based comparison. It’s possible to have more than one reference to a single <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instance on the heap, and those references will still compare equal. However, it’s also possible to have two independent <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instances that have the same content, and those instances also compare equal.</p>
<p class="TX">For example, in <a href="#list5-9">Listing 5-9</a>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables don’t refer to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instance but do have the same <i>value</i> at run time.</p>
<pre id="list5-9"><code>var monarch = "Henry";&#13;
var number = "IV";&#13;
var x = $"{monarch} the {number}";&#13;
var y = $"{monarch} the {number}";&#13;
Assert.That(x == y, Is.True);&#13;
Assert.That(x.Equals(y), Is.True);&#13;
Assert.That(ReferenceEquals(x, y), Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Comparing string values</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class customizes the behavior of both <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables compare equal because they both have the same content, although they’re references to distinct instances. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> overrides the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> method here to perform a reference comparison. <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> is a static method defined on <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> and performs an identity comparison between any two reference type variables. In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> because its arguments are references to different objects on the heap.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables in <a href="#list5-9">Listing 5-9</a> both use string interpolation to insert the values of named variables within the string, ensuring that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> really are distinct instances—at least in debug mode. If we use two simple string literals, as we do in <a href="#list5-10">Listing 5-10</a>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> gives us a different result.</p>
<pre id="list5-10"><code>var x = "Henry the IV";&#13;
var y = "Henry the IV";&#13;
Assert.That(ReferenceEquals(x, y), Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Comparing string literal values</samp></p>
<p class="TX"><span aria-label=" Page 149. " epub:type="pagebreak" id="pg_149" role="doc-pagebreak"/>This test shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> really are the same instance in memory, even though they were independently assigned to two apparently separate strings. The reason for the different behavior is that the compiler conserves memory by using <i>string interning</i>, whereby it maintains an <i>intern pool</i> containing a single instance of each unique string literal used in a program. This way, even if the same string literal appears more than once in the code, only one instance is in memory. Strings are immutable, so having multiple references to one instance can never cause aliasing issues.</p>
<p class="TX">We can use the intern pool ourselves at run time, although we have other memory considerations to take into account. We might save memory on individual string values, but the intern pool itself isn’t routinely garbage collected and will most likely stay in memory until the program terminates.</p>
<p class="TX">We can determine whether two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> variables refer to separate instances with <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> or another method, but it rarely matters. Whether two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> variables are references to one <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> instance or two separate instances with the same contents, they still compare equal.</p>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h2 class="H1" id="sec12"><span id="h-111"/><samp class="SANS_Futura_Std_Bold_B_11">Custom Equality for Classes</samp></h2>
<p class="TNI">If we want value-based rather than reference-based equality for our own class types, we override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method and define <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> for the class to customize the behavior of equality comparisons. There are several aspects to a complete implementation of equality comparisons in a class, so we’ll build it up in stages and implement each part in turn so you can better understand how all the components fit together.</p>
<p class="TX">Our first task is to customize the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method for the class. The <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class in <a href="#list5-11">Listing 5-11</a> has two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> properties, and we define <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> so that two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> compare equal if the values for both fields compare equal.</p>
<pre id="list5-11"><code>public sealed class MusicTrack&#13;
{&#13;
    public MusicTrack(string artist, string name)&#13;
        =&gt; (Artist, Name) = (artist, name);&#13;
    public string Artist {get;}&#13;
    public string Name {get;}&#13;
    <b>public override bool Equals(object? obj)</b>&#13;
        <b>=&gt;</b> <b>obj is MusicTrack other &amp;&amp;</b>&#13;
            <b>this.Artist</b> <b>==</b> <b>other.Artist &amp;&amp;</b>&#13;
            <b>this.Name</b> <b>==</b> <b>other.Name;</b>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-11: Overriding the Equals method</samp></p>
<p class="TX">Because we’re customizing the implementation of an inherited virtual method, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">override</samp> keyword, and the method’s signature must match the signature of the base class method being overridden. Note <span aria-label=" Page 150. " epub:type="pagebreak" id="pg_150" role="doc-pagebreak"/>that compiling this code will issue a warning that we haven’t overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>. We’ll address that shortly.</p>
<p class="TX">The virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method takes a single nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference, which we need to cast to our implementing type in order to compare it with the current instance. Here we use a <i>declaration pattern</i> to declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> variable if the <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> parameter is non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> and there’s an identity conversion or implicit reference conversion from the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>. An <i>identity conversion</i> simply means a type can be converted to itself. An <i>implicit reference conversion</i> can take several forms, but for simplicity here it means that <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> is a base type of the run-time type of <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>. In this example, since <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> is a sealed class, the type will match exactly (an identity conversion) or not match at all.</p>
<p class="TX">If the <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> variable’s type matches the pattern, <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> is cast to the specified type and assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> variable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> variable is therefore a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> reference, and we use it to compare its properties with those of the current instance to see if they’re equal.</p>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H2" id="sec13"><span id="h-112"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Equality Operators</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is seldom used directly, because most programmers find using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> more natural than calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. It’s generally desirable that <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> have identical behavior, and we achieve that most simply by implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method we’ve already defined.</p>
<p class="TX">Operator definitions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> are static methods. The <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> definition takes two parameters, at least one of which must be of the type implementing the operator. The return type is most often <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>, although that’s not a strict requirement. The usual implementation has both parameters of the same type, allowing us to use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare two instances, as shown in <a href="#list5-12">Listing 5-12</a>.</p>
<pre id="list5-12"><code>public static bool operator==(MusicTrack? left, MusicTrack? right)&#13;
{&#13;
    if(left is null)&#13;
    {&#13;
        return right is null;&#13;
    }&#13;
    else&#13;
    {&#13;
        return left.Equals(right);&#13;
    }&#13;
}&#13;
public static bool operator!=(MusicTrack? left, MusicTrack? right)&#13;
    =&gt; !(left == right);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-12: Defining operator</samp><span class="TheSansMonoCd_W5Regular_11">==</span> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for the MusicTrack class</samp></p>
<p class="TX">If we provide <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, we must also implement a matching <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, which we do simply by inverting the result of calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator method.</p>
<p class="TX"><span aria-label=" Page 151. " epub:type="pagebreak" id="pg_151" role="doc-pagebreak"/>Since <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> is a class, either or both of the arguments to the operators could be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, so we make that expectation explicit by using the nullable reference syntax for the parameters. If both arguments are <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, they compare equal. If <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> is non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, passing <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> as the argument even where <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> is a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference. Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> already handles <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> being passed to its parameter.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H2" id="sec14"><span id="h-113"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Comparisons with null</samp></h3>
<p class="TNI">In <a href="#list5-12">Listing 5-12</a>, we used the constant pattern and the <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp> keyword to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> parameters with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. If we compared them with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> instead, <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> would call itself recursively because <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is implicitly converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> in those comparisons. Applying the constant pattern here avoids that pitfall because the <samp class="SANS_TheSansMonoCd_W5Regular_11">is null</samp> expression never calls a user-defined <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> implementation. The compiler translates all such comparisons to use the intrinsic <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction.</p>
<p class="TX">Since the contents of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> blocks are simple expressions, we make the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> more compact in <a href="#list5-13">Listing 5-13</a> by using the ternary operator, which has the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">result if true</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">result if false</samp>.</p>
<pre id="list5-13"><code>public static bool operator==(MusicTrack? left, MusicTrack? right)&#13;
{&#13;
    return left is null ? right is null : left.Equals(right);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: A more compact implementation of operator</samp><span class="TheSansMonoCd_W5Regular_11">==</span></p>
<p class="TX">We can further simplify the code for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> by employing the null-conditional operator <samp class="SANS_TheSansMonoCd_W5Regular_11">?.</samp>, which invokes an instance method only if the variable used to make the call is non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. In the expression <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp>, if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, the result of the whole expression is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>; otherwise, the result is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</samp>. Using the null-conditional operator to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> makes the implementation much more compact, especially if we also make the operator an expression-bodied method, like so:</p>
<pre><code>public static bool operator==(MusicTrack? left, MusicTrack? right)&#13;
    =&gt; left?.Equals(right) ?? right is null;</code></pre>
<p class="TX">Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is called only if the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> parameter is not <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, since we’ve used the null-conditional operator on the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> variable. We combine the null-conditional operator with the null-coalescing operator <samp class="SANS_TheSansMonoCd_W5Regular_11">??</samp>, which evaluates its right-hand expression only if the whole left expression is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> are equal if <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> is also <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> constant pattern, the null-conditional operator, and the null-coalescing operator are all different ways of testing whether a reference is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> without invoking an <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method or ever calling a user-defined <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> implementation. While we can customize both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <span aria-label=" Page 152. " epub:type="pagebreak" id="pg_152" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, we can’t change the behavior of comparisons made with the <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp> keyword or the null-conditional and null-coalescing operators.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h3 class="H2" id="sec15"><span id="h-114"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Type-Safe Comparisons</samp></h3>
<p class="TNI">When we compare values for equality, we’re most commonly comparing two values of the same type, which is why the usual implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> has two matching parameters. Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, however, takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter, which must be cast back to <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> so we can compare its individual property values. We can avoid this cast by writing an overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> parameter, shown in <a href="#list5-14">Listing 5-14</a>.</p>
<pre id="list5-14"><code>public bool <b>Equals(MusicTrack? other)</b>&#13;
    =&gt; other is not null &amp;&amp;&#13;
        this.Artist == other.Artist &amp;&amp;&#13;
        this.Name == other.Name;</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-14: A type-safe Equals method</samp></p>
<p class="TX">We still need to compare the argument with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, and, as we did for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, we use the constant pattern to make that comparison as efficient as possible. To avoid duplicating the code for comparing the property values, we alter the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> method to call the type-safe overload like this:</p>
<pre><code>public override bool Equals(object? obj)&#13;
    =&gt; Equals(obj as MusicTrack);</code></pre>
<p class="TX">Although we’re employing a run-time cast using the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> keyword, <a href="#list5-14">Listing 5-14</a>’s overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack?</samp> parameter is much more likely to be called than this overridden method with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter. In particular, our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> will always call the type-specific overload because the parameters to the operator are both <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> variables.</p>
<p class="TX">Since we’ve overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class, the compiler will warn us that we should override <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> too.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="H2" id="sec16"><span id="h-115"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with Hash Codes</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods are closely associated. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> is defined on <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> and is virtual. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method is used by collection types like <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> to efficiently store and look up keys. Essentially, a data structure such as a hash table uses an object’s <i>hash code</i> to identify its location within the data structure. When we add a new key or try to locate an existing one, the lookup algorithm quickly identifies the correct place in the table by using a hash code.</p>
<p class="TX">However, a particular hash code in the table may identify several different keys, because although the items in a hash table are usually unique, hash codes don’t have to be. When we add a new item to a hash table and <span aria-label=" Page 153. " epub:type="pagebreak" id="pg_153" role="doc-pagebreak"/>the item’s hash code already exists in the table—a scenario known as a <i>collision</i>—the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is used on each key with a matching hash code to verify whether the table already contains the new item. This is why <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> are so closely related.</p>
<p class="TX">A key can be any object, as long as these two rules are followed:</p>
<ul class="BL">
<li class="BL">Objects that are equal according to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> have the same hash code.</li>
<li class="BL">The hash code for an object being used as a key doesn’t change.</li>
</ul>
<p class="TX">Ideally, each unique hash code will identify a single key—meaning we avoid the need to compare several objects via <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>—and so searching for a key is much faster. When we search for a key in the table, if the hash code is matched by only a single key, it <i>must</i> be the required key as long as the two rules have been followed. Ensuring that hash codes are widely distributed is recommended to increase the likelihood that each hash code uniquely identifies one key.</p>
<p class="TX">For class types, the default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> uses an object’s identity rather than its value to create a hash code, just as the default implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> compares object identities, not their state. If two references are equal, they must also have the same hash value, because they refer to the same <i>instance</i>. The default hash code for an instance also never changes. However, if we accept the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> for classes, we must take extra care when using class types as keys.</p>
<p class="TX">We can safely use any class type that doesn’t override the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method as a key, but when we search for an object in a hashing collection like a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, we must make sure to use the exact same instance of the object that was originally inserted. If we try to look up an item with a different instance, the item won’t be found. To demonstrate, consider <a href="#list5-15">Listing 5-15</a>, where we use a new object instance to find a key in a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>.</p>
<pre id="list5-15"><code>public sealed class Character&#13;
{&#13;
    public Character(string name)&#13;
            =&gt; Name = name;&#13;
    public string Name {get;}&#13;
}&#13;
var cast = new HashSet&lt;Character&gt;&#13;
    {&#13;
        new Character("MacReady")&#13;
    };&#13;
<b>var key</b> <b>=</b> <b>new Character("MacReady");</b>&#13;
<b>Assert.That(cast.Contains(key), Is.True);</b></code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-15: Using a Character class identity as a key</samp></p>
<p class="TX"><span aria-label=" Page 154. " epub:type="pagebreak" id="pg_154" role="doc-pagebreak"/>The test in this example fails because we’re searching for a different instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Character</samp> class than was added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Character</samp> doesn’t override the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method, the instance being looked up has a different hash code than the item contained in the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, even though both instances have the same state.</p>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a Suitable Key</samp></h4>
<p class="TNI">Failing to find a key in a collection has important consequences. Elements in a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> and keys in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> should be <i>unique</i>. When we attempt to insert a new key, it should be added only if it isn’t already in the collection. However, if the key exists but can’t be found, we’ll get a <i>duplicated</i> key. The new object will be erroneously added to the table, effectively corrupting the collection.</p>
<p class="TX">Needing to rely on using a single object instance to both insert and search for any particular key in a hashing collection is usually overly restrictive. If, for example, the collection is populated from a file or user input, the original instances frequently aren’t immediately at hand when we come to search for a specific item. It’s much more convenient for objects used as keys to generate their hash codes according to their state, not their identity. That way, we can use any key with the same state to identify an object in the table.</p>
<p class="TX">As things stand, the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class we defined in <a href="#list5-11">Listing 5-11</a> isn’t suitable as a key for a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> because it breaks the first of the two cardinal rules—that equal objects produce identical hash codes—because we’ve customized equality to compare the objects’ state. To make <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> behave correctly, we must also override <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> and ensure that two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> that compare equal according to our customized <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method produce identical hash codes. To do that, we’ll generate a hash code using the same properties that determine whether two instances are equal. <a href="#list5-16">Listing 5-16</a> shows one way to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class.</p>
<pre id="list5-16"><code>public override int GetHashCode()&#13;
    =&gt; HashCode.Combine(Artist, Name);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-16: Overriding GetHashCode</samp></p>
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashCode</samp> static class from the Standard Library, which combines multiple arguments to create reasonably well-distributed hash codes. Our implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> uses the same properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method in <a href="#list5-14">Listing 5-14</a>, so two objects that compare equal will always generate identical hash codes.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Floating-Point Numbers as Keys</samp></h4>
<p class="TNI">Using a floating-point number as the key in a hash table can result in keys being lost, in much the same way as relying on the default <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> for class types. As you saw earlier, comparing <span aria-label=" Page 155. " epub:type="pagebreak" id="pg_155" role="doc-pagebreak"/>floating-point numbers for strict equality isn’t reliable. In <a href="#list5-17">Listing 5-17</a>, we try to identify whether the collection has a specific <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> value.</p>
<pre id="list5-17"><code>var history = new HashSet&lt;double&gt;();&#13;
var rate = 0.1 + 0.2;&#13;
<b>history.Add(rate);</b>&#13;
Assert.That(history.Contains(0.3));</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-17: Using floating-point numbers as keys</samp></p>
<p class="TX">This test fails because the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0.3</samp> doesn’t exactly match the representation of <samp class="SANS_TheSansMonoCd_W5Regular_11">0.1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0.2</samp>. Because calculations using <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values are imprecise, they’re generally a bad choice as keys in a hashed collection. By extension, the same reasoning applies to user-defined types that have floating-point field values; comparing objects of such a type for equality necessarily means comparing any floating-point fields, with the same potential for errors.</p>
<p class="TX">In a type with floating-point fields, we might be tempted to override its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method by using an approach similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp> implementations from <a href="#list5-3">Listings 5-3</a> and <a href="#list5-4">5-4</a>, but doing so would introduce two problems. First, equality is a transitive relationship between values: for three values <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> must be equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>. Implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> to mean <i>approximately</i> equal means the transitive relationship wouldn’t necessarily hold, because the difference between <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> could be larger than any tolerance we define, even when <samp class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y.Equals(z)</samp> are both <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.</p>
<p class="TX">The second issue is directly related to hash codes. Recall that objects that compare equal should have the same hash code. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">ApproximatelyEqual</samp> to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> could easily break that rule, because two <i>almost</i> equal values will still produce different hash codes. We could implement <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> to ignore any floating-point fields, but doing so would compromise how well our objects’ hash codes are distributed. It also raises the question of what to do about types that have only a single field that’s a floating-point value, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types we developed in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>.</p>
<p class="TX">Floating-point numbers and types containing floating-point values, then, don’t make good keys for hash tables, dictionaries, and other data structures that depend on the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>. Unfortunately, C# doesn’t allow us to prevent a particular type from being used as a key in a hash table or similar data structure, because <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> is defined on <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> and can’t be hidden. It’s up to us to make sure that the keys we use are suitable for that purpose.</p>
<p class="TX">Strings make excellent keys for hash tables, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> to compare the string contents. This is the same behavior the compiler adds for us in record and record struct types. Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> are synthesized by the compiler, so record and record struct instances use their <i>value</i> for equality comparisons and for generating their hash codes. Although records are reference types, like strings they work very well as keys, subject to the caveats we’ve just discussed regarding floating-point fields.</p>
<p class="TX"><span aria-label=" Page 156. " epub:type="pagebreak" id="pg_156" role="doc-pagebreak"/>The compiler also generates <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> and its companion <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> for records and record structs. They follow the same general pattern we’ve used for <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> returns the inverse of the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>. The compiler does <i>not</i> generate any of these methods for ordinary structs, which instead rely on the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> base class common to all struct types.</p>
</section>
</section>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h2 class="H1" id="sec19"><span id="h-116"/><samp class="SANS_Futura_Std_Bold_B_11">Structs and Equality</samp></h2>
<p class="TNI">Since value type instances are copied by value, every value type variable is a distinct instance of the type, so two instances can never compare equal according to their identity. We need to compare their values, meaning that we compare their state instead. This usually involves comparing each field of one instance with the corresponding field of another.</p>
<p class="TX">Structs implicitly inherit from the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp> class, which provides the value-based equality required for value types. By default, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> on a struct will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation, because <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is a virtual method. As <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> explained, for its implementation, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> method relies on reflection, which provides the correct behavior for any possible struct type at the expense of performance. While it might not be the most efficient comparison, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> method uses each field’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method to compare the field with its companion, so it has the behavior we require. Similarly, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> also overrides <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> to create hash codes based on a struct’s fields, ensuring that any two struct instances that are equal according to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> also generate identical hash codes.</p>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="H2" id="sec20"><span id="h-117"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overriding Equals for Structs</samp></h3>
<p class="TNI">Overriding the default <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods for struct types is common in order to address that the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementations of those methods may not be optimal. Implementing efficient equality for structs follows a similar pattern as for classes, as shown in <a href="#list5-18">Listing 5-18</a>, where we create a struct to represent color values.</p>
<pre id="list5-18"><code>public readonly struct Color&#13;
{&#13;
    public Color(int r, int g, int b)&#13;
        =&gt; (Red, Green, Blue) = (r, g, b);&#13;
    public int Red {get;}&#13;
    public int Green {get;}&#13;
    public int Blue {get;}&#13;
    public bool Equals(Color other)&#13;
        =&gt; Red == other.Red &amp;&amp;&#13;
           Green == other.Green &amp;&amp;&#13;
           Blue == other.Blue;&#13;
<span aria-label=" Page 157. " epub:type="pagebreak" id="pg_157" role="doc-pagebreak"/>&#13;
    public override bool Equals(object? obj)&#13;
        =&gt; obj is Color color &amp;&amp; Equals(color);&#13;
    public override int GetHashCode()&#13;
        =&gt; HashCode.Combine(Red, Green, Blue);&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-18: Overriding equality for a Color struct</samp></p>
<p class="TX">As we did with <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> in the previous section, we override the base class <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method and add a type-specific overload taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter. There are subtle differences, related to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, from the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> implementations of those methods. As a struct type, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances can’t be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, so the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method takes its <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameters by value rather than nullable references, and we don’t check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> in the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color)</samp>.</p>
<p class="TX">In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> override, we use a declaration pattern to cast the <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> variable to the correct type. We used a declaration pattern in <a href="#list5-11">Listing 5-11</a> for <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> but later switched it for the simpler <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> run-time cast. We can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> in our struct implementation because if the cast fails, the result is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, which can’t be assigned to a struct variable. As noted in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, we <i>can</i> use <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> to cast to a nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, but in that case the argument would match the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter instead of our type-safe overload, making the method recursive. Applying the declaration pattern here avoids that issue.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> implementation is identical in principle to the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> implementation from <a href="#list5-16">Listing 5-16</a>.</p>
<p class="TX">Struct types don’t allow comparison with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> by default. If we want to support such comparisons, we must define our own <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> for the type. The equality operator is straightforward to implement in terms of our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, as shown here:</p>
<pre><code>public static bool operator==(Color left, Color right)&#13;
    =&gt; left.Equals(right);&#13;
public static bool operator!=(Color left, Color right)&#13;
    =&gt; !left.Equals(right);</code></pre>
<p class="TX">While <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is a virtual instance method and is overridden by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> is a static method and therefore <i>can’t</i> be virtual. Static methods are never inherited, so these operators couldn’t usefully be implemented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> class.</p>
<p class="TX">Since a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variable can’t be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, we can simply use the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> variable to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, passing <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> as the argument to invoke our type-safe implementation that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter by value. The equality operators are therefore simpler than their equivalents for a class, and, more significantly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp> variables won’t be boxed when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. Notice that rather than inverting the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, we invert the result of calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. The effect is identical in both cases, but this version of <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> avoids the extra <span aria-label=" Page 158. " epub:type="pagebreak" id="pg_158" role="doc-pagebreak"/>indirection of also calling <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> and the additional copies of the arguments it would involve.</p>
<p class="TX">Another reason a default implementation for structs provided by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> would be useless is that, as discussed earlier, an operator overload requires the type of at least one of its parameters to match the implementing type. We can’t, for instance, define our own <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> to compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables because that would hijack the default behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables. Comparing two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <i>always</i> compares identities, since those variables are references. This has important consequences when an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variable refers to an instance of a value type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that’s been boxed.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h3 class="H2" id="sec21"><span id="h-118"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Boxing Values and Comparing by Identity</samp></h3>
<p class="TNI">Values are implicitly boxed anytime we use a reference type variable to refer to a value type instance. Because value types have value-based equality and reference type variables have reference-based equality, boxing has implications for object identity and equality. We went to some effort to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> have identical behavior when comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances, but when we compare <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values that have been boxed, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> behave differently.</p>
<p class="TX">To illustrate how boxing affects equality, <a href="#list5-19">Listing 5-19</a> creates two instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct, but instead of having the compiler deduce the variable types as <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, we explicitly declare them as <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, causing the values to be boxed. The variables aren’t equal when we use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare them.</p>
<pre id="list5-19"><code>object x = new Color(0xFF, 0xA0, 0);&#13;
object y = new Color(0xFF, 0xA0, 0);&#13;
Assert.That(x == y, Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-19: Explicitly boxing values</samp></p>
<p class="TX">This test passes because reference variables are compared by their identity. These <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables are references to different boxed <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values on the heap, approximately as shown in <a href="#fig5-1">Figure 5-1</a>.</p>
<figure class="IMG"><img alt="" class="img90" height="222" id="fig5-1" src="../images/Figure5-1.png" width="584"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: Boxed values in memory</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 159. " epub:type="pagebreak" id="pg_159" role="doc-pagebreak"/>The boxes for the two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances in <a href="#fig5-1">Figure 5-1</a> could be anywhere on the heap; the way that memory is allocated is determined by the CLR. When we use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables, the instance values aren’t considered. Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> has an overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> to allow comparisons using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> between two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values, that custom equality implementation isn’t invoked when we compare the two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> references. This is because <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> is a <i>static</i> method that requires two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> arguments, not two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> arguments. The comparison with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> therefore correctly returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, because the two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables refer to independent instances.</p>
<p class="TX">If we make the comparison using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method instead, the variables compare equal because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is virtual:</p>
<pre><code>Assert.That(x.Equals(y), Is.True);</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> variable used to invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference but still refers to an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, so here it’s our override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> that’s called. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> didn’t override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation would be called instead. In either case, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> because the two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> have exactly the same state.</p>
<p class="TX">We can think of a boxed value as an instance of a simple reference type on the heap that contains a copy of the value in a field with the same type as the original value. Since the box is on the heap, it can be referenced by more than one reference variable, as shown in <a href="#list5-20">Listing 5-20</a>.</p>
<pre id="list5-20"><code>var color = new Color(0xFF, 0xA0, 0);&#13;
object x = color;&#13;
object y = x;&#13;
Assert.That(x == y, Is.True);&#13;
Assert.That(x.Equals(y), Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-20: Two references to one boxed value</samp></p>
<p class="TX">In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a reference to a boxed value, and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is a different reference to the <i>same box</i>, illustrated in <a href="#fig5-2">Figure 5-2</a>.</p>
<figure class="IMG"><img alt="" class="img100" height="165" id="fig5-2" src="../images/Figure5-2.png" width="658"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: Adding a reference to an existing box</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 160. " epub:type="pagebreak" id="pg_160" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables compare equal with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> because both <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are references to a single instance. The comparison with the virtual call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> also returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> because an instance will always compare equal with itself.</p>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Boxed Method Parameters</samp></h4>
<p class="TNI">A value will be automatically boxed when we pass it to a method that takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> or other reference type parameter. The effects are the same as assigning directly to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variable, as we did in <a href="#list5-19">Listing 5-19</a>, but the box is less obvious in our code.</p>
<p class="TX">Consider <a href="#list5-21">Listing 5-21</a>, where we pass the same value twice to the <samp class="SANS_TheSansMonoCd_W5Regular_11">object.ReferenceEquals</samp> method, which takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameters and compares them for identity equality.</p>
<pre id="list5-21"><code>Color x = new Color();&#13;
Assert.That(object.ReferenceEquals(x, x), Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-21: Passing values as boxed arguments</samp></p>
<p class="TX">This test asserts that the two arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> are <i>not</i> equal. Should the test pass?</p>
<p class="TX">Yes, it should. The arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> are different <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables. Passing a value type as an argument to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter boxes the value. Even though the same value is passed to both parameters, each argument is boxed separately, resulting in two independent boxes. The outcome is identical to explicitly boxing the same value into separate <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables, like this:</p>
<pre><code>object a = x;&#13;
object b = x;&#13;
Assert.That(object.ReferenceEquals(a, b), Is.False);</code></pre>
<p class="TX">The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is explicitly boxed into two separate <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> references. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, and they do <i>not</i> compare equal because they’re different objects.</p>
<p class="TX">Compare <a href="#list5-21">Listing 5-21</a> with the following, where we explicitly box the value to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variable <i>before</i> calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>:</p>
<pre><code>object x = new Color();&#13;
Assert.That(object.ReferenceEquals(x, x), Is.True);</code></pre>
<p class="TX">We pass the same reference for both arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp>, so they compare equal. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> in this instance is identical to the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> variable is a reference to a boxed <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, as shown in <a href="#fig5-3">Figure 5-3</a>.</p><span aria-label=" Page 161. " epub:type="pagebreak" id="pg_161" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img50" height="165" id="fig5-3" src="../images/Figure5-3.png" width="320"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: Passing an already-boxed value to a method</samp></p></figcaption>
</figure>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals</samp> method receives two arguments, but they’re references to the same boxed value on the heap.</p>
<p class="TX">Quite apart from testing variables for equality, we need to be sure we understand where values are being boxed and whether our own code is using a boxed value. Boxing affects what <i>identity</i> means for a value—and while this is most apparent when we’re comparing two values, it also has wider implications, such as whether we need to be concerned about aliasing or side effects.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="H3" id="sec23"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Interface Boxes</samp></h4>
<p class="TNI">We can refer to an object via any of the interfaces implemented by the type. To demonstrate, in <a href="#list5-22">Listing 5-22</a> the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> value type implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IFormattable</samp>, one of the common system interfaces provided by the Standard Library. In this code snippet, we use the interface name to refer to two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>.</p>
<pre id="list5-22"><code>public readonly struct Angle : IFormattable&#13;
{&#13;
    <var>--snip--</var>&#13;
}&#13;
IFormattable x = new Angle();&#13;
IFormattable y = new Angle();&#13;
Assert.That(x == y, Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-22: Referring to a value via interface name</samp></p>
<p class="TX">An <i>interface type</i> is a reference type that defines the public operations guaranteed to be available for a type that implements it. Variables of interface type are always references, regardless of the implementing type. Referring to value type instances via interface variables must therefore box the value, with the result that the comparison in <a href="#list5-22">Listing 5-22</a> is effectively the same as when the values were boxed into <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> variables in <a href="#list5-19">Listing 5-19</a>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> expression in this example, then, performs a reference check for equality that will compare object identities. The values returned from each of the <samp class="SANS_TheSansMonoCd_W5Regular_11">new Angle</samp> expressions will be boxed so that the references <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> can refer to them, and each will refer to different boxes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <span aria-label=" Page 162. " epub:type="pagebreak" id="pg_162" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables will compare equal if we use <samp class="SANS_TheSansMonoCd_W5Regular_11">x.Equals(y)</samp>, owing to the virtual nature of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.</p>
</section>
</section>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h2 class="H1" id="sec24"><span id="h-119"/><samp class="SANS_Futura_Std_Bold_B_11">Comparing Generic Variables</samp></h2>
<p class="TNI">We use a generic type or method to implement functionality that works for a range of other types, often for both reference types and value types transparently. In the context of a generic type or a generic method, a given variable might represent either a value or a reference at different times during a program’s execution.</p>
<p class="TX">This poses an issue for equality comparisons of generic variables; in particular, using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare variables typed by a generic parameter will never invoke a user-defined <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> implementation. If a generic parameter is unconstrained, we can’t even use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare two variables of the same generic type.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>C# v11.0 introduces a preview feature named</i> <span class="Roman">static abstract interface members</span> <i>that enables you to use user-defined operators, including operator</i><samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp><i>, in generic code. For more information on this feature, see</i> <a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members"><span class="LinkURL_R">https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members</span><i>.</i></a></p>
<p class="TX">Consider the simple generic class in <a href="#list5-23">Listing 5-23</a>, which uses <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare two variables declared using the generic type parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>. As it stands, this class won’t compile.</p>
<pre id="list5-23"><code>public class Playlist&lt;T&gt;&#13;
{&#13;
    public void PlayNow(T item)&#13;
    {&#13;
        <b>if(item</b> <b>==</b> <b>current)</b>&#13;
        {&#13;
           <var>--snip--</var>&#13;
        }&#13;
    }&#13;
    private T current;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-23: Generic type parameter comparison</samp></p>
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> is a generic class with a type parameter that by convention is named <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>. We’d generally refer to this class as a <i>Playlist of T</i>.</p>
<p class="TX">We can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp> parameter with the field <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> because when <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is an unconstrained type parameter like this, the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> operators can be used only to check instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> for equality or inequality with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<p class="TX">If we add a general class constraint, or a specific base class or interface type constraint for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, the comparison <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> will compile, but it will always represent a reference comparison. C# has no generic constraint we <span aria-label=" Page 163. " epub:type="pagebreak" id="pg_163" role="doc-pagebreak"/>can add for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> to allow the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> to invoke an overloaded <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is typed by a generic parameter.</p>
<p class="TX">We <i>can</i> invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, which will call an overridden implementation if one exists on whatever type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> represents at run time. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is defined on the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base class and so is available to any variable, regardless of its actual type. However, when the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a value type, the argument may be boxed by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method that takes <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> as its parameter.</p>
<section aria-labelledby="sec25" epub:type="division">
<h3 class="H2" id="sec25"><span id="h-120"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Code and the Equals Method</samp></h3>
<p class="TNI">In <a href="#list5-11">Listing 5-11</a>, we implemented equality for our <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> type so that instances of them compare by value rather than by identity. In <a href="#list5-18">Listing 5-18</a>, we did the same for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct to override the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp> method. To make the comparison more efficient, we added a type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for both types by taking the parameter as <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, respectively, rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, thereby preventing the argument from being boxed.</p>
<p class="TX">In the current implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, however, their type-safe overloads of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> won’t be used if called using a generic type parameter variable. When <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is called using a generic variable, the virtual method with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter is called by default. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> class, that merely results in an extra run-time cast, but for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct, the parameter will be boxed to <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> and then unboxed again to compare <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s properties.</p>
<p class="TX">To demonstrate, <a href="#list5-24">Listing 5-24</a> uses <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as a type argument for the generic <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> collection type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet&lt; T &gt;.Contains</samp> method uses a combination of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> to determine whether any item in the collection matches the <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp> argument.</p>
<pre id="list5-24"><code>var colors = new HashSet&lt;Color&gt;();&#13;
var orange = new Color(0xFF, 0xA0, 0);&#13;
colors.Add(orange);&#13;
Assert.That(<b>colors.Contains(orange)</b>, Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-24: Searching a collection of Color values</samp></p>
<p class="TX">The test passes, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> method will be used, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet.Contains</samp> implementation has no way of knowing that <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> implements a type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter directly. This matters for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> because it’s a struct, and so every comparison will box the argument to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> contains a large number of elements, that boxing could well represent many unnecessary copies of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.</p>
<p class="TX">The same would be true of a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> containing <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> elements, and although the impact is a little less costly, it’s still an unnecessary inefficiency.</p>
<p class="TX"><span aria-label=" Page 164. " epub:type="pagebreak" id="pg_164" role="doc-pagebreak"/>To have generic code prefer our type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> over the more general implementation inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, our types must implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h3 class="H2" id="sec26"><span id="h-121"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The IEquatable&lt;T&gt; Interface</samp></h3>
<p class="TNI">When we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface on any class or struct, we’re signaling to generic code that the type has a public type-safe implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface specifies that the type represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> contains an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> as its parameter. Generic code such as <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet&lt; T &gt;</samp> can detect that a generic type implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> and will use the type-specific overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> if it’s available. <a href="#list5-25">Listing 5-25</a> shows how our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct would implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface.</p>
<pre id="list5-25"><code>public readonly struct Color <b>: IEquatable&lt;Color&gt;</b>&#13;
{&#13;
    <var>--snip--</var>&#13;
    public bool Equals(Color other)&#13;
        =&gt; other.Red == Red &amp;&amp;&#13;
           other.Green == Green &amp;&amp;&#13;
           other.Blue == Blue;&#13;
    <var>--snip--</var>&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-25: The IEquatable</samp><span class="TheSansMonoCd_W5Regular_11">&lt;</span> <span class="TheSansMonoCd_W5Regular_Italic_I_11">T</span> <span class="TheSansMonoCd_W5Regular_11">&gt;</span> <samp class="SANS_Futura_Std_Book_Oblique_I_11">interface</samp></p>
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method is identical to the original type-safe method from <a href="#list5-18">Listing 5-18</a>; the difference is that <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> indicates the presence of that overload by explicitly implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; Color&gt;</samp>. Now when we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as the element type for a <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> or other generic collection, any comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> will use our type-safe implementation and avoid the need to box the argument.</p>
<p class="TX">This works because generic collections like <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp> don’t invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> directly; instead, they defer the comparison to a helper class named <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer&lt; T &gt;</samp>, which internally selects a type-specific <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface. If <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> doesn’t implement the interface, the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> is used instead.</p>
<p class="TX">We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp> class in our own generic code to automatically select the best available implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method for a generic parameter type variable. <a href="#list5-26">Listing 5-26</a> shows the usual pattern for checking equality via an <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp> object.</p>
<pre id="list5-26"><code>public void PlayNow(T item)&#13;
{&#13;
    var comparer = EqualityComparer&lt;T&gt;.Default;&#13;
    if(!comparer.Equals(Current, item))&#13;
        Current = item;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-26: Equality using the EqualityComparer</samp><span class="TheSansMonoCd_W5Regular_11">&lt;</span> <span class="TheSansMonoCd_W5Regular_Italic_I_11">T</span> <span class="TheSansMonoCd_W5Regular_11">&gt;</span> <samp class="SANS_Futura_Std_Book_Oblique_I_11">class</samp></p>
<p class="TX"><span aria-label=" Page 165. " epub:type="pagebreak" id="pg_165" role="doc-pagebreak"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer&lt; T &gt;.Default</samp> static property returns an implementation of the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; T &gt;</samp> interface with the appropriate behavior for the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> type parameter. When <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Default</samp> property returns an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; T &gt;</samp> that uses the type-specific overload of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.</p>
<p class="TX">Besides <samp class="SANS_TheSansMonoCd_W5Regular_11">HashSet</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary</samp> collection and some LINQ algorithms use <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; T &gt;</samp> to define equality between elements. They can all be given a specific <samp class="SANS_TheSansMonoCd_W5Regular_11">IEqualityComparer&lt; T &gt;</samp> implementation, so we can provide our own implementation of it to customize that behavior. We’ll use this technique in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> to modify the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SequenceEqual</samp> method.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer&lt; T &gt;</samp> class is designed for generic code but can be useful when equality comparisons need to be made in the most general and efficient manner possible. One such situation is in code generated by the compiler.</p>
</section>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h2 class="H1" id="sec27"><span id="h-122"/><samp class="SANS_Futura_Std_Bold_B_11">Compiler-Generated Equality</samp></h2>
<p class="TNI">The compiler itself is capable of synthesizing a correct and complete implementation of equality for some types. The code generated by the compiler uses the same techniques we’ve been exploring. In this section, we’ll look at examples to better appreciate what the compiler is prepared to generate on our behalf, even for something as fundamental as equality comparison of variables.</p>
<section aria-labelledby="sec28" epub:type="division">
<h3 class="H2" id="sec28"><span id="h-123"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Records and Record Structs</samp></h3>
<p class="TNI">Records and record structs give us a compact way of creating a type that has value semantics built in. Records are syntactically different from both classes and structs, but in the CIL they’re just classes with some compiler-generated features, including overrides of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods. Similarly, record structs are structs in the compiled code and have most of the same compiler-provided features as records.</p>
<p class="TX">The notable exception is that the compiler implements a <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp> method for records, but not for record structs. <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp> emulates copying a record instance by value to support non-destructive mutation, which we examined in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>. Since record structs are natively copied by value, they have no need for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp> method.</p>
<p class="TX">Both records and record structs implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp>, and the compiler-generated type-specific overload of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method compares each field of the type, exactly as we did earlier in <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> method implementation uses all the fields to provide well-distributed hash codes. All this is in contrast to plain structs, where the default value-based equality behavior is provided by a common base class, <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>.</p>
<p class="TX">This simple <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type is implemented as a positional record and demonstrates admirably how compact a record definition can be:</p>
<pre><code>public sealed record Color(int Red, int Green, int Blue);</code></pre>
<p class="TX"><span aria-label=" Page 166. " epub:type="pagebreak" id="pg_166" role="doc-pagebreak"/>This positional syntax for a record causes the compiler to create three properties for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, each with the same name and type as the respective positional parameters defined for the type. The compiler also provides a public constructor with those three parameters to initialize the three property values. This positional syntax can be used for records and record structs.</p>
<section aria-labelledby="sec29" epub:type="division">
<h4 class="H3" id="sec29"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Inside Record Equality</samp></h4>
<p class="TNI">All records are classes, but they have value-based equality semantics, courtesy of the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface provided automatically by the compiler. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> methods shown in <a href="#list5-27">Listing 5-27</a> are almost—but not quite—the same as those generated for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record by the compiler.</p>
<pre id="list5-27"><code>public bool Equals(Color? other)&#13;
    =&gt; (object?)other != null &amp;&amp;&#13;
       GetType() == other.GetType() &amp;&amp;&#13;
       EqualityComparer&lt;int&gt;.Default.Equals(Red, other.Red) &amp;&amp;&#13;
       EqualityComparer&lt;int&gt;.Default.Equals(Green, other.Green) &amp;&amp;&#13;
       EqualityComparer&lt;int&gt;.Default.Equals(Blue, other.Blue);&#13;
public override bool Equals(object? obj)&#13;
    =&gt; Equals(obj as Color);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-27: Equality implementation generated for a record</samp></p>
<p class="TX">The compiler-generated type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method can <i>directly</i> access the backing fields for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> properties and thus avoids the extra method calls shown here for reading the property values. Note how the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer&lt; T &gt;</samp> class to compare each value, so if the type of any property implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp>, the type-safe implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> will be used.</p>
<p class="TX">Records can, by default, inherit from other records, so equality isn’t quite as simple as comparing each object’s fields. The <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> could in that case refer to an instance of a more derived record. Checking for equality of objects that could have different run-time types requires extra care. In most cases, objects of different types aren’t equal, which is why we use <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> on the second line of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color?)</samp> method in <a href="#list5-27">Listing 5-27</a>.</p>
<p class="TX">Our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record is sealed and doesn’t inherit from another record. Therefore, checking the type is redundant because the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> parameter can’t refer to anything other than an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.</p>
<p class="TX">Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record is sealed and has no base types, we should consider making it a record struct. Record structs compile down to struct definitions, which can’t be inherited or have <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> values, making their internals simpler. The type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method for a record struct type doesn’t check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> or whether the types match but is otherwise the same as for a record.</p>
<p class="TX"><span aria-label=" Page 167. " epub:type="pagebreak" id="pg_167" role="doc-pagebreak"/>In addition to implementations of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> methods, the compiler generates <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> and a corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> for records and record structs. The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, so record variables exhibit value-based equality when they’re compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, rather than the default identity-based comparison that classes have. We confirm this behavior for our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record in <a href="#list5-28">Listing 5-28</a>.</p>
<pre id="list5-28"><code>var red1 = new Color(0xFF, 0, 0);&#13;
var red2 = new Color(0xFF, 0, 0);&#13;
Assert.That(red1 == red2, Is.True);&#13;
Assert.That(ReferenceEquals(red1, red2), Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-28: Comparing records with</samp> <span class="TheSansMonoCd_W5Regular_11">==</span></p>
<p class="TX">Here we see that two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variables compare equal, because even though they’re definitely not two references to a single instance, the state of the instances is the same.</p>
</section>
<section aria-labelledby="sec30" epub:type="division">
<h4 class="H3" id="sec30"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Custom Implementations for Record Equality</samp></h4>
<p class="TNI">The compiler will normally generate at least two versions of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for a record or a record struct: one taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter (or <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> within a nullable context) and the other implementing the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface, which performs the comparison of each instance’s fields. The version taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter casts its argument to the required type and invokes the type-specific overload if the cast is successful, as we did for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record in <a href="#list5-27">Listing 5-27</a>. We can provide our own implementation of the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method for a record or record struct type, in which case the compiler uses our implementation instead of generating one. If we do so, we should implement our own <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp> to match, which will also replace the compiler-generated implementation.</p>
<p class="TX">However, we can’t provide our own implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> for comparing two record or record struct instances. If we attempt to do so, the compiler gives us an error:</p>
<pre><code>[CS0111] Type 'Color' already defines a member called 'op_Equality' with the same parameter&#13;
types</code></pre>
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp> is the name of the static method to which the compiler translates <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>. The name for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Inequality</samp>, and the compiler always provides both methods, preventing us from defining our own.</p>
<p class="TX">We should almost always accept the default implementation of equality for records and record structs, as the compiler-generated code is both correct and efficient. However, if we need to customize the behavior of equality for a record or record struct, we need only override the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. Each of the other equality methods, including the overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter, ultimately calls the type-specific overload to perform the actual comparison. The compiler’s implementation <span aria-label=" Page 168. " epub:type="pagebreak" id="pg_168" role="doc-pagebreak"/>of the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator is identical to that shown here for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, so if we alter the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, that behavior is also reflected in the implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> provided by the compiler:</p>
<pre><code>public static bool operator==(Color left, Color right)&#13;
{&#13;
    if((object)left == (object)right) return true;&#13;
    return (object)left != null &amp;&amp; left.Equals(right);&#13;
}&#13;
public static bool operator!=(Color left, Color right)&#13;
    =&gt; !(left == right);</code></pre>
<p class="TX">When we define a positional record or positional record struct, the compiler synthesizes a complete type, along with methods to support equality comparisons. The compiler generates code to support equality for nullable value types, too, although in a very different way.</p>
</section>
</section>
<section aria-labelledby="sec31" epub:type="division">
<h3 class="H2" id="sec31"><span id="h-124"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equality for Nullable Values</samp></h3>
<p class="TNI">We denote a nullable value type by using the special <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> notation on a value type variable. The compiler translates a nullable value type to an instance of the system type <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable&lt; T &gt;</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is the declared type for the variable. <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable&lt; T &gt;</samp> is a struct, instances of which may have a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> or no value (represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>).</p>
<p class="TX">Comparing nullable value type variables differs from comparing references, which may be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, because for two nullable value type variables, we must always compare each underlying value if one exists. To illustrate, consider <a href="#list5-29">Listing 5-29</a>, where we compare two nullable value type variables, one with a value and the other <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.</p>
<pre id="list5-29"><code>public readonly struct Color&#13;
{&#13;
    <var>--snip--</var>&#13;
    public static bool operator==(Color left, Color right)&#13;
        =&gt; left.Equals(right);&#13;
    public static bool operator!=(Color left, Color right)&#13;
        =&gt; !left.Equals(right);&#13;
}&#13;
Color? fg = new Color(0xFF, 0xA0, 0);&#13;
Color? bg = null;&#13;
Assert.That(fg == bg, Is.False);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-29: Comparing nullable values</samp></p>
<p class="TX">Both <samp class="SANS_TheSansMonoCd_W5Regular_11">fg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">bg</samp> in this example are nullable, but while <samp class="SANS_TheSansMonoCd_W5Regular_11">fg</samp> has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value, <samp class="SANS_TheSansMonoCd_W5Regular_11">bg</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. The test passes because the values aren’t equal. Two nullable value type variables are equal if both have no value, or if both have <span aria-label=" Page 169. " epub:type="pagebreak" id="pg_169" role="doc-pagebreak"/>a value and those values are themselves equal. What’s interesting about this example is that while <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> has a custom <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> to compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values, it accepts two <i>non</i>-nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameters. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a struct, <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> isn’t a valid value for it, although <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is a valid value for a <i>nullable</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable&lt; T &gt;</samp> struct doesn’t have an overloaded <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> of its own. When the compiler encounters code comparing two nullable value types, or a nullable value type and a normal value type instance, it rewrites the comparison by inserting the implementation from the corresponding operator definition for the underlying—non-nullable—value type. This process is known as <i>lifting</i> the operator. Since one or both of those arguments may have <i>no</i> value, the lifted operation makes the additional checks for the existence of a value before finally comparing those values by using the original, non-nullable comparison.</p>
<p class="TX">For this reason, if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> has no <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> defined, the comparison of two <samp class="SANS_TheSansMonoCd_W5Regular_11">T?</samp> variables fails to compile, because the compiler has no operator implementation to lift. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lifted_op_Equality</samp> method in <a href="#list5-30">Listing 5-30</a> is fictional but demonstrates the basic algorithm for the lifted equality comparison operation.</p>
<pre id="list5-30"><code>bool lifted_op_Equality(Color? fg, Color? bg)&#13;
{&#13;
    if(fg.HasValue &amp;&amp; bg.HasValue)&#13;
        return fg.Value == bg.Value; // uses Color.operator==&#13;
    else&#13;
        return !fg.HasValue &amp;&amp; !bg.HasValue;&#13;
}</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-30: The lifted equality operator</samp></p>
<p class="TX">The compiler doesn’t generate a new method for this algorithm but simply inserts logic inline in our code, replacing the original comparison using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> in <a href="#list5-29">Listing 5-29</a> with the equivalent of the following:</p>
<pre><code>Assert.That(&#13;
    fg.HasValue == bg.HasValue &amp;&amp;&#13;
    (!fg.HasValue || fg.GetValueOrDefault() == bg.GetValueOrDefault()),&#13;
Is.False);</code></pre>
<p class="TX">The logic of this code is essentially identical to that in <a href="#list5-30">Listing 5-30</a>, but it’s a single expression and thus easier for the compiler to inline. The reason for using <samp class="SANS_TheSansMonoCd_W5Regular_11">GetValueOrDefault</samp> instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Value</samp> property is that the latter needs to check that a valid value exists and will throw an exception if it doesn’t. <samp class="SANS_TheSansMonoCd_W5Regular_11">GetValueOrDefault</samp> is therefore slightly more efficient.</p>
<p class="TX">Although nullable value types are instances of the special system type <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable&lt; T &gt;</samp>, the same functionality couldn’t be implemented by <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable&lt; T &gt;</samp> simply having its own <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> to perform the comparison. The purpose of lifting the underlying type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> is to ensure that when both variables have a value, they’re compared exactly as if they were non-nullable types—that is, direct instances of the original value type. An <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> <span aria-label=" Page 170. " epub:type="pagebreak" id="pg_170" role="doc-pagebreak"/>implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable&lt; T &gt;</samp> would need to use <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare two instances of the generic type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, which, as we know, isn’t allowed.</p>
<p class="TX">By lifting the underlying type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, the compiler ensures that the correct behavior is maintained and that values compare the same way whether or not they’re nullable types.</p>
<p class="TX">The compiler also generates code inline to support comparisons of value tuple variables, introduced in C# v7.0, although the process for value tuples is a little different.</p>
</section>
<section aria-labelledby="sec32" epub:type="division">
<h3 class="H2" id="sec32"><span id="h-125"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Tuples and Equality</samp></h3>
<p class="TNI"><i>Tuples</i> are a common feature of many modern programming languages to gather several related values together into a single lightweight data structure. A tuple in C# is similar to a struct with all public fields and no member methods, although the syntax for declaring and using a tuple is different from doing so for such a struct.</p>
<p class="TX">Compiler support for tuple types supersedes the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Tuple</samp> class introduced in .NET v4.0. The more modern feature, available since C# v7.0, is known as a <i>value tuple</i>. Value tuples are underpinned by a system type named <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueTuple</samp>, but that type isn’t intended to be used directly. Instead, when we want to relate several fields together without the overhead of adding a full user-defined class or struct, we use the value tuple syntax.</p>
<p class="TX">Value tuples enjoy sophisticated support from the compiler, both in how variables are declared and in how they can be used. <a href="#list5-31">Listing 5-31</a> shows an example of comparing value tuple variables for equality.</p>
<pre id="list5-31"><code>var x = (10, "October");&#13;
var y = (ShortMonth: 10, LongMonth: "October");&#13;
Assert.That(x == y, Is.True);</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-31: Comparing value tuple variables for equality</samp></p>
<p class="TX">We’re declaring two tuple variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, by surrounding multiple values with parentheses; this syntax is common in several languages with tuple support and probably familiar to many programmers. However, although the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variables have the same <i>values</i>, they look distinctly different from each other in their declarations. In particular, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> gives names to its component parts, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> doesn’t. The test determines that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are equal and passes.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>Support for using</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <i>to compare value tuples was introduced in C# v7.3, shortly after value tuples were introduced.</i></p>
<p class="TX">When we compare value tuple variables with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, the compiler generates code to compare each element of the value tuple with the corresponding element in the other value tuple. The elements of a value tuple are public fields, not properties, meaning that reading or writing a value accesses the <span aria-label=" Page 171. " epub:type="pagebreak" id="pg_171" role="doc-pagebreak"/>field directly. As with nullable values, the compiler rewrites our comparison expression by inserting the code to compare the fields of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> directly.</p>
<p class="TX">The CIL extract in <a href="#list5-32">Listing 5-32</a> shows just the comparison of the tuples’ first component in <a href="#list5-31">Listing 5-31</a>.</p>
<pre id="list5-32"><code>IL_0021: ldloc.2    // V_2&#13;
IL_0022: ldfld      !0/*int32*/ valuetype System.ValueTuple`2&lt;int32, string&gt;::Item1&#13;
IL_0027: ldloc.3    // V_3&#13;
IL_0028: ldfld      !0/*int32*/ valuetype System.ValueTuple`2&lt;int32, string&gt;::Item1&#13;
IL_002d: <b>bne.un.s   IL_0042</b></code></pre>
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-32: New-style value tuple comparison CIL</samp></p>
<p class="TX">The compiler directly loads the fields by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ldfld</samp> instruction and then compares those values by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp> instruction, which stands for <i>break if not equal</i>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp> instruction is a companion to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction we encountered in <a href="#list5-1">Listing 5-1</a>. Whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> pushes its result onto the evaluation stack, <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp> jumps to the specified label (<samp class="SANS_TheSansMonoCd_W5Regular_11">IL_0042</samp> in this example) if the values being compared are <i>not</i> equal; otherwise, processing continues from the next instruction following <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp>.</p>
<p class="TX">The fact that we’re attempting to compare a simple tuple with a tuple that has named elements is irrelevant. The generated code doesn’t attempt to use the names we’ve given the fields. It’s comparing only their values, so the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. We could compare <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with a tuple using different names with the same result; only the types and values of the fields matter.</p>
<p class="TX">The names we give the tuple components are a purely compile-time construct for <i>our</i> convenience. In fact, the names we give the <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> variable’s components never even make it into the compiled code.</p>
<p class="TX">As with the generated code for comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable&lt; T &gt;</samp> values, the compiler will inject code to call a user-defined <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> if needed. You can see this in <a href="#list5-33">Listing 5-33</a>, which shows the CIL for the comparison of the second component of our tuples, a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> field.</p>
<pre id="list5-33"><code>IL_002f: ldloc.2   // V_2&#13;
IL_0030: ldfld     !1/*string*/ valuetype System.ValueTuple`2&lt;int32, string&gt;::Item2&#13;
IL_0035: ldloc.3   // V_3&#13;
IL_0036: ldfld     !1/*string*/ valuetype System.ValueTuple`2&lt;int32, string&gt;::Item2&#13;
IL_003b: call      bool [System.Runtime] <b>System.String::op_Equality(string, string)</b></code></pre>
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-33: The call to a user-defined equality operator inserted by the compiler</samp></p>
<p class="TX">Instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">bne</samp> instruction used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> field, the compiler has synthesized a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp>, exactly as if we’d handwritten the code. Fields of a value tuple are compared in the order in which they appear, so the first field of one is compared with the first field of the corresponding variable, and so on.</p>
<p class="TX">This approach differs from records, which use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer</samp> protocol instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare their fields. For records, the compiler <span aria-label=" Page 172. " epub:type="pagebreak" id="pg_172" role="doc-pagebreak"/>generates the right methods on the underlying class or struct type to implement equality. When we compare two records with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, we’re invoking the <samp class="SANS_TheSansMonoCd_W5Regular_11">op_Equality</samp> method generated for the record type. That method compares each field of the record in turn by using its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.</p>
<p class="TX">For value tuples, as with nullable value types, the compiler generates the comparison code <i>inline</i>, effectively replacing the comparison of two tuples with a direct comparison of the component fields of each tuple type. If a component field of the tuple has an <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> defined for it, that implementation is used, but like <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable&lt; T &gt;</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueTuple</samp> type used to implement value tuples has no <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> of its own.</p>
<p class="TX">If the fields can’t be compared using either <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, our code using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare the value tuple fails to compile. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueTuple</samp> type does override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method and also implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> interface. Therefore, if a field has no <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>, we can still compare value tuple variables with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, which in turn will call each field’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, safe in the knowledge that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is always there, whatever type we’re using.</p>
</section>
</section>
<section aria-labelledby="sec33" epub:type="division">
<h2 class="H1" id="sec33"><span id="h-126"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<blockquote epub:type="epigraph" role="doc-epigraph">
<p class="EP"><i>All animals are equal, but some animals are more equal than others.</i></p>
<footer class="EPS">—George Orwell, <i>Animal Farm</i></footer></blockquote>
<p class="BodyContinued">For such a simple expression, comparing two variables for equality can represent a wide variety of behavior, from using a simple built-in equality check with <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> in the compiled code all the way up to the compiler automatically generating the correct code to perform a comparison. We’ve looked at how references are compared, how overriding the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method and <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator can affect behavior, and how the compiler can generate code to make sure the “right thing” happens.</p>
<p class="TX">For many programmers, using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> to compare variables comes more naturally than calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. For the built-in numeric types, using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> is always more efficient, although with the binary floating-point types <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we have to be cautious of using either approach. Notwithstanding that, the cost of calling a method is very small, but it can never be as fast as the intrinsic <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction.</p>
<p class="TX">The purpose of examining these effects in such intricate detail is to demonstrate that we can’t necessarily take for granted what such a simple expression does when a program runs. The run-time complexity of any expression may be hidden from view, perhaps masked by the compiler choosing an unexpected method overload or override instead of a direct comparison between two variables. Certainly the performance costs in such examples are small, but they might be significant in “hot” paths through a program.</p>
<p class="TX">Boxing value type instances can have a significant effect on performance, not only because boxing generates copies of the value, but also because those copies are put on the heap and add pressure to the garbage <span aria-label=" Page 173. " epub:type="pagebreak" id="pg_173" role="doc-pagebreak"/>collector. The standard <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable&lt; T &gt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityComparer&lt; T &gt;</samp> types help us avoid many cases where boxing would otherwise be required, especially in generic code.</p>
<p class="TX">We should always be aware of those circumstances where the compiler generates code on our behalf, but in the case of equality comparisons, the compiler goes to quite a lot of trouble to make sure that code is as efficient as possible.</p>
</section>
</section>
</div></body></html>