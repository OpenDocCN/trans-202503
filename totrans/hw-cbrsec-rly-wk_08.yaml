- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Encryption Cracking
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 加密破解
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Imagine if all your internet emails, messages, and purchases were available
    for everyone to see. A black hat would just need to watch your network traffic
    to learn anything they wanted to know about your internet browsing, steal your
    files, or even capture passwords. One of the most important parts of cybersecurity
    is *cryptography*, or the process of hiding data so only authorized people can
    see it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你所有的互联网电子邮件、消息和购买记录都能被任何人查看。一位黑帽黑客只需要观察你的网络流量，就能知道你想要的任何信息，盗取你的文件，甚至捕获你的密码。网络安全中最重要的部分之一就是*密码学*，即隐藏数据的过程，使得只有授权的人才能看到它。
- en: In this chapter, you’ll learn how encryption works, how attackers try to break
    it, and how you can strengthen it to protect your personal information from prying
    eyes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解加密是如何工作的，攻击者如何尝试破解它，以及你如何加强加密来保护个人信息免受窥探。
- en: What Is Cryptography?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是密码学？
- en: '*Cryptography* is the study and art of writing codes. When people want to hide
    data, they often do so by writing a code or process, known as a *cipher*, to conceal
    the information. In modern computer systems we hide data using *cryptographic
    algorithms*,which are procedures that perform complex math to securely transform
    information.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码学*是编写代码的研究与艺术。当人们想要隐藏数据时，他们通常通过编写代码或过程（称为*密码*）来掩盖信息。在现代计算机系统中，我们使用*密码算法*来隐藏数据，这些算法是执行复杂数学运算以安全地转换信息的过程。'
- en: Ciphers and algorithms work in various ways, but they all use keysto function.
    A *key* is a piece of unique information that usually remains secret. Using the
    key, a person can turn *plaintext*,or data that hasn’t been encrypted, into *ciphertext,*
    or encrypted data. The encryption process is similar to putting a lock on a door.
    When a door is unlocked, anyone can access what’s on the other side. Locks, like
    cryptography, restrict access to only those who have the key. Every door has a
    unique lock and key that can be used to keep whatever is on the other side of
    the door safe. Encoding data using a key is known as *encryption*. You can think
    of this like locking a door. Reversing the encryption, a process equivalent to
    unlocking the door, is called *decryption*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 密码和算法以各种方式工作，但它们都使用密钥来执行功能。一个*密钥*是一个独特的信息，通常保持秘密。通过使用这个密钥，用户可以将*明文*（即未加密的数据）转化为*密文*（即加密后的数据）。加密过程类似于在门上安装锁。当门未上锁时，任何人都可以访问门的另一侧。像密码学一样，锁限制了只有持有钥匙的人才能访问。每个门都有一个独特的锁和钥匙，用来保护门的另一侧的安全。使用密钥对数据进行编码的过程称为*加密*。你可以把它想象成给门上锁。反向加密过程，相当于解锁门，称为*解密*。
- en: What We Encrypt
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们加密的内容
- en: 'We use encryption on many types of files and processes. Basically, anything
    stored on a computer can be encrypted in some form or fashion. However, the type
    of encryption used might change depending on the state of the data. All data is
    organized into one of three categories: data at rest, data in transit, and data
    in use. *Data at rest* includes any file that a computer isn’t actively processing;
    for example, music, documents, or information in a database. *Data in transit*is
    any data being sent between two systems, including packets (as discussed in Chapter
    6), emails, or files in the process of being sent over a network. *Data in use*
    is data that a computer system is currently using. This type of data can’t be
    encrypted, because the computer must be able to read it to use it.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在许多类型的文件和过程上使用加密。基本上，存储在计算机上的任何内容都可以以某种形式加密。然而，所使用的加密类型可能会根据数据的状态而变化。所有数据都被组织为三类之一：静态数据、传输中的数据和使用中的数据。*静态数据*包括计算机不在主动处理的任何文件；例如，音乐、文档或数据库中的信息。*传输中的数据*是指在两个系统之间传输的任何数据，包括数据包（如第六章所讨论）、电子邮件或正在通过网络发送的文件。*使用中的数据*是指计算机系统当前正在使用的数据。此类数据不能加密，因为计算机必须能够读取它以进行使用。
- en: As data moves between different states, the encryption type changes. For example,
    imagine you install a game on your computer. If you’re not playing that game,
    you can encrypt it using *file encryption*,storing it on your hard drive or other
    storage medium. But as soon as you open the game, it becomes data in use and must
    be decrypted by the computer to function. Now let’s say you send the game to a
    friend over the internet. At that point, the game becomes data in transit and
    must now use *transport encryption*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据在不同状态之间传输时，加密类型会发生变化。例如，假设你在电脑上安装了一个游戏。如果你没有在玩这个游戏，你可以使用*文件加密*将其加密，并将其存储在硬盘或其他存储介质上。但一旦你打开游戏，它就变成了“使用中的数据”，计算机必须对其进行解密才能正常运行。现在假设你通过互联网将游戏发送给一个朋友。这时，游戏变成了“传输中的数据”，必须使用*传输加密*。
- en: The different options for encryption help distinguish the methods used to encrypt
    that particular type of data. Each encryption option has its strengths and weaknesses,
    which we’ll discuss in more detail in “Modern Cryptography” on page 160. For now,
    keep in mind that just because you’re using one type of encryption, such as file
    encryption, that doesn’t always mean your data is safe in other states, such as
    when it’s in use or in transit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的加密选项有助于区分用于加密特定类型数据的方法。每种加密选项都有其优缺点，我们将在《现代密码学》第160页中更详细地讨论这一点。现在，请记住，单单因为你使用了一种加密方式，例如文件加密，并不意味着你的数据在其他状态下（例如使用中或传输中）也一定是安全的。
- en: Early Cryptography
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 早期密码学
- en: The practice of writing encrypted messages has been around for as long as writing
    has. Militaries used early cryptographic techniques to transport messages, ensuring
    that the enemy couldn’t learn about their plans should the messages fall into
    the wrong hands.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 加密消息的做法与书写本身一样古老。军事部门早期使用密码学技术来传输消息，确保如果消息落入敌人之手，他们无法得知自己的计划。
- en: Early cryptography was also fairly ad hoc. People had no set standards for how
    to encrypt messages, so they typically invented strategies on a case-by-case basis.
    At times, the lack of standards presented problems when transporting messages
    to a stranger, such as a king or general in another kingdom, because they didn’t
    know the encryption method. In fact, some historical writings have yet to be interpreted
    because experts believe they’re written in long-lost ciphers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的密码学也相当临时。人们没有加密消息的固定标准，因此通常是根据具体情况发明策略。有时，缺乏标准在将消息传递给陌生人时会带来问题，比如传递给其他王国的国王或将军，因为他们不知道加密方法。事实上，一些历史文献至今未能被解读，因为专家认为它们是用早已失传的密码写成的。
- en: 'The absence of standards highlights one of the primary problems in cryptography:
    how do you create a system that hides information well while still sharing a decryption
    key between two people? In other words, this is a problem of balancing the CIA
    triad elements of confidentiality and availability. If the encryption system is
    too difficult, it can be challenging to use effectively. For example, if I encrypt
    a message so it can only be decrypted on the highest peak in a kingdom during
    a full moon while saying magic words backward in Elvish, I might very well prevent
    enemies from reading it. But if I want to share my work with other wizards, it
    will be problematic for them to read it too. However, if I create a cipher that
    uses a keyword for decryption and then write that word at the top of the message,
    the encryption becomes pointless because anyone who gets the message will know
    the keyword as well.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏标准突显了密码学中的一个主要问题：如何创建一个在隐藏信息的同时，仍能在两人之间共享解密密钥的系统？换句话说，这是平衡机密性和可用性的CIA三原则元素的问题。如果加密系统过于复杂，可能会导致难以有效使用。例如，如果我加密一条消息，使得只有在某个王国的最高峰在满月时，并且在倒着说精灵语的魔法词语时才能解密，那我很可能会阻止敌人阅读这条消息。但如果我想和其他巫师分享我的工作，他们也会很难阅读它。然而，如果我创建一个使用关键字解密的密码，并将这个关键字写在消息的顶部，那么加密就变得毫无意义，因为任何收到消息的人都会知道这个关键字。
- en: 'Balancing availability and confidentiality considerations is an ongoing problem
    in cryptography. To help solve this problem, cryptographers began relying on two
    methods of encryption: *substitution* and *transposition*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡可用性和机密性的考虑始终是密码学中的一个难题。为了解决这个问题，密码学家开始依赖两种加密方法：*代换*和*置换*。
- en: Substitution Ciphers
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代换密码
- en: 'To create a substitution cipher, you replace one symbol with another. For example,
    consider the fictitious Super Awesome Substitution Cipher in which you replace
    each letter of a message with a number. To use the Super Awesome Substitution
    Cipher, you would only need to know one of the substitutions, which could be used
    as the key. That key might be *A is equal to 10*. Once you know the key, it’s
    easy to continue counting, pairing each subsequent letter with the next number:
    *B* becomes *11*, *C* becomes *12*, and so on, ending with *Z* becoming *36*.
    Using this cipher and key, the message *attack now* becomes *10, 29, 29, 10, 12,
    20, 23, 24, 32*.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个替代密码，你需要用一个符号替换另一个符号。例如，考虑虚构的超级棒替代密码，在这种密码中，你用数字替换消息中的每个字母。要使用超级棒替代密码，你只需要知道其中一个替代规则，这可以作为密钥。这个密钥可能是*字母A等于10*。一旦你知道了密钥，就可以继续计数，将每个后续字母与下一个数字配对：*B*变成*11*，*C*变成*12*，依此类推，直到*Z*变成*36*。使用这个密码和密钥，消息*attack
    now*就变成了*10, 29, 29, 10, 12, 20, 23, 24, 32*。
- en: 'This substitution cipher wouldn’t be very secure for practical use, because
    it’s simple to crack through trial and error. However, throughout history, many
    effective ciphers have used the substitution method. The most famous is the Caesar
    Cipher, which Julius Caesar invented. It relied on the use of two copies of the
    alphabet. The writer lined up the two alphabets, one on top of another, so they
    matched: the letter *A* in the top alphabet aligned with the letter *A* in the
    bottom alphabet. The writer then shifted the bottom alphabet left or right by
    a few spaces and used the shifted alphabet to encrypt their message. The number
    of spaces shifted was the key. For example, to encrypt the letter *A* with a key
    of 3, you would write it as the letter *D*. Although it’s still easy to break,
    this was the first cipher to create a standard substitution algorithm, and it
    became the basis for future substitution ciphers.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代密码在实际应用中并不安全，因为它很容易通过试错法破解。然而，在历史上，许多有效的密码都使用了替代法。最著名的是凯撒密码，它由尤利乌斯·凯撒发明。它依赖于使用两个字母表副本。作者将这两个字母表一上一下对齐，使它们相匹配：上面的字母表中的字母*A*与下面字母表中的字母*A*对齐。然后，作者将下面的字母表向左或向右移动几个位置，并使用移动后的字母表来加密他们的信息。移动的空间数就是密钥。例如，要用密钥3加密字母*A*，你会将它写成字母*D*。虽然它仍然容易破解，但这是第一个创建标准替代算法的密码，并成为未来替代密码的基础。
- en: Transposition Ciphers
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 换位密码
- en: Whereas a substitution cipher replaces a message with completely new symbols,
    a transposition cipher uses the same symbols but arranges them in a different
    order to hide their meaning. This process resembles the word jumbles you see in
    newspapers or online. When put through a transposition cipher, the message *attack
    now* might become *kcnwta toa*, for example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 替代密码将消息替换为完全新的符号，而换位密码使用相同的符号，但将它们以不同的顺序排列以隐藏其含义。这个过程类似于你在报纸或在线上看到的字谜。当经过换位密码处理后，消息*attack
    now*可能变成*kcnwta toa*，例如。
- en: For a transposition cipher to be an effective form of encryption instead of
    a fun brainteaser, you must scramble the letters in an organized fashion. There
    are several ways to accomplish this, but one of the oldest is the *Scytale* method.
    Invented in Greece, the original Scytale method used a piece of cloth that was
    wrapped around a rod of a certain thickness and length. Writers wrote the message
    across the cloth, and when they unwound it the message was naturally scrambled
    along its length. A person had to wrap the cloth around the same type of rod to
    decrypt the message. To conceal the messages even further, people sometimes wore
    the cloths as belts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使换位密码成为一种有效的加密形式，而不仅仅是一个有趣的脑筋急转弯，你必须以有序的方式打乱字母。有几种方法可以实现这一点，但其中一种最古老的方法是*Scytale*法。Scytale法起源于希腊，原始的Scytale方法使用一块布，将其缠绕在一根特定厚度和长度的棒上。作者在布上写下信息，当他们将布解开时，信息沿着布的长度自然被打乱。解密消息的人必须将布缠绕在相同类型的棒上。为了进一步隐藏消息，人们有时将这些布作为腰带佩戴。
- en: Modern Cryptography
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代密码学
- en: In the 1800s, governments began to use more systematic approaches to cryptography.
    This included building machines to handle the encryption/decryption process, a
    method of cryptography best illustrated by the German Enigma machine. Used during
    World War II, the Enigma used three rotating dials that encrypted and decrypted
    messages being sent via radio. Theoretically, the cipher was too complicated to
    break without an Enigma machine to do the work, because the machine’s use of three
    unique disks generated an extensive number of symbol combinations.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1800 年代，政府开始采用更系统化的密码学方法。这包括制造机器来处理加密/解密过程，这种加密方法最典型的例子就是德国的恩尼格玛机。恩尼格玛机在第二次世界大战期间使用，采用了三组旋转盘来加密和解密通过无线电发送的消息。从理论上讲，这种密码太复杂，如果没有恩尼格玛机来进行工作，就无法破解，因为该机器使用三片独特的磁盘生成了大量的符号组合。
- en: But the cipher wasn’t unbreakable. The universal flaw in cryptography is that
    any cipher can be broken, given enough time, even if it takes a billion years
    to try every possible key combination. The real value of a cipher is its *work
    factor*, meaning that it takes long enough to break that the message is no longer
    relevant. By the end of World War II, *cryptanalysis**,* or the study of breaking
    ciphers, was so advanced that researchers could break any code that relied on
    a mechanical process, such as the one the Enigma machine used, in a short amount
    of time. This lowered the work factor of these ciphers, essentially making them
    worthless.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但该密码并非无法破解。密码学的普遍缺陷是：任何密码都有可能被破解，只要有足够的时间，即使破解每一个可能的密钥组合需要一亿年。一个密码的真正价值在于它的*工作量*，也就是说，破解它所需的时间足够长，以至于消息在破解之前就不再相关。到第二次世界大战结束时，*密码分析*，即破解密码的研究，已经发展到如此先进的程度，以至于研究人员能够在短时间内破解依赖机械过程的任何密码，例如恩尼格玛机所使用的密码。这大大降低了这些密码的工作量，基本上使它们变得毫无价值。
- en: The advent of computers further reduced work factors, but also created new means
    of creating ciphers. Computers made it effortless to perform advanced math calculations
    quickly. As a result, people were able to solve problems in a matter of minutes
    that would normally have taken them days or weeks to finish. Starting in the 1950s,
    modern cryptographers began working on new methods of encryption that used exceptionally
    complicated mathematical problems to compute the numbers necessary to create the
    ciphertext. For example, using two specific points on an elliptical curve graph
    that are paired together, you can create a set of keys to encrypt and decrypt
    ciphertext. Even if you knew one of the points, it would take a high-end computer
    many, many years to search through all the possible pairs for the correct one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的出现进一步减少了工作量，但也创造了新的加密方式。计算机使得执行高级数学运算变得非常迅速。因此，人们能够在几分钟内解决那些通常需要几天或几周才能完成的问题。从
    1950 年代开始，现代密码学家开始研究新的加密方法，这些方法使用极其复杂的数学问题来计算生成密文所需的数字。例如，利用椭圆曲线图上的两个特定点，配对后可以创建一组密钥来加密和解密密文。即使你知道其中一个点，使用高端计算机也需要许多年才能搜索出所有可能的配对以找到正确的那一对。
- en: 'Eventually, cryptographers created three main methods of encryption: *symmetric*,
    *asymmetric*, and *hashing*. These three methods became the foundation of modern
    cryptography and are what most encryption is built upon today.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，加密学家创造了三种主要的加密方法：*对称*、*非对称*和*哈希*。这三种方法成为了现代密码学的基础，是当今大多数加密技术的构建基石。
- en: Symmetric Cryptography
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对称密码学
- en: Symmetric cryptography, also known as *single* or *private key cryptography,*
    uses one key to encrypt and decrypt plaintext ([Figure 9-1](#figure9-1)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密码学，也称为*单一*或*私钥密码学*，使用一个密钥来加密和解密明文（[图 9-1](#figure9-1)）。
- en: '![f09001](image_fi/501287c09/f09001.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](image_fi/501287c09/f09001.png)'
- en: 'Figure 9-1: Encrypting with private key cryptography'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：使用私钥加密
- en: 'Symmetric key algorithms use complex functions to create ciphertext from plaintext,
    but at their core they still use substitution and transposition techniques. Instead
    of switching and moving letters, they move around the computer’s 1s and 0s that
    represent those letters. They’re much stronger than traditional transposition
    and substitution techniques, because unlike a human manipulating data by hand,
    a computer can perform hundreds, if not thousands, of transformations in a short
    amount of time. Computers can also change how they perform the substitution or
    transposition while running their algorithm. However, this can be tricky for two
    reasons: the system needs to scramble the 1s and 0s to ensure they can’t be read
    again, but also make sure the process can be reversed given the correct key.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥算法使用复杂的函数将明文转化为密文，但其核心仍然使用替换和换位技术。它们不是交换或移动字母，而是移动表示这些字母的计算机中的1和0。它们比传统的换位和替换技术要强大得多，因为与人类手动操作数据不同，计算机可以在短时间内执行数百次甚至数千次变换。计算机还可以在运行算法时改变它们执行替换或换位的方式。然而，这可能会有一定难度，原因有二：系统需要对1和0进行打乱，以确保它们无法再次被读取，同时也要确保在提供正确密钥的情况下，过程能够被逆转。
- en: 'To make these processes easier, symmetric key algorithms use two types of cipher
    modes: *stream* and *block*.In stream cipher mode, the computer encrypts one bit
    of data at a time. This mode creates some of the fastest encryption but is generally
    considered weaker than block modes, because it generates less randomness in the
    resulting ciphertext; in other words, it produces patterns that can make breaking
    the algorithm easier, especially if the key is too short or if the same key is
    used frequently.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这些过程，对称密钥算法使用两种类型的密码模式：*流式*和*块式*。在流密码模式下，计算机一次加密一个比特的数据。这个模式产生的是一些最快的加密，但通常被认为比块模式弱，因为它在生成的密文中产生的随机性较少；换句话说，它会产生一些模式，这些模式可能使破解算法变得更容易，特别是当密钥过短或者同一密钥频繁使用时。
- en: Block ciphers encrypt fixed-length blocks of bits. This technique is slower
    but stronger than using a stream cipher. Instead of encrypting each bit one at
    a time, the algorithm organizes bits into blocks. For example, a 4 × 4–sized block
    of bits is taken from the data you’re encrypting, and an equally large block of
    bits is taken from the key. Then the algorithm encrypts the whole block of bits
    at once, creating an encrypted 4 × 4–sized block of bits.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 块密码对固定长度的比特块进行加密。与使用流密码相比，这种技术较慢但更强大。它不是逐个比特加密，而是将比特组织成块。例如，从正在加密的数据中取出一个4×4大小的比特块，并从密钥中取出一个相同大小的比特块。然后，算法一次性加密整个比特块，生成一个加密的4×4大小的比特块。
- en: Because the blocks are all the same size, the algorithm can combine a previously
    encrypted block with the key to create a new, unique input to use for the next
    block that is encrypted. Therefore, not only does the key help create a unique
    encryption, but what is being encrypted also helps increase the uniqueness of
    the final ciphertext, making it incredibly hard to break.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于块的大小相同，算法可以将之前加密过的块与密钥结合，生成一个新的、唯一的输入，用来加密下一个块。因此，不仅密钥帮助创建独特的加密方式，而且被加密的内容也有助于增加最终密文的唯一性，使得破解变得极为困难。
- en: Just like locking a door with a key, symmetric algorithms are fast when encrypting
    files, making them efficient at bulk encryption, such as encrypting numerous files
    on a hard drive or an entire database. But this speed comes with a catch. If two
    people attempt to communicate using a symmetric algorithm, they must find a way
    to transmit the key without exposing it. This requires finding some method of
    transportation other than the one used to send the ciphertext, because anyone
    who intercepted the ciphertext would also intercept the key if they were together.
    The type of transfer needed is known as *out of band*transportation and can be
    tricky to do in many situations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像用钥匙锁住一扇门一样，对称算法在加密文件时速度较快，这使得它们在大批量加密中非常高效，例如加密硬盘上的多个文件或整个数据库。但这种速度也有一个代价。如果两个人试图使用对称算法进行通信，他们必须找到一种方法来传输密钥而不暴露它。这需要找到一种不同于发送密文所用的传输方式，因为如果有人截获了密文，他们也会同时截获密钥。所需的传输方式被称为*带外*传输，在许多情况下，这可能会非常棘手。
- en: Many symmetric algorithms are available, but two in particular are well known.
    One is the *Data Encryption Standard (DES)*, which is one of the first modern
    encryption standards widely used among government, military, and public systems.
    This algorithm implements a block cipher with a 56-bit key. Although 56 bits resulted
    in an effective work factor when DES was invented, since the early 2000s it’s
    been easy to break a DES key in less than 24 hours due to an increase in computer
    processing power. The more bits there are in a key, the more combinations a computer
    must go through to guess the right key. But as processors became faster, it became
    possible for computers to calculate the possible combinations more rapidly. A
    56-bit key just doesn’t produce enough combinations to prevent modern processors
    from guessing the key quickly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多对称加密算法可用，但其中有两个特别著名。一个是*数据加密标准（DES）*，这是最早的现代加密标准之一，在政府、军事和公共系统中被广泛使用。该算法实现了一个56位密钥的分组加密算法。尽管在DES被发明时，56位密钥能够提供有效的工作因子，但由于计算机处理能力的提升，从2000年代初开始，破解一个DES密钥只需不到24小时。密钥位数越多，计算机需要遍历的组合就越多。随着处理器的速度越来越快，计算机能够更快地计算出所有可能的组合。56位密钥的组合数不足以防止现代处理器快速猜测出密钥。
- en: To get more life out of DES, cryptographers invented a new method of using the
    algorithm, called *3DES* (pronounced “triple DES”), which, as you might guess,
    used three DES keys instead of just one. However, this method included a flaw
    in how the encryption was executed. Black hats can exploit this flaw to break
    3DES nearly as quickly as DES.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了延长DES的生命周期，密码学家发明了一种新的使用该算法的方法，叫做*3DES*（发音为“三重DES”），顾名思义，它使用了三个DES密钥，而不是仅使用一个。然而，这种方法在加密执行的方式上存在缺陷。黑客可以利用这个缺陷，几乎和破解DES一样快速地破译3DES。
- en: Because DES was at the end of its life cycle, people needed a new algorithm
    to replace it. Many cryptographers tried to develop a replacement, and in the
    end, they settled on the Rijndaelalgorithm. Today, we commonly call the implementation
    of this algorithm the *Advanced Encryption Standard* *(AES**)*. AES typically
    uses a key size of 128 bits, although the key can be as long as 256 bits if needed.
    AES uses the block encryption method. Although first implemented in 2001, it’s
    still very much in use today and has an excellent work factor. Even with current
    supercomputers, it would take a billion billion years to brute-force an AES key—longer
    than the age of the universe.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DES已经接近其生命周期的末期，人们需要一种新的算法来替代它。许多密码学家尝试开发替代算法，最终他们选择了Rijndael算法。今天，我们通常将该算法的实现称为*高级加密标准*（*AES*）。AES通常使用128位密钥，尽管在需要时密钥长度可以达到256位。AES使用的是分组加密方法。尽管该算法于2001年首次实施，但它至今仍在广泛使用，并且具有出色的工作因子。即使是当前的超级计算机，也需要数十亿年才能暴力破解一个AES密钥——这比宇宙的年龄还要长。
- en: Asymmetric Cryptography
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非对称加密
- en: Although symmetric cryptography works well for most encryption needs, such as
    protecting files or creating a secure connection between two devices, the inability
    to easily share keys between two parties makes it problematic to use effectively
    to communicate across the internet. This is where asymmetric cryptography, also
    known as *public key encryption,* steps in.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对称加密适用于大多数加密需求，如保护文件或在两台设备之间建立安全连接，但无法轻易在两方之间共享密钥，这使得它在互联网上的有效通信中存在问题。这就是非对称加密，也称为*公钥加密*，发挥作用的地方。
- en: 'In asymmetric cryptography, the algorithm uses two keys for each party: a public
    key and a private key. The keys are linked, so anything that the public key encrypts
    only the private key can decrypt, and vice versa. No one key can encrypt and decrypt
    the same ciphertext. This system is useful because any data encrypted with the
    public key can only be decrypted with the private key, so you can share the public
    key in the same message as the data you intend to encrypt ([Figure 9-2](#figure9-2)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在非对称加密中，算法为每一方使用两把密钥：公钥和私钥。这两把密钥是相互关联的，因此公钥加密的任何内容只有私钥才能解密，反之亦然。没有任何一把密钥能够加密并解密相同的密文。这个系统之所以有用，是因为任何用公钥加密的数据只能用私钥解密，因此你可以将公钥和要加密的数据一起在同一消息中共享（[图
    9-2](#figure9-2)）。
- en: '![f09002](image_fi/501287c09/f09002.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](image_fi/501287c09/f09002.png)'
- en: 'Figure 9-2: Encrypting using a public/private key pair'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：使用公钥/私钥对进行加密
- en: For this reason, asymmetric cryptography makes it easy to encrypt communication
    between two people, especially when they don’t know each other. For example, let’s
    say Alice wants to send Bob a private document using email. Before she encrypts
    the document, she needs to be assured that Bob can decrypt it once it reaches
    his inbox. If she were using a symmetric key, she wouldn’t be able to send the
    key with the email, because anyone who might be sniffing the traffic would see
    the document and the key. She could put the symmetric key on a zip drive and send
    it to Bob in the mail, but this would take time and effort. Instead of using a
    symmetric key, Alice could ask Bob to send her his public key. Bob can send this
    key over the internet by any convenient means because it doesn’t have to remain
    a secret. Alice can then encrypt the document using Bob’s public key and send
    the document back by email. If an adversary intercepts the email, they won’t be
    able to decrypt it, because only Bob’s private key can do that. If his private
    key is secret, it doesn’t matter who has his public key.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，非对称加密使得两个人之间的通信加密变得容易，特别是当他们互不相识时。例如，假设艾丽丝想通过电子邮件向鲍勃发送一份私人文档。在她加密文档之前，她需要确保鲍勃在文档到达他的收件箱后能够解密它。如果她使用的是对称密钥，她就无法将密钥与电子邮件一起发送，因为任何可能监听流量的人都能看到文档和密钥。她可以将对称密钥放在一个U盘上，并通过邮寄的方式发送给鲍勃，但这需要时间和精力。与其使用对称密钥，艾丽丝可以让鲍勃将他的公钥发给她。鲍勃可以通过任何方便的方式通过互联网发送这个公钥，因为它不需要保密。然后，艾丽丝可以使用鲍勃的公钥加密文档，并通过电子邮件将文档发送回去。如果有对手拦截了电子邮件，他们也无法解密，因为只有鲍勃的私钥可以解密它。如果他的私钥保密，谁拥有他的公钥都无关紧要。
- en: Public key cryptography is also beneficial for proving that someone is who they
    say they are and to keep them from refuting that they sent something, a concept
    called *non-repudiation***.** Let’s say that Bob reviews the document, says it
    looks good, and sends it back to Alice. Alice wants to confirm that Bob sent the
    document instead of someone pretending to be Bob. To do this using asymmetric
    cryptography, Bob can encrypt a hash of the document using his private key and
    send that to Alice (we’ll discuss hashes in “Hashing” on page 166). Only Bob’s
    public key can decrypt the file. If the decryption works, Alice knows that Bob
    sent it, because he is the only one with access to the private key. In addition,
    Bob can’t later say that he didn’t send the document, because the key pair is
    unique to him. Unless Bob’s private key is compromised, no other person could
    have used it to encrypt the information.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密对于证明某人就是他们所说的那个人，并防止他们否认自己发送了某个信息，也非常有益，这个概念叫做*不可否认性*。假设鲍勃审阅了文档，表示文档看起来不错，然后将其发回给艾丽丝。艾丽丝想要确认是鲍勃而不是某个冒充鲍勃的人发送了文档。为了使用非对称加密做到这一点，鲍勃可以用他的私钥加密文档的哈希值，并将其发送给艾丽丝（我们将在第166页的《哈希》一章中讨论哈希）。只有鲍勃的公钥可以解密该文件。如果解密成功，艾丽丝就知道是鲍勃发送的，因为他是唯一拥有私钥的人。此外，鲍勃以后不能否认自己没有发送文档，因为密钥对是唯一的，属于他自己。除非鲍勃的私钥被泄露，否则没有其他人能够使用它来加密信息。
- en: Much like in symmetric cryptography, many different algorithms use asymmetric
    keys. However, these algorithms don’t use block or stream ciphers. Instead, they
    rely on extremely complex math problems to create their key pairs. For example,
    one of the first asymmetric algorithms worked by calculating discrete logarithms.
    Another uses the factoring of large prime numbers. Although the details of these
    math problems are outside the scope of this book, the keys are the numbers required
    to solve the problems. The problems are so complex that, without the numbers,
    it would take a very long time for a computer to calculate the values necessary
    to solve them. This is what creates the algorithm’s work factor.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 很像对称加密，许多不同的算法也使用非对称密钥。然而，这些算法不使用分组密码或流密码。相反，它们依赖于极其复杂的数学问题来生成密钥对。例如，其中一个最早的非对称算法通过计算离散对数来实现。另一个则使用大素数的因数分解。尽管这些数学问题的细节超出了本书的范围，但密钥是解决问题所需的数字。这些问题非常复杂，以至于没有这些数字，计算机需要花费很长时间才能计算出解决问题所需的值。这就是算法的工作量因素。
- en: For a long period of time, the de facto standard for asymmetric cryptography
    was an algorithm known as *Rivest–Shamir–Adleman (RSA)*. Named after its inventors,
    RSA was the most widely used public key cryptography algorithm on the internet
    from 2000 to 2013\. Its main key size was 1024 bits, which is much larger than
    the keys symmetric cryptography uses. In recent years RSA has fallen out of favor,
    because in 2013 it was proven that the US government could crack 1024-bit RSA
    keys using supercomputers. Since then, most systems use either a 2048-bit key,
    which is substantially more complex, or another algorithm.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间以来，非对称加密的事实标准是一个叫做 *Rivest–Shamir–Adleman (RSA)* 的算法。RSA以其发明者命名，从2000年到2013年，它是互联网上最广泛使用的公钥加密算法。其主要的密钥长度是1024位，这比对称加密所使用的密钥要大得多。近年来，RSA逐渐失宠，因为2013年证明美国政府可以使用超级计算机破解1024位的RSA密钥。从那时起，大多数系统使用2048位密钥，这要复杂得多，或者使用其他算法。
- en: One of the more popular replacements for RSA is *Elliptical Curve Cryptography
    (ECC)*. Although asymmetric cryptography is much slower than symmetric cryptography
    and creates substantially larger files, ECC is one of the fastest asymmetric algorithms.
    It can encrypt files 10 times faster than RSA. ECC also doesn’t require nearly
    as much processor power to use. Its typical key size is 160 bits, but it can also
    use 256-bit keys. As a result, we can implement ECC on devices that don’t have
    a lot of memory, such as IoT devices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: RSA的一个更受欢迎的替代品是 *椭圆曲线加密（ECC）*。尽管非对称加密比对称加密慢得多，且生成的文件要大得多，但ECC是最迅速的非对称算法之一。它可以比RSA快10倍加密文件。ECC还不需要消耗大量的处理器能力。它的典型密钥长度是160位，但也可以使用256位密钥。因此，我们可以在内存有限的设备上实现ECC，例如物联网设备。
- en: Validating Public Keys
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证公钥
- en: After reading about public key cryptography, you might be wondering how Alice
    initially gets Bob’s public key. This is a bigger problem than you might first
    expect, because although it doesn’t matter who receives that public key, you must
    make sure that you’re using the correct public key for the message’s recipient.
    Doing so is especially important when communicating across the internet, because
    you have no idea whether the recipient is the person you think they are. They
    might be a black hat pretending to be someone else. The two main ways to verify
    public keys are *webs of trust* and *certificate authorities*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读有关公钥加密的内容后，你可能会想知道爱丽丝最初是如何获得鲍勃的公钥的。这比你最初想象的要复杂，因为虽然接收公钥的人不重要，但你必须确保你使用的是正确的公钥来发送消息。特别是在互联网上交流时，这一点尤为重要，因为你根本无法确定接收方是否就是你认为的那个人。他们可能是一个黑帽黑客，伪装成别人。验证公钥的两种主要方法是
    *信任网* 和 *证书授权机构*。
- en: Webs of Trust
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 信任网
- en: A web of trust is a network of trusted individuals in which each person vouches
    for the people to whom they’re connected in the web. For example, Alice knows
    Bob in real life and trusts him, so she creates a trusted link between her and
    Bob, and her system accepts Bob’s public key. Bob not only trusts Alice but also
    Charlie. Therefore, Alice also trusts Charlie, because her trust of Bob transfers
    to every person Bob trusts (which also includes Danielle, Eric, and Frankie in
    the web).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 信任网是一个由受信任的个体组成的网络，每个人都为他们在网络中所连接的人担保。例如，爱丽丝在现实生活中认识鲍勃并信任他，因此她在自己和鲍勃之间建立了一个受信任的链接，她的系统接受鲍勃的公钥。鲍勃不仅信任爱丽丝，还信任查理。因此，爱丽丝也信任查理，因为她对鲍勃的信任转移到鲍勃信任的每个人（这也包括网络中的丹妮尔、埃里克和弗兰基）。
- en: Although the web of trust works well for small organizations that don’t want
    a centrally managed trust system, it doesn’t work well on the internet. With the
    billions of people using the internet, it would be nearly impossible to make sure
    that every person in the web of trust was trustworthy. Adversaries could easily
    exploit the web to trick people into sending them sensitive information. Therefore,
    only a few applications use the web of trust system. One of the most famous is
    called *Pretty Good Privacy* *(PGP**)*. PGP is an encryption system primarily
    used to encrypt email. It was created as an alternative to centralized trust solutions
    that might become compromised or snooped on by government or private organizations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管信任网络对于那些不希望使用集中管理的信任系统的小型组织来说效果很好，但它在互联网中并不适用。随着数十亿人使用互联网，几乎不可能确保信任网络中的每个人都是可信的。对手很容易利用信任网络来欺骗他人，诱使他们发送敏感信息。因此，只有少数应用程序使用信任网络系统。其中一个最著名的应用叫做*Pretty
    Good Privacy*（*PGP*）。PGP是一种主要用于加密电子邮件的加密系统。它作为一种替代方案应运而生，目的是避免集中式信任解决方案可能会受到政府或私人组织的破坏或监听。
- en: Certificate Authorities
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 证书颁发机构
- en: The vastly more popular way to verify that public keys are authentic is to use
    a *digital certificate*.Similar to a high school or college diploma, a digital
    certificate is a document that verifies that the public key you received truly
    did come from the person who sent it. To maintain and manage a digital certificate,
    a person uses the services of a *certificate authority* *(CA**)*, a third-party
    organization that creates, manages, and validates certificates for individuals
    or organizations. Essentially, it tells you whether a public key can be trusted.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 验证公钥是否真实有效的更流行的方式是使用*数字证书*。类似于高中或大学文凭，数字证书是一种文档，验证你收到的公钥确实来自发送它的人。为了维护和管理数字证书，个人需要使用*证书颁发机构*（*CA*），这是一家为个人或组织创建、管理和验证证书的第三方机构。本质上，它告诉你是否可以信任一个公钥。
- en: CAs provide several different services. One is that they create certificates
    for people or organizations. When an organization, for example Sparkle Kitten
    Inc., wants to use public key encryption for its website, it chooses a CA to provide
    the company with a certificate. That CA then verifies that Sparkle Kitten Inc.
    is a legitimate company and that the person requesting the certificate in fact
    represents Sparkle Kitten Inc. Once they’ve done so and received a fee, the CA
    creates the digital certificate and provides a copy to the company. The CA also
    creates the public/private key pair that accompanies the certificate. Typically,
    these certificates expire in a year, at which point anyone who has the certificate
    will receive a warning. Be mindful of expiring certificates when you’re visiting
    a site. Even though the owner might just have forgotten to renew their certificate,
    black hats can use expired certificates to trick you into connecting to an unsafe
    website.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 证书颁发机构提供几种不同的服务。其中一项是它们为个人或组织创建证书。例如，当一个组织（比如Sparkle Kitten Inc.）希望在其网站上使用公钥加密时，它会选择一个证书颁发机构来为该公司提供证书。该证书颁发机构随后验证Sparkle
    Kitten Inc.是一个合法公司，并且请求证书的人确实代表Sparkle Kitten Inc. 一旦完成验证并收取费用，证书颁发机构会创建数字证书并提供副本给公司。证书颁发机构还会创建与证书一起使用的公钥/私钥对。通常，这些证书的有效期为一年，到期后，任何持有证书的人都会收到警告。在访问网站时，要注意过期的证书。即使网站所有者可能只是忘记续期证书，黑客也可以利用过期的证书来欺骗你连接到不安全的网站。
- en: Another service CAs provide is key management and recovery. Let’s say that Sparkle
    Kitten Inc. encrypts its entire database using a symmetric key and then encrypts
    that symmetric key using its CA-issued public key (a common practice for sharing
    symmetric keys across the internet). The private key would be the only way to
    access the symmetric key and decrypt the database. Now, let’s say that one of
    the resident company cats knocks the system that stores the private key out a
    window, destroying the hard drive so no data can be recovered from it. Without
    the key, the data encrypted on the database would be lost forever. Fortunately,
    CAs can retain copies of the public/private key pairs they create in highly secure
    vaults for just such emergencies, if they provide this service and you pay an
    additional charge for it. Once Sparkle Kitten Inc. provides the authentication
    materials needed to prove that it legitimately owns the key, the CA releases the
    private key back to the company, allowing it to recover the database.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 证书授权机构（CA）提供的另一个服务是密钥管理和恢复。假设Sparkle Kitten Inc.使用对称密钥加密了整个数据库，然后使用其CA颁发的公钥对该对称密钥进行加密（这是一种常见的通过互联网共享对称密钥的做法）。私钥将是唯一可以访问对称密钥并解密数据库的方法。现在，假设公司的一只常驻猫把存储私钥的系统从窗户上撞了出去，摧毁了硬盘，导致无法从中恢复任何数据。没有密钥，数据库中加密的数据将永远丢失。幸运的是，CA可以将它们创建的公钥/私钥对保存在高度安全的保险库中，以备不时之需，如果它们提供此服务，并且你为此支付了额外费用。一旦Sparkle
    Kitten Inc.提供所需的认证材料，证明它合法拥有密钥，CA就会将私钥释放回公司，使其能够恢复数据库。
- en: Additionally, CAs provide a highly managed repository of all the publicly available
    certificates that they manage. This allows anyone on the internet to validate
    that the public key sent to them is from the right person. For example, when a
    customer goes to Sparkle Kitten Inc.’s website, they will receive a digital certificate
    and a public key to use to secure the connection. The customer’s browser will
    then contact the CA that issued the certificate to verify that the certificate
    came from that specific CA. If the CA verifies it as authentic, the browser can
    trust the public key that was sent to it. CAs maintain lists of bad certificates
    and routinely update their lists so adversaries can’t use compromised or outdated
    certificates.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CA还提供了一个高度管理的所有公开证书的存储库，供它们管理的所有证书公开使用。这使得互联网上的任何人都可以验证发送给他们的公钥是否来自正确的人。例如，当客户访问Sparkle
    Kitten Inc.的网站时，他们将收到一个数字证书和一个公钥，用于保护连接。然后，客户的浏览器将联系颁发证书的CA，以验证该证书是否来自该特定CA。如果CA验证它是真实的，浏览器就可以信任发送给它的公钥。CA还会维护不良证书的列表，并定期更新这些列表，以防止对手使用被破坏或过时的证书。
- en: Hashing
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希
- en: One of the most widely used forms of cryptography is *hashes*, which are one-way
    cryptographic functions that always provide the same encrypted output given the
    same input. Once data is encrypted using a hashing algorithm, it can never be
    decrypted. For example, if I put the word *CAT* through a hashing algorithm, the
    output might be `x5d7nt2k`. Every time I put the word CAT into the algorithm,
    it will come out the same. But if I change even one letter, say creating the word
    *PAT*, the entire ciphertext will change to a completely different output; for
    example, `l3loi2jd`. Even changing a letter’s case, say from a capital *C* to
    a lowercase *c*, would substantially change the ciphertext. This is known as the
    *waterfall effect*, and it’s one of the main purposes of hashing algorithm; that
    is, making sure that even the most minor change creates a vastly different ciphertext.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学中最广泛使用的一种形式是*哈希*，它是一种单向加密函数，给定相同的输入总是提供相同的加密输出。一旦数据使用哈希算法进行加密，它就无法再被解密。例如，如果我将单词*CAT*输入哈希算法，输出可能是`x5d7nt2k`。每次将单词CAT输入该算法时，输出结果都会相同。但如果我改变一个字母，比如将单词改为*PAT*，整个密文将变成完全不同的输出；例如，`l3loi2jd`。即使只改变字母的大小写，比如将大写的*C*改为小写的*c*，密文也会发生实质性的变化。这种现象被称为*瀑布效应*，它是哈希算法的主要目的之一；也就是说，确保即使是最微小的变化也会产生完全不同的密文。
- en: It might be difficult at first to understand why we need an algorithm that always
    creates the same output and can’t be reversed. One of the reasons hashing is useful
    is that it provides a way to verify that information is authentic without revealing
    the information. For example, we use hashing to verify passwords. Rather than
    storing passwords in plaintext—an incredibly unsafe practice that makes them easy
    to compromise—applications usually put passwords through a hashing algorithm and
    then store the hash. When users want to log in to their accounts, they enter their
    passwords, which get put through the same type of hashing algorithm. Instead of
    sending the password in plaintext, the application sends the hash over the network.
    When it reaches the system, it compares that hash to the one stored in its database.
    Because a hashing algorithm’s output never changes if the input is the same, the
    system knows that the user entered the correct password if the hashes match. Also,
    this means the user is the only one who knows the value of the password in plaintext
    form.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，可能难以理解为什么我们需要一个始终生成相同输出且无法反向操作的算法。哈希算法的一个有用之处在于，它提供了一种验证信息真实性的方法，而不会泄露信息。例如，我们使用哈希算法来验证密码。与其以明文存储密码（这是一种极不安全的做法，容易被攻击者窃取），应用程序通常会将密码经过哈希算法处理后再存储哈希值。当用户想要登录他们的账户时，输入的密码会通过相同类型的哈希算法处理。应用程序并非以明文形式发送密码，而是发送哈希值通过网络传输。当哈希值到达系统后，系统将其与存储在数据库中的哈希值进行比较。由于哈希算法的输出在输入相同时永远不会改变，系统如果匹配的哈希值相同，则知道用户输入了正确的密码。此外，这意味着用户是唯一知道密码明文值的人。
- en: We also use hashing to verify files. I can run a file, such as a piece of software,
    through a hashing algorithm to get a hash and then distribute that hash to the
    public. When someone downloads my software, they can run it through the same hashing
    algorithm and compare it to the hash I provided. If both are the same, they know
    that it’s the original software and hasn’t been modified by another person, perhaps
    by adding malicious code like a virus.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用哈希算法来验证文件。我可以通过哈希算法运行文件（如软件）以获得哈希值，然后将该哈希值分发给公众。当有人下载我的软件时，他们可以将其通过相同的哈希算法运行，并将其与我提供的哈希值进行比较。如果两者相同，他们就知道这是原始软件，并且未被其他人修改，例如添加恶意代码如病毒。
- en: Many hashing algorithms are available for public use. The first algorithm to
    gain popularity was Message Digest 5 (MD5). MD5 had a *digest size* of 128 bits,
    which means that its output was always 128 bits long, no matter how much data
    was input. Although this might seem like a lot of bits, it’s not nearly enough
    to prevent an attacker from crackingthe hash (more on this topic in “How Black
    Hats Break Hashes” on page 171). Due to MD5’s flaws, security professionals replaced
    it with Secure Hashing Algorithm 1 (SHA-1). SHA-1 has a digest size of 160 bits,
    which, although better than MD5, is still too small to survive modern hacking
    techniques. Currently, we use either the SHA-2 or SHA-3 algorithms. Both have
    much larger digest sizes, typically 256 or 512 bits.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 许多哈希算法可供公众使用。首个获得广泛认可的算法是消息摘要 5（MD5）。MD5 的 *摘要大小* 是 128 位，这意味着其输出始终为 128 位，无论输入数据量大小如何。尽管这看起来是很多位，但并不足以防止攻击者破解哈希值（有关此主题的更多信息，请参阅第
    171 页上的“黑客如何破解哈希值”）。由于 MD5 的缺陷，安全专家将其替换为安全哈希算法 1（SHA-1）。SHA-1 的摘要大小为 160 位，虽然比
    MD5 好，但仍然不足以抵御现代黑客技术的攻击。目前，我们使用的是 SHA-2 或 SHA-3 算法。两者的摘要大小通常为 256 或 512 位。
- en: It’s also important to note that users usually don’t have to do anything to
    use a hashing algorithm. Hashing occurs as part of normal communication between
    your computer and an application or server. In fact, your computer doesn’t even
    choose which algorithm it uses; instead, the service to which it’s connecting
    decides which one it should use.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还需注意的是，通常用户无需做任何事情即可使用哈希算法。哈希过程是计算机与应用程序或服务器之间正常通信的一部分。事实上，您的计算机甚至不会选择使用哪种算法；相反，连接的服务决定应该使用哪种算法。
- en: What Happens When You Visit a Website?
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问网站时发生了什么？
- en: 'Now that you’ve learned about the different types of modern cryptography, let’s
    revisit what we know about encrypted traffic flowing across the internet. Let’s
    say you want to visit a secure website, such as sparklekitten.net. First, the
    Sparkle Kitten web server sends you a digital certificate. This certificate includes
    three pieces of important information: the public key for that web server, the
    type of symmetric key algorithm it will accept, and the CA that created the certificate.
    Then your system verifies that the certificate is legitimate by contacting the
    CA (or checks whether it’s signed by an already trusted CA, such as a trusted
    root authority).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了不同类型的现代加密技术，让我们回顾一下我们所知道的通过互联网传输的加密流量。假设你想访问一个安全的网站，例如sparklekitten.net。首先，Sparkle
    Kitten的Web服务器会向你发送一个数字证书。该证书包含三项重要信息：该Web服务器的公钥、它将接受的对称密钥算法类型以及创建该证书的证书颁发机构（CA）。然后，你的系统通过联系CA来验证证书的合法性（或检查证书是否由已经信任的CA签名，例如一个受信的根证书机构）。
- en: If the CA validates the certificate, your system creates a symmetric key using
    the algorithm the web server dictates. Because public key encryption is so slow,
    you must use a symmetric key to send data efficiently to sparklekitten.net. However,
    to be secure,sparklekitten.net can’t directly send you a symmetric key, because
    any black hat intercepting traffic from the web server could capture it and break
    the encryption. Instead, you create a symmetric key and use sparklekitten.net’s
    public key to encrypt it. Now only sparklekitten.net’s private key can decrypt
    the symmetric key. You also send a hash of all the data you just sent to sparklekitten.net
    to use as an integrity check.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CA验证了证书，你的系统就会使用Web服务器指定的算法生成对称密钥。由于公钥加密速度较慢，必须使用对称密钥来高效地将数据发送到sparklekitten.net。然而，为了保证安全，sparklekitten.net不能直接将对称密钥发送给你，因为任何拦截Web服务器流量的黑帽黑客都可能捕获并破解加密。相反，你会生成一个对称密钥，并使用sparklekitten.net的公钥加密它。现在，只有sparklekitten.net的私钥能够解密该对称密钥。你还会将你刚刚发送给sparklekitten.net的所有数据的哈希值发送过去，用作完整性检查。
- en: Once sparklekitten.net’s web server receives the encrypted symmetric key, it
    decrypts the key using its private key. Then the web server uses the hash to verify
    the key’s integrity. If everything looks good, the web server confirms the connection,
    allowing you and sparklekitten.net to communicate securely using the same symmetric
    key. This entire process usually takes less than a second to complete. [Figure
    9-3](#figure9-3) provides a breakdown of how this communication works.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦sparklekitten.net的Web服务器接收到加密的对称密钥，它就会使用自己的私钥解密该密钥。然后，Web服务器使用哈希值验证密钥的完整性。如果一切正常，Web服务器会确认连接，允许你和sparklekitten.net使用相同的对称密钥安全地进行通信。整个过程通常不到一秒钟就可以完成。[图9-3](#figure9-3)提供了该通信方式的详细说明。
- en: '![f09003](image_fi/501287c09/f09003.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![f09003](image_fi/501287c09/f09003.png)'
- en: 'Figure 9-3: Creating a secure connection with a website'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3：与网站建立安全连接
- en: Although we use hashing and symmetric and asymmetric cryptography in a variety
    of ways, securing communications, as in the preceding website example, is one
    of the more common uses. The main aspect to remember is that systems usually handle
    keys and encryption in the background. As a user, you don’t need to do anything
    to secure your system using the power of encryption. In fact, you might not even
    realize it’s happening, making encryption simple, fast, and effective for all
    users. However, this lack of awareness can lead to attacks by adversaries you
    might not even know about.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在多种方式中使用哈希和对称加密与非对称加密来保护通信，正如前面网站示例所示，保护通信是其中最常见的应用之一。需要记住的主要方面是，系统通常在后台处理密钥和加密。作为用户，你不需要做任何事情就能利用加密的强大功能来保护系统。事实上，你可能甚至没有意识到它正在发生，这使得加密对所有用户而言既简单又快速且有效。然而，这种缺乏意识可能导致你甚至不知道的攻击。
- en: How Black Hats Steal Your Keys
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑帽如何窃取你的密钥
- en: Circumventing encryption is a central part of being a black hat. An attacker
    can work around the security encryption provides in many ways, most of which involve
    another type of attack, such as social engineering, which renders the presence
    of encryption irrelevant. For example, you might have full-disk encryption on
    your hard drive, but if an adversary tricks you into revealing the pin code or
    password you use to access the drive, it doesn’t matter how strong the encryption
    is. This is also true if they can trick you into negotiating an encrypted connection
    with them instead of with a legitimate service, as is the case in many man-in-the-middle
    attacks. If this situation occurs, you share the symmetric key you generate with
    the adversary, allowing them to decrypt your traffic before passing it on to the
    legitimate service.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过加密是黑客行为的核心部分。攻击者可以通过多种方式绕过加密提供的安全性，其中大多数方式涉及另一种类型的攻击，如社会工程学，这使得加密的存在变得无关紧要。例如，您可能对硬盘进行了全盘加密，但如果攻击者诱使您透露用于访问硬盘的
    PIN 码或密码，那么无论加密多么强大，都没有意义。如果攻击者能够欺骗您与他们而非合法服务建立加密连接，这种情况也是一样的，这在许多中间人攻击中都有发生。如果发生这种情况，您与对方共享生成的对称密钥，允许他们在将流量转发给合法服务之前解密您的流量。
- en: Attackers can also steal keys stored on hardware, especially those that applications
    use. Keys stored on hardware are generally harder to compromise because the attacker
    usually has to physically interact with the system to steal those keys. For example,
    your keys might be stored on a USB drive that needs to be plugged in for them
    to access those keys. If the adversary doesn’t have the USB drive, they can’t
    get the keys. Certain vulnerabilities, such as errors in memory storage or problems
    with how CPUs access information, have made it possible to access keys stored
    on hardware, although these are normally very rare and difficult to exploit.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者还可以窃取存储在硬件上的密钥，尤其是应用程序使用的密钥。存储在硬件上的密钥通常更难被破解，因为攻击者通常需要与系统进行物理交互才能窃取这些密钥。例如，您的密钥可能存储在一个
    USB 驱动器中，必须将其插入才能访问这些密钥。如果对方没有 USB 驱动器，他们就无法获取这些密钥。某些漏洞，如内存存储中的错误或 CPU 访问信息时出现的问题，使得存储在硬件上的密钥有可能被访问，尽管这些漏洞通常非常罕见且难以利用。
- en: These attacks against hardware don’t attack the encryption algorithm but instead
    affect its implementation. Many cryptography compromises are caused by flaws in
    how the encryption ran at the time of use rather than how the algorithm is supposed
    to run in a perfect situation. One of the most famous examples is the wireless
    encryption standard WEP. It used the RC4 algorithm but chose an extremely small
    key space and reused information to create keys. This led to a compromise of the
    standard, even though the underlying algorithm was strong.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些针对硬件的攻击并不是攻击加密算法本身，而是影响了加密算法的实现。许多密码学漏洞是由于加密算法在使用时的运行方式存在缺陷，而非算法在理想状态下应如何运行。例如，最著名的例子之一是无线加密标准
    WEP。它使用了 RC4 算法，但选择了一个极小的密钥空间并重用信息来生成密钥。这导致了该标准的漏洞，尽管底层算法本身是强大的。
- en: Cryptanalysis
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码分析
- en: The study of cryptography and how to break it is known as *cryptanalysis*.Modern
    cryptanalysis searches the inner workings of an encryption algorithm for any possible
    flaw that might reveal the plaintext of an encrypted message. This includes not
    just methods for finding the key, but also ways to decode the plaintext without
    revealing the key.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 研究密码学及其破解方法被称为*密码分析*。现代密码分析通过检查加密算法的内部工作原理，寻找任何可能揭示加密消息明文的缺陷。这不仅包括寻找密钥的方法，还包括在不暴露密钥的情况下解码明文的方法。
- en: Researchers use a variety of techniques during cryptanalysis. One such technique
    is brute-force analysis. As mentioned earlier, any algorithm can be broken given
    enough time. The problem is, if brute-forcing the algorithm takes a long time—say,
    years or decades—the information obtained upon breaking it might no longer be
    useful. Therefore, brute-force analysis also includes methods to reduce the time
    it takes to correctly guess a key by exploiting flaws in how algorithms process
    information. For example, 3DES’s main flaw was that, at its core, it used three
    different DES keys during its encryption process. By analyzing the algorithm,
    researchers found they could isolate each key separately, essentially turning
    them into normal 56-bit DES keys, which could then be broken using traditional
    brute-force techniques, thus neutralizing the strength of 3DES. This attack became
    known as *meet-in-the-middle* (not to be confused with man-in-the-middle).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员在密码分析中使用多种技术，其中一种技术是暴力破解分析。如前所述，任何算法都可以被破解，只要时间足够。问题在于，如果暴力破解算法需要很长时间——比如说，几年或几十年——那么破解后获得的信息可能不再有用。因此，暴力破解分析还包括一些方法，利用算法处理信息时的漏洞，来减少正确猜测密钥所需的时间。例如，3DES的主要漏洞在于其核心使用了三个不同的DES密钥进行加密过程。通过分析该算法，研究人员发现他们可以分别隔离每个密钥，实际上将其转化为普通的56位DES密钥，然后可以使用传统的暴力破解技术来破解，从而削弱了3DES的强度。这种攻击被称为*meet-in-the-middle*（不要与man-in-the-middle混淆）。
- en: Another cryptanalysis technique is analyzing how plaintext is converted to ciphertext.
    One of the more common ways of doing this is by using *differential analysis*,
    which focuses on differences in plaintext inputs and ciphertext outputs. This
    method creates various plaintext inputs to a cipher, all identical except for
    a controlled variable, such as a varying number in each input. The researcher
    then analyzes the ciphertext output and looks for statistical patterns based on
    the plaintexts used. Another analysis technique is *integral analysis*, which
    considers a block cipher’s substitution method, looking for statistical patterns
    in how a cipher manages its substitution. Both types of analysis can often discover
    exploitable flaws, such as the meet-in-the-middle flaw mentioned previously.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种密码分析技术是分析明文如何转换为密文。常见的做法之一是使用*差分分析*，它侧重于明文输入和密文输出之间的差异。该方法创建多种明文输入，除了一个受控变量（例如，每个输入中的数字不同）外，其他都相同。研究人员随后分析密文输出，并根据使用的明文寻找统计模式。另一种分析技术是*积分分析*，它考虑块密码的替代方法，寻找加密算法在管理替代过程中产生的统计模式。这两种分析方法通常可以发现可以利用的漏洞，例如之前提到的meet-in-the-middle漏洞。
- en: Cryptanalysis doesn’t just focus on how the algorithm encrypts plaintext; it
    also looks at how it interacts with the systems around it. A *side-channel attack*
    focuses on elements that are outside the algorithm, such as its power consumption,
    timing, and even any sounds the encryption process generates that could potentially
    lead to the discovery of critical flaws.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 密码分析不仅关注算法如何加密明文；它还关注算法与周围系统的互动。*侧信道攻击*侧重于算法外部的元素，如功耗、时序，甚至加密过程生成的声音，这些都可能导致发现关键的漏洞。
- en: Asymmetric Algorithm Attacks
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非对称算法攻击
- en: Although many cryptanalysis techniques work equally well on symmetric and asymmetric
    algorithms, the nature of public key cryptography makes it more vulnerable to
    brute-force attacks. Because asymmetric algorithms rely on complex mathematics
    to create their key pairs, adversaries could potentially use any method that helps
    solve a problem faster to break an asymmetric algorithm. For example, your algorithm
    might rely on the difficulty of calculating discrete logarithms, creating keys
    from the numbers required to calculate the discrete logarithm between a pair of
    numbers chosen at random. If a mathematician finds a faster way to do this, they
    might significantly reduce the work factor of your algorithm.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多密码分析技术在对称和非对称算法上同样有效，但公钥密码学的特性使其更容易受到暴力破解攻击。由于非对称算法依赖于复杂的数学运算来生成密钥对，攻击者可能会利用任何能够加速问题求解的方法来破解非对称算法。例如，你的算法可能依赖于计算离散对数的难度，通过需要计算离散对数的数字来生成密钥，这些数字是从一对随机选择的数字中获得的。如果一个数学家找到了一种更快速的方法来计算离散对数，他们可能会显著降低你算法的工作难度。
- en: The security of RSA was diminished when Edward Snowden, an NSA contractor, revealed
    that supercomputers could accomplish the factoring of prime numbers required to
    create the public/private key pair. This meant that the typical key length of
    1024 bits was no longer viable, and the algorithm had to use 2048-bit keys to
    be secure. As computer processors continue to increase in power, asymmetric cryptography
    must constantly update its algorithms and standards to avoid being broken.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: RSA的安全性在爱德华·斯诺登（Edward Snowden）——一名美国国家安全局承包商——揭露出超级计算机可以完成素数分解，从而创建公钥/私钥对后受到了削弱。这意味着传统的1024位密钥长度不再可行，算法必须使用2048位密钥才能保持安全。随着计算机处理器的持续增强，非对称加密必须不断更新其算法和标准，以避免被破解。
- en: Protecting Your Keys
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护你的密钥
- en: To keep keys safe, many cryptographic algorithms use an *initialization vector*
    *(IV**)*. An IV consists of random bits that the algorithm adds to the key before
    encrypting the data. This ensures that even data encrypted with the same key follows
    different encryption processes. IVs are a great way to protect against cryptanalysis,
    because they omit patterns from encrypted data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护密钥，许多加密算法使用*初始化向量*（*IV*）。初始化向量由算法在加密数据之前添加到密钥中的随机位组成。这确保即使是用相同密钥加密的数据，也遵循不同的加密过程。初始化向量是保护加密分析的一个好方法，因为它们能避免加密数据中出现规律。
- en: Another way to protect keys is to limit how often you reuse them. Because keys
    are more likely to be cracked when used frequently, it’s best to change them as
    often as possible. You can do this by using a *session key*, which encrypts data
    during a single session only, such as during a connection to Google. As soon as
    you close the Google window or a certain timeout is reached, the session is over
    and the platform destroys the key. That way, even if an attacker somehow obtains
    the key during the session, they won’t be able to use it to decrypt future communications.
    We often use symmetric keys, such as those created during the connection to sparklekitten.net
    discussed earlier in the chapter, as session keys to secure communications on
    the internet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 保护密钥的另一种方式是限制它们的重用频率。由于密钥在频繁使用时更容易被破解，因此最好尽可能频繁地更换密钥。你可以通过使用*会话密钥*来做到这一点，*会话密钥*仅在单个会话期间加密数据，例如在连接到谷歌时。一旦你关闭谷歌窗口或达到某个超时，*会话*就结束了，平台会销毁该密钥。这样，即使攻击者在会话期间获得了密钥，他们也无法用它解密未来的通信。我们通常使用对称密钥，如本章早些时候讨论的在连接到sparklekitten.net时创建的密钥，作为会话密钥来保护互联网通信。
- en: 'We must also periodically change asymmetric keys. Typically, this occurs on
    a yearly basis as part of normal certificate renewal, but you can do it more often.
    A good rule to adhere to when deciding when to update asymmetric keys is that
    the more traffic is encrypted using the key, the sooner it needs to be changed:
    a key used twice a year has much less exposure than one used thousands of times
    a month (or, in the case of a big company like Google, thousands of times a second).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须定期更换非对称密钥。通常，这会在每年进行一次，作为正常证书续期的一部分，但你也可以更频繁地更换。决定何时更新非对称密钥的一个好规则是，使用该密钥加密的流量越多，它需要更早更换：每年使用两次的密钥比每月使用数千次的密钥（或者像谷歌这样的公司每秒使用数千次的密钥）暴露的风险要小得多。
- en: How Black Hats Break Hashes
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑帽如何破解哈希值
- en: We often use hashes to check the integrity of certain data, such as a password.
    By their very nature, hashes aren’t reversible. The hashing algorithm only creates
    a hash; it can’t be used to decrypt it. So, most normal cryptanalysis attacks
    won’t work on hashing algorithms. However, hashes aren’t invulnerable to attack.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用哈希值来检查某些数据的完整性，如密码。由于哈希值本质上是不可逆的，哈希算法仅生成一个哈希值，不能用于解密。因此，大多数常见的密码分析攻击对哈希算法不起作用。然而，哈希值并非不可攻破。
- en: 'The main way that adversaries break hashes is by using brute-force techniques.
    This can be as simple as creating a table containing the hashes of random but
    plausible inputs and then comparing the hash they’re trying to break to the hashes
    in the table. Once they find the hash, they know that they’ve correctly guessed
    the input. But given the amount of inputs possible—a near infinite quantity—this
    approach is rarely effective unless they have information to narrow down the possible
    results, perhaps by using other password-cracking techniques, like a dictionary
    attack or social engineering. But hashes do have a critical flaw that makes them
    easier to brute-force than other encryption keys: that flaw is *collisions*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对手破解哈希的主要方式是使用暴力破解技术。方法可能很简单，比如创建一个包含随机但可能的输入的哈希表，并将其与他们要破解的哈希进行比较。一旦找到哈希，他们就知道自己已经正确猜出了输入。但考虑到可能的输入数量——几乎是无限的——这种方法很少有效，除非他们拥有一些信息来缩小可能的结果范围，可能通过使用其他密码破解技术，如字典攻击或社会工程学。然而，哈希确实存在一个关键的漏洞，使其比其他加密密钥更容易被暴力破解：这个漏洞就是*碰撞*。
- en: 'A collision occurs when two inputs create the same hash output. For example,
    by random chance, the words *sparkle* and *kitten* might both create the hash
    `f90ab7`. Collisions in hashing algorithms reduce the amount of time it takes
    to reverse a hash. Think of it this way: if you had a list of 10 items that you
    had to get at the grocery store, and each item was in a different part of the
    store, it would take you, say, 20 minutes to find them all. But if two of the
    items were right next to each other on the shelf, it would reduce the time it
    took to find all the items. The more items that were next to each other, the less
    time it would take to find them all. The more collisions there are in the hashing
    algorithm, the less time it takes an attacker to go through the various combinations
    to find the one they’re looking for. Finding a collision can effectively halve
    the amount of time necessary to guess the input given a specific hash output.
    More collisions reduce that time further.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个输入产生相同的哈希输出时，就发生了碰撞。例如，随机情况下，单词*sparkle*和*kitten*可能都会生成哈希`f90ab7`。哈希算法中的碰撞会减少破解哈希所需的时间。可以这样理解：假设你有一个需要在超市购买的10个物品清单，而这些物品分布在商店的不同位置，可能需要花费20分钟才能找到所有物品。但如果其中有两个物品就放在靠近的货架上，找到它们所需的时间就会减少。物品之间越是靠得近，找到它们的时间就越短。哈希算法中的碰撞越多，攻击者通过各种组合找到目标的时间就越短。找到一个碰撞可以有效地将猜测输入的时间减半。碰撞越多，所需的时间就越少。
- en: Stronger hashing algorithms generate fewer collisions and thus take longer to
    break. But as a workaround, black hats use a technique that requires a special
    tool known as a *rainbow table*.Essentially, a rainbow table is a table of precomputed
    hashes that have been grouped together by hash output to make a specific output
    easier to find. So if I have the hash `4fd3cd`, the table will attempt to isolate
    that hash into a specific group of outputs and find the password that created
    the hash in that group. Once the table finds the password, I can run it through
    the hashing algorithm to confirm it’s correct.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更强的哈希算法会生成较少的碰撞，因此破解所需的时间更长。但作为一种变通方法，黑帽黑客使用一种需要特殊工具的技术，这种工具被称为*彩虹表*。本质上，彩虹表是一个预先计算的哈希表，它通过哈希输出将哈希值分组，从而使特定输出更容易找到。因此，如果我有一个哈希值`4fd3cd`，该表会尝试将这个哈希值孤立成一个特定的输出组，并找到在该组中生成此哈希的密码。一旦表格找到密码，我就可以通过哈希算法确认它是否正确。
- en: Salting Your Hashes
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给你的哈希添加盐
- en: The MD5 algorithm is extremely susceptible to collision attacks. It can take
    seconds, given the right information, to break one of its hashes. SHA-1, although
    more secure than MD5, is also susceptible. SHA-2 and SHA-3 are more secure due
    to their hash size. Another way to strengthen hashes is to use salt. Like an IV,
    a salt is a series of random bits that we add to an input before hashing it. This
    procedure creates a unique hash that is completely different from the unsalted
    input.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: MD5算法极易受到碰撞攻击。在拥有正确的信息的情况下，破解其哈希只需几秒钟。SHA-1虽然比MD5更安全，但也容易受到攻击。SHA-2和SHA-3由于其哈希大小，更加安全。增强哈希安全的另一种方法是使用盐。像初始化向量（IV）一样，盐是一串随机位，在对输入进行哈希之前，我们将其添加到输入中。这一过程会生成一个独特的哈希，与未加盐的输入完全不同。
- en: As an example, let’s say the input *kitten* creates the hash `f903d`. To keep
    the hash more secure, my system might hash *kitten* by adding a random set of
    numbers to the end, making the input something like *kitten123* (although, in
    practice, it would add bits to the input’s binary representation rather than decimal
    digits). Because the system adds new numbers to *kitten* every time it hashes
    that input, the hash is different every time. This process also makes it harder
    to group hashes together in a rainbow table because the output isn’t directly
    connected to the original plaintext that was hashed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设输入*kitten*生成的哈希值是`f903d`。为了使哈希更加安全，我的系统可能会通过在末尾添加一组随机数字来对*kitten*进行哈希处理，使输入变成*kitten123*（尽管在实际应用中，它会将位添加到输入的二进制表示中，而不是十进制数字）。由于系统每次对*kitten*进行哈希时都会添加新的数字，因此哈希值每次都不同。这个过程还使得将哈希值聚集在一个彩虹表中变得更加困难，因为输出与被哈希的原始明文没有直接关联。
- en: 'By adding salt, you increase the number of possible hashes to a point at which
    collisions become incredibly rare or difficult to discover. As a result, breaking
    the hashes becomes a very long process, especially if the inputs are complex (see
    “Type 1: Something You Know” on page 76 for more details). That said, just like
    encryption keys, any hash can be broken given enough time.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加盐，你可以增加可能的哈希数量，直到碰撞变得极其罕见或难以发现。结果，破解哈希成为一个非常漫长的过程，尤其是当输入复杂时（有关详细信息，请参见第
    76 页的“类型 1：你知道的某些东西”）。尽管如此，就像加密密钥一样，只要给足够的时间，任何哈希都是可以破解的。
- en: 'Exercise: Encrypting and Hashing Files'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习：加密和哈希文件
- en: Windows and macOS systems provide several tools to help you encrypt and hash
    files. In this exercise, you’ll use the tools embedded in Windows 10 and macOS
    to encrypt a file. You’ll also hash a file and then encrypt it and hash it again
    to see the difference between the hashed outputs. After completing the exercise,
    you’ll be able to protect your files and verify whether they’ve been modified.
    (Only the Pro version of Windows 10 allows for inherent file encryption. For those
    using Windows Home Edition, I suggest using the VeraCrypt Open Source software
    to create a place to store sensitive files so they’re encrypted.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 和 macOS 系统提供了多种工具来帮助你加密和哈希文件。在本次练习中，你将使用 Windows 10 和 macOS 中嵌入的工具来加密文件。你还将对文件进行哈希处理，然后再加密它，并再次哈希，以查看哈希输出的不同之处。完成练习后，你将能够保护你的文件并验证它们是否已被修改。（只有
    Windows 10 专业版才支持内建文件加密。对于使用 Windows 家庭版的用户，我建议使用 VeraCrypt 开源软件来创建存储敏感文件的地方，这样它们就会被加密。）
- en: Encrypting and Hashing a File in Windows 10
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 10 中加密和哈希文件
- en: To practice using file encryption, you need to create a file to encrypt. The
    quickest way to do this is to open a text editor, add some text, and then save
    it as a *.txt* file in an easy-to-remember location; you’ll be entering the file
    path later. Choose a filename without spaces to make it easier to use later in
    the exercise. [Figure 9-4](#figure9-4) shows a super-secret file I created called
    *Secretfile.txt* and saved to a folder called *Secret*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习使用文件加密，你需要创建一个文件进行加密。最快的方法是打开一个文本编辑器，添加一些文本，然后将其保存为一个*.txt*文件，并存储在一个容易记住的位置；稍后你会输入文件路径。选择一个没有空格的文件名，以便稍后在练习中更容易使用。[图
    9-4](#figure9-4)展示了我创建的一个超级秘密文件，名为*Secretfile.txt*，并将其保存到一个名为*Secret*的文件夹中。
- en: Next, you need to make sure that no one can modify your secret file without
    you detecting a change. One of the easiest ways to do this is to create a hash
    of the file. You can then compare this hash with the hashes of other versions
    of the same file to confirm the contents are identical. Windows 10 features built-in
    tools that allow you to create such a hash. To access these tools, open the Command
    Prompt application, just as you did in the exercise in Chapter 2.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要确保没有人能够在没有被你察觉的情况下修改你的秘密文件。最简单的方法之一就是创建文件的哈希值。然后，你可以将这个哈希值与该文件其他版本的哈希值进行比较，以确认文件内容是否完全一致。Windows
    10 提供了内建工具，允许你创建这样的哈希值。要访问这些工具，打开命令提示符应用程序，就像在第 2 章的练习中那样。
- en: '![f09004](image_fi/501287c09/f09004.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![f09004](image_fi/501287c09/f09004.png)'
- en: 'Figure 9-4: A very secret file'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：一个非常秘密的文件
- en: 'In the Command Prompt window, you’ll use the certutil command line tool. Normally
    we use certutil to find information about certificates, but it can also create
    file hashes. Run the tool using the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符窗口中，你将使用 certutil 命令行工具。通常我们使用 certutil 来查找有关证书的信息，但它也可以创建文件哈希。使用以下命令运行该工具：
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command runs certutil using the `hashfile` function. Recall from the exercise
    in Chapter 2 that subsequent commands beginning with a dash (`–`), which are called
    *flags*, can modify the original command. Add the path to the file so the system
    knows which file you want to hash. To enter the file path, start with the hard
    drive letter (often it’s *C*), and list each folder in order until you reach the
    one where you stored your file; be sure to use the backslash (\) between each
    folder name. Then choose the hashing algorithm to use. By default this tool uses
    SHA-1, so here we enter `SHA2-512` to make sure we’re using a strong algorithm.
    Press ENTER to run the command.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令通过 `hashfile` 函数运行 certutil。回想一下第二章的练习，后续以破折号（`–`）开头的命令，被称为 *标志*，可以修改原始命令。添加文件路径，以便系统知道你要哈希的文件。输入文件路径时，从硬盘字母（通常是
    *C*）开始，按顺序列出每个文件夹，直到到达存储文件的文件夹；确保在每个文件夹名称之间使用反斜杠（\）。然后选择要使用的哈希算法。默认情况下，此工具使用 SHA-1，因此我们在这里输入
    `SHA2-512`，以确保我们使用的是强大的算法。按 ENTER 运行命令。
- en: The command calculates the hash and then outputs a long string of characters.
    Copy and paste this string into another *.txt* file, such as one called *SecretHash.txt*,
    to save it for later comparison.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令计算哈希值并输出一长串字符。将这串字符复制并粘贴到另一个 *.txt* 文件中，例如名为 *SecretHash.txt* 的文件，以便以后进行比较。
- en: Now that you’ve hashed the file, you need to encrypt it. For this exercise,
    you’ll use the built-in encryption feature in Windows 10\. To access this feature,
    right-click the file in the filesystem, and click **Properties** to open the Properties
    menu. Find the area labeled Attributes at the bottom of the window and click **Advanced**.
    From here, you’ll see a few different options. Select **Encrypt Contents To Secure
    Data**, as shown in [Figure 9-5](#figure9-5), and then click **OK** to encrypt
    the file using the default AES algorithm.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对文件进行了哈希处理，接下来需要对其进行加密。对于本次练习，你将使用 Windows 10 中内置的加密功能。要访问此功能，右键点击文件，在文件系统中选择
    **属性** 以打开属性菜单。找到窗口底部的属性区域，然后点击 **高级**。在这里，你会看到一些不同的选项。选择 **加密内容以保护数据**，如[图 9-5](#figure9-5)所示，然后点击
    **确定** 以使用默认的 AES 算法对文件进行加密。
- en: '![f09005](image_fi/501287c09/f09005.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![f09005](image_fi/501287c09/f09005.png)'
- en: 'Figure 9-5: Selecting the encrypt contents option'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：选择加密内容选项
- en: Now the file is encrypted and secure. Let’s run the certutil tool one more time
    to compare the hashes of the original (*Secretfile.txt*) and encrypted versions
    of the file. Because you already have the hash for *Secretfile.txt* when it wasn’t
    encrypted in the *SecretHash.txt* file, all you need to do now is create a new
    hash for *Secretfile.txt* that is encrypted. Keep in mind that any change to the
    file, no matter how slight, should create a new hash. After running the same `certutil`
    command as you did earlier, paste the hash into the text file called *SecretHash.txt*
    where you pasted the first hash and compare the two. Notice that the hashes are
    vastly different, which indicates that something happened to the original file.
    If you hadn’t made that change, you’d suspect the file had been tampered with
    for malicious purposes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件已加密并且安全。让我们再运行一次 `certutil` 工具，以比较原始的（*Secretfile.txt*）文件和加密版本的哈希值。因为你已经拥有了未加密的
    *Secretfile.txt* 文件的哈希值，这些哈希值保存在 *SecretHash.txt* 文件中，现在你只需要为加密后的 *Secretfile.txt*
    创建一个新的哈希值。请记住，任何对文件的修改，无论多么微小，都应该生成一个新的哈希值。在运行与之前相同的 `certutil` 命令后，将哈希值粘贴到名为
    *SecretHash.txt* 的文本文件中，那里存放了第一个哈希值，然后比较这两个哈希值。注意到哈希值差异很大，这表明原始文件发生了变化。如果你没有进行这些更改，你可能会怀疑文件被恶意篡改。
- en: Protecting Files Using macOS
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 macOS 保护文件
- en: Protecting files in macOS is simple because you can access every tool you need
    from the Terminal using a few basic commands. To start, you’ll need to create
    a file to use as an example. Open a text editor, create a new file named *Secret*,
    and save it as a *.rtf* file in your *Documents* folder. You can write any message
    you want in the file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 中保护文件非常简单，因为你可以通过一些基本命令从终端访问所需的所有工具。首先，你需要创建一个文件作为示例。打开文本编辑器，创建一个名为
    *Secret* 的新文件，并将其保存为 *.rtf* 文件，存放在你的 *Documents* 文件夹中。你可以在文件中写下任何你想要的内容。
- en: Once you’ve created the file, you can hash it to give you a baseline to check
    against in case the file is modified. Open the Terminal application, as you did
    in the Chapter 2 exercise. You don’t need any special permissions to use the commands
    in the Terminal.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了文件，就可以对它进行哈希处理，以便在文件被修改时提供一个基准值进行对比。打开终端应用程序，就像你在第二章的练习中所做的那样。你无需特别的权限即可在终端中使用这些命令。
- en: 'To hash *Secret.rtf*, use the following `shasum` command. To indicate the home
    directory, you can use the tilde (~) symbol instead of typing it in the path:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要为*Secret.rtf*创建哈希，使用以下`shasum`命令。为了表示主目录，你可以使用波浪符（~）符号，而无需在路径中键入完整路径：
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you’ve entered the command, it automatically produces a hash. The long
    string of characters is the hash of your file. Copy this string into a new file
    called *SecretHash.rtf* to save it for later comparison.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入了命令，它会自动生成一个哈希值。这个长字符串就是你文件的哈希值。将这个字符串复制到一个新文件中，命名为*SecretHash.rtf*，以便日后进行比较。
- en: 'To encrypt *Secret.rtf*, you’ll use the openssl tool. SSL is a form of encryption
    for network communication, and openssl is an open source toolset for that protocol.
    You can use it to encrypt *Secret.rtf* by entering the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密*Secret.rtf*，你需要使用openssl工具。SSL是一种网络通信加密形式，而openssl是该协议的开源工具集。你可以通过输入以下命令来加密*Secret.rtf*：
- en: '[PRE2]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command uses the AES-256 algorithm, which, as you learned in this chapter,
    is incredibly strong. It then takes an input—in this case, the file you want to
    encrypt. The output uses a different filename to distinguish between the original
    *Secret.rtf* file and the encrypted one, so I suggest adding *.enc* to the end
    of the encrypted file’s name so you know it’s encrypted. After you press ENTER
    to run the command, you’ll be asked to enter a passphrase twice (the second time
    is a confirmation). Be sure to remember this passphrase, because it’s the only
    way to decrypt your file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令使用了AES-256算法，正如你在本章中学到的，它非常强大。然后，它接收一个输入——在这个例子中，就是你想要加密的文件。输出使用不同的文件名来区分原始的*Secret.rtf*文件和加密后的文件，因此我建议在加密文件名的末尾添加*.enc*，这样你就知道它是加密过的。按下ENTER键运行命令后，你将被要求输入密码短语两次（第二次是确认）。请务必记住这个密码短语，因为它是解密文件的唯一方式。
- en: 'To decrypt *Secret.rtf*, you run the same command again but add `-d` for decryption
    and reverse the `-in` and `-out` paths, as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密*Secret.rtf*，你再次运行相同的命令，但需要添加`-d`来表示解密，并反转`-in`和`-out`路径，如下所示：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For now, let’s leave *Secret.rtf* encrypted so you can hash it again and compare
    it with the original hash you created before encrypting the file. Run the `shasum`
    command again*,* but this time, point it to the encrypted file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们保持*Secret.rtf*的加密状态，以便你可以重新进行哈希，并将其与之前加密文件时创建的原始哈希进行比较。再次运行`shasum`命令，但这次指向加密后的文件：
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the hash is completely different from the original you created
    and saved into your *SecretHash.rtf* file. This hash will help you detect whether
    your file has been modified, which might indicate that something malicious was
    added to it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，哈希值与原始的完全不同，而原始哈希已被保存在*SecretHash.rtf*文件中。这个哈希值将帮助你检测文件是否已被修改，这可能表明文件中被添加了恶意内容。
- en: Using ssh-keygen to Generate a Public Key (Windows 10 or macOS)
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ssh-keygen生成公钥（适用于Windows 10或macOS）
- en: 'Now that you’ve encrypted your file, whether on Windows 10 or macOS, and created
    your hashes, you’ll need to create a secure means of sending the file. Even though
    it’s encrypted, it’s always best to send a file using a secure communication channel.
    To do this, you might need a set of public/private asymmetric keys. You can generate
    an RSA key pair using the command `ssh-keygen`, whether you’re on Windows or macOS.
    For this exercise, I used the Windows command, but it’s the same command for macOS:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经加密了文件，无论是在Windows 10还是macOS上，并创建了哈希值，你需要创建一个安全的方式来发送文件。尽管文件已经加密，但最好还是通过安全的通信渠道发送文件。为此，你可能需要一对公钥/私钥的非对称密钥。你可以通过`ssh-keygen`命令生成RSA密钥对，无论是在Windows还是macOS上。对于这个练习，我使用了Windows命令，但macOS上的命令是一样的：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A prompt appears asking where you want to store the file. The default path is
    the *.ssh* folder in the current user’s directory (in the example the directory
    is *samgr*, but it will be whatever the directory is named on your system). The
    default filename is *id_rsa*. To select this default press ENTER, or create your
    own file path if you want to save the key in a particular place. The next prompt
    asks for a passphrase to secure the key against misuse. If you add a passphrase,
    you’ll need to enter that phrase every time you use the key. Enter a strong passphrase
    and then reenter it at the next prompt. Once you do this, your key is generated
    and saved to the *.ssh* folder in your *Users* directory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 会弹出一个提示，询问你想将文件存储在哪里。默认路径是当前用户目录下的*.ssh*文件夹（在示例中，目录是*samgr*，但它会根据你系统上的目录名称而不同）。默认文件名是*id_rsa*。若选择默认路径，按ENTER键，或者如果你想将密钥保存在特定位置，可以创建自己的文件路径。接下来的提示会要求你设置一个密码短语以保护密钥免受滥用。如果你设置了密码短语，每次使用密钥时都需要输入该短语。请输入一个强密码短语，并在下一个提示框中重新输入它。完成后，你的密钥将生成并保存到*Users*目录下的*.ssh*文件夹中。
- en: The *.ssh* folder should now contain two files. One is *id_rsa*, which is the
    actual private key. You can open this file in Notepad to view the private key.
    The other file is a publisher file that contains the public key. You can also
    open this file in Notepad to see the public key. Now you have a public/private
    key pair that you can use for encrypted communication when necessary.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*.ssh*文件夹现在应该包含两个文件。一个是*id_rsa*，它是实际的私钥。你可以在记事本中打开此文件以查看私钥。另一个文件是一个发布者文件，包含公钥。你也可以在记事本中打开此文件查看公钥。现在，你拥有了一对公钥/私钥，可以在需要时用于加密通信。'
- en: Knowing how to create a hash, encrypt a file, and generate public/private key
    pairs allows you to encrypt your communications to ensure their safety. Using
    these techniques, you can protect your files from unauthorized access and determine
    whether they were modified. You can also check files you download, especially
    executables, to see whether their hash matches what the vendor posts as the real
    hash. If it’s different, it’s possible a black hat changed the file to add malware
    or other malicious code to it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何创建哈希、加密文件并生成公钥/私钥对，能够让你加密通信以确保其安全。通过使用这些技术，你可以保护文件免受未经授权的访问，并判断文件是否被修改。你还可以检查下载的文件，特别是可执行文件，看看它们的哈希值是否与供应商公布的真实哈希值匹配。如果不同，可能是黑客篡改了文件，添加了恶意软件或其他恶意代码。
- en: Conclusion
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Cryptography is a complex subject with lots of moving parts. This makes it challenging
    to know how to keep your communications secure. By recognizing the basic structure
    of how cryptography is used in the modern world, with symmetric and asymmetric
    encryption and hashing working together to create secure connections, you’ll have
    a better understanding of how to keep your connections secure from adversaries
    trying to steal your data. Although there are numerous ways that black hats can
    steal keys or crack encryption, using cryptography correctly works well to mitigate
    the risk of an attack being successful. One easy way to ensure that it’s properly
    implemented when you’re connecting to a website or using a protocol is to *check
    for the S*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学是一个复杂的学科，涉及众多动态部分。这使得了解如何保持通信安全变得具有挑战性。通过认识到现代世界中密码学的基本结构，包括对称加密和非对称加密以及哈希技术如何协同工作以建立安全连接，你将更好地理解如何保护你的连接免受试图窃取数据的对手。尽管黑客有许多方法窃取密钥或破解加密，但正确使用密码学可以有效降低攻击成功的风险。确保在连接到网站或使用协议时正确实现加密的一个简单方法是*检查是否有S*。
- en: What do I mean by check for the S? Many protocols use the letter S to indicate
    that they’re secure—for example, SSH (for secure remote access), FTPS (for secure
    file transfer), and HTTPS (for secure web connections). By contrast, Telnet, FTP,
    and HTTP provide the same services without encryption. Although not all secure
    protocols have an S in their acronym (WPA is a prime example), looking for the
    S is a good reminder to check for encryption when sending or storing important
    data. The context in which you’re using the protocol determines where you need
    to look for the S. For example, when browsing the internet, look at the website
    name to ensure it starts with HTTPS instead of HTTP.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我说的检查“S”是什么意思？许多协议使用字母S来表示它们是安全的——例如，SSH（用于安全远程访问）、FTPS（用于安全文件传输）和HTTPS（用于安全网络连接）。相比之下，Telnet、FTP和HTTP提供相同的服务，但没有加密。虽然并非所有安全协议的缩写中都包含S（WPA就是一个典型例子），但寻找S仍然是一个很好的提醒，让你在发送或存储重要数据时检查是否进行了加密。你使用协议的上下文决定了你需要在哪里查找S。例如，当浏览互联网时，查看网站名称，确保它以HTTPS而不是HTTP开头。
- en: It’s up to you to verify that your system sets up the encryption correctly,
    whether you’re shopping online or sending sensitive tax documents to your accountant.
    You do this in the security settings, either on your computer or in a software
    application you’re using. By understanding how encryption works, you can do a
    better job of ensuring it’s working the way it’s supposed to. This guarantees
    that whatever you’re doing or sending is hidden from attackers, as long as it
    remains encrypted.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要自己验证系统是否正确设置了加密，无论是在线购物还是将敏感的税务文件发送给会计师。你可以在安全设置中进行此操作，无论是在你的电脑上还是在你使用的软件应用中。通过了解加密的工作原理，你可以更好地确保它按预期工作。这能保证无论你在做什么或发送什么，只要它保持加密状态，就能避免被攻击者窃取。
