- en: '**19'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**19'
- en: CONCURRENCY AND PARALLELISM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发与并行**'
- en: '*The Senior Watchdog had her own watchwords: “Show me a completely smooth operation
    and I’ll show you someone who’s covering mistakes. Real boats rock.”'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*高级监视员有她自己的格言：“给我看一个完全平稳的操作，我会告诉你那是某人掩盖错误的结果。真正的船只会摇摆。”*'
- en: '—Frank Herbert,* Chapterhouse: Dune'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: — 弗兰克·赫伯特，《沙丘圣殿》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: In programming, *concurrency* means two or more tasks running in a given time
    period. *Parallelism* means two or more tasks running at the same instant. Often,
    these terms are used interchangeably without negative consequence, because they’re
    so closely related. This chapter introduces the very basics of both concepts.
    Because concurrent and parallel programming are huge and complicated topics, thorough
    treatment requires an entire book. You’ll find such books in the “Further Reading”
    section at the end of this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，*并发*意味着在给定时间段内运行两个或更多任务。*并行*意味着两个或更多任务在同一时刻运行。这两个术语常常可以互换使用而不会产生负面后果，因为它们关系密切。本章介绍了这两个概念的基础知识。由于并发和并行编程是庞大而复杂的主题，全面的探讨需要一本完整的书籍。在本章末尾的“进一步阅读”部分，您可以找到相关书籍。
- en: In this chapter, you’ll learn about concurrent and parallel programming with
    futures. Next, you’ll learn how to share data safely with mutexes, condition variables,
    and atomics. Then the chapter illustrates how execution policies help to speed
    up your code but also contain hidden dangers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用future进行并发和并行编程。接下来，您将学习如何通过互斥量、条件变量和原子操作来安全地共享数据。然后，本章将演示如何利用执行策略加速代码，同时也可能带来潜在的风险。
- en: '**Concurrent Programming**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**并发编程**'
- en: '*Concurrent programs* have multiple *threads of execution* (or simply *threads*),
    which are sequences of instructions. In most runtime environments, the operating
    system acts as a scheduler to determine when a thread executes its next instruction.
    Each process can have one or more threads, which typically share resources, such
    as memory, with each other. Because the scheduler determines when threads execute,
    the programmer can’t generally rely on their ordering. In exchange, programs can
    execute multiple tasks in the same time period (or at the same time), which often
    results in serious speedups. To observe any speedup from the serial to the concurrent
    version, your system will need concurrent hardware, for example, a multicore processor.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发程序*拥有多个*执行线程*（简称*线程*），这些线程是指令的序列。在大多数运行时环境中，操作系统充当调度程序，决定何时执行线程的下一条指令。每个进程可以有一个或多个线程，这些线程通常共享资源，例如内存。由于调度程序决定线程执行的时机，程序员通常无法依赖线程的执行顺序。作为交换，程序可以在同一时间段内（或者同时）执行多个任务，这通常会导致显著的加速。要观察从串行到并发版本的加速，系统需要具有并发硬件，例如多核处理器。'
- en: This section begins with asynchronous tasks, a high-level method for making
    your programs concurrent. Next, you’ll learn some basic methods for coordinating
    between these tasks when they’re handling shared mutable state. Then you’ll survey
    some low-level facilities available to you in the stdlib for unique situations
    in which the higher-level tools don’t have the performance characteristics you
    require.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本节从异步任务开始，这是使程序并发的高级方法。接下来，您将学习一些基本的方法来协调这些任务，特别是在它们处理共享可变状态时。然后，您将了解一些低级功能，这些功能可用于在高层工具无法满足性能需求的独特情况下使用。
- en: '***Asynchronous Tasks***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***异步任务***'
- en: One way to introduce concurrency into your program is by creating *asynchronous
    tasks*. An asynchronous task doesn’t immediately need a result. To launch an asynchronous
    task, you use the `std::async` function template in the `<future>` header.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 引入并发到程序中的一种方式是创建*异步任务*。异步任务不需要立即获得结果。要启动异步任务，可以使用`std::async`函数模板，该模板位于`<future>`头文件中。
- en: '**async**'
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**async**'
- en: 'When you invoke `std::async`, the first argument is the launch policy `std::launch`,
    which takes one of two values: `std::launch::async` or `std::launch::deferred`.
    If you pass `launch::async`, the runtime creates a new thread to launch your task.
    If you pass `deferred`, the runtime waits until you need the task’s result before
    executing (a pattern sometimes called *lazy evaluation*). This first argument
    is optional and defaults to `async|deferred`, meaning it’s up to the implementation
    which strategy to employ. The second argument to `std::async` is a function object
    representing the task you want to execute. There are no restrictions on the number
    or type of arguments the function object accepts, and it might return any type.
    The `std::async` function is a variadic template with a function parameter pack.
    Any additional arguments you pass beyond the function object will be used to invoke
    the function object when the asynchronous task launches. Also, `std::async` returns
    an object called a `std::future`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `std::async` 时，第一个参数是启动策略 `std::launch`，它有两个值可选：`std::launch::async` 或
    `std::launch::deferred`。如果你传递 `launch::async`，运行时会创建一个新线程来启动任务。如果传递 `deferred`，运行时会等到你需要任务结果时才会执行（有时这种模式被称为
    *延迟求值*）。这个第一个参数是可选的，默认为 `async|deferred`，意味着具体使用哪种策略由实现决定。`std::async` 的第二个参数是一个函数对象，表示你想执行的任务。函数对象接受的参数数量和类型没有限制，且它可以返回任何类型。`std::async`
    函数是一个可变参数模板，包含一个函数参数包。你传递的任何额外参数都会在异步任务启动时用于调用函数对象。此外，`std::async` 会返回一个名为 `std::future`
    的对象。
- en: 'The following simplified `async` declaration helps to summarize:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是简化的 `async` 声明，帮助总结：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that you know how to invoke `async`, let’s look at how to interact with
    its return value.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何调用 `async`，让我们来看一下如何与其返回值进行交互。
- en: '**Back to the future**'
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**回到未来**'
- en: A `future` is a class template that holds the value of an asynchronous task.
    It has a single template parameter that corresponds with the type of the asynchronous
    task’s return value. For example, if you pass a function object that returns a
    `string`, `async` will return a `future<string>`. Given a `future`, you can interact
    with an asynchronous task in three ways.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`future` 是一个类模板，用于保存异步任务的结果值。它有一个模板参数，对应异步任务的返回值类型。例如，如果你传递一个返回 `string` 的函数对象，`async`
    会返回一个 `future<string>`。给定一个 `future`，你可以通过三种方式与异步任务进行交互。'
- en: First, you can query the `future` about its validity using the `valid` method.
    A valid `future` has a shared state associated with it. Asynchronous tasks have
    a shared state so they can communicate the results. Any `future` returned by `async`
    will be valid until you retrieve the asynchronous task’s return value, at which
    point the shared state’s lifetime ends, as [Listing 19-1](ch19.xhtml#ch19ex01)
    illustrates.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以通过 `valid` 方法查询 `future` 是否有效。一个有效的 `future` 会关联一个共享状态。异步任务有共享状态，以便它们可以传递结果。任何由
    `async` 返回的 `future` 在你获取异步任务的返回值之前都会是有效的，之后共享状态的生命周期结束，如 [示例 19-1](ch19.xhtml#ch19ex01)
    所示。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 19-1: The `async` function returns a valid `future`.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 19-1：`async` 函数返回一个有效的 `future`。*'
- en: You launch an asynchronous task that simply returns a `string` ➊. Because `async`
    always returns a valid `future`, `valid` returns `true` ➋.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你启动一个异步任务，它简单地返回一个 `string` ➊。因为 `async` 总是返回一个有效的 `future`，所以 `valid` 返回 `true`
    ➋。
- en: If you default construct a `future`, it’s not associated with a shared state,
    so `valid` will return `false`, as [Listing 19-2](ch19.xhtml#ch19ex02) illustrates.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你默认构造一个 `future`，它没有关联共享状态，因此 `valid` 会返回 `false`，如 [示例 19-2](ch19.xhtml#ch19ex02)
    所示。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 19-2: A default constructed `future` is invalid.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 19-2：默认构造的 `future` 是无效的。*'
- en: You default construct a `future` ➊, and `valid` returns `false` ➋.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你默认构造一个 `future` ➊，然后 `valid` 返回 `false` ➋。
- en: Second, you can obtain the value from a valid `future` with its `get` method.
    If the asynchronous task hasn’t yet completed, the call to `get` will block the
    currently executed thread until the result is available. [Listing 19-3](ch19.xhtml#ch19ex03)
    illustrates how to employ `get` to obtain return values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可以通过 `get` 方法从有效的 `future` 中获取值。如果异步任务尚未完成，调用 `get` 会阻塞当前执行的线程，直到结果可用。[示例
    19-3](ch19.xhtml#ch19ex03) 演示了如何使用 `get` 获取返回值。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 19-3: The `async` function returns a valid `future`.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 19-3：`async` 函数返回一个有效的 `future`。*'
- en: You use `async` to launch an asynchronous task ➊ and then invoke the `get` method
    on the resulting `future`. As expected, the result is the return value of the
    function object you passed into `async` ➋.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`async`来启动一个异步任务➊，然后在返回的`future`对象上调用`get`方法。正如预期的那样，结果是你传递给`async`的函数对象的返回值➋。
- en: If an asynchronous task throws an exception, the `future` will collect that
    exception and throw it when you invoke `get`, as [Listing 19-4](ch19.xhtml#ch19ex04)
    illustrates.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异步任务抛出异常，`future`将收集该异常，并在你调用`get`时抛出它，正如[清单 19-4](ch19.xhtml#ch19ex04)所展示的那样。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 19-4: The `get` method will throw the exception thrown by an asynchronous
    task.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-4：`get`方法将抛出异步任务抛出的异常。*'
- en: You pass a lambda to `async` that throws a `runtime_error` ➊. When you invoke
    `get`, it throws the exception ➋.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你将一个抛出`runtime_error`的lambda传递给`async`➊。当你调用`get`时，它会抛出该异常➋。
- en: 'Third, you can check whether an asynchronous task has completed using either
    `std::wait_for` or `std::wait_until`. Which you choose depends on the sort of
    `chrono` object you want to pass. If you have a `duration` object, you’ll use
    `wait_for`. If you have a `time_point` object, you’ll use `wait_until`. Both return
    a `std::future_status`, which takes one of three values:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你可以使用`std::wait_for`或`std::wait_until`来检查异步任务是否已完成。选择哪个取决于你想传递的`chrono`对象的类型。如果你有一个`duration`对象，你将使用`wait_for`；如果你有一个`time_point`对象，你将使用`wait_until`。两者都返回一个`std::future_status`，它有三种可能的值：
- en: '`future_status::deferred` signals that the asynchronous task will be evaluated
    lazily, so the task will execute once you call `get`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`future_status::deferred`表示异步任务将被懒惰评估，因此一旦调用`get`，任务就会执行。'
- en: '`future_status::ready` indicates that the task has completed and the result
    is ready.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`future_status::ready`表示任务已完成，结果已经准备好。'
- en: '`future_status::timeout` indicates that the task isn’t ready.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`future_status::timeout`表示任务尚未准备好。'
- en: If the task completes before the specified waiting period, `async` will return
    early.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务在指定的等待时间之前完成，`async`会提前返回。
- en: '[Listing 19-5](ch19.xhtml#ch19ex05) illustrates how to use `wait_for` to check
    an asynchronous task’s status.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 19-5](ch19.xhtml#ch19ex05)展示了如何使用`wait_for`检查异步任务的状态。'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 19-5: Checking an asynchronous task’s status using `wait_for`*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-5：使用`wait_for`检查异步任务的状态*'
- en: You first launch an asynchronous task with `async`, which simply waits for up
    to 100 milliseconds before returning ➊. Next, you call `wait_for` with 25 milliseconds
    ➋. Because the task is still sleeping (25 < 100), `wait_for` returns `future_status::timeout`
    ➌. You call `wait_for` again and wait for up to another 100 milliseconds ➍. Because
    the second `wait_for` will finish after the `async` task finishes, the final `wait_for`
    will return a `future_status::ready` ➎.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用`async`启动一个异步任务，该任务仅等待最多100毫秒后再返回➊。接下来，你调用`wait_for`并设置等待时间为25毫秒➋。由于任务仍在睡眠中（25
    < 100），`wait_for`返回`future_status::timeout` ➌。你再次调用`wait_for`并等待最多100毫秒 ➍。因为第二次`wait_for`会在`async`任务完成后结束，所以最终的`wait_for`会返回`future_status::ready`
    ➎。
- en: '**NOTE**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Technically, the assertions in [Listing 19-5](ch19.xhtml#ch19ex05) aren’t
    guaranteed to pass. “Waiting” on [page 389](ch12.xhtml#page_389) introduced this_thread::sleep_for,
    which isn’t exact. The operating environment is responsible for scheduling threads,
    and it might schedule the sleeping thread later than the specified duration.*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，[清单 19-5](ch19.xhtml#ch19ex05)中的断言并不保证总是会通过。页面389中介绍的“等待”引入了`this_thread::sleep_for`，它并不精确。操作环境负责调度线程，可能会在指定的时间后再调度睡眠中的线程。*'
- en: '**An Example with Asynchronous Tasks**'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**异步任务示例**'
- en: '[Listing 19-6](ch19.xhtml#ch19ex06) contains the `factorize` function, which
    finds all of an integer’s factors.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 19-6](ch19.xhtml#ch19ex06)包含了`factorize`函数，它用于查找一个整数的所有因数。'
- en: '**NOTE**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The factorization algorithm in [Listing 19-6](ch19.xhtml#ch19ex06) is woefully
    inefficient but is good enough for this example. For efficient integer factorization
    algorithms, refer to Dixon’s algorithm, the continued fraction factorization algorithm,
    or the quadratic sieve.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*[清单 19-6](ch19.xhtml#ch19ex06)中的因式分解算法效率非常低，但对于本示例足够用了。要了解高效的整数因式分解算法，请参考Dixon算法、连分式因式分解算法或二次筛法。*'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 19-6: A very simple integer factorization algorithm*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-6：一个非常简单的整数因式分解算法*'
- en: The algorithm accepts a single argument `x` and begins by initializing a `set`
    containing 1 ➊. Next, it iterates from 2 to `x` ➋, checking whether modulo division
    with the `candidate` results in 0 ➌. If it does, `candidate` is a factor, and
    you add it to the factor `set` ➍. You divide `x` by the factor you just discovered
    ➎ and then restart your search by resetting the `candidate` to 1 ➏.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法接受一个单一的参数`x`，并通过初始化一个包含1的`set`开始 ➊。接下来，它从2迭代到`x` ➋，检查`candidate`是否与之取模后结果为0
    ➌。若是，则`candidate`是一个因子，并将其添加到因子`set`中 ➍。你将`x`除以刚刚发现的因子 ➎，然后通过将`candidate`重置为1重新开始搜索
    ➏。
- en: Because integer factorization is a hard problem (and because [Listing 19-6](ch19.xhtml#ch19ex06)
    is so inefficient), calls to `factorize` can take a long time relative to most
    of the functions you’ve encountered so far in the book. This makes it a prime
    candidate for asynchronous tasking. The `factor_task` function in [Listing 19-7](ch19.xhtml#ch19ex07)
    uses the trusty `Stopwatch` from [Listing 12-25](ch12.xhtml#ch12ex25) in [Chapter
    12](ch12.xhtml#ch12) to wrap `factorize` and returns a nicely formatted message.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整数分解是一个难题（并且因为[Listing 19-6](ch19.xhtml#ch19ex06)效率低下），调用`factorize`可能需要相较于本书中大多数函数更长的时间。这使得它成为异步任务的一个理想候选。`factor_task`函数在[Listing
    19-7](ch19.xhtml#ch19ex07)中使用了[第12章](ch12.xhtml#ch12)中[Listing 12-25](ch12.xhtml#ch12ex25)中的`Stopwatch`来封装`factorize`，并返回一个格式化良好的消息。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 19-7: A `factor_task` function that wraps a call to `factorize` and
    returns a nicely formatted message*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-7: 一个包装`factorize`调用并返回格式化消息的`factor_task`函数*'
- en: Like `factorize`, `factor_task` accepts a single argument `x` to factorize ➊.
    (For simplicity, `factor_task` takes an `unsigned long` rather than a templated
    argument). Next, you initialize a `Stopwatch` within a nested scope ➋ and then
    invoke `factorize` with `x` ➌. The result is that `elapsed_ns` contains the number
    of nanoseconds elapsed while `factorize` executed, and `factors` contains all
    the factors of `x`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 和`factorize`类似，`factor_task`也接受一个单一的参数`x`进行分解 ➊。（为了简化，`factor_task`接受一个`unsigned
    long`类型的参数，而不是模板参数）。接下来，你在一个嵌套作用域中初始化一个`Stopwatch` ➋，然后调用`factorize`来分解`x` ➌。结果是，`elapsed_ns`包含了`factorize`执行时经过的纳秒数，而`factors`则包含了`x`的所有因子。
- en: Next, you construct a nicely formatted string by first converting `elapsed_ns`
    to a count in milliseconds ➍. You write this information into a `stringstream`
    object called `ss` ➎ followed by the factors of `x` ➏. Then you return the resulting
    `string` ➐.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你通过首先将`elapsed_ns`转换为毫秒数 ➍，构建一个格式化良好的字符串。你将这些信息写入名为`ss`的`stringstream`对象
    ➎，然后写入`x`的因子 ➏。最后，返回生成的`string` ➐。
- en: '[Listing 19-8](ch19.xhtml#ch19ex08) employs `factor_task` to factor six different
    numbers and record the total elapsed program time.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 19-8](ch19.xhtml#ch19ex08)使用`factor_task`分解六个不同的数字，并记录总的程序运行时间。'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 19-8: A program using `factor_task` to factorize six different numbers*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-8: 一个使用`factor_task`来分解六个不同数字的程序*'
- en: You construct an array containing six `numbers` of varied size and primality
    ➊. Next, you initialize a `Stopwatch` ➋, iterate over each element in `numbers`
    ➌, and invoke `factor_task` with them ➍. You then determine the program’s runtime
    in milliseconds ➎ and print it ➏.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建了一个包含六个不同大小和素数性质的`numbers`数组 ➊。接下来，你初始化一个`Stopwatch` ➋，遍历`numbers`中的每个元素
    ➌，并调用`factor_task`进行分解 ➍。然后，你计算程序的运行时间（以毫秒为单位） ➎，并打印出来 ➏。
- en: The output shows that some numbers, such as 9,699,690, 4,294,967,296, and 1,307,674,368,000,
    factor almost immediately because they contain small factors. However, the prime
    numbers take quite a while. Note that because the program is single threaded,
    the runtime for the entire program roughly equals the sum of the times taken to
    factorize each number.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果显示，某些数字，如9,699,690、4,294,967,296和1,307,674,368,000，几乎可以立即分解，因为它们包含较小的因子。然而，素数需要相当长的时间。请注意，由于程序是单线程的，整个程序的运行时间大致等于分解每个数字所花费时间的总和。
- en: What if you treat each `factor_task` as an asynchronous task? [Listing 19-9](ch19.xhtml#ch19ex09)
    illustrates how to do this with `async`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将每个`factor_task`视为异步任务会怎样？[Listing 19-9](ch19.xhtml#ch19ex09)演示了如何使用`async`实现这一点。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 19-9: A program using `factor_task` to factorize six different numbers
    asynchronously*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-9: 一个使用`factor_task`异步地分解六个不同数字的程序*'
- en: As in [Listing 19-8](ch19.xhtml#ch19ex08), you initialize a `Stopwatch` to keep
    track of how long the program executes ➊. Next, you initialize a `vector` called
    `factor_tasks` that contains objects of type `future<string>` ➋. You iterate over
    `numbers` ➌, invoking `async` with the `launch::async` strategy, specifying `factor_task`
    as the function object, and passing a `number` as the task’s argument. You invoke
    `emplace_back` on each resulting `future` into `factor_tasks` ➍. Now that `async`
    has launched each task, you iterate over each element of `factor_tasks` ➎, invoke
    `get` on each `task`, and write it to `cout` ➏. Once you’ve received values from
    all the futures, you determine the number of milliseconds it took to run all tasks
    ➐ and write it to `cout` ➑.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[示例 19-8](ch19.xhtml#ch19ex08)中所示，你初始化一个`Stopwatch`来记录程序执行的时长 ➊。接下来，你初始化一个名为`factor_tasks`的`vector`，它包含`future<string>`类型的对象
    ➋。你遍历`numbers` ➌，调用`async`并使用`launch::async`策略，指定`factor_task`为函数对象，并传递`number`作为任务的参数。你对每个生成的`future`调用`emplace_back`，将其加入到`factor_tasks`
    ➍。现在，`async`已经启动了每个任务，你遍历`factor_tasks`中的每个元素 ➎，调用`get`来获取每个`task`的结果，并将其写入`cout`
    ➏。一旦从所有的`future`中收到了值，你就能计算出执行所有任务所用的毫秒数 ➐，并将其写入`cout` ➑。
- en: Thanks to concurrency, the total program time of [Listing 19-9](ch19.xhtml#ch19ex09)
    roughly equals the maximum task execution time (28,988 ms) rather than the sum
    of task execution times, as in [Listing 19-8](ch19.xhtml#ch19ex08) (37,115 ms).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并发性，[示例 19-9](ch19.xhtml#ch19ex09)的总程序时间大约等于最大任务执行时间（28,988毫秒），而不是任务执行时间的总和，如在[示例
    19-8](ch19.xhtml#ch19ex08)中所示（37,115毫秒）。
- en: '**NOTE**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The times in [Listing 19-8](ch19.xhtml#ch19ex08) and [Listing 19-9](ch19.xhtml#ch19ex09)
    will vary from run to run.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*[示例 19-8](ch19.xhtml#ch19ex08)和[示例 19-9](ch19.xhtml#ch19ex09)中的时间会因每次运行而有所不同。*'
- en: '***Sharing and Coordinating***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***共享与协调***'
- en: Concurrent programming with asynchronous tasks is simple as long as the tasks
    don’t require synchronization and don’t involve sharing mutable data. For example,
    consider a simple situation in which two threads access the same integer. One
    thread will increment the integer while the other decrements it. To modify a variable,
    each thread must read the variable’s current value, perform an addition or subtraction
    operation, and then write the variable to memory. Without synchronization, the
    two threads will perform these operations in an undefined, interleaved order.
    Such situations are sometimes called *race conditions* because the result depends
    on which thread executes first. [Listing 19-10](ch19.xhtml#ch19ex10) illustrates
    just how disastrous this situation is.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步任务进行并发编程是简单的，只要任务不需要同步，并且不涉及共享可变数据。例如，考虑一个简单的情境，其中两个线程访问同一个整数。一个线程会递增这个整数，而另一个线程会递减它。为了修改变量，每个线程必须读取变量的当前值，进行加法或减法操作，然后将变量写回内存。如果没有同步机制，这两个线程将以未定义的交错顺序执行这些操作。这种情况有时被称为*竞争条件*，因为结果取决于哪个线程先执行。[示例
    19-10](ch19.xhtml#ch19ex10)展示了这种情况有多么灾难性。
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 19-10: An illustration of how disastrous unsynchronized, mutable,
    shared data access can be*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 19-10：展示了未同步、可变共享数据访问可能带来的灾难性后果*'
- en: '**NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll get different results on each run of the program in [Listing 19-10](ch19.xhtml#ch19ex10)
    because the program has undefined behavior.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于程序存在未定义行为，在运行[示例 19-10](ch19.xhtml#ch19ex10)时，你将获得不同的结果。*'
- en: '[Listing 19-10](ch19.xhtml#ch19ex10) involves defining a function called `goat_rodeo`,
    which involves a catastrophic race condition, and a `main` that invokes `goat_rodeo`
    three times. Within `goat_rodeo`, you initialize the shared data `tin_cans_available`
    ➊. Next, you launch an asynchronous task called `eat_cans` ➋ in which a trip of
    goats decrements the shared variable `tin_cans_available` one million times ➌.
    Next, you launch another asynchronous task called `deposit_cans` ➍ in which you
    increment `tin_cans_available` ➎. After launching the two tasks, you wait for
    them to complete by calling `get` (the order doesn’t matter) ➏➐. Once the tasks
    complete, you print the `tin_cans_available` variable ➑.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19-10](ch19.xhtml#ch19ex10)涉及定义一个名为`goat_rodeo`的函数，它包含一个灾难性的竞争条件，以及一个调用`goat_rodeo`三次的`main`函数。在`goat_rodeo`中，你初始化了共享数据`tin_cans_available`
    ➊。接下来，你启动一个名为`eat_cans`的异步任务 ➋，在该任务中，一群山羊会将共享变量`tin_cans_available`递减一百万次 ➌。然后，你启动另一个名为`deposit_cans`的异步任务
    ➍，该任务会递增`tin_cans_available` ➎。启动这两个任务后，你通过调用`get`等待它们完成（顺序无关） ➏➐。任务完成后，你打印出`tin_cans_available`变量的值
    ➑。'
- en: Intuitively, you might expect `tin_cans_available` to equal zero after each
    task completes. After all, no matter how you order increments and decrements,
    if you perform them in equal number, they’ll cancel. You invoke `goat_rodeo` three
    times, and each invocation produces a wildly different result.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从直觉上讲，你可能会期望每个任务完成后 `tin_cans_available` 等于零。毕竟，无论你如何排序递增和递减，如果它们的次数相等，它们会相互抵消。你调用了三次
    `goat_rodeo`，每次调用的结果都完全不同。
- en: '[Table 19-1](ch19.xhtml#ch19tab01) illustrates one of the many ways the unsynchronized
    access in [Listing 19-10](ch19.xhtml#ch19ex10) goes awry.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 19-1](ch19.xhtml#ch19tab01) 说明了在 [清单 19-10](ch19.xhtml#ch19ex10) 中，无同步访问如何导致问题。'
- en: '**Table 19-1:** One Possible Schedule for `eat_cans` and `deposit_cans`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 19-1：** `eat_cans` 和 `deposit_cans` 的一种可能调度'
- en: '| **eat_cans** | **deposit_cans** | **cans_available** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **eat_cans** | **deposit_cans** | **cans_available** |'
- en: '| Read `cans_available` (0) |  | 0 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 读取 `cans_available` (0) |  | 0 |'
- en: '|  | Read `cans_available` (0) ➊ | 0 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  | 读取 `cans_available` (0) ➊ | 0 |'
- en: '| Compute `cans_available+1` (1) |  | 0 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 计算 `cans_available+1` (1) |  | 0 |'
- en: '|  | Compute `cans_available-1` (-1) ➌ | 0 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|  | 计算 `cans_available-1` (-1) ➌ | 0 |'
- en: '| Write `cans_available+1` (1) ➋ |  | 1 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 写入 `cans_available+1` (1) ➋ |  | 1 |'
- en: '|  | Write `cans_available-1` (-1) ➍ | -1 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  | 写入 `cans_available-1` (-1) ➍ | -1 |'
- en: '[Table 19-1](ch19.xhtml#ch19tab01) shows how interleaving reads and writes
    invites disaster. In this particular incarnation, the read by `deposit_cans` ➊
    precedes the write from `eat_cans` ➋, so `deposit_cans` computes a stale result
    ➌. If this weren’t bad enough, it clobbers the write from `eat_cans` when it writes
    ➍.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 19-1](ch19.xhtml#ch19tab01) 显示了交替读取和写入如何带来灾难。在这种特殊情况下，`deposit_cans` 的读取
    ➊ 在 `eat_cans` 的写入 ➋ 之前发生，因此 `deposit_cans` 计算了一个过时的结果 ➌。更糟糕的是，它在写入时覆盖了 `eat_cans`
    的写入 ➍。'
- en: 'The fundamental problem with this data race is *unsynchronized access to mutable
    shared data*. You might wonder why `cans_available` doesn’t update immediately
    whenever a thread computes `cans_available+1` or `cans_available-1`. The answer
    lies in the fact that each of the rows in [Table 19-1](ch19.xhtml#ch19tab01) represents
    a moment in time when some instruction completes execution, and the instructions
    for adding, subtracting, reading, and writing memory are all separate. Because
    the `cans_available` variable is shared and both threads write to it without synchronizing
    their actions, the instructions get interleaved in an undefined way at runtime
    (with catastrophic results). In the following subsections, you’ll learn three
    tools for dealing with such situations: *mutexes*, *condition variables*, and
    atomics.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据竞争问题的根本原因是 *对可变共享数据的无同步访问*。你可能会问，为什么每当一个线程计算 `cans_available+1` 或 `cans_available-1`
    时，`cans_available` 不会立即更新？答案在于，表 [19-1](ch19.xhtml#ch19tab01) 中的每一行都表示某个指令执行完毕的时刻，而加法、减法、读取和写入内存的指令是分开的。由于
    `cans_available` 变量是共享的，并且两个线程都在没有同步其操作的情况下写入它，因此指令在运行时会以未定义的方式交替执行（并带来灾难性后果）。在接下来的子节中，你将学习三种应对这种情况的工具：*互斥量*、*条件变量*
    和原子操作。
- en: '**Mutexes**'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**互斥量**'
- en: 'A *mutual exclusion algorithm* (*mutex*) is a mechanism for preventing multiple
    threads from accessing resources simultaneously. Mutexes are *synchronization
    primitives* that support two operations: lock and unlock. When a thread needs
    to access shared data, it locks the mutex. This operation can block depending
    on the nature of the mutex and whether another thread has the lock. When a thread
    no longer needs access, it unlocks the mutex.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*互斥算法*（*mutex*）是一种防止多个线程同时访问资源的机制。互斥量是 *同步原语*，支持两种操作：锁定和解锁。当一个线程需要访问共享数据时，它会锁定互斥量。根据互斥量的性质以及是否有其他线程已获得锁，锁定操作可能会被阻塞。当线程不再需要访问时，它会解锁互斥量。'
- en: 'The `<mutex>` header exposes several mutex options:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`<mutex>` 头文件提供了几种互斥选项：'
- en: '`std::mutex` provides basic mutual exclusion.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::mutex` 提供基本的互斥功能。'
- en: '`std::timed_mutex` provides mutual exclusion with a timeout.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::timed_mutex` 提供了带有超时的互斥功能。'
- en: '`std::recursive_mutex` provides mutual exclusion that allows recursive locking
    by the same thread.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::recursive_mutex` 提供了允许同一线程递归锁定的互斥功能。'
- en: '`std::recursive_timed_mutex` provides mutual exclusion that allows recursive
    locking by the same thread and a timeout.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::recursive_timed_mutex` 提供了允许同一线程递归锁定的互斥功能，并且有超时功能。'
- en: 'The `<shared_mutex>` header provides two additional options:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`<shared_mutex>` 头文件提供了两个额外的选项：'
- en: '`std::shared_mutex` provides shared mutual exclusion facility, which means
    that several threads can own the mutex at once. This option is typically used
    in scenarios when multiple readers can access shared data but a writer needs exclusive
    access.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_mutex`提供共享互斥功能，这意味着多个线程可以同时拥有该互斥锁。这个选项通常用于多个读线程可以访问共享数据，而写线程需要独占访问的场景。'
- en: '`std::shared_timed_mutex` provides shared mutual exclusion facility and implements
    locking with a timeout.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_timed_mutex`提供共享互斥功能，并实现了带有超时的锁定机制。'
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For simplicity, this chapter only covers mutex. See [thread.mutex] for more
    information about the other options.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简单起见，本章仅介绍互斥锁。有关其他选项的更多信息，请参见[thread.mutex]。*'
- en: 'The `mutex` class defines only a single, default constructor. When you want
    to obtain mutual exclusion, you call one of two methods on a `mutex` object: `lock`
    or `try_lock`. If you call `lock`, which accepts no arguments and returns `void`,
    the calling thread blocks until the `mutex` becomes available. If you call `try_lock`,
    which accepts no arguments and returns a `bool`, it returns immediately. If the
    `try_lock` successfully obtained mutual exclusion, it returns `true` and the calling
    thread now owns the lock. If `try_lock` was unsuccessful, it returns `false` and
    the calling thread doesn’t own the lock. To release a mutual exclusion lock, you
    simply call the method `unlock`, which accepts no arguments and returns `void`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex`类只定义了一个单一的默认构造函数。当你需要获得互斥访问时，你可以在`mutex`对象上调用两个方法之一：`lock`或`try_lock`。如果调用`lock`，它不接受任何参数并返回`void`，调用线程会阻塞，直到`mutex`可用。如果调用`try_lock`，它也不接受任何参数并返回一个`bool`，它会立即返回。如果`try_lock`成功获得了互斥访问，它会返回`true`，并且调用线程现在拥有锁。如果`try_lock`失败，它会返回`false`，并且调用线程没有获得锁。要释放互斥锁，你只需调用`unlock`方法，它不接受任何参数并返回`void`。'
- en: '[Listing 19-11](ch19.xhtml#ch19ex11) shows a lock-based way to solve the race
    condition in [Listing 19-10](ch19.xhtml#ch19ex10).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 19-11](ch19.xhtml#ch19ex11)展示了一种基于锁的方式来解决[列表 19-10](ch19.xhtml#ch19ex10)中的竞态条件。'
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 19-11: Using a `mutex` to resolve the race condition in [Listing 19-10](ch19.xhtml#ch19ex10)*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-11：使用`mutex`解决[列表 19-10](ch19.xhtml#ch19ex10)中的竞态条件*'
- en: You add a `mutex` into `goat_rodeo` ➊ called `tin_can_mutex`, which provides
    mutual exclusion on the `tin_cans_available`. Inside each asynchronous task, a
    thread acquires a lock ➋➍ before modifying `tin_cans_available`. Once the thread
    is done modifying, it unlocks ➌➎. Notice that the resulting number of available
    tin cans at the end of each run is zero ➏➐➑, reflecting that you’ve fixed your
    race condition.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`goat_rodeo` ➊中添加了一个名为`tin_can_mutex`的`mutex`，它对`tin_cans_available`提供互斥访问。在每个异步任务中，线程在修改`tin_cans_available`之前会获取一个锁
    ➋➍。修改完成后，线程会解锁 ➌➎。注意，每次运行结束时，`tin_cans_available`的最终数量为零 ➏➐➑，这表明你已经修复了竞态条件。
- en: '**MUTEX IMPLEMENTATIONS**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**互斥锁实现**'
- en: In practice, mutexes are implemented in a number of ways. Perhaps the simplest
    mutex is a *spin lock* in which a thread will execute a loop until the lock is
    released. This kind of lock usually minimizes the amount of time between a lock
    getting released by one thread and acquired by another. But it’s computationally
    expensive because a CPU is spending all of its time checking for lock availability
    when some other thread could be doing productive work. Typically, mutexes require
    atomic instructions, such as `compare-and-swap`, `fetch-and-add`, or `test-and-set`,
    so they can check for and acquire a lock in one operation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，互斥锁有多种实现方式。最简单的互斥锁可能是*自旋锁*，其中线程会执行一个循环，直到锁被释放。这种锁通常可以最小化一个线程释放锁与另一个线程获取锁之间的时间。但它在计算上是昂贵的，因为CPU会花费大量时间检查锁是否可用，而其他线程本可以进行有生产力的工作。通常，互斥锁需要原子指令，如`compare-and-swap`、`fetch-and-add`或`test-and-set`，这样它们就能在一个操作中检查并获取锁。
- en: Modern operating systems, like Windows, offer more efficient alternatives to
    spin locks. For example, mutexes based on *asynchronous procedure calls* allow
    threads to wait on a mutex and go into a *wait state*. Once the mutex becomes
    available, the operating system awakens the waiting thread and hands off ownership
    of the mutex. This allows other threads to do productive work on a CPU that would
    otherwise be occupied in a spin lock.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统，如Windows，提供了比自旋锁更高效的替代方案。例如，基于*异步过程调用*的互斥锁允许线程在等待互斥锁时进入*等待状态*。一旦互斥锁变得可用，操作系统会唤醒等待的线程，并将互斥锁的所有权交给该线程。这使得其他线程可以在CPU上做有生产力的工作，而不是被自旋锁占用。
- en: In general, you won’t need to worry about the details of how mutexes are implemented
    by your operating system unless they become a bottleneck in your program.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，除非互斥锁成为程序的瓶颈，否则你不需要关心操作系统如何实现互斥锁的细节。
- en: 'If you’re thinking that handling `mutex` locking is a perfect job for an RAII
    object, you’re right. Suppose you forgot to invoke `unlock` on a mutex, say because
    it threw an exception. When the next thread comes along and attempts to acquire
    the mutex with `lock`, your program will come to a screeching halt. For this reason,
    the stdlib provides RAII classes for handling mutexes in the `<mutex>` header.
    There you’ll find several class templates, all of which accept mutexes as constructor
    parameters and a template parameter corresponding to the class of the mutexes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为处理`mutex`锁定是RAII对象的完美任务，你是对的。假设你忘记调用`unlock`释放一个互斥锁，比如因为它抛出了异常。当下一个线程来尝试通过`lock`获取这个互斥锁时，你的程序会停滞不前。正因如此，标准库提供了用于处理互斥锁的RAII类，位于`<mutex>`头文件中。在那里，你会找到几个类模板，它们都接受互斥锁作为构造函数参数，并且有一个与互斥锁类型对应的模板参数：
- en: '`std::lock_guard` is a non-copyable, non-moveable RAII wrapper that accepts
    a mutex object in its constructor, where it calls `lock`. It then calls `unlock`
    in the destructor.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::lock_guard`是一个不可复制、不可移动的RAII封装器，它在构造函数中接受一个互斥锁对象，并调用`lock`。然后在析构函数中调用`unlock`。'
- en: '`std::scoped_lock` is a deadlock avoiding RAII wrapper for multiple mutexes.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::scoped_lock`是一个避免死锁的RAII封装器，用于多个互斥锁。'
- en: '`std::unique_lock` implements a movable mutex ownership wrapper.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unique_lock`实现了一个可移动的互斥锁所有权封装器。'
- en: '`std::shared_lock` implements a movable shared mutex ownership wrapper.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::shared_lock`实现了一个可移动的共享互斥锁所有权封装器。'
- en: For brevity, this section focuses on `lock_guard`. [Listing 19-12](ch19.xhtml#ch19ex12)
    shows how to refactor [Listing 19-11](ch19.xhtml#ch19ex11) to use `lock_guard`
    instead of manual `mutex` manipulation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为简洁起见，本节重点讨论`lock_guard`。[清单19-12](ch19.xhtml#ch19ex12)展示了如何重构[清单19-11](ch19.xhtml#ch19ex11)，以使用`lock_guard`代替手动操作`mutex`。
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 19-12: Refactoring [Listing 19-11](ch19.xhtml#ch19ex11) to use `lock_guard`*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单19-12：重构[清单19-11](ch19.xhtml#ch19ex11)以使用`lock_guard`*'
- en: Rather than using `lock` and `unlock` to manage mutual exclusion, you construct
    a `lock_guard` at the beginning of each scope where you need synchronization ➊➋.
    Because your mutual exclusion mechanism is a `mutex`, you specify it as your `lock_guard`
    template parameter. [Listing 19-11](ch19.xhtml#ch19ex11) and [Listing 19-12](ch19.xhtml#ch19ex12)
    have equivalent runtime behavior, including how long it takes the programs to
    execute. RAII objects don’t involve any additional runtime costs over programming
    releases and acquisitions by hand.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用`lock`和`unlock`来管理互斥，你可以在需要同步的每个作用域开始时构造一个`lock_guard` ➊➋。由于你的互斥机制是`mutex`，你需要将其指定为`lock_guard`模板参数。[清单19-11](ch19.xhtml#ch19ex11)和[清单19-12](ch19.xhtml#ch19ex12)在运行时行为上是等价的，包括程序执行所需的时间。RAII对象不会引入比手动释放和获取锁更高的运行时成本。
- en: Unfortunately, mutual exclusion locks involve runtime costs. You might also
    have noticed that executing [Listings 19-11](ch19.xhtml#ch19ex11) and [19-12](ch19.xhtml#ch19ex12)
    took substantially longer than executing [Listing 19-10](ch19.xhtml#ch19ex10).
    The reason is that acquiring and releasing locks is a relatively expensive operation.
    In [Listings 19-11](ch19.xhtml#ch19ex11) and [19-12](ch19.xhtml#ch19ex12), the
    `tin_can_mutex` gets acquired and then released two million times. Relative to
    incrementing or decrementing an integer, acquiring or releasing a lock takes substantially
    more time, so using a mutex to synchronize the asynchronous tasks is suboptimal.
    In certain situations, you can take a potentially more efficient approach by using
    atomics.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，互斥锁涉及运行时成本。你可能也注意到，执行[清单19-11](ch19.xhtml#ch19ex11)和[19-12](ch19.xhtml#ch19ex12)的时间明显比执行[清单19-10](ch19.xhtml#ch19ex10)要长。原因是获取和释放锁是相对昂贵的操作。在[清单19-11](ch19.xhtml#ch19ex11)和[清单19-12](ch19.xhtml#ch19ex12)中，`tin_can_mutex`被获取然后释放了两百万次。相较于增减一个整数，获取或释放锁花费的时间要多得多，因此使用互斥锁来同步异步任务是次优的。在某些情况下，你可以通过使用原子操作采取可能更高效的方法。
- en: '**NOTE**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For more information about asynchronous tasks and futures, refer to [futures.async].*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关异步任务和未来值的更多信息，请参阅[futures.async]。*'
- en: '**Atomics**'
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**原子操作**'
- en: The word *atomic* comes from the Greek *átomos*, meaning “indivisible.” An operation
    is atomic if it occurs in an indivisible unit. Another thread cannot observe the
    operation halfway through. When you introduced locks into [Listing 19-10](ch19.xhtml#ch19ex10)
    to produce [Listing 19-11](ch19.xhtml#ch19ex11), you made the increment and decrement
    operations atomic because the asynchronous tasks could no longer interleave read
    and write operations on `tin_cans_available`. As you experienced running this
    lock-based solution, this approach is very slow because acquiring locks is expensive.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 单词*atomic*来自希腊语*átomos*，意为“不可分割”。当一个操作在不可分割的单元中发生时，这个操作就是原子的。另一个线程无法观察到操作进行到一半的状态。当你在[清单
    19-10](ch19.xhtml#ch19ex10)中引入锁来生成[清单 19-11](ch19.xhtml#ch19ex11)时，你使得增量和减量操作变得原子化，因为异步任务无法再交错地读取和写入`tin_cans_available`。正如你在运行这个基于锁的解决方案时体验到的那样，这种方法非常慢，因为获取锁是非常昂贵的。
- en: Another approach is to use the `std::atomic` class template in the `<atomic>`
    header, which provides primitives often used in *lock-free concurrent programming*.
    Lock-free concurrent programming solves data race issues without involving locks.
    On many modern architectures, CPUs support atomic instructions. Using atomics,
    you might be able to avoid locks by leaning on atomic hardware instructions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`std::atomic`类模板，该模板在`<atomic>`头文件中提供了常用于*无锁并发编程*的原语。无锁并发编程解决了数据竞争问题，而不涉及锁。在许多现代架构中，CPU支持原子指令。使用原子操作，你可能能够通过依赖原子硬件指令来避免锁。
- en: This chapter doesn’t discuss `std::atomic` or how to devise your own lock-free
    solutions in detail, because it’s incredibly difficult to do correctly and is
    best left to experts. However, in simple situations, such as in [Listing 19-10](ch19.xhtml#ch19ex10),
    you can employ a `std::atomic` to make sure that the increment or decrement operations
    cannot be divided. This neatly solves your data race problem.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会详细讨论`std::atomic`或如何设计自己的无锁解决方案，因为这非常难以正确实现，最好留给专家。不过，在简单的情况下，比如在[清单 19-10](ch19.xhtml#ch19ex10)中，你可以使用`std::atomic`来确保增量或减量操作无法被拆分。这样可以巧妙地解决数据竞争问题。
- en: The `std::atomic` template offers specializations for all fundamental types,
    as shown in [Table 19-2](ch19.xhtml#ch19tab02).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic`模板为所有基本类型提供了特化，如[表 19-2](ch19.xhtml#ch19tab02)所示。'
- en: '**Table 19-2:** `std::atomic` Template Specializations for the Fundamental
    Types'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 19-2：** `std::atomic`模板对基本类型的特化'
- en: '| **Template specialization** | **Alias** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **模板特化** | **别名** |'
- en: '| `std::atomic<bool>` | `std::atomic_bool` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<bool>` | `std::atomic_bool` |'
- en: '| `std::atomic<char>` | `std::atomic_char` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<char>` | `std::atomic_char` |'
- en: '| `std::atomic<unsigned char>` | `std::atomic_uchar` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<unsigned char>` | `std::atomic_uchar` |'
- en: '| `std::atomic<short>` | `std::atomic_short` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<short>` | `std::atomic_short` |'
- en: '| `std::atomic<unsigned short>` | `std::atomic_ushort` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<unsigned short>` | `std::atomic_ushort` |'
- en: '| `std::atomic<int>` | `std::atomic_int` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<int>` | `std::atomic_int` |'
- en: '| `std::atomic<unsigned int>` | `std::atomic_uint` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<unsigned int>` | `std::atomic_uint` |'
- en: '| `std::atomic<long>` | `std::atomic_long` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<long>` | `std::atomic_long` |'
- en: '| `std::atomic<unsigned long>` | `std::atomic_ulong` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<unsigned long>` | `std::atomic_ulong` |'
- en: '| `std::atomic<long long>` | `std::atomic_llong` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<long long>` | `std::atomic_llong` |'
- en: '| `std::atomic<unsigned long long>` | `std::atomic_ullong` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<unsigned long long>` | `std::atomic_ullong` |'
- en: '| `std::atomic<char16_t>` | `std::atomic_char16_t` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<char16_t>` | `std::atomic_char16_t` |'
- en: '| `std::atomic<char32_t>` | `std::atomic_char32_t` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<char32_t>` | `std::atomic_char32_t` |'
- en: '| `std::atomic<wchar_t>` | `std::atomic_wchar_t` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `std::atomic<wchar_t>` | `std::atomic_wchar_t` |'
- en: '[Table 19-3](ch19.xhtml#ch19tab03) lists some of the supported operations for
    `std::atomic`. The `std::atomic` template has no copy constructor.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 19-3](ch19.xhtml#ch19tab03)列出了`std::atomic`的一些支持操作。`std::atomic`模板没有拷贝构造函数。'
- en: '**Table 19-3:** Supported Operations for `std::atomic`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 19-3：** `std::atomic`的支持操作'
- en: '| **Operation** | **Description** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **描述** |'
- en: '| a`{}`a`{ 123 }` | Default constructor.Initializes value to 123. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| a`{}`a`{ 123 }` | 默认构造函数。将值初始化为 123。 |'
- en: '| a`.is_lock_free()` | Returns true if a is lock-free. (Depends on the CPU.)
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| a`.is_lock_free()` | 如果a是无锁的，则返回true。（取决于CPU。） |'
- en: '| a`.store(123)` | Stores the value 123 into a. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| a`.store(123)` | 将值 123 存储到a中。 |'
- en: '| a`.load()`a`()` | Returns the stored value. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| a`.load()`a`() | 返回存储的值。 |'
- en: '| a`.exchange(123)` | Replaces the current value with 123 and returns the old
    value. This is a “read-modify-write” operation. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| a`.exchange(123)` | 将当前值替换为 123，并返回旧值。这是一个“读-修改-写”操作。 |'
- en: '| a`.compare_exchange_weak(10, 20)`a`.compare_exchange_strong(10, 20)` | If
    the current value is 10, replaces with 20\. Returns true if the value was replaced.
    See `[atomic]` for details on weak versus strong. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| a`.compare_exchange_weak(10, 20)`a`.compare_exchange_strong(10, 20)` | 如果当前值为10，则替换为20。若值被替换，返回true。有关弱交换与强交换的详情，请参见`[atomic]`。
    |'
- en: '**NOTE**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Specializations for the types in <cstdint> are also available. See [atomics.syn]
    for details.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*<cstdint>中的类型也提供了特化操作。详细信息请参见[atomics.syn]。*'
- en: For the numeric types, the specializations offer additional operations, as listed
    in [Table 19-4](ch19.xhtml#ch19tab04).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值类型，特化操作提供了附加的操作，如[表19-4](ch19.xhtml#ch19tab04)所列。
- en: '**Table 19-4:** Supported Operations for Numeric Specializations of a `std::atomic`
    a'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**表19-4：** `std::atomic` a的数值特化支持的操作'
- en: '| **Operation** | **Description** |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **描述** |'
- en: '| a`.fetch_add(123)`a`+=123` | Replaces the current value with the result of
    adding the argument to the current value. Returns the value before modification.
    This is a “read-modify-write” operation. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| a`.fetch_add(123)`a`+=123` | 用当前值加上参数的结果替换当前值。返回修改前的值。这是一个“读-修改-写”操作。 |'
- en: '| a`.fetch_sub(123)`a`-=123` | Replaces the current value with the result of
    subtracting the argument from the current value. Returns the value before modification.
    This is a “read-modify-write” operation. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| a`.fetch_sub(123)`a`-=123` | 用当前值减去参数的结果替换当前值。返回修改前的值。这是一个“读-修改-写”操作。 |'
- en: '| a`.fetch_and(123)`a`&=123` | Replaces the current value with the result of
    bitwise ANDing the argument with the current value. Returns the value before modification.
    This is a “read-modify-write” operation. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| a`.fetch_and(123)`a`&=123` | 用当前值与参数进行按位与运算的结果替换当前值。返回修改前的值。这是一个“读-修改-写”操作。
    |'
- en: '| a`.fetch_or(123)`a`&#124;=123` | Replaces the current value with the result
    of bitwise ORing the argument with the current value. Returns the value before
    modification. This is a “read-modify-write” operation. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| a`.fetch_or(123)`a`&#124;=123` | 用当前值与参数进行按位或运算的结果替换当前值。返回修改前的值。这是一个“读-修改-写”操作。
    |'
- en: '| a`.fetch_xor(123)`a`^=123` | Replaces the current value with the result of
    bitwise XORing the argument with the current value. Returns the value before modification.
    This is a “read-modify-write” operation. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| a`.fetch_xor(123)`a`^=123` | 用当前值与参数进行按位异或运算的结果替换当前值。返回修改前的值。这是一个“读-修改-写”操作。
    |'
- en: '| a`++`a`--` | Increments or decrements a. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| a`++`a`--` | 增加或减少a的值。 |'
- en: Because [Listing 19-12](ch19.xhtml#ch19ex12) is a prime candidate for a lock-free
    solution, you can replace the type of `tin_cans_available` with `atomic_int` and
    remove the `mutex`. This prevents race conditions like the one illustrated in
    [Table 19-1](ch19.xhtml#ch19tab01). [Listing 19-13](ch19.xhtml#ch19ex13) implements
    this refactor.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因为[清单19-12](ch19.xhtml#ch19ex12)是一个适合无锁解决方案的典型例子，你可以将`tin_cans_available`的类型替换为`atomic_int`，并移除`mutex`。这样可以防止像[表19-1](ch19.xhtml#ch19tab01)所示的竞争条件。[清单19-13](ch19.xhtml#ch19ex13)实现了这一重构。
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 19-13: Resolving the race condition using `atomic_int` rather than
    `mutex`*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单19-13：使用`atomic_int`而非`mutex`解决竞争条件*'
- en: You replace `int` with `atomic_int` ➊ and remove the `mutex`. Because the decrement
    ➋ and increment ➌ operators are atomic, the race condition remains solved.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你将`int`替换为`atomic_int` ➊并移除`mutex`。因为递减 ➋ 和递增 ➌ 运算符是原子的，竞争条件仍然得到解决。
- en: '**NOTE**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For more information about atomics, refer to [atomics].*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关原子操作的更多信息，请参见[atomics]。*'
- en: You also probably noticed a considerable performance boost from [Listing 19-12](ch19.xhtml#ch19ex12)
    to [19-13](ch19.xhtml#ch19ex12). In general, using atomic operations will be much
    faster than acquiring a mutex.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到，从[清单19-12](ch19.xhtml#ch19ex12)到[19-13](ch19.xhtml#ch19ex12)，性能有了显著的提升。一般来说，使用原子操作将比获取互斥锁更快。
- en: '**WARNING**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Unless you have a very simple concurrent access problem, such as the one in
    this section, you really shouldn’t try to implement lock-free solutions on your
    own. Refer to the Boost Lockfree library for high-quality, thoroughly tested lock-free
    containers. As always, you must decide whether a lock-based or lock-free implementation
    is optimal.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非你有一个非常简单的并发访问问题，比如本节中的例子，否则你真的不应该尝试自己实现无锁解决方案。请参考Boost Lockfree库，获取高质量、经过彻底测试的无锁容器。像往常一样，你必须决定基于锁的实现还是无锁实现更为优化。*'
- en: '**Condition Variables**'
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**条件变量**'
- en: 'A *condition variable* is a synchronization primitive that blocks one or more
    threads until notified. Another thread can notify the condition variable. After
    notification, the condition variable can unblock one or more threads so they can
    make progress. A very popular condition variable pattern involves a thread performing
    the following actions:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件变量*是一种同步原语，它会阻塞一个或多个线程，直到被通知。另一个线程可以通知条件变量。通知后，条件变量可以解除阻塞一个或多个线程，使它们能够继续执行。一个非常流行的条件变量模式涉及一个线程执行以下操作：'
- en: Acquire some mutex shared with awaiting threads.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一些与等待线程共享的互斥锁。
- en: Modify the shared state.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改共享状态。
- en: Notify the condition variable.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知条件变量。
- en: Release the mutex.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放互斥锁。
- en: 'Any threads waiting on the condition variable then perform the following actions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在条件变量上等待的线程会执行以下操作：
- en: Acquire the mutex.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取互斥锁。
- en: Wait on the condition variable (this releases the mutex).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在条件变量上等待（这会释放互斥锁）。
- en: When another thread notifies the condition variable, this thread wakes up and
    can perform some work (this reacquires the mutex automatically).
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当另一个线程通知条件变量时，当前线程醒来并可以执行一些工作（这会自动重新获取互斥锁）。
- en: Release the mutex.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放互斥锁。
- en: Due to complications arising from the complexity of modern operating systems,
    sometimes threads can wake up spuriously. Therefore, it’s important to verify
    that a condition variable was in fact signaled once a waiting thread awakens.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代操作系统的复杂性，有时线程会无故醒来。因此，重要的是在等待的线程醒来时，验证条件变量确实已被通知。
- en: The stdlib provides `std::condition_variable` in the `<condition_variable>`
    header, which supports several operations, including those in [Table 19-5](ch19.xhtml#ch19tab05).
    The `condition_variable` supports only default construction, and the copy constructor
    is deleted.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库在`<condition_variable>`头文件中提供了`std::condition_variable`，它支持多种操作，包括[表 19-5](ch19.xhtml#ch19tab05)中的操作。`condition_variable`仅支持默认构造，并且拷贝构造函数被删除。
- en: '**Table 19-5:** Supported Operations of a `std::condition_variable` cv'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 19-5：** `std::condition_variable` cv 支持的操作'
- en: '| **Operation** | **Description** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **描述** |'
- en: '| cv`.notify_one()` | If any threads are waiting on cv, this operation notifies
    one of them. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| cv`.notify_one()` | 如果有线程在等待条件变量，此操作会通知其中一个线程。 |'
- en: '| cv`.notify_all()` | If any threads are waiting on cv, this operation notifies
    all of them. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| cv`.notify_all()` | 如果有线程在等待条件变量，此操作会通知所有线程。 |'
- en: '| cv`.wait(`lock`, [`pred`])` | Given a lock on the mutex owned by the notifier,
    returns when awakened. If supplied, pred determines whether the notification is
    spurious (returns `false`) or real (returns `true`). |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| cv`.wait(`lock`, [`pred`])` | 在通知者拥有的互斥锁上获取锁，唤醒时返回。如果提供了`pred`，则确定通知是否是虚假通知（返回`false`）还是有效通知（返回`true`）。
    |'
- en: '| cv`.wait_for(`lock`, [`durn`], [`pred`])` | Same as cv`.wait` except `wait_for`
    only waits for durn. If timeout occurs and no pred is supplied, returns `std::cv_status::timeout`;
    otherwise, returns `std::cv_status::no_timeout`. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| cv`.wait_for(`lock`, [`durn`], [`pred`])` | 与cv`.wait`相同，除了`wait_for`只等待`durn`。如果超时发生且未提供`pred`，返回`std::cv_status::timeout`；否则，返回`std::cv_status::no_timeout`。
    |'
- en: '| cv`.wait_until(`lock`, [`time`], [`pred`])` | Same as `wait_for` except uses
    a `std::chrono::time_point` instead of a `std::chrono::duration`. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| cv`.wait_until(`lock`, [`time`], [`pred`])` | 与`wait_for`相同，只是使用`std::chrono::time_point`而不是`std::chrono::duration`。
    |'
- en: For example, you can refactor [Listing 19-12](ch19.xhtml#ch19ex12) so the *deposit
    cans* task completes before the *eat cans* task using a condition variable, as
    [Listing 19-14](ch19.xhtml#ch19ex14) illustrates.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以重构[清单 19-12](ch19.xhtml#ch19ex12)，使得*放置罐子*任务在*吃罐子*任务之前完成，使用条件变量，正如[清单
    19-14](ch19.xhtml#ch19ex14)所示。
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 19-14: Using condition variables to ensure all cans are deposited
    before they’re eaten*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-14：使用条件变量确保所有罐子在被吃之前都被放置*'
- en: 'You declare a `mutex` ➊ and a `condition_variable` ➋ that you’ll use to coordinate
    the asynchronous tasks. Within the *eat cans* task, you acquire a `unique_lock`
    to the `mutex`, which you pass into `wait` along with a predicate that returns
    `true` if there are cans available ➌. This method will release the mutex and then
    block until two conditions are met: the `condition_variable` awakens this thread
    and one million tin cans are available ➍ (recall that you must check that all
    the cans are available because of spurious wakeups). Within the *deposit cans*
    task, you acquire a lock on the `mutex` ➎, deposit the cans, and then notify all
    threads blocked on the `condition_variable` ➏.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明一个 `mutex` ➊ 和一个 `condition_variable` ➋，你将用它们来协调异步任务。在 *吃罐头* 任务中，你获取一个 `unique_lock`
    对 `mutex` 的锁，并将其与一个谓词一起传递给 `wait`，该谓词如果有罐头可用时返回 `true` ➌。该方法将释放 `mutex`，然后阻塞直到满足两个条件：`condition_variable`
    唤醒该线程，并且有一百万个罐头可用 ➍（记住，你必须检查所有罐头是否可用，因为可能会发生虚假唤醒）。在 *存罐头* 任务中，你获取对 `mutex` ➎ 的锁，存入罐头，然后通知所有在
    `condition_variable` 上阻塞的线程 ➏。
- en: Note that, unlike with all the previous approaches, it’s impossible for `tin_cans_available`
    to be negative because the ordering of deposit cans and eat cans is guaranteed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与之前的所有方法不同，`tin_cans_available` 不可能为负，因为存罐头和吃罐头的顺序是有保障的。
- en: '**NOTE**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For more information about condition variables, refer to *[thread.condition]*.*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关条件变量的更多信息，请参考 *[thread.condition]*。*'
- en: '***Low-Level Concurrency Facilities***'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***低级并发设施***'
- en: The stdlib’s `<thread>` library contains low-level facilities for concurrent
    programming. The `std::thread` class, for example, models an operating system
    thread. However, it’s best not to use `thread` directly and instead design concurrency
    into your programs with higher-level abstractions, like tasks. Should you require
    low-level thread access, [thread] offers more information.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的 `<thread>` 库包含用于并发编程的低级设施。例如，`std::thread` 类模拟了操作系统线程。然而，最好不要直接使用 `thread`，而是通过更高级的抽象设计并发，比如任务。如果你需要低级线程访问，[thread]
    提供了更多信息。
- en: 'But the `<thread>` library does include several useful functions for manipulating
    the current thread:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`<thread>` 库确实包含了几个有用的函数，用于操作当前线程：
- en: The `std::this_thread::yield` function accepts no arguments and returns `void`.
    The exact behavior of `yield` depends on the environment, but in general it provides
    a hint that the operating system should give other threads a chance to run. This
    is useful when, for example, there’s high lock contention over a particular resource
    and you want to help all threads get a chance at access.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::this_thread::yield` 函数不接受任何参数，并返回 `void`。`yield` 的确切行为取决于环境，但通常它提供一个提示，操作系统应该给其他线程一个运行的机会。这在例如，当某个资源的锁竞争很激烈时非常有用，你希望帮助所有线程获得访问的机会。'
- en: The `std::this_thread::get_id` function accepts no arguments and returns an
    object of type `std::thread::id`, which is a lightweight thread that supports
    comparison operators and `operator<<`. Typically, it’s used as a key in associative
    containers.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::this_thread::get_id` 函数不接受任何参数，并返回一个类型为 `std::thread::id` 的对象，这是一个轻量级线程，支持比较操作符和
    `operator<<`。通常，它被用作关联容器中的键。'
- en: The `std::this_thread::sleep_for` function accepts a `std::chrono::duration`
    argument, blocks execution on the current thread until at least the specified
    duration passes, and returns `void`.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::this_thread::sleep_for` 函数接受一个 `std::chrono::duration` 参数，阻塞当前线程的执行，直到至少经过指定的时长，并返回
    `void`。'
- en: The `std::this_thread::sleep_until` accepts a `std::chrono::time_point` and
    returns void. It is entirely analogous to `sleep_for` except it blocks the thread
    until at least the specified `time_point`.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::this_thread::sleep_until` 接受一个 `std::chrono::time_point`，并返回 `void`。它完全类似于
    `sleep_for`，只不过它会阻塞线程直到至少达到指定的 `time_point`。'
- en: When you need these functions, they’re indispensable. Otherwise, you really
    shouldn’t need to interact with the `<thread>` header.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要这些功能时，它们是不可或缺的。否则，你真的不应该需要与 `<thread>` 头文件交互。
- en: '**Parallel Algorithms**'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**并行算法**'
- en: '[Chapter 18](ch18.xhtml) introduced the stdlib’s algorithms, many of which
    take an optional first argument called its execution policy encoded by a `std::execution`
    value. In supported environments, there are three possible values: `seq`, `par`,
    and `par_unseq`. The latter two options indicate that you want to execute the
    algorithm in parallel.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18章](ch18.xhtml)介绍了stdlib的算法，其中许多算法接受一个可选的第一个参数，称为其执行策略，由一个`std::execution`值进行编码。在支持的环境中，有三个可能的值：`seq`、`par`和`par_unseq`。后两个选项表示你希望并行执行算法。'
- en: '***An Example: Parallel sort***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例：并行排序***'
- en: '[Listing 19-15](ch19.xhtml#ch19ex15) illustrates how changing a single argument
    from `seq` to `par` can have a massive impact on a program’s runtime by sorting
    a billion numbers both ways.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例19-15](ch19.xhtml#ch19ex15)展示了如何通过将单一参数从`seq`改为`par`，大幅影响程序运行时间，方法是对十亿个数字进行两种方式的排序。'
- en: '[PRE15]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 19-15: Sorting a billion numbers using `std::sort` with `std::execution::seq`
    versus `std::execution::par`. (Results are from a Windows 10 x64 machine with
    two Intel Xeon E5-2620 v3 processors.)*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例19-15：使用`std::sort`和`std::execution::seq`与`std::execution::par`对十亿个数字进行排序。（结果来自一台Windows
    10 x64机器，配有两颗Intel Xeon E5-2620 v3处理器。）*'
- en: The `make_random_vector` function ➊ produces a `vector` containing a billion
    unique numbers. You build two copies, `numbers_a` ➋ and `numbers_b` ➌. You sort
    each `vector` separately. In the first case, you sort with a sequential execution
    policy ➍, and `Stopwatch` indicates that the operation took about two and a half
    minutes (about 150 seconds). In the second case, you sort with a parallel execution
    policy ➎. In contrast, `Stopwatch` indicates that the operation took about 18
    seconds. The sequential execution took roughly 8.5 times as long.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_random_vector`函数 ➊ 生成一个包含十亿个唯一数字的`vector`。你创建两个副本，`numbers_a` ➋ 和 `numbers_b`
    ➌。你分别对每个`vector`进行排序。在第一种情况下，你使用顺序执行策略进行排序 ➍，`Stopwatch`显示操作花费了大约两分半钟（约150秒）。在第二种情况下，你使用并行执行策略进行排序
    ➎。相比之下，`Stopwatch`显示操作只花费了大约18秒。顺序执行耗时大约是并行执行的8.5倍。'
- en: '***Parallel Algorithms Are Not Magic***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***并行算法并非魔法***'
- en: Unfortunately, parallel algorithms aren’t magic. Although they work brilliantly
    in simple situations, such as with `sort` in [Listing 19-15](ch19.xhtml#ch19ex15),
    you must be careful when using them. Any time an algorithm produces side effects
    beyond the target sequence, you have to think hard about race conditions. A red
    flag is any algorithm that passes a function object to the algorithm. If the function
    object has shared mutable state, the executing threads will have shared access
    and you might have a race condition. For example, consider the parallel `transform`
    invocation in [Listing 19-16](ch19.xhtml#ch19ex16).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并行算法并非魔法。尽管它们在简单情况中表现得非常出色，例如在[示例19-15](ch19.xhtml#ch19ex15)中的`sort`，但在使用时仍需小心。每当算法产生超出目标序列的副作用时，你就必须深入思考竞态条件。一个警示信号是任何向算法传递函数对象的算法。如果函数对象有共享的可变状态，执行的线程将共享访问，可能会发生竞态条件。例如，考虑[示例19-16](ch19.xhtml#ch19ex16)中的并行`transform`调用。
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 19-16: A program containing a race condition due to non-atomic access
    to `n_transformed`*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例19-16：由于非原子访问`n_transformed`而导致的竞态条件程序*'
- en: You begin by initializing two `vector` objects, `numbers` and `squares`, which
    contain a million elements ➊. Next, you fill one of them with numbers using `iota`
    ➋ and initialize the variable `n_transformed` to `0` ➌. You then invoke `transform`
    with a parallel execution policy, `numbers` as your target sequence, `squares`
    as your result sequence, and a simple lambda ➍. The lambda increments `n_transformed`
    ➎ and returns the square of the argument `x` ➏. Because multiple threads execute
    this lambda, access to `n_transformed` must be synchronized ➐.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先初始化两个`vector`对象，`numbers`和`squares`，它们包含一百万个元素 ➊。接着，你使用`iota`填充其中一个 ➋，并将变量`n_transformed`初始化为`0`
    ➌。然后，你使用并行执行策略调用`transform`，将`numbers`作为目标序列，`squares`作为结果序列，并传入一个简单的lambda ➍。这个lambda会递增`n_transformed`
    ➎，并返回参数`x`的平方 ➏。由于多个线程会执行这个lambda，必须对`n_transformed`的访问进行同步 ➐。
- en: The previous section introduced two ways to solve this problem, locks and atomics.
    In this scenario, it’s probably best to just use a `std::atomic_size_t` as a drop-in
    replacement for `size_t`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节介绍了两种解决此问题的方法：锁和原子操作。在这种情况下，最好的方法可能就是直接使用`std::atomic_size_t`来替代`size_t`。
- en: '**Summary**'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'This chapter surveyed concurrency and parallelism at a very high level. In
    addition, you learned how to launch asynchronous tasks, which allow you to easily
    introduce multithreaded programming concepts into your code. Although introducing
    parallel and concurrent concepts into your programs can provide a significant
    performance boost, you must carefully avoid introducing race conditions that invite
    undefined behavior. You also learned several mechanisms for synchronizing access
    to mutable shared state: mutexes, condition variables, and atomics.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '**19-1.** Write your own spin lock-based mutex called `SpinLock`. Expose a
    `lock`, a `try_lock`, and an `unlock` method. Your class should delete the copy
    constructor. Try using a `std::lock_guard<SpinLock>` with an instance of your
    class.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**19-2.** Read about the infamous double-checked locking pattern (DCLP) and
    why you shouldn’t use it. (See the article by Scott Meyers and Andrei Alexandrescu
    mentioned in the following “Further Reading” section.) Then read about the appropriate
    way to ensure that a callable gets invoked exactly once using `std::call_once`
    in [thread.once.callonce].'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '**19-3.** Create a thread-safe queue class. This class must expose an interface
    like `std::queue` (see [queue.defn]). Use a `std::queue` internally to store elements.
    Use a `std::mutex` to synchronize access to this internal `std::queue`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**19-4.** Add a `wait_and_pop` method and a `std::condition_variable` member
    to your thread-safe queue. When a user invokes `wait_and_pop` and the queue contains
    an element, it should pop the element off the queue and return it. If the queue
    is empty, the thread should block until an element becomes available and then
    proceed to pop an element.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**19-5.** (Optional) Read the Boost Coroutine2 documentation, especially the
    “Overview,” “Introduction,” and “Motivation” sections.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '“C++ and The Perils of Double-Checked Locking: [Part I](part01.xhtml#part01)”
    by Scott Meyers and Andrei Alexandrescu ([*http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726/*](http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726/))'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ISO International Standard ISO/IEC (2017) — Programming Language C++* (International
    Organization for Standardization; Geneva, Switzerland; *[https://isocpp.org/std/the-standard/](https://isocpp.org/std/the-standard/)*)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++ Concurrency in Action*, 2nd Edition, by Anthony Williams (Manning, 2018)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“Effective Concurrency: Know When to Use an Active Object Instead of a Mutex”
    by Herb Sutter ([*https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-use-an-active-object-instead-of-a-mutex/*](https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-use-an-active-object-instead-of-a-mutex/))'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective Modern C++: 42 Specific Ways to Improve Your Use of C++ 11 and C++
    14* by Scott Meyers (O’Reilly Media, 2014)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“A Survey of Modern Integer Factorization Algorithms” by Peter L. Montgomery.
    *CWI Quarterly* 7.4 (1994): 337–365.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彼得·L·蒙哥马利的《现代整数分解算法综述》。《CWI季刊》7.4（1994年）：337–365。
