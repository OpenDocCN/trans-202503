["```\n; btoh - This procedure converts the binary value\n;        in the AL register to two hexadecimal\n;        characters and returns those characters\n;        in the AH (HO nibble) and AL (LO nibble)\n;        registers.\n\nbtoh        proc\n\n            mov     ah, al      ; Do HO nibble first\n            shr     ah, 4       ; Move HO nibble to LO\n            or      ah, '0'     ; Convert to char\n            cmp     ah, '9' + 1 ; Is it \"A\" through \"F\"?\n            jb      AHisGood\n\n; Convert 3Ah to 3Fh to \"A\" through \"F\":\n\n            add     ah, 7\n\n; Process the LO nibble here:\n\nAHisGood:   and     al, 0Fh     ; Strip away HO nibble\n            or      al, '0'     ; Convert to char\n            cmp     al, '9' + 1 ; Is it \"A\" through \"F\"?\n            jb      ALisGood\n\n; Convert 3Ah to 3Fh to \"A\" through \"F\":\n\n            add     al, 7\nALisGood:   ret\nbtoh        endp\n```", "```\n; Listing 9-2\n\n; Numeric-to-hex string functions.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 9-2\", 0\nfmtStr1     byte    \"btoStr: Value=%I64x, string=%s\"\n            byte    nl, 0\n\nfmtStr2     byte    \"wtoStr: Value=%I64x, string=%s\"\n            byte    nl, 0\n\nfmtStr3     byte    \"dtoStr: Value=%I64x, string=%s\"\n            byte    nl, 0\n\nfmtStr4     byte    \"qtoStr: Value=%I64x, string=%s\"\n            byte    nl, 0\n\n            .data\nbuffer      byte    20 dup (?)\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n ret\ngetTitle    endp\n\n; btoh - This procedure converts the binary value\n;        in the AL register to two hexadecimal\n;        characters and returns those characters\n;        in the AH (HO nibble) and AL (LO nibble)\n;        registers.\n\nbtoh        proc\n\n            mov     ah, al      ; Do HO nibble first\n            shr     ah, 4       ; Move HO nibble to LO\n            or      ah, '0'     ; Convert to char\n            cmp     ah, '9' + 1 ; Is it \"A\" to \"F\"?\n            jb      AHisGood\n\n; Convert 3Ah through 3Fh to \"A\" to \"F\":\n\n            add     ah, 7\n\n; Process the LO nibble here:\n\nAHisGood:   and     al, 0Fh     ; Strip away HO nibble\n            or      al, '0'     ; Convert to char\n            cmp     al, '9' + 1 ; Is it \"A\" to \"F\"?\n            jb      ALisGood\n\n; Convert 3Ah through 3Fh to \"A\" to \"F\":\n\n            add     al, 7   \nALisGood:   ret\n\nbtoh        endp\n\n; btoStr - Converts the byte in AL to a string of hexadecimal\n;          characters and stores them at the buffer pointed at\n;          by RDI. Buffer must have room for at least 3 bytes.\n;          This function zero-terminates the string.\n\nbtoStr      proc\n            push    rax\n            call    btoh        ; Do conversion here\n\n; Create a zero-terminated string at [RDI] from the\n; two characters we converted to hex format:\n\n            mov     [rdi], ah\n            mov     [rdi + 1], al\n            mov     byte ptr [rdi + 2], 0\n            pop     rax\n            ret\nbtoStr      endp\n\n; wtoStr - Converts the word in AX to a string of hexadecimal\n;          characters and stores them at the buffer pointed at\n;          by RDI. Buffer must have room for at least 5 bytes.\n;          This function zero-terminates the string.\n\nwtoStr      proc\n            push    rdi\n            push    rax     ; Note: leaves LO byte at [RSP]\n\n; Use btoStr to convert HO byte to a string:\n\n            mov     al, ah\n            call    btoStr\n\n            mov     al, [rsp]       ; Get LO byte\n            add     rdi, 2          ; Skip HO chars\n            call    btoStr\n\n            pop     rax\n            pop     rdi\n            ret\nwtoStr      endp\n\n; dtoStr - Converts the dword in EAX to a string of hexadecimal\n;          characters and stores them at the buffer pointed at\n;          by RDI. Buffer must have room for at least 9 bytes.\n;          This function zero-terminates the string.\n\ndtoStr      proc\n            push    rdi\n            push    rax     ; Note: leaves LO word at [RSP]\n\n; Use wtoStr to convert HO word to a string:\n\n            shr     eax, 16\n            call    wtoStr\n\n            mov     ax, [rsp]       ; Get LO word\n            add     rdi, 4          ; Skip HO chars\n            call    wtoStr\n\n            pop     rax\n            pop     rdi\n            ret\ndtoStr      endp\n\n; qtoStr - Converts the qword in RAX to a string of hexadecimal\n;          characters and stores them at the buffer pointed at\n;          by RDI. Buffer must have room for at least 17 bytes.\n;          This function zero-terminates the string.\n\nqtoStr      proc\n            push    rdi\n            push    rax     ; Note: leaves LO dword at [RSP]\n\n; Use dtoStr to convert HO dword to a string:\n\n            shr     rax, 32\n            call    dtoStr\n\n            mov     eax, [rsp]      ; Get LO dword\n            add     rdi, 8          ; Skip HO chars\n            call    dtoStr\n\n            pop     rax\n            pop     rdi\n            ret\nqtoStr      endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rdi\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 64         ; Shadow storage\n\n; Because all the (`x`)toStr functions preserve RDI,\n; we need to do the following only once:\n\n            lea     rdi, buffer\n\n; Demonstrate call to btoStr:\n\n            mov     al, 0aah\n            call    btoStr\n\n            lea     rcx, fmtStr1\n            mov     edx, eax\n            mov     r8, rdi\n            call    printf\n\n; Demonstrate call to wtoStr:\n\n            mov     ax, 0a55ah\n            call    wtoStr\n\n            lea     rcx, fmtStr2\n            mov     edx, eax\n            mov     r8, rdi\n            call    printf\n\n; Demonstrate call to dtoStr:\n\n            mov     eax, 0aa55FF00h\n            call    dtoStr\n\n            lea     rcx, fmtStr3\n            mov     edx, eax\n mov     r8, rdi\n            call    printf\n\n; Demonstrate call to qtoStr:\n\n            mov     rax, 1234567890abcdefh\n            call    qtoStr\n\n            lea     rcx, fmtStr4\n            mov     rdx, rax\n            mov     r8, rdi\n            call    printf\n\n            leave\n            pop     rdi\n            ret     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing9-2**\n\nC:\\>**echo off**\n Assembling: listing9-2.asm\nc.cpp\n\nC:\\>**listing9-2**\nCalling Listing 9-2:\nbtoStr: Value=aa, string=AA\nwtoStr: Value=a55a, string=A55A\ndtoStr: Value=aa55ff00, string=AA55FF00\nqtoStr: Value=1234567890abcdef, string=1234567890ABCDEF\nListing 9-2 terminated\n```", "```\n; qtoStr - Converts the qword in RAX to a string of hexadecimal\n;          characters and stores them at the buffer pointed at\n;          by RDI. Buffer must have room for at least 17 bytes.\n;          This function zero-terminates the string.\n\nhexChar             byte    \"0123456789ABCDEF\"\n\nqtoStr      proc\n            push    rdi\n            push    rcx\n            push    rdx\n            push    rax                ; Leaves LO dword at [RSP]\n\n            lea     rcx, hexChar\n\n            xor     edx, edx           ; Zero-extends!\n            shld    rdx, rax, 4\n            shl     rax, 4\n            mov     dl, [rcx][rdx * 1] ; Table lookup\n            mov     [rdi], dl\n\n; Emit bits 56-59:\n\n            xor     edx, edx\n            shld    rdx, rax, 4\n            shl     rax, 4\n            mov     dl, [rcx][rdx * 1]\n            mov     [rdi + 1], dl\n\n; Emit bits 52-55:\n\n            xor     edx, edx\n            shld    rdx, rax, 4\n            shl     rax, 4\n            mov     dl, [rcx][rdx * 1]\n            mov     [rdi + 2], dl\n             .\n             .\n             .\n `Code to emit bits 8-51 was deleted for length reasons.`\n `The code should be obvious if you look at the output`\n `for the other nibbles appearing here.` \n             .\n             .\n             .\n; Emit bits 4-7:\n\n            xor     edx, edx\n            shld    rdx, rax, 4\n            shl     rax, 4\n            mov     dl, [rcx][rdx * 1]\n            mov     [rdi + 14], dl\n\n; Emit bits 0-3:\n\n            xor     edx, edx\n            shld    rdx, rax, 4\n            shl     rax, 4\n            mov     dl, [rcx][rdx * 1]\n            mov     [rdi + 15], dl\n\n; Zero-terminate string:\n\n            mov     byte ptr [rdi + 16], 0\n\n            pop     rax\n            pop     rdx\n            pop     rcx\n            pop     rdi\n            ret\nqtoStr      endp\n```", "```\n lea     rdi, buffer\n            mov     rax, 07fffffffh\nloopit:     call    qtoStr\n            dec     eax\n            jnz     loopit\n```", "```\n; otoStr - Converts the oword in RDX:RAX to a string of hexadecimal\n;          characters and stores them at the buffer pointed at\n;          by RDI. Buffer must have room for at least 33 bytes.\n;          This function zero-terminates the string.\n\notoStr      proc\n            push    rdi\n            push    rax     ; Note: leaves LO dword at [RSP]\n\n; Use qtoStr to convert each qword to a string:\n\n            mov     rax, rdx\n            call    qtoStr\n\n            mov     rax, [rsp]      ; Get LO qword\n            add     rdi, 16         ; Skip HO chars\n            call    qtoStr\n\n            pop     rax\n            pop     rdi\n            ret\notoStr      endp\n```", "```\n; Listing 9-4\n\n; Numeric unsigned integer-to-string function.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 9-4\", 0\nfmtStr1     byte    \"utoStr: Value=%I64u, string=%s\"\n            byte    nl, 0\n\n            .data\nbuffer      byte    24 dup (?)\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; utoStr - Unsigned integer to string.\n\n; Inputs:\n\n;    RAX:   Unsigned integer to convert.\n;    RDI:   Location to hold string.\n\n; Note: for 64-bit integers, resulting\n; string could be as long as 21 bytes\n; (including the zero-terminating byte).\n\nutoStr      proc\n            push    rax\n            push    rdx\n            push    rdi\n\n; Handle zero specially:\n\n            test    rax, rax\n            jnz     doConvert\n\n            mov     byte ptr [rdi], '0'\n            inc     rdi\n            jmp     allDone \n\ndoConvert:  call    rcrsvUtoStr\n\n; Zero-terminate the string and return:\n\nallDone:    mov     byte ptr [rdi], 0\n            pop     rdi\n            pop     rdx\n            pop     rax\n            ret\nutoStr      endp\n\nten         qword   10\n\n; Here's the recursive code that does the\n; actual conversion:\n\nrcrsvUtoStr proc\n\n            xor     rdx, rdx           ; Zero-extend RAX -> RDX\n            div     ten\n            push    rdx                ; Save output value\n            test    eax, eax           ; Quit when RAX is 0\n            jz      allDone \n\n; Recursive call to handle value % 10:\n\n            call    rcrsvUtoStr\n\nallDone:    pop     rax                ; Retrieve char to print\n            and     al, 0Fh            ; Convert to \"0\" to \"9\"\n            or      al, '0'\n            mov     byte ptr [rdi], al ; Save in buffer\n            inc     rdi                ; Next char position\n            ret\nrcrsvUtoStr endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rdi\n push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56         ; Shadow storage\n\n; Because all the (`x`)toStr functions preserve RDI,\n; we need to do the following only once:\n\n            lea     rdi, buffer\n            mov     rax, 1234567890\n            call    utoStr\n\n; Print the result:\n\n            lea     rcx, fmtStr1\n            mov     rdx, rax\n            mov     r8, rdi\n            call    printf\n\n            leave\n            pop     rdi\n            ret     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing9-4**\n\nC:\\>**echo off**\n Assembling: listing9-4.asm\nc.cpp\n\nC:\\>**listing9-4**\nCalling Listing 9-4:\nutoStr: Value=1234567890, string=1234567890\nListing 9-4 terminated\n```", "```\n; Listing 9-5\n\n; Fast unsigned integer-to-string function\n; using fist and fbstp.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 9-5\", 0\nfmtStr1     byte    \"utoStr: Value=%I64u, string=%s\"\n            byte    nl, 0\n\n            .data\nbuffer      byte    30 dup (?)\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; utoStr - Unsigned integer to string.\n\n; Inputs:\n\n;    RAX:   Unsigned integer to convert.\n;    RDI:   Location to hold string.\n\n; Note: for 64-bit integers, resulting\n; string could be as long as 21 bytes\n; (including the zero-terminating byte).\n\nbigNum      qword   1000000000000000000\nutoStr      proc\n            push    rcx\n            push    rdx\n            push    rdi\n            push    rax\n            sub     rsp, 10\n\n; Quick test for zero to handle that special case:\n\n            test    rax, rax\n            jnz     not0\n            mov     byte ptr [rdi], '0'\n            jmp     allDone\n\n; The FBSTP instruction supports only 18 digits.\n; 64-bit integers can have up to 19 digits.\n; Handle that 19th possible digit here:\n\nnot0:       cmp     rax, bigNum\n            jb      lt19Digits\n\n; The number has 19 digits (which can be 0-9).\n; Pull off the 19th digit:\n\n            xor     edx, edx\n            div     bigNum            ; 19th digit in AL\n            mov     [rsp + 10], rdx   ; Remainder\n            or      al, '0'\n            mov     [rdi], al\n            inc     rdi\n\n; The number to convert is nonzero.\n; Use BCD load and store to convert\n; the integer to BCD:\n\nlt19Digits: fild    qword ptr [rsp + 10]\n            fbstp   tbyte ptr [rsp]\n\n; Begin by skipping over leading zeros in\n; the BCD value (max 19 digits, so the most\n; significant digit will be in the LO nibble\n; of DH).\n\n            mov     dx, [rsp + 8]\n            mov     rax, [rsp]\n            mov     ecx, 20\n            jmp     testFor0\n\nSkip0s:     shld    rdx, rax, 4\n            shl     rax, 4\ntestFor0:   dec     ecx         ; Count digits we've processed\n            test    dh, 0fh     ; Because the number is not 0\n            jz      Skip0s      ; this always terminates\n\n; At this point the code has encountered\n; the first nonzero digit. Convert the remaining\n; digits to a string:\n\ncnvrtStr:   and     dh, 0fh\n            or      dh, '0'\n            mov     [rdi], dh\n            inc     rdi\n            mov     dh, 0\n            shld    rdx, rax, 4\n            shl     rax, 4\n            dec     ecx\n            jnz     cnvrtStr\n\n; Zero-terminate the string and return:\n\nallDone:    mov     byte ptr [rdi], 0\n            add     rsp, 10\n            pop     rax\n            pop     rdi\n            pop     rdx\n            pop     rcx\n            ret\nutoStr      endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 64         ; Shadow storage\n\n; Because all the (`x`)toStr functions preserve RDI,\n; we need to do the following only once:\n\n            lea     rdi, buffer\n            mov     rax, 9123456789012345678\n            call    utoStr\n\n            lea     rcx, fmtStr1\n            mov     rdx, 9123456789012345678\n            lea     r8, buffer\n            call    printf\n\n            leave\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing9-5**\n\nC:\\>**echo off**\n Assembling: listing9-5.asm\nc.cpp\n\nC:\\>**listing9-5**\nCalling Listing 9-5:\nutoStr: Value=9123456789012345678, string=9123456789012345678\nListing 9-5 terminated\n```", "```\n; itoStr - Signed integer-to-string conversion.\n\n; Inputs:\n;    RAX -   Signed integer to convert.\n;    RDI -   Destination buffer address.\n\nitoStr      proc\n            push    rdi\n            push    rax\n            test    rax, rax\n            jns     notNeg\n\n; Number was negative, emit \"-\" and negate\n; value.\n\n mov     byte ptr [rdi], '-'\n            inc     rdi\n            neg     rax\n\n; Call utoStr to convert non-negative number:\n\nnotNeg:     call    utoStr\n            pop     rax\n            pop     rdi\n            ret\nitoStr      endp\n```", "```\n; Listing 9-7\n\n; Extended-precision numeric unsigned \n; integer-to-string function.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 9-7\", 0\nfmtStr1     byte    \"otoStr(0): string=%s\", nl, 0\nfmtStr2     byte    \"otoStr(1234567890): string=%s\", nl, 0\nfmtStr3     byte    \"otoStr(2147483648): string=%s\", nl, 0\nfmtStr4     byte    \"otoStr(4294967296): string=%s\", nl, 0\nfmtStr5     byte    \"otoStr(FFF...FFFF): string=%s\", nl, 0\n\n            .data\nbuffer      byte    40 dup (?)\n\nb0          oword   0\nb1          oword   1234567890\nb2          oword   2147483648\nb3          oword   4294967296\n\n; Largest oword value\n; (decimal=340,282,366,920,938,463,463,374,607,431,768,211,455):\n\nb4          oword   0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFh\n\n .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; DivideBy10 - Divides \"divisor\" by 10 using fast\n;              extended-precision division algorithm\n;              that employs the div instruction.\n\n; Returns quotient in \"quotient.\"\n; Returns remainder in RAX.\n; Trashes RDX.\n\n; RCX - Points at oword dividend and location to\n;       receive quotient.\n\nten         qword   10\n\nDivideBy10  proc\nparm        equ     <[rcx]>\n\n            xor     edx, edx       ; Zero-extends!\n            mov     rax, parm[8]\n            div     ten\n            mov     parm[8], rax\n\n            mov     rax, parm\n            div     ten\n            mov     parm, rax\n            mov     eax, edx       ; Remainder (always \"0\" to \"9\"!)\n            ret    \nDivideBy10  endp\n\n; Recursive version of otoStr.\n; A separate \"shell\" procedure calls this so that\n; this code does not have to preserve all the registers\n; it uses (and DivideBy10 uses) on each recursive call.\n\n; On entry:\n;    Stack - Contains oword in/out parameter (dividend in/quotient out).\n;    RDI   - Contains location to place output string.\n\n; Note: this function must clean up stack (parameters)\n;       on return.\n\nrcrsvOtoStr proc\nvalue       equ     <[rbp + 16]>\nremainder   equ     <[rbp - 8]>\n            push    rbp\n mov     rbp, rsp\n            sub     rsp, 8\n            lea     rcx, value\n            call    DivideBy10\n            mov     remainder, al\n\n; If the quotient (left in value) is not 0, recursively\n; call this routine to output the HO digits.\n\n            mov     rax, value\n            or      rax, value[8]\n            jz      allDone\n\n            mov     rax, value[8]\n            push    rax\n            mov     rax, value\n            push    rax\n            call    rcrsvOtoStr\n\nallDone:    mov     al, remainder\n            or      al, '0'\n            mov     [rdi], al\n            inc     rdi\n            leave\n            ret     16      ; Remove parms from stack\nrcrsvOtoStr endp\n\n; Nonrecursive shell to the above routine so we don't bother\n; saving all the registers on each recursive call.\n\n; On entry:\n\n;   RDX:RAX - Contains oword to print.\n;   RDI     - Buffer to hold string (at least 40 bytes).\n\notostr      proc\n\n            push    rax\n            push    rcx\n            push    rdx\n            push    rdi\n\n; Special-case zero:\n\n            test    rax, rax\n            jnz     not0\n            test    rdx, rdx\n            jnz     not0\n            mov     byte ptr [rdi], '0'\n            inc     rdi\n            jmp     allDone\n\nnot0:       push    rdx\n push    rax\n            call    rcrsvOtoStr\n\n; Zero-terminate string before leaving:\n\nallDone:    mov     byte ptr [rdi], 0\n\n            pop     rdi\n            pop     rdx\n            pop     rcx\n            pop     rax\n            ret\n\notostr      endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rdi\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56         ; Shadow storage\n\n; Because all the (`x`)toStr functions preserve RDI,\n; we need to do the following only once:\n\n            lea     rdi, buffer\n\n; Convert b0 to a string and print the result:\n\n            mov     rax, qword ptr b0\n            mov     rdx, qword ptr b0[8]\n            call    otostr\n\n            lea     rcx, fmtStr1\n            lea     rdx, buffer\n            call    printf\n\n; Convert b1 to a string and print the result:\n\n            mov     rax, qword ptr b1\n            mov     rdx, qword ptr b1[8]\n            call    otostr\n\n            lea     rcx, fmtStr2\n            lea     rdx, buffer\n            call    printf\n\n; Convert b2 to a string and print the result:\n\n            mov     rax, qword ptr b2\n            mov     rdx, qword ptr b2[8]\n call    otostr\n\n            lea     rcx, fmtStr3\n            lea     rdx, buffer\n            call    printf\n\n; Convert b3 to a string and print the result:\n\n            mov     rax, qword ptr b3\n            mov     rdx, qword ptr b3[8]\n            call    otostr\n\n            lea     rcx, fmtStr4\n            lea     rdx, buffer\n            call    printf\n\n; Convert b4 to a string and print the result:\n\n            mov     rax, qword ptr b4\n            mov     rdx, qword ptr b4[8]\n            call    otostr\n\n            lea     rcx, fmtStr5\n            lea     rdx, buffer\n            call    printf\n\n            leave\n            pop     rdi\n            ret     ; Returns to caller\n\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing9-7**\n\nC:\\>**echo off**\n Assembling: listing9-7.asm\nc.cpp\n\nC:\\>**listing9-7**\nCalling Listing 9-7:\notoStr(0): string=0\notoStr(1234567890): string=1234567890\notoStr(2147483648): string=2147483648\notoStr(4294967296): string=4294967296\notoStr(FFF...FFFF):\n        string=340282366920938463463374607431768211455\nListing 9-7 terminated\n```", "```\n; i128toStr - Converts a 128-bit signed integer to a string.\n\n; Inputs:\n;    RDX:RAX - Signed integer to convert.\n;    RDI     - Pointer to buffer to receive string.\n\ni128toStr   proc\n            push    rax\n            push    rdx\n            push    rdi\n\n            test    rdx, rdx  ; Is number negative?\n            jns     notNeg\n\n            mov     byte ptr [rdi], '-'\n            inc     rdi\n            neg     rdx       ; 128-bit negation\n            neg     rax\n            sbb     rdx, 0\n\nnotNeg:     call    otostr\n            pop     rdi\n            pop     rdx\n            pop     rax\n            ret\ni128toStr   endp\n```", "```\n; uSize - Determines how many character positions it will take\n;         to hold a 64-bit numeric-to-string conversion.\n\n; Input:\n;   RAX -    Number to check.\n\n; Returns:\n;   RAX -    Number of character positions required.\n\ndig2        qword   10\ndig3        qword   100\ndig4        qword   1000\ndig5        qword   10000\ndig6        qword   100000\ndig7        qword   1000000\ndig8        qword   10000000\ndig9        qword   100000000\ndig10       qword   1000000000\ndig11       qword   10000000000\ndig12       qword   100000000000\ndig13       qword   1000000000000\ndig14       qword   10000000000000\ndig15       qword   100000000000000\ndig16       qword   1000000000000000\ndig17       qword   10000000000000000\ndig18       qword   100000000000000000\ndig19       qword   1000000000000000000\ndig20       qword   10000000000000000000\n\nuSize       proc\n            push    rdx\n            cmp     rax, dig10\n            jae     ge10\n            cmp     rax, dig5\n            jae     ge5\n            mov     edx, 4\n            cmp     rax, dig4\n            jae     allDone\n            dec     edx\n            cmp     rax, dig3\n            jae     allDone\n            dec     edx\n            cmp     rax, dig2\n            jae     allDone\n            dec     edx\n            jmp     allDone\n\nge5:        mov     edx, 9\n            cmp     rax, dig9\n            jae     allDone\n            dec     edx\n            cmp     rax, dig8\n            jae     allDone\n            dec     edx\n            cmp     rax, dig7\n            jae     allDone\n            dec     edx\n            cmp     rax, dig6\n            jae     allDone\n            dec     edx      ; Must be 5\n            jmp     allDone\n\nge10:       cmp     rax, dig14\n            jae     ge14\n            mov     edx, 13\n            cmp     rax, dig13\n            jae     allDone\n            dec     edx\n            cmp     rax, dig12\n            jae     allDone\n            dec     edx\n            cmp     rax, dig11\n            jae     allDone\n            dec     edx      ; Must be 10\n            jmp     allDone\n\nge14:       mov     edx, 20\n            cmp     rax, dig20\n            jae     allDone\n            dec     edx\n            cmp     rax, dig19\n            jae     allDone\n            dec     edx\n            cmp     rax, dig18\n jae     allDone\n            dec     edx\n            cmp     rax, dig17\n            jae     allDone\n            dec     edx\n            cmp     rax, dig16\n            jae     allDone\n            dec     edx\n            cmp     rax, dig15\n            jae     allDone\n            dec     edx      ; Must be 14\n\nallDone:    mov     rax, rdx ; Return digit count\n            pop     rdx\n            ret\nuSize       endp\n```", "```\n; iSize - Determines the number of print positions required by \n;         a 64-bit signed integer.\n\niSize       proc\n            test    rax, rax\n            js      isNeg\n\n            jmp     uSize   ; Effectively a call and ret\n\n; If the number is negative, negate it, call uSize,\n; and then bump the size up by 1 (for the \"-\" character):\n\nisNeg:      neg     rax\n            call    uSize\n            inc     rax\n            ret\niSize       endp\n```", "```\n; utoStrSize - Converts an unsigned integer to a formatted string\n;              having at least \"minDigits\" character positions.\n;              If the actual number of digits is smaller than\n;              \"minDigits\" then this procedure inserts enough\n;              \"pad\" characters to extend the size of the string.\n\n; Inputs:\n;    RAX -   Number to convert to string.\n;    CL  -   minDigits (minimum print positions).\n;    CH  -   Padding character.\n;    RDI -   Buffer pointer for output string.\n\nutoStrSize  proc\n            push    rcx\n            push    rdi\n            push    rax\n\n            call    uSize           ; Get actual number of digits\n            sub     cl, al          ; >= the minimum size?\n            jbe     justConvert\n\n; If the minimum size is greater than the number of actual\n; digits, we need to emit padding characters here.\n\n; Note that this code used \"sub\" rather than \"cmp\" above.\n; As a result, CL now contains the number of padding\n; characters to emit to the string (CL is always positive\n; at this point as negative and zero results would have\n; branched to justConvert).\n\npadLoop:    mov     [rdi], ch\n            inc     rdi\n            dec     cl\n            jne     padLoop\n\n; Okay, any necessary padding characters have already been\n; added to the string. Call utoStr to convert the number\n; to a string and append to the buffer:\n\njustConvert:\n            mov     rax, [rsp]      ; Retrieve original value\n            call    utoStr\n\n            pop     rax\n            pop     rdi\n pop     rcx\n            ret\nutoStrSize  endp\n\n; itoStrSize - Converts a signed integer to a formatted string\n;              having at least \"minDigits\" character positions.\n;              If the actual number of digits is smaller than\n;              \"minDigits\" then this procedure inserts enough\n;              \"pad\" characters to extend the size of the string.\n\n; Inputs:\n;    RAX -   Number to convert to string.\n;    CL  -   minDigits (minimum print positions).\n;    CH  -   Padding character.\n;    RDI -   Buffer pointer for output string.\n\nitoStrSize  proc\n            push    rcx\n            push    rdi\n            push    rax\n\n            call    iSize           ; Get actual number of digits\n            sub     cl, al          ; >= the minimum size?\n            jbe     justConvert\n\n; If the minimum size is greater than the number of actual\n; digits, we need to emit padding characters here.\n\n; Note that this code used \"sub\" rather than \"cmp\" above.\n; As a result, CL now contains the number of padding\n; characters to emit to the string (CL is always positive\n; at this point as negative and zero results would have\n; branched to justConvert).\n\npadLoop:    mov     [rdi], ch\n            inc     rdi\n            dec     cl\n            jne     padLoop\n\n; Okay, any necessary padding characters have already been\n; added to the string. Call utoStr to convert the number\n; to a string and append to the buffer:\n\njustConvert:\n            mov     rax, [rsp]     ; Retrieve original value\n            call    itoStr\n\n            pop     rax\n            pop     rdi\n            pop     rcx\n            ret\nitoStrSize  endp\n```", "```\n .data\n\n            align   4\n\n; TenTo17 - Holds the value 1.0e+17\\. Used to get a floating-\n;           point number into the range `x.xxxxxxxxxxxx`e+17.\n\nTenTo17     real10  1.0e+17\n\n; PotTblN - Hold powers of 10 raised to negative powers of 2.\n\nPotTblN     real10  1.0,\n                    1.0e-1,\n                    1.0e-2,\n                    1.0e-4,\n                    1.0e-8,\n                    1.0e-16,\n                    1.0e-32,\n 1.0e-64,\n                    1.0e-128,\n                    1.0e-256,\n                    1.0e-512,\n                    1.0e-1024,\n                    1.0e-2048,\n                    1.0e-4096\n\n; PotTblP - Hold powers of 10 raised to positive powers of 2.\n\n            align   4\nPotTblP     real10  1.0,\n                    1.0e+1,\n                    1.0e+2,\n                    1.0e+4,\n                    1.0e+8,\n                    1.0e+16,\n                    1.0e+32,\n                    1.0e+64,\n                    1.0e+128,\n                    1.0e+256,\n                    1.0e+512,\n                    1.0e+1024,\n                    1.0e+2048,\n                    1.0e+4096\n\n; ExpTbl - Integer equivalents to the powers\n;          in the tables above.\n\n            align   4\nExpTab      dword   0,\n                    1,\n                    2,\n                    4,\n                    8,\n                    16,\n                    32,\n                    64,\n                    128,\n                    256,\n                    512,\n                    1024,\n                    2048,\n                    4096\n               .\n               .\n               .\n\n*************************************************************\n\n; FPDigits - Used to convert a floating-point number on the FPU\n;            stack (ST(0)) to a string of digits.\n\n; Entry Conditions:\n\n; ST(0) -    80-bit number to convert.\n;            Note: code requires two free FPU stack elements.\n; RDI   -    Points at array of at least 18 bytes where \n;            FPDigits stores the output string.\n\n; Exit Conditions:\n\n; RDI   -    Converted digits are found here.\n; RAX   -    Contains exponent of the number.\n; CL    -    Contains the sign of the mantissa (\" \" or \"-\").\n; ST(0) -    Popped from stack.\n\n*************************************************************\n\nP10TblN     equ     <real10 ptr [r8]>\nP10TblP     equ     <real10 ptr [r9]>\nxTab        equ     <dword ptr [r10]>\n\nFPDigits    proc\n            push    rbx\n            push    rdx\n            push    rsi\n            push    r8\n            push    r9\n            push    r10\n\n; Special case if the number is zero.\n\n            ftst\n            fstsw   ax\n            sahf\n            jnz     fpdNotZero\n\n; The number is zero, output it as a special case.\n\n            fstp    tbyte ptr [rdi] ; Pop value off FPU stack\n            mov     rax, \"00000000\"\n            mov     [rdi], rax \n            mov     [rdi + 8], rax \n            mov     [rdi + 16], ax\n            add     rdi, 18 \n            xor     edx, edx        ; Return an exponent of 0\n            mov     bl, ' '         ; Sign is positive\n            jmp     fpdDone\n\nfpdNotZero:\n\n; If the number is not zero, then fix the sign of the value.\n\n            mov     bl, ' '         ; Assume it's positive\n            jnc     WasPositive     ; Flags set from sahf above\n\n fabs                 ; Deal only with positive numbers\n            mov     bl, '-'      ; Set the sign return result\n\nWasPositive:\n\n; Get the number between 1 and 10 so we can figure out \n; what the exponent is.  Begin by checking to see if we have\n; a positive or negative exponent.\n\n            xor     edx, edx     ; Initialize exponent to 0\n            fld1\n            fcomip  st(0), st(1)\n            jbe     PosExp\n\n; We've got a value between zero and one, exclusive,\n; at this point.  That means this number has a negative\n; exponent.  Multiply the number by an appropriate power\n; of 10 until we get it in the range 1 through 10.\n\n            mov     esi, sizeof PotTblN  ; After last element\n            mov     ecx, sizeof ExpTab   ; Ditto\n            lea     r8, PotTblN\n            lea     r9, PotTblP\n            lea     r10, ExpTab\n\nCmpNegExp:\n            sub     esi, 10          ; Move to previous element\n            sub     ecx, 4           ; Zeroes HO bytes\n            jz      test1\n\n            fld     P10TblN[rsi * 1] ; Get current power of 10\n            fcomip  st(0), st(1)     ; Compare against NOS\n            jbe     CmpNegExp        ; While Table >= value\n\n            mov     eax, xTab[rcx * 1]\n            test    eax, eax\n            jz      didAllDigits\n\n            sub     edx, eax\n            fld     P10TblP[rsi * 1]\n            fmulp\n            jmp     CmpNegExp\n\n; If the remainder is *exactly* 1.0, then we can branch\n; on to InRange1_10; otherwise, we still have to multiply\n; by 10.0 because we've overshot the mark a bit.\n\ntest1:\n            fld1\n            fcomip  st(0), st(1)\n            je      InRange1_10\n\ndidAllDigits:\n\n; If we get to this point, then we've indexed through\n; all the elements in the PotTblN and it's time to stop.\n\n            fld     P10TblP[10]   ; 10.0\n            fmulp\n            dec     edx\n            jmp     InRange1_10\n\n; At this point, we've got a number that is 1 or greater.\n; Once again, our task is to get the value between 1 and 10.\n\nPosExp:\n\n            mov     esi, sizeof PotTblP ; After last element\n            mov     ecx, sizeof ExpTab  ; Ditto\n            lea     r9, PotTblP\n            lea     r10, ExpTab\n\nCmpPosExp:\n            sub     esi, 10             ; Move back 1 element in\n            sub     ecx, 4              ; PotTblP and ExpTbl\n            fld     P10TblP[rsi * 1]\n            fcomip  st(0), st(1)\n            ja      CmpPosExp;\n            mov     eax, xTab[rcx * 1]\n            test    eax, eax\n            jz      InRange1_10\n\n            add     edx, eax\n            fld     P10TblP[rsi * 1]\n            fdivp\n            jmp     CmpPosExp\n\nInRange1_10:\n\n; Okay, at this point the number is in the range 1 <= x < 10.\n; Let's multiply it by 1e+18 to put the most significant digit\n; into the 18th print position.  Then convert the result to\n; a BCD value and store away in memory.\n\n            sub     rsp, 24         ; Make room for BCD result\n            fld     TenTo17\n            fmulp\n\n; We need to check the floating-point result to make sure it\n; is not outside the range we can legally convert to a BCD \n; value.\n\n; Illegal values will be in the range:\n\n; >999,999,999,999,999,999 ... <1,000,000,000,000,000,000\n; $403a_de0b_6b3a_763f_ff01 ... $403a_de0b_6b3a_763f_ffff\n\n; Should one of these values appear, round the result up to\n; $403a_de0b_6b3a_7640_0000:\n\n            fstp    real10 ptr [rsp]\n            cmp     word ptr [rsp + 8], 403ah\n            jne     noRounding\n\n            cmp     dword ptr [rsp + 4], 0de0b6b3ah\n            jne     noRounding\n\n            mov     eax, [rsp]\n            cmp     eax, 763fff01h\n            jb      noRounding;\n            cmp     eax, 76400000h\n            jae     TooBig\n\n            fld     TenTo17\n            inc     edx           ; Inc exp as this is really 10^18\n            jmp     didRound\n\n; If we get down here, there were problems getting the\n; value in the range 1 <= x <= 10 above and we've got a value\n; that is 10e+18 or slightly larger. We need to compensate for\n; that here.\n\nTooBig:\n            lea     r9, PotTblP\n            fld     real10 ptr [rsp]\n            fld     P10TblP[10]   ; /10\n            fdivp\n            inc     edx           ; Adjust exp due to fdiv\n            jmp     didRound\n\nnoRounding:\n            fld     real10 ptr [rsp]\ndidRound:   \n            fbstp   tbyte ptr [rsp]\n\n; The data on the stack contains 18 BCD digits. Convert these\n; to ASCII characters and store them at the destination location\n; pointed at by EDI.\n\n            mov     ecx, 8\nrepeatLp:\n            mov     al, byte ptr [rsp + rcx]\n            shr     al, 4         ; Always in the\n            or      al, '0'       ; range \"0\" to \"9\"\n            mov     [rdi], al\n            inc     rdi\n\n            mov     al, byte ptr [rsp + rcx]\n            and     al, 0fh\n or      al, '0'\n            mov     [rdi], al\n            inc     rdi\n\n            dec     ecx\n            jns     repeatLp\n\n            add     rsp, 24         ; Remove BCD data from stack\n\nfpdDone:\n\n            mov     eax, edx        ; Return exponent in EAX\n            mov     cl, bl          ; Return sign in CL\n            pop     r10\n            pop     r9\n            pop     r8\n            pop     rsi\n            pop     rdx\n            pop     rbx\n            ret\n\nFPDigits    endp\n```", "```\n`exponent` + 2 + `decDigits` + (0 if `decDigits` is 0, 1 otherwise)\n```", "```\n***********************************************************\n\n; r10ToStr -  Converts a real10 floating-point number to the\n;             corresponding string of digits.  Note that this\n;             function always emits the string using decimal\n;             notation.  For scientific notation, use the e10ToBuf\n;             routine.\n\n; On Entry:\n\n;    r10        -    real10 value to convert.\n;                    Passed in ST(0).\n\n;    fWidth     -    Field width for the number (note that this\n;                    is an *exact* field width, not a minimum\n;                    field width).\n;                    Passed in EAX (RAX).\n\n;    decimalpts -    # of digits to display after the decimal pt.\n;                    Passed in EDX (RDX). \n\n;    fill       -    Padding character if the number is smaller\n;                    than the specified field width.\n;                    Passed in CL (RCX).\n\n;    buffer     -    Stores the resulting characters in\n;                    this string.\n;                    Address passed in RDI.\n\n;    maxLength  -    Maximum string length.\n;                    Passed in R8d (R8).\n\n; On Exit:\n\n; Buffer contains the newly formatted string.  If the\n; formatted value does not fit in the width specified,\n; r10ToStr will store \"#\" characters into this string.\n\n; Carry -    Clear if success; set if an exception occurs.\n;            If width is larger than the maximum length of\n;            the string specified by buffer, this routine\n;            will return with the carry set and RAX = -1,\n;            -2, or -3.\n\n***********************************************************\n\nr10ToStr    proc\n\n; Local variables:\n\nfWidth      equ     <dword ptr [rbp - 8]>    ; RAX: uns32\ndecDigits   equ     <dword ptr [rbp - 16]>   ; RDX: uns32\nfill        equ     <[rbp - 24]>             ; CL: char\nbufPtr      equ     <[rbp - 32]>             ; RDI: pointer\nexponent    equ     <dword ptr [rbp - 40]>   ; uns32\nsign        equ     <byte ptr [rbp - 48]>    ; char\ndigits      equ     <byte ptr [rbp - 128]>   ; char[80]\nmaxWidth    =       64              ; Must be smaller than 80 - 2\n\n            push    rdi\n            push    rbx\n            push    rcx\n            push    rdx\n            push    rsi\n            push    rax\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 128        ; 128 bytes of local vars\n\n; First, make sure the number will fit into the \n; specified string.\n\n            cmp     eax, r8d        ; R8d = max length\n            jae     strOverflow\n\n; If the width is zero, raise an exception:\n\n            test    eax, eax\n            jz      voor            ; Value out of range\n\n            mov     bufPtr, rdi\n            mov     qword ptr decDigits, rdx\n            mov     fill, rcx\n            mov     qword ptr fWidth, rax\n\n; If the width is too big, raise an exception:\n\n            cmp     eax, maxWidth\n            ja      badWidth\n\n; Okay, do the conversion.\n; Begin by processing the mantissa digits:\n\n            lea     rdi, digits     ; Store result here\n            call    FPDigits        ; Convert r80 to string\n            mov     exponent, eax   ; Save exp result\n            mov     sign, cl        ; Save mantissa sign char\n\n; Round the string of digits to the number of significant \n; digits we want to display for this number:\n\n            cmp     eax, 17\n            jl      dontForceWidthZero\n\n            xor     rax, rax        ; If the exp is negative or\n                                    ; too large, set width to 0\ndontForceWidthZero:\n            mov     rbx, rax        ; Really just 8 bits\n            add     ebx, decDigits  ; Compute rounding position\n            cmp     ebx, 17\n            jge     dontRound       ; Don't bother if a big #\n\n; To round the value to the number of significant digits,\n; go to the digit just beyond the last one we are considering\n; (EAX currently contains the number of decimal positions)\n; and add 5 to that digit.  Propagate any overflow into the\n; remaining digit positions.\n\n            inc     ebx                 ; Index + 1 of last sig digit\n            mov     al, digits[rbx * 1] ; Get that digit\n            add     al, 5               ; Round (for example, +0.5)\n            cmp     al, '9'\n            jbe     dontRound\n\n            mov     digits[rbx * 1], '0' + 10 ; Force to zero\n\nwhileDigitGT9:                                ; (See sub 10 below)\n            sub     digits[rbx * 1], 10       ; Sub out overflow, \n            dec     ebx                       ; carry, into prev\n            js      hitFirstDigit;            ; digit (until 1st\n                                              ; digit in the #)\n            inc     digits[rbx * 1]\n            cmp     digits[rbx], '9'          ; Overflow if > \"9\"\n            ja      whileDigitGT9\n            jmp     dontRound\n\nhitFirstDigit:\n\n; If we get to this point, then we've hit the first\n; digit in the number.  So we've got to shift all\n; the characters down one position in the string of\n; bytes and put a \"1\" in the first character position.\n\n            mov     ebx, 17\n\nrepeatUntilEBXeq0:\n\n            mov     al, digits[rbx * 1]\n            mov     digits[rbx * 1 + 1], al\n            dec     ebx\n            jnz     repeatUntilEBXeq0\n\n            mov     digits, '1'\n inc     exponent    ; Because we added a digit\n\ndontRound: \n\n; Handle positive and negative exponents separately.\n\n            mov     rdi, bufPtr ; Store the output here\n            cmp     exponent, 0\n            jge     positiveExponent\n\n; Negative exponents:\n; Handle values between 0 and 1.0 here (negative exponents\n; imply negative powers of 10).\n\n; Compute the number's width.  Since this value is between\n; 0 and 1, the width calculation is easy: it's just the\n; number of decimal positions they've specified plus three\n; (since we need to allow room for a leading \"-0.\").\n\n            mov     ecx, decDigits\n            add     ecx, 3\n            cmp     ecx, 4\n            jae     minimumWidthIs4\n\n            mov     ecx, 4      ; Minimum possible width is four\n\nminimumWidthIs4:\n            cmp     ecx, fWidth\n            ja      widthTooBig \n\n; This number will fit in the specified field width,\n; so output any necessary leading pad characters.\n\n            mov     al, fill\n            mov     edx, fWidth\n            sub     edx, ecx\n            jmp     testWhileECXltWidth\n\nwhileECXltWidth:\n            mov     [rdi], al\n            inc     rdi\n            inc     ecx\n\ntestWhileECXltWidth:\n            cmp     ecx, fWidth\n            jb      whileECXltWidth\n\n; Output \" 0.\" or \"-0.\", depending on the sign of the number.\n\n            mov     al, sign\n            cmp     al, '-'\n            je      isMinus\n\n            mov     al, ' '\n\nisMinus:    mov     [rdi], al\n            inc     rdi\n            inc     edx\n\n            mov     word ptr [rdi], '.0'\n            add     rdi, 2\n            add     edx, 2\n\n; Now output the digits after the decimal point:\n\n            xor     ecx, ecx        ; Count the digits in ECX\n            lea     rbx, digits     ; Pointer to data to output d\n\n; If the exponent is currently negative, or if\n; we've output more than 18 significant digits,\n; just output a zero character.\n\nrepeatUntilEDXgeWidth: \n            mov     al, '0'\n            inc     exponent\n            js      noMoreOutput\n\n            cmp     ecx, 18\n            jge     noMoreOutput\n\n            mov     al, [rbx]\n            inc     ebx\n\nnoMoreOutput:\n            mov     [rdi], al\n            inc     rdi\n            inc     ecx\n            inc     edx\n            cmp     edx, fWidth\n            jb      repeatUntilEDXgeWidth\n            jmp     r10BufDone\n\n; If the number's actual width was bigger than the width\n; specified by the caller, emit a sequence of \"#\" characters\n; to denote the error.\n\nwidthTooBig:\n\n; The number won't fit in the specified field width,\n; so fill the string with the \"#\" character to indicate\n; an error.\n\n            mov     ecx, fWidth\n            mov     al, '#'\nfillPound:  mov     [rdi], al\n            inc     rdi\n            dec     ecx\n            jnz     fillPound\n            jmp     r10BufDone\n\n; Handle numbers with a positive exponent here.\n\npositiveExponent:\n\n; Compute # of digits to the left of the \".\".\n; This is given by:\n\n;                   Exponent        ; # of digits to left of \".\"\n;           +       2               ; Allow for sign and there\n;                                   ; is always 1 digit left of \".\"\n;           +       decimalpts      ; Add in digits right of \".\"\n;           +       1               ; If there is a decimal point\n\n            mov     edx, exponent   ; Digits to left of \".\"\n            add     edx, 2          ; 1 digit + sign posn\n            cmp     decDigits, 0\n            je      decPtsIs0\n\n            add     edx, decDigits  ; Digits to right of \".\"\n            inc     edx             ; Make room for the \".\"\n\ndecPtsIs0:\n\n; Make sure the result will fit in the\n; specified field width.\n\n            cmp     edx, fWidth\n            ja      widthTooBig\n\n; If the actual number of print positions\n; is fewer than the specified field width,\n; output leading pad characters here.\n\n            cmp     edx, fWidth\n            jae     noFillChars\n\n            mov     ecx, fWidth\n            sub     ecx, edx\n            jz      noFillChars\n            mov     al, fill\nfillChars:  mov     [rdi], al\n            inc     rdi\n            dec     ecx\n            jnz     fillChars\n\nnoFillChars:\n\n; Output the sign character.\n\n            mov     al, sign\n            cmp     al, '-'\n            je      outputMinus;\n\n            mov     al, ' '\n\noutputMinus:\n            mov     [rdi], al\n            inc     rdi\n\n; Okay, output the digits for the number here.\n\n            xor     ecx, ecx        ; Counts # of output chars\n            lea     rbx, digits     ; Ptr to digits to output\n\n; Calculate the number of digits to output\n; before and after the decimal point.\n\n            mov     edx, decDigits  ; Chars after \".\"\n            add     edx, exponent   ; # chars before \".\"\n            inc     edx             ; Always one digit before \".\"\n\n; If we've output fewer than 18 digits, go ahead\n; and output the next digit.  Beyond 18 digits,\n; output zeros.\n\nrepeatUntilEDXeq0:\n            mov     al, '0'\n            cmp     ecx, 18\n            jnb     putChar\n\n            mov     al, [rbx]\n            inc     rbx\n\nputChar:    mov     [rdi], al\n            inc     rdi\n\n; If the exponent decrements to zero,\n; then output a decimal point.\n\n            cmp     exponent, 0\n            jne     noDecimalPt\n            cmp     decDigits, 0\n            je      noDecimalPt\n\n            mov     al, '.'\n            mov     [rdi], al\n            inc     rdi\n\nnoDecimalPt:\n            dec     exponent        ; Count down to \".\" output\n            inc     ecx             ; # of digits thus far\n            dec     edx             ; Total # of digits to output\n            jnz     repeatUntilEDXeq0\n\n; Zero-terminate string and leave:\n\nr10BufDone: mov     byte ptr [rdi], 0\n            leave\n            clc                     ; No error\n            jmp     popRet\n\nbadWidth:   mov     rax, -2     ; Illegal width\n            jmp     ErrorExit\n\nstrOverflow:\n            mov     rax, -3     ; String overflow\n            jmp     ErrorExit\n\nvoor:       or      rax, -1     ; Range error\nErrorExit:  leave\n            stc     ; Error\n            mov     [rsp], rax  ; Change RAX on return\n\npopRet:     pop     rax\n            pop     rsi\n            pop     rdx\n            pop     rcx\n            pop     rbx\n            pop     rdi\n            ret\n\nr10ToStr    endp\n```", "```\n*************************************************************\n\n; expToBuf - Unsigned integer to buffer.\n;            Used to output up to 4-digit exponents.\n\n; Inputs:\n\n;    EAX:   Unsigned integer to convert.\n;    ECX:   Print width 1-4.\n;    RDI:   Points at buffer.\n\n;    FPU:   Uses FPU stack.\n\n; Returns:\n\n;    RDI:   Points at end of buffer.\n\nexpToBuf    proc\n\nexpWidth    equ     <[rbp + 16]>\nexp         equ     <[rbp + 8]>\nbcd         equ     <[rbp - 16]>\n\n            push    rdx\n            push    rcx            ; At [RBP + 16]\n            push    rax            ; At [RBP + 8]\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 16\n\n; Verify exponent digit count is in the range 1-4:\n\n            cmp     rcx, 1\n            jb      badExp\n            cmp     rcx, 4\n            ja      badExp\n            mov     rdx, rcx\n\n; Verify the actual exponent will fit in the number of digits:\n\n            cmp     rcx, 2\n            jb      oneDigit\n            je      twoDigits\n            cmp     rcx, 3\n            ja      fillZeros      ; 4 digits, no error\n            cmp     eax, 1000\n            jae     badExp\n            jmp     fillZeros\n\noneDigit:   cmp     eax, 10\n            jae     badExp\n            jmp     fillZeros\n\ntwoDigits:  cmp     eax, 100\n            jae     badExp\n\n; Fill in zeros for exponent:\n\nfillZeros:  mov     byte ptr [rdi + rcx * 1 - 1], '0'\n            dec     ecx\n            jnz     fillZeros\n\n; Point RDI at the end of the buffer:\n\n            lea     rdi, [rdi + rdx * 1 - 1]\n            mov     byte ptr [rdi + 1], 0\n            push    rdi             ; Save pointer to end\n\n; Quick test for zero to handle that special case:\n\n            test    eax, eax\n            jz      allDone\n\n; The number to convert is nonzero.\n; Use BCD load and store to convert\n; the integer to BCD:\n\n            fild    dword ptr exp   ; Get integer value\n            fbstp   tbyte ptr bcd   ; Convert to BCD\n\n; Begin by skipping over leading zeros in\n; the BCD value (max 10 digits, so the most\n; significant digit will be in the HO nibble\n; of byte 4).\n\n            mov     eax, bcd        ; Get exponent digits\n            mov     ecx, expWidth   ; Number of total digits\n\nOutputExp:  mov     dl, al\n            and     dl, 0fh\n            or      dl, '0'\n            mov     [rdi], dl\n            dec     rdi\n            shr     ax, 4\n            jnz     OutputExp\n\n; Zero-terminate the string and return:\n\nallDone:    pop     rdi\n            leave\n            pop     rax\n            pop     rcx\n            pop     rdx\n            clc\n            ret\n\nbadExp:     leave\n            pop     rax\n pop     rcx\n            pop     rdx\n            stc\n            ret\n\nexpToBuf    endp\n```", "```\n***********************************************************\n\n; e10ToStr - Converts a real10 floating-point number to the\n;            corresponding string of digits.  Note that this\n;            function always emits the string using scientific\n;            notation; use the r10ToStr routine for decimal notation.  \n\n; On Entry:\n\n;    e10         -   real10 value to convert.\n;                    Passed in ST(0).\n\n;    width       -   Field width for the number (note that this\n;                    is an *exact* field width, not a minimum\n;                    field width).\n;                    Passed in RAX (LO 32 bits).\n\n;    fill        -   Padding character if the number is smaller\n;                    than the specified field width.\n;                    Passed in RCX.\n\n;    buffer      -   e10ToStr stores the resulting characters in\n;                    this buffer (passed in RDI).\n\n;    expDigs     -   Number of exponent digits (2 for real4,\n;                    3 for real8, and 4 for real10).\n;                    Passed in RDX (LO 8 bits).\n\n;    maxLength   -   Maximum buffer size.\n;                    Passed in R8\\.                           \n\n; On Exit:                                                  \n\n;    RDI         -  Points at end of converted string.      \n\n; Buffer contains the newly formatted string.  If the    \n; formatted value does not fit in the width specified,   \n; e10ToStr will store \"#\" characters into this string.   \n\n; If there was an error, EAX contains -1, -2, or -3      \n; denoting the error (value out of range, bad width,     \n; or string overflow, respectively).                     \n\n***********************************************************\n\n; Unlike the integer-to-string conversions, this routine    \n; always right-justifies the number in the specified        \n; string.  Width must be a positive number; negative        \n; values are illegal (actually, they are treated as         \n; *really* big positive numbers that will always raise      \n; a string overflow exception).                              \n\n***********************************************************\n\ne10ToStr    proc\n\nfWidth      equ     <[rbp - 8]>       ; RAX\nbuffer      equ     <[rbp - 16]>      ; RDI\nexpDigs     equ     <[rbp - 24]>      ; RDX\nrbxSave     equ     <[rbp - 32]>\nrcxSave     equ     <[rbp - 40]>\nrsiSave     equ     <[rbp - 48]>\nExponent    equ     <dword ptr [rbp - 52]>\nMantSize    equ     <dword ptr [rbp - 56]>\nSign        equ     <byte ptr [rbp - 60]>\nDigits      equ     <byte ptr [rbp - 128]>\n\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 128\n\n            mov     buffer, rdi\n            mov     rsiSave, rsi\n            mov     rcxSave, rcx\n            mov     rbxSave, rbx\n            mov     fWidth, rax\n            mov     expDigs, rdx\n\n            cmp     eax, r8d\n            jae     strOvfl\n            mov     byte ptr [rdi + rax * 1], 0 ; Zero-terminate str\n\n; First, make sure the width isn't zero.\n\n            test    eax, eax\n            jz      voor\n\n; Just to be on the safe side, don't allow widths greater \n; than 1024:\n\n            cmp     eax, 1024\n            ja      badWidth\n\n; Okay, do the conversion.\n\n            lea     rdi, Digits     ; Store result string here\n            call    FPDigits        ; Convert e80 to digit str\n            mov     Exponent, eax   ; Save away exponent result\n            mov     Sign, cl        ; Save mantissa sign char\n\n; Verify that there is sufficient room for the mantissa's sign,\n; the decimal point, two mantissa digits, the \"E\", and the\n; exponent's sign.  Also add in the number of digits required\n; by the exponent (2 for real4, 3 for real8, 4 for real10).\n\n; -1.2e+00    :real4\n; -1.2e+000   :real8\n; -1.2e+0000  :real10\n\n            mov     ecx, 6          ; Char posns for above chars\n            add     ecx, expDigs    ; # of digits for the exp\n            cmp     ecx, fWidth\n            jbe     goodWidth\n\n; Output a sequence of \"#...#\" chars (to the specified width)\n; if the width value is not large enough to hold the \n; conversion:\n\n            mov     ecx, fWidth\n            mov     al, '#'\n            mov     rdi, buffer\nfillPound:  mov     [rdi], al\n            inc     rdi\n            dec     ecx\n            jnz     fillPound\n            jmp     exit_eToBuf\n\n; Okay, the width is sufficient to hold the number; do the\n; conversion and output the string here:\n\ngoodWidth:\n\n            mov     ebx, fWidth     ; Compute the # of mantissa\n            sub     ebx, ecx        ; digits to display\n            add     ebx, 2          ; ECX allows for 2 mant digs\n            mov     MantSize,ebx\n\n; Round the number to the specified number of print positions.\n; (Note: since there are a maximum of 18 significant digits,\n; don't bother with the rounding if the field width is greater\n; than 18 digits.)\n\n cmp     ebx, 18\n            jae     noNeedToRound\n\n; To round the value to the number of significant digits,\n; go to the digit just beyond the last one we are considering\n; (EBX currently contains the number of decimal positions)\n; and add 5 to that digit.  Propagate any overflow into the\n; remaining digit positions.\n\n            mov     al, Digits[rbx * 1] ; Get least sig digit + 1\n            add     al, 5               ; Round (for example, +0.5)\n            cmp     al, '9'\n            jbe     noNeedToRound\n            mov     Digits[rbx * 1], '9' + 1\n            jmp     whileDigitGT9Test\n\nwhileDigitGT9:\n\n; Subtract out overflow and add the carry into the previous\n; digit (unless we hit the first digit in the number).\n\n            sub     Digits[rbx * 1], 10     \n            dec     ebx                     \n            cmp     ebx, 0                  \n            jl      firstDigitInNumber      \n\n            inc     Digits[rbx * 1]\n            jmp     whileDigitGT9Test\n\nfirstDigitInNumber:\n\n; If we get to this point, then we've hit the first\n; digit in the number.  So we've got to shift all\n; the characters down one position in the string of\n; bytes and put a \"1\" in the first character position.\n\n            mov     ebx, 17\nrepeatUntilEBXeq0:\n\n            mov     al, Digits[rbx * 1]\n            mov     Digits[rbx * 1 + 1], al\n            dec     ebx\n            jnz     repeatUntilEBXeq0\n\n            mov     Digits, '1'\n            inc     Exponent         ; Because we added a digit\n            jmp     noNeedToRound\n\nwhileDigitGT9Test:\n            cmp     Digits[rbx], '9' ; Overflow if char > \"9\"\n            ja      whileDigitGT9 \n\nnoNeedToRound:      \n\n; Okay, emit the string at this point.  This is pretty easy\n; since all we really need to do is copy data from the\n; digits array and add an exponent (plus a few other simple chars).\n\n            xor     ecx, ecx    ; Count output mantissa digits\n            mov     rdi, buffer\n            xor     edx, edx    ; Count output chars\n            mov     al, Sign\n            cmp     al, '-'\n            je      noMinus\n\n            mov     al, ' '\n\nnoMinus:    mov     [rdi], al\n\n; Output the first character and a following decimal point\n; if there are more than two mantissa digits to output.\n\n            mov     al, Digits\n            mov     [rdi + 1], al\n            add     rdi, 2\n            add     edx, 2\n            inc     ecx\n            cmp     ecx, MantSize\n            je      noDecPt\n\n            mov     al, '.'\n            mov     [rdi], al\n            inc     rdi\n            inc     edx\n\nnoDecPt:\n\n; Output any remaining mantissa digits here.\n; Note that if the caller requests the output of\n; more than 18 digits, this routine will output zeros\n; for the additional digits.\n\n            jmp     whileECXltMantSizeTest\n\nwhileECXltMantSize:\n\n            mov     al, '0'\n            cmp     ecx, 18\n            jae     justPut0\n\n            mov     al, Digits[rcx * 1]\n\njustPut0:\n            mov     [rdi], al\n            inc     rdi\n            inc     ecx\n            inc     edx\n\nwhileECXltMantSizeTest:\n            cmp     ecx, MantSize\n            jb      whileECXltMantSize\n\n; Output the exponent:\n\n            mov     byte ptr [rdi], 'e'\n            inc     rdi\n            inc     edx\n            mov     al, '+'\n            cmp     Exponent, 0\n            jge     noNegExp\n\n            mov     al, '-'\n            neg     Exponent\n\nnoNegExp:\n            mov     [rdi], al\n            inc     rdi\n            inc     edx\n\n            mov     eax, Exponent\n            mov     ecx, expDigs\n            call    expToBuf\n            jc      error\n\nexit_eToBuf:\n            mov     rsi, rsiSave\n            mov     rcx, rcxSave\n            mov     rbx, rbxSave\n            mov     rax, fWidth\n            mov     rdx, expDigs\n            leave\n            clc\n            ret\n\nstrOvfl:    mov     rax, -3\n            jmp     error\n\nbadWidth:   mov     rax, -2\n            jmp     error\n\nvoor:       mov     rax, -1\nerror:      mov     rsi, rsiSave\n            mov     rcx, rcxSave\n            mov     rbx, rbxSave\n            mov     rdx, expDigs\n            leave\n            stc\n            ret\n\ne10ToStr   endp\n```", "```\n; Listing 9-14\n\n; String-to-numeric conversion.\n\n        option  casemap:none\n\nfalse       =       0\ntrue        =       1\ntab         =       9\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 9-14\", 0\nfmtStr1     byte    \"strtou: String='%s'\", nl\n            byte    \"    value=%I64u\", nl, 0\n\nfmtStr2     byte    \"Overflow: String='%s'\", nl\n            byte    \"    value=%I64x\", nl, 0\n\nfmtStr3     byte    \"strtoi: String='%s'\", nl\n            byte    \"    value=%I64i\",nl, 0\n\nunexError   byte    \"Unexpected error in program\", nl, 0\n\nvalue1      byte    \"  1\", 0\nvalue2      byte    \"12 \", 0\nvalue3      byte    \" 123 \", 0\nvalue4      byte    \"1234\", 0\nvalue5      byte    \"1234567890123456789\", 0\nvalue6      byte    \"18446744073709551615\", 0\nOFvalue     byte    \"18446744073709551616\", 0\nOFvalue2    byte    \"999999999999999999999\", 0\n\nivalue1     byte    \"  -1\", 0\nivalue2     byte    \"-12 \", 0\nivalue3     byte    \" -123 \", 0\nivalue4     byte    \"-1234\", 0\nivalue5     byte    \"-1234567890123456789\", 0\nivalue6     byte    \"-9223372036854775807\", 0\nOFivalue    byte    \"-9223372036854775808\", 0\nOFivalue2   byte    \"-999999999999999999999\", 0\n\n            .data\nbuffer      byte    30 dup (?)\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; strtou -   Converts string data to a 64-bit unsigned integer.\n\n; Input:\n;   RDI  -   Pointer to buffer containing string to convert.\n\n; Output:\n;   RAX  -   Contains converted string (if success), error code\n;            if an error occurs.\n\n;   RDI  -   Points at first char beyond end of numeric string.\n;            If error, RDI's value is restored to original value.\n;            Caller can check character at [RDI] after a\n;            successful result to see if the character following\n;            the numeric digits is a legal numeric delimiter.\n\n;   C    -   (carry flag) Set if error occurs, clear if\n;            conversion was successful. On error, RAX will\n;            contain 0 (illegal initial character) or\n;            0FFFFFFFFFFFFFFFFh (overflow).\n\nstrtou      proc\n            push    rdi      ; In case we have to restore RDI\n            push    rdx      ; Munged by mul \n            push    rcx      ; Holds input char\n\n xor     edx, edx ; Zero-extends!\n            xor     eax, eax ; Zero-extends!\n\n; The following loop skips over any whitespace (spaces and\n; tabs) that appears at the beginning of the string.\n\n            dec     rdi      ; Because of inc below\nskipWS:     inc     rdi\n            mov     cl, [rdi]\n            cmp     cl, ' '\n            je      skipWS\n            cmp     al, tab\n            je      skipWS\n\n; If we don't have a numeric digit at this point,\n; return an error.\n\n            cmp     cl, '0'  ; Note: \"0\" < \"1\" < ... < \"9\"\n            jb      badNumber\n            cmp     cl, '9'\n            ja      badNumber\n\n; Okay, the first digit is good. Convert the string\n; of digits to numeric form:\n\nconvert:    and     ecx, 0fh ; Convert to numeric in RCX\n            mul     ten      ; Accumulator *= 10\n            jc      overflow\n            add     rax, rcx ; Accumulator += digit\n            jc      overflow\n            inc     rdi      ; Move on to next character\n            mov     cl, [rdi]\n            cmp     cl, '0'\n            jb      endOfNum\n            cmp     cl, '9'\n            jbe     convert\n\n; If we get to this point, we've successfully converted\n; the string to numeric form:\n\nendOfNum:   pop     rcx\n            pop     rdx\n\n; Because the conversion was successful, this procedure\n; leaves RDI pointing at the first character beyond the\n; converted digits. As such, we don't restore RDI from\n; the stack. Just bump the stack pointer up by 8 bytes\n; to throw away RDI's saved value.\n\n            add     rsp, 8\n            clc              ; Return success in carry flag\n            ret\n\n; badNumber - Drop down here if the first character in\n;             the string was not a valid digit.\n\nbadNumber:  mov     rax, 0\n            pop     rcx\n            pop     rdx\n            pop     rdi\n            stc              ; Return error in carry flag\n            ret     \n\noverflow:   mov     rax, -1  ; 0FFFFFFFFFFFFFFFFh\n            pop     rcx\n            pop     rdx\n            pop     rdi\n            stc              ; Return error in carry flag\n            ret\n\nten         qword   10\n\nstrtou      endp\n\n; strtoi - Converts string data to a 64-bit signed integer.\n\n; Input:\n;   RDI  -   Pointer to buffer containing string to convert.\n\n; Output:\n;   RAX  -   Contains converted string (if success), error code\n;            if an error occurs.\n\n;   RDI  -   Points at first char beyond end of numeric string.\n;            If error, RDI's value is restored to original value.\n;            Caller can check character at [RDI] after a\n;            successful result to see if the character following\n;            the numeric digits is a legal numeric delimiter.\n\n;   C    -   (carry flag) Set if error occurs, clear if\n;            conversion was successful. On error, RAX will\n;            contain 0 (illegal initial character) or\n;            0FFFFFFFFFFFFFFFFh (-1, indicating overflow).\n\nstrtoi      proc\nnegFlag     equ     <byte ptr [rsp]>\n\n            push    rdi      ; In case we have to restore RDI\n            sub     rsp, 8\n\n; Assume we have a non-negative number.\n\n            mov     negFlag, false\n\n; The following loop skips over any whitespace (spaces and\n; tabs) that appears at the beginning of the string.\n\n            dec     rdi      ; Because of inc below\nskipWS:     inc     rdi\n            mov     al, [rdi]\n            cmp     al, ' '\n            je      skipWS\n            cmp     al, tab\n            je      skipWS\n\n; If the first character we've encountered is \"-\",\n; then skip it, but remember that this is a negative\n; number.\n\n            cmp     al, '-'\n            jne     notNeg\n            mov     negFlag, true\n            inc     rdi             ; Skip \"-\"\n\nnotNeg:     call    strtou          ; Convert string to integer\n            jc      hadError\n\n; strtou returned success. Check the negative flag and\n; negate the input if the flag contains true.\n\n            cmp     negFlag, true\n            jne     itsPosOr0\n\n            cmp     rax, tooBig     ; Number is too big\n            ja      overflow\n            neg     rax\nitsPosOr0:  add     rsp, 16         ; Success, so don't restore RDI\n            clc                     ; Return success in carry flag\n            ret\n\n; If we have an error, we need to restore RDI from the stack:\n\noverflow:   mov     rax, -1         ; Indicate overflow\nhadError:   add     rsp, 8          ; Remove locals\n            pop     rdi\n            stc                     ; Return error in carry flag\n            ret \n\ntooBig      qword   7fffffffffffffffh\nstrtoi      endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 64         ; Shadow storage\n\n; Test unsigned conversions:\n\n            lea     rdi, value1\n            call    strtou\n\njc      UnexpectedError\n\n            lea     rcx, fmtStr1\n            lea     rdx, value1\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, value2\n            call    strtou\n            jc      UnexpectedError\n\n            lea     rcx, fmtStr1\n            lea     rdx, value2\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, value3\n            call    strtou\n            jc      UnexpectedError\n\n            lea     rcx, fmtStr1\n            lea     rdx, value3\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, value4\n            call    strtou\n            jc      UnexpectedError\n\n            lea     rcx, fmtStr1\n            lea     rdx, value4\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, value5\n            call    strtou\n            jc      UnexpectedError\n\n            lea     rcx, fmtStr1\n            lea     rdx, value5\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, value6\n            call    strtou\n            jc      UnexpectedError\n\n            lea     rcx, fmtStr1\n            lea     rdx, value6\n            mov     r8, rax\n            call    printf\n\n lea     rdi, OFvalue\n            call    strtou\n            jnc     UnexpectedError\n            test    rax, rax        ; Nonzero for overflow\n            jz      UnexpectedError\n\n            lea     rcx, fmtStr2\n            lea     rdx, OFvalue\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, OFvalue2\n            call    strtou\n            jnc     UnexpectedError\n            test    rax, rax        ; Nonzero for overflow\n            jz      UnexpectedError\n\n            lea     rcx, fmtStr2\n            lea     rdx, OFvalue2\n            mov     r8, rax\n            call    printf\n\n; Test signed conversions:\n\n            lea     rdi, ivalue1\n            call    strtoi\n            jc      UnexpectedError\n\n            lea     rcx, fmtStr3\n            lea     rdx, ivalue1\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, ivalue2\n            call    strtoi\n            jc      UnexpectedError\n\n            lea     rcx, fmtStr3\n            lea     rdx, ivalue2\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, ivalue3\n            call    strtoi\n            jc      UnexpectedError\n\n            lea     rcx, fmtStr3\n            lea     rdx, ivalue3\n            mov     r8, rax\n            call    printf\n\n lea     rdi, ivalue4\n            call    strtoi\n            jc      UnexpectedError\n\n            lea     rcx, fmtStr3\n            lea     rdx, ivalue4\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, ivalue5\n            call    strtoi\n            jc      UnexpectedError\n\n            lea     rcx, fmtStr3\n            lea     rdx, ivalue5\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, ivalue6\n            call    strtoi\n            jc      UnexpectedError\n\n            lea     rcx, fmtStr3\n            lea     rdx, ivalue6\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, OFivalue\n            call    strtoi\n            jnc     UnexpectedError\n            test    rax, rax        ; Nonzero for overflow\n            jz      UnexpectedError\n\n            lea     rcx, fmtStr2\n            lea     rdx, OFivalue\n            mov     r8, rax\n            call    printf\n\n            lea     rdi, OFivalue2\n            call    strtoi\n            jnc     UnexpectedError\n            test    rax, rax        ; Nonzero for overflow\n            jz      UnexpectedError\n\n            lea     rcx, fmtStr2\n            lea     rdx, OFivalue2\n            mov     r8, rax\n            call    printf\n\n            jmp     allDone\n\nUnexpectedError:\n            lea     rcx, unexError\n            call    printf\n\nallDone:    leave\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing9-14**\n\nC:\\>**echo off**\n Assembling: listing9-14.asm\nc.cpp\n\nC:\\>**listing9-14**\nCalling Listing 9-14:\nstrtou: String='  1'\n    value=1\nstrtou: String='12 '\n    value=12\nstrtou: String=' 123 '\n    value=123\nstrtou: String='1234'\n    value=1234\nstrtou: String='1234567890123456789'\n    value=1234567890123456789\nstrtou: String='18446744073709551615'\n    value=18446744073709551615\nOverflow: String='18446744073709551616'\n    value=ffffffffffffffff\nOverflow: String='999999999999999999999'\n    value=ffffffffffffffff\nstrtoi: String='  -1'\n    value=-1\nstrtoi: String='-12 '\n    value=-12\nstrtoi: String=' -123 '\n    value=-123\nstrtoi: String='-1234'\n    value=-1234\nstrtoi: String='-1234567890123456789'\n    value=-1234567890123456789\nstrtoi: String='-9223372036854775807'\n    value=-9223372036854775807\nOverflow: String='-9223372036854775808'\n    value=ffffffffffffffff\nOverflow: String='-999999999999999999999'\n    value=ffffffffffffffff\nListing 9-14 terminated\n```", "```\n; Listing 9-15\n\n; Hexadecimal string-to-numeric conversion.\n\n        option  casemap:none\n\nfalse       =       0\ntrue        =       1\ntab         =       9\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 9-15\", 0\nfmtStr1     byte    \"strtoh: String='%s' \"\n            byte    \"value=%I64x\", nl, 0\n\nfmtStr2     byte    \"Error, RAX=%I64x, str='%s'\", nl, 0 \nfmtStr3     byte    \"Error, expected overflow: RAX=%I64x, \"\n            byte    \"str='%s'\", nl, 0\n\nfmtStr4     byte    \"Error, expected bad char: RAX=%I64x, \"\n            byte    \"str='%s'\", nl, 0 \n\nhexStr      byte    \"1234567890abcdef\", 0\nhexStrOVFL  byte    \"1234567890abcdef0\", 0\nhexStrBAD   byte    \"x123\", 0\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; strtoh -   Converts string data to a 64-bit unsigned integer.\n\n; Input:\n;   RDI  -   Pointer to buffer containing string to convert.\n\n; Output:\n;   RAX  -   Contains converted string (if success), error code\n;            if an error occurs.\n\n;   RDI  -   Points at first char beyond end of hexadecimal string.\n;            If error, RDI's value is restored to original value.\n;            Caller can check character at [RDI] after a\n;            successful result to see if the character following\n;            the numeric digits is a legal numeric delimiter.\n\n;   C    -   (carry flag) Set if error occurs, clear if\n;            conversion was successful. On error, RAX will\n;            contain 0 (illegal initial character) or\n;            0FFFFFFFFFFFFFFFFh (overflow).\n\nstrtoh      proc\n            push    rcx      ; Holds input char\n            push    rdx      ; Special mask value\n            push    rdi      ; In case we have to restore RDI\n\n; This code will use the value in RDX to test and see if overflow\n; will occur in RAX when shifting to the left 4 bits:\n\n            mov     rdx, 0F000000000000000h\n            xor     eax, eax ; Zero out accumulator\n\n; The following loop skips over any whitespace (spaces and\n; tabs) that appears at the beginning of the string.\n\n            dec     rdi      ; Because of inc below\nskipWS:     inc     rdi\n            mov     cl, [rdi]\n            cmp     cl, ' '\n            je      skipWS\n            cmp     al, tab\n            je      skipWS\n\n; If we don't have a hexadecimal digit at this point,\n; return an error.\n\n cmp     cl, '0'  ; Note: \"0\" < \"1\" < ... < \"9\"\n            jb      badNumber\n            cmp     cl, '9'\n            jbe     convert\n            and     cl, 5fh  ; Cheesy LC -> UC conversion\n            cmp     cl, 'A'\n            jb      badNumber\n            cmp     cl, 'F'\n            ja      badNumber\n            sub     cl, 7    ; Maps 41h to 46h -> 3Ah to 3Fh\n\n; Okay, the first digit is good. Convert the string\n; of digits to numeric form:\n\nconvert:    test    rdx, rax ; See if adding in the current\n            jnz     overflow ; digit will cause an overflow\n\n            and     ecx, 0fh ; Convert to numeric in RCX\n\n; Multiply 64-bit accumulator by 16 and add in new digit:\n\n            shl     rax, 4\n            add     al, cl   ; Never overflows outside LO 4 bits\n\n; Move on to next character:\n\n            inc     rdi\n            mov     cl, [rdi]\n            cmp     cl, '0'\n            jb      endOfNum\n            cmp     cl, '9'\n            jbe     convert\n\n            and     cl, 5fh  ; Cheesy LC -> UC conversion\n            cmp     cl, 'A'\n            jb      endOfNum\n            cmp     cl, 'F'\n            ja      endOfNum\n            sub     cl, 7    ; Maps 41h to 46h -> 3Ah to 3Fh\n            jmp     convert\n\n; If we get to this point, we've successfully converted\n; the string to numeric form:\n\nendOfNum:\n\n; Because the conversion was successful, this procedure\n; leaves RDI pointing at the first character beyond the\n; converted digits. As such, we don't restore RDI from\n; the stack. Just bump the stack pointer up by 8 bytes\n; to throw away RDI's saved value.\n\n add     rsp, 8   ; Remove original RDI value\n            pop     rdx      ; Restore RDX\n            pop     rcx      ; Restore RCX\n            clc              ; Return success in carry flag\n            ret\n\n; badNumber- Drop down here if the first character in\n;            the string was not a valid digit.\n\nbadNumber:  xor     rax, rax\n            jmp     errorExit\n\noverflow:   or      rax, -1  ; Return -1 as error on overflow\nerrorExit:  pop     rdi      ; Restore RDI if an error occurs\n            pop     rdx\n            pop     rcx\n            stc              ; Return error in carry flag\n            ret\n\nstrtoh      endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 64  ; Shadow storage\n\n; Test hexadecimal conversion:\n\n            lea     rdi, hexStr\n            call    strtoh\n            jc      error\n\n            lea     rcx, fmtStr1\n            mov     r8, rax\n            lea     rdx, hexStr\n            call    printf\n\n; Test overflow conversion:\n\n            lea     rdi, hexStrOVFL\n            call    strtoh\n            jnc     unexpected\n\n            lea     rcx, fmtStr2\n            mov     rdx, rax\n            mov     r8, rdi\n            call    printf\n\n; Test bad character:\n\n            lea     rdi, hexStrBAD\n            call    strtoh\n            jnc     unexp2\n\n            lea     rcx, fmtStr2\n            mov     rdx, rax\n            mov     r8, rdi\n            call    printf\n            jmp     allDone\n\nunexpected: lea     rcx, fmtStr3\n            mov     rdx, rax\n            mov     r8, rdi\n            call    printf\n            jmp     allDone\n\nunexp2:     lea     rcx, fmtStr4\n            mov     rdx, rax\n            mov     r8, rdi\n            call    printf\n            jmp     allDone\n\nerror:      lea     rcx, fmtStr2\n            mov     rdx, rax\n            mov     r8, rdi\n            call    printf\n\nallDone:    leave\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing9-15**\n\nC:\\>**echo off**\n Assembling: listing9-15.asm\nc.cpp\n\nC:\\>**listing9-15**\nCalling Listing 9-15:\nstrtoh: String='1234567890abcdef' value=1234567890abcdef\nError, RAX=ffffffffffffffff, str='1234567890abcdef0'\nError, RAX=0, str='x123'\nListing 9-15 terminated\n```", "```\n; strtoh128 - Converts string data to a 128-bit unsigned integer.\n\n; Input:\n;   RDI     - Pointer to buffer containing string to convert.\n\n; Output:\n;   RDX:RAX - Contains converted string (if success), error code\n;             if an error occurs.\n\n;   RDI     - Points at first char beyond end of hex string.\n;             If error, RDI's value is restored to original value.\n;             Caller can check character at [RDI] after a\n;             successful result to see if the character following\n;             the numeric digits is a legal numeric delimiter.\n\n;   C       - (carry flag) Set if error occurs, clear if\n;             conversion was successful. On error, RAX will\n;             contain 0 (illegal initial character) or\n;             0FFFFFFFFFFFFFFFFh (overflow).\n\nstrtoh128   proc\n            push    rbx      ; Special mask value\n            push    rcx      ; Input char to process\n            push    rdi      ; In case we have to restore RDI\n\n; This code will use the value in RDX to test and see if overflow\n; will occur in RAX when shifting to the left 4 bits:\n\n            mov     rbx, 0F000000000000000h\n            xor     eax, eax ; Zero out accumulator\n            xor     edx, edx\n\n; The following loop skips over any whitespace (spaces and\n; tabs) that appears at the beginning of the string.\n\n            dec     rdi      ; Because of inc below\nskipWS:     inc     rdi\n            mov     cl, [rdi]\n            cmp     cl, ' '\n            je      skipWS\n            cmp     al, tab\n            je      skipWS\n\n; If we don't have a hexadecimal digit at this point,\n; return an error.\n\n            cmp     cl, '0'  ; Note: \"0\" < \"1\" < ... < \"9\"\n            jb      badNumber\n            cmp     cl, '9'\n            jbe     convert\n and     cl, 5fh  ; Cheesy LC -> UC conversion\n            cmp     cl, 'A'\n            jb      badNumber\n            cmp     cl, 'F'\n            ja      badNumber\n            sub     cl, 7    ; Maps 41h to 46h -> 3Ah to 3Fh\n\n; Okay, the first digit is good. Convert the string\n; of digits to numeric form:\n\nconvert:    test    rdx, rbx ; See if adding in the current\n            jnz     overflow ; digit will cause an overflow\n\n            and     ecx, 0fh ; Convert to numeric in RCX\n\n; Multiply 64-bit accumulator by 16 and add in new digit:\n\n            shld    rdx, rax, 4\n            shl     rax, 4\n            add     al, cl   ; Never overflows outside LO 4 bits\n\n; Move on to next character:\n\n            inc     rdi      \n            mov     cl, [rdi]\n            cmp     cl, '0'\n            jb      endOfNum\n            cmp     cl, '9'\n            jbe     convert\n\n            and     cl, 5fh  ; Cheesy LC -> UC conversion\n            cmp     cl, 'A'\n            jb      endOfNum\n            cmp     cl, 'F'\n            ja      endOfNum\n            sub     cl, 7    ; Maps 41h to 46h -> 3Ah to 3Fh\n            jmp     convert\n\n; If we get to this point, we've successfully converted\n; the string to numeric form:\n\nendOfNum:\n\n; Because the conversion was successful, this procedure\n; leaves RDI pointing at the first character beyond the\n; converted digits. As such, we don't restore RDI from\n; the stack. Just bump the stack pointer up by 8 bytes\n; to throw away RDI's saved value.\n\n            add     rsp, 8   ; Remove original RDI value\n            pop     rcx      ; Restore RCX\n            pop     rbx      ; Restore RBX\n            clc              ; Return success in carry flag\n            ret\n\n; badNumber - Drop down here if the first character in\n;             the string was not a valid digit.\n\nbadNumber:  xor     rax, rax\n            jmp     errorExit\n\noverflow:   or      rax, -1  ; Return -1 as error on overflow\nerrorExit:  pop     rdi      ; Restore RDI if an error occurs\n            pop     rcx\n            pop     rbx\n            stc              ; Return error in carry flag\n            ret\n\nstrtoh128   endp\n```", "```\n; Listing 9-17\n\n; 64-bit unsigned decimal string-to-numeric conversion.\n\n        option  casemap:none\n\nfalse       =       0\ntrue        =       1\ntab         =       9\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 9-17\", 0\nfmtStr1     byte    \"strtou: String='%s' value=%I64u\", nl, 0\nfmtStr2     byte    \"strtou: error, rax=%d\", nl, 0\n\nqStr      byte    \"12345678901234567\", 0\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n ret\ngetTitle    endp\n\n; strtou -   Converts string data to a 64-bit unsigned integer.\n\n; Input:\n;   RDI  -   Pointer to buffer containing string to convert.\n\n; Output:\n;   RAX  -   Contains converted string (if success), error code\n;            if an error occurs.\n\n;   RDI  -   Points at first char beyond end of numeric string.\n;            If error, RDI's value is restored to original value.\n;            Caller can check character at [RDI] after a\n;            successful result to see if the character following\n;            the numeric digits is a legal numeric delimiter.\n\n;   C    -   (carry flag) Set if error occurs, clear if\n;            conversion was successful. On error, RAX will\n;            contain 0 (illegal initial character) or\n;            0FFFFFFFFFFFFFFFFh (overflow).\n\nstrtou      proc\n            push    rcx      ; Holds input char\n            push    rdx      ; Save, used for multiplication\n            push    rdi      ; In case we have to restore RDI\n\n            xor     rax, rax ; Zero out accumulator\n\n; The following loop skips over any whitespace (spaces and\n; tabs) that appears at the beginning of the string.\n\n            dec     rdi      ; Because of inc below\nskipWS:     inc     rdi\n            mov     cl, [rdi]\n            cmp     cl, ' '\n            je      skipWS\n            cmp     al, tab\n            je      skipWS\n\n; If we don't have a numeric digit at this point,\n; return an error.\n\n            cmp     cl, '0'  ; Note: \"0\" < \"1\" < ... < \"9\"\n            jb      badNumber\n            cmp     cl, '9'\n            ja      badNumber\n\n; Okay, the first digit is good. Convert the string\n; of digits to numeric form:\n\nconvert:    and     ecx, 0fh ; Convert to numeric in RCX\n\n; Multiple 64-bit accumulator by 10:\n\n            mul     ten\n            test    rdx, rdx ; Test for overflow\n            jnz     overflow\n\n            add     rax, rcx\n            jc      overflow\n\n; Move on to next character:\n\n            inc     rdi\n            mov     cl, [rdi]\n            cmp     cl, '0'\n            jb      endOfNum\n            cmp     cl, '9'\n            jbe     convert\n\n; If we get to this point, we've successfully converted\n; the string to numeric form:\n\nendOfNum:\n\n; Because the conversion was successful, this procedure\n; leaves RDI pointing at the first character beyond the\n; converted digits. As such, we don't restore RDI from\n; the stack. Just bump the stack pointer up by 8 bytes\n; to throw away RDI's saved value.\n\n            add     rsp, 8   ; Remove original RDI value\n            pop     rdx\n            pop     rcx      ; Restore RCX\n            clc              ; Return success in carry flag\n            ret\n\n; badNumber - Drop down here if the first character in\n;             the string was not a valid digit.\n\nbadNumber:  xor     rax, rax\n            jmp     errorExit\n\noverflow:   mov     rax, -1  ; 0FFFFFFFFFFFFFFFFh\nerrorExit:  pop     rdi\n            pop     rdx\n            pop     rcx\n            stc              ; Return error in carry flag\n            ret\n\nten         qword   10\n\nstrtou      endp\n\n; Here is the \"asmMain\" function.\n\n public  asmMain\nasmMain     proc\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 64  ; Shadow storage\n\n; Test hexadecimal conversion:\n\n            lea     rdi, qStr\n            call    strtou\n            jc      error\n\n            lea     rcx, fmtStr1\n            mov     r8, rax\n            lea     rdx, qStr\n            call    printf\n            jmp     allDone\n\nerror:      lea     rcx, fmtStr2\n            mov     rdx, rax\n            call    printf\n\nallDone:    leave\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing9-17**\n\nC:\\>**echo off**\n Assembling: listing9-17.asm\nc.cpp\n\nC:\\>**listing9-17**\nCalling Listing 9-17:\nstrtou: String='12345678901234567' value=12345678901234567\nListing 9-17 terminated\n```", "```\n; strtou128 - Converts string data to a 128-bit unsigned integer.\n\n; Input:\n;   RDI     - Pointer to buffer containing string to convert.\n\n; Output:\n;   RDX:RAX - Contains converted string (if success), error code\n;             if an error occurs.\n\n;   RDI     - Points at first char beyond end of numeric string.\n;             If error, RDI's value is restored to original value.\n;             Caller can check character at [RDI] after a\n;             successful result to see if the character following\n;             the numeric digits is a legal numeric delimiter.\n\n;   C       - (carry flag) Set if error occurs, clear if\n;             conversion was successful. On error, RAX will\n;             contain 0 (illegal initial character) or\n;             0FFFFFFFFFFFFFFFFh (overflow).\n\nstrtou128   proc\naccumulator equ     <[rbp - 16]>\npartial     equ     <[rbp - 24]>\n            push    rcx      ; Holds input char\n            push    rdi      ; In case we have to restore RDI\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 24  ; Accumulate result here\n\n            xor     edx, edx ; Zero-extends!\n            mov     accumulator, rdx\n            mov     accumulator[8], rdx\n\n; The following loop skips over any whitespace (spaces and\n; tabs) that appears at the beginning of the string.\n\n            dec     rdi      ; Because of inc below\nskipWS:     inc     rdi\n            mov     cl, [rdi]\n cmp     cl, ' '\n            je      skipWS\n            cmp     al, tab\n            je      skipWS\n\n; If we don't have a numeric digit at this point,\n; return an error.\n\n            cmp     cl, '0'         ; Note: \"0\" < \"1\" < ... < \"9\"\n            jb      badNumber\n            cmp     cl, '9'\n            ja      badNumber\n\n; Okay, the first digit is good. Convert the string\n; of digits to numeric form:\n\nconvert:    and     ecx, 0fh        ; Convert to numeric in RCX\n\n; Multiply 128-bit accumulator by 10:\n\n            mov     rax, accumulator \n            mul     ten\n            mov     accumulator, rax\n            mov     partial, rdx    ; Save partial product\n            mov     rax, accumulator[8]\n            mul     ten\n            jc      overflow1\n            add     rax, partial\n            mov     accumulator[8], rax\n            jc      overflow1\n\n; Add in the current character to the 128-bit accumulator:\n\n            mov     rax, accumulator\n            add     rax, rcx\n            mov     accumulator, rax\n            mov     rax, accumulator[8]\n            adc     rax, 0\n            mov     accumulator[8], rax\n            jc      overflow2\n\n; Move on to next character:\n\n            inc     rdi\n            mov     cl, [rdi]\n            cmp     cl, '0'\n            jb      endOfNum\n            cmp     cl, '9'\n            jbe     convert\n\n; If we get to this point, we've successfully converted\n; the string to numeric form:\n\nendOfNum:\n\n; Because the conversion was successful, this procedure\n; leaves RDI pointing at the first character beyond the\n; converted digits. As such, we don't restore RDI from\n; the stack. Just bump the stack pointer up by 8 bytes\n; to throw away RDI's saved value.\n\n            mov     rax, accumulator\n            mov     rdx, accumulator[8]\n            leave\n            add     rsp, 8   ; Remove original RDI value\n            pop     rcx      ; Restore RCX\n            clc              ; Return success in carry flag\n            ret\n\n; badNumber - Drop down here if the first character in\n;             the string was not a valid digit.\n\nbadNumber:  xor     rax, rax\n            xor     rdx, rdx\n            jmp     errorExit\n\noverflow1:  mov     rax, -1\n            cqo              ; RDX = -1, too\n            jmp     errorExit\n\noverflow2:  mov     rax, -2  ; 0FFFFFFFFFFFFFFFEh\n            cqo              ; Just to be consistent\nerrorExit:  leave            ; Remove accumulator from stack\n            pop     rdi\n            pop     rcx\n            stc              ; Return error in carry flag\n            ret\n\nten         qword   10\n\nstrtou128   endp\n```", "```\n; Listing 9-19\n\n; Real string-to-floating-point conversion.\n\n        option  casemap:none\n\nfalse       =       0\ntrue        =       1\ntab         =       9\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 9-19\", 0\nfmtStr1     byte    \"strToR10: str='%s', value=%e\", nl, 0\n\nfStr1a      byte    \"1.234e56\",0\nfStr1b      byte    \"-1.234e56\",0\nfStr1c      byte    \"1.234e-56\",0\nfStr1d      byte    \"-1.234e-56\",0\nfStr2a      byte    \"1.23\",0\nfStr2b      byte    \"-1.23\",0\nfStr3a      byte    \"1\",0\nfStr3b      byte    \"-1\",0\nfStr4a      byte    \"0.1\",0\nfStr4b      byte    \"-0.1\",0\nfStr4c      byte    \"0000000.1\",0\nfStr4d      byte    \"-0000000.1\",0\nfStr4e      byte    \"0.1000000\",0\nfStr4f      byte    \"-0.1000000\",0\nfStr4g      byte    \"0.0000001\",0\nfStr4h      byte    \"-0.0000001\",0\nfStr4i      byte    \".1\",0\nfStr4j      byte    \"-.1\",0\n\nvalues      qword   fStr1a, fStr1b, fStr1c, fStr1d,\n                    fStr2a, fStr2b,\n                    fStr3a, fStr3b,\n                    fStr4a, fStr4b, fStr4c, fStr4d,\n                    fStr4e, fStr4f, fStr4g, fStr4h,\n                    fStr4i, fStr4j,\n                    0\n\n            align   4\nPotTbl      real10  1.0e+4096,\n                    1.0e+2048,\n 1.0e+1024,\n                    1.0e+512,\n                    1.0e+256,\n                    1.0e+128,\n                    1.0e+64,\n                    1.0e+32,\n                    1.0e+16,\n                    1.0e+8,\n                    1.0e+4,\n                    1.0e+2,\n                    1.0e+1,\n                    1.0e+0\n\n            .data\nr8Val       real8   ?\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n*********************************************************\n\n; strToR10 - RSI points at a string of characters that represent a\n;            floating-point value. This routine converts that string\n;            to the corresponding FP value and leaves the result on\n;            the top of the FPU stack. On return, ESI points at the\n;            first character this routine couldn't convert.\n\n; Like the other ATOx routines, this routine raises an\n; exception if there is a conversion error or if ESI\n; contains NULL.\n\n*********************************************************\n\nstrToR10    proc\n\nsign        equ     <cl>\nexpSign     equ     <ch>\n\nDigitStr    equ     <[rbp - 20]>\nBCDValue    equ     <[rbp - 30]>\nrsiSave     equ     <[rbp - 40]>\n\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 40\n\n            push    rbx\n push    rcx\n            push    rdx\n            push    r8\n            push    rax\n\n; Verify that RSI is not NULL.\n\n            test    rsi, rsi\n            jz      refNULL\n\n; Zero out the DigitStr and BCDValue arrays.\n\n            xor     rax, rax\n            mov     qword ptr DigitStr, rax\n            mov     qword ptr DigitStr[8], rax\n            mov     dword ptr DigitStr[16], eax\n\n            mov     qword ptr BCDValue, rax\n            mov     word ptr BCDValue[8], ax\n\n; Skip over any leading space or tab characters in the sequence.\n\n            dec     rsi\nwhileDelimLoop:\n            inc     rsi\n            mov     al, [rsi]\n            cmp     al, ' '\n            je      whileDelimLoop\n            cmp     al, tab\n            je      whileDelimLoop\n\n; Check for \"+\" or \"-\".\n\n            cmp     al, '-'\n            sete    sign\n            je      doNextChar\n            cmp     al, '+'\n            jne     notPlus\ndoNextChar: inc     rsi             ; Skip the \"+\" or \"-\"\n            mov     al, [rsi]\n\nnotPlus:\n\n; Initialize EDX with -18 since we have to account\n; for BCD conversion (which generates a number * 10^18 by\n; default). EDX holds the value's decimal exponent.\n\n            mov     rdx, -18\n\n; Initialize EBX with 18, which is the number of significant\n; digits left to process and it is also the index into the\n; DigitStr array.\n\n mov     ebx, 18         ; Zero-extends!\n\n; At this point, we're beyond any leading sign character.\n; Therefore, the next character must be a decimal digit\n; or a decimal point.\n\n            mov     rsiSave, rsi    ; Save to look ahead 1 digit\n            cmp     al, '.'\n            jne     notPeriod\n\n; If the first character is a decimal point, then the\n; second character needs to be a decimal digit.\n\n            inc     rsi\n            mov     al, [rsi]\n\nnotPeriod:\n            cmp     al, '0'\n            jb      convError\n            cmp     al, '9'\n            ja      convError\n            mov     rsi, rsiSave    ; Go back to orig char\n            mov     al, [rsi]\n            jmp     testWhlAL0\n\n; Eliminate any leading zeros (they do not affect the value or\n; the number of significant digits).\n\nwhileAL0:   inc     rsi\n            mov     al, [rsi]\ntestWhlAL0: cmp     al, '0'\n            je      whileAL0\n\n; If we're looking at a decimal point, we need to get rid of the\n; zeros immediately after the decimal point since they don't\n; count as significant digits.  Unlike zeros before the decimal\n; point, however, these zeros do affect the number's value as\n; we must decrement the current exponent for each such zero.\n\n            cmp     al, '.'\n            jne     testDigit\n\n            inc     edx             ; Counteract dec below\nrepeatUntilALnot0:\n            dec     edx\n            inc     rsi\n            mov     al, [rsi]\n            cmp     al, '0'\n            je      repeatUntilALnot0\n            jmp     testDigit2\n\n; If we didn't encounter a decimal point after removing leading\n; zeros, then we've got a sequence of digits before a decimal\n; point.  Process those digits here.\n\n; Each digit to the left of the decimal point increases\n; the number by an additional power of 10\\.  Deal with\n; that here.\n\nwhileADigit:\n            inc     edx     \n\n; Save all the significant digits, but ignore any digits\n; beyond the 18th digit.\n\n            test    ebx, ebx\n            jz      Beyond18\n\n            mov     DigitStr[rbx * 1], al\n            dec     ebx\n\nBeyond18:   inc     rsi\n            mov     al, [rsi]\n\ntestDigit:  \n            sub     al, '0'\n            cmp     al, 10\n            jb      whileADigit\n\n            cmp     al, '.'-'0'\n            jne     testDigit2\n\n            inc     rsi             ; Skip over decimal point\n            mov     al, [rsi]\n            jmp     testDigit2\n\n; Okay, process any digits to the right of the decimal point.\n\nwhileDigit2:\n            test    ebx, ebx\n            jz      Beyond18_2\n\n            mov     DigitStr[rbx * 1], al\n            dec     ebx\n\nBeyond18_2: inc     rsi\n            mov     al, [rsi]\n\ntestDigit2: sub     al, '0'\n            cmp     al, 10\n            jb      whileDigit2\n\n; At this point, we've finished processing the mantissa.\n; Now see if there is an exponent we need to deal with.\n\n            mov     al, [rsi]       \n            cmp     al, 'E'\n            je      hasExponent\n            cmp     al, 'e'\n            jne     noExponent\n\nhasExponent:\n            inc     rsi\n            mov     al, [rsi]       ; Skip the \"E\".\n            cmp     al, '-'\n            sete    expSign\n            je      doNextChar_2\n            cmp     al, '+'\n            jne     getExponent;\n\ndoNextChar_2:\n            inc     rsi             ; Skip \"+\" or \"-\"\n            mov     al, [rsi]\n\n; Okay, we're past the \"E\" and the optional sign at this\n; point.  We must have at least one decimal digit.\n\ngetExponent:\n            sub     al, '0'\n            cmp     al, 10\n            jae     convError\n\n            xor     ebx, ebx        ; Compute exponent value in EBX\nExpLoop:    movzx   eax, byte ptr [rsi] ; Zero-extends to RAX!\n            sub     al, '0'\n            cmp     al, 10\n            jae     ExpDone\n\n            imul    ebx, 10\n            add     ebx, eax\n            inc     rsi\n            jmp     ExpLoop\n\n; If the exponent was negative, negate our computed result.\n\nExpDone:\n            cmp     expSign, false\n            je      noNegExp\n\n            neg     ebx\n\nnoNegExp:\n\n; Add in the BCD adjustment (remember, values in DigitStr, when\n; loaded into the FPU, are multiplied by 10^18 by default.\n; The value in EDX adjusts for this).\n\n            add     edx, ebx\n\nnoExponent:\n\n; Verify that the exponent is between -4930 and +4930 (which\n; is the maximum dynamic range for an 80-bit FP value).\n\n            cmp     edx, 4930\n            jg      voor            ; Value out of range\n cmp     edx, -4930\n            jl      voor\n\n; Now convert the DigitStr variable (unpacked BCD) to a packed\n; BCD value.\n\n            mov     r8, 8\nfor9:       mov     al, DigitStr[r8 * 2 + 2]\n            shl     al, 4\n            or      al, DigitStr[r8 * 2 + 1]\n            mov     BCDValue[r8 * 1], al\n\n            dec     r8\n            jns     for9\n\n            fbld    tbyte ptr BCDValue\n\n; Okay, we've got the mantissa into the FPU.  Now multiply the\n; mantissa by 10 raised to the value of the computed exponent\n; (currently in EDX).\n\n; This code uses power of 10 tables to help make the \n; computation a little more accurate.\n\n; We want to determine which power of 10 is just less than the\n; value of our exponent.  The powers of 10 we are checking are\n; 10**4096, 10**2048, 10**1024, 10**512, and so on. A slick way to\n; do this check is by shifting the bits in the exponent\n; to the left.  Bit #12 is the 4096 bit.  So if this bit is set,\n; our exponent is >= 10**4096\\.  If not, check the next bit down\n; to see if our exponent >= 10**2048, etc.\n\n            mov     ebx, -10 ; Initial index into power of 10 table\n            test    edx, edx\n            jns     positiveExponent\n\n; Handle negative exponents here.\n\n            neg     edx\n            shl     edx, 19 ; Bits 0 to 12 -> 19 to 31\n            lea     r8, PotTbl\n\nwhileEDXne0:\n            add     ebx, 10\n            shl     edx, 1\n            jnc     testEDX0\n\n            fld     real10 ptr [r8][rbx * 1]\n            fdivp\n\ntestEDX0:   test    edx, edx\n            jnz     whileEDXne0\n            jmp     doMantissaSign\n\n; Handle positive exponents here.\n\npositiveExponent:\n            lea     r8, PotTbl\n            shl     edx, 19 ; Bits 0 to 12 -> 19 to 31\n            jmp     testEDX0_2\n\nwhileEDXne0_2:\n            add     ebx, 10\n            shl     edx, 1\n            jnc     testEDX0_2\n\n            fld     real10 ptr [r8][rbx * 1]\n            fmulp\n\ntestEDX0_2: test    edx, edx\n            jnz     whileEDXne0_2\n\n; If the mantissa was negative, negate the result down here.\n\ndoMantissaSign:\n            cmp     sign, false\n            je      mantNotNegative\n\n            fchs\n\nmantNotNegative:\n            clc                     ; Indicate success\n            jmp     Exit\n\nrefNULL:    mov     rax, -3\n            jmp     ErrorExit\n\nconvError:  mov     rax, -2\n            jmp     ErrorExit\n\nvoor:       mov     rax, -1         ; Value out of range\n            jmp     ErrorExit\n\nillChar:    mov     rax, -4\n\nErrorExit:  stc                     ; Indicate failure\n            mov     [rsp], rax      ; Save error code\nExit:       pop     rax\n            pop     r8\n            pop     rdx\n            pop     rcx\n            pop     rbx\n            leave\n            ret\n\nstrToR10    endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rsi\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 64         ; Shadow storage\n\n; Test floating-point conversion:\n\n            lea     rbx, values\nValuesLp:   cmp     qword ptr [rbx], 0\n            je      allDone\n\n            mov     rsi, [rbx]\n            call    strToR10\n            fstp    r8Val\n\n            lea     rcx, fmtStr1\n            mov     rdx, [rbx]\n            mov     r8, qword ptr r8Val\n            call    printf\n            add     rbx, 8\n            jmp     ValuesLp\n\nallDone:    leave\n            pop     rsi\n            pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing9-19**\n\nC:\\>**echo off**\n Assembling: listing9-19.asm\nc.cpp\n\nC:\\>**listing9-19**\nCalling Listing 9-19:\nstrToR10: str='1.234e56', value=1.234000e+56\nstrToR10: str='-1.234e56', value=-1.234000e+56\nstrToR10: str='1.234e-56', value=1.234000e-56\nstrToR10: str='-1.234e-56', value=-1.234000e-56\nstrToR10: str='1.23', value=1.230000e+00\nstrToR10: str='-1.23', value=-1.230000e+00\nstrToR10: str='1', value=1.000000e+00\nstrToR10: str='-1', value=-1.000000e+00\nstrToR10: str='0.1', value=1.000000e-01\nstrToR10: str='-0.1', value=-1.000000e-01\nstrToR10: str='0000000.1', value=1.000000e-01\nstrToR10: str='-0000000.1', value=-1.000000e-01\nstrToR10: str='0.1000000', value=1.000000e-01\nstrToR10: str='-0.1000000', value=-1.000000e-01\nstrToR10: str='0.0000001', value=1.000000e-07\nstrToR10: str='-0.0000001', value=-1.000000e-07\nstrToR10: str='.1', value=1.000000e-01\nstrToR10: str='-.1', value=-1.000000e-01\nListing 9-19 terminated\n```"]