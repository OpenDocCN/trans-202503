<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="backmatter" aria-labelledby="appendix_A">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_345" aria-label="345"/>&#13;
<hgroup>&#13;
<h1 class="TITLE" id="appendix_A">&#13;
<span class="APN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">A</samp></span>&#13;
<span class="APH"><samp class="SANS_Dogma_OT_Bold_B_11">CONSTRUCTING GRAPHS</samp></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">This book has covered a range of algorithms that operate over graphs. To apply these algorithms to real-world problems, we need a mechanism for programmatically creating new graphs or loading them from files.</p>&#13;
<p class="TX">While the graph creation functions in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> such as <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> provide a full mechanism for defining graphs, it would be unrealistic to hard-code the creation of each graph. Beyond the tedium of listing out hundreds or thousands of <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> statements, such an approach is error-prone.</p>&#13;
<p class="TX">In this appendix we introduce a variety of simple mechanisms for creating graphs and loading them from files. As with previous chapters, we optimize for understandability instead of storage size or computational efficiency. This means that some of the input formats we use, such as comma-separated values, will be simplistic. However, these formats are perfect for demonstrating what information we need to consider and how we can programmatically manipulate it to form a graph. Readers can build off of these approaches to construct formats optimized for their own applications.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_346" aria-label="346"/>This appendix makes use of Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp> library to facilitate loading and parsing files. We encourage readers to explore the vast ecosystem of more specialized libraries that might further simplify their code.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h2 class="H1" id="sec1"><span id="h-264"/><samp class="SANS_Futura_Std_Bold_B_11">Constructing Graphs from Edges</samp></h2>&#13;
<p class="TNI1">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structure we’ve used since <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> relies upon a constructor that creates an initial graph with no edges. The user can add edges to the graph using the <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> function. In this section, we’ll automate this flow to build graphs from lists of edges.</p>&#13;
<p class="TX">After creating a new graph from a given list of edges, we extend this functionality to read from and write to edge files. Along the way, we tackle the problem of nodes being specified by a generic text label rather than a node index.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H2" id="sec2"><span id="h-265"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inserting Edges from a List</samp></h3>&#13;
<p class="TNI1">We can create a graph from a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> data structures:</p>&#13;
<pre><code>def make_graph_from_edges(num_nodes: int,&#13;
                          undirected: bool,&#13;
                          edge_list: list) -&gt; Graph: &#13;
    g: Graph = Graph(num_nodes, undirected)&#13;
    for edge in edge_list:&#13;
        g.insert_edge(edge.from_node, edge.to_node, edge.weight)&#13;
    return g&#13;
</code></pre>&#13;
<p class="TX">In addition to the edge list, the code takes in the number of nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp>) and whether the graph is undirected (<samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp>). It creates an initial graph structure with the correct number of nodes and undirected setting, then loops over each edge and inserts it into the graph. If the edges are undirected, the <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> function in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class inserts a directed edge in each direction.</p>&#13;
<p class="TX">In many cases, we could compute the number of nodes directly from the edge list by tracking the largest node index seen. However, this approach does not allow for graphs with fully disconnected nodes, because their index would never appear in the edge list and the resulting graph might miss later nodes. Instead, the code takes <samp class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp> as an input parameter.</p>&#13;
<p class="TX"><a href="#figA-1">Figure A-1</a> shows an example graph construction where the following directed edges are inserted:</p>&#13;
<p class="EQ"><samp class="SANS_TheSansMonoCd_W5Regular_11">[Edge(0,1,1.0), Edge(1,3,10.0), Edge(2,4,5.0), Edge(3,1,2.0), Edge(1,2,3.0)]</samp></p>&#13;
<p class="BodyContinued"><a href="#figA-1">Figure A-1(a)</a> shows the graph after the first node is inserted. Each subfigure shows the state of the graph after one iteration of the code’s <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_347" aria-label="347"/>&#13;
<figure class="IMG"><img id="figA-1" class="img100" src="../images/f0a001.jpg" alt="Six subfigures show a five-node graph with an increasing number of edges. In (A), there are no edges. In (B), the edge (0, 1) has been added." width="1290" height="1309"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-1: The steps of adding edges to a graph with five nodes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_graph_from_edges()</samp> function in conjunction with algorithms that return lists of edges, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">randomized_kruskals()</samp> algorithm in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H2" id="sec3"><span id="h-266"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loading Edge Lists from Files</samp></h3>&#13;
<p class="TNI1">A natural approach to constructing graphs is to load the graph directly from a file. While there are myriad different formats we could use to store a graph’s representation, we’ll start with one of the simplest approaches: storing a graph as a file of comma-separated values (CSV). Each row indicates a single edge listing the originating node as a string label, the destination node as a string label, and an optional floating-point weight. Unconnected nodes are listed alone.</p>&#13;
<p class="TX">Using this CSV format, we can encode the undirected graph shown in <a href="#figA-2">Figure A-2</a> with the following data:</p>&#13;
<p class="ListPlain">a,b</p>&#13;
<p class="ListPlain">b,c,10.0</p>&#13;
<p class="ListPlain">d,e,5.0</p>&#13;
<p class="BodyContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_348" aria-label="348"/>The data define a graph with five nodes a, b, c, d, and e, and three edges. Two of the edges are given explicit weights and the third uses a default value of 1.0.</p>&#13;
<figure class="IMG"><img id="figA-2" class="img40" src="../images/f0a002.jpg" alt="A graph with five nodes and undirected edges (a, b), (b, c), and (d, e)." width="448" height="271"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-2: A graph with five nodes and three weighted edges</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can extend this format to account for fully disconnected nodes, which will not appear in any edge, by allowing rows with a single entry. This single entry simply indicates the node exists so that the program includes it in the graph.</p>&#13;
<p class="TX">We can use this general format to encode a vast number of real-world phenomena. For example, we could use a single file to represent note-passing behavior in a classroom. Each node represents a student. Each row provides new information about the class (graph). A row can contain a single name to indicate the existence of a student (node). Alternatively, a row can indicate the directed note-passing behavior between a pair of students and includes <samp class="SANS_TheSansMonoCd_W5Regular_11">person1</samp><i>,</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">person2</samp><i>,</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">weight</samp> to indicate how many times (represented by weight) person 1 passed a note to person 2.</p>&#13;
<p class="TX">The code to read such a CSV file makes use of Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">open()</samp> function to read the file and the csv package (which requires importing <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>) to parse each row, as shown in Listing A-1.</p>&#13;
<pre><code>def make_graph_from_weighted_csv(filename: str, undirected: bool) -&gt; Graph: &#13;
    g: Graph = Graph(0, undirected)&#13;
    node_indices: dict = {}&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> with open(filename) as f:&#13;
        graph_reader = csv.reader(f, delimiter=',')&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> for row in graph_reader:&#13;
            name1: str = row[0]&#13;
            if name1 not in node_indices:&#13;
                new_node: Node = g.insert_node(label=name1)&#13;
                node_indices[name1] = new_node.index&#13;
            index1: int = node_indices[name1]&#13;
&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if len(row) &gt; 1:&#13;
                name2: str = row[1]&#13;
                if name2 not in node_indices:&#13;
                    new_node = g.insert_node(label=name2)&#13;
                    node_indices[name2] = new_node.index&#13;
                index2: int = node_indices[name2]<span role="doc-pagebreak" epub:type="pagebreak" id="pg_349" aria-label="349"/>&#13;
&#13;
              <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> if len(row) &gt; 2:&#13;
                    weight: float = float(row[2])&#13;
                else:&#13;
                    weight = 1.0&#13;
&#13;
                g.insert_edge(index1, index2, weight)&#13;
    return g&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-1: Loading a graph from a CSV file</samp></p>&#13;
<p class="TX">The code starts by creating the necessary data structures—an empty graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>) and an empty dictionary (<samp class="SANS_TheSansMonoCd_W5Regular_11">node_indices</samp>) that will map the string names to the corresponding node index.</p>&#13;
<p class="TX">The code then opens the file and parses it using <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.reader</samp> <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. It iterates through every row in the file, reading up to three entries <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. For each row, it extracts the name of the node from the first entry. Since the code reads in names, it needs to map those names to a corresponding index. If the node is in the graph already, the code can look it up from the <samp class="SANS_TheSansMonoCd_W5Regular_11">node_indices</samp> dictionary. Otherwise, it has found a node that is not yet in the graph and must insert this node into the graph and the name into the dictionary. If the row has only a single entry, the function skips the rest of the logic and continues to the next row.</p>&#13;
<p class="TX">If the row has a second entry, however, that row specifies an edge <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. The code extracts the second node’s name. Again, it checks whether the node is in the graph and, if not, inserts it. The code checks for a third entry in the row, indicating a weight <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. If no weight is provided, the code uses a default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>. Finally, the code uses the combination of the two node indices and the weight to insert a new edge into the graph.</p>&#13;
<p class="TX">The code continues row by row in the CSV until it has read the entire file. At that point it returns the final graph. The file is closed automatically as the code exits the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> statement.</p>&#13;
<p class="TX">One of the major complexities in this code is mapping the nodes’ text strings to their indices. In theory, we could restrict our loader function to require that files supply each node’s integer index. While this would remove the need for a mapping, it greatly reduces the usability. Anytime we want to load in a new graph, we must first construct a mapping from name to index and convert the file. In a later section, we will look at how to incorporate this common operation into the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structure itself.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H2" id="sec4"><span id="h-267"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Saving Edge Lists to Files</samp></h3>&#13;
<p class="TNI1">We can use the same comma-separated values format to save our favorite graphs. Since most of the graphs we have considered have not used named nodes, we will use each node’s integer index as its name in our CSV file. However, we still face the problem that the code in Listing A-1 assigns node indices as they are encountered. Ideally, we would like node 5 to stay node 5 when reloaded, regardless of the order in which the code encounters it in the edge list.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_350" aria-label="350"/>There are a couple potential solutions to this problem. We could forgo names altogether and just store the integer node indices in the CSV, modifying Listing A-1 to read the node names directly as integer indices. Alternatively, we can output one node name per row in order at the start of the CSV file to indicate their existence. This will ensure that the first node is mapped to index 0, the second to index 1, and so on.</p>&#13;
<p class="TX">For the following code, we use this second approach to stay consistent with Listing A-1. This code will work for an integer-based reader as well:</p>&#13;
<pre><code>def save_graph_to_csv(g: Graph, filename: str): &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> with open(filename, 'w', newline="\n") as f:&#13;
        graph_writer = csv.writer(f, delimiter=',')&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> for node in g.nodes:&#13;
            graph_writer.writerow([node.index])&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> for node in g.nodes:&#13;
            for edge in node.get_edge_list():&#13;
                graph_writer.writerow([edge.from_node, edge.to_node,&#13;
                                       edge.weight])&#13;
</code></pre>&#13;
<p class="TX">The code opens the file and writes to it using <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.writer</samp> <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. It uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to iterate through each node, writing one node index per row <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. This ensures that all nodes are captured in the CSV even if they are not part of any edges. Finally, a pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops iterate through each edge in the graph and write out three values (origin node, destination node, and weight) representing the edge <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. The file closes automatically as the code exits the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> statement.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h2 class="H1" id="sec5"><span id="h-268"/><samp class="SANS_Futura_Std_Bold_B_11">Inserting Nodes by Name</samp></h2>&#13;
<p class="TNI1">A significant portion of the code in Listing A-1 consists of handling the mapping of a node’s name to its index. We look up each name string in the <samp class="SANS_TheSansMonoCd_W5Regular_11">node_indices</samp> dictionary to get the index. If the name is not in the dictionary, we need to insert a new node and create the corresponding dictionary entry mapping the name to the new index. Depending on how you reference nodes in your program, this can be a common problem.</p>&#13;
<p class="TX">To simplify working with named nodes, we can incorporate this logic into the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class itself. We need to make two changes. First, we add the creation of an empty dictionary to the initialization function:</p>&#13;
<pre><code>self.node_indices: dict = {} &#13;
</code></pre>&#13;
<p class="BodyContinued">We will use this dictionary whenever we need to map a name to an index.</p>&#13;
<p class="TX">Second, we add a function to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class that performs both the lookup and, if necessary, the insertion, as shown in Listing A-2.</p>&#13;
<pre><code>def get_index_by_name(self, name: str) -&gt; int: &#13;
    if name not in self.node_indices:&#13;
        new_node: Node = self.insert_node()<span role="doc-pagebreak" epub:type="pagebreak" id="pg_351" aria-label="351"/>&#13;
        self.node_indices[name] = new_node.index&#13;
    return self.node_indices[name]&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing A-2: Adding named nodes to a graph</samp></p>&#13;
<p class="TX">The code starts by determining if this node already exists in the graph by checking whether its name is in the mapping. If not, the graph inserts the node into the graph using the original <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp> function. It also inserts the name into the index map. The function finishes by returning the node’s index.</p>&#13;
<p class="TX">We can picture this function in the context of a lazy teacher creating a seating chart. On the first day, the teacher allows the students to pick their own seats but does not bother to write down who is sitting where. Their seating chart is initially empty. As the class progresses, students raise their hands with questions. Each time this happens, the teacher glances down at their seating chart. If the student’s name is listed, the teacher uses it. Otherwise, they peer at the student and, with a complete lack of tact, ask, “Who are you?” When the student finishes rolling their eyes and responding, the teacher adds the student to the seating chart. The chart progressively gets filled in as the students are acknowledged.</p>&#13;
<p class="TX">We can use these helper functions to rewrite the CSV reader code from Listing A-1 more compactly:</p>&#13;
<pre><code>def make_graph_from_weighted_csv2(filename: str, undirected: bool) -&gt; Graph: &#13;
    g: Graph = Graph(0, undirected)&#13;
&#13;
    with open(filename) as f:&#13;
        graph_reader = csv.reader(f, delimiter=',')&#13;
        for row in graph_reader:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> index1: int = g.get_index_by_name(row[0])&#13;
&#13;
            if len(row) &gt; 1:&#13;
              <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> index2: int = g.get_index_by_name(row[1])&#13;
&#13;
                if len(row) &gt; 2:&#13;
                    weight: float = float(row[2])&#13;
                else:&#13;
                    weight = 1.0&#13;
                g.insert_edge(index1, index2, weight)&#13;
    return g&#13;
</code></pre>&#13;
<p class="TX">The code follows the same flow as Listing A-1 but uses <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by _name()</samp> to do both the node mapping and lookup for the first <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> and second nodes <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> in each row.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h2 class="H1" id="sec6"><span id="h-269"/><samp class="SANS_Futura_Std_Bold_B_11">Co-occurrences</samp></h2>&#13;
<p class="TNI1"><i>Co-occurrence graphs</i> represent which pairs of entities have previously co-occurred. In biology, they can be used to study interactions, such as which genes are often present together or which microbes interact. In sociology, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_352" aria-label="352"/>they can model gatherings of groups or coauthorship of academic publications. And in pop culture, they can help answer critical questions about which movie stars appeared on-screen together, as discussed in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>.</p>&#13;
<p class="TX">The difficulty with ingesting co-occurrence data is that it usually consists of a list of sets instead of pairwise interactions. Our favorite online movie database probably does not list each pairing of movie stars from last summer’s smash hit. Instead, it provides a single list labeled <i>cast</i> that includes everyone who appeared in the movie.</p>&#13;
<p class="TX">For example, when reviewing all the local theater company’s recent productions, we might find the following cast lists:</p>&#13;
<p class="ListPlain">(<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>)</p>&#13;
<p class="ListPlain">(<samp class="SANS_TheSansMonoCd_W5Regular_11">D</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>)</p>&#13;
<p class="ListPlain">(<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">D</samp>)</p>&#13;
<p class="ListPlain">(<samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">F</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>)</p>&#13;
<p class="ListPlain">(<samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>)</p>&#13;
<p class="TX">Using a single cast list, we can easily see that <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> has appeared onstage with <samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>. However, if we are interested in more complex questions such as how many degrees of separation there are between <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>, we need to construct a more comprehensive picture. <a href="#figA-3">Figure A-3</a> shows the co-occurrence graph based on these plays.</p>&#13;
<figure class="IMG"><img id="figA-3" class="img30" src="../images/f0a003.jpg" alt="A graph with 8 nodes and 12 edges. Node A has edges to nodes B, C, and D." width="457" height="457"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-3: An undirected graph with eight nodes representing the co-occurrence of actors in plays</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To make the model more powerful, we can use edge weights to track how often two nodes have co-occurred. For example, Alice and Bob might have a stronger acting connection after appearing together in 10 different plays, while Diane’s weaker connection to Alice comes from sharing the stage a single time. If you are looking for an introduction to the world-famous Alice, it is better to use the stronger connection through Bob.</p>&#13;
<p class="TX">We can extend the approach used to load graphs from CSVs to construct pairwise graphs from arbitrary lists. Instead of expecting at most three entries per row, we allow all co-occurring entries to be listed on a single row. The code then determines the pairwise edges implied by each list:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_353" aria-label="353"/>def make_graph_from_multi_csv(filename: str) -&gt; Graph: &#13;
    g: Graph = Graph(0, undirected=True)&#13;
    with open(filename) as f:&#13;
        graph_reader = csv.reader(f, delimiter=',')&#13;
        for row in graph_reader:&#13;
            num_items: int = len(row)&#13;
&#13;
            for i in range(num_items):&#13;
                index1: int = g.get_index_by_name(row[i])&#13;
&#13;
                for j in range(i + 1, num_items):&#13;
                    index2: int = g.get_index_by_name(row[j])&#13;
                    edge: Union[Edge, None] = g.get_edge(index1, index2)&#13;
                  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if edge is not None:&#13;
                        weight = edge.weight + 1.0&#13;
                    else:&#13;
                        weight = 1.0&#13;
                  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> g.insert_edge(index1, index2, weight)&#13;
    return g&#13;
</code></pre>&#13;
<p class="TX">As with the earlier CSV reader, the code starts by creating an empty graph, opening the file, and parsing it with <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.reader</samp>. This time, the code restricts the graph to being undirected, as there is no implied directionality in these co-occurrence edges. The code also does not maintain a dictionary of names, but rather uses the helper function from Listing A-2 to insert new nodes and retrieve each node’s index.</p>&#13;
<p class="TX">The code iterates through each row using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. For each row, it uses another pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to iterate over all unique pairs of entities on each row. It looks up the nodes’ indices using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by_name()</samp> function, inserting new nodes as needed. Before creating an edge from the pair, the code checks whether the edge exists <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library to allow <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to be returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function. If the edge already exists, the code retrieves its current weight and increments it by 1, then inserts a new edge with the updated weight <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> overwrites the existing edges when a duplicate is inserted, the code effectively updates the weights of existing edges.</p>&#13;
<p class="TX">As with the previous CSV reader in Listing A-1, the code continues row by row until it has read the entire file. At that point it returns the final graph.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h2 class="H1" id="sec7"><span id="h-270"/><samp class="SANS_Futura_Std_Bold_B_11">Spatial Points</samp></h2>&#13;
<p class="TNI1">When using graphs to model path planning or other physical problems, we often need to construct a graph from a series of spatial data points. We can do this by creating a graph containing one node for each spatial point and one edge between <i>every pair</i> of points.</p>&#13;
<p class="TX"><a href="#figA-4">Figure A-4</a> shows an example of such a representation. <a href="#figA-4">Figure A-4(a)</a> shows five two-dimensional points: (0, 0), (1, 0), (1.2, 1), (1.8, 1), and (0.5, 1.5). <a href="#figA-4">Figure A-4(b)</a> shows the graph representation with the edge weights capturing the distance between points.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_354" aria-label="354"/>&#13;
<figure class="IMG"><img id="figA-4" class="img80" src="../images/f0a004.jpg" alt="(A) Shows Five Points Plotted on Cartesian X and Y Axes. (B) Shows the Points with the 10 Pairwise Edges, Each Labeled with the Pair’s Distance." width="1151" height="613"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-4: A set of two-dimensional spatial points (a) and the corresponding graph representation (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We start by defining a helper class to store the spatial points and compute the distance between them:</p>&#13;
<pre><code>class Point: &#13;
    def __init__(self, x: float, y: float):&#13;
        self.x: float = x&#13;
        self.y: float = y&#13;
&#13;
    def distance(self, b) -&gt; float:&#13;
        diff_x: float = (self.x - b.x)&#13;
        diff_y: float = (self.y - b.y)&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> dist: float = math.sqrt(diff_x*diff_x + diff_y*diff_y)&#13;
        return dist&#13;
</code></pre>&#13;
<p class="TX">While using a <samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp> class is not required, it allows us to easily swap in higher-dimensional points or alternative distance functions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function computes the Euclidean distance in two-dimensional space. Note that we will need to import <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp> to use the square root function.</p>&#13;
<p class="TX">We can substitute in alternative distance functions by modifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function. For example, we could use Manhattan distance by changing the line at <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> to the following:</p>&#13;
<pre><code>        dist: float = abs(diff_x) + abs(diff_y)&#13;
</code></pre>&#13;
<p class="TX">We can write the code for constructing the graph from spatial points using a nested pair of loops:</p>&#13;
<pre><code>def build_graph_from_points(points: list) -&gt; Graph:  &#13;
    num_pts: int = len(points)&#13;
    g: Graph = Graph(num_pts, undirected=True)&#13;
&#13;
    for i in range(num_pts):&#13;
        for j in range(i + 1, num_pts):<span role="doc-pagebreak" epub:type="pagebreak" id="pg_355" aria-label="355"/>&#13;
            dist: float = points[i].distance(points[j])&#13;
            g.insert_edge(i, j, dist)&#13;
    return g&#13;
</code></pre>&#13;
<p class="TX">The code allocates a graph with one node for each point in the dataset, then uses a pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to iterate through each pair of points. For each pair, the code computes the distance between the points using the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp> class and inserts an undirected edge with the corresponding weight into the graph. Once all edges are added, the function returns the completed graph.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h2 class="H1" id="sec8"><span id="h-271"/><samp class="SANS_Futura_Std_Bold_B_11">Preconditions</samp></h2>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> we considered the problem of topological sort—ordering nodes according to the graph’s directed edges. <a href="#figA-5">Figure A-5</a> shows an example of such an ordering, where each node is ordered along the horizontal direction.</p>&#13;
<figure class="IMG"><img id="figA-5" class="img60" src="../images/f0a005.jpg" alt="A graph with six nodes and directed edges (0, 1), (0, 2), (1, 2), (2, 5), (1, 4), (3, 4), and (4, 5)." width="860" height="385"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure A-5: Six nodes ordered by their relative dependencies</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Topological sort allows us to list steps for an instruction manual, plan for courses with prerequisites, or compute the order in which to compile parts of a program. Each of these problems required us to specify the dependencies between nodes.</p>&#13;
<p class="TX">We define a simple function to construct a graph from a dictionary of preconditions. Each entry in the dictionary maps a node to a list of its dependencies. For example, the graph in <a href="#figA-5">Figure A-5</a> would be represented as:</p>&#13;
<p class="EQ"><samp class="SANS_TheSansMonoCd_W5Regular_11">{0: [], 1: [0], 2: [0, 1], 3: [], 4: [1, 3],</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5: [2, 4]}</samp></p>&#13;
<p class="BodyContinued">Nodes without a dependency, such as nodes 0 and 3, are represented using an empty list.</p>&#13;
<p class="TX">The code for constructing a graph from dependencies consists of loops that iterate through each node, as well as each node’s dependencies:</p>&#13;
<pre><code>def make_graph_from_dependencies(dependencies: dict) -&gt; Graph: &#13;
    g: Graph = Graph(0, undirected=False)&#13;
    for node in dependencies:&#13;
        n_index: int = g.get_index_by_name(node)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_356" aria-label="356"/>&#13;
        for prior in dependencies[node]:&#13;
            p_index: int = g.get_index_by_name(prior)&#13;
            g.insert_edge(p_index, n_index, 1.0)&#13;
    return g&#13;
</code></pre>&#13;
<p class="TX">The code starts by allocating an empty directed graph. It fills the graph by iterating over each key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dependencies</samp> list with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. For each entry, even those with an empty list of priors, the code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by _name()</samp> to look up and potentially insert a new node. This code is sufficient to fill in the graph’s nodes.</p>&#13;
<p class="TX">To fill in the edges, the code uses a second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to iterate over each node’s dependency list. The dependency’s index is retrieved (and a new node may be inserted) using <samp class="SANS_TheSansMonoCd_W5Regular_11">get_index_by_name()</samp>. The code then inserts the edge <i>from</i> the dependency node <i>to</i> the current node. Since we are interested only in the ordering, the code uses a default <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> weight for all edges. The code concludes by returning the constructed graph.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>