- en: '**INTRODUCTION**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/pg23_Image_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This book introduces the concepts of how computer hardware works from a programmer’s
    point of view. The hardware is controlled by a set of *machine instructions*.
    The way these instructions control the hardware is called the *instruction set
    architecture (ISA)*. A programmer’s job is to design a sequence of these instructions
    that causes the hardware to perform operations to solve a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Nearly all computer programs are written in a high-level language. Some of these
    languages are general-purpose, and others are geared toward specific applications.
    But they are all intended to provide a programmer with a set of programming constructs
    more suitable for solving problems in human terms than working directly with the
    ISA and the details of the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '**Who This Book Is For**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have you ever wondered what’s going on “under the hood” when you write a program
    in a high-level language? You know that computers can be programmed to make decisions,
    but how do they do that? You probably know that data is stored in bits, but what
    does that mean when storing a decimal number? My goal in this book is to answer
    these and many other questions about how computers work. We’ll be looking at both
    the hardware components and the machine-level instructions used to control the
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll assume that you know the basics of how to program in a high-level language,
    but you don’t need to be an expert programmer. After discussing the hardware components,
    we’ll look at and write lots of programs in *assembly language*, the language
    that translates directly into machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing in assembly language is a tedious, error-prone, time-consuming process,
    so it should be avoided whenever possible. The best language for most programming
    projects on a Raspberry Pi is Python, which is included with Raspberry Pi OS and
    has excellent support for electronics projects. Python is very good at isolating
    us from the tedium of writing in assembly language. However, our goal here is
    to study programming concepts, not to create applications, so we’ll mainly be
    using C as our high-level language.
  prefs: []
  type: TYPE_NORMAL
- en: '**About This Book**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The guidelines I followed in creating this book are:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning is easier if it builds on concepts you already know.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world hardware and software make a more interesting platform for learning
    theoretical concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tools used for learning should be inexpensive and readily available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***The Programming in the Book***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This book is based on the AArch64 architecture, which is the 64-bit version
    of the ARM architecture. It supports both the 64-bit A64 and 32-bit A32 instruction
    sets.
  prefs: []
  type: TYPE_NORMAL
- en: All the programming in the book was done using the GNU programming environment
    running under the 64-bit Raspberry Pi OS. All the programs have been tested on
    both my Raspberry Pi 3 and my Raspberry Pi 5\. [Chapter 20](ch20.xhtml) includes
    a section on assembly language programming of the general-purpose input/output
    (GPIO) pins on the Raspberry Pi 5, which differs significantly from earlier Raspberry
    Pi models.
  prefs: []
  type: TYPE_NORMAL
- en: Because Python is so good at isolating us from the computer’s ISA, we’re using
    C as our high-level language, with some C++ in [Chapter 18](ch18.xhtml). The GNU
    programming tools make it easy for us to see how C and C++ use the ISA. Don’t
    worry if you don’t know C/C++; all our C/C++ programming will be very simple,
    and I’ll explain what you need to know as we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important issue arises when learning assembly language: using the keyboard
    and terminal screen in an application. Programming input from a keyboard and output
    to a screen is complex, well beyond the expertise of a beginner. The GNU programming
    environment includes the C standard library. In keeping with the “real-world”
    criterion of this book, we’ll use the functions in that library, which are easily
    called from assembly language, to use the keyboard and screen in our applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Why Read This Book?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given that there are many excellent high-level languages that allow you to write
    programs without being concerned with how machine instructions control the hardware,
    you may wonder why you should learn the material in this book. All high-level
    languages are ultimately translated into machine instructions that control the
    hardware. Understanding what the hardware does and how the instructions control
    it helps you understand the capabilities and limitations of the computer. I believe
    this understanding can make you a better programmer, even when you are working
    with a high-level language.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other reasons to learn assembly language, though. If your interests
    take you into *systems programming*—writing parts of an operating system, writing
    a compiler, or even designing another higher-level language—these endeavors typically
    require an understanding at the assembly language level. And if your primary interest
    is in the hardware, I think it’s important to understand how a program will use
    that hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also many challenging opportunities in programming *embedded systems*,
    or systems in which the computer has a dedicated task. These systems form integral
    parts of our daily lives: think cell phones, home appliances, automobiles, HVAC
    systems, medical devices, and more. Embedded systems are an essential component
    of Internet of Things (IoT) technologies. Programming them often requires an understanding
    of how the computer interacts with various hardware devices at the assembly language
    level.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you already know assembly language for another processor, this book
    will serve as a primer for reading the ARM manuals.
  prefs: []
  type: TYPE_NORMAL
- en: '***Chapter Organization***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The book is roughly organized into three parts, focusing on mathematics and
    logic, hardware, and software. The mathematics and logic part is intended to give
    you the necessary language to discuss the concepts. The hardware part is an introduction
    to the components used to construct a computer.
  prefs: []
  type: TYPE_NORMAL
- en: These first two parts provide the background for discussing how software controls
    the hardware. We’ll look at each of the basic programming constructs in the C
    programming language, with some C++ toward the end of the book. Then we’ll look
    at how the compiler translates the C/C++ code into assembly language. I’ll also
    show you how a programmer might program the same constructs directly in assembly
    language.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 1: Setting the Stage](ch01.xhtml)**   Describes the three fundamental
    subsystems of a computer and how they’re connected. This chapter also discusses
    setting up the programming tools used in the book.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 2: Data Storage Formats](ch02.xhtml)**   Shows how unsigned integers
    are stored using the binary and hexadecimal number systems and how characters
    are stored in ASCII code. In this chapter, we’ll write our first C program and
    use the `gdb` debugger to explore these concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3: Computer Arithmetic](ch03.xhtml)**   Describes the addition and
    subtraction of unsigned and signed integers and explains the limits of using a
    fixed number of bits to represent integers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4: Boolean Algebra](ch04.xhtml)**   Describes Boolean algebra operators
    and functions and discusses function minimization using algebraic tools and Karnaugh
    maps.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5: Logic Gates](ch05.xhtml)**   Begins with an introduction to electronics,
    then discusses logic gates and how they’re built using complementary metal-oxide
    semiconductor (CMOS) transistors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 6: Combinational Logic Circuits](ch06.xhtml)**   Discusses logic
    circuits that have no memory, including adders, decoders, multiplexers, and programmable
    logic devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 7: Sequential Logic Circuits](ch07.xhtml)**   Discusses clocked
    and unclocked logic circuits that maintain a memory, as well as circuit design
    using state transition tables and state diagrams.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8: Memory](ch08.xhtml)**   Describes the memory hierarchy (cloud,
    mass storage, main memory, cache, and CPU registers) and discusses memory hardware
    designs for registers, SRAM, and DRAM.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 9: Central Processing Unit](ch09.xhtml)**   Gives an overview of
    CPU subsystems. This chapter also explains the instruction execution cycle and
    the main A64 registers and shows how to view register contents in the `gdb` debugger.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 10: Programming in Assembly Language](ch10.xhtml)**   Looks at the
    minimal C function, both as compiler-generated assembly language and as written
    directly in assembly language. This chapter covers assembler directives and first
    instructions. I give an example of using the text user interface of `gdb` as a
    learning tool.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 11: Inside the](ch11.xhtml)**   main **Function**   Describes passing
    arguments in registers, position-independent code, and use of the call stack for
    passing the return address and automatic local variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 12: Instruction Details](ch12.xhtml)**   Looks at how instructions
    are coded at the bit level. This chapter also discusses how addresses needed by
    instructions are computed, as well as algorithms of assembler and linker programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 13: Control Flow Constructs](ch13.xhtml)**   Covers assembly language
    implementation of program flow control with `while`, `do-while`, `for`, `if-else`,
    and `switch` constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 14: Inside Subfunctions](ch14.xhtml)**   Describes how functions
    access external variables (global, pass by value, pass by pointer, and pass by
    reference) and summarizes the structure of the stack frame.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 15: Special Uses of Subfunctions](ch15.xhtml)**   Shows how recursion
    works. This chapter discusses using assembly language to access CPU hardware features
    that are not directly accessible in high-level languages, using a separate function
    or inline assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 16: Bitwise Logic, Multiplication, and Division Instructions](ch16.xhtml)**   Describes
    bit masking, shifting bits, and the multiplication and division instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 17: Data Structures](ch17.xhtml)**   Explains how arrays and records
    (`struct`s) are implemented and accessed in a program at the assembly language
    level.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 18: Object-Oriented Programming](ch18.xhtml)**   Shows how `struct`s
    are used as objects in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 19: Fractional Numbers](ch19.xhtml)**   Describes fixed-point and
    floating-point numbers, the IEEE 754 standard, and a few A64 floating-point instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 20: Input/Output](ch20.xhtml)**   Compares I/O with memory and bus
    timing, describes memory-mapped I/O, and shows how to program the GPIO on the
    Raspberry Pi, both in C and in assembly language. This chapter also gives a rough
    sketch of polled I/O programming and discusses interrupt-driven and direct memory
    access I/O.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 21: Exceptions and Interrupts](ch21.xhtml)**   Briefly describes
    how AArch64 handles exceptions and interrupts. The chapter includes an example
    of using the `svc` instruction to do system calls without using the C runtime
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficient Use of This Book**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve organized this book in such a way that you should be able to learn the
    material efficiently by following a few simple guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Many sections have “Your Turn” exercises at the end that give you the opportunity
    to practice working with the material presented in the main body of the section.
    These are intended as exercises, not tests. I have provided answers and my solutions
    to most of them online, at *[https://rgplantz.github.io](https://rgplantz.github.io)*.
    If you are an instructor using this book, sorry, you will have to make up your
    own exam questions! Many of the exercises have fairly obvious extensions that
    instructors can use to create class assignments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make efficient use of these exercises, I recommend an iterative process:'
  prefs: []
  type: TYPE_NORMAL
- en: Try to solve the problem on your own. Spend some time on it, but don’t let yourself
    get stuck for too long.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the answer doesn’t come to you, peek at my solution. In some cases, I give
    a hint before providing the full solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to step 1, armed with some knowledge of how an experienced assembly language
    programmer might approach the solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One thing I strongly urge you to do is type the code in yourself. This physical
    activity will help you to learn the material faster. If nothing else, it forces
    you to read every character in the code. There is no advantage to copying and
    pasting code from my online solutions; frankly, none of the programs in this book
    have any real-world usefulness. The code is provided for your own exercising,
    so please use it in that spirit.
  prefs: []
  type: TYPE_NORMAL
- en: This hands-on approach also applies to the mathematics in the first few chapters,
    which includes converting numbers between several number bases. Any good calculator
    will do that easily, but the actual conversion is not the point. The point is
    to learn how data values can be represented in bit patterns, and using paper and
    pencil to work through the arithmetic will help you get a feel for these patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start in [Chapter 1](ch01.xhtml) by taking a high-level overview of the
    major subsystems of a computer. Then I’ll describe how I set up the programming
    environment on my two Raspberry Pis, a 3 and a 5, to create and run the programs
    in this book.
  prefs: []
  type: TYPE_NORMAL
