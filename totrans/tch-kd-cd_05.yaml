- en: Chapter 5. Conditions (What If?)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 条件语句（如果？）
- en: 'In addition to speed and accuracy, one quality that makes computers powerful
    is their ability to evaluate information and make small decisions quickly: a thermostat
    checks the temperature continuously and turns on heating or cooling as soon as
    the temperature goes below or above a certain number; sensors on new cars react
    and apply brakes more quickly than we can when another car suddenly stops ahead;
    spam filters turn away dozens of emails to keep our inboxes clean.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了速度和准确性，计算机强大的另一个特点是它们能够快速评估信息并做出小的决策：温控器不断检查温度，并在温度高于或低于某个数值时迅速开启加热或制冷；新车上的传感器比我们反应更快，当前方有车突然停下时，它们会立即应用刹车；垃圾邮件过滤器会阻挡数十封电子邮件，以保持我们的收件箱清洁。
- en: 'In each of these cases, the computer checks a set of conditions: Is the temperature
    too cold? Is there something in the path of the car? Does the email look like
    spam?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，计算机会检查一组条件：温度是否太冷？车前面是否有障碍物？电子邮件看起来像是垃圾邮件吗？
- en: 'In [Chapter 4](ch04.html "Chapter 4. Loops Are Fun (You Can Say That Again)"),
    we saw a statement that uses a condition to make a decision: the `while` statement.
    In those examples, the condition told the `while` loop how many times to run.
    What if we wanted to make decisions about *whether* to run a set of statements
    at all? Imagine if we could write one program and let the user decide whether
    they wanted circles or other shapes on their spiral. Or what if we wanted circles
    *and* other shapes, like in [Figure 5-1](ch05.html#spiral_of_rosettes_and_smaller_spiralsco
    "Figure 5-1. A spiral of rosettes and smaller spirals, courtesy of an if statement")?'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章 循环很有趣（你可以再说一遍）")中，我们看到了一种使用条件做出决策的语句：`while` 语句。在那些例子中，条件告诉
    `while` 循环应该执行多少次。如果我们想要根据*是否*执行一组语句来做决策会怎么样呢？想象一下，如果我们能编写一个程序，让用户决定他们是否希望在螺旋图案上使用圆形或其他形状。或者，如果我们想要圆形*和*其他形状，像[图5-1](ch05.html#spiral_of_rosettes_and_smaller_spiralsco
    "图5-1. 由 `if` 语句生成的玫瑰花形螺旋和更小的螺旋")中的那样呢？
- en: '![A spiral of rosettes and smaller spirals, courtesy of an if statement](httpatomoreillycomsourcenostarchimages2188891.png.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![由 `if` 语句生成的玫瑰花形螺旋和更小的螺旋](httpatomoreillycomsourcenostarchimages2188891.png.jpg)'
- en: Figure 5-1. A spiral of rosettes and smaller spirals, courtesy of an `if` statement
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1. 由 `if` 语句生成的玫瑰花形螺旋和更小的螺旋
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188893.png.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2188893.png.jpg)'
- en: The statement that makes all this possible is the `if` statement. It asks *if*
    something is true, and based on the answer, it decides whether to perform a set
    of actions or skip over them. If the temperature in a building is fine, the heating
    and cooling system doesn’t run, but if it’s too hot or too cold, the system turns
    on. If it’s raining outside, you bring an umbrella; otherwise, you don’t. In this
    chapter, we’ll learn how to program the computer to make decisions based on whether
    a condition is true or false.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使这一切成为可能的语句就是 `if` 语句。它询问*是否*某事为真，并根据答案决定是执行一组动作还是跳过它们。如果建筑物内的温度正常，暖气和空调系统不会运行，但如果温度过高或过低，系统会开启。如果外面下雨，你就带伞；否则你就不带。在本章中，我们将学习如何编程让计算机根据条件是否为真来做出决策。
- en: If Statements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`if` 语句'
- en: The `if` statement is an important programming tool. It allows us to tell the
    computer whether to run a group of instructions, based on a condition or set of
    conditions. With an `if` statement, we can tell the computer to make a choice.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句是一个重要的编程工具。它允许我们根据一个或一组条件来告诉计算机是否运行一组指令。通过 `if` 语句，我们可以告诉计算机做出选择。'
- en: 'The syntax of the `if` statement—that is, the way we code an `if` statement
    so the computer understands it—looks like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句的语法——即我们编写 `if` 语句的方式，使计算机能够理解——如下所示：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The condition we’re testing in an `if` statement is usually a Boolean expression,
    or a true/false test. A Boolean expression evaluates to either `True` or `False`.
    When you use a Boolean expression with an `if` statement, you specify an action
    or set of actions that you want performed if the expression is true. If the expression
    is true, the program will run the indented statement(s), but if it’s false, the
    program will skip them and continue with the rest of the program at the next unindented
    line.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`if`语句中测试的条件通常是一个布尔表达式，或者是一个真/假测试。布尔表达式的结果是`True`或`False`。当你在`if`语句中使用布尔表达式时，你指定的是当表达式为真时要执行的动作或一组动作。如果表达式为真，程序将执行缩进的语句；如果为假，程序将跳过这些语句，并继续执行下一个未缩进的语句。
- en: '*IfSpiral.py* shows an example of an `if` statement in code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*IfSpiral.py*展示了一个`if`语句的代码示例：'
- en: IfSpiral.py
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IfSpiral.py
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line of our *IfSpiral.py* program ➊ asks the user to enter `y` or
    `n` for whether they would like to see a spiral and stores the user’s response
    in `answer`. At ➋, the `if` statement checks to see if `answer` is equal to `'y'`.
    Notice that the operator to test “is equal to” uses two equal signs together,
    `==`, to distinguish it from the assignment operator, which is a single equal
    sign like at ➊. The `==` operator checks to see if `answer` and `'y'` are equal.
    If they are, the condition in our `if` statement is true. We use a pair of single
    quotation marks (`'`) around a letter or other character when we’re testing a
    variable to see if it contains a single character entered by the user.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*IfSpiral.py*程序的第一行 ➊要求用户输入`y`或`n`，表示他们是否希望看到螺旋，并将用户的回答存储在`answer`中。在➋处，`if`语句检查`answer`是否等于`'y'`。请注意，测试“是否相等”的运算符使用的是两个等号`==`，以将其与赋值运算符（在➊处的单个等号）区分开来。`==`运算符检查`answer`和`'y'`是否相等。如果相等，`if`语句中的条件为真。我们在测试变量时，如果是单个字符（例如用户输入的字符），会在字母或其他字符周围加上一对单引号（`'`）。
- en: If our condition at ➋ is true, we print `Working...` on the screen at ➌, then
    draw a spiral on the screen. Notice that the `print` statement at ➌ and the statements
    that draw the spiral all the way down to ➏ are indented. These indented statements
    will be executed only if the condition at ➋ is true. Otherwise, the program will
    skip all the way to ➐ and just print `Okay, we're done!`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在➋的条件为真，我们会在➌的屏幕上打印`Working...`，然后在屏幕上绘制一个螺旋。请注意，➌处的`print`语句以及绘制螺旋的语句一直到➏都被缩进了。这些缩进的语句只有在➋的条件为真时才会执行。否则，程序将跳过这些语句，直接跳到➐并打印`Okay,
    we're done!`。
- en: The statements after our `for` loop at ➍ are indented farther (➎ and ➏). This
    is because they belong to the `for` statement. Just as we added a loop inside
    another loop in [Chapter 4](ch04.html "Chapter 4. Loops Are Fun (You Can Say That
    Again)") by indenting the nested loop, we can put a loop inside an `if` statement
    by indenting the whole loop.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➔4之后的语句被缩进得更深（➎和➏）。这是因为它们属于`for`语句。就像我们在[第4章](ch04.html "第4章：循环很有趣（你可以再说一遍）")通过缩进嵌套循环将一个循环添加到另一个循环中一样，我们也可以通过缩进整个循环将一个循环放入`if`语句中。
- en: Once the spiral is complete, our program picks back up at ➐ and tells the user
    we’re done. This is also the line our program jumps to if the user typed `n` or
    anything other than `y` at ➊. Remember, the whole `if` block from ➌ through ➏
    is skipped if the condition at ➋ is `False`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦螺旋完成，我们的程序将继续从➐开始，并告诉用户我们已经完成。这也是程序在用户在➊输入`n`或其他任何不是`y`的字符时跳转到的行。记住，如果➋的条件为`False`，整个`if`块从➌到➏都会被跳过。
- en: Type *IfSpiral.py* in a new IDLE window or download it from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*,
    and run it a few times, testing different answers. If you enter the letter `y`
    when prompted, you’ll see a spiral like the one in [Figure 5-2](ch05.html#if_you_answer_y_to_the_question_in_ifspi
    "Figure 5-2. If you answer y to the question in IfSpiral.py, you’ll see a spiral
    like this one.").
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的IDLE窗口中输入*IfSpiral.py*，或者从*[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*下载它，并运行几次，测试不同的答案。如果你在提示时输入字母`y`，你会看到像[图5-2](ch05.html#if_you_answer_y_to_the_question_in_ifspi
    "图5-2。如果你在IfSpiral.py中的问题上回答'y'，你将看到像这样的螺旋。")中的螺旋。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188895.png.jpg)![If
    you answer y to the question in IfSpiral.py, you’ll see a spiral like this one.](httpatomoreillycomsourcenostarchimages2188897.png.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages2188895.png.jpg)![如果你在IfSpiral.py中回答''y''，你将看到像这样的螺旋。](httpatomoreillycomsourcenostarchimages2188897.png.jpg)'
- en: Figure 5-2. If you answer `y` to the question in *IfSpiral.py*, you’ll see a
    spiral like this one.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-2。如果你在*IfSpiral.py*中回答`y`，你将看到一个像这样的螺旋图案。
- en: If you enter a character other than a lowercase `y`—or more than one character—the
    program prints `Okay, we're done!` and ends.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入一个小写字母`y`以外的字符，或者输入多个字符，程序将打印出`Okay, we're done!`并结束。
- en: Meet the Booleans
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认识布尔值
- en: 'Boolean expressions, or [*conditional expressions*](apd.html#gloss01_014),
    are important programming tools: the computer’s ability to make decisions depends
    on its ability to evaluate Boolean expressions to `True` or `False`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔表达式，或称[*条件表达式*](apd.html#gloss01_014)，是重要的编程工具：计算机做决策的能力依赖于它评估布尔表达式为`True`或`False`的能力。
- en: 'We have to use the computer’s language to tell it the condition we’d like to
    test. The syntax of a conditional expression in Python is this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用计算机的语言告诉它我们想要测试的条件。Python中条件表达式的语法是这样的：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each expression can be a variable, a value, or another expression. In *IfSpiral.py*,
    `answer == 'y'` was a conditional expression, with `answer` as the first expression
    and `'y'` as the second. The conditional operator was `==`, to check if `answer`
    was equal to `'y'`. There are many other conditional operators in Python besides
    `==`. Let’s learn about some of them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表达式可以是一个变量、一个值或另一个表达式。在*IfSpiral.py*中，`answer == 'y'`是一个条件表达式，其中`answer`是第一个表达式，`'y'`是第二个表达式。条件运算符是`==`，用来检查`answer`是否等于`'y'`。除了`==`，Python中还有许多其他的条件运算符。让我们来了解一些。
- en: Comparison Operators
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: The most common conditional operators are *comparison operators*, which let
    you test two values to see how they compare to each other. Is one of the values
    bigger or smaller than the other? Are they equal? Each comparison you make using
    a comparison operator is a condition that will evaluate to `True` or `False`.
    One real-world example of a comparison is when you enter a passcode to access
    a building. The Boolean expression takes the passcode you entered and compares
    it to the correct passcode; if the input matches (is equal to) the correct passcode,
    the expression evaluates to `True`, and the door opens.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的条件运算符是*比较运算符*，它让你测试两个值，看看它们如何互相比较。一个值是否大于或小于另一个值？它们是否相等？每次使用比较运算符进行比较时，都会产生一个条件，它的结果是`True`或`False`。一个现实世界中的比较例子是你输入密码来进入大楼。布尔表达式将你输入的密码与正确的密码进行比较；如果输入匹配（等于）正确的密码，表达式的结果为`True`，门就会打开。
- en: The comparison operators are shown in [Table 5-1](ch05.html#python_comparison_operators
    "Table 5-1. Python Comparison Operators").
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符展示在[表5-1](ch05.html#python_comparison_operators "表5-1. Python 比较运算符")中。
- en: Table 5-1. Python Comparison Operators
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-1. Python 比较运算符
- en: '| Math symbol | Python operator | Meaning | Example | Result |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 数学符号 | Python 运算符 | 意义 | 示例 | 结果 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `<` | `<` | Less than | `1 < 2` | `True` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `<` | `<` | 小于 | `1 < 2` | `True` |'
- en: '| `>` | `>` | Greater than | `1 > 2` | `False` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `>` | `>` | 大于 | `1 > 2` | `False` |'
- en: '| `≤` | `<=` | Less than or equal to | `1 <= 2` | `True` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `≤` | `<=` | 小于或等于 | `1 <= 2` | `True` |'
- en: '| `≥` | `>=` | Greater than or equal to | `1 >= 2` | `False` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `≥` | `>=` | 大于或等于 | `1 >= 2` | `False` |'
- en: '| `=` | `==` | Equal to | `1 == 2` | `False` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `=` | `==` | 等于 | `1 == 2` | `False` |'
- en: '| `≠` | `!=` | Not equal to | `1 != 2` | `True` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `≠` | `!=` | 不等于 | `1 != 2` | `True` |'
- en: 'As we saw with math operators in [Chapter 3](ch03.html "Chapter 3. Numbers
    and Variables: Python Does the Math"), some of the operators in Python are different
    from math symbols to make them easier to type on a standard keyboard. *Less than*
    and *greater than* use the symbols we’re used to, `<` and `>`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](ch03.html "第3章. 数字和变量：Python 做数学")中看到的，Python中的一些运算符与数学符号不同，这是为了让它们在标准键盘上更容易输入。*小于*和*大于*使用我们熟悉的符号`<`和`>`。
- en: For *less than or equal to*, Python uses the less than sign and equal sign together,
    `<=`, with no space in between. The same goes for *greater than or equal to*,
    `>=`. Remember *not* to put a space between the two signs, as that will cause
    an error in your program.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*小于或等于*，Python使用小于符号和等号符号一起，`<=`，中间没有空格。*大于或等于*也是如此，使用`>=`。记住*不要*在这两个符号之间加空格，否则会导致程序出错。
- en: The operator to see if two values are equal is the double equal sign, `==`,
    because the single equal sign is already used as the assignment operator. The
    expression `x = 5` assigns the value `5` to the variable `x`, but `x == 5` tests
    to see if `x` *is equal to* `5`. It’s helpful to read the double equal sign out
    loud as “is equal to” so you can avoid the common mistake of writing the incorrect
    statement `if x = 5` instead of the correct `if x` **`==`** `5` (“if x *is equal
    to* five”) in your programs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检查两个值是否相等的操作符是双等号 `==`，因为单个等号已经用作赋值操作符。表达式 `x = 5` 将值 `5` 赋给变量 `x`，而 `x ==
    5` 用来测试 `x` 是否 *等于* `5`。为了避免常见的错误，可以将双等号大声读作“等于”，这样就能避免错误地写出 `if x = 5`（错误的语句）而应写作正确的
    `if x` **`==`** `5`（“如果 x *等于* 5”）。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188899.png.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188899.png.jpg)'
- en: The operator that tests to see if two values are *not equal* is `!=`, an exclamation
    point followed by the equal sign. This combination may be easier to remember if
    you say “not equal to” when you see `!=` in a statement. For example, you might
    read `if x != 5` aloud as “if x *is not equal to* five.”
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用来测试两个值是否 *不相等* 的操作符是 `!=`，即感叹号后跟等号。你可以将其记为“*不等于*”，例如，看到 `if x != 5` 时，可以大声读作“如果
    x *不等于* 5”。
- en: The result of a test involving a conditional operator is one of the Boolean
    values, `True` or `False`. Go to the Python shell and try entering some of the
    expressions shown in [Figure 5-3](ch05.html#testing_conditional_expressions_in_the_p
    "Figure 5-3. Testing conditional expressions in the Python shell"). Python will
    respond with either `True` or `False`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及条件操作符的测试结果是布尔值之一，`True` 或 `False`。进入 Python shell，尝试输入图 [5-3](ch05.html#testing_conditional_expressions_in_the_p
    "图 5-3. 在 Python shell 中测试条件表达式") 中显示的一些表达式。Python 将返回 `True` 或 `False`。
- en: '![Testing conditional expressions in the Python shell](httpatomoreillycomsourcenostarchimages2188901.png.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![在 Python shell 中测试条件表达式](httpatomoreillycomsourcenostarchimages2188901.png.jpg)'
- en: Figure 5-3. Testing conditional expressions in the Python shell
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3. 在 Python shell 中测试条件表达式
- en: We start by going to the shell and entering **`x = 5`** to create a variable
    called `x` that holds the value `5`. On the second line, we check the value of
    `x` by typing it by itself, and the shell responds with its value, `5`. Our first
    conditional expression is `x > 2`, or “x is greater than two.” Python responds
    with `True` because `5` is greater than `2`. Our next expression, `x < 2` (“x
    is less than two”), is false when `x` is equal to `5`, so Python returns `False`.
    The remaining conditionals use the `<=` (less than or equal to), `>=` (greater
    than or equal to), `==` (is equal to), and `!=` (not equal to) operators.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从进入 shell 开始，输入 **`x = 5`** 来创建一个名为 `x` 的变量，并赋值为 `5`。在第二行，我们通过单独输入 `x` 来检查其值，shell
    会返回 `5`。我们的第一个条件表达式是 `x > 2`，也就是“x 大于 2”。Python 返回 `True`，因为 `5` 大于 `2`。接下来的表达式
    `x < 2`（“x 小于 2”）在 `x` 等于 `5` 时为假，所以 Python 返回 `False`。剩余的条件表达式使用了 `<=`（小于或等于）、`>=`（大于或等于）、`==`（等于）和
    `!=`（不等于）操作符。
- en: Every conditional expression will evaluate to either `True` or `False` in Python.
    Those are the only two Boolean values, and the capital *T* in `True` and capital
    *F* in `False` are required. `True` and `False` are built-in constant values in
    Python. Python will not understand if you type `True` as `true` without the capital
    *T*, and the same goes for `False`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条件表达式在 Python 中都会计算为 `True` 或 `False`。这两者是唯一的布尔值，而且 `True` 中的 *T* 和 `False`
    中的 *F* 必须大写。`True` 和 `False` 是 Python 内置的常量值。如果你将 `True` 写成 `true`（没有大写的 *T*）或将
    `False` 写成 `false`，Python 将无法理解。
- en: You’re Not Old Enough!
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你还不够年龄！
- en: Let’s write a program that uses Boolean conditional expressions to see if you’re
    old enough to drive a car. Type the following in a new window and save it as *OldEnough.py*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序，使用布尔条件表达式来检查你是否足够年龄开车。在新窗口中输入以下内容，并将其保存为 *OldEnough.py*。
- en: OldEnough.py
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OldEnough.py
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At ➊, we ask the user for the legal driving age in their area, evaluate the
    number they enter, and store that value in the variable `driving_age`. At ➋, we
    ask for the user’s current age and store that number in `your_age`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们询问用户所在地区的合法驾龄，评估他们输入的数字，并将该值存储在变量 `driving_age` 中。在 ➋，我们询问用户当前的年龄，并将该数字存储在
    `your_age` 中。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188903.png.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188903.png.jpg)'
- en: The `if` statement at ➌ checks to see if the user’s current age is *greater
    than or equal to* the driving age. If ➌ evaluates to `True`, the program runs
    the code at ➍ and prints, `"You're old enough to drive!"`. If the condition at
    ➌ evaluates to `False`, the program skips ➍ and goes to ➎. At ➎, we check if the
    user’s age is *less than* the driving age. If so, the program runs the code at
    ➏ and tells the user how many years it’ll be until they can drive by subtracting
    `driving_age` from `your_age` and printing the result. [Figure 5-4](ch05.html#iapostrophem_old_enough_to_drive_in_the
    "Figure 5-4. I’m old enough to drive in the United States, but my five-year-old
    son isn’t.") shows the results of this program for my son and me.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处的`if`语句检查用户当前年龄是否*大于或等于*驾龄。如果➌评估为`True`，程序将运行➍处的代码，并打印出 `"你足够大，可以开车！"`。如果➌的条件评估为`False`，程序将跳过➍，并转到➎。在➎处，我们检查用户的年龄是否*小于*驾龄。如果是，程序将在➏处运行代码，并通过从`your_age`中减去`driving_age`来告诉用户距离他们可以开车还需多少年，并打印结果。[图
    5-4](ch05.html#iapostrophem_old_enough_to_drive_in_the "图 5-4. 我足够大可以在美国开车，但我的五岁儿子不能。")展示了我和我儿子运行此程序的结果。
- en: '![I’m old enough to drive in the United States, but my five-year-old son isn’t.](httpatomoreillycomsourcenostarchimages2188905.png.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![我足够大可以在美国开车，但我的五岁儿子不能。](httpatomoreillycomsourcenostarchimages2188905.png.jpg)'
- en: Figure 5-4. I’m old enough to drive in the United States, but my five-year-old
    son isn’t.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4. 我足够大可以在美国开车，但我的五岁儿子不能。
- en: The only catch is that the last `if` statement at ➎ feels redundant. If the
    user is old enough at ➌, we shouldn’t need to test to see if they’re too young,
    because we already know they’re not. And if the user *isn’t* old enough at ➌,
    we shouldn’t need to test to see if they’re too young at ➎, because we already
    know they are. If only Python had a way of getting rid of that unnecessary code
    . . . well, it just so happens that Python *does* have a shorter, faster way to
    handle situations like this one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要注意的是，在➎处的最后一个`if`语句显得有些冗余。如果用户在➌处已经足够大，我们就不需要再测试他们是否太年轻，因为我们已经知道他们不是。而如果用户在➌处*不够*大，我们也不需要在➎处测试他们是否太年轻，因为我们已经知道他们是。如果Python能有办法去掉这些不必要的代码就好了……嗯，恰好Python*确实*有一种更短、更快的方法来处理像这种情况。
- en: Else Statements
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`else`语句'
- en: 'Often we want our program to do one thing if a condition evaluates to `True`
    and something else if the condition evaluates to `False`. This is so common, in
    fact, that we have a shortcut, the `else` statement, that allows us to test if
    the condition is true without having to perform another test to see if it’s false.
    The `else` statement can only be used after an `if` statement, not by itself,
    so we sometimes refer to the two together as an `if-else`. The syntax looks like
    this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常常希望程序在某个条件为`True`时执行一件事情，在条件为`False`时执行另一件事情。实际上，这种情况非常常见，以至于我们有了一个快捷方式——`else`语句，它允许我们在不需要再次测试条件是否为`False`的情况下，直接测试条件是否为`True`。`else`语句只能在`if`语句后使用，不能单独使用，因此我们有时将这两者一起称为`if-else`。其语法如下：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the condition in an `if` statement is true, the indented statements under
    the `if` are executed, and the `else` and all its statements are skipped. If the
    condition in the `if` statement is false, the program skips directly to the `else`’s
    other indented statements and runs those.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`if`语句中的条件为真，则执行`if`下的缩进语句，跳过`else`及其所有语句。如果`if`语句中的条件为假，则程序将直接跳到`else`下的其他缩进语句并执行它们。
- en: We can rewrite *OldEnough.py* with an `else` statement to remove the extra conditional
    test (`your_age < driving_age`). This not only makes the code shorter and easier
    to read, but it also helps prevent coding errors in the two conditions. For example,
    if we test `your_age > driving_age` in the first `if` statement and `your_age
    < driving_age` in the second `if` statement, we might accidentally leave out the
    case where `your_age == driving_age`. By using the `if-else` statement pair, we
    can just test `if your_age >= driving_age` to see if you’re old enough to drive
    and inform you if you are, and otherwise go to the `else` statement and print
    how many years you must wait to drive.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`else`语句重写*OldEnough.py*，从而去除多余的条件判断（`your_age < driving_age`）。这不仅使代码更简洁易读，还能帮助避免在两个条件中出现编码错误。例如，如果我们在第一个`if`语句中测试`your_age
    > driving_age`，而在第二个`if`语句中测试`your_age < driving_age`，我们可能会不小心漏掉`your_age == driving_age`的情况。通过使用`if-else`语句对，我们只需测试`if
    your_age >= driving_age`来判断你是否足够大可以开车，并告知你，如果可以，否则进入`else`语句并打印你需要等多少年才能开车。
- en: 'Here’s *OldEnoughOrElse.py*, a revised version of *OldEnough.py* with an `if-else`
    instead of two `if` statements:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*OldEnoughOrElse.py*，它是*OldEnough.py*的修订版，使用了`if-else`语句代替了两个`if`语句：
- en: OldEnoughOrElse.py
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OldEnoughOrElse.py
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only difference between the two programs is that we replaced the second
    `if` statement and condition with a shorter, simpler `else` statement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 两个程序的唯一区别是，我们将第二个`if`语句和条件替换为更短、更简单的`else`语句。
- en: Polygons or Rosettes
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多边形或玫瑰花形
- en: As a visual example, we can ask the user to input whether they’d like to draw
    a polygon (triangle, square, pentagon, and so on) or a rosette with a certain
    number of sides or circles. Depending on the user’s choice (`p` for polygon or
    `r` for rosette), we can draw exactly the right shape.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个视觉示例，我们可以让用户输入他们是想绘制多边形（三角形、正方形、五边形等）还是玫瑰花形，指定边数或圆圈数。根据用户的选择（`p`表示多边形或`r`表示玫瑰花形），我们可以绘制准确的形状。
- en: Let’s type and run this example, *PolygonOrRosette.py*, which has an `if-else`
    statement pair.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入并运行这个示例，*PolygonOrRosette.py*，它包含一个`if-else`语句对。
- en: PolygonOrRosette.py
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PolygonOrRosette.py
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At ➊, we ask the user for a number of sides (for a polygon) or circles (for
    a rosette). At ➋, we give the user a choice between `p` for polygon or `r` for
    rosette. Run the program a few times, trying each option with different numbers
    of sides/circles, and see how the `for` loop at ➌ works.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们要求用户输入边数（对于多边形）或圆圈数（对于玫瑰花形）。在➋处，我们给用户一个选择，`p`表示多边形，`r`表示玫瑰花形。运行程序几次，尝试每个选项，并输入不同的边数/圆圈数，看看➌处的`for`循环是如何工作的。
- en: Notice that ➍ through ➑ are indented, so they are part of the `for` loop at
    ➌ and are executed the number of times the user entered as the number of lines
    or circles at ➊. The `if` statement at ➍ checks to see if the user entered `r`
    to draw a rosette, and if that’s true, ➎ is executed and draws a circle at this
    location as part of the rosette. If the user entered `p` or anything other than
    `r`, the `else` statement at ➏ is selected and draws a line at ➐ by default, to
    make one side of a polygon. Finally, at ➑ we turn left by the correct number of
    degrees (360 degrees divided by the number of sides or rosettes) and keep looping
    from ➌ to ➑ until the shape is finished. See [Figure 5-5](ch05.html#our_polygonorrosettedotpy_program_with_u
    "Figure 5-5. Our PolygonOrRosette.py program with user input of 7 sides and r
    for rosette") for an example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，➍到➑是缩进的，所以它们是`for`循环的一部分，位于➌，并且根据用户在➊输入的行数或圆圈数执行相应次数。➍处的`if`语句检查用户是否输入了`r`来绘制玫瑰花形，如果为真，➎将被执行并在当前位置绘制一个圆圈，作为玫瑰花形的一部分。如果用户输入了`p`或其他任何非`r`的内容，则会选择➏处的`else`语句，默认绘制一条线段，在➐处作为多边形的一条边。最后，在➑处我们按正确的角度（360度除以边数或玫瑰花形的数量）左转并保持循环从➌到➑，直到形状完成。请参见[图5-5](ch05.html#our_polygonorrosettedotpy_program_with_u
    "图5-5. 我们的PolygonOrRosette.py程序，用户输入7边和r表示玫瑰花形")，查看示例。
- en: '![Our PolygonOrRosette.py program with user input of 7 sides and r for rosette](httpatomoreillycomsourcenostarchimages2188907.png.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![我们的PolygonOrRosette.py程序，用户输入7边和r表示玫瑰花形](httpatomoreillycomsourcenostarchimages2188907.png.jpg)'
- en: Figure 5-5. Our *PolygonOrRosette.py* program with user input of `7` sides and
    `r` for rosette
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-5。我们的*PolygonOrRosette.py*程序，用户输入`7`边和`r`表示玫瑰花形
- en: Even or Odd?
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偶数还是奇数？
- en: The `if-else` statement can test more than user input. We can use it to alternate
    shapes, like in [Figure 5-1](ch05.html#spiral_of_rosettes_and_smaller_spiralsco
    "Figure 5-1. A spiral of rosettes and smaller spirals, courtesy of an if statement"),
    by using an `if` statement to test our loop variable each time it changes to see
    if it’s even or odd. On every even pass through the loop—when our variable is
    equal to `0`, `2`, `4`, and so on—we can draw a rosette, and on every odd pass
    through the loop, we can draw a polygon.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else`语句不仅可以测试用户输入。我们还可以用它来交替形状，就像在[图5-1](ch05.html#spiral_of_rosettes_and_smaller_spiralsco
    "图5-1. 玫瑰花形和更小的螺旋形，感谢if语句")中那样，通过每次循环变量发生变化时，使用`if`语句测试它是偶数还是奇数。在每次偶数次通过循环时——当我们的变量等于`0`、`2`、`4`等——我们可以绘制一个玫瑰花形；在每次奇数次通过循环时，我们可以绘制一个多边形。'
- en: 'To do this, we need to know how to check if a number is odd or even. Think
    about how we decide if a number is even; that means the number is divisible by
    two. Is there a way to see if a number is evenly divisible by two? “Evenly divisible”
    means there’s no remainder. For example, four is *even*, or evenly divisible by
    two, because 4 ÷ 2 = 2 with no remainder. Five is *odd* because 5 ÷ 2 = 2 with
    a remainder of 1\. So even numbers have a remainder of zero when they’re divided
    by two, and odd numbers have a remainder of one. Remember the remainder operator?
    That’s right: it’s our old friend the modulo operator, `%`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要知道如何检查一个数字是奇数还是偶数。考虑一下我们如何判断一个数字是偶数；这意味着这个数字可以被 2 整除。有办法看一个数字是否可以被
    2 平均整除吗？“平均整除”意味着没有余数。例如，4 是 *偶数*，因为 4 ÷ 2 = 2，没有余数。5 是 *奇数*，因为 5 ÷ 2 = 2，余数为
    1。所以偶数除以 2 时余数为零，奇数除以 2 时余数为 1。还记得余数运算符吗？没错：就是我们熟悉的模运算符 `%`。
- en: 'In Python code, we can set up a loop variable `m` and check to see if `m` is
    even by testing `m % 2 == 0`—that is, checking to see if the remainder when we
    divide `m` by two is equal to zero:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 代码中，我们可以设置一个循环变量 `m`，并通过测试 `m % 2 == 0` 来检查 `m` 是否为偶数——也就是说，检查当我们将
    `m` 除以 2 时，余数是否为零：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s modify a spiral program to draw rosettes at even corners and polygons
    at odd corners of a big spiral. We’ll use a big `for` loop for the big spiral,
    an `if-else` statement to check whether to draw a rosette or a polygon, and two
    small inner loops to draw either a rosette or a polygon. This will be longer than
    most of our programs so far, but comments will help explain what the program is
    doing. Type and run the following program, *RosettesAndPolygons.py*, and be sure
    to check that your indentation is correct for the loops and `if` statements.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改一个螺旋程序，在大螺旋的偶数角绘制花形，在奇数角绘制多边形。我们将使用一个大的 `for` 循环来绘制大螺旋，使用 `if-else` 语句来检查是绘制花形还是多边形，并使用两个小的内部循环来绘制花形或多边形。这将比我们到目前为止的大多数程序都要长，但注释将帮助解释程序的功能。输入并运行以下程序，*RosettesAndPolygons.py*，并确保检查循环和
    `if` 语句的缩进是否正确。
- en: RosettesAndPolygons.py
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RosettesAndPolygons.py
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s look at how this program works. At ➊, we set up a `for` loop over the
    range 5 to 75; we’re skipping 0 to 4 because it’s hard to see shapes that are
    4 pixels across or smaller. We turn for our spiral; then, at ➋ we use integer
    division to make the pen wider (thicker) after every 25th shape. [Figure 5-6](ch05.html#two_runs_of_our_rosettesandpolygonsdotpy
    "Figure 5-6. Two runs of our RosettesAndPolygons.py program with user inputs of
    4 sides (top) and 5 sides (bottom)") shows the lines getting thicker as the shapes
    get bigger.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序是如何工作的。在 ➊ 处，我们设置了一个从 5 到 75 的 `for` 循环；我们跳过了 0 到 4，因为很难看到大小为 4 像素或更小的形状。我们开始绘制螺旋；然后，在
    ➋ 处，我们使用整数除法，使得每绘制 25 个形状后，画笔变宽（加粗）。[图 5-6](ch05.html#two_runs_of_our_rosettesandpolygonsdotpy
    "图 5-6. 我们的 *RosettesAndPolygons.py* 程序的两次运行，用户输入为 4 边（上图）和 5 边（下图）") 显示了形状变大时，线条变得更粗。
- en: At ➌, we lift our turtle’s pen off the screen and move forward so we don’t draw
    lines between rosettes and polygons. At ➍, we put the pen back down and get ready
    to draw a shape at the corner of the big spiral. At ➎, we test our loop variable
    `m` to see if we’re drawing at an even corner. If `m` is even (`m % 2 == 0`),
    we draw the rosette with the `for` loop at ➏. Otherwise, the `else` at ➐ tells
    us to draw a polygon using the `for` loop beginning at ➑.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，我们将海龟的画笔抬起并向前移动，这样就不会在花形和多边形之间画线了。到 ➍ 时，我们将画笔放下，并准备在大螺旋的角落处绘制一个形状。在 ➎
    处，我们测试循环变量 `m`，看看我们是否在偶数角绘制。如果 `m` 是偶数（`m % 2 == 0`），我们将在 ➏ 处使用 `for` 循环绘制花形。否则，
    ➐ 处的 `else` 告诉我们使用从 ➑ 开始的 `for` 循环绘制多边形。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188909.png.jpg)![Two
    runs of our RosettesAndPolygons.py program with user inputs of 4 sides (top) and
    5 sides (bottom)](httpatomoreillycomsourcenostarchimages2188911.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2188909.png.jpg)![我们的 *RosettesAndPolygons.py*
    程序的两次运行，用户输入为 4 边（上图）和 5 边（下图）](httpatomoreillycomsourcenostarchimages2188911.png)'
- en: Figure 5-6. Two runs of our *RosettesAndPolygons.py* program with user inputs
    of `4` sides (top) and `5` sides (bottom)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6. 我们的 *RosettesAndPolygons.py* 程序的两次运行，用户输入为 `4` 边（上图）和 `5` 边（下图）
- en: Notice that when we use an even number of sides, the alternating shapes form
    separate legs of the spiral, as shown at the top in [Figure 5-6](ch05.html#two_runs_of_our_rosettesandpolygonsdotpy
    "Figure 5-6. Two runs of our RosettesAndPolygons.py program with user inputs of
    4 sides (top) and 5 sides (bottom)"). But when the number of sides is odd, each
    leg of the spiral alternates with the even (rosette) shape and the odd (polygon)
    shape. With color and some thought, you can make this program draw a design like
    the one in [Figure 5-1](ch05.html#spiral_of_rosettes_and_smaller_spiralsco "Figure 5-1. A
    spiral of rosettes and smaller spirals, courtesy of an if statement"). The `if-else`
    statements add another dimension to our programming toolkit.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们使用偶数边数时，交替的形状会形成螺旋的不同部分，如[图5-6](ch05.html#two_runs_of_our_rosettesandpolygonsdotpy
    "图5-6：我们的RosettesAndPolygons.py程序的两次运行，用户输入为4边（顶部）和5边（底部）")所示。但当边数为奇数时，螺旋的每一条腿都与偶数（玫瑰花形）形状和奇数（多边形）形状交替。通过加上颜色和一些思考，你可以让这个程序绘制出像[图5-1](ch05.html#spiral_of_rosettes_and_smaller_spiralsco
    "图5-1：由if语句提供的玫瑰花和较小螺旋的螺旋")这样的设计。`if-else`语句为我们的编程工具包增添了另一维度。
- en: Elif Statements
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elif 语句
- en: 'There’s one more useful add-on to an `if` statement: the `elif` clause. No,
    that’s not one of Santa’s helpers! An `elif` is a way to string together `if-else`
    statements when you need to check for more than two possible outcomes. The keyword
    `elif` is short for “else if.” Think about letter grades in school: if you score
    98 percent on an exam, the teacher might assign a grade of A or A+ depending on
    the grading scale. But if you score lower, there’s not just one grade (there are
    more options than A or F, thank goodness). Instead, there are several possible
    grades your teacher might use: A, B, C, D, or F.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句还有一个有用的附加功能：`elif`子句。不是圣诞老人的助手哦！`elif`是一种将`if-else`语句串联在一起的方式，当你需要检查超过两个可能的结果时就能派上用场。关键字`elif`是“else
    if”的缩写。想想学校里的字母成绩：如果你在考试中得了98分，老师可能会根据评分标准给你A或A+。但是如果你的分数较低，成绩不止A或F（谢天谢地）。相反，老师可能会使用几个不同的成绩选项：A、B、C、D或F。'
- en: This is a case where an `elif` statement or a set of `elif` statements can help.
    Let’s take the example of a 10-point grading scale, where 90 or above is an A,
    80–89 is a B, and so on. If your score is 95, we can print the letter grade A
    and skip all other options. Similarly, if you earned an 85, we don’t need to test
    further than a B. The `if-elif-else` construct helps us do this in a straightforward
    way. Try running the following program, *WhatsMyGrade.py*, and entering different
    values between 0 and 100.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以使用`elif`语句或一组`elif`语句的场景。我们以一个10分制的评分标准为例，90分或以上为A，80到89分为B，以此类推。如果你的分数是95分，我们可以打印字母成绩A并跳过其他选项。类似地，如果你得了85分，我们不需要再测试低于B的选项。`if-elif-else`结构帮助我们以直观的方式完成这一任务。尝试运行下面的程序，*WhatsMyGrade.py*，并输入不同的0到100之间的值。
- en: WhatsMyGrade.py
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WhatsMyGrade.py
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At ➊, we ask the user for a numeric grade from 0 to 100 with an `input()` prompt,
    convert it to a number with the `eval()` function, and store it in the variable
    `grade`. At ➋, we compare the user’s grade to the value `90`, the cutoff for a
    letter grade of A. If the user entered a score of 90 or greater, Python will print
    `You got an A! :)`, skip the other `elif` and `else` statements, and continue
    with the rest of the program. If the score is not 90 or greater, we proceed to
    ➌ to check for a grade of B. Again, if the score is 80 or greater, the program
    prints the correct grade and skips past the `else` statement. Otherwise, the `elif`
    statement at ➍ checks for a C, the `elif` statement at ➎ checks for a D, and,
    finally, any score less than 60 makes it all the way to ➏ and results in the `else`
    statement’s `You got an F. :(`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们通过`input()`提示要求用户输入一个0到100之间的数值，将其通过`eval()`函数转换为数字，并将其存储在变量`grade`中。在➋，我们将用户的成绩与90进行比较，90是A的字母成绩临界值。如果用户输入的分数为90或以上，Python会打印`You
    got an A! :)`，跳过其他`elif`和`else`语句，并继续执行程序的其余部分。如果分数不满90，我们会进入➌，检查是否为B级成绩。同样，如果分数为80或以上，程序会打印正确的成绩，并跳过`else`语句。否则，➔
    语句检查C级成绩，➎检查D级成绩，最后，任何低于60的分数都会进入➏，并输出`else`语句中的`You got an F. :(`。
- en: We can use `if`-`elif`-`else` statements to test a variable across multiple
    ranges of values. Sometimes, though, we need to test multiple variables. For example,
    when deciding what to wear for the day, we want to know the temperature (warm
    or cold) and the weather (sun or rain). To combine conditional statements, we
    need to learn a few new tricks.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`if`-`elif`-`else`语句来测试一个变量在多个值范围内的情况。然而，有时我们需要测试多个变量。例如，在决定穿什么衣服时，我们想知道温度（温暖或寒冷）和天气（晴天或下雨）。要结合条件语句，我们需要学习一些新技巧。
- en: 'Complex Conditions: If, and, or, not'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂条件：if、and、or、not
- en: There are times when a single conditional statement isn’t enough. What if we
    want to know if it’s warm *and* sunny or cold *and* rainy?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时单个条件语句不足以解决问题。如果我们想知道天气是温暖*而且*晴朗，还是寒冷*而且*下雨，怎么办？
- en: 'Think back to our first program in this chapter, in which we answered `y` if
    we wanted to draw a spiral. The first two lines asked for input and checked to
    see if that input was `y`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在本章中的第一个程序，当我们想要绘制螺旋时，如果输入`y`，就会得到答案。前两行代码请求输入并检查输入是否为`y`：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To see a spiral, the user has to enter `y` exactly; only this one answer is
    accepted. Even something similar, like capital `Y` or the word `yes`, doesn’t
    work because our `if` statement checks only for `y`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到螺旋，用户必须准确输入`y`；只有这个答案是被接受的。即使是类似的输入，比如大写`Y`或`yes`，也不起作用，因为我们的`if`语句只检查`y`。
- en: 'One easy way to solve the `Y` versus `y` problem is to use the `lower()` function,
    which makes strings all lowercase. You can try it in IDLE:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解决`Y`和`y`问题的一种简单方法是使用`lower()`函数，它将字符串转换为全小写字母。你可以在IDLE中尝试：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `lower()` function changed the capital `Y` and capital `S` in `Yes, Sir`
    to lowercase, leaving the rest of the string unchanged.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower()`函数将`Yes, Sir`中的大写`Y`和`S`转换为小写字母，其他部分的字符串保持不变。'
- en: 'We can use `lower()` on the user’s input so that no matter which they enter,
    `Y` or `y`, the condition in our `if` statement will be `True`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在用户输入上使用`lower()`，这样无论他们输入的是`Y`还是`y`，`if`语句中的条件都会是`True`：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, if a user enters either `Y` or `y`, our program checks to see if the lowercase
    version of their answer is `y`. But if we want to check for the full word `Yes`,
    we need a *compound `if` statement*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果用户输入`Y`或`y`，我们的程序会检查他们输入的答案的小写版本是否为`y`。但如果我们想检查完整的`Yes`这个单词，我们就需要使用*复合`if`语句*。
- en: 'Compound `if` statements are like compound sentences: “I’m going to the store,
    *and* I’m going to buy some groceries.” Compound `if` statements are useful when
    we want to do a bit more than just test whether one condition is true. We might
    want to test if this condition *and* another condition are both true. We might
    test if this condition *or* another condition is true. And we might want to see
    if the condition is *not* true. We do this in everyday life, too. We say, “If
    it’s cold *and* raining, I’ll wear my heavy raincoat,” “If it’s windy *or* cold,
    I’ll wear a jacket,” or “If it’s *not* raining, I’ll wear my favorite shoes.”'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 复合`if`语句就像复合句：“我要去商店，*而且*我要买些杂货。”当我们想要做的不仅仅是测试一个条件是否为真时，复合`if`语句非常有用。我们可能想要测试这个条件*和*另一个条件是否都为真。我们可能想测试这个条件*或*另一个条件是否为真。我们也可能想知道这个条件是否*不*为真。这些都是我们在日常生活中常做的事情。我们说：“如果天气冷*而且*下雨，我会穿上厚雨衣，”
    “如果刮风*或*很冷，我会穿上夹克，”或者“如果*不*下雨，我会穿上我最喜欢的鞋子。”
- en: When we build a compound `if` statement, we use one of the *logical operators*
    shown in [Table 5-2](ch05.html#logical_operators "Table 5-2. Logical Operators").
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建复合`if`语句时，我们会使用[表格5-2](ch05.html#logical_operators "表格5-2. 逻辑运算符")中展示的*逻辑运算符*。
- en: Table 5-2. Logical Operators
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表格5-2. 逻辑运算符
- en: '| Logical operator | Usage | Result |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑运算符 | 用法 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `and` | `if(`*`condition1`* `and` *`condition2`*`):` | True only if both
    *`condition1`* and *`condition2`* are `True` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `and` | `if(`*`condition1`* `and` *`condition2`*`):` | 仅当*`condition1`*和*`condition2`*都为`True`时为真
    |'
- en: '| `or` | `if(`*`condition1`* `or` *`condition2`*`):` | True if either of *`condition1`*
    or *`condition2`* are `True` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `or` | `if(`*`condition1`* `or` *`condition2`*`):` | 如果*`condition1`*或*`condition2`*为`True`，则为真
    |'
- en: '| `not` | `if not(`*`condition`*`):` | True only if the *`condition`* is `False`
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `not` | `if not(`*`condition`*`):` | 仅当*`condition`*为`False`时为真 |'
- en: We can use the `or` operator to check if the user entered `y` *or* `yes`; either
    one will do.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`or`运算符来检查用户输入的是`y` *或* `yes`，两者都可以。
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we’re testing if either of two conditions is `True`. If either is `True`,
    the user gets to see the spiral. Notice that we write the full conditional on
    either side of the `or` keyword: `answer == ''y'' or answer == ''yes''`. One common
    error for new programmers is trying to shorten `or` conditions by leaving out
    the second `answer ==`. To remember the right way to use an `or` statement, think
    about each condition separately. If any of the conditions joined by an `or` evaluates
    to `True`, the whole statement is true, but each condition has to be complete
    for the statement to work.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在测试两个条件中的任何一个是否为`True`。如果其中任何一个是`True`，用户将看到螺旋图案。注意，我们在`or`关键字的两边写出完整的条件表达式：`answer
    == 'y' or answer == 'yes'`。新手程序员常犯的一个错误是试图通过省略第二个`answer ==`来缩短`or`条件。要记住正确使用`or`语句的方法，可以将每个条件分开考虑。如果`or`连接的任何条件评估为`True`，整个语句就为真，但每个条件必须完整才能使语句生效。
- en: 'A compound condition using `and` looks similar, but `and` requires *every*
    condition in the statement to be true for the overall statement to evaluate to
    `True`. For an example, let’s write a program to decide what to wear based on
    the weather. Type *WhatToWear.py* in a new window or download it from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*,
    and run it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`and`的复合条件看起来类似，但`and`要求语句中的*每个*条件都为真，整个语句才会评估为`True`。举个例子，我们来编写一个程序，根据天气决定穿什么。可以在新窗口中输入*WhatToWear.py*，或者从*[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*下载并运行它：
- en: WhatToWear.py
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WhatToWear.py
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At ➊, we ask the user whether it’s raining outside, and at ➋, we ask if it’s
    cold or not. We also make sure the answers stored in `rainy` and `cold` are lowercase
    by adding the `lower()` function to the end of the `input()` functions on both
    lines. With these two conditions (whether it’s rainy and whether it’s cold), we
    can help the user decide what to wear. At ➌, the compound `if` statement checks
    to see if it’s both rainy and cold; if it is, the program suggests a raincoat.
    At ➍, the program checks to see if it’s both rainy and not cold. For rainy but
    not cold weather, the program recommends an umbrella. At ➎, we check to see if
    it’s *not* raining (`rainy` *not equal to* `'y'`) but still cold, requiring a
    jacket. Finally, at ➏, if it’s not raining *and* it’s not cold, wear whatever
    you want!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们询问用户外面是否在下雨，在➋，我们询问是否寒冷。我们还通过在`input()`函数的两行末尾加上`lower()`函数来确保`rainy`和`cold`中存储的答案是小写字母。有了这两个条件（是否下雨以及是否寒冷），我们可以帮助用户决定穿什么。在➌，复合`if`语句检查是否既下雨又寒冷；如果是，程序建议穿雨衣。在➍，程序检查是否既下雨又不寒冷。对于下雨但不寒冷的天气，程序推荐带伞。在➎，我们检查是否*不*下雨（`rainy`
    *不等于* `'y'`），但仍然寒冷，需要穿夹克。最后，在➏，如果不下雨*并且*不寒冷，随便穿什么都行！
- en: Secret Messages
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密信息
- en: 'Now that we understand how to use conditions, we’re going to learn to encode
    and decode secret messages using a Caesar cipher. A *cipher* is a secret code,
    or a way of changing messages to make them harder to read. The *Caesar cipher*
    is named after Julius Caesar, who is said to have liked sending private messages
    by shifting letters in the alphabet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了如何使用条件语句，接下来我们将学习如何使用凯撒密码编码和解码秘密信息。*密码*是一个秘密的代码，或者是一种改变信息的方式，使其更加难以阅读。*凯撒密码*以尤利乌斯·凯撒命名，据说他喜欢通过在字母表中移动字母来发送私人信息：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can create a simple Caesar cipher by using an encoder ring like the one shown
    in [Figure 5-7](ch05.html#caesar_cipher "Figure 5-7. A Caesar cipher"). To create
    the encoded message, decide on the *key*, or the number of letters you want to
    shift each letter by. In the coded message and in [Figure 5-7](ch05.html#caesar_cipher
    "Figure 5-7. A Caesar cipher"), each letter is being shifted by a key value of
    `13`, meaning we take the letter we want to encode and count 13 letters past it
    in the alphabet to get our encoded letter. An *A* becomes an *N*, a *B* becomes
    an *O*, and so on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用一个编码环来创建一个简单的凯撒密码，示例如[图 5-7](ch05.html#caesar_cipher "图 5-7. 凯撒密码")。要创建加密信息，首先决定*密钥*，即你想将每个字母移动多少个字母。在编码信息中以及在[图
    5-7](ch05.html#caesar_cipher "图 5-7. 凯撒密码")中，每个字母都被一个`13`的密钥值所移动，这意味着我们取一个想要编码的字母，然后在字母表中向后数13个字母，以得到我们的编码字母。*A*变成*N*，*B*变成*O*，依此类推。
- en: 'We sometimes call this shift a *rotation* because by the time we get to *M*
    (which becomes *Z*), we’re at the end of the alphabet. To be able to encode an
    *N*, we wrap around to *A* again. *O* wraps around to *B*, all the way to *Z*,
    which becomes an *M*. Here’s an example of a Caesar cipher lookup table for the
    key value of `13`, where each letter is shifted by 13 letters for encoding or
    decoding:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时称这种转换为 *旋转*，因为当我们到达 *M*（它变为 *Z*）时，我们已经到达字母表的末尾。为了能够编码 *N*，我们会重新回到 *A*。*O*
    会变成 *B*，一直到 *Z*，它会变成 *M*。这里有一个凯撒密码查找表的示例，使用密钥值 `13`，每个字母都会按13个字母进行编码或解码：
- en: '![A Caesar cipher](httpatomoreillycomsourcenostarchimages2188913.png.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![凯撒密码](httpatomoreillycomsourcenostarchimages2188913.png.jpg)'
- en: Figure 5-7. A Caesar cipher
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7. 凯撒密码
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice a pattern? The letter *A* is encoded as an *N*, and *N* is encoded as
    an *A*. We call this a *symmetric cipher* or *symmetric code* because it has *symmetry*—it’s
    the same in both directions. We can encode and decode messages using the same
    key of `13` because the English alphabet has 26 letters, and the key value of
    `13` means that we shift every letter exactly halfway around. You can try it with
    a message of your own: `HELLO -> URYYB -> HELLO`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到一个模式了吗？字母 *A* 被编码为 *N*，而 *N* 被编码为 *A*。我们称这为 *对称密码* 或 *对称码*，因为它具有 *对称性*——它在两个方向上是相同的。我们可以使用相同的密钥
    `13` 来编码和解码消息，因为英语字母表有26个字母，密钥值 `13` 意味着我们将每个字母正好偏移一半。你可以尝试用你自己的消息：`HELLO -> URYYB
    -> HELLO`。
- en: If we can write a program that looks at each letter in a secret message, then
    encodes that letter by shifting it 13 letters to the right, we can send encoded
    messages to anyone who has the same program (or who can figure out the pattern
    in the cipher). To write a program that manipulates individual letters in a string,
    we need to pick up more skills for working with strings in Python.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能写一个程序，逐个查看秘密消息中的每个字母，然后通过将其向右偏移13个字母来编码该字母，那么我们就能将编码后的消息发送给拥有相同程序的人（或能够破解密码模式的人）。为了编写一个操作字符串中单个字母的程序，我们需要掌握更多处理字符串的技能。
- en: Messin’ with Strings
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操控字符串
- en: Python comes with powerful functions for working with strings. There are built-in
    functions that can change a string of characters to all uppercase, functions that
    can change single characters into their number equivalents, and functions that
    can tell us whether a single character is a letter, number, or other symbol.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了强大的字符串处理函数。有内建函数可以将字符组成的字符串转换为全大写字母，函数可以将单个字符转换为其数字等价物，还有函数可以告诉我们一个字符是否是字母、数字或其他符号。
- en: 'Let’s start with a function to change a string to uppercase letters. To make
    our encoder/decoder program easier to understand, we’re going to change the message
    to all uppercase so that we’re encoding only one set of 26 letters (*A* to *Z*)
    instead of two (*A* to *Z* and *a* to *z*). The function that converts a string
    to all uppercase letters is `upper()`. Any string followed by the dot (`.`) and
    the function name `upper()` will return the same string with letters in uppercase
    and other characters unchanged. In the Python shell, try typing your name or any
    other string in quotes, followed by `.upper()`, to see this function in action:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个将字符串转换为大写字母的函数开始。为了让我们的编码器/解码器程序更容易理解，我们将把消息转换为全大写字母，这样我们只需编码一组26个字母（*A*
    到 *Z*），而不是两组（*A* 到 *Z* 和 *a* 到 *z*）。将字符串转换为全大写字母的函数是 `upper()`。任何后跟点（`.`）和函数名
    `upper()` 的字符串都将返回相同的字符串，字母变为大写，其他字符保持不变。在 Python shell 中，尝试输入你的名字或任何其他字符串并加上
    `.upper()`，看看这个函数的效果：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we saw earlier, the `lower()` function does the opposite:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，`lower()` 函数执行的是相反的操作：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can check to see whether a single character is an uppercase letter with
    the `isupper()` function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `isupper()` 函数检查一个字符是否是大写字母：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And you can check whether a character is a lowercase letter with the `islower()`
    function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `islower()` 函数检查一个字符是否是小写字母：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A string is a collection of characters, so looping through a string in Python
    with a `for` loop will break the string into individual characters. Here, `letter`
    will loop through each character in the string variable `message`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是字符的集合，因此在 Python 中使用 `for` 循环遍历字符串会将字符串拆分为单个字符。这里，`letter` 将循环遍历字符串变量 `message`
    中的每个字符：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we can use the regular addition operator `+` (plus) to add strings
    together or add letters onto a string:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用常规的加法运算符 `+`（加号）将字符串连接起来，或将字母添加到字符串中：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we add the second string onto the end of the first. Adding strings together
    is called *appending*. You may also see string addition referred to as [*concatenation*](apd.html#gloss01_013);
    just remember that’s a fancy word for adding two or more strings together.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将第二个字符串附加到第一个字符串的末尾。将字符串连接在一起称为 *附加*。你可能还会看到字符串加法被称为 [*连接*](apd.html#gloss01_013)；只需记住，这是将两个或更多字符串相加的高级术语。
- en: The Value of Character(s)
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符的值
- en: The final tool we need to build our encoder/decoder program is the ability to
    perform math on individual letters, like adding 13 to the value of the letter
    *A* to get the letter *N*. Python has a function or two that can help.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建编码器/解码器程序所需的最终工具是能够对单个字母进行数学运算，例如将字母 *A* 的值加 13 得到字母 *N*。Python 有一个或两个可以帮助实现这一功能的函数。
- en: Every letter, number, and symbol is turned into a number value when stored on
    a computer. One of the most popular numbering systems is *ASCII (American Standard
    Code for Information Interchange)*. [Table 5-3](ch05.html#numeric_values_for_standard_ascii_charac
    "Table 5-3. Numeric Values for Standard ASCII Characters") shows the ASCII values
    of some keyboard characters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字母、数字和符号在计算机存储时都会转换为数字值。最流行的数字系统之一是 *ASCII（美国信息交换标准代码）*。 [表 5-3](ch05.html#numeric_values_for_standard_ascii_charac
    "表 5-3：标准 ASCII 字符的数字值") 显示了某些键盘字符的 ASCII 值。
- en: Table 5-3. Numeric Values for Standard ASCII Characters
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-3：标准 ASCII 字符的数字值
- en: '| Value | Symbol | Description |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 符号 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 32 |   | Space |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 32 |   | 空格 |'
- en: '| 33 | `!` | Exclamation mark |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 33 | `!` | 感叹号 |'
- en: '| 34 | `"` | Double quote |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 34 | `"` | 双引号 |'
- en: '| 35 | `#` | Hash mark |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 35 | `#` | 井号 |'
- en: '| 36 | `$` | Dollar sign |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 36 | `$` | 美元符号 |'
- en: '| 37 | `%` | Percent |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 37 | `%` | 百分号 |'
- en: '| 38 | `&` | Ampersand |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 38 | `&` | 和号 |'
- en: '| 39 | `''` | Single quote, apostrophe |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 39 | `''` | 单引号、撇号 |'
- en: '| 40 | `(` | Opening parenthesis |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 40 | `(` | 左括号 |'
- en: '| 41 | `)` | Closing parenthesis |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 41 | `)` | 右括号 |'
- en: '| 42 | `*` | Asterisk |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 42 | `*` | 星号 |'
- en: '| 43 | `+` | Plus |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 43 | `+` | 加号 |'
- en: '| 44 | `,` | Comma |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 44 | `,` | 逗号 |'
- en: '| 45 | `-` | Hyphen |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 45 | `-` | 连字符 |'
- en: '| 46 | `.` | Period, dot, full stop |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 46 | `.` | 句号、点、圆点 |'
- en: '| 47 | `/` | Slash or divide |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 47 | `/` | 斜杠或除号 |'
- en: '| 48 | `0` | Zero |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 48 | `0` | 零 |'
- en: '| 49 | `1` | One |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 49 | `1` | 一 |'
- en: '| 50 | `2` | Two |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 50 | `2` | 二 |'
- en: '| 51 | `3` | Three |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 51 | `3` | 三 |'
- en: '| 52 | `4` | Four |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 52 | `4` | 四 |'
- en: '| 53 | `5` | Five |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 53 | `5` | 五 |'
- en: '| 54 | `6` | Six |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 54 | `6` | 六 |'
- en: '| 55 | `7` | Seven |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 55 | `7` | 七 |'
- en: '| 56 | `8` | Eight |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 56 | `8` | 八 |'
- en: '| 57 | `9` | Nine |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 57 | `9` | 九 |'
- en: '| 58 | `:` | Colon |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 58 | `:` | 冒号 |'
- en: '| 59 | `;` | Semicolon |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 59 | `;` | 分号 |'
- en: '| 60 | `<` | Less than |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 60 | `<` | 小于 |'
- en: '| 61 | `=` | Equals |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 61 | `=` | 等号 |'
- en: '| 62 | `>` | Greater than |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 62 | `>` | 大于 |'
- en: '| 63 | `?` | Question mark |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 63 | `?` | 问号 |'
- en: '| 64 | `@` | At symbol |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 64 | `@` | @ 符号 |'
- en: '| 65 | `A` | Uppercase A |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 65 | `A` | 大写字母 A |'
- en: '| 66 | `B` | Uppercase B |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 66 | `B` | 大写字母 B |'
- en: '| 67 | `C` | Uppercase C |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 67 | `C` | 大写字母 C |'
- en: '| 68 | `D` | Uppercase D |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 68 | `D` | 大写字母 D |'
- en: '| 69 | `E` | Uppercase E |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 69 | `E` | 大写字母 E |'
- en: '| 70 | `F` | Uppercase F |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 70 | `F` | 大写字母 F |'
- en: '| 71 | `G` | Uppercase G |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 71 | `G` | 大写字母 G |'
- en: '| 72 | `H` | Uppercase H |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 72 | `H` | 大写字母 H |'
- en: '| 73 | `I` | Uppercase I |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 73 | `I` | 大写字母 I |'
- en: '| 74 | `J` | Uppercase J |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 74 | `J` | 大写字母 J |'
- en: '| 75 | `K` | Uppercase K |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 75 | `K` | 大写字母 K |'
- en: '| 76 | `L` | Uppercase L |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 76 | `L` | 大写字母 L |'
- en: '| 77 | `M` | Uppercase M |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 77 | `M` | 大写字母 M |'
- en: '| 78 | `N` | Uppercase N |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 78 | `N` | 大写字母 N |'
- en: '| 79 | `O` | Uppercase O |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 79 | `O` | 大写字母 O |'
- en: '| 80 | `P` | Uppercase P |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 80 | `P` | 大写字母 P |'
- en: '| 81 | `Q` | Uppercase Q |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 81 | `Q` | 大写字母 Q |'
- en: '| 82 | `R` | Uppercase R |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 82 | `R` | 大写字母 R |'
- en: '| 83 | `S` | Uppercase S |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 83 | `S` | 大写字母 S |'
- en: '| 84 | `T` | Uppercase T |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 84 | `T` | 大写字母 T |'
- en: '| 85 | `U` | Uppercase U |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 85 | `U` | 大写字母 U |'
- en: '| 86 | `V` | Uppercase V |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 86 | `V` | 大写字母 V |'
- en: '| 87 | `W` | Uppercase W |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 87 | `W` | 大写字母 W |'
- en: '| 88 | `X` | Uppercase X |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 88 | `X` | 大写字母 X |'
- en: '| 89 | `Y` | Uppercase Y |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 89 | `Y` | 大写字母 Y |'
- en: '| 90 | `Z` | Uppercase Z |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 90 | `Z` | 大写字母 Z |'
- en: '| 91 | `[` | Opening bracket |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 91 | `[` | 左括号 |'
- en: '| 92 | `\` | Backslash |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 92 | `\` | 反斜杠 |'
- en: '| 93 | `]` | Closing bracket |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 93 | `]` | 右括号 |'
- en: '| 94 | `^` | Caret, circumflex |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 94 | `^` | 插入符号、抑扬符号 |'
- en: '| 95 | `_` | Underscore |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 95 | `_` | 下划线 |'
- en: '| 96 | `` ` `` | Grave accent |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 96 | `` ` `` | 重音符号 |'
- en: '| 97 | `a` | Lowercase a |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 97 | `a` | 小写字母 a |'
- en: 'The Python function to turn a character into its ASCII number value is `ord()`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符转换为其 ASCII 数字值的 Python 函数是 `ord()`：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The reverse function is `chr()`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 反向函数是 `chr()`：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function turns a numeric value into the corresponding character.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将数字值转换为相应的字符。
- en: Our Encoder/Decoder Program
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的编码器/解码器程序
- en: With all these pieces, we can put together a program that takes in a message
    and makes it all uppercase. It then loops through each character in the message
    and, if the character is a letter, shifts it by 13 to encode or decode it, adds
    the letter to an output message, and prints the output message.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些部分，我们可以组成一个程序，它接收一条消息并将其全部转换为大写。然后，它会遍历消息中的每个字符，如果字符是字母，则将其按13个字符偏移来编码或解码，最后将字母添加到输出消息中，并打印输出消息。
- en: EncoderDecoder.py
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EncoderDecoder.py
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first line prompts the user for an input message to encode or decode. At
    ➊, the `upper()` function makes the message all uppercase to make the letters
    easier for the program to read and to make the encoding simpler to write. At ➋,
    we create an empty string (nothing between the double quotes, `""`) named `output`,
    in which we’ll store our encoded message, letter by letter. The `for` loop at
    ➌ makes use of the fact that Python treats strings like collections of characters;
    the variable `letter` will iterate over, or loop through, the string `message`
    one character at a time.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行提示用户输入要编码或解码的消息。在➊处，`upper()`函数将消息转换为全大写，以便程序更容易读取字母，并简化编码的编写。在➋处，我们创建一个空字符串（双引号之间没有任何内容，`""`），命名为`output`，我们将在其中逐个字母存储编码后的消息。➌处的`for`循环利用了Python将字符串视为字符集合的特性；变量`letter`将遍历字符串`message`中的每个字符，一次一个。
- en: At ➍, the `isupper()` function checks each character in the message to see if
    it’s an uppercase letter (`A` to `Z)`. If it is, then at ➎ we get the numeric
    value of the letter in ASCII using `ord()` and add 13 to that value to encode
    it. At ➏, we turn the new, encoded value back into a character with `chr()`, and
    at ➐, we check to see if it’s still a letter from `A` to `Z`. If not, we wrap
    the letter back around to the front of the alphabet at ➑ by subtracting 26 from
    the encoded value (that’s how `Z` becomes an `M`), and we turn the new value into
    its letter equivalent in ➒.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在➍处，`isupper()`函数检查消息中的每个字符，看看它是否是大写字母（`A`到`Z`）。如果是，在➎处我们通过`ord()`获取该字母的ASCII数值，并加上13来进行编码。在➏处，我们通过`chr()`将新的编码值转回字符，而在➐处，我们检查它是否仍然是`A`到`Z`的字母。如果不是，我们在➑处通过从编码值中减去26将字母循环回字母表的前面（这就是`Z`变成`M`的方式），然后在➒处将新的值转为其字母对应的字符。
- en: At ➓, we add the letter to the end of the `output` string (appending the character
    onto the end of the string) using the `+=` operator. The `+=` operator is one
    of a handful of shortcut operators that combine math (`+`) and assignment (`=`),
    and `output += letter` means `output` gets `letter` added to it. This is the last
    line in our `for` loop, so the whole process is repeated for each character in
    the input message until `output` has been built up one letter at a time to hold
    the encoded version of the entire message. When the loop is finished, the last
    line of the program prints the output message.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在➓处，我们使用`+=`运算符将字母添加到`output`字符串的末尾（将字符附加到字符串末尾）。`+=`运算符是结合数学运算（`+`）和赋值（`=`）的快捷运算符之一，`output
    += letter`意味着将`letter`添加到`output`中。这是`for`循环中的最后一行，所以这个过程会对输入消息中的每个字符重复，直到`output`被逐个字母构建为整个消息的编码版本。循环完成后，程序的最后一行会打印输出消息。
- en: You can use this program to send coded messages for fun, but you should know
    that it’s not as secure as modern ways of encoding messages—anyone who can solve
    a puzzle in the Sunday paper can read the encoded messages you’ve sent—so use
    it only for fun with friends.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个程序发送编码消息来娱乐，但你应该知道，它并不像现代的消息编码方法那样安全——任何能解开星期日报纸谜题的人都能读懂你发送的编码消息——因此只应在和朋友玩乐时使用。
- en: Do a web search for *encryption* or *cryptography* to learn about the science
    of making secret messages secure.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络搜索*加密*或*密码学*，了解如何让秘密消息更安全的科学原理。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188915.png.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2188915.png.jpg)'
- en: What You Learned
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: In this chapter, you learned how to program a computer to make decisions based
    on conditions in code. We saw that the `if` statement lets a program execute a
    set of statements only if a condition is true (like `age >= 16`). We used Boolean
    (true/false) expressions to represent the conditions we wanted to check for, and
    we built expressions using conditional operators like `<`, `>`, `<=`, and more.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何编程让计算机根据代码中的条件做出决策。我们看到，`if`语句让程序只在条件为真时执行一系列语句（比如`age >= 16`）。我们使用布尔值（真/假）表达式来表示我们想检查的条件，并使用条件运算符如`<`、`>`、`<=`等来构建表达式。
- en: We combined `if` and `else` statements to run one piece of code or the other,
    so that if our `if` statement is not executed, the `else` statement runs. We extended
    this further by selecting among multiple options using `if-elif-else` statements,
    like in our letter grade program that gave out grades of A, B, C, D, or F depending
    on the numeric score entered.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`if`和`else`语句组合在一起，以便在`if`语句不执行时执行`else`语句。我们进一步扩展了这一点，通过使用`if-elif-else`语句从多个选项中选择，如在我们的成绩程序中，根据输入的数字分数给出A、B、C、D或F的成绩。
- en: We learned how to test multiple conditions at the same time using the `and`
    and `or` logical operators to combine conditions (like `rainy == 'y' and cold
    == 'y'`). We used the `not` operator to check whether a variable or expression
    is `False`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何使用`and`和`or`逻辑运算符同时测试多个条件来组合条件（如`rainy == 'y' and cold == 'y'`）。我们使用`not`运算符来检查一个变量或表达式是否为`False`。
- en: In our secret message program at the end of the chapter, you learned that all
    letters and characters are converted into numeric values when stored on a computer
    and that ASCII is one method of storing text as number values. We used the `chr()`
    and `ord()` functions to convert characters into their ASCII values and back again.
    We changed strings of letters to all uppercase or lowercase with `upper()` and
    `lower()`, and we checked whether a string was uppercase or lowercase with `isupper()`
    and `islower()`. We built a string by adding letters one at a time onto the end
    of the string using the `+` operator, and we learned that adding strings together
    is sometimes called *appending* or *concatenating*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾的秘密信息程序中，你学到了所有字母和字符在计算机中存储时都会转换为数值，并且ASCII是一种将文本存储为数字值的方法。我们使用了`chr()`和`ord()`函数来转换字符为其ASCII值并反向转换。我们使用`upper()`和`lower()`将字母串转换为全大写或全小写，并使用`isupper()`和`islower()`检查字符串是否为大写或小写。我们通过使用`+`运算符将字母逐个添加到字符串末尾，构建了一个字符串，并且学到了将字符串连接起来有时被称为*附加*或*连接*。
- en: 'At this point you should be able to do the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你应该能够做到以下几点：
- en: Use `if` statements to make decisions using conditionals.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if`语句根据条件做出决策。
- en: Use conditionals and Boolean expressions to control program flow.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件语句和布尔表达式来控制程序流程。
- en: Describe how a Boolean expression evaluates to `True` or `False`.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述布尔表达式如何评估为`True`或`False`。
- en: Write conditional expressions using comparison operators (`<`, `>`, `==`, `!=`,
    `<=`, `>=`).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用比较运算符（`<`、`>`、`==`、`!=`、`<=`、`>=`）编写条件表达式。
- en: Use `if-else` statement combinations to choose between two alternative program
    paths.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if-else`语句组合来选择两条不同的程序路径。
- en: Test a variable to see if it is odd or even using the modulo operator, `%`.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模运算符`%`测试一个变量是否为奇数或偶数。
- en: Write `if-elif-else` statements that select from among a number of options.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写`if-elif-else`语句，从多个选项中进行选择。
- en: Use `and` and `or` to test multiple conditions at once.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`and`和`or`一次测试多个条件。
- en: Use the `not` operator to check whether a value or variable is `False`.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`not`运算符检查一个值或变量是否为`False`。
- en: Explain how letters and other characters are stored as numeric values in computers.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释字母和其他字符如何在计算机中存储为数值。
- en: Use `ord()` and `chr()` to convert characters into their ASCII equivalents and
    vice versa.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ord()`和`chr()`将字符转换为其ASCII等价物，并进行反向转换。
- en: Manipulate strings using various string functions like `lower()`, `upper()`,
    and `isupper()`.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种字符串函数（如`lower()`、`upper()`和`isupper()`）操作字符串。
- en: Add strings and characters together using the `+` operator.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`+`运算符将字符串和字符连接在一起。
- en: Programming Challenges
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 编程挑战
- en: To practice what you’ve learned in this chapter, try these challenges. (If you
    get stuck, go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    for sample answers.)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习你在本章中学到的内容，尝试这些挑战。（如果遇到困难，可以访问* [http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    获取示例答案。）
- en: '**#1: COLORFUL ROSETTES AND SPIRALS**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1: 彩色花环和螺旋**'
- en: For a more visual challenge, look back at the colorful spiral and rosette image
    in [Figure 5-1](ch05.html#spiral_of_rosettes_and_smaller_spiralsco "Figure 5-1. A
    spiral of rosettes and smaller spirals, courtesy of an if statement"). You should
    be able to modify [RosettesAndPolygons.py](ch05.html#rosettesandpolygonsdotpy
    "RosettesAndPolygons.py") to make it more colorful and, if you like, replace the
    polygons with small spirals to match the illustration in [Figure 5-1](ch05.html#spiral_of_rosettes_and_smaller_spiralsco
    "Figure 5-1. A spiral of rosettes and smaller spirals, courtesy of an if statement").
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更具视觉挑战性的任务，回顾[图5-1](ch05.html#spiral_of_rosettes_and_smaller_spiralsco "图5-1：彩色的螺旋和小型罗塞塔图案，感谢if语句")中的彩色螺旋和罗塞塔图案图像。你应该能够修改[RosettesAndPolygons.py](ch05.html#rosettesandpolygonsdotpy
    "RosettesAndPolygons.py")，使其更加多彩，并且如果你愿意，可以用小型螺旋替换多边形，以匹配[图5-1](ch05.html#spiral_of_rosettes_and_smaller_spiralsco
    "图5-1：彩色的螺旋和小型罗塞塔图案，感谢if语句")中的插图。
- en: '**#2: USER-DEFINED KEYS**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**#2: 用户定义的密钥**'
- en: For a more text-based challenge, create an advanced version of our *EncoderDecoder.py*
    program by allowing the user to input their own key value, from 1 to 25, to determine
    how many letters to shift the message by. Then, at the line marked ➎ in *EncoderDecoder.py*
    ([Our Encoder/Decoder Program](ch05.html#our_encodersolidusdecoder_program "Our
    Encoder/Decoder Program")), instead of shifting by 13 every time, shift by the
    user’s key value.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更具文本挑战性的任务，可以通过允许用户输入自己的密钥值（1到25之间的数值）来创建我们*EncoderDecoder.py*程序的高级版本，以确定消息需要位移多少字母。然后，在*EncoderDecoder.py*中标记为➎的那一行（[我们的编码/解码程序](ch05.html#our_encodersolidusdecoder_program
    "我们的编码/解码程序")），不再每次位移13，而是根据用户提供的密钥值进行位移。
- en: To decode a message sent with a different key (let’s use `5` as a key value,
    so *A* becomes *F*, *B* becomes *G*, and so on), the person receiving the message
    needs to know the key. They retrieve the message by encoding again with the reverse
    key (26 minus the key value, 26 – 5 = 21) so that *F* wraps around to *A*, *G*
    becomes *B*, and so on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解码使用不同密钥发送的消息（假设我们使用`5`作为密钥值，那么*A*变为*F*，*B*变为*G*，依此类推），接收消息的人需要知道密钥。他们通过再次使用反向密钥（26减去密钥值，即26
    - 5 = 21）来恢复消息，这样*F*就会回绕到*A*，*G*变为*B*，依此类推。
- en: If you’d like to make this program easier to use, start by asking the user whether
    they’d like to encode or decode (`e` or `d`) and then ask them for a key value
    that you store as `key` (the number of letters to shift by). If the user chooses
    to encode, add the key value to each letter at ➎, but if they choose to decode,
    add `26 - key` to each letter. Send this program to a friend and message away!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使这个程序更易于使用，可以首先询问用户他们是否希望编码还是解码（输入`e`或`d`），然后询问他们输入一个密钥值并将其存储为`key`（即字母位移的数量）。如果用户选择编码，就在➎处将密钥值加到每个字母上；如果选择解码，则将`26
    - key`加到每个字母上。将这个程序发送给朋友，开始消息发送吧！
