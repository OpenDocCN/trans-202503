- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 10 LISTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous chapters we explored algorithms that perform several generic
    tasks, and in this chapter we’ll study data structures for specific objectives,
    beginning with the most basic one: a list of elements. Lists are quite simple,
    but the concepts behind lists appear in many other structures, as you’ll learn
    in the rest of the book. In fact, lists are at the center of the most antiquated
    language still widely in use: the acronym for LISP, created in 1959, stands for
    “list processing.”'
  prefs: []
  type: TYPE_NORMAL
- en: What’s a *list*? A simple definition is that a list is a sequence of elements
    (or values, or nodes), which implies that there’s a first element and that every
    element (except the last) is followed by another element. Another definition,
    recursive in nature, is that a list is either empty (no elements) or formed by
    a specific element, called the head of the list, which is followed by the tail—which
    is another list.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by defining the basic abstract data type (ADT) for lists and how
    to implement it in a couple of ways. (See [Table 10-1](chapter10.xhtml#tab10-1)
    for all operations.) It happens, however, that the ADT has some more important
    variants, so we’ll also consider those, which will lead to implementing other
    structures like stacks, queues, deques, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-1: Basic Operations on Lists'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Signature | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | → L | Create a new list. |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | L → boolean | Determine whether the list is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| Size | L → number | Count how many elements are in the list. |'
  prefs: []
  type: TYPE_TB
- en: '| Add | L × position x value → L | Add a value to the list at a certain position.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | L × position → L | Remove a value from the list at a certain position.
    |'
  prefs: []
  type: TYPE_TB
- en: '| At | L × position → value &#124; undefined | Given a position, return the
    value at that position. |'
  prefs: []
  type: TYPE_TB
- en: '| Find | L × value → boolean | Given a value, find whether it exists in the
    list. |'
  prefs: []
  type: TYPE_TB
- en: For some types of lists, such as stacks, queues, or deques, we’ll substitute
    some of the functions in [Table 10-2](chapter10.xhtml#tab10-2) (possibly with
    different names) for the add, remove, and at operations. We may also drop some
    other operations, but we’ll consider them case by case. For instance, instead
    of adding an element at any place in the list, we may want to restrict ourselves
    to adding new elements only at the front or at the back of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-2: Extra Operations on Lists'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Signature | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Add at front | L × value → L | Add a new value at the front of the list.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Add at back | L × value → L | Add a new value at the back of the list. |'
  prefs: []
  type: TYPE_TB
- en: '| Remove from front | L → value &#124; undefined | Remove a value from the
    front of the list. |'
  prefs: []
  type: TYPE_TB
- en: '| Remove from back | L → value &#124; undefined | Remove a value from the back
    of the list. |'
  prefs: []
  type: TYPE_TB
- en: '| At front | L → value &#124; undefined | Get the value at the front of the
    list. |'
  prefs: []
  type: TYPE_TB
- en: '| At back | L → value &#124; undefined | Get the value at the back of the list.
    |'
  prefs: []
  type: TYPE_TB
- en: Finally, we’ll also be able to use lists to represent other ADTs, such as sets
    or maps (see [Chapter 11](chapter11.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: Basic Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with the most basic implementation of a list, which may be good
    enough for many applications, and then move on to a dynamic memory version, which
    is able to deal with more complex situations and structures.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Implementing Lists with Arrays'
  prefs: []
  type: TYPE_NORMAL
- en: Given that JavaScript implements *dynamic arrays*, which can grow larger or
    become smaller as needed, using arrays for lists seems logical, and for most applications
    that’s the case. However, expanding an array often requires moving the whole array
    to a new, larger space in memory, so operations may not be as instant. (The inner
    details of how JavaScript allocates space for arrays isn’t clear, but if you keep
    adding elements, at some point, JavaScript will run out of space and have to allocate
    more space somewhere else and move the array there.) Obviously, with small, short
    lists, you won’t be able to perceive the impact, but for large structures, it
    could become noticeable.
  prefs: []
  type: TYPE_NORMAL
- en: You can implement all the operations for the ADT in a minimum number of lines,
    taking advantage of available JavaScript methods as follows. create was renamed
    newList to make its function clearer, and Empty? was renamed isEmpty because of
    JavaScript naming rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new list ❶ is just a matter of producing an empty array. The list
    size is the array’s length ❷, and to check whether a list is empty, test whether
    its size is 0 ❸. Adding an element at a given position ❹ is tailor-made for the
    splice(...) standard method, which is also used to remove an element ❺. Finally,
    accessing the element at a given position ❻ is trivial. (The latest version of
    JavaScript provides an .at(...) method, which is somewhat different from what
    is defined here because of the possibility of using negative indices; see *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at)*.)
    Finally, use the .includes(...) method to see whether a list includes the value
    ❼.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10-3](chapter10.xhtml#tab10-3) shows the performance of these operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-3: Performance of Operations for Array-Based Lists'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Size | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(n) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(n) |'
  prefs: []
  type: TYPE_TB
- en: '| At | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Find | O(n) |'
  prefs: []
  type: TYPE_TB
- en: Creating a new list, checking whether it’s empty, getting its size, and accessing
    the element at a given position are all *O*(1) operations. As expected, finding
    a value is *O*(*n*), because the operation needs to go through the whole list.
    On the other hand, adding and removing elements are *O*(*n*) operations, because
    they basically move the whole array to a different place in memory. If you implement
    lists dynamically, these results will change.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Lists with Dynamic Memory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Languages that support dynamic memory provide a different way to deal with
    varying-length lists: through pointers. You can include a reference to an object
    in another object along the lines of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Given only the pointer to the first object, you can list the next object’s name
    with first.next.name, for example; then first.next.next.name would list the third
    object’s name. All of this is standard JavaScript notation. The last object has
    its next attribute with a null value, meaning there’s no next object in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-1](chapter10.xhtml#fig10-1) represents pointers with arrows and
    a null pointer with a line ending in a circle. Of course, you’re not limited to
    having a single pointer in a node; you can have as many as you want. Let’s start
    with a simple case: an example of a list with six elements is shown in [Figure
    10-1](chapter10.xhtml#fig10-1), where first points to the head.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: A simple list'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new element requires changing a pointer. For instance, [Figure 10-2](chapter10.xhtml#fig10-2)
    shows adding an 80 after the 60.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-2: Adding a new element to the list requires changing only a single
    pointer in a node.'
  prefs: []
  type: TYPE_NORMAL
- en: The same result occurs when removing an element; you need to change only a single
    pointer—usually the one from the previous element, or first itself if removing
    the head of the list. In the next example, let’s remove the 60 (see [Figure 10-3](chapter10.xhtml#fig10-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-3: Removing an element from the list also requires just changing
    a single pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing elements by themselves are *O*(1) operations. (Of course,
    this assumes you already know where to effect the changes and also what other
    element points to the one you wanted to remove.) Let’s consider functioning code
    for all the possible operations.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Creating a List'
  prefs: []
  type: TYPE_NORMAL
- en: 'A list is just an object, which may have a link to another object, and so on.
    An empty list is a null pointer. With that in mind, creating a new, empty list
    is simple, and so is checking whether you have an empty list or calculating a
    list’s size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a list produces a null pointer that eventually points to the list’s
    head ❶. Checking whether a list is empty ❷ means seeing whether the pointer is
    null. Finally, calculating the list’s size is simple with recursion: an empty
    list has a size of 0, and a nonempty list has a size of 1 (for the list’s head)
    plus whatever the list’s tail size is ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To figure the list’s nodes, use objects with a value (a key or whatever you
    want to add to the list) and a pointer (ptr) to the following element in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The add(...) recursive function gets a pointer to a list and the position in
    which to add the new value. If the pointer is null or if the position is zero
    ❶, the new node goes at the beginning of the list ❷, pointing to whatever was
    the first element of the list earlier. Otherwise, go down the list recursively
    to the next node ❸. After the new value is added, return a pointer to the updated
    list ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To remove an element from a list, you have two options: remove the first element
    (in which case the pointer to the first element of the list must be changed) or
    remove another element in the list (and then modify the pointer in the previous
    node as mentioned earlier). The following code does all of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If the list is null, just return it ❶; you can’t do anything else. If it’s not
    null and you want to remove its head, the new list is the list’s tail ❷. Finally,
    if the list isn’t null and you don’t want to remove its head, advance to the next
    place in the list to attempt the removal again ❸, but now the position to remove
    is one less than before. In all cases return a pointer to the list after the removal.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the Value at a Position
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can get the value at a given position in a naturally recursive way by considering
    several cases. If the list is null, it has no value to return, so you’ll return
    undefined. If the list isn’t empty and the position you asked for is 0, you want
    the first element of the list. If the list isn’t empty and you want some element
    further down the list, advance by one position and apply recursion. The following
    code does exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic closely follows the three cases: checking for an empty list ❶, testing
    for the head of the list ❷, and using recursion to advance down the list ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for a Value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Finally, you can search a list to see whether it includes a given value. This
    operation isn’t as common, but you’ll do it anyway to gain more experience with
    this structure. The general logic is similar to at(...) in the example you just
    saw. Assume you have a ptr pointer to an element of the list. If the pointer is
    null, the value isn’t in the list. Otherwise, if the object ptr points to has
    the value you want, you’ve found it. If the value isn’t what you want, keep searching
    from the next node onward. Here’s the recursive logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the list is empty, ❶ return false. Otherwise, if the head of the list is
    the value you want ❷, return true. If it isn’t what you want, search the list’s
    tail. (Note that you’re grouping the two tests together by using JavaScript’s
    || operator.)
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Dynamic Memory Lists
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To wrap up this discussion of dynamic memory lists, let’s analyze their performance
    (see [Table 10-4](chapter10.xhtml#tab10-4)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-4: Performance of Operations for Dynamic Memory Lists'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Size | O(n) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(n) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(n) |'
  prefs: []
  type: TYPE_TB
- en: '| At | O(n) |'
  prefs: []
  type: TYPE_TB
- en: '| Find | O(n) |'
  prefs: []
  type: TYPE_TB
- en: As with the array-based implementation, creating a new list and checking whether
    it’s empty are both *O*(1) operations, but all other operations become *O*(*n*)!
    This difference suggests that simply implementing arrays with pointers, as was
    shown earlier, isn’t the best solution. However, some varieties of lists that
    have a more specific set of operations suited to their particular requirements
    achieve better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Varieties of Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For some tasks, a more specialized ADT is needed than the basic ADT and implementation
    for common lists that you explored in the previous section. Specifically, we’ll
    consider stacks, queues, deques, and circular lists, including their specific
    operations and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *stack* is a last-in, first-out (LIFO) data structure, similar to an actual
    physical stack of plates: imagine you can add a plate only to the top of the pile
    or remove only the top plate; adding or removing middle plates isn’t allowed.
    Stacks behave in the same way. You’ll add and remove only at the top, and these
    operations are usually known as *push* and *pop*, respectively. You’ll also want
    to check whether a stack is empty (as with common lists) and learn the value at
    the top. (Sometimes the pop operation is defined to return the updated stack and
    also what the top value is. In that case you wouldn’t need an operation to get
    the top value of the stack, since you could just pop it, use it, and push it again.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10-5](chapter10.xhtml#tab10-5) sums up the operations you’ll need, and
    as mentioned previously, you’re dealing with a smaller, more specific set of operations
    here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-5: Operations on Stacks'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Signature | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | → S | Create a new stack. |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | S → boolean | Determine whether the stack is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| Push | S × value → S | Add a value at the top of the stack. |'
  prefs: []
  type: TYPE_TB
- en: '| Pop | S → S | Remove the value at the top of the stack. |'
  prefs: []
  type: TYPE_TB
- en: '| Top | S → value | Get the value at the top of the stack. |'
  prefs: []
  type: TYPE_TB
- en: 'Stacks are frequently used in applications. For example, to explore how to
    implement a recursive depth-first process in an iterative fashion by using a stack,
    check out question 13.3 in [Chapter 13](chapter13.xhtml). One uncommon place where
    you’ll find a stack is in Hewlett-Packard calculators that provide reverse Polish
    notation (RPN): you push numbers into a stack, and then operations pop them, do
    whatever calculation you asked, and push the result back in.'
  prefs: []
  type: TYPE_NORMAL
- en: Stacks are also used in programming languages like FORTH or WebAssembly (WASM),
    as well as page description languages like PostScript. Central processing units
    (CPUs) use stacks for subroutine calls and interruptions. If code is executing
    and an interruption comes in, the current status is pushed into a stack, and the
    interruption is processed; afterward, the normal execution resumes after popping
    the status from the stack. (Obviously, you could have a new interruption while
    processing an old one. In that case, the status for the first interruption is
    also pushed, then the second interruption is processed, and when finished, the
    status for the first interruption is popped to continue processing it.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, JavaScript itself implements a stack for calls. Whenever a function
    calls itself, it’s as if the current status and variables were pushed into a stack
    before starting the recursive call. When returning from a recursive call, the
    old status is popped from the stack and execution recommences from where it stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Implementing a stack with an array is simple given that you can directly use
    .pop(...) and .push(...)(see question 10.5). Working with linked memory is also
    simple, and you’ll base the code on the functions you wrote for lists. In this
    structure you’ll have a pointer to the first element, the one at the top of the
    stack, and each element will have a .next pointer to the element “below” it. The
    “bottom” element will have a null pointer. [Figure 10-4](chapter10.xhtml#fig10-4)
    shows how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-4: A stack implemented with dynamic memory'
  prefs: []
  type: TYPE_NORMAL
- en: Pushing a new value onto a nonempty stack just requires adding a new object
    that points to the old top element and changing the top pointer (see [Figure 10-5](chapter10.xhtml#fig10-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-5: Pushing a new element on top of a stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'Popping the top element is even simpler: adjust the top pointer to point to
    the next one, as shown in [Figure 10-6](chapter10.xhtml#fig10-6).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-6: Popping the top element from a stack'
  prefs: []
  type: TYPE_NORMAL
- en: In both cases (pushing and popping), you need to make simple changes to the
    logic when dealing with an empty stack.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A stack is a list, so creating a stack is exactly the same as creating a generic
    list, as shown in the previous section; just change the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the top requires a single line of code (all other operations on stacks
    are also one-liners):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For an empty stack, just return undefined; otherwise, stack points to the top
    element, so stack.value is what you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pushing a value means you’ll have a new element on top, which points to the
    element that was previously at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This logic also works if the stack is empty. Can you see why?
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, popping the top of the stack is also quick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the stack is empty, return it as is. You also could easily change the code,
    for example, to throw an error. For a nonempty stack, just return the tail of
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Performance for Dynamic Memory–Based Stacks'
  prefs: []
  type: TYPE_NORMAL
- en: When considering how this stack implementation performs, the results are much
    better than with common lists (see [Table 10-6](chapter10.xhtml#tab10-6)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-6: Performance of Operations for Dynamic Memory–Based Stacks'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Push | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Pop | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Top | O(1) |'
  prefs: []
  type: TYPE_TB
- en: 'All operations require constant time, and that’s optimal. Implementing stacks
    with arrays, the results would *almost* be the same with an exception: pushing
    a new value could require moving the array to a new, larger place in memory, and
    that would make pushing a value an *O*(*n*) operation. In comparison to implementing
    common lists, which brought higher costs for most operations, implementing stacks
    with dynamic memory is just as good, and in a single case, even better. Now consider
    other variations on lists that provide similar results.'
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Queues* are another variant of lists, and they are a first-in, first-out (FIFO)
    data structure. Queues work the same as a line of people waiting for something.
    New people enter the queue at the back (nobody may cut in), and the person at
    the front will exit the queue next. These two operations are *enter* and *exit*
    (or *enqueue* and *dequeue*), and they mimic what happens in real queues. You’ll
    also want to check whether a queue is empty and be able to get the value of the
    front of the queue. [Table 10-7](chapter10.xhtml#tab10-7) shows the operations
    you’ll need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-7: Operations on Queues'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Signature | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | → Q | Create a new queue. |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | Q → boolean | Determine whether the queue is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| Enter | Q × value → Q | Add a value at the back of the queue. |'
  prefs: []
  type: TYPE_TB
- en: '| Exit | Q → Q | Remove the value at the front of the queue. |'
  prefs: []
  type: TYPE_TB
- en: '| Front | Q → value | Get the value at the front of the queue. |'
  prefs: []
  type: TYPE_TB
- en: An alternative that’s sometimes used is that the *exit* operation returns both
    the updated queue and the value that was removed from the queue, but that’s not
    needed given the *front* operation. You could also have a *rear* operation to
    access the value at the end of the queue, but that’s not common.
  prefs: []
  type: TYPE_NORMAL
- en: Queues are frequently used in situations where things don’t have to be (or cannot
    be) processed immediately and should be attended to in order such as printer queues
    or call center phone systems that keep you on hold until a representative is free.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Implementing a queue is quite simple using arrays. With linked memory, you need
    pointers to the first and the last nodes of the queue, so you’ll represent a queue
    with an object that has first and last links. Each element in the queue has a
    next pointer to the following element, as shown in [Figure 10-7](chapter10.xhtml#fig10-7).
    (The next element is actually in the previous place in the queue, so prev could
    also be the name of the pointer.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-7: A queue implemented with dynamic memory'
  prefs: []
  type: TYPE_NORMAL
- en: The first element in the queue (the next to exit) is 22; the following is 9\.
    The last place in the queue is a 56\. Adding a new element at the back of the
    queue simply requires modifying the pointer to the last element and the pointer
    in the last element itself (see [Figure 10-8](chapter10.xhtml#fig10-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-8: Adding an element at the back of a queue'
  prefs: []
  type: TYPE_NORMAL
- en: After adding 80, the previous last element, 56, now points to the 80, and so
    does the last pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the element from the front of the queue is exactly the same as with
    stacks, as shown in [Figure 10-9](chapter10.xhtml#fig10-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-9: Removing an element from the front of a queue'
  prefs: []
  type: TYPE_NORMAL
- en: You just have to make the first point at whatever the previous first element
    pointed at. Now you’ll see how to implement all of this.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Creating a new queue and checking whether it’s empty is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The queue is represented by an object with two pointers ❶ that are initially
    null. You can tell that the queue is empty ❷ if one of those pointers is null;
    in fact, either both or none will be null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the value at the front (first in line) is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the queue is empty, return undefined; otherwise, queue.first points at the
    first element of the queue, and you return its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entering a queue at the last place is a short function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the queue was empty ❶, make the first and last pointers point to a new object,
    with a null pointer to the next node in the queue. Otherwise, make the last element
    point to a new one ❷, and then make last point to it too ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, exiting the queue is the same as with stacks, but with a special case
    when the queue becomes empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the queue isn’t empty ❶, you just have to make the first pointer ❷ point
    to the next element in the queue, but if the queue was emptied ❸, you also have
    to fix the last pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Performance for Dynamic Memory–Based Queues
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Given the similarity of queues and stacks (the only difference is that pop removes
    the first element of the stack, but exit removes the last element of the queue),
    it’s no surprise that performance is the same, as shown in [Table 10-8](chapter10.xhtml#tab10-8).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-8: Performance of Operations for Dynamic Memory–Based Queues'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Enter | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Exit | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Front | O(1) |'
  prefs: []
  type: TYPE_TB
- en: Again, all operations require constant time; using an array wouldn’t be as good
    (see question 10.9).
  prefs: []
  type: TYPE_NORMAL
- en: Deques
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next variation on lists doesn’t really have very many applications (stacks
    and queues are far more common), but their implementation introduces the interesting
    concept of double (forward and backward) linking. Assume a queue where entering
    or exiting is allowed at both ends. (Think of a train with several cars; new cars
    can be added only at the ends, and cars can be removed only from the ends.) This
    type of list is called a *deque* (pronounced like “deck”), which stands for “double-ended
    queue.”
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10-9](chapter10.xhtml#tab10-9) shows operations necessary for deques.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-9: Operations on Deques'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Signature | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | → D | Create a new deque. |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | D → boolean | Determine whether deque is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| Enter at front | D × value → D | Add a value at the front of the deque. |'
  prefs: []
  type: TYPE_TB
- en: '| Enter at back | D × value → D | Add a value at the back of the deque. |'
  prefs: []
  type: TYPE_TB
- en: '| Exit from front | D → D | Remove the value at the front of the deque. |'
  prefs: []
  type: TYPE_TB
- en: '| Exit from back | D → D | Remove the value at the back of the deque. |'
  prefs: []
  type: TYPE_TB
- en: '| Front | D → value | Get the value at the front of the deque. |'
  prefs: []
  type: TYPE_TB
- en: '| Back | D → value | Get the value at the back of the deque. |'
  prefs: []
  type: TYPE_TB
- en: Basically a deque is the same as a queue, except that you enter at or exit from
    both ends. Similarly, you also need operations to get the values at both extremes;
    for queues, you looked at only the first (front) item.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Is it possible to implement deques with linked memory? Since you now have full
    symmetry for all operations, you need links that go in both directions. [Figure
    10-10](chapter10.xhtml#fig10-10) shows how it works: if you were to drop all left-pointing
    links (or all right-pointing links), you’d be left with a common queue. In this
    structure, you’ll again have first and last pointers to the extremes of the deque,
    and each node will have next and prev (previous) pointers to the contiguous nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-10: Implementing a deque requires two pointers at each node.'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the symmetry, operations on one end are totally analogous to the
    same operation at the other end, so let’s just work at the end of the deque (see
    [Figure 10-11](chapter10.xhtml#fig10-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-11: Adding an element at one extreme of a deque'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a value at the end is the same as for a queue, with the addition that
    the newly added node must point to the node that was previously at the end of
    the deque. (Working at the other end is exactly the same, so we’ll skip it.)
  prefs: []
  type: TYPE_NORMAL
- en: Removing an element from the end of the deque is the same as shown in [Figure
    10-11](chapter10.xhtml#fig10-11), but from the bottom up; see [Figure 10-12](chapter10.xhtml#fig10-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-12: Removing an element from one extreme of a deque'
  prefs: []
  type: TYPE_NORMAL
- en: When removing a value from the back, modify the corresponding pointer (last)
    and the next pointer of the new extreme of the deque; working at the other extreme
    entails modifying first and a prev pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Deletions are simple in doubly linked lists. If you have a pointer to some element
    and want to remove it (say, the 60 in the list shown in [Figure 10-13](chapter10.xhtml#fig10-13)),
    doing so is easy.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-13: Removing an element somewhere in a deque'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key is that all nodes have pointers to both neighbors, so you have to do
    something along the lines of the following code, assuming that ptr points to the
    node to be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This kind of pointer work is common, but it can be jarring the first time you
    see it, so it merits careful study. The code works for elements in the middle
    of the deque. For elements at both ends, you need to make minor changes, as well
    as adjust at least one of (and possibly both) the first and last elements. Even
    if you don’t ever use deques, the concept of double links and the ease of extracting
    any element from the middle is the key takeaway from this section. You’ll use
    this for circular lists later in this chapter and in future chapters as well.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Creating a deque and checking whether it’s empty are exactly the same as with
    a queue, since you have the same first and last pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a new element to a deque is the same as entering a queue; the only difference
    is that you can add it at either extreme, subtly changing what pointers you modify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You use an auxiliary function to create a new node with its pair of pointers
    ❶. Entering at the front requires changing both first and last if the deque is
    empty ❷. Otherwise, use the same kind of pointer work as for queues ❸. The code
    for entering a deque at the back is exactly the same, in symmetrical fashion:
    just change last to first and prev to next ❹.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, removing an element from the front or back of a deque is the same
    as exiting from a queue; both algorithms are symmetrical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If the deque is empty ❶, there’s nothing to do. Otherwise, to remove the front
    element, advance to the next element of the deque ❷, and if that element is null
    ❸, you also adjust the last element. A bit of symmetry produces exactly the same
    “remove last” operation ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Performance for Dynamic Memory–Based Deques
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A deque is essentially a queue that goes both ways: half of its operations
    are exactly the same as for queues, and the rest are symmetrical, but with the
    same style of code, so the results are not unexpected (see [Table 10-10](chapter10.xhtml#tab10-10)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-10: Performance of Operations for Dynamic Memory–Based Deques'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Enter at front (or at back) | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Exit from front (or from back) | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Front (or back) | O(1) |'
  prefs: []
  type: TYPE_TB
- en: All the operations of deques perform the same as those of queues. Everything
    is *O*(1).
  prefs: []
  type: TYPE_NORMAL
- en: Circular Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Circular lists are useful for “round-robin”–style processing. For example, PCs
    place apps in a list and cycle through them, and after the last completes, processing
    returns to the first. (You’ll see another example of this when looking at Fibonacci
    heaps in [Chapter 15](chapter15.xhtml).) Instead of an open-ended list, a circular
    list joins the first and last elements together. This kind of ADT allows for continuous
    processing, with a “current” element and the possibility of advancing to the next,
    but cyclically. [Table 10-11](chapter10.xhtml#tab10-11) shows the operations we’ll
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-11: Operations on Circular Lists'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Signature | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | → C | Create a new circular list. |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | C → boolean | Determine whether the circular list is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| Add | C × value → C | Add a new value before the current one and make it
    current. |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | C → C | Remove the current value from the list and advance. |'
  prefs: []
  type: TYPE_TB
- en: '| Current | C → value | Get the current value from the circular list. |'
  prefs: []
  type: TYPE_TB
- en: '| Advance | C → C | Advance to the next value in the list cyclically. |'
  prefs: []
  type: TYPE_TB
- en: Some variations and changes are possible. You could require a “go back” (retreat)
    operation that performs in the opposite direction as an “advance.” You could also
    use an “add after current,” but you could achieve that by first advancing and
    then using the add operation. These changes aren’t significant, and the structure
    is useful as shown. The work you did with deques, however, will help in implementing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Circular lists can be singly or doubly linked, but the latter is the most useful
    version. Basically, you just want a list that has no first or last element. Instead,
    the elements form a circle, and you’ll have a pointer to the element that’s being
    processed currently. [Figure 10-14](chapter10.xhtml#fig10-14) shows such a list;
    the nodes have next and prev pointers, as with deques.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-14: A circular list also needs two pointers at every node.'
  prefs: []
  type: TYPE_NORMAL
- en: The “advance to the next” operation simply requires following the next link
    (see [Figure 10-15](chapter10.xhtml#fig10-15)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-15: Moving along the list is possible in both directions.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new element before the current one is also a matter of dealing with
    several pointers (see [Figure 10-16](chapter10.xhtml#fig10-16)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-16: Adding an element to a circular list is done by changing a few
    pointers.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing the current element requires some juggling with pointers, but as with
    deques, having links in both directions makes it easy (see [Figure 10-17](chapter10.xhtml#fig10-17)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure10-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-17: Removing an element from a circular list also requires just a
    few pointer changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Operations in a circular list require essentially the same kind of logic that
    you’ve already explored. Now consider an actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Creating a circular list is the same as for common lists, and so is testing
    whether such a list is empty. The only difference is the naming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In a stack, you had a pointer to the top element. Here you have a pointer to
    some element in the list, the current one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a new node merely involves more work with pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If the list is empty, it consists of a single node ❶ whose next and prev links
    point to itself. Otherwise, the new node is between the nodes that circ (the current
    node) and circ.prev (the previous one) point to. Fix the four involved pointers
    so that the new node lies in its correct place ❷. At the end, return the new node
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing the current element is a tad shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You have three distinct cases to consider. If the circular list is empty, do
    nothing ❶. If the list consists of a single element (and in that case both its
    next and prev links point to itself), return a new, empty list ❷. Finally, if
    the list isn’t empty, make the nodes at circ.prev and circ.next (the ones that
    surround the current node) point to each other ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, getting the current value and advancing to the next one are both one-liners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The current element of an empty list is just undefined ❶; otherwise, circ.value
    gives its value. Advancing the current element to the next position, for a nonempty
    circular list, is just a matter of going to the next node ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Performance for Circular Lists
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Checking all the implemented functions, none of them require loops or recursion,
    so as with other data structures in this chapter, the performance is constant
    (see [Table 10-12](chapter10.xhtml#tab10-12)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 10-12: Performance of Operations for Circular Lists'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Current | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Advance | O(1) |'
  prefs: []
  type: TYPE_TB
- en: 'You could use arrays, of course, but the performance for some operations, such
    as adding a new value, would suffer because of the possible need to move the whole
    array to a new place in memory: *O*(*n*).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter we examined several linear structures and a circular one that
    are based on linked memory, and you’ll have the opportunity to reuse them in later
    chapters. Linked memory is key for all the dynamic structures we’ll explore in
    this book, and in upcoming chapters, we’ll work with more complex structures to
    enable better performance for more complex operations.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**10.1  Iterating Through Lists**'
  prefs: []
  type: TYPE_NORMAL
- en: All the examples in the “Implementing Lists with Dynamic Memory” section on
    [page 180](chapter10.xhtml#pg_180) were written using recursion, but they are
    often coded in iterative fashion. Can you rewrite them in that way?
  prefs: []
  type: TYPE_NORMAL
- en: '**10.2  Going the Other Way**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a reverse(list) algorithm that given a list will reverse it, meaning
    the first element becomes the last, the second element the next to last, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.3  Joining Forces**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement an append(list1, list2) function that given two lists will append
    the second one to the first one.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4  Unloop the Loop**'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are given a list that may or may not have a loop; in other words,
    instead of eventually finishing with a null pointer, there may be an element that
    points back to some previous element, so the list has a loop. Can you write a
    hasALoop(list) function that given a list will determine whether it has a loop?
    Your solution should use constant extra memory; don’t assume anything about the
    length of the list, because it may be incredibly long.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.5  Arrays for Stacks**'
  prefs: []
  type: TYPE_NORMAL
- en: Since JavaScript provides operations on arrays like .pop(...) and .push(...),
    implementing a stack with an array should be pretty straightforward. Can you write
    appropriate code?
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6  Stack Printing**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you write code that prints out a stack’s contents in top-to-bottom order?
    Could you print it in reverse (bottom-to-top) order?
  prefs: []
  type: TYPE_NORMAL
- en: '**10.7  Height of a Stack**'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you need to know how many elements are in a stack. How could you implement
    this?
  prefs: []
  type: TYPE_NORMAL
- en: '**10.8  Maximum Stack**'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that you need a stack for some process, but you also need to know, after
    each push or pop, the maximum value in the stack. How can you implement this efficiently
    without having to go through the whole stack every time?
  prefs: []
  type: TYPE_NORMAL
- en: '**10.9  Queued Arrays**'
  prefs: []
  type: TYPE_NORMAL
- en: In a previous question, you saw that JavaScript provided operations that made
    it simple to emulate a stack with arrays. Is the same true for queues? How would
    you emulate queues with arrays? What would the performance of such an implementation
    be?
  prefs: []
  type: TYPE_NORMAL
- en: '**10.10  Queue Length**'
  prefs: []
  type: TYPE_NORMAL
- en: Write a function that given a queue will count how many values are in it; in
    other words, find the queue’s length.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.11  Queueing for Sorting**'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](chapter6.xhtml) you implemented radix sort with arrays, but using
    queues and linked memory is more efficient. Can you rewrite the algorithm accordingly?
  prefs: []
  type: TYPE_NORMAL
- en: '**10.12  Stacked Queues**'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you needed to use a queue for some program, but all you had was
    a library that implemented stacks. With some trickery, you can simulate a queue
    by using a pair of stacks; can you see how? (You’ll explore this strategy in [Chapter
    18](chapter18.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: '**10.13  Palindrome Detection**'
  prefs: []
  type: TYPE_NORMAL
- en: 'How could you use a deque to decide whether a string is a palindrome? Palindromes
    are words that can be read the same way forward or backward, like “Hannah” or
    “radar,” or ignoring spaces and punctuation “Step on no pets” or “A man, a plan,
    a canal: Panama.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.14  Circular Listing**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a function to list all the contents of a circular list; take care
    not to go into a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.15  Joining Circles**'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you have two circular lists. How could you join them into a single,
    larger list? For simplicity, assume neither of the lists is empty.
  prefs: []
  type: TYPE_NORMAL
