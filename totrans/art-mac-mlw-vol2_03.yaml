- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 2 PARSING BINARIES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 解析二进制文件
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In the previous chapter, we enumerated running processes and extracted information
    that could help us heuristically detect malware. However, we didn’t cover how
    to examine the actual binary that backed each process. This chapter describes
    how to programmatically parse and analyze universal and Mach-O, the native executable
    binary file format of macOS.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们枚举了正在运行的进程，并提取了可以帮助我们启发式地检测恶意软件的信息。然而，我们并未讨论如何检查每个进程背后的实际二进制文件。本章将介绍如何以编程方式解析和分析通用二进制文件和Mach-O文件，后者是macOS的本地可执行二进制文件格式。
- en: You’ll learn how to extract information such as a binary’s dependencies and
    symbols, as well as detect whether the binary contains anomalies, such as encrypted
    data or instructions. This information will improve your ability to classify a
    binary as malicious or benign.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何提取二进制文件的依赖关系和符号信息，以及检测二进制文件是否包含异常，例如加密数据或指令。这些信息将提高你对二进制文件进行恶意或良性分类的能力。
- en: Universal Binaries
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用二进制文件
- en: The majority of Mach-O binaries are distributed in universal binaries. Called
    *fat binaries* in Apple parlance, these are containers for multiple architecture-specific
    (but generally logically equivalent) Mach-O binaries known as *slices*. At runtime,
    the macOS dynamic loader (*dyld*) will load and then execute whichever embedded
    Mach-O binary best matches the host’s native architecture (for example, Intel
    or ARM). Because these embedded binaries hold the information you’re looking to
    extract, such as dependencies, you must first understand how to programmatically
    parse the universal binary.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Mach-O二进制文件以通用二进制文件的形式分发。在Apple的术语中，这些被称为*fat二进制文件*，它们是多个特定架构（但通常逻辑上等价）的Mach-O二进制文件的容器，称为*slices*。在运行时，macOS的动态加载器（*dyld*）会加载并执行最适合主机本地架构（例如Intel或ARM）的嵌入式Mach-O二进制文件。由于这些嵌入式二进制文件包含你需要提取的信息，例如依赖关系，你必须首先了解如何以编程方式解析通用二进制文件。
- en: Inspecting
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查
- en: 'Apple’s file utility can inspect universal binaries. For example, the CloudMensis
    malware is distributed as a universal binary named *WindowServer* containing two
    Mach-O binaries: one compiled for Intel x86_64 and one for Apple Silicon ARM64
    systems. Let’s execute file against CloudMensis. As you can see, the tool identifies
    it as a universal binary and shows its two embedded Mach-Os:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Apple的文件工具可以检查通用二进制文件。例如，CloudMensis恶意软件作为名为*WindowServer*的通用二进制文件分发，包含两个Mach-O二进制文件：一个为Intel
    x86_64编译，另一个为Apple Silicon ARM64系统编译。让我们对CloudMensis执行file命令。正如你所看到的，该工具将其识别为通用二进制文件，并显示其包含的两个嵌入式Mach-O文件：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To programmatically access these embedded binaries, we have to parse the universal
    binary’s header, which contains the offset of each Mach-O. Luckily, parsing the
    header is straightforward. Universal binaries start with a fat_header structure.
    We can find relevant universal structures and constants in Apple’s SDK *mach-o/fat.h*
    header file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要以编程方式访问这些嵌入式二进制文件，我们必须解析通用二进制文件的头部，其中包含每个Mach-O文件的偏移量。幸运的是，解析头部是直接的。通用二进制文件以fat_header结构开头。我们可以在Apple的SDK
    *mach-o/fat.h*头文件中找到相关的通用结构和常量：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Apple’s comments in this header file indicate that magic, the first member of
    the fat_header structure (an unsigned 32-bit integer), will contain the constant
    FAT_MAGIC or FAT_MAGIC_64. The use of FAT_MAGIC_64 means the next structures are
    of the type fat_arch_64, used when the following slice or offset to it is greater
    than 4GB.^([1](#chapter2-1)) Comments in Apple’s *fat.h* header files note that
    support for this extended format is a work in progress, and universal binaries
    are rarely, if ever, so massive, so we’ll focus on the traditional fat_arch structure
    in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Apple在此头文件中的注释表明，fat_header结构的第一个成员magic（一个无符号32位整数）将包含常量FAT_MAGIC或FAT_MAGIC_64。使用FAT_MAGIC_64意味着接下来的结构是fat_arch_64类型，当随后的切片或偏移量大于4GB时使用该类型。^([1](#chapter2-1))
    Apple的*fat.h*头文件中的注释指出，扩展格式的支持仍在进行中，通用二进制文件通常不那么庞大，因此本章将重点讨论传统的fat_arch结构。
- en: Not mentioned in the fat_header structure’s comments is the fact that the values
    in the structure are assumed to be big-endian, a vestige of the OSX PPC days.
    Therefore, on little-endian systems such as Intel and Apple Silicon, when you
    read a universal binary into memory, values such as the 4 bytes for magic will
    appear in reverse-byte order.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在fat_header结构的注释中没有提到的一点是，该结构中的值假定为大端字节序，这是OSX PPC时代的遗留物。因此，在Intel和Apple Silicon等小端系统上，当你将通用二进制文件读取到内存中时，像magic的4个字节这样的值将以反字节顺序出现。
- en: 'Apple accounts for this fact by providing the “swapped” magic constant FAT_CIGAM.
    (Yes, CIGAM is just magic backward.) The hexadecimal value of this constant is
    0xbebafeca.^([2](#chapter2-2)) We can see this value by using xxd to dump the
    bytes at the start of the CloudMensis universal binary. On a little-endian host,
    we make use of the -e flag to display the hexadecimal values in little-endian:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果通过提供“交换”后的魔术常量 FAT_CIGAM 来考虑这一事实。（是的，CIGAM 只是反向的魔术。）该常量的十六进制值为 0xbebafeca。^([2](#chapter2-2))
    我们可以通过使用 xxd 命令来转储 CloudMensis 通用二进制文件开头的字节。对于小端主机，我们使用 -e 标志来显示小端格式的十六进制值：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output, when interpreted as a 4-byte value, will have the host’s endianness
    applied, which explains why we see the swapped universal magic value FAT_CIGAM
    (0xbebafeca).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当将输出解释为 4 字节值时，主机的字节序会被应用，这解释了为什么我们看到交换后的通用魔术值 FAT_CIGAM（0xbebafeca）。
- en: Following the magic field in the fat_header structure, we find the nfat_arch
    field, which specifies the number of fat_arch structures. We’ll find one fat_arch
    structure for each architecture-specific Mach-O binary embedded in the universal
    binary. As illustrated in [Figure 2-1](chapter2.xhtml#fig2-1), these structures
    immediately follow the fat header.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 fat_header 结构中的魔术字段之后，我们找到了 nfat_arch 字段，该字段指定了 fat_arch 结构的数量。对于每个嵌入在通用二进制文件中的特定架构的
    Mach-O 二进制文件，我们会找到一个 fat_arch 结构。如[图 2-1](chapter2.xhtml#fig2-1)所示，这些结构紧随 fat_header
    之后。
- en: '![](../images/Figure2-1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-1.jpg)'
- en: 'Figure 2-1: The layout of a universal binary'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：通用二进制文件的布局
- en: 'Because file showed that CloudMensis contained two embedded Mach-Os, we’d expect
    to see nfat_arch set to 2. We confirm that this is the case by using xxd once
    again. This time, though, we skip the -e flag so as to keep the values in big
    endian:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件显示 CloudMensis 包含了两个嵌入的 Mach-O 文件，我们预计会看到 nfat_arch 设置为 2。我们通过再次使用 xxd 来确认这一点。不过这次，我们跳过了
    -e 标志，以保持大端格式的值：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can find the fat_arch structure definition in the *fat.h* header file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *fat.h* 头文件中找到 fat_arch 结构的定义：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first two members of the fat_arch structure specify the CPU type and subtype
    of the Mach-O binary, while the next two specify the offset and size of this slice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: fat_arch 结构的前两个成员指定了 Mach-O 二进制文件的 CPU 类型和子类型，而接下来的两个成员指定了该切片的偏移量和大小。
- en: Parsing
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析
- en: 'Let’s programmatically parse a universal binary and locate each embedded Mach-O
    binary. We’ll show two methods of doing so: using the older NX* APIs compatible
    with older versions of macOS and the newer Macho* APIs available on macOS 13 and
    newer.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编程解析一个通用二进制文件并定位每个嵌入的 Mach-O 二进制文件。我们将展示两种方法：使用兼容旧版本 macOS 的老旧 NX* APIs
    和适用于 macOS 13 及更高版本的新 Macho* APIs。
- en: NOTE
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can find the code mentioned in this chapter in the* parseBinary *project
    in the book’s GitHub repository at* [https://github.com/Objective-see/TAOMM*.*](https://github.com/Objective-see/TAOMM)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在本章提到的代码中找到* parseBinary *项目，该项目位于本书 GitHub 仓库的* [https://github.com/Objective-see/TAOMM*.*](https://github.com/Objective-see/TAOMM)'
- en: NX* APIs
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: NX* APIs
- en: We’ll begin by checking whether the file is indeed a universal binary. Then
    we’ll iterate over all fat_arch structures, printing out their values, and leverage
    the NXFindBestFatArch API to find the embedded binary most compatible with the
    host’s architecture. The system will load and execute this binary when the universal
    binary is launched, so it’s the one we’ll focus on in our analysis.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先检查文件是否确实是一个通用二进制文件。然后我们将遍历所有的 fat_arch 结构，打印出它们的值，并利用 NXFindBestFatArch
    API 查找与主机架构最兼容的嵌入式二进制文件。当启动通用二进制文件时，系统将加载并执行这个二进制文件，因此我们会将其作为分析的重点。
- en: Your own code may instead want to examine each embedded Mach-O binary, especially
    as nothing stops a developer from making these binaries completely different.
    Although you’ll rarely find this to be the case, the 2023 3CX supply chain attack
    provides one notable exception. To trojanize the 3CX application, attackers subverted
    a legitimate universal binary that contained both Intel and ARM binaries, adding
    malicious code to the former and leaving the ARM binary untouched.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码可能会希望检查每个嵌入的 Mach-O 二进制文件，尤其是没有什么能阻止开发者将这些二进制文件完全不同。虽然这种情况很少见，但 2023 年的
    3CX 供应链攻击就是一个显著的例外。为了对 3CX 应用程序进行木马化，攻击者破坏了一个合法的通用二进制文件，该文件同时包含了 Intel 和 ARM 二进制文件，攻击者在前者中加入了恶意代码，而保持
    ARM 二进制文件不变。
- en: Let’s start by loading a file and performing some initial checks ([Listing 2-1](chapter2.xhtml#Lis2-1)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从加载一个文件并执行一些初步检查开始（[Listing 2-1](chapter2.xhtml#Lis2-1)）。
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 2-1: Loading, validating, and finding the “best” slice of a universal
    binary'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-1：加载、验证并找到通用二进制文件的“最佳”切片
- en: After reading the contents of the file into memory ❶ and typecasting the initial
    bytes to a struct fat_header * ❷, the code checks that it is indeed a universal
    binary ❸. Note that it checks both the big-endian (FAT_MAGIC) and little-endian
    (FAT_CIGAM) versions of the magic value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在将文件内容读取到内存 ❶ 并将初始字节类型转换为 struct fat_header * ❷ 后，代码会检查它是否确实是一个通用二进制文件 ❸。注意，它会检查大端（FAT_MAGIC）和小端（FAT_CIGAM）版本的魔数值。
- en: To keep things simple, this code doesn’t support the large fat file format.
    Moreover, for production code, you should perform other sanity checks, such as
    ensuring that the file was successfully loaded and that it’s bigger than the size
    of a fat_header structure.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，这段代码不支持大型 fat 文件格式。此外，对于生产环境代码，你还应该执行其他合理性检查，比如确保文件已成功加载，并且文件大于 fat_header
    结构的大小。
- en: The parsing logic lives in a helper function named parseFat, which you can see
    invoked in [Listing 2-1](chapter2.xhtml#Lis2-1). After printing out the fat header,
    this function will iterate over each fat_arch structure and return the most compatible
    Mach-O slice.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 解析逻辑在一个名为 parseFat 的辅助函数中，你可以在 [列表 2-1](chapter2.xhtml#Lis2-1) 中看到该函数的调用。打印出
    fat 头部后，该函数将迭代每个 fat_arch 结构并返回最兼容的 Mach-O 切片。
- en: First, though, we must deal with any differences in endianness. The values in
    the fat_header and fat_arch structures are always in big-endian order, so on little-endian
    systems such as Intel and Apple Silicon, we must swap them. To do so, we first
    invoke the NXGetLocalArchInfo API to determine the host’s underlying byte order
    ([Listing 2-2](chapter2.xhtml#Lis2-2)). We’ll use the value returned, a pointer
    to an NXArchInfo structure, to swap the endianness (as well as later, to determine
    the most compatible Mach-O).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，首先我们必须处理字节序的差异。fat_header 和 fat_arch 结构中的值总是以大端顺序存储，因此在 Intel 和 Apple Silicon
    等小端系统上，我们必须交换它们。为此，我们首先调用 NXGetLocalArchInfo API 来确定主机的底层字节顺序（[列表 2-2](chapter2.xhtml#Lis2-2)）。我们将使用返回的值，即指向
    NXArchInfo 结构的指针，来交换字节序（以及稍后，用于确定最兼容的 Mach-O）。
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 2-2: Determining the local machine’s architecture'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-2：确定本地机器的架构
- en: You might notice that the NXGetLocalArchInfo and swap_* APIs are marked as deprecated,
    although they’re still available and fully functional at the time of publication.
    You can use replacement macho_* APIs, found in *mach-o/utils.h*, on macOS 13 and
    newer, and you’ll learn about this in the next section. However, until macOS 15,
    one of these new APIs was broken, so you may still want to stick to the older
    APIs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到 NXGetLocalArchInfo 和 swap_* APIs 被标记为已弃用，尽管它们在发布时仍然可用且完全正常工作。你可以在 macOS
    13 及更新版本中使用替代的 macho_* APIs，这些 API 可以在 *mach-o/utils.h* 中找到，下一节将介绍这些内容。然而，直到 macOS
    15，其中一个新的 API 存在问题，因此你可能仍然需要坚持使用旧的 API。
- en: Next, we perform the swap with the swap_fat_header and swap_fat_arch functions
    ([Listing 2-3](chapter2.xhtml#Lis2-3)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 swap_fat_header 和 swap_fat_arch 函数进行交换（[列表 2-3](chapter2.xhtml#Lis2-3)）。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 2-3: Swapping the fat header and fat architecture structures to match
    the host’s byte ordering'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-3：交换 fat 头部和 fat 架构结构，以匹配主机的字节序
- en: The code first checks whether a swap is needed ❶. Recall that if the magic constant
    of the fat header is FAT_CIGAM, the code is executing on a little-endian host,
    so we should perform a swap. By invoking the helper APIs swap_fat_header ❷ and
    swap_fat_arch ❸, the code converts the header and all fat_arch values to match
    the host’s byte ordering, as returned by NXGetLocalArchInfo. The latter API takes
    the number of fat_arch structures to swap, which the code provides via the nfat_arch
    field of the now-swapped fat header.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查是否需要交换 ❶。回想一下，如果 fat 头部的魔数常量是 FAT_CIGAM，说明代码在小端主机上执行，因此我们应该执行交换。通过调用辅助
    API swap_fat_header ❷ 和 swap_fat_arch ❸，代码将头部和所有 fat_arch 值转换为与主机字节序匹配，这一字节序是通过
    NXGetLocalArchInfo 返回的。后者 API 接受要交换的 fat_arch 结构的数量，代码通过已交换的 fat 头部的 nfat_arch
    字段提供这个数量。
- en: Once the header and all fat_arch structures conform to the host’s byte ordering,
    the code can print out details of each embedded Mach-O binary that the fat_arch
    structures describe ([Listing 2-4](chapter2.xhtml#Lis2-4)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦头部和所有 fat_arch 结构符合主机的字节序，代码就可以打印出每个嵌入的 Mach-O 二进制文件的详细信息，这些信息由 fat_arch 结构描述（[列表
    2-4](chapter2.xhtml#Lis2-4)）。
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 2-4: Printing out each fat_arch structure'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-4：打印出每个 fat_arch 结构
- en: The code starts by initializing a pointer to the first fat_arch structure, which
    comes immediately after the fat_header. Then it iterates over each, bounded by
    the nfat_arch member of the fat_header ❶. To print out values from each fat_arch
    structure, the code invokes a helper function we’ve named printFatArch ❷, which
    first separates the CPU subtype and its capabilities, as both are found in the
    cpusubtype member. Apple provides the CPU_SUBTYPE _MASK constant to extract just
    the bits that describe the subtype ❸.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先初始化一个指向第一个fat_arch结构的指针，该结构紧跟在fat_header之后。然后，它遍历每个结构，这些结构由fat_header中的nfat_arch成员界定❶。为了打印出每个fat_arch结构的值，代码调用了一个我们命名为printFatArch的辅助函数❷，该函数首先分离出CPU子类型及其能力，因为这两者都位于cpusubtype成员中。Apple提供了CPU_SUBTYPE_MASK常量来提取描述子类型的位❸。
- en: 'Let’s run this code against CloudMensis. It outputs the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在CloudMensis上运行此代码。它输出以下内容：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From the output, we can see the malware’s two embedded Mach-O binaries:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到恶意软件的两个嵌入式Mach-O二进制文件：
- en: At offset 16384, a binary compatible with CPU_TYPE_X86_64 (0x1000007) that is
    708,560 bytes long
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在偏移量16384处，一个与CPU_TYPE_X86_64（0x1000007）兼容的二进制文件，大小为708,560字节
- en: At offset 737280, a binary compatible with CPU_TYPE_ARM64 (0x100000c) that is
    688,176 bytes long
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在偏移量737280处，一个与CPU_TYPE_ARM64（0x100000c）兼容的二进制文件，大小为688,176字节
- en: 'To confirm the accuracy of this code, we can compare this output against the
    macOS otool command, whose -f flag parses and displays fat headers:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认此代码的准确性，我们可以将此输出与macOS的otool命令进行比较，-f标志可以解析并显示fat头：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the tool’s output, we see the same information about the malware’s two embedded
    binaries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具的输出中，我们看到有关恶意软件两个嵌入式二进制文件的相同信息。
- en: Next, let’s add some code to determine which of the embedded Mach-O binaries
    matches the host’s native architecture. Recall that we already invoked the NXGetLocalArchInfo
    API to retrieve the host architecture. Moreover, we also showed how to compute
    the offset to the first fat_arch structure, which immediately follows the fat
    header. To find the natively compatible Mach-O, we can now invoke the NXFindBestFatArch
    API ([Listing 2-5](chapter2.xhtml#Lis2-5)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一些代码来确定哪个嵌入式Mach-O二进制文件与主机的原生架构匹配。回想一下，我们已经调用了NXGetLocalArchInfo API来获取主机架构。此外，我们还展示了如何计算到第一个fat_arch结构的偏移量，该结构紧随fat头之后。为了找到原生兼容的Mach-O，现在我们可以调用NXFindBestFatArch
    API（[列表2-5](chapter2.xhtml#Lis2-5)）。
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 2-5: Determining a universal binary’s best architecture'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2-5：确定通用二进制文件的最佳架构
- en: We pass the API the host’s architecture, a pointer to the start of the fat _arch
    structures, and the number of these structures. The NXFindBestFatArch API will
    then determine the Mach-O binary from within the universal binary that is the
    most compatible with the host’s native architecture. Recall the parseFat helper
    function returns this value and prints it out.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主机架构、指向fat_arch结构开始的指针以及这些结构的数量传递给API。NXFindBestFatArch API将确定在通用二进制文件中最与主机原生架构兼容的Mach-O二进制文件。回想一下，parseFat辅助函数返回此值并打印出来。
- en: 'If we add this code to the binary parser and then run it again against CloudMensis,
    it outputs the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此代码添加到二进制解析器中，然后再次在CloudMensis上运行，它输出以下内容：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: On an Apple Silicon (ARM64) system, the code has correctly determined that the
    second embedded Mach-O binary, with a CPU type of 16777228/0x100000c (CPU_TYPE_ARM64),
    is the most compatible Mach-O in the universal CloudMensis binary. When launching
    this universal binary, we can use the Kind column in Activity Monitor to confirm
    that macOS indeed selected and ran the Apple Silicon Mach-O ([Figure 2-2](chapter2.xhtml#fig2-2)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Apple Silicon（ARM64）系统上，代码已正确确定第二个嵌入式Mach-O二进制文件，其CPU类型为16777228/0x100000c（CPU_TYPE_ARM64），是通用CloudMensis二进制文件中最兼容的Mach-O。当启动此通用二进制文件时，我们可以使用活动监视器中的“类型”栏来确认macOS确实选择并运行了Apple
    Silicon Mach-O（[图2-2](chapter2.xhtml#fig2-2)）。
- en: '![](../images/Figure2-2.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-2.jpg)'
- en: 'Figure 2-2: The CloudMensis binary WindowServer running as a native Apple Silicon
    binary'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-2：CloudMensis二进制文件WindowServer作为原生Apple Silicon二进制文件运行
- en: 'Another way to confirm that CloudMensis runs as a native Apple Silicon binary
    is to use the *enumerateProcesses* project presented in [Chapter 1](chapter1.xhtml).
    Recall that it extracts the architecture of each running process:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种确认CloudMensis作为原生Apple Silicon二进制运行的方法是使用在[第1章](chapter1.xhtml)中介绍的*enumerateProcesses*项目。回想一下，它提取了每个正在运行的进程的架构：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We receive the same result.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到相同的结果。
- en: Macho* APIs
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Macho* API
- en: In macOS 13, Apple introduced the macho_* APIs. Found in *mach-o/utils.h*, these
    APIs offer a simplified way to iterate over Mach-O binaries in a universal binary
    and select the most compatible one. The deprecated NX* APIs still work for this
    purpose, but if you’re developing tools on macOS 13 or later, it’s wise to instead
    use the newer functions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS 13中，Apple引入了`macho_*` API。这些API位于`mach-o/utils.h`中，提供了一种简化的方式来遍历通用二进制文件中的Mach-O二进制文件，并选择最兼容的一个。已经弃用的NX*
    API仍然可以用于这个目的，但如果你在macOS 13或更高版本上开发工具，建议使用更新的函数。
- en: 'The macho_for_each_slice API lets us extract a universal binary’s Mach-Os without
    having to manually parse the universal header or deal with the nuances of byte
    orderings. We invoke this function with a path to a file and callback block to
    run for each Mach-O slice. If invoked against a stand-alone Mach-O, the function
    will run its callback just once, and if the file isn’t a well- formed universal
    binary or Mach-O, the function will gracefully fail, meaning we don’t have to
    manually verify the file type ourselves. The *mach-o/utils.h* header file includes
    the possible return values and their meanings:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`macho_for_each_slice` API让我们无需手动解析通用头文件或处理字节顺序的细节，就能提取出通用二进制文件中的Mach-O文件。我们通过文件路径和回调块来调用此函数，对每个Mach-O切片执行回调。如果对独立的Mach-O文件调用此函数，回调将只运行一次。如果文件不是格式正确的通用二进制文件或Mach-O文件，函数会优雅地失败，这意味着我们不必手动验证文件类型。`mach-o/utils.h`头文件包含了可能的返回值及其含义：'
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The callback block invoked for each embedded Mach-O has the following type:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个嵌入的Mach-O调用的回调块具有以下类型：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This type might look a little confusing at first, but if we focus solely on
    the parameters, we see that the callback will be invoked with a variety of information
    about the slice, including a pointer to a mach_header structure, the slice’s offset,
    and its size.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型乍一看可能有点令人困惑，但如果我们仅仅关注参数，就会发现回调函数将会被调用，并传递包含切片信息的各种数据，包括指向`mach_header`结构的指针、切片的偏移量以及其大小。
- en: The code in [Listing 2-6](chapter2.xhtml#Lis2-6), part of the parseFat helper
    function, invokes macho_for_each_slice to print out information about each embedded
    Mach-O. It also includes some basic error handling, which we can use to filter
    out files that are neither universal nor Mach-Os.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例2-6](chapter2.xhtml#Lis2-6)中的代码，作为`parseFat`辅助函数的一部分，调用了`macho_for_each_slice`来打印出每个嵌入Mach-O的信息。它还包含了一些基本的错误处理，我们可以用它来过滤掉那些既不是通用文件也不是Mach-O文件的文件。'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 2-6: Iterating over all embedded Mach-Os'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-6：遍历所有嵌入的Mach-O
- en: This code invokes the macho_for_each_slice function ❶. In the callback block,
    we print out a counter variable followed by the slice’s offset and size ❷. We
    also make use of the macho_arch_name_for_mach_header function to print out the
    name of each slice’s architecture ❸.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码调用了`macho_for_each_slice`函数❶。在回调块中，我们打印出一个计数器变量，后跟切片的偏移量和大小❷。我们还利用了`macho_arch_name_for_mach_header`函数来打印出每个切片架构的名称❸。
- en: If the user-specified file isn’t a well-formed universal or Mach-O binary, the
    function will fail. The code handles this, printing out a generic error message,
    as well as additional information for common errors ❹.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户指定的文件不是格式正确的通用或Mach-O二进制文件，函数将失败。代码会处理这个情况，打印出一个通用的错误消息，以及常见错误的额外信息❹。
- en: 'If we add this code to the *parseBinary* project and then run it against the
    CloudMensis universal binary, it should print out the same offset and size values
    for the malware’s two embedded Mach-Os as the code that leveraged the NX* APIs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这段代码添加到`parseBinary`项目中，并运行它来处理CloudMensis的通用二进制文件，它应该输出与利用NX* API的代码相同的偏移量和大小值，用于恶意软件的两个嵌入式Mach-O：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, what about finding the most compatible slice, or the one that the host
    would load and run if the universal binary were executed? The macho _best_slice
    function is designed to return exactly that. It takes a path to a file to inspect
    and a callback block to invoke with the best slice. Add the function in [Listing
    2-7](chapter2.xhtml#Lis2-7) to the previous code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何找到最兼容的切片，或者说，如果执行通用二进制文件时，主机会加载并运行哪个切片呢？`macho_best_slice`函数旨在准确返回这个切片。它接受一个文件路径用于检查，并且在找到最佳切片时会调用一个回调块。将[示例2-7](chapter2.xhtml#Lis2-7)中的函数添加到之前的代码中。
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 2-7: Invoking macho_best_slice to find the best slice'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-7：调用`macho_best_slice`来寻找最佳切片
- en: 'If we run this against CloudMensis (on a version of macOS prior to 15), however,
    it fails with the value 86:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们在CloudMensis（macOS版本低于15）上运行这段代码，它会失败并返回值86：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: According to the *mach-o/utils.h* header file, this error value maps to EBADARCH,
    which means none of the slices can load. This is odd, considering that the NXFindBestFatArch
    function identified the embedded ARM64 Mach-O binary as compatible with my Apple
    Silicon analysis machine. Moreover, this ARM64 Mach-O definitely runs, as you
    saw in [Figure 2-2](chapter2.xhtml#fig2-2). It turns out, as is often the case
    with new APIs from Apple, that the macho_best_slice function was broken until
    macOS 15\. On older versions of macOS, for any third-party universal binary on
    Apple Silicon systems, the function returns EBADARCH.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *mach-o/utils.h* 头文件，这个错误值映射到 EBADARCH，意味着没有任何切片可以加载。这很奇怪，因为 NXFindBestFatArch
    函数识别出嵌入的 ARM64 Mach-O 二进制文件与我的 Apple Silicon 分析机兼容。此外，这个 ARM64 Mach-O 绝对可以运行，正如你在
    [图 2-2](chapter2.xhtml#fig2-2) 中看到的那样。事实证明，正如苹果新 API 经常发生的情况一样，macho_best_slice
    函数在 macOS 15 之前是有问题的。在旧版本的 macOS 上，对于任何在 Apple Silicon 系统上的第三方通用二进制文件，该函数返回 EBADARCH。
- en: 'Reverse engineering, as well as studying the code of *dyld*,^([3](#chapter2-3))
    revealed the cause of the error: instead of passing a list of compatible CPU types
    (such as arm64 or x86_64) to the slice selection function, the code incorrectly
    passed in only the CPU type for which the operating system was compiled. On Apple
    Silicon, this CPU type is arm64e (CPU_SUBTYPE_ARM64E), used exclusively by Apple.
    This explains why the selection logic never chose slices in third-party universal
    binaries, which are compiled as arm64 or x86_64 (but never arm64e), and instead
    returned the EBADARCH error.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程以及研究 *dyld* 的代码，^([3](#chapter2-3)) 揭示了错误的根本原因：代码没有传递一个兼容的 CPU 类型列表（例如 arm64
    或 x86_64）给切片选择函数，而是错误地只传递了操作系统编译时所用的 CPU 类型。在 Apple Silicon 上，这个 CPU 类型是 arm64e（CPU_SUBTYPE_ARM64E），仅被苹果使用。这就解释了为什么选择逻辑从未选择第三方通用二进制文件中的切片，因为这些文件是以
    arm64 或 x86_64 编译的（但从不包含 arm64e），而是直接返回了 EBADARCH 错误。
- en: 'You can read more about the bug in my write-up “Apple Gets an ‘F’ for Slicing
    Apples.”^([4](#chapter2-4)) My analysis proposed a simple fix: instead of invoking
    the GradedArchs::forCurrentOS method, Apple should have invoked GradedArchs::launchCurrentOS
    to obtain the correct list of compatible CPU types. The good news is that Apple
    eventually took this recommendation, meaning that macho_best_slice on macOS 15
    and above works as expected.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我的文章《苹果因切割苹果而得到‘F’评价》中阅读更多关于这个 bug 的内容。^([4](#chapter2-4)) 我的分析提出了一个简单的修复方法：苹果不应该调用
    GradedArchs::forCurrentOS 方法，而应该调用 GradedArchs::launchCurrentOS 来获取正确的兼容 CPU 类型列表。好消息是，苹果最终采纳了这个建议，这意味着在
    macOS 15 及更高版本上，macho_best_slice 按预期工作。
- en: Now that you know how to parse universal binaries, let’s turn our attention
    to the Mach-O binaries embedded within them.^([5](#chapter2-5))
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经知道如何解析通用二进制文件，接下来让我们将注意力转向嵌入其中的 Mach-O 二进制文件。^([5](#chapter2-5))
- en: Mach-O Headers
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mach-O 头部
- en: Mach-O binaries contain the information we’re after, such as dependencies and
    symbols. To programmatically extract these, we must parse the Mach-O’s header.
    In a universal binary, we can locate this header by analyzing the fat header and
    architecture structures, as you saw in the previous section. In a single-architecture,
    stand-alone Mach-O, finding the header is trivial, as it’s located at the start
    of the file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Mach-O 二进制文件包含我们需要的信息，比如依赖关系和符号。为了程序化地提取这些信息，我们必须解析 Mach-O 的头部。在一个通用二进制文件中，我们可以通过分析
    fat 头和架构结构来定位这个头部，就像你在上一节中看到的那样。在一个单架构的独立 Mach-O 文件中，找到头部非常简单，因为它位于文件的开头。
- en: '[Listing 2-8](chapter2.xhtml#Lis2-8) follows the code that identifies the best
    Mach-O within a universal binary. It confirms that the slice is indeed a Mach-O,
    then handles cases in which a file is a stand-alone Mach-O.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-8](chapter2.xhtml#Lis2-8) 跟随代码，识别通用二进制文件中的最佳 Mach-O。它确认该切片确实是一个 Mach-O，然后处理文件是独立
    Mach-O 的情况。'
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 2-8: Finding the relevant Mach-O header'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-8：找到相关的 Mach-O 头部
- en: After loading the file into memory, we typecast the bytes at the start of the
    file to a mach_header_64 structure ❶. If the binary is universal, we find the
    fat_arch structure that describes the most compatible embedded Mach-O. Using this
    structure’s offset member, we update the pointer to point to the embedded binary
    ❷.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 加载文件到内存后，我们将文件开头的字节转换为 mach_header_64 结构体 ❶。如果是通用二进制文件，我们会找到描述最兼容的嵌入式 Mach-O
    的 fat_arch 结构体。使用该结构体的偏移量成员，我们更新指针以指向嵌入的二进制文件 ❷。
- en: 'Before we parse the binary, we must verify that the pointer really points to
    the start of the Mach-O. We take a simple verification approach: checking for
    the presence of a Mach-O magic value ❸. Because the binary’s header and the host
    machine architecture could have different endianness, the code checks for both
    the MH_MAGIC_64 and MH_CIGAM_64 constants, defined in Apple’s *mach-o/loader.h*
    header file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析二进制文件之前，我们必须验证指针确实指向 Mach-O 的开始部分。我们采用一种简单的验证方法：检查 Mach-O 魔术值的存在 ❸。由于二进制文件的头部和主机架构可能具有不同的字节序，代码会检查
    Apple 的 `*mach-o/loader.h*` 头文件中定义的 `MH_MAGIC_64` 和 `MH_CIGAM_64` 常量：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For the sake of simplicity, the code skips recommended sanity and error checks.
    For example, production code should, at the very minimum, ensure that the size
    of the read-in bytes is greater than sizeof(struct mach_header_64) before dereferencing
    offsets in the header.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化代码，示例跳过了推荐的健全性和错误检查。例如，生产环境代码应该至少确保读取的字节大小大于 `sizeof(struct mach_header_64)`，才能在头部解引用偏移量。
- en: NOTE
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Mach-O headers are of type mach_header or mach_header_64. Recent versions
    of macOS support 64-bit code only, so this section focuses on* mach_header_64,
    *defined in* mach-o/loader.h*.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mach-O 头部的类型为 `mach_header` 或 `mach_header_64`。由于最新版本的 macOS 仅支持 64 位代码，因此本节聚焦于*
    `mach_header_64`，*它在* `mach-o/loader.h` *中定义。*'
- en: Now that we’re sure we’re looking at a Mach-O, we can parse it. [Listing 2-9](chapter2.xhtml#Lis2-9)
    defines a helper function named parseMachO for this purpose. It takes a pointer
    to the mach_header_64 structure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确定正在查看 Mach-O 文件，我们可以对其进行解析。[清单 2-9](chapter2.xhtml#Lis2-9) 定义了一个名为 `parseMachO`
    的辅助函数来实现这一目的。它接收指向 `mach_header_64` 结构体的指针。
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 2-9: Swapping the Mach-O header to match the host’s byte ordering'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-9：交换 Mach-O 头部以匹配主机的字节顺序
- en: Because the binary’s header and the host machine could have a different endianness,
    the code first checks for the swapped Mach-O magic value. If you encounter it,
    swap the header via the swap_mach_header_64 API. Note here that the code makes
    use of the macOS NXGetLocalArchInfo function, but if you’re writing code for versions
    of macOS 13 or newer, you should use the more modern macho* APIs (again noting
    that the macho_best_slice function was broken until macOS 15).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二进制文件的头部和主机机器可能具有不同的字节序，代码首先检查交换过的 Mach-O 魔术值。如果遇到它，则通过 `swap_mach_header_64`
    API 交换头部。请注意，这段代码使用了 macOS 的 `NXGetLocalArchInfo` 函数，但如果你为 macOS 13 或更高版本编写代码，应该使用更新的
    macho* API（再次注意，`macho_best_slice` 函数在 macOS 15 之前是有问题的）。
- en: To print out the Mach-O header, we write a helper function, printMachOHeader
    ([Listing 2-10](chapter2.xhtml#Lis2-10)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印出 Mach-O 头部，我们编写了一个辅助函数 `printMachOHeader`（[清单 2-10](chapter2.xhtml#Lis2-10)）。
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 2-10: Printing out a Mach-O header'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-10：打印出 Mach-O 头部
- en: You can find an overview of each header member in the comments of the mach_header_64
    structure definition. For example, following the magic field are the two fields
    that describe the binary’s compatible CPU type and subtype. The cpusubtype member
    also contains the binary’s capabilities, and these can be extracted into their
    own field.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `mach_header_64` 结构体定义的注释中找到每个头部成员的概述。例如，在魔术值字段后面是描述二进制文件兼容的 CPU 类型和子类型的两个字段。`cpusubtype`
    成员还包含二进制文件的能力，这些能力可以提取到它们自己的字段中。
- en: The file type indicates whether the binary is a stand-alone executable or a
    loadable library. The next fields describe the number and size of the binary’s
    load commands, which we’ll make extensive use of shortly. Finally, the flags member
    of the structure indicates additional optional features, such as whether the binary
    is compatible with address space layout randomization.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型表示二进制文件是独立可执行文件还是可加载的库。接下来的字段描述了二进制文件的加载命令的数量和大小，我们稍后将广泛使用这些字段。最后，结构体的 flags
    成员表示附加的可选功能，例如二进制文件是否与地址空间布局随机化兼容。
- en: 'Let’s run the Mach-O parsing code against CloudMensis. After searching the
    universal header, the tool finds the compatible Mach-O header and then prints
    it out:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 Mach-O 解析代码来处理 CloudMensis。在搜索通用头部之后，工具找到了兼容的 Mach-O 头部并将其打印出来：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This output matches that of Apple’s otool, whose -h flag instructs it to print
    out the Mach-O header:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出与 Apple 的 `otool` 相匹配，后者的 `-h` 标志指示其打印出 Mach-O 头部：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running otool with the -v flag converts the returned numerical values into
    symbols:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行带有 `-v` 标志的 `otool` 会将返回的数字值转换为符号：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These values confirm that our tool works as expected.  ### Load Commands'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '这些值确认了我们的工具按预期工作。  ### 加载命令'
- en: 'Load commands are instructions to *dyld* that immediately follow the Mach-O
    header. A header field named ncmds specifies the number of load commands, and
    each command is a structure of type load_command containing the command type (cmd)
    and size (cmdsize), as you can see here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 加载命令是*dyld*的指令，紧随Mach-O头部之后。一个名为ncmds的头部字段指定了加载命令的数量，每个命令都是一个load_command类型的结构，包含命令类型(cmd)和大小(cmdsize)，如下所示：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Some load commands describe the segments in the binary, such as the __TEXT segment
    that contains the binary’s code, while others describe dependencies, the location
    of the symbol table, and more. As such, code that aims to extract information
    found within Mach-Os will generally start by parsing load commands.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些加载命令描述了二进制文件中的段，例如包含二进制代码的__TEXT段，而其他命令则描述了依赖关系、符号表的位置等。因此，旨在提取Mach-O文件中信息的代码通常会从解析加载命令开始。
- en: '[Listing 2-11](chapter2.xhtml#Lis2-11) defines a helper function named findLoadCommand
    for this purpose. It takes a pointer to a Mach-O header and the type of load command
    to find. After locating the start of the load commands, it iterates over each
    to create an array containing commands that match the specified type.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 2-11](chapter2.xhtml#Lis2-11)定义了一个名为findLoadCommand的辅助函数。该函数接受指向Mach-O头部的指针和要查找的加载命令类型。找到加载命令的起始位置后，它会遍历每个命令，创建一个包含匹配指定类型命令的数组。'
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 2-11: Iterating over all load commands and collecting those that match
    a specified type'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-11：遍历所有加载命令，并收集匹配指定类型的命令
- en: We start by calculating a pointer to the first load command, which immediately
    follows the Mach-O header ❶. Then we iterate over all load commands, which appear
    one after another ❷, and check the cmd member of each to see if it matches the
    specified type ❸. As we can’t directly store pointers in an Objective-C array,
    we first create an NSValue object with the load command’s address ❹. Finally,
    we advance to the next load command. Load commands can vary in size, so we use
    the current command’s cmdsize field ❺ to find the next one.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算指向第一个加载命令的指针，该命令紧随Mach-O头部❶之后。然后，我们遍历所有加载命令，它们一个接一个地出现❷，并检查每个命令的cmd成员，看看它是否匹配指定的类型❸。由于我们不能直接将指针存储在Objective-C数组中，因此我们首先创建一个NSValue对象来存储加载命令的地址❹。最后，我们前进到下一个加载命令。加载命令的大小可能不同，因此我们使用当前命令的cmdsize字段❺来找到下一个命令。
- en: 'With an understanding of load commands and a helper function that returns commands
    of interest, let’s now consider a few examples of pertinent information we can
    extract, starting with dependencies.  ### Extracting Dependencies'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '通过理解加载命令和返回感兴趣命令的辅助函数，我们现在可以考虑一些可以提取的相关信息示例，从依赖关系开始。 ### 提取依赖关系'
- en: 'One of the reasons to parse Mach-Os is to extract their *dependencies*: dynamic
    libraries that *dyld* will automatically load. Understanding the dependencies
    of a binary can provide insight into its likely capabilities or even uncover malicious
    dependencies. For example, CloudMensis links against the *DiskArbitration* framework,
    which provides APIs to interact with external disks. Using this framework’s APIs,
    the malware monitors for the insertion of removable USB drives so it can exfiltrate
    external files.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 解析Mach-O文件的原因之一是为了提取其*依赖关系*：*dyld*会自动加载的动态库。理解二进制文件的依赖关系可以帮助我们了解它可能的功能，甚至揭示恶意的依赖关系。例如，CloudMensis链接了*DiskArbitration*框架，该框架提供了与外部磁盘交互的API。通过使用该框架的API，恶意软件监视可移动USB驱动器的插入，以便它可以窃取外部文件。
- en: When writing code, we can often achieve the same outcome in several ways. For
    example, in [Chapter 1](chapter1.xhtml), we extracted all loaded libraries and
    frameworks from a running process by leveraging vmmap. In this chapter, we’ll
    perform a similar task by manually parsing the Mach-O. This static approach will
    extract direct dependencies only, excluding recursion; that is to say, we won’t
    extract the dependencies of dependencies. Moreover, libraries directly loaded
    by the binary at runtime are not dependencies per se and thus will not be extracted.
    While simple, this technique should help us understand the Mach-O’s capabilities
    and doesn’t require executing external binaries like vmmap. Also, the code will
    run against any Mach-O binary without requiring it to be currently executing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，我们通常可以通过多种方式实现相同的结果。例如，在[第1章](chapter1.xhtml)中，我们通过利用vmmap提取了运行中的进程中加载的所有库和框架。在这一章中，我们将通过手动解析Mach-O来执行类似的任务。这种静态方法只会提取直接依赖关系，排除递归；也就是说，我们不会提取依赖项的依赖项。此外，二进制文件在运行时直接加载的库本身不是依赖项，因此也不会被提取。虽然这种方法简单，但它有助于我们理解Mach-O的能力，而且不需要像vmmap那样执行外部二进制文件。此外，该代码可以在任何Mach-O二进制文件上运行，而不要求其当前正在执行。
- en: Finding Dependency Paths
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找依赖路径
- en: 'To extract a binary’s dependencies, we can enumerate its LC_LOAD_DYLIB load
    commands, each of which contains a path to a library or framework on which the
    Mach-O depends. The dylib_command structure describes these load commands:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取一个二进制文件的依赖关系，我们可以枚举它的LC_LOAD_DYLIB加载命令，每个命令都包含一个指向Mach-O所依赖的库或框架的路径。dylib_command结构体描述了这些加载命令：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We’ll extract these dependencies in a function named extractDependencies that
    accepts a pointer to a Mach-O header and returns an array containing the names
    of dependencies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个名为extractDependencies的函数中提取这些依赖关系，该函数接受一个指向Mach-O头部的指针，并返回一个包含依赖项名称的数组。
- en: NOTE
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*To keep things simple, we won’t take into account LC_LOAD_WEAK_DYLIB load
    commands, which describe optional dependencies.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简化起见，我们不会考虑LC_LOAD_WEAK_DYLIB加载命令，它描述的是可选的依赖关系。*'
- en: In [Listing 2-12](chapter2.xhtml#Lis2-12), the code starts by invoking the findLoadCommand
    helper function to find load commands whose type is LC_LOAD_DYLIB. It then iterates
    over each of these load commands to extract the dependency’s path.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单2-12](chapter2.xhtml#Lis2-12)中，代码首先调用findLoadCommand辅助函数，找到类型为LC_LOAD_DYLIB的加载命令。然后，它遍历这些加载命令中的每一个，提取依赖项的路径。
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 2-12: Finding all LC_LOAD_DYLIB load commands'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-12：查找所有LC_LOAD_DYLIB加载命令
- en: 'Let’s now extract the name of each dependency. To understand how we’ll do so,
    take a look at the dylib structure that describes a dependency. This structure
    is the last member of the dylib_command structure used to describe LC_LOAD_DYLIB
    load commands:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们提取每个依赖项的名称。要理解我们如何做到这一点，请看一下描述依赖项的dylib结构体。这个结构体是dylib_command结构体的最后一个成员，用于描述LC_LOAD_DYLIB加载命令：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Of interest to us is the structure’s name field, whose type is lc_str. A comment
    in Apple’s *loader.h* file explains that we must first extract the offset to the
    dependency path and then use it to compute the path’s bytes and length ([Listing
    2-13](chapter2.xhtml#Lis2-13)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心的是该结构体中的name字段，其类型为lc_str。Apple的*loader.h*文件中的注释解释了我们必须首先提取依赖路径的偏移量，然后使用它来计算路径的字节和长度（[清单2-13](chapter2.xhtml#Lis2-13)）。
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 2-13: Extracting a dependency from an LC_LOAD_DYLIB load command'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-13：从LC_LOAD_DYLIB加载命令中提取依赖项
- en: We previously stored the pointer to each matching load command as an NSValue
    object, so we must first extract these ❶. Then we extract the offset to the dependency
    path and use it to compute the path’s bytes and length ❷. Now we can easily extract
    the path into a string object and save it into an array ❸. We return this array
    containing all dependencies once the enumeration is complete.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前将每个匹配的加载命令的指针存储为NSValue对象，因此我们首先需要提取这些❶。然后，我们提取依赖路径的偏移量，并用它来计算路径的字节和长度❷。现在我们可以轻松地将路径提取为字符串对象，并将其保存到数组中❸。一旦枚举完成，我们就返回包含所有依赖项的数组。
- en: 'When we compile and run this code against CloudMensis, it outputs the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译并运行这段代码并将其应用于CloudMensis时，它输出以下内容：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Notice the inclusion of the *DiskArbitration* framework we mentioned earlier.
    Once again, we can use otool, this time with the -L flag, to confirm the accuracy
    of our code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们之前提到的*DiskArbitration*框架的包含。我们可以再次使用otool，这次加上-L标志，来确认我们代码的准确性：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The dependencies extracted from CloudMensis via otool match those extracted
    by our code, so we can move on to analyzing them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从 CloudMensis 提取的依赖关系与我们的代码提取的依赖关系相符，因此我们可以继续分析它们。
- en: Analyzing Dependencies
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分析依赖关系
- en: 'The majority of CloudMensis’s dependencies are system libraries and frameworks,
    such as *libobjc.A.dylib* and *libSystem.B.dylib*. Essentially all Mach-O binaries
    link against these, and from the point of view of malware detection, they’re uninteresting.
    However, the *DiskArbitration* dependency is notable, as it provides the DA* APIs
    to interact with external disks. Here is a snippet of CloudMensis’s decompiled
    binary code showing its interactions with the *DiskArbitration* APIs:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: CloudMensis 的大多数依赖关系是系统库和框架，例如 *libobjc.A.dylib* 和 *libSystem.B.dylib*。几乎所有的
    Mach-O 二进制文件都与这些库链接，从恶意软件检测的角度来看，这些库本身并不引人注意。然而，*DiskArbitration* 依赖关系是值得注意的，因为它提供了
    DA* API 用于与外部磁盘进行交互。以下是 CloudMensis 反编译后的二进制代码片段，展示了它与 *DiskArbitration* API 的交互：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, in a function named loop_usb, the malware invokes various DiskArbitration
    APIs to register a callback that the operating system will invoke automatically
    once a new disk appears ❶. When this OnDiskAppeared callback is invoked—for example,
    when an external USB drive is inserted—it calls other DA* APIs, such as DADiskCopyDescription
    ❷, to access information about the new disk. The remainder of the code in the
    OnDiskAppeared callback is responsible for generating a file listing, then copying
    files off the drive into a custom file store. These files eventually get exfiltrated
    to the attacker’s remote command-and-control server.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在一个名为 loop_usb 的函数中，恶意软件调用了多个 DiskArbitration API 来注册一个回调，操作系统在新磁盘出现时会自动调用该回调❶。当这个
    OnDiskAppeared 回调被触发时——例如，当外部 USB 驱动器插入时——它调用其他 DA* API，如 DADiskCopyDescription❷，以访问新磁盘的信息。OnDiskAppeared
    回调中的其余代码负责生成文件列表，然后将文件从驱动器复制到自定义文件存储中。这些文件最终会被外泄到攻击者的远程命令与控制服务器。
- en: 'Let’s run the dependency code against another malware sample that leverages
    even more frameworks to achieve a wide range of offensive capabilities. Mokes
    is a cross-platform cyber-espionage implant that has infected macOS users in attacks
    leveraging browser zero-days.^([6](#chapter2-6)) Running the dependency extractor
    code against the malware’s binary, named *storeuserd*, generates the following
    output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们针对另一个恶意软件样本运行依赖代码，该样本利用更多的框架来实现广泛的攻击能力。Mokes 是一个跨平台的网络间谍植入程序，已经在利用浏览器零日漏洞的攻击中感染了
    macOS 用户。^([6](#chapter2-6)) 运行依赖提取器代码分析恶意软件的二进制文件，名为 *storeuserd*，生成了以下输出：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Several of these dependencies shed light on the malware’s capabilities and could
    guide future analysis. For example, the malware leverages the *AVFoundation* framework
    to record audio and video from the mic and webcam of an infected host. It also
    uses CoreWLAN to enumerate and monitor network interfaces and DiskArbitration
    to monitor external storage drives to find and exfiltrate files of interest.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些依赖关系揭示了恶意软件的功能，并可能为未来的分析提供指导。例如，恶意软件利用 *AVFoundation* 框架从受感染主机的麦克风和摄像头录制音频和视频。它还使用
    CoreWLAN 枚举和监控网络接口，使用 DiskArbitration 监控外部存储驱动器，以查找并外泄感兴趣的文件。
- en: 'Of course, dependencies alone can’t prove that code is malicious. For example,
    a binary that links against the AVFoundation isn’t necessarily spying on the user;
    it might be a legitimate videoconferencing app or simply be making use of the
    framework for benign multimedia-related tasks. However, taking a look at the following
    snippet of disassembly from Mokes confirms that it does indeed leverage AVFoundation
    APIs in a nefarious manner:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，单独依赖关系无法证明代码是恶意的。例如，链接到 AVFoundation 的二进制文件不一定是在监视用户；它可能是一个合法的视频会议应用程序，或者只是将该框架用于无害的多媒体相关任务。然而，查看以下来自
    Mokes 的反汇编片段确认它确实以恶意方式利用了 AVFoundation API：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This excerpt shows the code interfacing with the webcam to spy on victims.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段摘录展示了代码如何与摄像头交互，监视受害者。
- en: Another reason to extract dependencies from a Mach-O binary is to detect malicious
    subversions. ZuRu is one such example. Its malware authors surreptitiously trojanized
    popular applications such as iTerm by adding a malicious dependency to them, then
    distributed the applications via sponsored ads that would appear as the first
    result when users searched online for the applications.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Mach-O 二进制文件中提取依赖关系的另一个原因是为了检测恶意的篡改版本。ZuRu 就是一个这样的例子。其恶意软件作者通过添加恶意依赖项悄悄地木马化了
    iTerm 等流行应用程序，然后通过赞助广告将这些应用程序分发出去，广告会出现在用户在线搜索这些应用程序时的首位。
- en: 'The subversion was stealthy, as it left the original application’s functionality
    wholly intact. However, extracting dependencies quickly reveals the malicious
    dependency. To demonstrate this, let’s first extract the dependencies from a legitimate
    copy of iTerm2:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该篡改非常隐蔽，因为它完全保留了原始应用程序的功能。然而，快速提取依赖项能够迅速揭示出恶意依赖项。为了演示这一点，我们首先从一个合法的 iTerm2 副本中提取依赖项：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Nothing unusual here. Now, if we extract the dependencies from a trojanized
    instance of iTerm, we uncover a new dependency, *libcrypto.2.dylib*, located in
    the application bundle. This dependency sticks out, not only because it doesn’t
    exist in the legitimate application but also because it’s the only dependency
    that uses the @executable_path variable:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么异常。不过，如果我们从一个被木马化的 iTerm 实例中提取依赖项，就会发现一个新的依赖项，*libcrypto.2.dylib*，它位于应用包中。这个依赖项很突出，不仅因为它在合法的应用程序中并不存在，还因为它是唯一一个使用
    @executable_path 变量的依赖项：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There is nothing inherently malicious about the @executable_path variable; it
    simply tells the loader how to relatively resolve the library’s path (meaning
    the library is likely embedded in the same bundle as the executable). Nevertheless,
    the addition of a new dependency that referenced a newly added library clearly
    warranted additional analysis, and such analysis revealed that the dependency
    contained all of the malware’s malicious logic.^([7](#chapter2-7))
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '@executable_path 变量本身并没有恶意，它仅仅是告诉加载器如何相对解析库的路径（意味着库可能和可执行文件嵌入在同一个包中）。然而，添加一个新依赖，它引用了新加入的库，显然需要进行额外的分析，而这种分析揭示出该依赖包含了所有恶意逻辑。^([7](#chapter2-7))'
- en: Extracting Symbols
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取符号
- en: 'A binary’s symbols contain the names of the binary’s functions or methods and
    those of the APIs it imports. These function names can reveal the file’s capabilities
    and even provide indicators that it is malicious. For example, let’s extract the
    symbols from malware called DazzleSpy using the macOS nm tool:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件的符号包含了该二进制文件的函数或方法名称，以及它所引入的 API 名称。这些函数名可以揭示文件的功能，甚至提供它是恶意的指示。例如，使用 macOS
    的 nm 工具从名为 DazzleSpy 的恶意软件中提取符号：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: From the format of these symbols, we can tell that the malware was written in
    Objective-C. The Objective-C runtime requires method names to remain intact in
    the compiled binary, so understanding the binaries’ capabilities is often relatively
    easy. For example, the symbols embedded in DazzleSpy reveal methods that appear
    to execute shell commands, survey the system, post mouse events, and steal passwords
    from the keychain.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些符号的格式来看，我们可以判断该恶意软件是用 Objective-C 编写的。Objective-C 运行时要求方法名在编译后的二进制文件中保持不变，因此了解二进制文件的功能通常比较容易。例如，嵌入在
    DazzleSpy 中的符号揭示出一些方法，看似执行了 shell 命令、调查系统、发布鼠标事件以及从钥匙串窃取密码。
- en: It’s worth noting, though, that nothing stops malware authors from using misleading
    method names, so you should never draw conclusions solely from extracted symbols.
    You might also encounter symbols that have been obfuscated (providing a pretty
    good indication that the binary has something to hide). Finally, the authors may
    have stripped a binary to remove symbols that aren’t essential for program execution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，恶意软件作者并没有什么阻碍去使用误导性的函数名，因此你永远不应仅仅通过提取的符号就得出结论。你还可能会遇到被混淆的符号（这通常表明二进制文件可能有隐瞒的内容）。最后，作者可能已经剥离了二进制文件，去除那些对程序执行不必要的符号。
- en: 'Later in the nm symbol output for DazzleSpy, we also find APIs that the malware
    imports from system libraries and frameworks:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DazzleSpy 的 nm 符号输出中，我们还发现了恶意软件从系统库和框架中导入的 API：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: These include networking APIs such as bind and connect related to the malware’s
    backdoor capabilities, AVFoundation imports related to its remote desktop capabilities,
    and APIs to survey a system and grab items from the victim’s keychain.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括与恶意软件后门功能相关的网络 API，如 bind 和 connect，涉及远程桌面功能的 AVFoundation 导入，以及用于调查系统和从受害者钥匙串中抓取项目的
    API。
- en: 'How can we extract a Mach-O binary’s symbols programmatically? As you’ll see,
    this requires yet again parsing the binary’s load commands. We’ll focus specifically
    on the LC_SYMTAB load command, which contains information about a binary’s symbols
    found in the symbol table (hence the load command’s suffix SYMTAB). This load
    command consists of a symtab_command structure, defined in *loader.h*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如何程序化提取 Mach-O 二进制文件的符号？正如你将看到的，这再次需要解析二进制文件的加载命令。我们将专注于 LC_SYMTAB 加载命令，它包含有关二进制文件符号的信息，这些符号位于符号表中（因此加载命令的后缀为
    SYMTAB）。该加载命令由一个 symtab_command 结构体组成，定义在 *loader.h* 中：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The symoff member contains the offset of the symbol table, while nsyms contains
    the number of entries in this table. The symbol table consists of nlist_64 structures,
    defined in *nlist.h*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: symoff 成员包含符号表的偏移量，而 nsyms 则包含符号表中的条目数量。符号表由 nlist_64 结构体组成，定义在 *nlist.h* 中：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Each nlist_64 structure in the symbol table contains an index to the string
    table, in the n_strx field. We can find the string table’s offset in the symtab_command
    structure’s stroff field. By adding the specified index from n_strx to this offset,
    we can retrieve the symbol as a NULL-terminated string. Thus, to extract a binary’s
    symbols, we must perform the following steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 符号表中的每个 nlist_64 结构体都包含指向字符串表的索引，存储在 n_strx 字段中。我们可以在 symtab_command 结构体的 stroff
    字段中找到字符串表的偏移量。通过将 n_strx 中指定的索引加到此偏移量上，我们可以检索符号的 NULL 终止字符串。因此，为了提取二进制文件的符号，我们必须执行以下步骤：
- en: 1.  Find the LC_SYMTAB load command that contains the symtab_command structure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  查找包含 symtab_command 结构体的 LC_SYMTAB 加载命令。
- en: 2.  Use the symoff member of the symtab_command structure to find the offset
    of the symbol table.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  使用 symtab_command 结构体的 symoff 成员来查找符号表的偏移量。
- en: 3.  Use the stroff member of the symtab_command structure to find the offset
    of the string table.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  使用 symtab_command 结构体的 stroff 成员来查找字符串表的偏移量。
- en: 4.  Iterate through all of the symbol table’s nlist_64 structures to extract
    each symbol’s index (n_strx) into the string table.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  遍历符号表中的所有 nlist_64 结构体，以提取每个符号的索引（n_strx），并将其添加到字符串表中。
- en: 5.  Apply this index to the string table to find the name of the symbol.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  将此索引应用于字符串表，以查找符号的名称。
- en: The function in [Listing 2-14](chapter2.xhtml#Lis2-14) implements these steps.
    Given a pointer to a Mach-O header, it saves all symbols into an array and returns
    it to the caller.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-14](chapter2.xhtml#Lis2-14) 中的函数实现了这些步骤。给定指向 Mach-O 头部的指针，它将所有符号保存到一个数组中，并返回给调用者。'
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 2-14: Extracting a binary’s symbols'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-14：提取二进制文件的符号
- en: Because this function is somewhat involved, we’ll walk through it in detail.
    First, it finds the LC_SYMTAB load command by means of the findLoadCommand helper
    function ❶. It then uses the fields in the load command’s symtab _command structure
    to compute the in-memory address of both the symbol table ❷ and the string table
    ❸. After initializing a pointer to the first nlist_64 structure, found at the
    start of the symbol table ❹, the code iterates over it and all subsequent nlist_64
    structures ❺. For each of these structures, it adds the index to the string table
    to compute the address of the symbol’s string representation ❻. If the symbol
    is not NULL, the code adds it to an array to return to the caller.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此功能相对复杂，我们将详细讲解它。首先，它通过 `findLoadCommand` 辅助函数 ❶ 查找 LC_SYMTAB 加载命令。然后，它使用加载命令中的
    symtab _command 结构体中的字段，计算符号表 ❷ 和字符串表 ❸ 的内存地址。在初始化指向符号表开始处的第一个 nlist_64 结构体的指针
    ❹ 后，代码对其以及所有后续的 nlist_64 结构体进行迭代 ❺。对于这些结构体中的每一个，它将索引添加到字符串表中，以计算符号的字符串表示地址 ❻。如果符号不为
    NULL，代码将其添加到数组中，并返回给调用者。
- en: 'Let’s compile and run this code against DazzleSpy. As we can see, the code
    is able to extract the malware’s method names, as well as the API imports it invokes:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行这段代码，以检测 DazzleSpy。正如我们所看到的，代码能够提取恶意软件的方法名称以及它调用的 API 导入：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The ability to extract symbols from any Mach-O binary will improve our heuristic
    malware detection. Next, we’ll programmatically detect anomalous characteristics
    that often indicate a binary is up to something nefarious.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 提取任何 Mach-O 二进制文件的符号的能力，将提高我们的启发式恶意软件检测。接下来，我们将程序化地检测那些通常表示二进制文件存在恶意活动的异常特征。
- en: NOTE
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Newer binaries may contain a LC_DYLD_CHAINED_FIXUPS load command that optimizes
    how symbols and imports are handled on recent versions of macOS. In this case,
    a different approach is needed to extract embedded symbols. See the* extractChainedSymbols
    *function in the* parseBinary *project for more details and a programmatic implementation
    of such extraction.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*更新版的二进制文件可能包含 LC_DYLD_CHAINED_FIXUPS 加载命令，优化了如何在最新版本的 macOS 上处理符号和导入。在这种情况下，需要采用不同的方法来提取嵌入的符号。有关更多细节和此类提取的编程实现，请参阅*
    extractChainedSymbols *函数，位于* parseBinary *项目中。*'
- en: Detecting Packed Binaries
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测打包二进制文件
- en: An *executable packer* is a tool that compresses binary code to shrink its size
    for distribution. The packer inserts a small unpacker stub at the binary’s entry
    point, and this stub executes automatically when the packed program is run, restoring
    the original code in memory.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *可执行压缩器* 是一种将二进制代码压缩以减小分发大小的工具。压缩器会在二进制文件的入口点插入一个小的解包器存根，当打包程序运行时，这个存根会自动执行，将原始代码恢复到内存中。
- en: Malware authors are quite fond of packers, as compressed code is more difficult
    to analyze. Moreover, certain packers encrypt or further obfuscate the binary
    in an attempt to thwart signature-based detections and complicate analysis. Legitimate
    software is rarely packed on macOS, so the ability to detect obfuscation can be
    a powerful heuristic for flagging binaries that warrant closer inspection.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者非常喜欢使用压缩器，因为压缩后的代码更难以分析。此外，某些压缩器会加密或进一步混淆二进制文件，以试图阻止基于签名的检测并复杂化分析。合法的软件在
    macOS 上很少被打包，因此，检测混淆的能力可以成为一个强有力的启发式方法，用于标记那些需要更仔细检查的二进制文件。
- en: I’ll wrap up this chapter by showing how to detect packed and encrypted Mach-O
    binaries by looking for a lack of dependencies and symbols, anomalous section
    and segment names, and high entropy.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过展示如何通过检查缺少依赖和符号、异常的节和段名称以及高熵，来检测打包和加密的 Mach-O 二进制文件，来结束本章。
- en: Dependencies and Symbols
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 依赖和符号
- en: One simple, albeit somewhat naive, approach to packer detection is enumerating
    a binary’s dependencies and symbols—or, rather, lack thereof. Nonpacked binaries
    will always have dependencies on various system frameworks and libraries such
    as *libSystem.B.dylib*, as well as imports from these dependencies. Packed binaries,
    on the other hand, may lack even a single dependency or symbol, as the unpacker
    stub will dynamically resolve and load any required libraries.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 检测压缩器的一个简单方法，尽管有些天真，就是枚举二进制文件的依赖和符号——或者说，缺少这些内容。未打包的二进制文件通常会依赖于各种系统框架和库，如 *libSystem.B.dylib*，以及这些依赖的导入。另一方面，打包的二进制文件可能缺少任何依赖或符号，因为解包器存根会动态解析并加载任何所需的库。
- en: 'A binary with no dependencies or symbols is, at the very least, anomalous,
    and our tool should flag it for analysis. For example, running the dependency
    and symbol extraction code against the oRAT malware finds no dependencies or symbols:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有依赖或符号的二进制文件，至少可以认为是异常的，我们的工具应该标记它以供分析。例如，运行依赖和符号提取代码对 oRAT 恶意软件进行分析时，发现没有任何依赖或符号：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Apple’s otool and nm confirm this absence as well:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Apple 的 otool 和 nm 也证实了这种缺失：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It turns out oRAT is packed via UPX, a cross-platform packer that Mac malware
    authors favor. Examples of other macOS malware packed with UPX include IPStorm,
    ZuRu, and Coldroot.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，oRAT 是通过 UPX 压缩的，UPX 是 Mac 恶意软件作者青睐的跨平台压缩器。其他使用 UPX 压缩的 macOS 恶意软件示例包括
    IPStorm、ZuRu 和 Coldroot。
- en: Section and Segment Names
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 节和段名称
- en: Binaries packed with UPX may contain UPX-specific section or segment names,
    such as __XHDR, UPX_DATA, or upxTEXT. If we find these names when parsing a Mach-O
    binary’s segments, we can conclude that the binary was packed. Other packers,
    such as MPress, add their own segment names, such as __MPRESS__.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 UPX 压缩的二进制文件可能包含 UPX 特有的节或段名称，如 __XHDR、UPX_DATA 或 upxTEXT。如果我们在解析 Mach-O
    二进制文件的段时发现这些名称，我们可以推断该二进制文件已经被打包。其他压缩器，如 MPress，会添加自己的段名称，如 __MPRESS__。
- en: 'The following code snippet, from UPX’s *p_mach.cpp* file,^([8](#chapter2-8))
    shows references to nonstandard segment names:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段来自 UPX 的 *p_mach.cpp* 文件，^([8](#chapter2-8)) 展示了对非标准段名称的引用：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To retrieve a binary’s section and segment names, we can iterate through its
    load commands, looking for those of type LC_SEGMENT_64. These load commands consist
    of segment_command_64 structures that contain a member named segname with the
    name of the segment. Here is the segment_command_64 structure:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取二进制文件的节（section）和段（segment）名称，我们可以遍历其加载命令，查找类型为 LC_SEGMENT_64 的命令。这些加载命令由
    segment_command_64 结构组成，结构中包含一个名为 segname 的成员，表示段的名称。以下是 segment_command_64 结构：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Any sections within the segment should immediately follow the segment _command_64
    structure, whose nsects member specifies the number of sections. The section_64
    structure, shown here, describes sections:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 段中的任何section应该紧随segment_command_64结构之后，该结构的nsects成员指定了section的数量。下面展示的section_64结构描述了这些section：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Since the segment name can be extracted from the segment_command_64 structure,
    here we’re solely interested in the section name, sectname. To detect packers
    such as UPX, our code can iterate through each segment and its sections, comparing
    the names with those of common packers. First, though, we need a function that
    accepts a Mach-O header, then extracts the binary’s segments and sections. The
    extractSegmentsAndSections function partially shown in [Listing 2-15](chapter2.xhtml#Lis2-15)
    does exactly this.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于段名称可以从segment_command_64结构中提取出来，因此我们这里只关心section名称sectname。为了检测像UPX这样的打包器，我们的代码可以遍历每个段及其各个section，比较这些名称是否与常见打包器的名称相匹配。然而，首先我们需要一个接受Mach-O头部的函数，然后提取二进制文件的段和section。部分展示的extractSegmentsAndSections函数在[Listing
    2-15](chapter2.xhtml#Lis2-15)中正是执行这个操作。
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 2-15: Retrieving a list of LC_SEGMENT_64 load commands'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-15: 检索LC_SEGMENT_64加载命令的列表'
- en: This code declares a few variables and then invokes the now-familiar findLoadCommand
    helper function with a value of LC_SEGMENT_64. Now that we have a list of the
    load commands describing each segment in the binary, we can iterate over each,
    saving their names and the names of all their sections ([Listing 2-16](chapter2.xhtml#Lis2-16)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码声明了一些变量，然后调用了现在熟悉的findLoadCommand助手函数，并传入LC_SEGMENT_64的值。现在我们拥有了描述二进制文件中每个段的加载命令列表，可以遍历每个段，保存它们的名称及其所有section的名称（见[Listing
    2-16](chapter2.xhtml#Lis2-16)）。
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 2-16: Iterating over each segment and its sections to extract their
    names'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-16: 遍历每个段及其section以提取其名称'
- en: After extracting the pointer to each LC_SEGMENT_64 and saving it into a struct
    segment_command_64* ❶, the code extracts the name of the segment from the segname
    member of the segment_command_64 structure, stored in a rather unwieldy (and not
    necessarily NULL-terminated) char array. The code converts it into a string object,
    trims any NULLs, and then saves it into an array to return to the caller ❷.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 提取指向每个LC_SEGMENT_64的指针并将其保存到struct segment_command_64* ❶中后，代码从segment_command_64结构的segname成员提取段的名称，存储在一个相当笨重（且不一定是以NULL结尾的）char数组中。代码将其转换为字符串对象，修剪掉任何NULL字符，然后将其保存到一个数组中，返回给调用者❷。
- en: Next, we iterate over the section_64 structures found in the LC_SEGMENT_64 command.
    One structure exists for each section in the segment. Because they begin immediately
    after the segment_command_64 structure, we initialize a pointer to the first section_64
    structure, adding the start of the segment _command_64 structure to the size of
    this structure ❸. Now we can iterate over each section structure, bounded by the
    nsects member of the segment structure ❹. As with each segment name, we extract,
    convert, trim, and save the section names ❺.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历在LC_SEGMENT_64命令中找到的section_64结构。每个段中都有一个结构。由于它们紧接在segment_command_64结构之后，因此我们初始化一个指向第一个section_64结构的指针，将segment_command_64结构的起始位置加上该结构的大小❸。现在我们可以遍历每个section结构，其边界由segment结构的nsects成员定义❹。与每个段名称一样，我们提取、转换、修剪并保存section名称❺。
- en: Once we’ve extracted all segment and section names, we pass this list to a simple
    helper function named isPacked. Shown in [Listing 2-17](chapter2.xhtml#Lis2-17),
    it checks whether any names match those of well-known packers, such as UPX and
    MPress.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们提取了所有段和section名称，我们将这个列表传递给一个简单的助手函数isPacked。该函数在[Listing 2-17](chapter2.xhtml#Lis2-17)中展示，它检查是否有任何名称与知名打包器（如UPX和MPress）匹配。
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 2-17: Checking for segment and section names matching those of known
    packers'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-17: 检查段和section名称是否与已知打包器匹配'
- en: 'First, we initialize a set with a few well-known packer-related segment and
    section names ❶. Then we convert the list of segments and sections into a mutable
    set ❷, as mutable set objects support the intersectSet: method, which will remove
    any items in the first set that aren’t in the second. Once we’ve called this method
    ❸, the only names left in the set of segment and section names will match the
    packer-related ones.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化一个集合，其中包含一些知名的与打包器相关的段和section名称❶。然后，我们将段和section的列表转换为一个可变集合❷，因为可变集合对象支持intersectSet:方法，该方法会删除第一个集合中不在第二个集合中的任何项。一旦我们调用此方法❸，集合中剩下的唯一名称将与打包器相关的名称匹配。
- en: 'After adding this code to the *parseBinary* project, we can run it against
    the macOS variant of the IPStorm malware:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这段代码添加到*parseBinary*项目后，我们可以将其应用于macOS版本的IPStorm恶意软件进行测试：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Because the IPStorm binary contains a section named upxTEXT indicative of UPX,
    our code correctly ascertains that the binary is packed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因为IPStorm的二进制文件包含一个名为upxTEXT的部分，表明它是使用UPX压缩的，我们的代码能够正确判断该二进制文件被打包。
- en: This name-based approach to packer detection has a low false-positive detection
    rate. However, it won’t detect custom packers or even modified versions of known
    packers. For example, if an attacker modifies UPX to remove custom section names
    (which, as UPX is open source, is easy to do), we’ll have a false negative, and
    the packed binary won’t be detected.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于名称的打包检测方法具有较低的误报率。然而，它无法检测自定义打包程序或已修改的已知打包程序。例如，如果攻击者修改了UPX以去除自定义的段名称（因为UPX是开源的，这很容易做到），我们就会遇到漏报情况，打包后的二进制文件无法被检测到。
- en: 'We find an example of this behavior in the malware known as Ocean- Lotus. In
    variant *H*, its authors packed the binary, *flashlightd*, with a customized version
    of UPX. Our current packer detector fails to determine that the malware is packed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在恶意软件Ocean-Lotus中发现了这种行为的例子。在*H*版本中，其作者使用了定制版本的UPX对二进制文件*flashlightd*进行了打包。我们的当前打包程序检测器未能判断该恶意软件是否被打包：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'However, if we manually examine the malware, it becomes fairly obvious that
    the binary is packed. In a disassembler, large chunks of the binary appear obfuscated.
    We can also see that the binary contains no symbols or dependencies:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们手动检查恶意软件，就很明显可以看出该二进制文件被打包。在反汇编器中，二进制文件的大块部分看起来是模糊的。我们还可以看到该二进制文件不包含符号或依赖项：
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Clearly, our packer detection approach needs some improvement. You’ll see how
    to detect packed binaries via their entropy next.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的打包程序检测方法需要一些改进。接下来，你将看到如何通过熵值检测打包的二进制文件。
- en: Entropy Calculations
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 熵值计算
- en: When a binary is packed, the amount of randomness in it greatly increases. This
    is largely due to the fact that packers either compress or encrypt the binary’s
    original instructions. If we can calculate a binary’s quantity of unique bytes
    and classify it as anomalously high, we can fairly accurately conclude the binary
    is packed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当二进制文件被打包时，它的随机性会大幅增加。这主要是因为打包程序会压缩或加密二进制文件的原始指令。如果我们能够计算一个二进制文件中唯一字节的数量，并将其归类为异常高，我们可以相当准确地推断该二进制文件是被打包的。
- en: Let’s parse a Mach-O binary and calculate the entropy of its executable segments.
    The code in [Listing 2-18](chapter2.xhtml#Lis2-18) builds on the segment parsing
    code in the isPackedByEntropy function. After enumerating all LC_SEGMENT_64 load
    commands, the function invokes a helper function named calcEntropy on each to
    calculate the entropy of the segment’s data.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解析一个Mach-O二进制文件并计算其可执行段的熵值。[Listing 2-18](chapter2.xhtml#Lis2-18)中的代码基于isPackedByEntropy函数中的段解析代码。在枚举所有LC_SEGMENT_64加载命令后，函数会调用一个名为calcEntropy的辅助函数来计算每个段数据的熵值。
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 2-18: Computing the Shannon entropy'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-18：计算香农熵
- en: The function first computes the number of occurrences of each byte value, from
    0 to 0xFF ❶. After skipping values that don’t occur ❷, it performs a standard
    formula ❸ to compute the Shannon entropy.^([9](#chapter2-9)) The function should
    return a value between 0.0 and 8.0, ranging from no entropy (meaning all the values
    are the same) to the highest level of entropy.^([10](#chapter2-10))
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先计算每个字节值的出现次数，从0到0xFF ❶。跳过不出现的值 ❷ 后，它使用标准公式 ❸ 来计算香农熵。^([9](#chapter2-9))
    该函数应返回一个介于0.0到8.0之间的值，范围从没有熵（即所有值都相同）到最高熵值。^([10](#chapter2-10))
- en: The code uses the entropy to determine whether the binary is likely packed ([Listing
    2-19](chapter2.xhtml#Lis2-19)). It’s inspired by the popular Windows-centric AnalyzePE
    and pefile Python libraries.^([11](#chapter2-11))
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用熵值来判断二进制文件是否可能被打包（[Listing 2-19](chapter2.xhtml#Lis2-19)）。它的灵感来源于流行的以Windows为中心的AnalyzePE和pefile
    Python库。^([11](#chapter2-11))
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 2-19: Packer detection via entropy analysis'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-19：通过熵分析检测打包程序
- en: Testing has shown that if the entropy of an average-size segment is above 7.0,
    we can confidently conclude that the segment contains compressed data, meaning
    it’s either packed or encrypted. In this case, we append the segment’s size to
    a variable to keep track of the total amount of compressed data ❶.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 测试表明，如果一个中等大小段的熵值超过7.0，我们可以自信地得出结论，该段包含压缩数据，意味着它被打包或加密。在这种情况下，我们将该段的大小追加到一个变量中，以跟踪压缩数据的总量
    ❶。
- en: Once we’ve computed the entropy of each segment, we check how much of the binary’s
    total data is packed by dividing the amount of compressed data by the size of
    the Mach-O. Research has shown that Mach-O binaries with a ratio of packed data
    to overall length greater than 20 percent are likely packed (though the ratio
    is usually much higher) ❷.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们计算了每个段的熵值，我们就会通过将压缩数据的量除以Mach-O的大小，来检查二进制文件的总数据中有多少是被打包的。研究表明，Mach-O二进制文件中压缩数据与整体长度的比例大于20%的通常是被打包的（尽管比例通常更高）❷。
- en: 'Let’s test this code against the packed IPStorm sample:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们针对打包的IPStorm样本测试这段代码：
- en: '[PRE59]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Hooray! The code correctly detected that the malware is packed. This is because
    the __TEXT segment has a very high entropy (7.884 out of 8), and because it’s
    the only segment containing any data, the ratio of packed data to the overall
    binary length is very high. Equally important is the fact that the code correctly
    determined that an unpacked version of the malware is indeed no longer packed:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！代码正确地检测到恶意软件是被打包的。这是因为__TEXT段具有非常高的熵（7.884满分8），并且它是唯一包含任何数据的段，因此压缩数据与整体二进制文件长度的比例非常高。同样重要的是，代码正确地判断出恶意软件的未打包版本确实已经不再被打包：
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this unpacked binary, the tool detects more segments, but all have an entropy
    of around 6 or below. Thus, it doesn’t classify any of them as containing compressed
    data, so the ratio of compressed data to binary size is zero.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个未打包的二进制文件中，工具检测到更多的段，但所有段的熵值大约在6或以下。因此，它没有将任何段分类为包含压缩数据，所以压缩数据与二进制文件大小的比例为零。
- en: 'As you’ve seen, this entropy-based approach can generically detect almost any
    packed binary, regardless of the packer used. This holds true even in the case
    of OceanLotus, whose authors used a customized version of UPX in an attempt to
    avoid detection:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种基于熵的方法可以通用地检测几乎所有被打包的二进制文件，无论使用了哪种打包工具。即使在OceanLotus的情况下也是如此，其作者使用了一个定制版本的UPX试图避免检测：
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Although the packed malware doesn’t contain any segments or sections that match
    known packers, the large __TEXT segment contains a very high amount of entropy
    (7.5+). As such, the code correctly determines that the OceanLotus sample is packed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管打包后的恶意软件不包含任何与已知打包工具匹配的段或部分，但较大的__TEXT段包含非常高的熵（7.5+）。因此，代码正确地判断出OceanLotus样本是被打包的。
- en: Detecting Encrypted Binaries
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测加密的二进制文件
- en: While Apple encrypts the Intel versions of various system binaries, encrypted
    third-party binaries are rarely legitimate, and you should flag these for closer
    analysis. *Binary encryptors* encrypt the original malware code at the binary
    level. To automatically decrypt the malware at runtime, the encryptor will often
    insert a decryption stub and keying information at the start of the binary unless
    the operating system natively supports encrypted binaries, which macOS does.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Apple加密了各种系统二进制文件的Intel版本，但加密的第三方二进制文件很少是合法的，你应该标记这些文件以便进一步分析。*二进制加密器*在二进制级别加密原始恶意软件代码。为了在运行时自动解密恶意软件，加密器通常会在二进制文件的开头插入解密存根和密钥信息，除非操作系统原生支持加密二进制文件，而macOS是支持的。
- en: As with packed binaries, we can detect encrypted binaries using entropy calculations,
    as any well-encrypted file will have a very high level of randomness. Thus, the
    code provided in the previous section should identify them. However, you might
    find it worthwhile to write code that focuses specifically on detecting binaries
    encrypted with the native macOS encryption scheme. The encryption scheme is undocumented
    and proprietary, so any third-party binary leveraging it should be treated as
    suspect.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与打包的二进制文件一样，我们可以通过熵计算来检测加密的二进制文件，因为任何经过良好加密的文件都会具有非常高的随机性。因此，上一节提供的代码应该能够识别它们。然而，你可能觉得编写专门检测使用本地macOS加密方案加密的二进制文件的代码是值得的。加密方案未公开，并且是专有的，因此任何使用该加密方案的第三方二进制文件都应该被视为可疑。
- en: 'We can see in the open source macOS Mach-O loader^([12](#chapter2-12)) how
    to detect such binaries. In the loader’s code, we find mention of an LC_SEGMENT_64
    flag value named SG_PROTECTED_VERSION_1 whose value is 0x8. As explained in Apple’s
    *mach-o/loader.h* file, this means the segment is encrypted with Apple’s proprietary
    encryption scheme:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在开源的macOS Mach-O加载器中看到如何检测此类二进制文件^([12](#chapter2-12))。在加载器的代码中，我们发现提到了一个名为SG_PROTECTED_VERSION_1的LC_SEGMENT_64标志，其值为0x8。正如Apple的*mach-o/loader.h*文件中所解释的，这意味着该段是使用Apple的专有加密方案加密的：
- en: '[PRE62]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Usually, malware will encrypt only the __TEXT segment, which contains the binary’s
    executable code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，恶意软件只会加密__TEXT段，它包含二进制文件的可执行代码。
- en: 'Although it’s rare to discover malware leveraging this proprietary encryption
    scheme, we find an example in a HackingTeam implant installer. Using otool, let’s
    dump the load commands of this binary. Sure enough, the flags of the __TEXT segment
    are set to SG_PROTECTED_VERSION_1 (0x8):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管发现恶意软件利用这种专有加密方案的情况较为罕见，但我们在HackingTeam植入式安装程序中发现了一个例子。使用otool，我们来转储这个二进制文件的加载命令。果然，__TEXT段的flags被设置为SG_PROTECTED_VERSION_1（0x8）：
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To detect if a binary is encrypted using this native encryption scheme, we can
    simply iterate over its LC_SEGMENT_64 load commands, looking for any that have
    the SG_PROTECTED_VERSION_1 bits set in the flags member of the segment_command_64
    structure ([Listing 2-20](chapter2.xhtml#Lis2-20)).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测一个二进制文件是否使用这种本地加密方案加密，我们只需遍历它的LC_SEGMENT_64加载命令，寻找那些在segment_command_64结构的flags成员中设置了SG_PROTECTED_VERSION_1位的命令（[Listing
    2-20](chapter2.xhtml#Lis2-20)）。
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 2-20: Checking whether a segment is encrypted with the native macOS
    encryption scheme'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-20：检查一个段是否使用本地macOS加密方案进行加密
- en: 'This chapter has focused on 64-bit Mach-Os, but the HackingTeam installer is
    almost 10 years old and was distributed as a 32-bit Intel binary, which isn’t
    compatible with recent versions of macOS. To write code capable of detecting HackingTeam’s
    32-bit installer, we’d have to make sure it uses the 32-bit versions of the Mach-O
    structures, such as mach_header and LC_SEGMENT.^([13](#chapter2-13)) If we made
    these changes and ran the code against the installer, it would correctly flag
    the binary as leveraging Apple’s proprietary encryption scheme:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论了64位Mach-O文件，但HackingTeam安装程序几乎已有10年历史，并且是以32位Intel二进制文件的形式发布的，这与最新版本的macOS不兼容。为了编写能够检测HackingTeam
    32位安装程序的代码，我们需要确保它使用32位版本的Mach-O结构，如mach_header和LC_SEGMENT。^([13](#chapter2-13))
    如果我们做出这些修改并对安装程序运行代码，它会正确标记该二进制文件为利用苹果专有加密方案：
- en: '[PRE65]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We noted that though macOS does natively support encrypted binaries, because
    this is not documented, any third-party binary that is encrypted in this manner
    should be closely examined, as it may be malware with something to hide.^([14](#chapter2-14))
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，虽然macOS确实支持加密的二进制文件，但由于这未被文档化，任何以这种方式加密的第三方二进制文件都应当被仔细检查，因为它可能是带有隐藏内容的恶意软件。^([14](#chapter2-14))
- en: Conclusion
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you learned how to confirm that a file is a Mach-O or a universal
    binary containing Mach-Os. Then you extracted dependencies and names and detected
    whether the binary was packed or encrypted.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何确认一个文件是否为Mach-O文件或包含Mach-O的通用二进制文件。接着，你提取了依赖关系和名称，并检测了该二进制文件是否被打包或加密。
- en: Of course, there are many other interesting things you could do with a Mach-O
    binary to classify it as benign or malicious. Take a look at Kimo Bumanglag’s
    Objective by the Sea talk for ideas.^([15](#chapter2-15))
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还可以对Mach-O二进制文件做许多其他有趣的事情，以将其分类为良性或恶意。参考Kimo Bumanglag的《Objective by the
    Sea》演讲，获取更多灵感。^([15](#chapter2-15))
- en: 'A final thought: I’ve noted that no single data point covered in this chapter
    can definitively indicate that a binary is malicious. For example, nothing stops
    legitimate developers from packing their binaries. Luckily, we have another powerful
    mechanism at our disposal to detect malware: code signing. [Chapter 3](chapter3.xhtml)
    is dedicated to this topic. Read on!'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的思考：我注意到，本章中讨论的任何单一数据点都无法明确表示一个二进制文件是恶意的。例如，合法的开发者也可以打包他们的二进制文件。幸运的是，我们还有另一个强大的机制可以用来检测恶意软件：代码签名。[第3章](chapter3.xhtml)专门讨论了这个主题。继续阅读吧！
- en: Notes
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '[  1](#chapter2_1).  UniqMartin, comment on “FatArch64,” Homebrew, July 7,
    2018, [*https://<wbr>github<wbr>.com<wbr>/Homebrew<wbr>/ruby<wbr>-macho<wbr>/issues<wbr>/101#issuecomment<wbr>-403202114*](https://github.com/Homebrew/ruby-macho/issues/101#issuecomment-403202114).'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  1](#chapter2_1).  UniqMartin，在“FatArch64”评论中，Homebrew，2018年7月7日，[*https://<wbr>github<wbr>.com<wbr>/Homebrew<wbr>/ruby<wbr>-macho<wbr>/issues<wbr>/101#issuecomment<wbr>-403202114*](https://github.com/Homebrew/ruby-macho/issues/101#issuecomment-403202114)。'
- en: '[  2](#chapter2_2).  “magic,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/kernel<wbr>/fat<wbr>_header<wbr>/1558632<wbr>-magic*](https://developer.apple.com/documentation/kernel/fat_header/1558632-magic).'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  2](#chapter2_2).  “magic”，Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/kernel<wbr>/fat<wbr>_header<wbr>/1558632<wbr>-magic*](https://developer.apple.com/documentation/kernel/fat_header/1558632-magic)。'
- en: '[  3](#chapter2_3).  See *utils.cpp* at [*https://<wbr>github<wbr>.com<wbr>/apple<wbr>-oss<wbr>-distributions<wbr>/dyld<wbr>/blob<wbr>/d1a0f6869ece370913a3f749617e457f3b4cd7c4<wbr>/libdyld<wbr>/utils<wbr>.cpp*](https://github.com/apple-oss-distributions/dyld/blob/d1a0f6869ece370913a3f749617e457f3b4cd7c4/libdyld/utils.cpp).'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  3](#chapter2_3).  请参阅*utils.cpp*，链接：[ *https://<wbr>github<wbr>.com<wbr>/apple<wbr>-oss<wbr>-distributions<wbr>/dyld<wbr>/blob<wbr>/d1a0f6869ece370913a3f749617e457f3b4cd7c4<wbr>/libdyld<wbr>/utils<wbr>.cpp*](https://github.com/apple-oss-distributions/dyld/blob/d1a0f6869ece370913a3f749617e457f3b4cd7c4/libdyld/utils.cpp)。'
- en: '[  4](#chapter2_4).  Patrick Wardle, “Apple Gets an ‘F’ for Slicing Apples,”
    Objective-See, February 22, 2024, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x80<wbr>.html*](https://objective-see.org/blog/blog_0x80.html).'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  4](#chapter2_4).  帕特里克·沃德尔（Patrick Wardle），“苹果公司因切割苹果而得‘F’分”，Objective-See，2024年2月22日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x80<wbr>.html*](https://objective-see.org/blog/blog_0x80.html)。'
- en: '[  5](#chapter2_5).  For more on universal binaries, see Howard Oakley, “Universal
    Binaries: Inside Fat Headers,” *The Eclectic Light Company*, July 28, 2020, [*https://<wbr>eclecticlight<wbr>.co<wbr>/2020<wbr>/07<wbr>/28<wbr>/universal<wbr>-binaries<wbr>-inside<wbr>-fat<wbr>-headers<wbr>/*](https://eclecticlight.co/2020/07/28/universal-binaries-inside-fat-headers/).'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  5](#chapter2_5).  关于通用二进制文件的更多内容，请参阅霍华德·奥克利（Howard Oakley），“通用二进制文件：深入分析
    Fat Headers”，*The Eclectic Light Company*，2020年7月28日，[*https://<wbr>eclecticlight<wbr>.co<wbr>/2020<wbr>/07<wbr>/28<wbr>/universal<wbr>-binaries<wbr>-inside<wbr>-fat<wbr>-headers<wbr>/*](https://eclecticlight.co/2020/07/28/universal-binaries-inside-fat-headers/)。'
- en: '[  6](#chapter2_6).  Patrick Wardle, “Burned by Fire(fox),” Objective-See,
    June 23, 2019, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x45<wbr>.html*](https://objective-see.org/blog/blog_0x45.html).'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  6](#chapter2_6).  帕特里克·沃德尔（Patrick Wardle），“被火狐（Firefox）烧伤”，Objective-See，2019年6月23日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x45<wbr>.html*](https://objective-see.org/blog/blog_0x45.html)。'
- en: '[  7](#chapter2_7).  For more details on ZuRu, see Patrick Wardle, “Made in
    China: OSX.ZuRu,” Objective-See, September 14, 2021, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x66<wbr>.html*](https://objective-see.org/blog/blog_0x66.html).'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  7](#chapter2_7).  有关ZuRu的更多详细信息，请参阅帕特里克·沃德尔（Patrick Wardle），“中国制造：OSX.ZuRu”，Objective-See，2021年9月14日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x66<wbr>.html*](https://objective-see.org/blog/blog_0x66.html)。'
- en: '[  8](#chapter2_8).  See [*https://<wbr>upx<wbr>.github<wbr>.io*](https://upx.github.io).'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  8](#chapter2_8).  请参阅[*https://<wbr>upx<wbr>.github<wbr>.io*](https://upx.github.io)。'
- en: '[  9](#chapter2_9).  “Entropy (information theory),” Wikipedia, [*https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Entropy<wbr>_(information<wbr>_theory)*](https://en.wikipedia.org/wiki/Entropy_(information_theory).'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  9](#chapter2_9).  “熵（信息论）”，维基百科，[*https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Entropy<wbr>_(information<wbr>_theory)*](https://en.wikipedia.org/wiki/Entropy_(information_theory))。'
- en: '[10](#chapter2_10).  To gain a deeper understanding of entropy, see Ms Aerin,
    “The Intuition Behind Shannon’s Entropy,” Towards Data Science, September 30,
    2018, [*https://<wbr>towardsdatascience<wbr>.com<wbr>/the<wbr>-intuition<wbr>-behind<wbr>-shannons<wbr>-entropy<wbr>-e74820fe9800*](https://towardsdatascience.com/the-intuition-behind-shannons-entropy-e74820fe9800).'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[10](#chapter2_10).  要深入理解熵的概念，请参阅Aerin女士，“香农熵背后的直觉”，Towards Data Science，2018年9月30日，[*https://<wbr>towardsdatascience<wbr>.com<wbr>/the<wbr>-intuition<wbr>-behind<wbr>-shannons<wbr>-entropy<wbr>-e74820fe9800*](https://towardsdatascience.com/the-intuition-behind-shannons-entropy-e74820fe9800)。'
- en: '[11](#chapter2_11).  See [*https://<wbr>github<wbr>.com<wbr>/hiddenillusion<wbr>/AnalyzePE<wbr>/blob<wbr>/master<wbr>/peutils<wbr>.py*](https://github.com/hiddenillusion/AnalyzePE/blob/master/peutils.py)
    and [*https://<wbr>github<wbr>.com<wbr>/erocarrera<wbr>/pefile<wbr>/blob<wbr>/master<wbr>/pefile<wbr>.py*](https://github.com/erocarrera/pefile/blob/master/pefile.py).'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[11](#chapter2_11).  请参阅[*https://<wbr>github<wbr>.com<wbr>/hiddenillusion<wbr>/AnalyzePE<wbr>/blob<wbr>/master<wbr>/peutils<wbr>.py*](https://github.com/hiddenillusion/AnalyzePE/blob/master/peutils.py)
    和 [*https://<wbr>github<wbr>.com<wbr>/erocarrera<wbr>/pefile<wbr>/blob<wbr>/master<wbr>/pefile<wbr>.py*](https://github.com/erocarrera/pefile/blob/master/pefile.py)。'
- en: '[12](#chapter2_12).  See [*https://<wbr>opensource<wbr>.apple<wbr>.com<wbr>/source<wbr>/xnu<wbr>/xnu<wbr>-7195<wbr>.81<wbr>.3<wbr>/EXTERNAL<wbr>_HEADERS<wbr>/mach<wbr>-o<wbr>/loader<wbr>.h*](https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/loader.h).'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[12](#chapter2_12).  请参阅[*https://<wbr>opensource<wbr>.apple<wbr>.com<wbr>/source<wbr>/xnu<wbr>/xnu<wbr>-7195<wbr>.81<wbr>.3<wbr>/EXTERNAL<wbr>_HEADERS<wbr>/mach<wbr>-o<wbr>/loader<wbr>.h*](https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/loader.h)。'
- en: '[13](#chapter2_13).  For more details about HackingTeam’s encrypted installer,
    see Patrick Wardle, “HackingTeam Reborn; A Brief Analysis of an RCS Implant Installer,”
    Objective-See, February 26, 2016, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x0D<wbr>.html*](https://objective-see.org/blog/blog_0x0D.html).'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[13](#chapter2_13).  有关HackingTeam加密安装程序的更多详情，请参见Patrick Wardle的“*HackingTeam重生；RCS植入安装程序简要分析*”，Objective-See，2016年2月26日，详见[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x0D<wbr>.html*](https://objective-see.org/blog/blog_0x0D.html)。'
- en: '[14](#chapter2_14).  You can read more about the macOS support of encrypted
    binaries and how to decrypt them in Patrick Wardle, *The Art of Mac Malware: The
    Guide to Analyzing Malicious Software*, Volume 1 (San Francisco: No Starch Press,
    2022), 187–218, or in Amit Singh, “ ‘TPM DRM’ in Mac OS X: A Myth That Won’t Die,”
    *OSX Book*, December 2007, [*https://<wbr>web<wbr>.archive<wbr>.org<wbr>/web<wbr>/20200603015401<wbr>/http:<wbr>/<wbr>/osxbook<wbr>.com<wbr>/book<wbr>/bonus<wbr>/chapter7<wbr>/tpmdrmmyth<wbr>/*](https://web.archive.org/web/20200603015401/http://osxbook.com/book/bonus/chapter7/tpmdrmmyth/).'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[14](#chapter2_14).  你可以在Patrick Wardle的《*Mac恶意软件的艺术：分析恶意软件指南*》第一卷（旧金山：No Starch
    Press，2022年），第187–218页，或在Amit Singh的“‘TPM DRM’在Mac OS X中：一个不会消失的神话”中，了解更多关于macOS对加密二进制文件的支持以及如何解密它们，详见[*https://<wbr>web<wbr>.archive<wbr>.org<wbr>/web<wbr>/20200603015401<wbr>/http:<wbr>/<wbr>/osxbook<wbr>.com<wbr>/book<wbr>/bonus<wbr>/chapter7<wbr>/tpmdrmmyth<wbr>/*](https://web.archive.org/web/20200603015401/http://osxbook.com/book/bonus/chapter7/tpmdrmmyth/)。'
- en: '[15](#chapter2_15).  Kimo Bumanglag, “Learning How to Machine Learn,” paper
    presented at Objective by the Sea v5, Spain, October 6, 2022, [*https://<wbr>objectivebythesea<wbr>.org<wbr>/v5<wbr>/talks<wbr>/OBTS<wbr>_v5<wbr>_kBumanglag<wbr>.pdf*](https://objectivebythesea.org/v5/talks/OBTS_v5_kBumanglag.pdf).
    To learn more about the Mach-O format in general, consult Wardle, *The Art of
    Mac Malware*, 1:99–123; Bartosz Olszanowski, “Mach-O Reader - Parsing Mach-O Headers,”
    *Olszanowski Blog*, May 8, 2020, [*https://<wbr>olszanowski<wbr>.blog<wbr>/posts<wbr>/macho<wbr>-reader<wbr>-parsing<wbr>-headers<wbr>/*](https://olszanowski.blog/posts/macho-reader-parsing-headers/);
    and Alex Denisov, “Parsing Mach-O Files,” *Low Level Bits*, August 20, 2015, [*https://<wbr>lowlevelbits<wbr>.org<wbr>/parsing<wbr>-mach<wbr>-o<wbr>-files<wbr>/*](https://lowlevelbits.org/parsing-mach-o-files/).'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15](#chapter2_15).  Kimo Bumanglag在2022年10月6日于西班牙举办的Objective by the Sea v5大会上发表了题为“学习如何进行机器学习”的论文，详见[*https://<wbr>objectivebythesea<wbr>.org<wbr>/v5<wbr>/talks<wbr>/OBTS<wbr>_v5<wbr>_kBumanglag<wbr>.pdf*](https://objectivebythesea.org/v5/talks/OBTS_v5_kBumanglag.pdf)。要了解更多关于Mach-O格式的信息，请参考Wardle的《*Mac恶意软件的艺术*》第一卷，第99–123页；Bartosz
    Olszanowski的“Mach-O Reader - 解析Mach-O头部”(*Olszanowski Blog*，2020年5月8日)，详见[*https://<wbr>olszanowski<wbr>.blog<wbr>/posts<wbr>/macho<wbr>-reader<wbr>-parsing<wbr>-headers<wbr>/*](https://olszanowski.blog/posts/macho-reader-parsing-headers/)；以及Alex
    Denisov的“解析Mach-O文件”(*Low Level Bits*，2015年8月20日)，详见[*https://<wbr>lowlevelbits<wbr>.org<wbr>/parsing<wbr>-mach<wbr>-o<wbr>-files<wbr>/*](https://lowlevelbits.org/parsing-mach-o-files/)。'
