- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 2 PARSING BINARIES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, we enumerated running processes and extracted information
    that could help us heuristically detect malware. However, we didn’t cover how
    to examine the actual binary that backed each process. This chapter describes
    how to programmatically parse and analyze universal and Mach-O, the native executable
    binary file format of macOS.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn how to extract information such as a binary’s dependencies and
    symbols, as well as detect whether the binary contains anomalies, such as encrypted
    data or instructions. This information will improve your ability to classify a
    binary as malicious or benign.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Binaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The majority of Mach-O binaries are distributed in universal binaries. Called
    *fat binaries* in Apple parlance, these are containers for multiple architecture-specific
    (but generally logically equivalent) Mach-O binaries known as *slices*. At runtime,
    the macOS dynamic loader (*dyld*) will load and then execute whichever embedded
    Mach-O binary best matches the host’s native architecture (for example, Intel
    or ARM). Because these embedded binaries hold the information you’re looking to
    extract, such as dependencies, you must first understand how to programmatically
    parse the universal binary.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Apple’s file utility can inspect universal binaries. For example, the CloudMensis
    malware is distributed as a universal binary named *WindowServer* containing two
    Mach-O binaries: one compiled for Intel x86_64 and one for Apple Silicon ARM64
    systems. Let’s execute file against CloudMensis. As you can see, the tool identifies
    it as a universal binary and shows its two embedded Mach-Os:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To programmatically access these embedded binaries, we have to parse the universal
    binary’s header, which contains the offset of each Mach-O. Luckily, parsing the
    header is straightforward. Universal binaries start with a fat_header structure.
    We can find relevant universal structures and constants in Apple’s SDK *mach-o/fat.h*
    header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Apple’s comments in this header file indicate that magic, the first member of
    the fat_header structure (an unsigned 32-bit integer), will contain the constant
    FAT_MAGIC or FAT_MAGIC_64. The use of FAT_MAGIC_64 means the next structures are
    of the type fat_arch_64, used when the following slice or offset to it is greater
    than 4GB.^([1](#chapter2-1)) Comments in Apple’s *fat.h* header files note that
    support for this extended format is a work in progress, and universal binaries
    are rarely, if ever, so massive, so we’ll focus on the traditional fat_arch structure
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Not mentioned in the fat_header structure’s comments is the fact that the values
    in the structure are assumed to be big-endian, a vestige of the OSX PPC days.
    Therefore, on little-endian systems such as Intel and Apple Silicon, when you
    read a universal binary into memory, values such as the 4 bytes for magic will
    appear in reverse-byte order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apple accounts for this fact by providing the “swapped” magic constant FAT_CIGAM.
    (Yes, CIGAM is just magic backward.) The hexadecimal value of this constant is
    0xbebafeca.^([2](#chapter2-2)) We can see this value by using xxd to dump the
    bytes at the start of the CloudMensis universal binary. On a little-endian host,
    we make use of the -e flag to display the hexadecimal values in little-endian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output, when interpreted as a 4-byte value, will have the host’s endianness
    applied, which explains why we see the swapped universal magic value FAT_CIGAM
    (0xbebafeca).
  prefs: []
  type: TYPE_NORMAL
- en: Following the magic field in the fat_header structure, we find the nfat_arch
    field, which specifies the number of fat_arch structures. We’ll find one fat_arch
    structure for each architecture-specific Mach-O binary embedded in the universal
    binary. As illustrated in [Figure 2-1](chapter2.xhtml#fig2-1), these structures
    immediately follow the fat header.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: The layout of a universal binary'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because file showed that CloudMensis contained two embedded Mach-Os, we’d expect
    to see nfat_arch set to 2. We confirm that this is the case by using xxd once
    again. This time, though, we skip the -e flag so as to keep the values in big
    endian:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the fat_arch structure definition in the *fat.h* header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first two members of the fat_arch structure specify the CPU type and subtype
    of the Mach-O binary, while the next two specify the offset and size of this slice.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s programmatically parse a universal binary and locate each embedded Mach-O
    binary. We’ll show two methods of doing so: using the older NX* APIs compatible
    with older versions of macOS and the newer Macho* APIs available on macOS 13 and
    newer.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can find the code mentioned in this chapter in the* parseBinary *project
    in the book’s GitHub repository at* [https://github.com/Objective-see/TAOMM*.*](https://github.com/Objective-see/TAOMM)'
  prefs: []
  type: TYPE_NORMAL
- en: NX* APIs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll begin by checking whether the file is indeed a universal binary. Then
    we’ll iterate over all fat_arch structures, printing out their values, and leverage
    the NXFindBestFatArch API to find the embedded binary most compatible with the
    host’s architecture. The system will load and execute this binary when the universal
    binary is launched, so it’s the one we’ll focus on in our analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Your own code may instead want to examine each embedded Mach-O binary, especially
    as nothing stops a developer from making these binaries completely different.
    Although you’ll rarely find this to be the case, the 2023 3CX supply chain attack
    provides one notable exception. To trojanize the 3CX application, attackers subverted
    a legitimate universal binary that contained both Intel and ARM binaries, adding
    malicious code to the former and leaving the ARM binary untouched.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by loading a file and performing some initial checks ([Listing 2-1](chapter2.xhtml#Lis2-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: Loading, validating, and finding the “best” slice of a universal
    binary'
  prefs: []
  type: TYPE_NORMAL
- en: After reading the contents of the file into memory ❶ and typecasting the initial
    bytes to a struct fat_header * ❷, the code checks that it is indeed a universal
    binary ❸. Note that it checks both the big-endian (FAT_MAGIC) and little-endian
    (FAT_CIGAM) versions of the magic value.
  prefs: []
  type: TYPE_NORMAL
- en: To keep things simple, this code doesn’t support the large fat file format.
    Moreover, for production code, you should perform other sanity checks, such as
    ensuring that the file was successfully loaded and that it’s bigger than the size
    of a fat_header structure.
  prefs: []
  type: TYPE_NORMAL
- en: The parsing logic lives in a helper function named parseFat, which you can see
    invoked in [Listing 2-1](chapter2.xhtml#Lis2-1). After printing out the fat header,
    this function will iterate over each fat_arch structure and return the most compatible
    Mach-O slice.
  prefs: []
  type: TYPE_NORMAL
- en: First, though, we must deal with any differences in endianness. The values in
    the fat_header and fat_arch structures are always in big-endian order, so on little-endian
    systems such as Intel and Apple Silicon, we must swap them. To do so, we first
    invoke the NXGetLocalArchInfo API to determine the host’s underlying byte order
    ([Listing 2-2](chapter2.xhtml#Lis2-2)). We’ll use the value returned, a pointer
    to an NXArchInfo structure, to swap the endianness (as well as later, to determine
    the most compatible Mach-O).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: Determining the local machine’s architecture'
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that the NXGetLocalArchInfo and swap_* APIs are marked as deprecated,
    although they’re still available and fully functional at the time of publication.
    You can use replacement macho_* APIs, found in *mach-o/utils.h*, on macOS 13 and
    newer, and you’ll learn about this in the next section. However, until macOS 15,
    one of these new APIs was broken, so you may still want to stick to the older
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we perform the swap with the swap_fat_header and swap_fat_arch functions
    ([Listing 2-3](chapter2.xhtml#Lis2-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-3: Swapping the fat header and fat architecture structures to match
    the host’s byte ordering'
  prefs: []
  type: TYPE_NORMAL
- en: The code first checks whether a swap is needed ❶. Recall that if the magic constant
    of the fat header is FAT_CIGAM, the code is executing on a little-endian host,
    so we should perform a swap. By invoking the helper APIs swap_fat_header ❷ and
    swap_fat_arch ❸, the code converts the header and all fat_arch values to match
    the host’s byte ordering, as returned by NXGetLocalArchInfo. The latter API takes
    the number of fat_arch structures to swap, which the code provides via the nfat_arch
    field of the now-swapped fat header.
  prefs: []
  type: TYPE_NORMAL
- en: Once the header and all fat_arch structures conform to the host’s byte ordering,
    the code can print out details of each embedded Mach-O binary that the fat_arch
    structures describe ([Listing 2-4](chapter2.xhtml#Lis2-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-4: Printing out each fat_arch structure'
  prefs: []
  type: TYPE_NORMAL
- en: The code starts by initializing a pointer to the first fat_arch structure, which
    comes immediately after the fat_header. Then it iterates over each, bounded by
    the nfat_arch member of the fat_header ❶. To print out values from each fat_arch
    structure, the code invokes a helper function we’ve named printFatArch ❷, which
    first separates the CPU subtype and its capabilities, as both are found in the
    cpusubtype member. Apple provides the CPU_SUBTYPE _MASK constant to extract just
    the bits that describe the subtype ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run this code against CloudMensis. It outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, we can see the malware’s two embedded Mach-O binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: At offset 16384, a binary compatible with CPU_TYPE_X86_64 (0x1000007) that is
    708,560 bytes long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At offset 737280, a binary compatible with CPU_TYPE_ARM64 (0x100000c) that is
    688,176 bytes long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To confirm the accuracy of this code, we can compare this output against the
    macOS otool command, whose -f flag parses and displays fat headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the tool’s output, we see the same information about the malware’s two embedded
    binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add some code to determine which of the embedded Mach-O binaries
    matches the host’s native architecture. Recall that we already invoked the NXGetLocalArchInfo
    API to retrieve the host architecture. Moreover, we also showed how to compute
    the offset to the first fat_arch structure, which immediately follows the fat
    header. To find the natively compatible Mach-O, we can now invoke the NXFindBestFatArch
    API ([Listing 2-5](chapter2.xhtml#Lis2-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-5: Determining a universal binary’s best architecture'
  prefs: []
  type: TYPE_NORMAL
- en: We pass the API the host’s architecture, a pointer to the start of the fat _arch
    structures, and the number of these structures. The NXFindBestFatArch API will
    then determine the Mach-O binary from within the universal binary that is the
    most compatible with the host’s native architecture. Recall the parseFat helper
    function returns this value and prints it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add this code to the binary parser and then run it again against CloudMensis,
    it outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: On an Apple Silicon (ARM64) system, the code has correctly determined that the
    second embedded Mach-O binary, with a CPU type of 16777228/0x100000c (CPU_TYPE_ARM64),
    is the most compatible Mach-O in the universal CloudMensis binary. When launching
    this universal binary, we can use the Kind column in Activity Monitor to confirm
    that macOS indeed selected and ran the Apple Silicon Mach-O ([Figure 2-2](chapter2.xhtml#fig2-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: The CloudMensis binary WindowServer running as a native Apple Silicon
    binary'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to confirm that CloudMensis runs as a native Apple Silicon binary
    is to use the *enumerateProcesses* project presented in [Chapter 1](chapter1.xhtml).
    Recall that it extracts the architecture of each running process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We receive the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Macho* APIs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In macOS 13, Apple introduced the macho_* APIs. Found in *mach-o/utils.h*, these
    APIs offer a simplified way to iterate over Mach-O binaries in a universal binary
    and select the most compatible one. The deprecated NX* APIs still work for this
    purpose, but if you’re developing tools on macOS 13 or later, it’s wise to instead
    use the newer functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The macho_for_each_slice API lets us extract a universal binary’s Mach-Os without
    having to manually parse the universal header or deal with the nuances of byte
    orderings. We invoke this function with a path to a file and callback block to
    run for each Mach-O slice. If invoked against a stand-alone Mach-O, the function
    will run its callback just once, and if the file isn’t a well- formed universal
    binary or Mach-O, the function will gracefully fail, meaning we don’t have to
    manually verify the file type ourselves. The *mach-o/utils.h* header file includes
    the possible return values and their meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback block invoked for each embedded Mach-O has the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This type might look a little confusing at first, but if we focus solely on
    the parameters, we see that the callback will be invoked with a variety of information
    about the slice, including a pointer to a mach_header structure, the slice’s offset,
    and its size.
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 2-6](chapter2.xhtml#Lis2-6), part of the parseFat helper
    function, invokes macho_for_each_slice to print out information about each embedded
    Mach-O. It also includes some basic error handling, which we can use to filter
    out files that are neither universal nor Mach-Os.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-6: Iterating over all embedded Mach-Os'
  prefs: []
  type: TYPE_NORMAL
- en: This code invokes the macho_for_each_slice function ❶. In the callback block,
    we print out a counter variable followed by the slice’s offset and size ❷. We
    also make use of the macho_arch_name_for_mach_header function to print out the
    name of each slice’s architecture ❸.
  prefs: []
  type: TYPE_NORMAL
- en: If the user-specified file isn’t a well-formed universal or Mach-O binary, the
    function will fail. The code handles this, printing out a generic error message,
    as well as additional information for common errors ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add this code to the *parseBinary* project and then run it against the
    CloudMensis universal binary, it should print out the same offset and size values
    for the malware’s two embedded Mach-Os as the code that leveraged the NX* APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, what about finding the most compatible slice, or the one that the host
    would load and run if the universal binary were executed? The macho _best_slice
    function is designed to return exactly that. It takes a path to a file to inspect
    and a callback block to invoke with the best slice. Add the function in [Listing
    2-7](chapter2.xhtml#Lis2-7) to the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-7: Invoking macho_best_slice to find the best slice'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this against CloudMensis (on a version of macOS prior to 15), however,
    it fails with the value 86:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: According to the *mach-o/utils.h* header file, this error value maps to EBADARCH,
    which means none of the slices can load. This is odd, considering that the NXFindBestFatArch
    function identified the embedded ARM64 Mach-O binary as compatible with my Apple
    Silicon analysis machine. Moreover, this ARM64 Mach-O definitely runs, as you
    saw in [Figure 2-2](chapter2.xhtml#fig2-2). It turns out, as is often the case
    with new APIs from Apple, that the macho_best_slice function was broken until
    macOS 15\. On older versions of macOS, for any third-party universal binary on
    Apple Silicon systems, the function returns EBADARCH.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reverse engineering, as well as studying the code of *dyld*,^([3](#chapter2-3))
    revealed the cause of the error: instead of passing a list of compatible CPU types
    (such as arm64 or x86_64) to the slice selection function, the code incorrectly
    passed in only the CPU type for which the operating system was compiled. On Apple
    Silicon, this CPU type is arm64e (CPU_SUBTYPE_ARM64E), used exclusively by Apple.
    This explains why the selection logic never chose slices in third-party universal
    binaries, which are compiled as arm64 or x86_64 (but never arm64e), and instead
    returned the EBADARCH error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about the bug in my write-up “Apple Gets an ‘F’ for Slicing
    Apples.”^([4](#chapter2-4)) My analysis proposed a simple fix: instead of invoking
    the GradedArchs::forCurrentOS method, Apple should have invoked GradedArchs::launchCurrentOS
    to obtain the correct list of compatible CPU types. The good news is that Apple
    eventually took this recommendation, meaning that macho_best_slice on macOS 15
    and above works as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to parse universal binaries, let’s turn our attention
    to the Mach-O binaries embedded within them.^([5](#chapter2-5))
  prefs: []
  type: TYPE_NORMAL
- en: Mach-O Headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mach-O binaries contain the information we’re after, such as dependencies and
    symbols. To programmatically extract these, we must parse the Mach-O’s header.
    In a universal binary, we can locate this header by analyzing the fat header and
    architecture structures, as you saw in the previous section. In a single-architecture,
    stand-alone Mach-O, finding the header is trivial, as it’s located at the start
    of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-8](chapter2.xhtml#Lis2-8) follows the code that identifies the best
    Mach-O within a universal binary. It confirms that the slice is indeed a Mach-O,
    then handles cases in which a file is a stand-alone Mach-O.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-8: Finding the relevant Mach-O header'
  prefs: []
  type: TYPE_NORMAL
- en: After loading the file into memory, we typecast the bytes at the start of the
    file to a mach_header_64 structure ❶. If the binary is universal, we find the
    fat_arch structure that describes the most compatible embedded Mach-O. Using this
    structure’s offset member, we update the pointer to point to the embedded binary
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we parse the binary, we must verify that the pointer really points to
    the start of the Mach-O. We take a simple verification approach: checking for
    the presence of a Mach-O magic value ❸. Because the binary’s header and the host
    machine architecture could have different endianness, the code checks for both
    the MH_MAGIC_64 and MH_CIGAM_64 constants, defined in Apple’s *mach-o/loader.h*
    header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of simplicity, the code skips recommended sanity and error checks.
    For example, production code should, at the very minimum, ensure that the size
    of the read-in bytes is greater than sizeof(struct mach_header_64) before dereferencing
    offsets in the header.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Mach-O headers are of type mach_header or mach_header_64. Recent versions
    of macOS support 64-bit code only, so this section focuses on* mach_header_64,
    *defined in* mach-o/loader.h*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re sure we’re looking at a Mach-O, we can parse it. [Listing 2-9](chapter2.xhtml#Lis2-9)
    defines a helper function named parseMachO for this purpose. It takes a pointer
    to the mach_header_64 structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-9: Swapping the Mach-O header to match the host’s byte ordering'
  prefs: []
  type: TYPE_NORMAL
- en: Because the binary’s header and the host machine could have a different endianness,
    the code first checks for the swapped Mach-O magic value. If you encounter it,
    swap the header via the swap_mach_header_64 API. Note here that the code makes
    use of the macOS NXGetLocalArchInfo function, but if you’re writing code for versions
    of macOS 13 or newer, you should use the more modern macho* APIs (again noting
    that the macho_best_slice function was broken until macOS 15).
  prefs: []
  type: TYPE_NORMAL
- en: To print out the Mach-O header, we write a helper function, printMachOHeader
    ([Listing 2-10](chapter2.xhtml#Lis2-10)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-10: Printing out a Mach-O header'
  prefs: []
  type: TYPE_NORMAL
- en: You can find an overview of each header member in the comments of the mach_header_64
    structure definition. For example, following the magic field are the two fields
    that describe the binary’s compatible CPU type and subtype. The cpusubtype member
    also contains the binary’s capabilities, and these can be extracted into their
    own field.
  prefs: []
  type: TYPE_NORMAL
- en: The file type indicates whether the binary is a stand-alone executable or a
    loadable library. The next fields describe the number and size of the binary’s
    load commands, which we’ll make extensive use of shortly. Finally, the flags member
    of the structure indicates additional optional features, such as whether the binary
    is compatible with address space layout randomization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the Mach-O parsing code against CloudMensis. After searching the
    universal header, the tool finds the compatible Mach-O header and then prints
    it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This output matches that of Apple’s otool, whose -h flag instructs it to print
    out the Mach-O header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Running otool with the -v flag converts the returned numerical values into
    symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'These values confirm that our tool works as expected.  ### Load Commands'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load commands are instructions to *dyld* that immediately follow the Mach-O
    header. A header field named ncmds specifies the number of load commands, and
    each command is a structure of type load_command containing the command type (cmd)
    and size (cmdsize), as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Some load commands describe the segments in the binary, such as the __TEXT segment
    that contains the binary’s code, while others describe dependencies, the location
    of the symbol table, and more. As such, code that aims to extract information
    found within Mach-Os will generally start by parsing load commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-11](chapter2.xhtml#Lis2-11) defines a helper function named findLoadCommand
    for this purpose. It takes a pointer to a Mach-O header and the type of load command
    to find. After locating the start of the load commands, it iterates over each
    to create an array containing commands that match the specified type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-11: Iterating over all load commands and collecting those that match
    a specified type'
  prefs: []
  type: TYPE_NORMAL
- en: We start by calculating a pointer to the first load command, which immediately
    follows the Mach-O header ❶. Then we iterate over all load commands, which appear
    one after another ❷, and check the cmd member of each to see if it matches the
    specified type ❸. As we can’t directly store pointers in an Objective-C array,
    we first create an NSValue object with the load command’s address ❹. Finally,
    we advance to the next load command. Load commands can vary in size, so we use
    the current command’s cmdsize field ❺ to find the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an understanding of load commands and a helper function that returns commands
    of interest, let’s now consider a few examples of pertinent information we can
    extract, starting with dependencies.  ### Extracting Dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the reasons to parse Mach-Os is to extract their *dependencies*: dynamic
    libraries that *dyld* will automatically load. Understanding the dependencies
    of a binary can provide insight into its likely capabilities or even uncover malicious
    dependencies. For example, CloudMensis links against the *DiskArbitration* framework,
    which provides APIs to interact with external disks. Using this framework’s APIs,
    the malware monitors for the insertion of removable USB drives so it can exfiltrate
    external files.'
  prefs: []
  type: TYPE_NORMAL
- en: When writing code, we can often achieve the same outcome in several ways. For
    example, in [Chapter 1](chapter1.xhtml), we extracted all loaded libraries and
    frameworks from a running process by leveraging vmmap. In this chapter, we’ll
    perform a similar task by manually parsing the Mach-O. This static approach will
    extract direct dependencies only, excluding recursion; that is to say, we won’t
    extract the dependencies of dependencies. Moreover, libraries directly loaded
    by the binary at runtime are not dependencies per se and thus will not be extracted.
    While simple, this technique should help us understand the Mach-O’s capabilities
    and doesn’t require executing external binaries like vmmap. Also, the code will
    run against any Mach-O binary without requiring it to be currently executing.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Dependency Paths
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To extract a binary’s dependencies, we can enumerate its LC_LOAD_DYLIB load
    commands, each of which contains a path to a library or framework on which the
    Mach-O depends. The dylib_command structure describes these load commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We’ll extract these dependencies in a function named extractDependencies that
    accepts a pointer to a Mach-O header and returns an array containing the names
    of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To keep things simple, we won’t take into account LC_LOAD_WEAK_DYLIB load
    commands, which describe optional dependencies.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 2-12](chapter2.xhtml#Lis2-12), the code starts by invoking the findLoadCommand
    helper function to find load commands whose type is LC_LOAD_DYLIB. It then iterates
    over each of these load commands to extract the dependency’s path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-12: Finding all LC_LOAD_DYLIB load commands'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now extract the name of each dependency. To understand how we’ll do so,
    take a look at the dylib structure that describes a dependency. This structure
    is the last member of the dylib_command structure used to describe LC_LOAD_DYLIB
    load commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Of interest to us is the structure’s name field, whose type is lc_str. A comment
    in Apple’s *loader.h* file explains that we must first extract the offset to the
    dependency path and then use it to compute the path’s bytes and length ([Listing
    2-13](chapter2.xhtml#Lis2-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-13: Extracting a dependency from an LC_LOAD_DYLIB load command'
  prefs: []
  type: TYPE_NORMAL
- en: We previously stored the pointer to each matching load command as an NSValue
    object, so we must first extract these ❶. Then we extract the offset to the dependency
    path and use it to compute the path’s bytes and length ❷. Now we can easily extract
    the path into a string object and save it into an array ❸. We return this array
    containing all dependencies once the enumeration is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we compile and run this code against CloudMensis, it outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the inclusion of the *DiskArbitration* framework we mentioned earlier.
    Once again, we can use otool, this time with the -L flag, to confirm the accuracy
    of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The dependencies extracted from CloudMensis via otool match those extracted
    by our code, so we can move on to analyzing them.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing Dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The majority of CloudMensis’s dependencies are system libraries and frameworks,
    such as *libobjc.A.dylib* and *libSystem.B.dylib*. Essentially all Mach-O binaries
    link against these, and from the point of view of malware detection, they’re uninteresting.
    However, the *DiskArbitration* dependency is notable, as it provides the DA* APIs
    to interact with external disks. Here is a snippet of CloudMensis’s decompiled
    binary code showing its interactions with the *DiskArbitration* APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: First, in a function named loop_usb, the malware invokes various DiskArbitration
    APIs to register a callback that the operating system will invoke automatically
    once a new disk appears ❶. When this OnDiskAppeared callback is invoked—for example,
    when an external USB drive is inserted—it calls other DA* APIs, such as DADiskCopyDescription
    ❷, to access information about the new disk. The remainder of the code in the
    OnDiskAppeared callback is responsible for generating a file listing, then copying
    files off the drive into a custom file store. These files eventually get exfiltrated
    to the attacker’s remote command-and-control server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the dependency code against another malware sample that leverages
    even more frameworks to achieve a wide range of offensive capabilities. Mokes
    is a cross-platform cyber-espionage implant that has infected macOS users in attacks
    leveraging browser zero-days.^([6](#chapter2-6)) Running the dependency extractor
    code against the malware’s binary, named *storeuserd*, generates the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Several of these dependencies shed light on the malware’s capabilities and could
    guide future analysis. For example, the malware leverages the *AVFoundation* framework
    to record audio and video from the mic and webcam of an infected host. It also
    uses CoreWLAN to enumerate and monitor network interfaces and DiskArbitration
    to monitor external storage drives to find and exfiltrate files of interest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, dependencies alone can’t prove that code is malicious. For example,
    a binary that links against the AVFoundation isn’t necessarily spying on the user;
    it might be a legitimate videoconferencing app or simply be making use of the
    framework for benign multimedia-related tasks. However, taking a look at the following
    snippet of disassembly from Mokes confirms that it does indeed leverage AVFoundation
    APIs in a nefarious manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This excerpt shows the code interfacing with the webcam to spy on victims.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to extract dependencies from a Mach-O binary is to detect malicious
    subversions. ZuRu is one such example. Its malware authors surreptitiously trojanized
    popular applications such as iTerm by adding a malicious dependency to them, then
    distributed the applications via sponsored ads that would appear as the first
    result when users searched online for the applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subversion was stealthy, as it left the original application’s functionality
    wholly intact. However, extracting dependencies quickly reveals the malicious
    dependency. To demonstrate this, let’s first extract the dependencies from a legitimate
    copy of iTerm2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing unusual here. Now, if we extract the dependencies from a trojanized
    instance of iTerm, we uncover a new dependency, *libcrypto.2.dylib*, located in
    the application bundle. This dependency sticks out, not only because it doesn’t
    exist in the legitimate application but also because it’s the only dependency
    that uses the @executable_path variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing inherently malicious about the @executable_path variable; it
    simply tells the loader how to relatively resolve the library’s path (meaning
    the library is likely embedded in the same bundle as the executable). Nevertheless,
    the addition of a new dependency that referenced a newly added library clearly
    warranted additional analysis, and such analysis revealed that the dependency
    contained all of the malware’s malicious logic.^([7](#chapter2-7))
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A binary’s symbols contain the names of the binary’s functions or methods and
    those of the APIs it imports. These function names can reveal the file’s capabilities
    and even provide indicators that it is malicious. For example, let’s extract the
    symbols from malware called DazzleSpy using the macOS nm tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: From the format of these symbols, we can tell that the malware was written in
    Objective-C. The Objective-C runtime requires method names to remain intact in
    the compiled binary, so understanding the binaries’ capabilities is often relatively
    easy. For example, the symbols embedded in DazzleSpy reveal methods that appear
    to execute shell commands, survey the system, post mouse events, and steal passwords
    from the keychain.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting, though, that nothing stops malware authors from using misleading
    method names, so you should never draw conclusions solely from extracted symbols.
    You might also encounter symbols that have been obfuscated (providing a pretty
    good indication that the binary has something to hide). Finally, the authors may
    have stripped a binary to remove symbols that aren’t essential for program execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in the nm symbol output for DazzleSpy, we also find APIs that the malware
    imports from system libraries and frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: These include networking APIs such as bind and connect related to the malware’s
    backdoor capabilities, AVFoundation imports related to its remote desktop capabilities,
    and APIs to survey a system and grab items from the victim’s keychain.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we extract a Mach-O binary’s symbols programmatically? As you’ll see,
    this requires yet again parsing the binary’s load commands. We’ll focus specifically
    on the LC_SYMTAB load command, which contains information about a binary’s symbols
    found in the symbol table (hence the load command’s suffix SYMTAB). This load
    command consists of a symtab_command structure, defined in *loader.h*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The symoff member contains the offset of the symbol table, while nsyms contains
    the number of entries in this table. The symbol table consists of nlist_64 structures,
    defined in *nlist.h*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Each nlist_64 structure in the symbol table contains an index to the string
    table, in the n_strx field. We can find the string table’s offset in the symtab_command
    structure’s stroff field. By adding the specified index from n_strx to this offset,
    we can retrieve the symbol as a NULL-terminated string. Thus, to extract a binary’s
    symbols, we must perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Find the LC_SYMTAB load command that contains the symtab_command structure.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Use the symoff member of the symtab_command structure to find the offset
    of the symbol table.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Use the stroff member of the symtab_command structure to find the offset
    of the string table.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Iterate through all of the symbol table’s nlist_64 structures to extract
    each symbol’s index (n_strx) into the string table.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Apply this index to the string table to find the name of the symbol.
  prefs: []
  type: TYPE_NORMAL
- en: The function in [Listing 2-14](chapter2.xhtml#Lis2-14) implements these steps.
    Given a pointer to a Mach-O header, it saves all symbols into an array and returns
    it to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-14: Extracting a binary’s symbols'
  prefs: []
  type: TYPE_NORMAL
- en: Because this function is somewhat involved, we’ll walk through it in detail.
    First, it finds the LC_SYMTAB load command by means of the findLoadCommand helper
    function ❶. It then uses the fields in the load command’s symtab _command structure
    to compute the in-memory address of both the symbol table ❷ and the string table
    ❸. After initializing a pointer to the first nlist_64 structure, found at the
    start of the symbol table ❹, the code iterates over it and all subsequent nlist_64
    structures ❺. For each of these structures, it adds the index to the string table
    to compute the address of the symbol’s string representation ❻. If the symbol
    is not NULL, the code adds it to an array to return to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compile and run this code against DazzleSpy. As we can see, the code
    is able to extract the malware’s method names, as well as the API imports it invokes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The ability to extract symbols from any Mach-O binary will improve our heuristic
    malware detection. Next, we’ll programmatically detect anomalous characteristics
    that often indicate a binary is up to something nefarious.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Newer binaries may contain a LC_DYLD_CHAINED_FIXUPS load command that optimizes
    how symbols and imports are handled on recent versions of macOS. In this case,
    a different approach is needed to extract embedded symbols. See the* extractChainedSymbols
    *function in the* parseBinary *project for more details and a programmatic implementation
    of such extraction.*'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Packed Binaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *executable packer* is a tool that compresses binary code to shrink its size
    for distribution. The packer inserts a small unpacker stub at the binary’s entry
    point, and this stub executes automatically when the packed program is run, restoring
    the original code in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Malware authors are quite fond of packers, as compressed code is more difficult
    to analyze. Moreover, certain packers encrypt or further obfuscate the binary
    in an attempt to thwart signature-based detections and complicate analysis. Legitimate
    software is rarely packed on macOS, so the ability to detect obfuscation can be
    a powerful heuristic for flagging binaries that warrant closer inspection.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll wrap up this chapter by showing how to detect packed and encrypted Mach-O
    binaries by looking for a lack of dependencies and symbols, anomalous section
    and segment names, and high entropy.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies and Symbols
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One simple, albeit somewhat naive, approach to packer detection is enumerating
    a binary’s dependencies and symbols—or, rather, lack thereof. Nonpacked binaries
    will always have dependencies on various system frameworks and libraries such
    as *libSystem.B.dylib*, as well as imports from these dependencies. Packed binaries,
    on the other hand, may lack even a single dependency or symbol, as the unpacker
    stub will dynamically resolve and load any required libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'A binary with no dependencies or symbols is, at the very least, anomalous,
    and our tool should flag it for analysis. For example, running the dependency
    and symbol extraction code against the oRAT malware finds no dependencies or symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Apple’s otool and nm confirm this absence as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: It turns out oRAT is packed via UPX, a cross-platform packer that Mac malware
    authors favor. Examples of other macOS malware packed with UPX include IPStorm,
    ZuRu, and Coldroot.
  prefs: []
  type: TYPE_NORMAL
- en: Section and Segment Names
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Binaries packed with UPX may contain UPX-specific section or segment names,
    such as __XHDR, UPX_DATA, or upxTEXT. If we find these names when parsing a Mach-O
    binary’s segments, we can conclude that the binary was packed. Other packers,
    such as MPress, add their own segment names, such as __MPRESS__.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet, from UPX’s *p_mach.cpp* file,^([8](#chapter2-8))
    shows references to nonstandard segment names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve a binary’s section and segment names, we can iterate through its
    load commands, looking for those of type LC_SEGMENT_64. These load commands consist
    of segment_command_64 structures that contain a member named segname with the
    name of the segment. Here is the segment_command_64 structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Any sections within the segment should immediately follow the segment _command_64
    structure, whose nsects member specifies the number of sections. The section_64
    structure, shown here, describes sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Since the segment name can be extracted from the segment_command_64 structure,
    here we’re solely interested in the section name, sectname. To detect packers
    such as UPX, our code can iterate through each segment and its sections, comparing
    the names with those of common packers. First, though, we need a function that
    accepts a Mach-O header, then extracts the binary’s segments and sections. The
    extractSegmentsAndSections function partially shown in [Listing 2-15](chapter2.xhtml#Lis2-15)
    does exactly this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-15: Retrieving a list of LC_SEGMENT_64 load commands'
  prefs: []
  type: TYPE_NORMAL
- en: This code declares a few variables and then invokes the now-familiar findLoadCommand
    helper function with a value of LC_SEGMENT_64. Now that we have a list of the
    load commands describing each segment in the binary, we can iterate over each,
    saving their names and the names of all their sections ([Listing 2-16](chapter2.xhtml#Lis2-16)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-16: Iterating over each segment and its sections to extract their
    names'
  prefs: []
  type: TYPE_NORMAL
- en: After extracting the pointer to each LC_SEGMENT_64 and saving it into a struct
    segment_command_64* ❶, the code extracts the name of the segment from the segname
    member of the segment_command_64 structure, stored in a rather unwieldy (and not
    necessarily NULL-terminated) char array. The code converts it into a string object,
    trims any NULLs, and then saves it into an array to return to the caller ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we iterate over the section_64 structures found in the LC_SEGMENT_64 command.
    One structure exists for each section in the segment. Because they begin immediately
    after the segment_command_64 structure, we initialize a pointer to the first section_64
    structure, adding the start of the segment _command_64 structure to the size of
    this structure ❸. Now we can iterate over each section structure, bounded by the
    nsects member of the segment structure ❹. As with each segment name, we extract,
    convert, trim, and save the section names ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve extracted all segment and section names, we pass this list to a simple
    helper function named isPacked. Shown in [Listing 2-17](chapter2.xhtml#Lis2-17),
    it checks whether any names match those of well-known packers, such as UPX and
    MPress.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-17: Checking for segment and section names matching those of known
    packers'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize a set with a few well-known packer-related segment and
    section names ❶. Then we convert the list of segments and sections into a mutable
    set ❷, as mutable set objects support the intersectSet: method, which will remove
    any items in the first set that aren’t in the second. Once we’ve called this method
    ❸, the only names left in the set of segment and section names will match the
    packer-related ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding this code to the *parseBinary* project, we can run it against
    the macOS variant of the IPStorm malware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Because the IPStorm binary contains a section named upxTEXT indicative of UPX,
    our code correctly ascertains that the binary is packed.
  prefs: []
  type: TYPE_NORMAL
- en: This name-based approach to packer detection has a low false-positive detection
    rate. However, it won’t detect custom packers or even modified versions of known
    packers. For example, if an attacker modifies UPX to remove custom section names
    (which, as UPX is open source, is easy to do), we’ll have a false negative, and
    the packed binary won’t be detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We find an example of this behavior in the malware known as Ocean- Lotus. In
    variant *H*, its authors packed the binary, *flashlightd*, with a customized version
    of UPX. Our current packer detector fails to determine that the malware is packed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we manually examine the malware, it becomes fairly obvious that
    the binary is packed. In a disassembler, large chunks of the binary appear obfuscated.
    We can also see that the binary contains no symbols or dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, our packer detection approach needs some improvement. You’ll see how
    to detect packed binaries via their entropy next.
  prefs: []
  type: TYPE_NORMAL
- en: Entropy Calculations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a binary is packed, the amount of randomness in it greatly increases. This
    is largely due to the fact that packers either compress or encrypt the binary’s
    original instructions. If we can calculate a binary’s quantity of unique bytes
    and classify it as anomalously high, we can fairly accurately conclude the binary
    is packed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s parse a Mach-O binary and calculate the entropy of its executable segments.
    The code in [Listing 2-18](chapter2.xhtml#Lis2-18) builds on the segment parsing
    code in the isPackedByEntropy function. After enumerating all LC_SEGMENT_64 load
    commands, the function invokes a helper function named calcEntropy on each to
    calculate the entropy of the segment’s data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-18: Computing the Shannon entropy'
  prefs: []
  type: TYPE_NORMAL
- en: The function first computes the number of occurrences of each byte value, from
    0 to 0xFF ❶. After skipping values that don’t occur ❷, it performs a standard
    formula ❸ to compute the Shannon entropy.^([9](#chapter2-9)) The function should
    return a value between 0.0 and 8.0, ranging from no entropy (meaning all the values
    are the same) to the highest level of entropy.^([10](#chapter2-10))
  prefs: []
  type: TYPE_NORMAL
- en: The code uses the entropy to determine whether the binary is likely packed ([Listing
    2-19](chapter2.xhtml#Lis2-19)). It’s inspired by the popular Windows-centric AnalyzePE
    and pefile Python libraries.^([11](#chapter2-11))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-19: Packer detection via entropy analysis'
  prefs: []
  type: TYPE_NORMAL
- en: Testing has shown that if the entropy of an average-size segment is above 7.0,
    we can confidently conclude that the segment contains compressed data, meaning
    it’s either packed or encrypted. In this case, we append the segment’s size to
    a variable to keep track of the total amount of compressed data ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve computed the entropy of each segment, we check how much of the binary’s
    total data is packed by dividing the amount of compressed data by the size of
    the Mach-O. Research has shown that Mach-O binaries with a ratio of packed data
    to overall length greater than 20 percent are likely packed (though the ratio
    is usually much higher) ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this code against the packed IPStorm sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Hooray! The code correctly detected that the malware is packed. This is because
    the __TEXT segment has a very high entropy (7.884 out of 8), and because it’s
    the only segment containing any data, the ratio of packed data to the overall
    binary length is very high. Equally important is the fact that the code correctly
    determined that an unpacked version of the malware is indeed no longer packed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this unpacked binary, the tool detects more segments, but all have an entropy
    of around 6 or below. Thus, it doesn’t classify any of them as containing compressed
    data, so the ratio of compressed data to binary size is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ve seen, this entropy-based approach can generically detect almost any
    packed binary, regardless of the packer used. This holds true even in the case
    of OceanLotus, whose authors used a customized version of UPX in an attempt to
    avoid detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Although the packed malware doesn’t contain any segments or sections that match
    known packers, the large __TEXT segment contains a very high amount of entropy
    (7.5+). As such, the code correctly determines that the OceanLotus sample is packed.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Encrypted Binaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While Apple encrypts the Intel versions of various system binaries, encrypted
    third-party binaries are rarely legitimate, and you should flag these for closer
    analysis. *Binary encryptors* encrypt the original malware code at the binary
    level. To automatically decrypt the malware at runtime, the encryptor will often
    insert a decryption stub and keying information at the start of the binary unless
    the operating system natively supports encrypted binaries, which macOS does.
  prefs: []
  type: TYPE_NORMAL
- en: As with packed binaries, we can detect encrypted binaries using entropy calculations,
    as any well-encrypted file will have a very high level of randomness. Thus, the
    code provided in the previous section should identify them. However, you might
    find it worthwhile to write code that focuses specifically on detecting binaries
    encrypted with the native macOS encryption scheme. The encryption scheme is undocumented
    and proprietary, so any third-party binary leveraging it should be treated as
    suspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see in the open source macOS Mach-O loader^([12](#chapter2-12)) how
    to detect such binaries. In the loader’s code, we find mention of an LC_SEGMENT_64
    flag value named SG_PROTECTED_VERSION_1 whose value is 0x8. As explained in Apple’s
    *mach-o/loader.h* file, this means the segment is encrypted with Apple’s proprietary
    encryption scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Usually, malware will encrypt only the __TEXT segment, which contains the binary’s
    executable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it’s rare to discover malware leveraging this proprietary encryption
    scheme, we find an example in a HackingTeam implant installer. Using otool, let’s
    dump the load commands of this binary. Sure enough, the flags of the __TEXT segment
    are set to SG_PROTECTED_VERSION_1 (0x8):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: To detect if a binary is encrypted using this native encryption scheme, we can
    simply iterate over its LC_SEGMENT_64 load commands, looking for any that have
    the SG_PROTECTED_VERSION_1 bits set in the flags member of the segment_command_64
    structure ([Listing 2-20](chapter2.xhtml#Lis2-20)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-20: Checking whether a segment is encrypted with the native macOS
    encryption scheme'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter has focused on 64-bit Mach-Os, but the HackingTeam installer is
    almost 10 years old and was distributed as a 32-bit Intel binary, which isn’t
    compatible with recent versions of macOS. To write code capable of detecting HackingTeam’s
    32-bit installer, we’d have to make sure it uses the 32-bit versions of the Mach-O
    structures, such as mach_header and LC_SEGMENT.^([13](#chapter2-13)) If we made
    these changes and ran the code against the installer, it would correctly flag
    the binary as leveraging Apple’s proprietary encryption scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We noted that though macOS does natively support encrypted binaries, because
    this is not documented, any third-party binary that is encrypted in this manner
    should be closely examined, as it may be malware with something to hide.^([14](#chapter2-14))
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to confirm that a file is a Mach-O or a universal
    binary containing Mach-Os. Then you extracted dependencies and names and detected
    whether the binary was packed or encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are many other interesting things you could do with a Mach-O
    binary to classify it as benign or malicious. Take a look at Kimo Bumanglag’s
    Objective by the Sea talk for ideas.^([15](#chapter2-15))
  prefs: []
  type: TYPE_NORMAL
- en: 'A final thought: I’ve noted that no single data point covered in this chapter
    can definitively indicate that a binary is malicious. For example, nothing stops
    legitimate developers from packing their binaries. Luckily, we have another powerful
    mechanism at our disposal to detect malware: code signing. [Chapter 3](chapter3.xhtml)
    is dedicated to this topic. Read on!'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[  1](#chapter2_1).  UniqMartin, comment on “FatArch64,” Homebrew, July 7,
    2018, [*https://<wbr>github<wbr>.com<wbr>/Homebrew<wbr>/ruby<wbr>-macho<wbr>/issues<wbr>/101#issuecomment<wbr>-403202114*](https://github.com/Homebrew/ruby-macho/issues/101#issuecomment-403202114).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  2](#chapter2_2).  “magic,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/kernel<wbr>/fat<wbr>_header<wbr>/1558632<wbr>-magic*](https://developer.apple.com/documentation/kernel/fat_header/1558632-magic).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  3](#chapter2_3).  See *utils.cpp* at [*https://<wbr>github<wbr>.com<wbr>/apple<wbr>-oss<wbr>-distributions<wbr>/dyld<wbr>/blob<wbr>/d1a0f6869ece370913a3f749617e457f3b4cd7c4<wbr>/libdyld<wbr>/utils<wbr>.cpp*](https://github.com/apple-oss-distributions/dyld/blob/d1a0f6869ece370913a3f749617e457f3b4cd7c4/libdyld/utils.cpp).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  4](#chapter2_4).  Patrick Wardle, “Apple Gets an ‘F’ for Slicing Apples,”
    Objective-See, February 22, 2024, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x80<wbr>.html*](https://objective-see.org/blog/blog_0x80.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  5](#chapter2_5).  For more on universal binaries, see Howard Oakley, “Universal
    Binaries: Inside Fat Headers,” *The Eclectic Light Company*, July 28, 2020, [*https://<wbr>eclecticlight<wbr>.co<wbr>/2020<wbr>/07<wbr>/28<wbr>/universal<wbr>-binaries<wbr>-inside<wbr>-fat<wbr>-headers<wbr>/*](https://eclecticlight.co/2020/07/28/universal-binaries-inside-fat-headers/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  6](#chapter2_6).  Patrick Wardle, “Burned by Fire(fox),” Objective-See,
    June 23, 2019, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x45<wbr>.html*](https://objective-see.org/blog/blog_0x45.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  7](#chapter2_7).  For more details on ZuRu, see Patrick Wardle, “Made in
    China: OSX.ZuRu,” Objective-See, September 14, 2021, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x66<wbr>.html*](https://objective-see.org/blog/blog_0x66.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  8](#chapter2_8).  See [*https://<wbr>upx<wbr>.github<wbr>.io*](https://upx.github.io).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  9](#chapter2_9).  “Entropy (information theory),” Wikipedia, [*https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Entropy<wbr>_(information<wbr>_theory)*](https://en.wikipedia.org/wiki/Entropy_(information_theory).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[10](#chapter2_10).  To gain a deeper understanding of entropy, see Ms Aerin,
    “The Intuition Behind Shannon’s Entropy,” Towards Data Science, September 30,
    2018, [*https://<wbr>towardsdatascience<wbr>.com<wbr>/the<wbr>-intuition<wbr>-behind<wbr>-shannons<wbr>-entropy<wbr>-e74820fe9800*](https://towardsdatascience.com/the-intuition-behind-shannons-entropy-e74820fe9800).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[11](#chapter2_11).  See [*https://<wbr>github<wbr>.com<wbr>/hiddenillusion<wbr>/AnalyzePE<wbr>/blob<wbr>/master<wbr>/peutils<wbr>.py*](https://github.com/hiddenillusion/AnalyzePE/blob/master/peutils.py)
    and [*https://<wbr>github<wbr>.com<wbr>/erocarrera<wbr>/pefile<wbr>/blob<wbr>/master<wbr>/pefile<wbr>.py*](https://github.com/erocarrera/pefile/blob/master/pefile.py).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[12](#chapter2_12).  See [*https://<wbr>opensource<wbr>.apple<wbr>.com<wbr>/source<wbr>/xnu<wbr>/xnu<wbr>-7195<wbr>.81<wbr>.3<wbr>/EXTERNAL<wbr>_HEADERS<wbr>/mach<wbr>-o<wbr>/loader<wbr>.h*](https://opensource.apple.com/source/xnu/xnu-7195.81.3/EXTERNAL_HEADERS/mach-o/loader.h).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[13](#chapter2_13).  For more details about HackingTeam’s encrypted installer,
    see Patrick Wardle, “HackingTeam Reborn; A Brief Analysis of an RCS Implant Installer,”
    Objective-See, February 26, 2016, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x0D<wbr>.html*](https://objective-see.org/blog/blog_0x0D.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[14](#chapter2_14).  You can read more about the macOS support of encrypted
    binaries and how to decrypt them in Patrick Wardle, *The Art of Mac Malware: The
    Guide to Analyzing Malicious Software*, Volume 1 (San Francisco: No Starch Press,
    2022), 187–218, or in Amit Singh, “ ‘TPM DRM’ in Mac OS X: A Myth That Won’t Die,”
    *OSX Book*, December 2007, [*https://<wbr>web<wbr>.archive<wbr>.org<wbr>/web<wbr>/20200603015401<wbr>/http:<wbr>/<wbr>/osxbook<wbr>.com<wbr>/book<wbr>/bonus<wbr>/chapter7<wbr>/tpmdrmmyth<wbr>/*](https://web.archive.org/web/20200603015401/http://osxbook.com/book/bonus/chapter7/tpmdrmmyth/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[15](#chapter2_15).  Kimo Bumanglag, “Learning How to Machine Learn,” paper
    presented at Objective by the Sea v5, Spain, October 6, 2022, [*https://<wbr>objectivebythesea<wbr>.org<wbr>/v5<wbr>/talks<wbr>/OBTS<wbr>_v5<wbr>_kBumanglag<wbr>.pdf*](https://objectivebythesea.org/v5/talks/OBTS_v5_kBumanglag.pdf).
    To learn more about the Mach-O format in general, consult Wardle, *The Art of
    Mac Malware*, 1:99–123; Bartosz Olszanowski, “Mach-O Reader - Parsing Mach-O Headers,”
    *Olszanowski Blog*, May 8, 2020, [*https://<wbr>olszanowski<wbr>.blog<wbr>/posts<wbr>/macho<wbr>-reader<wbr>-parsing<wbr>-headers<wbr>/*](https://olszanowski.blog/posts/macho-reader-parsing-headers/);
    and Alex Denisov, “Parsing Mach-O Files,” *Low Level Bits*, August 20, 2015, [*https://<wbr>lowlevelbits<wbr>.org<wbr>/parsing<wbr>-mach<wbr>-o<wbr>-files<wbr>/*](https://lowlevelbits.org/parsing-mach-o-files/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
