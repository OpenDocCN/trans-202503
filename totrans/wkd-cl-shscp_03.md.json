["```\n#!/bin/bash\n\n# How many commands: a simple script to count how many executable\n#   commands are in your current PATH\n\nIFS=\":\"\ncount=0 ; nonex=0\nfor directory in $PATH ;  do\n  if [ -d \"$directory\" ] ; then\n    for command in \"$directory\"/* ; do\n      if [ -x \"$command\" ] ; then\n        count=\"$(( $count + 1 ))\"\n      else\n        nonex=\"$(( $nonex + 1 ))\"\n      fi\n    done\n  fi\ndone\n\necho \"$count commands, and $nonex entries that weren't executable\"\n\nexit 0\n```", "```\n   #!/bin/bash\n\n   # fmt--Text formatting utility that acts as a wrapper for nroff\n   #   Adds two useful flags: -w X for line width\n   #   and -h to enable hyphenation for better fills\n➊ while getopts \"hw:\" opt; do\n     case $opt in\n       h ) hyph=1              ;;\n       w ) width=\"$OPTARG\"     ;;\n     esac\n   done\n➋ shift $(($OPTIND - 1))\n\n➌ nroff << EOF\n➍ .ll ${width:-72}\n   .na\n   .hy ${hyph:-0}\n   .pl 1\n➎ $(cat \"$@\")\n   EOF\n\n   exit 0\n```", "```\n$ fmt -h -w 50 014-ragged.txt\nSo she sat on, with closed eyes, and half believed\nherself in Wonderland, though she knew she had but\nto open them again, and all would change to dull\nreality--the grass would be only rustling in the\nwind, and the pool rippling to the waving of the\nreeds--the rattling teacups would change to tin-\nkling sheep-bells, and the Queen's shrill cries\nto the voice of the shepherd boy--and the sneeze\nof the baby, the shriek of the Gryphon, and all\nthe other queer noises, would change (she knew) to\nthe confused clamour of the busy farm-yard--while\nthe lowing of the cattle in the distance would\ntake the place of the Mock Turtle's heavy sobs.\n```", "```\n$ fmt 014-ragged.txt\nSo she sat on, with closed eyes, and half believed herself in\nWonderland, though she knew she had but to open them again, and all\nwould change to dull reality--the grass would be only rustling in the\nwind, and the pool rippling to the waving of the reeds--the rattling\nteacups would change to tinkling sheep-bells, and the Queen's shrill\ncries to the voice of the shepherd boy--and the sneeze of the baby, the\nshriek of the Gryphon, and all the other queer noises, would change (she\nknew) to the confused clamour of the busy farm-yard--while the lowing of\nthe cattle in the distance would take the place of the Mock Turtle's\nheavy sobs.\n```", "```\n   #!/bin/bash\n\n   # newrm--A replacement for the existing rm command.\n   #   This script provides a rudimentary unremove capability by creating and\n   #   utilizing a new directory within the user's home directory. It can handle\n   #   directories of content as well as individual files. If the user specifies\n   #   the -f flag, files are removed and NOT archived.\n\n   # Big Important Warning: You'll want a cron job or something similar to keep\n   #   the trash directories tamed. Otherwise, nothing will ever actually\n   #   be deleted from the system, and you'll run out of disk space!\n\n   archivedir=\"$HOME/.deleted-files\"\n   realrm=\"$(which rm)\"\n   copy=\"$(which cp) -R\"\n\n   if [ $# -eq 0 ] ; then            # Let 'rm' output the usage error.\n     exec $realrm                    # Our shell is replaced by /bin/rm.\n   fi\n\n   # Parse all options looking for '-f'\n\n   flags=\"\"\n\n   while getopts \"dfiPRrvW\" opt\n   do\n     case $opt in\n       f ) exec $realrm \"$@\"     ;;  # exec lets us exit this script directly.\n       * ) flags=\"$flags -$opt\"  ;;  # Other flags are for rm, not us.\n     esac\n   done\n   shift $(( $OPTIND - 1 ))\n\n   # BEGIN MAIN SCRIPT\n   # =================\n\n   # Make sure that the $archivedir exists.\n\n➊ if [ ! -d $archivedir] ; then\n     if [ ! -w $HOME ] ; then\n       echo \"$0 failed: can't create $archivedir in $HOME\" >&2\n       exit 1\n     fi\n     mkdir $archivedir\n➋   chmod 700 $archivedir           # A little bit of privacy, please.\n   fi\n\n   for arg\n   do\n➌   newname=\"$archivedir/$(date \"+%S.%M.%H.%d.%m\").$(basename \"$arg\")\"\n     if [ -f \"$arg\" -o -d \"$arg\" ] ; then\n       $copy \"$arg\" \"$newname\"\n     fi\n   done\n\n➍ exec $realrm $flags \"$@\"          # Our shell is replaced by realrm.\n```", "```\nnewname=\"$archivedir/$(date \"+\"%S.%M.%H.%d.%m\").$(basename \"$arg\")\"\n```", "```\nalias rm=yourpath/newrm\n```", "```\n$ ls ~/.deleted-files\nls: /Users/taylor/.deleted-files/: No such file or directory\n$ newrm file-to-keep-forever\n$ ls ~/.deleted-files/\n51.36.16.25.03.file-to-keep-forever\n```", "```\nnewname=\"$archivedir/$(date \"+\"%S.%M.%H.%d.%m\").$(basename \"$arg\")\"\n```", "```\n   #!/bin/bash\n\n   # unrm--Searches the deleted files archive for the specified file or\n   #   directory. If there is more than one matching result, it shows a list\n   #   of results ordered by timestamp and lets the user specify which one\n   #   to restore.\n\n   archivedir=\"$HOME/.deleted-files\"\n   realrm=\"$(which rm)\"\n   move=\"$(which mv)\"\n\n   dest=$(pwd)\n\n   if [ ! -d $archivedir ] ; then\n     echo \"$0: No deleted files directory: nothing to unrm\" >&2\n     exit 1\n   fi\n cd $archivedir\n\n   # If given no arguments, just show a listing of the deleted files.\n➊ if [ $# -eq 0 ] ; then\n     echo \"Contents of your deleted files archive (sorted by date):\"\n➋   ls -FC | sed -e 's/\\([[:digit:]][[:digit:]]\\.\\)\\{5\\}//g' \\\n       -e 's/^/ /'\n     exit 0\n   fi\n\n   # Otherwise, we must have a user-specified pattern to work with.\n   #   Let's see if the pattern matches more than one file or directory\n   #   in the archive.\n\n➌ matches=\"$(ls -d *\"$1\" 2> /dev/null | wc -l)\"\n\n   if [ $matches -eq 0 ] ; then\n     echo \"No match for \\\"$1\\\" in the deleted file archive.\" >&2\n     exit 1\n   fi\n\n➍ if [ $matches -gt 1 ] ; then\n     echo \"More than one file or directory match in the archive:\"\n     index=1\n     for name in $(ls -td *\"$1\")\n     do\n       datetime=\"$(echo $name | cut -c1-14| \\\n➎       awk -F. '{ print $5\"/\"$4\" at \"$3\":\"$2\":\"$1 }')\"\n       filename=\"$(echo $name | cut -c16-)\"\n       if [ -d $name ] ; then\n➏      filecount=\"$(ls $name | wc -l | sed 's/[^[:digit:]]//g')\"\n         echo \" $index) $filename (contents = ${filecount} items,\" \\\n              \" deleted = $datetime)\"\n       else\n➐       size=\"$(ls -sdk1 $name | awk '{print $1}')\"\n         echo \" $index) $filename (size = ${size}Kb, deleted = $datetime)\"\n       fi\n       index=$(( $index + 1))\n     done\n     echo \"\"\n     /bin/echo -n \"Which version of $1 should I restore ('0' to quit)? [1] : \"\n     read desired\n     if [ ! -z \"$(echo $desired | sed 's/[[:digit:]]//g')\" ] ; then\n       echo \"$0: Restore canceled by user: invalid input.\" >&2\n       exit 1\n     fi\n\n     if [ ${desired:=1} -ge $index ] ; then\n       echo \"$0: Restore canceled by user: index value too big.\" >&2\n       exit 1\n     fi\n\n if [ $desired -lt 1 ] ; then\n       echo \"$0: Restore canceled by user.\" >&2\n       exit 1\n     fi\n\n➑   restore=\"$(ls -td1 *\"$1\" | sed -n \"${desired}p\")\"\n\n➒   if [ -e \"$dest/$1\" ] ; then\n       echo \"\\\"$1\\\" already exists in this directory. Cannot overwrite.\" >&2\n       exit 1\n     fi\n\n     /bin/echo -n \"Restoring file \\\"$1\\\" ...\"\n     $move \"$restore\" \"$dest/$1\"\n     echo \"done.\"\n\n➓   /bin/echo -n \"Delete the additional copies of this file? [y] \"\n     read answer\n\n     if [ ${answer:=y} = \"y\" ] ; then\n       $realrm -rf *\"$1\"\n       echo \"Deleted.\"\n     else\n       echo \"Additional copies retained.\"\n     fi\n   else\n     if [ -e \"$dest/$1\" ] ; then\n       echo \"\\\"$1\\\" already exists in this directory. Cannot overwrite.\" >&2\n       exit 1\n     fi\n\n     restore=\"$(ls -d *\"$1\")\"\n\n     /bin/echo -n \"Restoring file \\\"$1\\\" ... \"\n     $move \"$restore\" \"$dest/$1\"\n     echo \"Done.\"\n   fi\n\n   exit 0\n```", "```\n$ unrm\nContents of your deleted files archive (sorted by date):\n  detritus            this is a test\n  detritus            garbage\n```", "```\n$ unrm detritus\nMore than one file or directory match in the archive:\n 1)   detritus (size = 7688Kb, deleted = 11/29 at 10:00:12)\n 2)   detritus  (size = 4Kb, deleted = 11/29 at 09:59:51)\n\nWhich version of detritus should I restore ('0' to quit)? [1] : 0\nunrm: Restore canceled by user.\n```", "```\n   #!/bin/bash\n   # logrm--Logs all file deletion requests unless the -s flag is used\n\n   removelog=\"/var/log/remove.log\"\n\n➊ if [ $# -eq 0 ] ; then\n     echo \"Usage: $0 [-s] list of files or directories\" >&2\n     exit 1\n   fi\n\n➋ if [ \"$1\" = \"-s\" ] ; then\n     # Silent operation requested ... don't log.\n     shift\n   else\n➌   echo \"$(date): ${USER}: $@\" >> $removelog\n   fi\n\n➍ /bin/rm \"$@\"\n\n   exit 0\n```", "```\nalias rm=logrm\n```", "```\n$ touch unused.file ciao.c /tmp/junkit\n$ logrm unused.file /tmp/junkit\n$ logrm ciao.c\n$ cat /var/log/remove.log\nThu Apr  6 11:32:05 MDT 2017: susan: /tmp/central.log\nFri Apr  7 14:25:11 MDT 2017: taylor: unused.file /tmp/junkit\nFri Apr  7 14:25:14 MDT 2017: taylor: ciao.c\n```", "```\nlogger -t logrm \"${USER:-LOGNAME}: $*\"\n```", "```\ndrwxrwxr-x    2 taylor   taylor        4096 Oct 28 19:07 bin\n```", "```\n   #!/bin/bash\n\n   # formatdir--Outputs a directory listing in a friendly and useful format\n\n   # Note that you need to ensure \"scriptbc\" (Script #9) is in your current path\n   #   because it's invoked within the script more than once.\n\n   scriptbc=$(which scriptbc)\n\n   # Function to format sizes in KB to KB, MB, or GB for more readable output\n➊ readablesize()\n   {\n\n     if [ $1 -ge 1048576 ] ; then\n       echo \"$($scriptbc -p 2 $1 / 1048576)GB\"\n     elif [ $1 -ge 1024 ] ; then\n       echo \"$($scriptbc -p 2 $1 / 1024)MB\"\n     else\n       echo \"${1}KB\"\n     fi\n   }\n\n   #################\n   ## MAIN CODE\n\n   if [ $# -gt 1 ] ; then\n     echo \"Usage: $0 [dirname]\" >&2\n     exit 1\n➋ elif [ $# -eq 1 ] ; then   # Specified a directory other than the current one?\n     cd \"$@\"                  # Then let's change to that one.\n     if [ $? -ne 0 ] ; then   # Or quit if the directory doesn't exist.\n       exit 1\n     fi\n   fi\n\n   for file in *\n   do\n     if [ -d \"$file\" ] ; then\n➌     size=$(ls \"$file\" | wc -l | sed 's/[^[:digit:]]//g')\n       if [ $size -eq 1 ] ; then\n         echo \"$file ($size entry)|\"\n       else\n         echo \"$file ($size entries)|\"\n       fi\n     else\n       size=\"$(ls -sk \"$file\" | awk '{print $1}')\"\n➍     echo \"$file ($(readablesize $size))|\"\n     fi\n   done | \\\n➎   sed 's/ /^^^/g' | \\\n     xargs -n 2 | \\\n     sed 's/\\^\\^\\^/ /g' | \\\n➏   awk -F\\| '{ printf \"%-39s %-39s\\n\", $1, $2 }'\n\n   exit 0\n```", "```\necho \"$file ($(readablesize $size))|\"\n```", "```\nsize=$(ls \"$file\" | wc -l | sed 's/[^[:digit:]]//g')\n```", "```\n$ formatdir ~\nApplications (0 entries)                Classes (4KB)\nDEMO (5 entries)                        Desktop (8 entries)\nDocuments (38 entries)                  Incomplete (9 entries)\nIntermediateHTML (3 entries)            Library (38 entries)\nMovies (1 entry)                        Music (1 entry)\nNetInfo (9 entries)                     Pictures (38 entries)\nPublic (1 entry)                        RedHat 7.2 (2.08GB)\nShared (4 entries)                      Synchronize! Volume ID (4KB)\nX Desktop (4KB)                         automatic-updates.txt (4KB)\nbin (31 entries)                        cal-liability.tar.gz (104KB)\ncbhma.tar.gz (376KB)                    errata (2 entries)\nfire aliases (4KB)                      games (3 entries)\njunk (4KB)                              leftside navbar (39 entries)\nmail (2 entries)                        perinatal.org (0 entries)\nscripts.old (46 entries)                test.sh (4KB)\ntestfeatures.sh (4KB)                   topcheck (3 entries)\ntweakmktargs.c (4KB)                    websites.tar.gz (18.85MB)\n```", "```\n   #!/bin/bash\n\n   # mklocatedb--Builds the locate database using find. User must be root\n   #   to run this script.\n\n   locatedb=\"/var/locate.db\"\n\n➊ if [ \"$(whoami)\" != \"root\" ] ; then\n     echo \"Must be root to run this command.\" >&2\n     exit 1\n   fi\n\n   find / -print > $locatedb\n\n   exit 0\n```", "```\n#!/bin/sh\n\n# locate--Searches the locate database for the specified pattern\n\nlocatedb=\"/var/locate.db\"\n\nexec grep -i \"$@\" $locatedb\n```", "```\n$ sudo mklocatedb\nPassword:\n...\nMuch time passes\n...\n$\n```", "```\n$ ls -l /var/locate.db\n-rw-r--r--  1 root  wheel  174088165 Mar 26 10:02 /var/locate.db\n```", "```\n$ locate -i solitaire\n/Users/taylor/Documents/AskDaveTaylor image folders/0-blog-pics/vista-search-\nsolitaire.png\n/Users/taylor/Documents/AskDaveTaylor image folders/8-blog-pics/windows-play-\nsolitaire-1.png\n/usr/share/emacs/22.1/lisp/play/solitaire.el.gz\n/usr/share/emacs/22.1/lisp/play/solitaire.elc\n/Volumes/MobileBackups/Backups.backupdb/Dave's MBP/2014-04-03-163622/BigHD/\nUsers/taylor/Documents/AskDaveTaylor image folders/0-blog-pics/vista-search-\nsolitaire.png\n/Volumes/MobileBackups/Backups.backupdb/Dave's MBP/2014-04-03-163622/BigHD/\nUsers/taylor/Documents/AskDaveTaylor image folders/8-blog-pics/windows-play-\nsolitaire-3.png\n```", "```\n$ locate '\\.c$' | wc -l\n  1479\n```", "```\nalias DIR=ls\n```", "```\n   #!/bin/bash\n   # DIR--Pretends we're the DIR command in DOS and displays the contents\n   #   of the specified file, accepting some of the standard DIR flags\n\n   function usage\n   {\n   cat << EOF >&2\n     Usage: $0 [DOS flags] directory or directories\n     Where:\n      /D           sort by columns\n      /H           show help for this shell script\n      /N           show long listing format with filenames on right\n      /OD          sort by oldest to newest\n      /O-D         sort by newest to oldest\n      /P           pause after each screenful of information\n      /Q           show owner of the file\n      /S           recursive listing\n      /W           use wide listing format\n   EOF\n     exit 1\n   }\n\n   #####################\n   ### MAIN BLOCK\n\n   postcmd=\"\"\n   flags=\"\"\n   while [ $# -gt 0 ]\n   do\n     case $1 in\n       /D        ) flags=\"$flags -x\"      ;;\n       /H        ) usage                  ;;\n➊     /[NQW]    ) flags=\"$flags -l\"      ;;\n       /OD       ) flags=\"$flags -rt\"     ;;\n       /O-D      ) flags=\"$flags -t\"      ;;\n       /P        ) postcmd=\"more\"         ;;\n       /S        ) flags=\"$flags -s\"      ;;\n               * ) # Unknown flag: probably a DIR specifier break;\n                   #   so let's get out of the while loop.\n     esac\n     shift         # Processed flag; let's see if there's another.\n   done\n\n   # Done processing flags; now the command itself:\n\n   if [ ! -z \"$postcmd\" ] ; then\n     ls $flags \"$@\" | $postcmd\n   else\n     ls $flags \"$@\"\n   fi\n\n   exit 0\n```", "```\n$ DIR /OD /S ~/Desktop\ntotal 48320\n 7720 PERP - Google SEO.pdf              28816 Thumbs.db\n    0 Traffic Data                       8 desktop.ini\n    8 gofatherhood-com-crawlerrors.csv   80 change-lid-close-behavior-win7-1.png\n   16 top-100-errors.txt                 176 change-lid-close-behavior-win7-2.png\n    0 $RECYCLE.BIN                       400 change-lid-close-behavior-win7-3.png\n    0 Drive Sunshine                     264 change-lid-close-behavior-win7-4.png\n   96 facebook-forcing-pay.jpg           32 change-lid-close-behavior-win7-5.png\n10704 WCSS Source Files\n```", "```\n$ TZ=\"Africa/Casablanca\" date\nFri Apr  7 16:31:01 WEST 2017\n```", "```\n   #!/bin/bash\n\n   # timein--Shows the current time in the specified time zone or\n   #   geographic zone. Without any argument, this shows UTC/GMT.\n   #   Use the word \"list\" to see a list of known geographic regions.\n   #   Note that it's possible to match zone directories (regions),\n   #   but that only time zone files (cities) are valid specifications.\n\n   # Time zone database ref: http://www.twinsun.com/tz/tz-link.htm\n\n   zonedir=\"/usr/share/zoneinfo\"\n\n   if [ ! -d $zonedir ] ; then\n     echo \"No time zone database at $zonedir.\" >&2\n     exit 1\n   fi\n\n   if [ -d \"$zonedir/posix\" ] ; then\n     zonedir=$zonedir/posix        # Modern Linux systems\n   fi\n\n   if [ $# -eq 0 ] ; then\n     timezone=\"UTC\"\n     mixedzone=\"UTC\"\n➊ elif [ \"$1\" = \"list\" ] ; then\n     ( echo \"All known time zones and regions defined on this system:\"\n       cd $zonedir\n       find -L * -type f -print | xargs -n 2 | \\\n         awk '{ printf \" %-38s %-38s\\n\", $1, $2 }'\n     ) | more\n     exit 0\n   else\n\n     region=\"$(dirname $1)\"\n     zone=\"$(basename $1)\"\n\n     # Is the given time zone a direct match? If so, we're good to go.\n     #   Otherwise we need to dig around a bit to find things. Start by\n     #   just counting matches.\n\n     matchcnt=\"$(find -L $zonedir -name $zone -type f -print |\\\n           wc -l | sed 's/[^[:digit:]]//g' )\"\n\n     # Check if at least one file matches.\n     if [ \"$matchcnt\" -gt 0 ] ; then\n       # But exit if more than one file matches.\n       if [ $matchcnt -gt 1 ] ; then\n         echo \"\\\"$zone\\\" matches more than one possible time zone record.\" >&2\n         echo \"Please use 'list' to see all known regions and time zones.\" >&2\n         exit 1\n         fi\n         match=\"$(find -L $zonedir -name $zone -type f -print)\"\n         mixedzone=\"$zone\"\n       else # Maybe we can find a matching time zone region, rather than a specific\n            #   time zone.\n         # First letter capitalized, rest of word lowercase for region + zone\n         mixedregion=\"$(echo ${region%${region#?}} \\\n                  | tr '[[:lower:]]' '[[:upper:]]')\\\n                  $(echo ${region#?} | tr '[[:upper:]]' '[[:lower:]]')\"\n       mixedzone=\"$(echo ${zone%${zone#?}} | tr '[[:lower:]]' '[[:upper:]]') \\\n                  $(echo ${zone#?} | tr '[[:upper:]]' '[[:lower:]]')\"\n\n       if [ \"$mixedregion\" != \".\" ] ; then\n         # Only look for specified zone in specified region\n         #   to let users specify unique matches when there's\n         #   more than one possibility (e.g., \"Atlantic\").\n         match=\"$(find -L $zonedir/$mixedregion -type f -name $mixedzone -print)\"\n       else\n         match=\"$(find -L $zonedir -name $mixedzone -type f -print)\"\n       fi\n\n       # If file exactly matched the specified pattern\n       if [ -z \"$match\" ] ; then\n         # Check if the pattern was too ambiguous.\n         if [ ! -z $(find -L $zonedir -name $mixedzone -type d -print) ] ; then\n➋         echo \"The region \\\"$1\\\" has more than one time zone. \" >&2\n         else  # Or if it just didn't produce any matches at all\n           echo \"Can't find an exact match for \\\"$1\\\". \" >&2\n         fi\n         echo \"Please use 'list' to see all known regions and time zones.\" >&2\n         exit 1\n       fi\n     fi\n➌   timezone=\"$match\"\n   fi\n\n   nicetz=$(echo $timezone | sed \"s|$zonedir/||g\")    # Pretty up the output.\n\n   echo It\\'s $(TZ=$timezone date '+%A, %B %e, %Y, at %l:%M %p') in $nicetz\n\n   exit 0\n```", "```\n$  timein\nIt's Wednesday, April 5, 2017, at 4:00 PM in UTC\n$ timein London\nIt's Wednesday, April 5, 2017, at 5:00 PM in Europe/London\n$ timein Brazil\nThe region \"Brazil\" has more than one time zone. Please use 'list'\nto see all known regions and time zones.\n$ timein Pacific/Honolulu\nIt's Wednesday, April 5, 2017, at 6:00 AM in Pacific/Honolulu\n$ timein WET\nIt's Wednesday, April 5, 2017, at 5:00 PM in WET\n$ timein mycloset\nCan't find an exact match for \"mycloset\". Please use 'list'\nto see all known regions and time zones.\n```"]