<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="61" id="Page_61"/>6</span><br/>
<span class="ChapterTitle">Containerizing an Application with Docker</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">A <em>container</em> is the running instance of an application based off a container image. Using containers provides you with a predictable and isolated way to create and run code. It allows you to package an application and its dependencies into a portable artifact you can easily distribute and run. Microservice architectures and continuous integration/continuous development pipelines heavily use containers, and if you’re a software or DevOps engineer, using containers has most likely changed the way you deliver and write software. </p>
<p>In this chapter, you’ll learn how to install the Docker engine and the <code>docker</code> client command line tool. You’ll also get a crash course in Dockerfiles, container images, and containers. You’ll combine this knowledge, along with some basic Docker commands, to containerize a sample <span epub:type="pagebreak" title="62" id="Page_62"/>application called <em>telnet-server</em> that I’ve provided in the repository for this book (<a href="https://github.com/bradleyd/devops_for_the_desperate/" class="LinkURL">https://github.com/bradleyd/devops_for_the_desperate/</a>). By the end of this chapter, you’ll have a solid understanding of how to use Docker to containerize any application, as well as the benefits of doing so.</p>
<h2 id="h1-502482c06-0001">Docker from 30,000 Feet</h2>
<p class="BodyFirst">The word <em>Docker</em> has become synonymous with the container movement. This is due to Docker’s ease of use, the rise of microservice architectures, and the need to solve the “works on my machine” paradox. The idea of containers has been around for quite some time, however, and numerous container frameworks exist. But since Docker released its first open-source version in March 2013, the industry has adopted the Docker framework as the de facto standard. The first stable version of Docker (1.0) was released in 2014, and since then, new versions have included many improvements.</p>
<p>The Docker framework consists of a Docker daemon (server), a <code>docker</code> command line client, and other tools that are beyond the scope of this book. Docker uses Linux kernel features to build and run containers. These pieces fit together to allow Docker to do its magic: <em>OS-level virtualization</em>, which partitions the operating system into what looks like separate isolated servers, as shown in <a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a>. Because of this, containers are effective when you need to run a lot of applications on limited hardware.</p>
<figure>
<img src="image_fi/502482c06/f06001.png" class="" alt="Diagram showing these layers from top to bottom: Containerized applications, docker framework, host os, infrastructure"/>
<figcaption><p><a id="figure6-1">Figure 6-1</a>: OS-level virtualization</p></figcaption>
</figure>
<h3 id="h2-502482c06-0001">Getting Started with Docker</h3>
<p class="BodyFirst">First, you’ll create a <em>Dockerfile</em> that describes how to build the <em>container image</em> from your application. A container image is made of different layers that house your application, dependencies, and anything else the application needs so it can run. Container images can be distributed and served from a service called a <em>registry</em>. Docker hosts the most popular registry at <span epub:type="pagebreak" title="63" id="Page_63"/><a href="https://hub.docker.com/" class="LinkURL">https://hub.docker.com/</a>. There, you’ll find just about any image you might need, such as Ubuntu or the PostgreSQL database. With a simple <code>docker pull</code> <var class="bold">&lt;image-name&gt;</var> command, you can download and use an image in a matter of seconds. A container is the running instance of an application based off the container image. <a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a> shows how all of Docker’s pieces fit together. In this chapter, you’ll mostly be working with the <code>docker</code> client. </p>
<figure>
<img src="image_fi/502482c06/f06002.png" class="" alt="Diagram showing the client (which contains the docker commands), connected to the docker host (which contains the docker daemon, containers, and images), connected to the registry (which is where the images come from)"/>
<figcaption><p><a id="figure6-2">Figure 6-2</a>: Docker framework</p></figcaption>
</figure>
<h3 id="h2-502482c06-0002">Dockerfile Instructions</h3>
<p class="BodyFirst">The Dockerfile contains the instructions that teach the Docker server how to turn an application into a container image. Each instruction represents a specific job and creates a new layer inside the container image. The following list includes the most common instructions: </p>
<ol class="none">
<li><code class="bold">FROM</code>  Specifies the parent or base image from which to build the new image (must be the first command in the file)</li>
<li><code class="bold">COPY</code>  Adds files from your current directory (where the Dockerfile resides) to a destination in the image filesystem</li>
<li><code class="bold">RUN</code>  Executes a command inside the image </li>
<li><code class="bold">ADD</code>  Copies new files or directories from either a source or a URL to a destination in the image filesystem</li>
<li><code class="bold">ENTRYPOINT</code>  Makes your container run like an executable (which you can think of as any Linux command line application that takes arguments on your host)</li>
<li><code class="bold">CMD</code>  Provides a default command or default parameters for the container (can be used in conjunction with <code>ENTRYPOINT</code>)</li>
</ol>
<p>See the Dockerfile reference at <a href="https://docs.docker.com/engine/reference/builder/" class="LinkURL">https://docs.docker.com/engine/reference/builder/</a> for instructions and configuration details.</p>
<h3 id="h2-502482c06-0003"><span epub:type="pagebreak" title="64" id="Page_64"/>Container Images and Layers</h3>
<p class="BodyFirst">The Dockerfile you build creates a container image. This image is made of different layers that house your application, dependencies, and anything else the application needs so it can run. These layers are like snapshots in time of your application’s state, so keeping your Dockerfiles in version control along with your source code makes it easier to build new container images every time your application code changes. </p>
<p>The layers fit together like LEGO bricks. Each layer, or intermediate image, is created each time an instruction in the Dockerfile is executed. For example, every time you use the <code>RUN</code> instruction, a new intermediate layer is created with the results of that instruction. Each layer (image) is assigned a unique hash, and all layers are cached by default. This means you can share layers with other images, so if a given layer hasn’t changed, you don’t need to build it again from scratch. Also, caching is your best friend, as it cuts down the time and space needed to build images.</p>
<p>Docker can stack these layers on top of each other because it uses the <em>union filesystem (UFS</em><em>)</em>, which allows multiple filesystems to come together and create what looks like a single filesystem. The topmost layer is the <em>container layer</em>, which is added when you run the container image. It’s the only layer that can be written to. All the subsequent layers are read only, by design. If you make any file or system changes to the container layer and then remove the running container, those changes will be gone. The underlying read-only images are kept intact. This is why containers are so popular with software engineers: the image is an immutable artifact that can be run on any Docker host and behave in the same way.</p>
<h3 id="h2-502482c06-0004">Containers</h3>
<p class="BodyFirst">The Docker container is a running instance of a container image. In computer programming terms, you can think of the container image as a <em>class</em> and the container as an <em>instance</em> of that class. When the container starts, the container layer is created. This writeable layer is where all the changes (like writing, deleting, and modifying existing files) will take place. </p>
<h3 id="h2-502482c06-0005">Namespaces and Cgroups</h3>
<p class="BodyFirst">The container is also roped off from the rest of the Linux host by some boundaries and limited views called <em>namespaces</em> and <em>cgroups</em>. These are kernel features that limit what a container can see and use on a host. They also make OS-level virtualization a reality. Namespaces restrict global system resources for a container. Without namespaces, a container could have free run of the system. Imagine if a container could see a process in another container. That mischievous container could kill a process, delete a user, or unmount a directory in another container. Try tracking that down when you’re on call at 2 <span class="KeyCaps">am</span>! </p>
<p>Common kernel namespaces include the following:</p>
<ol class="none">
<li><span class="RunInHead">Process ID (<span class="LiteralBold"><code>PID</code></span>) </span>  Isolates the process IDs</li>
<li><span class="RunInHead">Network (<span class="LiteralBold"><code>net</code></span>) </span>  Isolates the network interface stack</li>
<li><span epub:type="pagebreak" title="65" id="Page_65"/><span class="RunInHead">UTS </span>  Isolates the hostname and domain name</li>
<li><span class="RunInHead">Mount (<span class="LiteralBold"><code>mnt</code></span>)  </span>  Isolates the mount points</li>
<li><span class="RunInHead">IPC </span>  Isolates the SysV-style interprocess communication</li>
<li><span class="RunInHead">User </span>  Isolates the user and group IDs</li>
</ol>
<p>Using these namespaces is not enough, however. You also need to control how much memory, CPU, and other physical resources a container uses. That’s where cgroups come in. Cgroups manage and measure the resources a container can use. They allow you to set resource limitations and prioritization for processes. The most common resources Docker sets with cgroups are memory, CPU, disk I/O, and network. Cgroups make it possible to stop a container from using up all the resources on a host.</p>
<p>The main point to remember is that namespaces limit what you can see, while cgroups limit what you can use. Without these features, containers would not be secure or useful. </p>
<h2 id="h1-502482c06-0002">Installing and Testing Docker</h2>
<p class="BodyFirst">To containerize a sample application, you’ll start by installing Docker with the aid of <em>minikube</em>, an app that contains the Docker engine and also provides a Kubernetes cluster (which you’ll use in the next chapter). Next, you’ll install the <code>docker</code> client so that you’ll be able to communicate with the Docker server. Then, you’ll configure your environment so that it can find the new Docker server. Finally, you’ll test client connectivity.</p>
<h3 id="h2-502482c06-0006">Installing the Docker Engine with Minikube</h3>
<p class="BodyFirst">To install minikube, follow the instructions for your operating system at <a href="https://minikube.sigs.k8s.io/" class="LinkURL">https://minikube.sigs.k8s.io/</a>. If you’re not on a Linux host, minikube requires a virtual machine manager to install Docker. Use VirtualBox for that.</p>
<p>By default, minikube makes a best guess about memory allocation for the VM it will create. It also sets the number of CPUs to two and the disk space to 20GB. For the purposes of this book, the defaults should be fine.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Overriding Minikube’s Defaults</h2>
<p class="BoxBodyFirst">Pass the <code>--cpus</code><code>=&lt;</code><var>number</var><code>&gt;</code>,<code> </code><code>--memory='&lt;</code><var>number</var><code>&gt;'</code>, and <code>--disk-size='&lt;</code><var>number</var><code>&gt;'</code> arguments to the <code>minikube start</code> command to change the defaults. Be sure to include the appropriate unit. For example, you could enter <code>minikube</code><code> start </code><code>--cpus</code><code>=4 --memory='10g' --disk-size='40g'</code> to give minikube more resources.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="66" id="Page_66"/>To start minikube using the resource defaults and VirtualBox as the VM manager, enter the following in a terminal:</p>
<pre><code>$ <b>minikube start --driver=virtualbox   </b>
 <var>--snip--</var>
 Done! kubectl is now configured to use "minikube"</code></pre>
<p class="BodyContinued">The <code>Done!</code> message shows that minikube started successfully. If minikube fails to start, you should investigate any error messages listed in the output.</p>
<h3 id="h2-502482c06-0007">Installing the Docker Client and Setting Up Docker Environment Variables</h3>
<p class="BodyFirst">To install the <code>docker</code> client, follow the instructions at <a href="https://docs.docker.com/engine/install/binaries/" class="LinkURL">https://docs.docker.com/engine/install/binaries/</a> for your operating system. Make sure you only download and install the client binary. You’ll use minikube to set some local environment variables in your shell, including the Docker host IP and the path to the Docker host TLS certificates, which are needed to connect. The Bash <code>eval</code> command will source the environment variables in your shell.</p>
<p>In a terminal, enter the following to set your Docker environment variables:</p>
<pre><code>$ <b>eval $(minikube -p minikube docker-env)</b></code></pre>
<p class="BodyContinued">This command should return zero output if it’s successful. The Docker host environment variables should be exported in your current terminal session. </p>
<p>When you close this terminal window, the environment variables will be lost, and you’ll need to run the command each time you want to interact with the Docker server. To avoid this inconvenience, add the command to the bottom of your shell configuration file such as <em>~/.bashrc</em> or <em>~/.zshrc</em> so it’s executed each time you open a terminal window or tab. Then you won’t see the <code>Is the docker daemon running?</code> error.</p>
<h3 id="h2-502482c06-0008">Testing the Docker Client Connectivity</h3>
<p class="BodyFirst">You should test whether the <code>docker</code> client can talk to the Docker server running inside the minikube VM. In the same terminal where you set the environment variables, enter the following to check the Docker version:</p>
<pre><code>$ <b>docker version</b></code></pre>
<p class="BodyContinued">The output should show your client and server versions if the connection is successful.</p>
<h2 id="h1-502482c06-0003">Containerizing a Sample Application</h2>
<p class="BodyFirst">I created a sample application named <em>telnet-server</em> that you can use to build a container with Docker. It’s a simple telnet server that mimics the bulletin board systems (BBSs) people used in the 1980s. The app is written in the Go programming language for OS portability and a small footprint. <span epub:type="pagebreak" title="67" id="Page_67"/>You’ll use an Alpine Linux container image that contains Go and all the needed dependencies.</p>
<p>To containerize an application, you’ll need the source code or binary you want to run in the container plus the Dockerfile to build the container image. The sample application source code and Dockerfile are in the companion repository for this book at <a href="https://github.com/bradleyd/devops_for_the_desperate/ " class="LinkURL">https://github.com/bradleyd/devops_for_the_desperate/ </a>in the <em>telnet-server/</em> folder.</p>
<h3 id="h2-502482c06-0009">Dissecting the Example telnet-server Dockerfile</h3>
<p class="BodyFirst">The example Dockerfile is a <em>multistage</em> <em>build</em> with two separate stages: <em>build</em> and <em>final</em>. Multistage builds allow you to manage complex builds in one Dockerfile, and they provide a good pattern for keeping container images small and secure. In the build stage, the Dockerfile instruction compiles the sample application with all its dependencies. In the final stage, the Dockerfile instruction copies the build artifact (in this case, the compiled sample application) from the build stage. The final container image is much smaller because it doesn’t contain all the dependencies or source code for the sample application from the build stage. Visit <a href="https://docs.docker.com/develop/develop-images/multistage-build/" class="LinkURL">https://docs.docker.com/develop/develop-images/multistage-build/</a><em> </em>for more information on multistage builds.</p>
<p>Navigate to the <em>telnet-server/</em> directory and open the Dockerfile, which should look like this:</p>
<pre><code># Build stage
FROM golang:alpine AS build-env 
ADD . /
RUN cd / &amp;&amp; go build -o telnet-server

# Final stage
FROM alpine:latest AS final
WORKDIR /app
ENV TELNET_PORT 2323
ENV METRIC_PORT 9000
COPY –from=build-env /telnet-server /app/
ENTRYPOINT [″./telnet-server″]</code></pre>
<p class="BodyContinued">The file starts the build stage with a <code>FROM</code> instruction to pull in the <code>golang:alpine</code> parent image. This is an Alpine Linux image from the Docker Hub registry that’s prebuilt for developing in the Go programming language. This image stage is named <code>build-env</code>, using the <code>AS</code> keyword. This name reference is used again later, in the final stage. </p>
<p>The <code>ADD</code> instruction copies all the Go source code in the current local <em>telnet-server/</em> directory to the image’s filesystem at the root (<code>/</code>) destination. </p>
<p>The next <code>RUN</code> instruction executes the shell command that navigates to the root directory in the image filesystem, and it uses the <code>go build</code> command to build the Go binary named telnet-server. </p>
<p>The final stage begins with a <code>FROM</code> instruction that again pulls in an Alpine Linux image (<code>alpine:latest</code>) for the final stage’s parent image. This time, though, the Alpine Linux image is the minimal image in which the application will run. It doesn’t contain any dependencies. </p>
<p><span epub:type="pagebreak" title="68" id="Page_68"/>The <code>WORKDIR</code> instruction sets the working directory for the application, which is <em>/app</em> in this example. Any <code>CMD</code>, <code>RUN</code>, <code>COPY</code>, or <code>ENTRYPOINT</code> instruction after that declaration will be executed in the context of that working directory. </p>
<p>The two <code>ENV</code> instructions set environment variables in the container image that the application can use: they set the telnet server to port <code>2323</code> and the metric server port to <code>9000</code>. (More on those ports later.) </p>
<p>The <code>COPY</code> instruction copies the telnet-server Golang binary from the <code>build-env</code> stage and places it in the working <em>app/</em> directory in the final-stage Alpine image. </p>
<p>The final <code>ENTRYPOINT</code> instruction invokes the telnet-server binary when the container starts to execute the sample application. You’ll use <code>ENTRYPOINT</code> instead of <code>CMD</code> because the application will require additional flags passed to it during a container test in a later chapter. If you need to override the default command in your container, swap <code>ENTRYPOINT</code> with the <code>CMD</code> instruction instead. See the Dockerfile reference at <a href="https://docs.docker.com/engine/reference/builder/" class="LinkURL">https://docs.docker.com/engine/reference/builder/</a> to learn more about <code>CMD</code> versus <code>ENTRYPOINT</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p> 	Notice that the on-disk sizes for the <code>golang:alpine</code> and <code>alpine:latest</code> images are very different. The Go base image comes in at around 315MB, and the <code>alpine:latest</code> image is 5.59MB. Multistage builds are effective at keeping down container size, which means faster downloads, quicker startup times, and more disk space. When it comes to containers, size matters.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502482c06-0010">Building the Container Image</h3>
<p class="BodyFirst">Next, you’ll build the container image for the sample telnet-server application, using the Dockerfile you just reviewed. Navigate to the <em>telnet-server/</em> directory and enter the following to pass Docker the image name and Dockerfile location:</p>
<pre><code>$ <b>docker build -t dftd/telnet-server:v1</b> .</code></pre>
<p class="BodyContinued">The <code>-t</code> flag sets the name and (optionally) a tag for the image, and the dot (<code>.</code>) argument sets the Dockerfile’s current location. The <em>dftd/telnet-server:v1</em> URI has three parts: the registry hostname (<em>dftd</em>), the image name, and the tag. The registry is local to minikube rather than online, so you can use anything for the base. (If it were a remote registry, you’d use something like <em>registry.example.com</em>.) The image name sandwiched between the forward slash (<code>/</code>) and the colon (<code>:</code>) is set to the name of the example application, <em>telnet-server</em>. The <em>v1</em> image tag comes after the colon.</p>
<p>Tags allow you to identify each build of an image and indicate what changes are inside. Using Git commit hashes as tags is a common practice, as each hash is unique and can mark the image’s source code version. If you omit the tag, Docker uses the latest word as the default tag.</p>
<p>After running the command, you should see output like this:</p>
<pre><code>Sending build context to Docker daemon     13MB
Step 1/9 : FROM golang:alpine AS build-env
 ---&gt; 6f9d081b1170
<span epub:type="pagebreak" title="69" id="Page_69"/>Step 2/9 : ADD . /
 ---&gt; 3146d8206747
Step 3/9 : RUN cd / &amp;&amp; go build -o telnet-server
 ---&gt; Running in 3e05a0704b36
go: downloading github.com/prometheus/client_golang v1.6.0
go: downloading github.com/prometheus/common v0.9.1
go: downloading github.com/prometheus/client_model v0.2.0
go: downloading github.com/beorn7/perks v1.0.1
go: downloading github.com/cespare/xxhash/v2 v2.1.1
go: downloading github.com/golang/protobuf v1.4.0
go: downloading github.com/prometheus/procfs v0.0.11
go: downloading github.com/matttproud/golang_protobuf_extensions
  v1.0.1 1 # Build stage
go: downloading google.golang.org/protobuf v1.21.0
go: downloading golang.org/x/sys v0.0.0-20200420163511-1957bb5e6d1f
Removing intermediate container 3e05a0704b36
 ---&gt; 96631440ea5d
Step 4/9 : FROM alpine:latest AS final
 ---&gt; c059bfaa849c
Step 5/9 : WORKDIR /app
 ---&gt; Running in ddc5b73b1712
Removing intermediate container ddc5b73b1712
 ---&gt; 022bcbba3b94
Step 6/9 : ENV TELNET_PORT 2323
 ---&gt; Running in 21bd3d15f50c
Removing intermediate container 21bd3d15f50c
 ---&gt; 30d0284cade4
Step 7/9 : ENV METRIC_PORT 9000
 ---&gt; Running in 8f1fc01b04d5
Removing intermediate container 8f1fc01b04d5
 ---&gt; adfd026e1c27
Step 8/9 : COPY --from=build-env /telnet-server /app/
 ---&gt; fd933cd32a94
Step 9/9 : ENTRYPOINT ["./telnet-server"]
 ---&gt; Running in 5d8542e950dc
Removing intermediate container 5d8542e950dc
 ---&gt; f796da88ab94
<b>Successfully built f796da88ab94</b>
<b>Successfully tagged dftd/telnet-server:v1 </b></code></pre>
<p>Each instruction is logged, allowing you to follow along with the build process in a linear fashion. At the end of the build, the image ID (<code>f796da88ab94</code>) should be listed, followed by a note that the image is tagged successfully as <em>dftf/telnet-server:v1</em>. The image ID you see will be different.</p>
<p>If your <code>docker build</code> wasn’t successful, you’ll want to resolve any errors in the output because you’ll build upon this image going forward. Common errors are typos in the <code>RUN</code> execution and missing files when using the <code>COPY</code> instruction.</p>
<h3 id="h2-502482c06-0011">Verifying the Docker Image</h3>
<p class="BodyFirst">Next, verify that the Docker registry inside minikube is storing the telnet-server image. (As mentioned previously, a registry is a server that stores and serves container images.)</p>
<p><span epub:type="pagebreak" title="70" id="Page_70"/>In a terminal, enter the following to list the Docker telnet-server image:</p>
<pre><code>$ <b>docker image ls dftd/telnet-server:v1</b>
REPOSITORY                  TAG        IMAGE ID         CREATED          SIZE
dftf/telnet-server          v1         f796da88ab94     1 minute ago     16.8MB</code></pre>
<p>Notice that the final image for the telnet-server is only 16.8MB. The Alpine Linux base image in the final stage was roughly 5MB before adding the telnet-server application. </p>
<h3 id="h2-502482c06-0012">Running the Container</h3>
<p class="BodyFirst">The next step is to create and run the telnet-server container from the image you just built. Do this by entering the following:</p>
<pre><code>$ <b>docker run -p 2323:2323 -d --name telnet-server dftd/telnet-server:v1</b>
9b4b719216a1664feb096ba5a67c54907268db781a28d08596e44d388c9e9632</code></pre>
<p class="BodyContinued">The <code>-p</code> (port) flag exposes port <code>2323</code> outside the container. (The telnet-server application needs to have port <code>2323</code> open.) The left side of the colon (<code>:</code>) is the host port, and the right side is the container port. This is useful if you have another application listening on the same port and need to change it for the host while keeping the container port the same. The <code>-d</code> (detach) flag launches the container in the background. If you don’t supply the <code>-d</code> flag, the container will run in the foreground of the terminal from which it launched. The <code>--name</code> flag sets the container name to <code>telnet-server</code>. Docker, by default, assigns randomly generated names for containers if you don’t set them. The last argument is the image name, complete with path and tag, from the build step. </p>
<p>The container is now running in the background and ready to accept traffic. This <code>docker run</code> command was successful because it returned the <em>container ID</em> (the long string of numbers and letters, which will be different for you) and no errors. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The volume flag, <code>-v</code>, can mount a local directory or local file inside the running container. This is a great way to share data between host and container.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Enter the following to verify that the container is actually running:</p>
<pre><code>$ <b>docker container ls -f name=telnet-server</b></code></pre>
<p class="BodyContinued">The optional filter flag (<code>-f</code>) narrows the output to the containers you specify. If you omit the filter flag, running the command should list every container running on the host.</p>
<p>If the container is running, the output should look like this:</p>
<pre><code>CONTAINER ID  IMAGE         COMMAND       ...   PORTS                    NAMES
9b4b719216a1  dftd/...      "./telnet-.." ...   0.0.0.0:2323-&gt;2323/tcp   telnet-server</code></pre>
<p><span epub:type="pagebreak" title="71" id="Page_71"/>The <code>CONTAINER ID</code> column matches the first 12 digits of the ID received from the <code>docker run</code> command issued previously. The <code>IMAGE</code> column contains the image ID given when you built the container image. The <code>PORTS</code> column shows that port <code>2323</code> is exposed on every interface (0.0.0.0) and is mapping that traffic to port <code>2323</code> inside the container. The directional arrow (<code>-&gt;</code>) denotes the traffic flow direction. Finally, the <code>NAMES</code> column shows the telnet-server name set earlier from the <code>run</code> command.</p>
<p> Now, enter the following in your terminal to stop the container:</p>
<pre><code>$ <b>docker container stop telnet-server</b>
telnet-server</code></pre>
<p class="BodyContinued">The container name should be returned, letting you know the Docker daemon thinks the container is stopped. To start the container again, swap the word <code>stop</code> with <code>start</code>, and you should see the container name returned again. </p>
<p>Docker won’t check to see whether your application stays running after you start it. As long as the container can start and not error out immediately, entering <code>docker start</code> or <code>docker run</code> will return the container name as if nothing were wrong. This can be misleading. You’ll want to perform health checks and monitor the application to verify that it’s actually running. (We’ll explore those topics in future chapters.)</p>
<h2 id="h1-502482c06-0004">Other Docker Client Commands</h2>
<p class="BodyFirst">Let’s look at a few more common Docker commands you’ll need to use when working with containers. </p>
<h3 id="h2-502482c06-0013">exec</h3>
<p class="BodyFirst">The <code>exec</code> command allows you to run a command inside a container or interact with a container, as if you were logged in to a terminal session. For example, if you are troubleshooting an application in a container and want to verify that the correct environment variables are being set, you could run the following command in a terminal to output all the environment variables:</p>
<pre><code>$ <b>docker exec telnet-server env</b>  
TELNET_PORT=2323
HOSTNAME=c8f66b93424a
SHLVL=1
HOME=/root
TERM=xterm
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
PWD=/app
METRIC_PORT=9000</code></pre>
<p class="BodyContinued">The <code>env</code> command executes inside the container, using the OS’s default shell. When it finishes, the output is sent back to the terminal. </p>
<p><span epub:type="pagebreak" title="72" id="Page_72"/>The <code>exec</code> command also allows you to access a running container to troubleshoot it or run a command. You’ll need to pass the interactive flag (<code>-i</code>) and the pseudo-TTY flag (<code>-t</code>), along with the shell command (<code>/bin/sh</code>), to do this. The interactive flag keeps STDIN open so you can type commands inside the container layer. The pseudo-TTY flag simulates a terminal, and when combined with the interactive flag, it mimics being in a live terminal session inside the container. Operating systems other than Linux will use different shells: most commonly, <em>/bin/sh</em> and <em>/bin/bash</em>. Alpine Linux uses the <em>/bin/sh</em> shell as its default.</p>
<p>Enter the following in a terminal to get a shell inside the container:</p>
<pre><code>$ <b>docker exec -it telnet-server /bin/sh </b>
/app # ls
telnet-server
/app #</code></pre>
<p class="BodyContinued">The <code>ls</code> command is issued to show you’re inside the container you built. (You earlier set the working directory to <em>app/</em> and put the telnet-server binary in there.) Input the <code class="bold">exit</code> command and press <span class="KeyCaps">enter</span> to leave the container and return to the local terminal.</p>
<h3 id="h2-502482c06-0014">rm</h3>
<p class="BodyFirst">The <code>rm</code> command removes a stopped container. For example, to remove the telnet-server container once it is stopped, enter the following in a terminal:</p>
<pre><code>$ <b>docker container rm telnet-server</b>
telnet-server</code></pre>
<p class="BodyContinued">The removed container’s name should be returned. You can use the <code>-f</code> (force) flag to remove a running container, but it’s best to stop it first.</p>
<h3 id="h2-502482c06-0015">inspect</h3>
<p class="BodyFirst">The <code>inspect</code> <code>docker</code> command returns low-level information about some Docker objects. The output is in JSON format by default. Depending on the Docker object, the results can be verbose. </p>
<p>To inspect the telnet-server container, enter the following in a terminal:</p>
<pre><code>$ <b>docker inspect telnet-server</b>
[
    {
        "Id": "c8f66b93424a3dac33415941e357ae9eb30567a3d64d4b5e87776701ad8274c5",
        "Created": "2022-02-16T03:35:44.777190911Z",
        "Path": "./telnet-server",
        "Args": [],
        "State": { <span class="CodeAnnotationCode" aria-label="annotation1">1</span>
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
<span epub:type="pagebreak" title="73" id="Page_73"/>            "Dead": false,
            "Pid": 19794,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2022-02-16T03:35:45.230788473Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
<var>--snip--</var>
        "NetworkSettings": { <span class="CodeAnnotationCode" aria-label="annotation2">2</span>
            "Bridge": "",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {
                "2323/tcp": [
                    {
                        "HostIp": "0.0.0.0",
                        "HostPort": "2323"
                    }
                ]
            },
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.5",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
         "MacAddress": "02:42:ac:11:00:05",
<var>--snip--</var></code></pre>
<p class="BodyContinued">The <code>State</code> section <span class="CodeAnnotation" aria-label="annotation1">1</span> contains data about the running container, like <code>Status</code> and <code>StartedAt</code> date. The <code>NetworkSettings</code> section <span class="CodeAnnotation" aria-label="annotation2">2</span> provides information like <code>Ports</code> and <code>IPAddress</code>, which are helpful when troubleshooting problematic containers. </p>
<h3 id="h2-502482c06-0016">history</h3>
<p class="BodyFirst">The <code>history</code> command displays a container image’s history, which is useful for viewing the number and sizes of an image’s layers. </p>
<p>To see the telnet-server image’s layers, enter the following in a terminal:</p>
<pre><code>$ <b>docker history dftd/telnet-server:v1</b>
IMAGE           CREATED       CREATED BY                                    SIZE    COMMENT
cb5a2baff085    20 hours ago  /bin/sh -c #(nop) ENTRYPOINT ["./telnet-ser...  0B
a826cfe49c09    20 hours ago  /bin/sh -c #(nop) COPY file:47e9acb5fa56759e... 13MB
a9a45301f95b    5 days ago    /bin/sh -c #(nop) ENV METRIC_PORT=9000          0B
001a12a073c2    5 days ago    /bin/sh -c #(nop) ENV TELNET_PORT=2323          0B
379892a150e3    6 days ago    /bin/sh -c #(nop) WORKDIR /app                  0B
f70734b6a266    3 weeks ago   /bin/sh -c #(nop) CMD ["/bin/sh"]               0B
&lt;missing&gt;       3 weeks ago   /bin/sh -c #(nop) ADD file:b91adb67b670d3a6f... 5.61MB</code></pre>
<p class="BodyContinued">The output (edited) shows the instructions that start each layer, like <code>COPY</code> and <code>ADD</code>. It also shows the layers’ ages and sizes.</p>
<h3 id="h2-502482c06-0017"><span epub:type="pagebreak" title="74" id="Page_74"/>stats</h3>
<p class="BodyFirst">The <code>stats</code> command displays a real-time update on the resources a container is using. It gathers this information from the cgroups and behaves similarly to the Linux <code>top</code> command. If you have a host that manages multiple containers and want to see which one is the resource hog, use the <code>stats</code> command. Once you run the <code>stats</code> command, it drops you into a page that updates every few seconds. As that’s impossible to show in a book, we’ll pass the <code>--no-stream</code> flag to take a snapshot of the resources and exit immediately. </p>
<p>Enter the following to show the telnet-server container’s resource usage:</p>
<pre><code>$ <b>docker stats --no-stream telnet-server</b>
CONTAINER ID  NAME           CPU %  MEM USAGE / LIMIT  MEM %   NET I/O  BLOCK I/O   PIDS
c8f66b93424a  telnet-server  0.00%  2.145MiB/5.678GiB  0.04%   0B / 0B  0B / 0B      7</code></pre>
<p>This telnet-server container is using virtually no CPU, no disk or network I/O, and only 2MiB of memory. You could easily run hundreds of these in a cloud environment on a single server.</p>
<p>Visit <a href="https://docs.docker.com/engine/reference/commandline/cli/" class="LinkURL">https://docs.docker.com/engine/reference/commandline/cli/</a><em> </em>to explore all of the <code>docker</code> command line client’s commands and flags.</p>
<h2 id="h1-502482c06-0005">Testing the Container</h2>
<p class="BodyFirst">To find out whether the sample application you’ve containerized actually works, you’ll connect to the telnet-server on port <code>2323</code> and run some basic commands. Then you’ll view the container logs to verify that the application is working correctly. </p>
<p>Before performing either of these steps, however, you’ll need to install a <code>telnet</code> client for your OS to communicate with the telnet-server. If you’re using macOS, simply enter <code class="bold">brew install telnet</code> in your terminal. If you’re using Ubuntu, enter <code class="bold">apt</code> <code class="bold">install telnet</code> in a terminal as a privileged user.</p>
<h3 id="h2-502482c06-0018">Connecting to the Telnet-Server</h3>
<p class="BodyFirst">To connect to the server, pass telnet the hostname or IP address of the server plus the port to which you want to connect. Since the Docker server is running inside a VM (minikube), you’ll need the IP address minikube exposes to your local host. </p>
<p>Enter the following in a terminal to get the IP address: </p>
<pre><code>$ <b>minikube ip</b>
192.168.99.103</code></pre>
<p>My minikube IP address is 192.168.99.103; yours may be different. </p>
<p>To connect to the telnet-server running inside the container, pass the IP address (192.168.99.103) and port (<code>2323</code>) to the <code>telnet</code> command:</p>
<pre><code><span epub:type="pagebreak" title="75" id="Page_75"/>$ <b>telnet 192.168.99.103 2323</b>
Trying 192.168.99.103...
Connected to 192.168.99.103.
Escape character is '^]'.

____________ ___________
|  _  \  ___|_   _|  _  \
| | | | |_    | | | | | |
| | | |  _|   | | | | | |
| |/ /| |     | | | |/ /
|___/ \_|     \_/ |___/

&gt;</code></pre>
<p>Success! The ASCII text banner of DFTD should greet you in all its glory. You’re now connected to the telnet-server application. The prompt (<code>&gt;</code>) is where you can enter commands. To start, you can enter only the <code>date</code>, <code>help</code>, <code>yell</code>, and <code>quit</code> commands. You can use the first character of any of those commands as a shortcut, and any commands you enter will be logged.</p>
<p>While still connected to the telnet-server, enter the following to print the current date and time:</p>
<pre><code>&gt;<b>d</b>
Tue May 10 22:55:13 +0000 UTC 2022.</code></pre>
<p>Great! The current date and time should be displayed. Depending on your age, this could bring back memories of baud rates and high-pitched squeals.</p>
<p>Enter the following to quit the telnet-server session:</p>
<pre><code>&gt;<b>q</b>
Good Bye!
Connection closed by foreign host.</code></pre>
<p>You should see that the telnet-server session is nice enough to say goodbye. Take that, modern-day internet!</p>
<p>You can add new commands to the server or change the responses in the <em>telnet-server/telnet/server.go</em> file. If you do, don’t forget to build, stop, and replace the image and container using the commands you learned earlier in this chapter.</p>
<h3 id="h2-502482c06-0019">Getting Logs from the Container</h3>
<p class="BodyFirst">Docker provides a simple way to retrieve logs from a running container. This is important for troubleshooting and forensics purposes. </p>
<p><span epub:type="pagebreak" title="76" id="Page_76"/>To see all the logs for the telnet-server, which is logging to STDOUT, enter the following in your terminal:</p>
<pre><code> $ <b>docker logs telnet-server</b>
telnet-server: 2022/01/04 19:38:22 telnet-server listening on [::]:2323
telnet-server: 2022/01/04 19:38:22 Metrics endpoint listening on :9000
telnet-server: 2022/01/04 19:38:32 [IP=192.168.99.1] New session
telnet-server: 2022/01/04 19:38:43 [IP=192.168.99.1] Requested command: d
telnet-server: 2022/01/04 19:38:44 [IP=192.168.99.1] User quit session</code></pre>
<p>The first two lines of output are startup messages showing that the server is running and listening on specific ports. (We’ll explore the metrics server when we look at monitoring applications in Chapter 9.) The fourth log line is from when you entered the <code>d</code> command into the telnet session to print the current date and time. The fifth log line shows when you entered <code>q</code> to exit the test telnet session. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The <code>logs</code> command can also mimic the Linux <code>tail</code> command. Use the <code>-f</code> flag to follow the log stream or the <code>--tail</code> flag to limit the number of lines shown.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502482c06-0006">Summary</h2>
<p class="BodyFirst">If you’re a software or DevOps engineer, you need a solid understanding of containers in today’s infrastructure. In this chapter, you explored how Docker makes containers possible with OS-level virtualization. You examined how a Dockerfile works to create the layers of a container image, and you applied that knowledge to build a sample container image using a multistage build. Finally, you started a container from the provided telnet-server image, tested that it was working correctly, and checked its logs. In the next chapter, you’ll take the telnet-server image you built here and run it inside a Kubernetes cluster.</p>
</section>
</body></html>