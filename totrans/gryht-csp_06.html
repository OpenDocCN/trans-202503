<html><head></head><body>
<p id="filepos509064" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">7</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">AUTOMATING OPENVAS</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">In this chapter, I introduce you to OpenVAS and the OpenVAS Management Protocol (OMP), a free and open source vulnerability management system forked from the last open source release of Nessus. In <a href="index_split_010.html#filepos420379">Chapters 5</a> and <a href="index_split_011.html#filepos455112">6</a>, we covered automating the proprietary vulnerability scanners Nessus and Nexpose, respectively. While OpenVAS has similar functionality, it’s another great tool to have in your arsenal.</p><p class="calibre_6">I show you how to drive OpenVAS to scan for and report on vulnerabilities for hosts on your network using the core C# libraries and some custom classes. By the time you’ve finished reading this chapter, you should be able to assess any network-connected hosts for vulnerabilities with OpenVAS and C#.</p><p id="filepos510195" class="calibre_10"><span class="calibre3"><span class="bold"> Installing OpenVAS</span></span></p><p class="calibre_11">The easiest way to install OpenVAS is to download the prebuilt OpenVAS Demo Virtual Appliance from <a href="http://www.openvas.org/"><span class="italic">http://www.openvas.org/</span></a>. The file you’ll download is an <span class="italic">.ova</span> file (open virtualization archive) that should run in a virtualization tool like VirtualBox or VMware. Install VirtualBox or VMware on your system and then open the downloaded <span class="italic">.ova</span> file to run it in your virtualization tool of choice. (Give the OVA appliance at least 4GB of RAM to improve its performance.) The root password for the virtual appliance should be <span class="italic">root</span>. You should use the root user when updating the appliance with the latest vulnerability data.</p><p class="calibre_6">Once you are logged in, update OpenVAS with the latest vulnerability information by entering the commands shown in <a href="#filepos511613">Listing 7-1</a>.</p><blockquote class="calibre_14"><span class="calibre4"># </span><span class="calibre4"><span class="bold">openvas-nvt-sync</span></span><br class="calibre5"/><span class="calibre4"># </span><span class="calibre4"><span class="bold">openvas-scapdata-sync</span></span><br class="calibre5"/><span class="calibre4"># </span><span class="calibre4"><span class="bold">openvas-certdata-sync</span></span><br class="calibre5"/><span class="calibre4"># </span><span class="calibre4"><span class="bold">openvasmd --update</span></span><span class="calibre4">
</span><a id="filepos511613"/><span class="calibre4"><span class="italic">Listing 7-1: Commands used to update OpenVAS</span></span></blockquote><p class="calibre_6">Depending on your internet connection, the updates may take a good while to complete. Once they are finished, try to connect to the <span class="calibre4">openvasmd</span> process on port 9390 and then run a test command as shown in <a href="#filepos512426">Listing 7-2</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">openssl s_client &lt;ip address&gt;:9390</span></span><br class="calibre5"/><span class="calibre4">[...SSL NEGOTIATION...]</span><br class="calibre5"/><span class="calibre4"><span class="bold">&lt;get_version /&gt;</span></span><br class="calibre5"/><span class="calibre4">&lt;get_version_response status="200" status_text="OK"&gt;&lt;version&gt;6.0&lt;/version&gt;&lt;/get_version_response&gt; </span><a id="filepos512426"/><span class="calibre4"><span class="italic">Listing 7-2: Connecting to</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">openvasmd</span></span></blockquote><p class="calibre_6">If everything is working, you should see <span class="calibre4">OK</span> in the status message at the end of the output.</p><p id="filepos512723" class="calibre_10"><span class="calibre3"><span class="bold">Building the Classes</span></span></p><p class="calibre_11">Like the Nexpose API, OpenVAS transfers data to the server in XML. To automate OpenVAS scans, we’ll use a combination of the <span class="calibre4">Session</span> and <span class="calibre4">Manager</span> classes discussed in earlier chapters. The <span class="calibre4">OpenVASSession</span> class will take care of how we communicate with OpenVAS, as well as authentication. The <span class="calibre4">OpenVASManager</span> class will wrap common functionality in the API to make using the API easy for a programmer.</p><p id="filepos513353" class="calibre_10"><span class="calibre3"><span class="bold">The OpenVASSession Class</span></span></p><p class="calibre_11">We’ll use the <span class="calibre4">OpenVASSession</span> class to communicate with OpenVAS. <a href="#filepos515080">Listing 7-3</a> shows the constructor and properties that begin the <span class="calibre4">OpenVASSession</span> class.</p><blockquote class="calibre_14"><span class="calibre4"> public class OpenVASSession : IDisposable</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> private SslStream _stream = null;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public OpenVASSession(string user, string pass, string host, int port = ➊9390)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> this.ServerIPAddress = ➋IPAddress.Parse(host);</span><br class="calibre5"/><span class="calibre4"> this.ServerPort = port;</span><br class="calibre5"/><span class="calibre4"> this.Authenticate(username, password);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public string Username { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string Password { get; set; }</span><br class="calibre5"/><span class="calibre4"> public IPAddress ServerIPAddress { get; set; }</span><br class="calibre5"/><span class="calibre4"> public int ServerPort { get; set; }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public SslStream Stream</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➌get</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (_stream == null)</span><br class="calibre5"/><span class="calibre4"> GetStream();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return _stream;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➍set { _stream = value; }</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos515080" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-3: The constructor and properties for the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">OpenVASSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6">The <span class="calibre4">OpenVASSession</span> constructor takes up to four arguments: a username and password to authenticate with OpenVAS (which is <span class="calibre4"><span class="italic">admin</span></span>:<span class="calibre4"><span class="italic">admin</span></span> by default in the virtual appliance); the host to connect to; and optionally the port to connect to on the host, with a default of <span class="calibre4">9390</span> ➊.</p><p class="calibre_6">We pass the <span class="calibre4">host</span> argument to <span class="calibre4">IPAddress.Parse()</span> ➋ and assign the result to the <span class="calibre4">ServerIPAddress</span> property. Next, we assign the value of the port variable to the <span class="calibre4">ServerPort</span> property and pass the username and password to the <span class="calibre4">Authenticate()</span> method if authentication succeeds (as discussed in the next section). The <span class="calibre4">ServerIPAddress</span> and <span class="calibre4">ServerPort</span> properties are assigned in the constructor and are used throughout the class.</p><p class="calibre_6">The <span class="calibre4">Stream</span> property uses <span class="calibre4">get</span> ➌ to see whether the private <span class="calibre4">_stream</span> member variable is null. If so, it calls <span class="calibre4">GetStream()</span>, which sets ➍ <span class="calibre4">_stream</span> with a connection to the OpenVAS server and then returns the <span class="calibre4">_stream</span> variable.</p><p id="filepos516776" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Authenticating with the OpenVAS Server</span></span></span></p><p class="calibre_11">To attempt to authenticate with the OpenVAS server, we send an XML document with the username and password to OpenVAS and then read the response, as shown in <a href="#filepos518272">Listing 7-4</a>. If authentication succeeds, we should be able to call higher-privilege commands to designate a target to scan, retrieve a report, and so on.</p><blockquote class="calibre_14"><span class="calibre4"> public XDocument ➊Authenticate(string username, string password)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> XDocument authXML = new XDocument(</span><br class="calibre5"/><span class="calibre4"> new XElement("authenticate",</span><br class="calibre5"/><span class="calibre4"> new XElement("credentials",</span><br class="calibre5"/><span class="calibre4"> new XElement("username", ➋username),</span><br class="calibre5"/><span class="calibre4"> new XElement("password", ➌password))));</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> XDocument response = this.➍ExecuteCommand(authXML);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (response.Root.Attribute(➎"status").Value != "200")</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Authentication failed");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> this.Username = username;</span><br class="calibre5"/><span class="calibre4"> this.Password = password;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return response;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos518272" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-4: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">OpenVASSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">constructor’s</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Authenticate()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The <span class="calibre4">Authenticate()</span> method ➊ starts by accepting two arguments: the username and the password to authenticate with OpenVAS. We create a new authenticate XML command and use the <span class="calibre4">username</span> ➋ and <span class="calibre4">password</span> ➌ supplied for the credentials; then we send the authentication request with <span class="calibre4">ExecuteCommand()</span> ➍ and store the response so we can ensure authentication was successful and retrieve the authentication token.</p><p class="calibre_6">If the <span class="calibre4">status</span> attribute ➎ of the root XML element returned by the server is 200, authentication was successful. We assign the <span class="calibre4">Username</span> properties, <span class="calibre4">Password</span> properties, and any arguments to the method, and then return the authentication response.</p><p id="filepos519528" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating a Method to Execute OpenVAS Commands</span></span></span></p><p class="calibre_11"><a href="#filepos520384">Listing 7-5</a> shows the <span class="calibre4">ExecuteCommand()</span> method, which takes an arbitrary OpenVAS command, sends it to OpenVAS, and then returns the result.</p><blockquote class="calibre_14"><span class="calibre4">public XDocument ExecuteCommand(XDocument doc)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> ASCIIEncoding enc = new ASCIIEncoding();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> string xml = doc.ToString();</span><br class="calibre5"/><span class="calibre4"> this.Stream.➊Write(enc.GetBytes(xml), 0, xml.Length);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return ReadMessage(this.Stream);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos520384" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-5: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ExecuteCommand()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method for OpenVAS</span></span></p><p class="calibre_6">To execute commands with the OpenVAS Management Protocol, we use a TCP socket to send XML to the server and receive XML in response. The <span class="calibre4">ExecuteCommand()</span> method takes only one argument: the XML document to send. We call <span class="calibre4">ToString()</span> on the XML document, save the result, and then use the <span class="calibre4">Stream</span> property’s <span class="calibre4">Write()</span> method ➊ to write the XML to the stream.</p><p id="filepos521104" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Reading the Server Message</span></span></span></p><p class="calibre_11">We use the <span class="calibre4">ReadMessage()</span> method shown in <a href="#filepos522759">Listing 7-6</a> to read the message returned by the server.</p><blockquote class="calibre_14"><span class="calibre4">private XDocument ReadMessage(SslStream ➊sslStream)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> using (var stream = new ➋MemoryStream())</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> int bytesRead = 0;</span><br class="calibre5"/><span class="calibre4"> ➌do</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> byte[] buffer = new byte[2048];</span><br class="calibre5"/><span class="calibre4"> bytesRead = sslStream.➍Read(buffer, 0, buffer.Length);</span><br class="calibre5"/><span class="calibre4"> stream.Write(buffer, 0, bytesRead);</span><br class="calibre5"/><span class="calibre4"> if (bytesRead &lt; buffer.Length)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➎try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string xml = System.Text.Encoding.ASCII.GetString(stream.ToArray());</span><br class="calibre5"/><span class="calibre4"> return XDocument.Parse(xml);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> catch</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ➏continue;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> while (bytesRead &gt; 0);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> return null;</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos522759" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-6: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ReadMessage()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method for OpenVAS</span></span></p><p class="calibre_6">This method reads an XML document from the TCP stream in chunks and returns the document (or null) to the caller. After passing an <span class="calibre4">sslStream</span> ➊ to the method, we declare a <span class="calibre4">MemoryStream</span> ➋, which allows us to dynamically store the data we receive from the server. We then declare an integer to store the number of bytes read and use a <span class="calibre4">do</span>/<span class="calibre4">while</span> loop ➌ to create a 2048-byte buffer to read the data into. Next, we call <span class="calibre4">Read()</span> ➍ on the <span class="calibre4">SslStream</span> to fill the buffer with the number of bytes read from the stream, and then we copy the data coming from OpenVAS to the <span class="calibre4">MemoryStream</span> using <span class="calibre4">Write()</span> so we can parse the data into XML later.</p><p class="calibre_6">If the server returns less data than the buffer can contain, we need to check whether we have read a valid XML document from the server. To do so, we use <span class="calibre4">GetString()</span> within a <span class="calibre4">try</span>/<span class="calibre4">catch</span> block ➎ to convert the bytes stored in the <span class="calibre4">MemoryStream</span> into a parseable string and attempt to parse the XML, since parsing will throw an exception if the XML isn’t valid. If no exception is thrown, we return the XML document. If an exception is thrown, we know that we haven’t finished reading the stream, so we call <span class="calibre4">continue</span> ➏ to read more data. If we finish reading bytes from the stream and have yet to return a valid XML document, we return null. This is a bit of defense, in case communication with OpenVAS is lost in the middle and we aren’t able to read the entire API response. Returning null allows us to check whether the response from OpenVAS is valid later since null will only be returned if we couldn’t read the full XML response.</p><p id="filepos524942" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Setting Up the TCP Stream to Send and Receive Commands</span></span></span></p><p class="calibre_11"><a href="#filepos526238">Listing 7-7</a> shows the <span class="calibre4">GetStream()</span> method that first appears in <a href="#filepos515080">Listing 7-3</a>. It makes the actual TCP connection to the OpenVAS server that we’ll use to send and receive commands.</p><blockquote class="calibre_14"><span class="calibre4">private void GetStream()</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> if (_stream == null || !_stream.CanRead)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> TcpClient client = new ➊TcpClient(this.ServerIPAddress.ToString(), this.ServerPort);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> _stream = new ➋SslStream(client.GetStream(), false,</span><br class="calibre5"/><span class="calibre4"> new RemoteCertificateValidationCallback (ValidateServerCertificate),</span><br class="calibre5"/><span class="calibre4"> (sender, targetHost, localCertificates, remoteCertificate, acceptableIssuers) =&gt; null);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> _stream.➌AuthenticateAsClient("OpenVAS", null, SslProtocols.Tls, false);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos526238" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-7: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">OpenVASSession</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">constructor’s</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetStream()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The <span class="calibre4">GetStream()</span> sets up the TCP stream for use in the rest of the class when communicating with OpenVAS. To do this, we instantiate a new <span class="calibre4">TcpClient</span> ➊ with the server by passing the <span class="calibre4">ServerIPAddress</span> and <span class="calibre4">ServerPort</span> properties to <span class="calibre4">TcpClient</span> if the stream is invalid. We wrap the stream in an <span class="calibre4">SslStream</span> ➋ that will not verify SSL certificates since the SSL certificates are self-signed and will throw an error; then we perform the SSL handshake by calling <span class="calibre4">AuthenticateAsClient()</span> ➌. The TCP stream to the OpenVAS server can now be used by the rest of the methods when we begin sending commands and receiving responses.</p><p id="filepos527401" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Certificate Validation and Garbage Collection</span></span></span></p><p class="calibre_11"><a href="#filepos528378">Listing 7-8</a> shows the methods used to validate SSL certificates (since the SSL certificates OpenVAS uses by default are self-signed) and clean up our session once we’ve finished with it.</p><blockquote class="calibre_14"><span class="calibre4">private bool ValidateServerCertificate(object sender, X509Certificate certificate,</span><br class="calibre5"/><span class="calibre4"> X509Chain chain, SslPolicyErrors sslPolicyErrors)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> return ➊true;</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">public void Dispose()</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> if (_stream != null)</span><br class="calibre5"/><span class="calibre4"> ➋_stream.Dispose();</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos528378" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-8: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ValidateServerCertificate()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">and</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Dispose()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">methods</span></span></p><p class="calibre_6">Returning <span class="calibre4">true</span> ➊ is generally poor practice, but since in our case OpenVAS is using a self-signed SSL certificate that would not otherwise validate, we must allow all certs. As with earlier examples, we create the <span class="calibre4">Dispose()</span> method so we can clean up after dealing with network or file streams. If the stream in the <span class="calibre4">OpenVASSession</span> class isn’t null, we dispose of the internal stream ➋ used to communicate with OpenVAS.</p><p id="filepos529259" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Getting the OpenVAS Version</span></span></span></p><p class="calibre_11">We can now drive OpenVAS to send commands and retrieve responses, as shown in <a href="#filepos530481">Listing 7-9</a>. For instance, we can run commands such as the <span class="calibre4">get_version</span> command, which returns version information for the OpenVAS instance. We’ll wrap similar functionality later in the <span class="calibre4">OpenVASManager</span> class.</p><blockquote class="calibre_14"><span class="calibre4">class MainClass</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (OpenVASSession session = new ➊OpenVASSession("admin", "admin", "192.168.1.19"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> XDocument doc = session.➋ExecuteCommand(</span><br class="calibre5"/><span class="calibre4"> XDocument.Parse("&lt;get_version /&gt;"));</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Console.WriteLine(doc.ToString());</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos530481" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-9: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method driving OpenVAS to retrieve the current version</span></span></p><p class="calibre_6">We create a new <span class="calibre4">OpenVASSession</span> ➊ by passing in a username, password, and host. Next, we pass <span class="calibre4">ExecuteCommand()</span> ➋ an <span class="calibre4">XDocument</span> requesting the OpenVAS version, store the result in a new <span class="calibre4">XDocument</span>, and then write it to the screen. The output from <a href="#filepos530481">Listing 7-9</a> should look like <a href="#filepos531469">Listing 7-10</a>.</p><blockquote class="calibre_14"><span class="calibre4">&lt;get_version_response status="200" status_text="OK"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;version&gt;6.0&lt;/version&gt;</span><br class="calibre5"/><span class="calibre4">&lt;/get_version_response&gt; </span><a id="filepos531469"/><span class="calibre4"><span class="italic">Listing 7-10: The OpenVAS response to</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">&lt;get_version /&gt;</span></span></blockquote><p id="filepos531628" class="calibre_10"><span class="calibre3"><span class="bold"> The OpenVASManager Class</span></span></p><p class="calibre_11">We’ll use the <span class="calibre4">OpenVASManager</span> class (shown in <a href="#filepos533004">Listing 7-11</a>) to wrap the API calls to start a scan, monitor the scan, and get the scan results.</p><blockquote class="calibre_14"><span class="calibre4">public class OpenVASManager : IDisposable</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> private OpenVASSession _session;</span><br class="calibre5"/><span class="calibre4"> public OpenVASManager(OpenVASSession ➊session)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> if (session != null)</span><br class="calibre5"/><span class="calibre4"> _session = session;</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> throw new ArgumentNullException("session");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public XDocument ➋GetVersion()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return _session.ExecuteCommand(XDocument.Parse("&lt;get_version /&gt;"));</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> private void Dispose()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> _session.Dispose();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos533004" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-11: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">OpenVASManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">constructor and</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetVersion()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method</span></span></p><p class="calibre_6">The <span class="calibre4">OpenVASManager</span> class constructor takes one argument, an <span class="calibre4">OpenVASSession</span> ➊. If the session passed as the argument is null, we throw an exception because we can’t communicate with OpenVAS without a valid session. Otherwise, we assign the session to a local class variable that we can use from the methods in the class, such as <span class="calibre4">GetVersion()</span>. We then implement <span class="calibre4">GetVersion()</span> ➋ to get the version of OpenVAS (as in <a href="#filepos530481">Listing 7-9</a>) and the <span class="calibre4">Dispose()</span> method.</p><p class="calibre_6">We can now replace the code calling <span class="calibre4">ExecuteCommand()</span> in our <span class="calibre4">Main()</span> method with the <span class="calibre4">OpenVASManager</span> to retrieve the OpenVAS version, as shown in <a href="#filepos534946">Listing 7-12</a>.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> using (OpenVASSession session = new OpenVASSession("admin", "admin", "192.168.1.19"))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (OpenVASManager manager = new OpenVASManager(session))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> XDocument version = manager.GetVersion();</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(version);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos534946" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-12: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method retrieving the OpenVAS version with the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">OpenVASManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class</span></span></p><p class="calibre_6"> The programmer no longer needs to remember the XML required to get the version information because it is abstracted away behind a convenient method call. We can follow this same pattern for the rest of the API commands we will be calling as well.</p><p id="filepos535611" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Getting Scan Configurations and Creating Targets</span></span></span></p><p class="calibre_11"><a href="#filepos536788">Listing 7-13</a> shows how we’ll add the commands to run in <span class="calibre4">OpenVASManager</span> to create a new target and retrieve scan configurations.</p><blockquote class="calibre_14"><span class="calibre4">public XDocument GetScanConfigurations()</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> return _session.ExecuteCommand(XDocument.Parse(➊"&lt;get_configs /&gt;"));</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">public XDocument CreateSimpleTarget(string cidrRange, string targetName)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> XDocument createTargetXML = new XDocument(</span><br class="calibre5"/><span class="calibre4"> new XElement(➋"create_target",</span><br class="calibre5"/><span class="calibre4"> new XElement("name", targetName),</span><br class="calibre5"/><span class="calibre4"> new XElement("hosts", cidrRange)));</span><br class="calibre5"/><span class="calibre4"> return _session.ExecuteCommand(createTargetXML);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos536788" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-13: The OpenVAS</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">GetScanConfigurations()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">and</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">CreateSimpleTarget()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">methods</span></span></p><p class="calibre_6">The <span class="calibre4">GetScanConfigurations()</span> method passes the <span class="calibre4">&lt;get_configs /&gt;</span> command ➊ to OpenVAS and returns the response. The <span class="calibre4">CreateSimpleTarget()</span> method accepts arguments for the IP address or CIDR range (192.168.1.0/24, for instance) and a target name, which we use to build an XML document using <span class="calibre4">XDocument</span> and <span class="calibre4">XElement</span>. The first <span class="calibre4">XElement</span> creates a root XML node of <span class="calibre4">create_target</span> ➋. The remaining two contain the name of the target and its hosts. <a href="#filepos538158">Listing 7-14</a> shows the resulting XML document.</p><blockquote class="calibre_14"><span class="calibre4">&lt;create_target&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;name&gt;Home Network&lt;/name&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;hosts&gt;192.168.1.0/24&lt;/hosts&gt;</span><br class="calibre5"/><span class="calibre4">&lt;/create_target&gt; </span><a id="filepos538158"/><span class="calibre4"><span class="italic">Listing 7-14: The OpenVAS</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">create_target</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">command XML</span></span></blockquote><p class="calibre_6"><a href="#filepos539584">Listing 7-15</a> shows how we create the target and scan it for the Discovery scan configuration, which performs a basic port scan and other basic network tests.</p><blockquote class="calibre_14"><span class="calibre4">XDocument target = manager.➊CreateSimpleTarget("192.168.1.31", Guid.NewGuid().ToString());</span><br class="calibre5"/><span class="calibre4">string targetID = target.Root.Attribute("id").➋Value;</span><br class="calibre5"/><span class="calibre4">XDocument configs = manager.GetScanConfigurations();</span><br class="calibre5"/><span class="calibre4">string discoveryConfigID = string.Empty;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">foreach (XElement node in configs.Descendants("name"))</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> if (node.Value == ➌"Discovery")</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> discoveryConfigID = node.Parent.Attribute ("id").Value;</span><br class="calibre5"/><span class="calibre4"> break;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">Console.➍WriteLine("Creating scan of target " + targetID + " with scan config " +</span><br class="calibre5"/><span class="calibre4"> discoveryConfigID); </span><a id="filepos539584"/><span class="calibre4"><span class="italic">Listing 7-15: Creating an OpenVAS target and retrieving the scan config ID</span></span></blockquote><p class="calibre_6">First, we create the target to scan with <span class="calibre4">CreateSimpleTarget()</span> ➊ by passing in an IP address to scan and a new <span class="calibre4">Guid</span> as the name of the target. For purposes of automation, we don’t need a human-readable name for the target, so we just generate a <span class="calibre4">Guid</span> for the name.</p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">In the future, you might want to name a target</span> Databases <span class="italic">or</span> Workstations <span class="italic">to separate specific machines on your network for scanning. You could specify readable names like these instead, but names must be unique for each target.)</span></blockquote><p class="calibre_6">Here’s what a response to successful target creation should look like: &lt;create_target_response status="201" status_text="OK, resource created"<br class="calibre5"/>id="254cd3ef-bbe1-4d58-859d-21b8d0c046c6"/&gt; After creating the target, we grab the value of the <span class="calibre4">id</span> attribute ➋ from the XML response and store it for later use when we need to get the scan status. We then call <span class="calibre4">GetScanConfigurations()</span> to retrieve all available scan configurations, store them, and loop through them to find the one with the name of <span class="calibre4">Discovery</span> ➌. Finally, we print a message to the screen with <span class="calibre4">WriteLine()</span> ➍, telling the user which target and scan configuration ID will be used for the scan.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Creating and Starting Tasks</span></span></p><p class="calibre_11"><a href="#filepos542916">Listing 7-16</a> shows how we create and start a scan with the <span class="calibre4">OpenVASManager</span> class.</p><blockquote class="calibre_14"><span class="calibre4">public XDocument ➊CreateSimpleTask(string name, string comment, Guid configID, Guid targetID)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> XDocument createTaskXML = new XDocument(</span><br class="calibre5"/><span class="calibre4"> new XElement(➋"create_task",</span><br class="calibre5"/><span class="calibre4"> new XElement("name", name),</span><br class="calibre5"/><span class="calibre4"> new XElement("comment", comment),</span><br class="calibre5"/><span class="calibre4"> new XElement("config",</span><br class="calibre5"/><span class="calibre4"> new XAttribute(➌"id", configID.ToString())),</span><br class="calibre5"/><span class="calibre4"> new XElement("target",</span><br class="calibre5"/><span class="calibre4"> new XAttribute("id", targetID.ToString()))));</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return _session.ExecuteCommand(createTaskXML);</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><span class="calibre4"> public XDocument ➍StartTask(Guid taskID)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> XDocument startTaskXML = new XDocument(</span><br class="calibre5"/><span class="calibre4"> new XElement(➎"start_task",</span><br class="calibre5"/><span class="calibre4"> new XAttribute("task_id", taskID.ToString())));</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return _session.ExecuteCommand(startTaskXML);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos542916" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-16: The OpenVAS methods to create and start a task</span></span></p><p class="calibre_6">The <span class="calibre4">CreateSimpleTask()</span> method ➊ creates a new task with a few basic pieces of information. It is possible to create very complex task configurations. For purposes of a basic vulnerability scan, we build a simple XML document with a root <span class="calibre4">create_task</span> element ➋ and some child elements to store configuration information. The first two child elements are the <span class="calibre4">name</span> and <span class="calibre4">comment</span> (or description) of the task. Next are the scan <span class="calibre4">config</span> and <span class="calibre4">target</span> elements, with values stored as <span class="calibre4">id</span> attributes ➌. After setting up our XML, we send the <span class="calibre4">create_task</span> command to OpenVAS and return the response.</p><p class="calibre_6">The <span class="calibre4">StartTask()</span> method ➍ accepts a single argument: the task ID to be started. We first create an XML element called <span class="calibre4">start_task</span> ➎ with the attribute <span class="calibre4">task_id</span>.</p><p class="calibre_6"><a href="#filepos544694">Listing 7-17</a> shows how we add these two methods to <span class="calibre4">Main()</span>.</p><blockquote class="calibre_14"><span class="calibre4">XDocument task = manager.CreateSimpleTask(Guid.NewGuid().ToString(),</span><br class="calibre5"/><span class="calibre4"> string.Empty, new Guid(discoveryConfigID), new Guid(targetID));</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">Guid taskID = new Guid(task.Root.➊Attribute("id").Value);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">manager.➋StartTask(taskID); </span><a id="filepos544694"/><span class="calibre4"><span class="italic">Listing 7-17: Creating and starting an OpenVAS task</span></span></blockquote><p class="calibre_6">To call <span class="calibre4">CreateSimpleTask()</span>, we pass a new <span class="calibre4">Guid</span> as the name of the task, an empty string for the comment, and the scan config ID and the target ID as the argument. We pull the <span class="calibre4">id</span> attribute ➊ from the root node of the XML document returned, which is the task ID; then we pass it to <span class="calibre4">StartTask()</span> ➋ to start the OpenVAS scan.</p><p class="calibre_10"><span class="calibre3"><span class="bold">Watching a Scan and Getting Scan Results</span></span></p><p class="calibre_11">In order to watch the scan, we implement <span class="calibre4">GetTasks()</span> and <span class="calibre4">GetTaskResults()</span>, as shown in <a href="#filepos546926">Listing 7-18</a>. The <span class="calibre4">GetTasks()</span> method (which is implemented first) returns a list of tasks and their status so we can monitor our scan until completion. The <span class="calibre4">GetTaskResults()</span> method returns the scan results of a given task so that we can see any vulnerabilities OpenVAS finds.</p><blockquote class="calibre_14"><span class="calibre4">public XDocument GetTasks(Guid? taskID = ➊null)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> if (taskID != null)</span><br class="calibre5"/><span class="calibre4"> return _session.ExecuteCommand(new XDocument(</span><br class="calibre5"/><span class="calibre4"> new XElement("get_tasks",</span><br class="calibre5"/><span class="calibre4"> new ➋XAttribute("task_id", taskID.ToString()))));</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return _session.ExecuteCommand(➌XDocument.Parse("&lt;get_tasks /&gt;"));</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">public XDocument GetTaskResults(Guid taskID)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> XDocument getTaskResultsXML = new XDocument(</span><br class="calibre5"/><span class="calibre4"> new ➍XElement("get_results",</span><br class="calibre5"/><span class="calibre4"> new XAttribute("task_id", taskID.ToString())));</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return _session.ExecuteCommand(getTaskResultsXML);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos546926" class="calibre_15"><span class="calibre4"><span class="italic">Listing 7-18: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">OpenVASManager</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">methods to get a list of current tasks and retrieve the results of a given task</span></span></p><p class="calibre_6">The <span class="calibre4">GetTasks()</span> method has a single, optional argument that is null ➊ by default. The <span class="calibre4">GetTasks()</span> method will return either all of the current tasks or just a single task, depending on whether the <span class="calibre4">taskID</span> argument passed in is null. If the task ID passed in is not null, we create a new XML element called <span class="calibre4">get_tasks</span> with a <span class="calibre4">task_id</span> attribute ➋ of the task ID passed in; then we send the <span class="calibre4">get_tasks</span> command to OpenVAS and return the response. If the ID is null, we use the <span class="calibre4">XDocument.Parse()</span> method ➌ to create a new <span class="calibre4">get_tasks</span> element without a specific ID to get; then we execute the command and return the result.</p><p class="calibre_6">The <span class="calibre4">GetTaskResults()</span> method works like <span class="calibre4">GetTasks()</span> except that its single argument is not optional. Using the ID passed in as the argument, we create a <span class="calibre4">get_results</span> XML node ➍ with a <span class="calibre4">task_id</span> attribute. After passing this XML node to <span class="calibre4">ExecuteCommand()</span>, we return the response.</p><p id="filepos548484" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Wrapping Up the Automation</span></span></span></p><p class="calibre_11"><a href="#filepos549838">Listing 7-19</a> shows how we can monitor the scan and retrieve its results with the methods we just implemented. In our <span class="calibre4">Main()</span> method driving the <span class="calibre4">Session</span>/<span class="calibre4">Manager</span> classes, we can add the following code to round out our automation.</p><blockquote class="calibre_14"><span class="calibre4">XDocument status = manager.➊GetTasks(taskID);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">while (status.➋Descendants("status").First().Value != "Done")</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> Thread.Sleep(5000);</span><br class="calibre5"/><span class="calibre4"> Console.Clear();</span><br class="calibre5"/><span class="calibre4"> string percentComplete = status.➌Descendants("progress").First().Nodes()</span><br class="calibre5"/><span class="calibre4"> .OfType&lt;XText&gt;().First().Value;</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("The scan is " + percentComplete + "% done.");</span><br class="calibre5"/><span class="calibre4"> status = manager.➍GetTasks(taskID);</span><br class="calibre5"/><span class="calibre4">}</span><br class="calibre5"/><span class="calibre4"> XDocument results = manager.➎GetTaskResults(taskID);</span><br class="calibre5"/><span class="calibre4">Console.WriteLine(results.ToString()); </span><a id="filepos549838"/><span class="calibre4"><span class="italic">Listing 7-19: Watching an OpenVAS scan until finished and then retrieving the scan results and printing them</span></span></blockquote><p class="calibre_6">We call <span class="calibre4">GetTasks()</span> ➊ by passing in the task ID saved earlier and then save the results in the <span class="calibre4">status</span> variable. Then, we use the LINQ to XML method <span class="calibre4">Descendants()</span> ➋ to see whether the <span class="calibre4">status</span> node in the XML document is equal to <span class="calibre4">Done</span>, meaning the scan is finished. If the scan is not done, we <span class="calibre4">Sleep()</span> for five seconds and then clear the console screen. We then get the completion percentage of the scan by using <span class="calibre4">Descendants()</span> ➌ to retrieve the <span class="calibre4">progress</span> node, print the percentage, ask OpenVAS again for the current status with <span class="calibre4">GetTasks()</span> ➍, and so on until the scan reports it is done.</p><p class="calibre_6">Once the scan finishes, we call <span class="calibre4">GetTaskResults()</span> ➎ by passing in the task ID; then we save and print the XML document containing the scan results to the console screen. This document includes a range of useful information, including detected hosts and open ports, known active services across the scanned hosts, and known vulnerabilities such as old versions of software.</p><p id="filepos551274" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Running the Automation</span></span></span></p><p class="calibre_11">Scans may take a while, depending on the machine running OpenVAS and the speed of your network. While running, our automation will display a friendly message to let the user know the status of the current scan. Successful output should look similar to the heavily trimmed sample report shown in <a href="#filepos552801">Listing 7-20</a>.</p><blockquote class="calibre_14"><span class="calibre4">The scan is 1% done.</span><br class="calibre5"/><span class="calibre4">The scan is 8% done.</span><br class="calibre5"/><span class="calibre4">The scan is 8% done.</span><br class="calibre5"/><span class="calibre4">The scan is 46% done.</span><br class="calibre5"/><span class="calibre4">The scan is 50% done.</span><br class="calibre5"/><span class="calibre4">The scan is 58% done.</span><br class="calibre5"/><span class="calibre4">The scan is 72% done.</span><br class="calibre5"/><span class="calibre4">The scan is 84% done.</span><br class="calibre5"/><span class="calibre4">The scan is 94% done.</span><br class="calibre5"/><span class="calibre4">The scan is 98% done.</span><br class="calibre5"/><span class="calibre4">&lt;get_results_response status="200" status_text="OK"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;result id="57e9d1fa-7ad9-4649-914d-4591321d061a"&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;owner&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;name&gt;admin&lt;/name&gt;</span><br class="calibre5"/><span class="calibre4"> &lt;/owner&gt;</span><br class="calibre5"/><span class="calibre4"><span class="italic">--snip--</span></span><br class="calibre5"/><span class="calibre4"> &lt;/result&gt;</span><br class="calibre5"/><span class="calibre4">&lt;/get_results_response&gt; </span><a id="filepos552801"/><span class="calibre4"><span class="italic">Listing 7-20: Sample output of the OpenVAS automation</span></span></blockquote><p id="filepos552903" class="calibre_10"><span class="calibre3"><span class="bold"> Conclusion</span></span></p><p class="calibre_11">This chapter has shown you how to use the built-in networking classes in C# to automate OpenVAS. You learned how to create an SSL connection with OpenVAS and how to communicate using the XML-based OMP. You learned how to create a target to scan, retrieve available scan configurations, and start a particular scan on a target. You also learned how to monitor the progress of a scan and retrieve its results in an XML report.</p><p class="calibre_6">With these basic blocks, we can begin remediating vulnerabilities on the network and then run new scans to ensure the vulnerabilities are no longer reported. The OpenVAS scanner is a very powerful tool, and we have only scratched the surface. OpenVAS constantly has updated vulnerability feeds and can be used as an effective vulnerability management solution.</p><p class="calibre_6">As a next step, you might want to look into managing credentials for authenticated vulnerability scans over SSH or creating custom scan configurations to check for specific policy configurations. All of this is possible, and more, through OpenVAS.</p><div class="mbp_pagebreak" id="calibre_pb_12"/>
</body></html>