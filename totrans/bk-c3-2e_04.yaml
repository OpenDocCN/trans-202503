- en: '**4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PSEUDO-CLASSES AND PSEUDO-ELEMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The very first CSS specification, CSS1, introduced the concepts of *pseudo-classes*
    and *pseudo-elements*. These are selectors that act on information about elements
    that extends (or sits outside of) the document tree. A pseudo-class differentiates
    among an element’s different states or types; these include—but are not limited
    to—those that provide information about link states: `:hover`, `:visited`, `:active`,
    and so on. A pseudo-element provides access to an element’s subpart, which includes
    those pseudo-elements that select portions of text nodes; for instance, `:first-line`
    and `:first-letter`.'
  prefs: []
  type: TYPE_NORMAL
- en: The selectors just mentioned have been around since the first CSS specification,
    but a handful more were added in CSS2.1—although pseudo-element support has not
    been well implemented until relatively recently. CSS3 builds on these foundations
    with an expanded range of pseudo-classes, as well as a (slightly) tweaked syntax
    to differentiate pseudo-elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of having more methods for traversing documents should be clear:
    Fewer styling hooks are required. You are most likely familiar with markup like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The markup contains class names to describe each element’s position in the
    document tree: `first` (➊) and `last` (➍) show that the `li` elements are the
    first and last children of the `ul` element, and `odd` (➋) is used for the oddnumbered
    `li` elements. An extra `span` (➌) is included around the first letter of the
    initial `li` element.'
  prefs: []
  type: TYPE_NORMAL
- en: You mark up code like this when you want to add styles to alternating elements,
    set different values on the first and last elements, or add special formatting
    to the first letter of a text node. This markup detracts from the clarity and
    semantic meaning of your code, but in many cases you need it to provide the hooks
    to hang your styles on.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS3’s new methods allow you to achieve the same visual results without muddying
    the markup with unnecessary classes and nonsemantic elements, making for cleaner
    and more maintainable code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The other major advantage of the new selectors is that if new elements are
    added to the markup, class names don’t have to be updated to accommodate them
    while still keeping order. This change takes CSS a big step closer to achieving
    its stated goal: the separation of content and presentation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structural Pseudo-classes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I stated in the introduction to this chapter, a pseudo-class provides a way
    to select an element based on information that is not specified in the document
    tree. Various subtypes are available, the most common of which is the *structural
    pseudo-class*. These subtypes are used to select elements that are not accessible
    using simple selectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first of the two `p` elements is the first child of the `div` element.
    That’s obvious from the document tree, but the document tree doesn’t provide any
    information that would allow you to apply a rule only to that element. CSS2 introduced
    the `:first-child` pseudo-class for exactly that reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This pseudo-class allows you to make a selection based on information that exists
    but isn’t provided as an attribute of the element—the exact purpose of a pseudo-class.
    Since `:first-child` was introduced in CSS2, it has been the only pseudo-class
    of its type. But CSS3 extends the range greatly with the introduction of 11 new
    structural pseudo-classes.
  prefs: []
  type: TYPE_NORMAL
- en: '***The :nth-* Pseudo-classes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Four of the new pseudo-classes are based on a count value used to find an element’s
    position in the document tree; for this count, you use the syntax `:nth-*`. Note
    that I’ve used the asterisk here in place of a number of different values, each
    of which I’ll introduce throughout the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax of the `:nth-*` pseudo-classes is quite straightforward. By
    default, `n` represents a number that begins at 0 and increments by 1 (1, 2, 3,
    etc.). Another integer can be passed into it as a multiplier. For example, `2n`
    is every multiple of 2 (2, 4, 6, etc.), `3n` is every multiple of 3 (3, 6, 9,
    etc.), and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first example uses the default value `n`, so all elements of type `*E*`
    would be selected; in practice, this is the same as using a simple element selector.
    The next example selects every other `*E*` element, and the final example selects
    every third element of type `*E*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also use the mathematical operators for plus (+) and minus (−). So
    `2n+1` selects every multiple of two plus one (1, 3, 5, etc.), and `3n-1` selects
    every multiple of three minus one (2, 5, 8, etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first example selects every element of type `*E*` except for the first instance;
    the count for this would be 2, 3, 4, 5, and so on. The next example selects every
    odd-numbered `*E*` element (1, 3, 5, and so on). The final example, as just mentioned,
    selects elements in the sequence 2, 5, 8, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two special keyword values, `even` and `odd`, are also available; you can use
    these to replace `2n` and `2n+1`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it’s also acceptable to use `0n` (that’s zero) as a value. It has
    no use of itself but is very useful when combined with a mathematical operator,
    as it allows you to pinpoint a single element without any recurrence. In fact,
    for brevity, you can supply only the value after the mathematical operator. For
    example, to select only the third element in a selector list, both of these values
    are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With the basic syntax out of the way, let’s move on to the pseudo-classes themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '**:nth-child() and :nth-of-type()**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Most of the new structural pseudo-classes allow you to select elements based
    on either their position in the document tree in relation to their parent element
    (`-child`) or their classification (`-of-type`). Often these definitions overlap,
    but there are crucial differences between them.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest examples of these pseudo-classes are `:nth-child()` and `:nth-of-type()`.
    The first, `:nth-child()`, selects an element based on its position in a count
    of the total number of children in its parent element; `:nth-of-type()` bases
    its count not on the total children, but only on those of the specified element
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, rules ➊ and ➋ are equivalent because the count value (`n`)
    is left at the default; both of these simply select all child elements of type
    `*E*`. The difference reveals itself in the later examples: in ➌, `:nth-child(2n)`
    selects all elements of type `*E*` from a count that includes all its siblings
    but only where those elements are even-numbered. In ➍, by comparison, `:nth-of-type(2n)`
    selects all even-numbered elements of type `*E*` from a count that includes only
    those elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These rules are much easier to demonstrate than they are to explain. I’ll demonstrate
    the difference between them with the following example (text has been truncated
    for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And in my style sheet I’ll use these two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the differing result of the two rules in [Figure 4-1](ch04.html#ch04fig1).
    In the example markup, the `div` element has a total of four child elements: one
    `h2` and three `p`. The `:nth-child(2n)` selector in rule ➊ makes bold every second
    child (the first and third paragraphs), as seen in the box on the left. Compare
    that to the box on the right, which has rule ➋ applied; the `:nth-of-type(2n)`
    selector ignores the `h2` and applies a bold weight to every second instance of
    the three elements of type `p`—that is, only the second paragraph.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f04-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: Comparing the result of using the* `*:nth-child()*` *selector
    (left) with* `*:nth-of-type()*` *(right)*'
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned before, and as you can no doubt deduce from the previous examples,
    `:nth-child()` and `:nth-of-type()` have a fair bit of overlap, and you can often
    use them interchangeably, as I do in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: The table on the left of [Figure 4-2](ch04.html#ch04fig2) shows the five-day
    weather forecast for London (so temperatures are given in degrees Celsius—0°C
    equals 32°F). These figures were taken in January—it’s not *always* this cold
    here! All of the information I want to convey is in the table, but without any
    definition of rows, I find the table difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: Now compare this table to the one on the right in the same [Figure 4-2](ch04.html#ch04fig2).
    Here, I used the technique known as *zebra striping* to aid the eye along the
    row, making the data much more readable to me.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f04-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Weather forecast table (left) and better formatted for readability
    (right). Weather data from* [http://bbc.co.uk/weather/](http://bbc.co.uk/weather/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'I achieved this technique with a single CSS3 declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, I could have used `:nth-child()` instead, as in the markup
    all of the child elements of `tbody` are of the same type: `tr`. Where every child
    is of the same type, `:nth-child()` and `:nth-of-type()` are interchangeable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**:nth-last-child() and :nth-last-of-type()**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `:nth-last-child()` and `:nth-last-of-type()` pseudo-classes accept the
    same arguments as `:nth-child()` and `:nth-of-type()`, except they are counted
    from the last element, working in reverse. For example, say I want to use some
    visual shorthand to show in my weather table that the forecasts for days four
    and five are less certain than for the preceding days. You can see how this would
    look in [Figure 4-3](ch04.html#ch04fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f04-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Extra formatting using* `*:nth-last-child()*`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here I italicized the characters in the last two rows by using the `:nth-last-child()`
    pseudo-class (although, once again, `:nth-last-of-type()` would serve just as
    well in this example), passing an argument of `-n+2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I used the negative value (`-n`) to increment the count negatively, which has
    the effect of acting in reverse. Because `:nth-last-child()` and `:nth-last-of-type()`
    count backward through the tree, using a negative value here makes the count go
    forward! The count starts at the last `tr` element in the table and counts up
    in reverse order, so the last and penultimate lines are the first two counted
    and are, therefore, italicized. This may seem counterintuitive, but it’ll become
    second nature as you traverse the document tree.
  prefs: []
  type: TYPE_NORMAL
- en: '***:first-of-type, :last-child, and :last-of-type***'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you take a look at the tables in [Figure 4-2](ch04.html#ch04fig2), you’ll
    notice that the text in the Weather column is left-aligned, whereas the other
    columns are center-aligned. I did this using the `:first-of-type` pseudo-class,
    which is similar to the `:first-child` selector introduced in CSS2, but with the
    same difference in type and child that you’ve seen so far in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As you’re no doubt aware, the `:first-child` pseudo-class is a selector used
    to apply rules to an element that is the first child of its parent. As with `:nth-of-type()`,
    however, `:first-of-type` is more specific, applying only to the element that
    is the first child of the named type of its parent. A pair of counterpart pseudo-classes
    is also available, `:last-child` and `:last-of-type`, which—as you might have
    guessed—select the last child element or the last child element of that type,
    respectively, of the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the weather table examples in the previous section, the markup for each
    row in the table body is structured like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'I want to left-align the content of the second column, so I can’t use `:first-child`
    here as the first child is a `th`. Instead, I use the `:first-of-type` selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ll show two more examples to demonstrate the difference clearly. I’ll apply
    both of the examples to the same chunk of markup (I’ve truncated the text for
    clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first example, I use `:first-child` and `:last-child`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The result is shown in [Figure 4-4](ch04.html#ch04fig4). The `h2` element is
    the first child of the `div`, so it has an underline applied to it. The last child
    of the `div` is the `h3` element, so that is italicized. All quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f04-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: Applying the* `*:first-child*` *and* `*:last-child*` *selectors*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see the difference when we use the `:first-of-type` and `:last-of-type`
    selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the result in [Figure 4-5](ch04.html#ch04fig5). You’ll notice
    that three elements—`h2`, `h3`, and the first `p`—are underlined. This is because
    they are the first instance of that element type. Likewise, the `h2`, `h3`, and
    last `p` are all italicized. Again, this is because they are all the last element
    of that type; the `h2` and `h3` are both the first and last of their type, and
    so both rules are applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f04-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: Applying the* `*:first-of-type*` *and* `*:last-of-type*` *selectors*'
  prefs: []
  type: TYPE_NORMAL
- en: As with all of the `*-type` and `*-child` pseudo-classes, the distinction is
    subtle, and sometimes the last child element is also the last of its type, so
    the selectors are interchangeable. But as I’ve just shown, at times, they have
    different applications.
  prefs: []
  type: TYPE_NORMAL
- en: '***:only-child and :only-of-type***'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'These two pseudo-classes are used to select elements in the document tree that
    have a parent but either no sibling elements (`:only-child`) or no siblings of
    the same type (`:only-of-type`). As with many of the previous pseudo-classes,
    these two overlap substantially in function, but this next example illustrates
    the difference between them. Take the following style rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'and then apply them to this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can see the result in [Figure 4-6](ch04.html#ch04fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f04-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Comparing* `*:only-child*` *and* `*:only-of-type*`'
  prefs: []
  type: TYPE_NORMAL
- en: Both `p` elements are the only elements of their type in their level of the
    document tree, so the `:only-of-type` rule selects both and italicizes them. The
    `p` element inside the blockquote, however, is also the only child in its level,
    so it’s also subject to the `:only-child` rule that applies the underline.
  prefs: []
  type: TYPE_NORMAL
- en: Using `:only-of-type` allows you to pick an element from among others, whereas
    `:only-child` requires the element to sit alone.
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Pseudo-classes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the structural pseudo-classes discussed so far in this chapter,
    CSS3 introduces a number of pseudo-classes that allow you to select elements based
    on other criteria. These include link destinations, user interface elements, and
    even an inverse selector that permits selection based on what an element *isn’t*!
  prefs: []
  type: TYPE_NORMAL
- en: '***:target***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On the Web, sites don’t just link between pages but also provide internal links
    to specific elements. A URI can contain a reference to a unique ID or a named
    anchor. For example, if you had this markup in a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'you could refer to it with this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `:target` pseudo-class allows you to apply styles to the element when the
    referring URI has been followed. In this example, if you want to apply styles
    to the `h4` element when the URI is followed, you use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A popular practice is to highlight the subject of an internal link visually
    to provide a clear cue to the user. Consider, for example, the standard pattern
    for blog comments, which are somewhat like this simplified markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And another fairly common pattern is to include links to individual comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `:target` pseudo-class, you can easily highlight the comment that
    the user wants to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-7](ch04.html#ch04fig7) shows a list of comments in two states: on
    the left, as they appear before the referring link has been clicked, and on the
    right, as they appear after the link has been clicked—with the element that the
    link refers to showing a different background color thanks to the `:target` selector.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f04-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: Highlighting applied with the* `*:target*` *pseudo-class*'
  prefs: []
  type: TYPE_NORMAL
- en: '***:empty***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `:empty` pseudo-class selects an element that has no children, including
    text nodes. Consider this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you apply this CSS rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: the rule is only applied to the first `td` element, as the other two contain
    a text node and a child element, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '***:root***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `:root` pseudo-class selects the first element in a document tree, which
    is only really handy if you’re adding a style sheet to XML documents—in HTML,
    the root will always be the `html` element. One small advantage of using `:root`
    in HTML is that you can use it to give a higher specificity to the `html` element,
    which could be useful if you need to override the simple type selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say you’re creating a base style sheet and want to set a property on
    the `html` element, which shouldn’t be altered. In this case, you would use something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The higher specificity gives precedence to this rule over any other rules applied
    to the `html` element, meaning the following is ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: But it’s unlikely that you’ll need to use this in most situations.
  prefs: []
  type: TYPE_NORMAL
- en: '***:not()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The negation pseudo-class `:not()` selects all elements *except* those that
    are given as the value of an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule selects all children of element `*E*` except for those of type `*F*`.
    For example, to color all the immediate child elements of a `div`, except for
    `p` elements, you use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how useful `:not()` is, consider a situation where you have the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now imagine you want to italicize all of the child `p` elements except for the
    first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this with CSS2, you applied a style to all the `p` elements and then
    applied a further style to reset the first element back to its previous state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With `:not()`, you can reduce that to a single rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The argument passed into `:not()` must be a simple selector—therefore combinators
    (such as `+` and `>`) and pseudo-elements (which I discuss in “[Pseudo-elements](ch04.html#ch04leve1sec47)”
    on [page 45](ch04.html#page_45)) are not valid values.
  prefs: []
  type: TYPE_NORMAL
- en: '***UI Element States***'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Elements relating to forms and user input can have various states; they can
    be disabled or checked, for example, by setting attribute values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'CSS3 has three UI state pseudo-class selectors, which allow you to apply rules
    to elements based on their current state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*HTML has no* `*enabled*` *attribute; elements that are not disabled are, by
    definition, enabled.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the effect of these pseudo-class selectors, consider the following style
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ll apply these rules to a form that has two text `input` elements, one of
    which has a `disabled` attribute (the form isn’t well-structured as I don’t have
    labels for the inputs, but I’ve left them out for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can see the results in [Figure 4-8](ch04.html#ch04fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f04-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: Disabled and enabled element states*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the disabled form element has grayed-out text (which is done
    automatically by the browser) and a gray dotted border (which I set in the style
    sheet). I set a solid black border around the enabled element.
  prefs: []
  type: TYPE_NORMAL
- en: I’m not giving a demonstration of the `checked` state here, as most browsers
    have different interpretations of which style rules can be applied to `checkbox`
    inputs. For a comprehensive overview of cross-browser styling of form elements,
    I highly recommend “Styling Form Controls with CSS” from the blog 456 Berea Street
    (*[http://www.456bereastreet.com/lab/styling-form-controls-revisited/](http://www.456bereastreet.com/lab/styling-form-controls-revisited/)*).
  prefs: []
  type: TYPE_NORMAL
- en: There is a fourth UI element state, `indeterminate`, which is used in a limited
    set of circumstances; for example, a radio button input in a group where no input
    has been checked would be classed as indeterminate, as would a `progress` element
    with no value supplied. Although implemented in some browsers, however, it hasn’t
    yet been fully defined, and its status is indeterminate (ha!).
  prefs: []
  type: TYPE_NORMAL
- en: '***Constraint Validation Pseudo-classes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: HTML5 introduced a new API for client-side validation of forms, known as the
    *constraint validation API*, which can be used to determine if certain requirements
    are met before the form contents are sent to the server. The constraint validation
    API brings along with it an associated range of new pseudo-classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mozilla Developer Network (MDN) has an excellent introduction to the Constraint
    Validation API at* [https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation/](https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under constraint validation, a form field can be made mandatory through use
    of the new `required` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can style elements depending on whether they’re required or optional by
    using their namesake pseudo-classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Each form field can be in one of two states of validation: either valid or
    invalid. If no specific constraints are applied, either by the browser or the
    author, a form field is valid by default. As before, each state has a namesake
    pseudo-class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In a form with which the user has yet to interact, fields with constraints
    that aren’t met—such as being required—will have rules set with the* `*:invalid*`
    *pseudo-class applied already.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, some HTML5 elements can have a permitted range of values, set by using
    the `min` and `max` attributes. You can style these elements depending on whether
    the current value is in or out of range by using, once again, a pair of namesake
    pseudo-classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Pseudo-elements**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like pseudo-classes, pseudo-elements provide information that is not specified
    in the document tree. But where pseudo-classes use “phantom” conditions such as
    an element’s position in the tree or its state, pseudo-elements go further and
    allow you to apply styles to elements that don’t exist in the tree at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'In CSS2, the four pseudo-elements are `:first-line` and `:first-letter`, which
    select subelements in text nodes, and `:after` and `:before`, which allow you
    to apply styles at the beginning and end of existing elements. CSS3 doesn’t introduce
    any new pseudo-elements, but it refines the definitions slightly and introduces
    a new syntax to differentiate them from pseudoclasses. In CSS3, pseudo-elements
    are prefixed with a double colon (`::`), like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The single colon syntax is still accepted for reasons of backward compatibility,
    although it is deprecated and you shouldn’t use it going forward.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The ::selection Pseudo-element***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Early versions of the CSS3 Selectors module included the definition of a `::selection`
    pseudo-element. Although formally removed from the module, it has been well implemented
    across desktop browsers (less so in mobile browsers). `::selection` is used to
    apply rules to an element that the user has selected in the browser (for example,
    a portion of a text node):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Only a limited number of properties can be applied with `::selection`: `color`,
    `background-color`, and the `background` shorthand (although not `background-image`).
    Using `::selection`, you can do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-9](ch04.html#ch04fig9) shows a comparison of the system-native `::selection`
    colors (top) and the colors I’ve applied with the `::selection` pseudo-element
    (bottom).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f04-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: Custom colors applied with the* `*::selection*` *pseudo-element*'
  prefs: []
  type: TYPE_NORMAL
- en: The `::selection` pseudo-element is implemented in Chrome, Safari, and IE9+
    without a prefix, and in Firefox with the `-moz-` prefix—so despite it no longer
    being part of the CSS3 specification, you can use it with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new range of pseudo-classes (and any pseudo-elements that may be defined
    in the future) makes document traversal far more flexible and powerful with CSS3
    than it ever was with its predecessors, and allows for much leaner and more maintainable
    markup.
  prefs: []
  type: TYPE_NORMAL
- en: The increased number of pseudo-classes based on the state of UI and form validation
    also gives users a much broader range of feedback, without relying on JavaScript.
    This is exceptionally useful for HTML5, with its increased focus on web applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**DOM and Attribute Selectors: Browser Support**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
  prefs: []
  type: TYPE_TB
- en: '| Structural pseudo-classes | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `:target` | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `:empty` | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `:root` | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `:not()` | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Pseudo-elements (`::` syntax) | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| UI element states | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Constraint validation | Yes | Yes | Yes | IE10^([*](ch04.html#footnote20a))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `::selection` | Yes | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '[*](ch04.html#footnote_20a) Does not support :in-range, :out-of-range'
  prefs: []
  type: TYPE_NORMAL
