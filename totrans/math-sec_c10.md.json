["```\nimport dlib\ndetector = dlib.get_frontal_face_detector()\npredictor = dlib.shape_predictor(\n    \"facial_model/shape_predictor_68_face_landmarks.dat\"\n)\n```", "```\nimport cv2\nimport imutils\ndef process_jpg(file_path):\n    img = cv2.imread(file_path)\n    image = imutils.resize(img, width=300)\n    return cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n```", "```\nfrom imutils import face_utils\ndef locate_landmarks(image_file):\n  ❶ gray = process_jpg(image_file)\n  ❷ clone = gray.copy()\n  ❸ rects = detector(clone, 1)\n    feature_coordinates = {}\n ❹ for (i, rect) in enumerate(rects):\n      ❺ shape = predictor(clone, rect)\n      ❻ shape = shape_to_np(shape) # See PoC code\n      ❼ for (part_name, (i, j)) in face_utils.FACIAL_LANDMARKS_IDXS.items():\n            if len(rects) >= 2:\n                feature_coordinates[part_name] = []\n            for x, y in shape[i:j]:\n              ❽ feature_coordinates[part_name].append((x, y))\n        face_points = []\n        for n in feature_coordinates.keys():\n          ❾ face_points += feature_coordinates[n]\n      ❿ feature_coordinates[part_name] = face_points\n    return feature_coordinates\n```", "```\ndef shape_to_np(shape, dtype=\"int\"):\n    coords = np.zeros((68, 2), dtype=dtype)\n    for i in range(0, 68):\n        coords[i] = (shape.part(i).x, shape.part(i).y)\n    return coords \n```", "```\nfrom shapely import Polygon\nleye = Polygon(feature_coordinates[\"left_eye\"])\nreye = Polygon(feature_coordinates[\"right_eye\"])\n```", "```\ndist = reye.distance(leye)\n```", "```\ndiff = abs(reye.area – leye.area)\n```", "```\nnose_btm = feature_coordinates[\"nose\"][6]\nbridge_top = feature_coordinates[\"nose\"][0]\nupper_lip_ctr = feature_coordinates[\"mouth\"][3]\nlower_lip_ctr = feature_coordinates[\"mouth\"][9]\nchin_ctr = feature_coordinates[\"jaw\"][8]\nr_temple = feature_coordinates[\"jaw\"][0]\nl_temple = feature_coordinates[\"jaw\"][16]\n```", "```\nfrom shapely import LineString\nface_dict = {}\n❶ face_dict[\"tri_area\"] = Polygon([r_temple, chin_ctr, l_temple]).area\n❷ face_dict[\"face_vert\"] = LineString((chin_ctr, bridge_top)).length\nface_dict[\"bow\"] = LineString((upper_lip_ctr, nose_btm)).length\n❸ face_dict[\"bow_ratio\"] = face_dict[\"face_vert\"]/face_dict[\"bow\"]\n```", "```\n❶ image_paths = get_image_files(\"faces95\", image_paths)\nface_collection = []\nfor image_file in image_paths:\n  ❷ feature_coordinates = locate_landmarks(image_file)\n  ❸ if len(feature_coordinates.keys()) < 8:\n        continue\n `--snip--`\n  ❹ face_series = pd.Series(face_dict)\n    face_collection.append(face_series)\n❺ faces_df = pd.DataFrame(face_collection)\n❻ faces_df.to_csv(\"facial_geometry.csv\")\n```", "```\nimport pandas as pd\n❶ faces_df = pd.read_csv(\"facial_geometry.csv\")\n❷ faces_df.drop([\"Unnamed: 0\", \"file\"], inplace=True, axis=1)\n❸ faces_df[\"category\"] = faces_df[\"name\"].astype(\"category\")\n❹ cat_columns = faces_df.select_dtypes([\"category\"]).columns\n❺ faces_df[cat_columns] = faces_df[cat_columns].apply(lambda x: x.cat.codes)\n❻ name_map = faces_df[[\"name\", \"category\"]].set_index([\"category\"])\n```", "```\nfrom random import choice\nreal_test = {}\nwhile len(real_test) < 3:\n  ❶ name = choice(list(faces_df[\"name\"].unique()))\n    if name not in real_test.keys():\n      ❷ group = faces_df[faces_df[\"name\"] == name]\n      ❸ real_test[name] = choice(group.index.to_list())\n❹ index_list = [r[1] for r in real_test.items()]\n❺ real_X = faces_df.iloc[index_list]\n❻ faces_df.drop(index_list, inplace=True)\n```", "```\nimport nominal\nassoc_matrix = associations(\n    faces_df,\n    nominal_columns=cat_columns,\n    theil_u=True,\n    return_results=True\n)\n```", "```\nassoc_matrix = assoc_matrix[abs(assoc_matrix[\"name\"]) > 0.95]\nkey_features = [k for k in assoc_matrix[\"name\"].index]\n```", "```\nfrom sklearn.feature_selection import mutual_info_classif\ncontributing = mutual_info_classif(\n    faces_df.drop([\"name\", \"category\"], axis=1),\n    faces_df[\"category\"],\n    discrete_features=\"auto\",\n    n_neighbors=7\n)\n```", "```\nresults = zip(\n    faces_df.drop([\"name\", \"category\"], axis=1).columns,\n    contributing\n)\nmi_scores = [f for f,v in results if v >= 1]\nreduced_features = [k for k in mi_scores if k in key_features]\n```", "```\netas = {}\nfor feat in faces_df.columns.to_list():\n    if feat not in [\"category\", \"name\"]:\n      ❶ etas[feat] = correlation_ratio(faces_df[feat], faces_df[\"category\"])\n❷ sorted_rank = sorted(etas.items(), key=lambda kv: kv[1])\nreduced_key_features = []\nfor f in sorted_rank[-21:]:\n  ❸ if f[0] in reduced_features:\n        reduced_key_features.append(f[0])\n```", "```\n['outer_eyes', 'nose_area', 'face_horz', 'center_tri_area']\n```", "```\nfrom sklearn.model_selection import LeaveOneOut\nX = faces_df[reduced_key_features]\ny = faces_df[\"category\"]\nloo = LeaveOneOut()\nsplits = list(loo.split(X))\n```", "```\nfrom sklearn.dummy import DummyClassifier\nfrom sklearn.model_selection import cross_val_score\n❶ dc = DummyClassifier(strategy=\"uniform\")\nscores = []\nhits = 0\nmisses = 0\nfor train_index, test_index in splits:\n  ❷ X_train, y_train, = X.iloc[train_index], y.iloc[train_index]\n  ❸ X_test, y_test, = X.iloc[test_index], y.iloc[test_index]  \n  ❹ cvs = cross_val_score(dc, X_train, y_train, cv=4)\n  ❺ score = sum(cvs) / 4 # Default cv value\n    scores.append(score)\n  ❻ dc.fit(X_train, y_train)\n  ❼ y_pred = dc.predict(X_test)\n  ❽ if y_test.values[0] == y_pred:\n        hits += 1\n    else:\n        misses += 1\n❾ print((sum(scores) / len(scores))*100)\n❿ print((hits / (hits+misses))*100)\n```", "```\nfrom sklearn.ensemble import RandomForestClassifier\nfrom random import randint\n❶ rfc = RandomForestClassifier(\n    n_estimators=100, min_samples_split=5, min_samples_leaf=3\n)\n❷ for i in range(50):\n    split_i = randint(0, len(splits))\n  ❸ while split_i in chose:\n        split_i = randint(0, len(splits))\n    chose.append(split_i)\n`--snip--`\n```", "```\nreal_y = real_X[\"category\"]\ntest_X = real_X[reduced_key_features]\nrfc = RandomForestClassifier(\n    n_estimators=100, min_samples_split=5, min_samples_leaf=3, random_state=42\n)\nrfc.fit(X, y)\ny_pred = rfc.predict(test_X)\nprint(list(zip(y_pred, real_y)))\n```", "```\n[(25, 25), (122, 122), (174, 174)]\n```", "```\nimport joblib\njoblib.dump(rfc, \"trained_facial_model.pkl\")\n```", "```\nimport joblib\nloaded_model = joblib.load(\"trained_facial_model.pkl\")\n```"]