- en: Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 宏与HLA编译时语言
- en: '![MACROS AND THE HLA COMPILE-TIME LANGUAGE](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![宏与HLA编译时语言](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: This chapter discusses the HLA compile-time language. This discussion includes
    what is perhaps the most important component of the HLA compile-time language,
    *macros*. Many people judge the power of an assembler by the power of its macro
    processing capabilities. If you happen to be one of these people, you'll probably
    agree that HLA is one of the more powerful assemblers on the planet after reading
    this chapter, because HLA has one of the most powerful macro processing facilities
    of any computer language processing system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了HLA编译时语言。讨论的内容包括HLA编译时语言中最重要的组成部分之一——*宏*。许多人通过汇编器的宏处理能力来判断其强大程度。如果你恰好是这些人之一，那么在阅读完本章之后，你可能会同意HLA是地球上最强大的汇编器之一，因为HLA拥有任何计算机语言处理系统中最强大的宏处理功能之一。
- en: 9.1 Introduction to the Compile-Time Language (CTL)
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 编译时语言（CTL）简介
- en: HLA is actually two languages rolled into a single program. The *runtime language*
    is the standard 80x86/HLA assembly language you've been reading about in all the
    previous chapters. This is called the runtime language because the programs you
    write execute when you run the executable file. HLA contains an interpreter for
    a second language, the HLA compile-time language (CTL), which executes programs
    while HLA is compiling a program. The source code for the CTL program is embedded
    in an HLA assembly language source file; that is, HLA source files contain instructions
    for both the HLA CTL and the runtime program. HLA executes the CTL program during
    compilation. Once HLA completes compilation, the CTL program terminates; the CTL
    application is not a part of the runtime executable that HLA emits, although the
    CTL application can *write* part of the runtime program for you, and, in fact,
    this is the major purpose of the CTL (see [Figure 9-1](ch09.html#compile-time_versus_runtime_execution
    "Figure 9-1. Compile-time versus runtime execution")).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: HLA实际上是将两种语言合并到一个程序中。*运行时语言*是你在前面所有章节中阅读过的标准80x86/HLA汇编语言。这被称为运行时语言，因为你编写的程序在你运行可执行文件时执行。HLA包含了第二种语言的解释器——HLA编译时语言（CTL），它在HLA编译程序时执行程序。CTL程序的源代码嵌入在HLA汇编语言源文件中；也就是说，HLA源文件包含了HLA
    CTL和运行时程序的指令。HLA在编译过程中执行CTL程序。HLA完成编译后，CTL程序终止；CTL应用程序不是HLA生成的运行时可执行文件的一部分，尽管CTL应用程序可以*为你写*部分运行时程序，实际上，CTL的主要目的就是这个（见[图9-1](ch09.html#compile-time_versus_runtime_execution
    "图9-1. 编译时执行与运行时执行")）。
- en: '![Compile-time versus runtime execution](tagoreillycom20100401nostarchimages578063.png.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![编译时执行与运行时执行](tagoreillycom20100401nostarchimages578063.png.jpg)'
- en: Figure 9-1. Compile-time versus runtime execution
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1. 编译时执行与运行时执行
- en: 'It may seem confusing to have two separate languages built into the same compiler.
    Perhaps you''re even questioning why anyone would need a compile-time language.
    To understand the benefits of a compile-time language, consider the following
    statement that you should be very comfortable with at this point:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个编译器中内置两个独立的语言可能会让人感到困惑。也许你甚至在质疑，为什么需要编译时语言。为了理解编译时语言的好处，请考虑以下你现在应该非常熟悉的陈述：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This statement is neither a statement in the HLA language nor a call to some
    HLA Standard Library procedure. Instead, `stdout.put` is actually a statement
    in a CTL application provided by the HLA Standard Library. The `stdout.put` "application"
    processes the parameter list and generates calls to various other Standard Library
    procedures; it chooses the procedure to call based on the type of the parameter
    it is currently processing. For example, the `stdout.put` "application" above
    will emit the following statements to the runtime executable:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这条陈述既不是HLA语言中的一条语句，也不是对某个HLA标准库过程的调用。实际上，`stdout.put`是HLA标准库提供的CTL应用程序中的一条语句。`stdout.put`
    "应用程序"处理参数列表，并生成对其他标准库过程的调用；它根据当前处理的参数类型选择要调用的过程。例如，上述`stdout.put` "应用程序"将向运行时可执行文件输出以下语句：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Clearly the `stdout.put` statement is much easier to read and write than the
    sequence of statements that `stdout.put` emits in response to its parameter list.
    This is one of the more powerful capabilities of the HLA programming language:
    the ability to modify the language to simplify common programming tasks. Printing
    different data objects in a sequential fashion is a common task; the `stdout.put`
    "application" greatly simplifies this process.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`stdout.put` 语句比 `stdout.put` 为其参数列表发出的语句序列更容易阅读和编写。这是 HLA 编程语言更强大的功能之一：能够修改语言以简化常见的编程任务。按顺序打印不同数据对象是一个常见任务；`stdout.put`
    “应用”极大简化了这一过程。
- en: The HLA Standard Library is *loaded* with many HLA CTL examples. In addition
    to Standard Library usage, the HLA CTL is quite adept at handling "one-use" applications.
    A classic example is filling in the data for a lookup table. [Chapter 8](ch08.html
    "Chapter 8. ADVANCED ARITHMETIC") noted that it is possible to construct lookup
    tables using the HLA CTL. Not only is this possible, but it is often far less
    work to use the HLA CTL to construct these tables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 标准库中*充满了*许多 HLA CTL 示例。除了标准库的使用，HLA CTL 在处理“一次性”应用程序时也非常擅长。一个经典的例子是填充查找表的数据。[第8章](ch08.html
    "第8章. 高级算术")提到，使用 HLA CTL 构建查找表是可行的。不仅如此，使用 HLA CTL 构建这些表往往比其他方法省时省力。
- en: Although the CTL itself is relatively inefficient and you would not normally
    use it to write end-user applications, it does maximize the use of your time.
    By learning how to use the HLA CTL and applying it properly, you can develop assembly
    language applications as rapidly as high-level language applications (even faster
    because HLA's CTL lets you create very high-level-language constructs).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CTL 本身相对低效，通常不用于编写最终用户应用程序，但它最大化了你时间的使用。通过学习如何使用 HLA CTL 并正确应用它，你可以像开发高级语言应用程序一样快速开发汇编语言应用程序（甚至更快，因为
    HLA 的 CTL 允许你创建非常高级语言的构造）。
- en: '9.2 The #print and #error Statements'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 `#print` 和 `#error` 语句
- en: You may recall that [Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF ASSEMBLY
    LANGUAGE") began with the typical first program most people write when learning
    a new language, the "Hello, world!" program. It is only fitting for this chapter
    to present that same program when discussing the second language of this book.
    [Example 9-1](ch09s02.html#the_ctl_quotation_mark_hello_comma_world "Example 9-1. The
    CTL "Hello, world!" program") provides the basic "Hello, world!" program written
    in the HLA compile-time language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，[第1章](ch01.html "第1章. HELLO，世界汇编语言")以大多数人在学习新语言时编写的典型第一个程序——“Hello, world!”程序开始。当讨论本书的第二种语言时，呈现这个程序是非常合适的。[示例
    9-1](ch09s02.html#the_ctl_quotation_mark_hello_comma_world "示例 9-1. CTL “Hello,
    world!”程序")提供了用 HLA 编译时语言编写的基本“Hello, world!”程序。
- en: Example 9-1. The CTL "Hello, world!" program
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-1. CTL “Hello, world!”程序
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only CTL statement in this program is the `#print` statement. The remaining
    lines are needed just to keep the compiler happy (though we could have reduced
    the overhead to two lines by using a `unit` rather than a `program` declaration).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序中的唯一 CTL 语句是 `#print` 语句。其余的行仅仅是为了让编译器正常工作（尽管我们可以通过使用 `unit` 声明而非 `program`
    声明，将开销减少到两行）。
- en: 'The `#print` statement displays the textual representation of its argument
    list during the compilation of an HLA program. Therefore, if you compile the program
    above with the command `hla ctlHW.hla`, the HLA compiler will immediately print
    the text:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`#print` 语句在编译 HLA 程序时会显示其参数列表的文本表示。因此，如果你使用命令 `hla ctlHW.hla` 编译上面的程序，HLA
    编译器将立即打印出以下文本：'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that there is a big difference between the following two statements in
    an HLA source file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 HLA 源文件中，以下两个语句之间有很大的区别：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first statement prints `Hello World` (and a new line) during the compilation
    process. This first statement does not have any effect on the executable program.
    The second line doesn't affect the compilation process (other than the emission
    of code to the executable file). However, when you run the executable file, the
    second statement prints the string `Hello World` followed by a newline sequence.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句在编译过程中打印出 `Hello World`（并添加一个换行符）。这个第一个语句对可执行程序没有任何影响。第二行则不影响编译过程（除了向可执行文件发出代码）。然而，当你运行可执行文件时，第二个语句会打印出字符串
    `Hello World`，后跟一个换行符。
- en: 'The HLA/CTL `#print` statement uses the following basic syntax:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: HLA/CTL `#print` 语句使用以下基本语法：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that a semicolon does not terminate this statement. Semicolons terminate
    runtime statements; they generally do not terminate compile-time statements (there
    is one big exception, as you will see a little later).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，分号并不会终止此语句。分号终止的是运行时语句；通常不会终止编译时语句（有一个例外，稍后你会看到）。
- en: 'The `#print` statement must have at least one operand; if multiple operands
    appear in the parameter list, you must separate each operand with a comma ( just
    like `stdout.put`). If a particular operand is not a string constant, HLA will
    translate that constant to its corresponding string representation and print that
    string. Here''s an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`#print`语句必须至少有一个操作数；如果参数列表中有多个操作数，你必须用逗号分隔每个操作数（就像`stdout.put`一样）。如果某个操作数不是字符串常量，HLA会将该常量转换为相应的字符串表示并打印该字符串。下面是一个示例：'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You may specify named symbolic constants and constant expressions. However,
    all `#print` operands must be constants (either literal constants or constants
    you define in the `const` or `val` sections), and those constants must be defined
    before you use them in the `#print` statement. For example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定命名的符号常量和常量表达式。然而，所有的`#print`操作数必须是常量（无论是字面常量还是你在`const`或`val`部分定义的常量），这些常量必须在你使用它们的`#print`语句之前定义。例如：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The HLA `#print` statement is particularly invaluable for debugging CTL programs.
    This statement is also useful for displaying the progress of the compilation and
    displaying assumptions and default actions that take place during compilation.
    Other than displaying the text associated with the `#print` parameter list, the
    `#print` statement has no effect on the compilation of the program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: HLA的`#print`语句对于调试CTL程序特别有价值。这个语句还用于显示编译进度，展示编译过程中发生的假设和默认操作。除了显示与`#print`参数列表相关的文本外，`#print`语句对程序的编译没有其他影响。
- en: 'The `#error` statement allows a single-string constant operand. Like `#print`,
    this statement will display the string to the console during compilation. However,
    the `#error` statement treats the string as an error message and displays the
    string as part of an HLA error diagnostic. Further, the `#error` statement increments
    the error count, and this will cause HLA to stop the compilation (without assembling
    or linking) after processing the current source file. You would normally use the
    `#error` statement to display an error message during compilation if your CTL
    code discovers something that prevents it from creating valid code. For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`#error`语句允许一个单一的字符串常量操作数。和`#print`一样，这个语句会在编译时将字符串显示到控制台。然而，`#error`语句将该字符串视为错误信息，并作为HLA错误诊断的一部分显示该字符串。此外，`#error`语句会增加错误计数，这将导致HLA在处理完当前源文件后停止编译（不会汇编或链接）。通常，当你的CTL代码发现某些问题，无法生成有效代码时，你会使用`#error`语句在编译期间显示错误信息。例如：'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Like the `#print` statement, the `#error` statement does not end with a semicolon.
    Although `#error` allows only a single-string operand, it's very easy to print
    other values by using the compile-time string concatenation operator and several
    of the HLA built-in compile-time functions. You'll learn about these a little
    later in this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 和`#print`语句一样，`#error`语句也不以分号结尾。虽然`#error`只允许一个单一的字符串操作数，但通过使用编译时字符串连接操作符和几个HLA内建的编译时函数，你可以很容易地打印其他值。你将在本章稍后部分了解这些内容。
- en: 9.3 Compile-Time Constants and Variables
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 编译时常量和变量
- en: Just as the runtime language does, the compile-time language supports constants
    and variables. You declare compile-time constants in the `const` section, just
    as you would with the runtime language. You declare compile-time variables in
    the `val` section. Objects you declare in the `val` section are constants to the
    runtime language, but remember that you can change the value of an object you
    declare in the `val` section throughout the source file. Hence the term "compile-time
    variable." See [Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES, AND DATA
    TYPES") for more details.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像运行时语言一样，编译时语言也支持常量和变量。你可以像在运行时语言中一样在`const`部分声明编译时常量。在`val`部分声明编译时变量。你在`val`部分声明的对象对运行时语言来说是常量，但记住，你可以在整个源文件中改变你在`val`部分声明的对象的值。因此，称之为“编译时变量”。有关详细信息，请参见[第4章](ch04.html
    "第4章 常量、变量和数据类型")。
- en: The CTL assignment statement (`?`) computes the value of the constant expression
    to the right of the assignment operator (`:=`) and stores the result into the
    `val` object name appearing immediately to the left of the assignment operator.^([[118](#ftn.CHP-9-FN-1)])
    This example code may appear anywhere in your HLA source file, not just in the
    `val` section of the program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: CTL 赋值语句（`?`）计算赋值运算符（`:=`）右侧常量表达式的值，并将结果存储到赋值运算符左侧紧接的 `val` 对象名中。^([[118](#ftn.CHP-9-FN-1)])
    这个示例代码可以出现在 HLA 源文件的任何位置，而不仅仅是程序的 `val` 部分。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '* * *'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[118](#CHP-9-FN-1)]) If the identifier to the left of the assignment operator
    is undefined, HLA will automatically declare this object at the current scope
    level.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[118](#CHP-9-FN-1)]) 如果赋值运算符左侧的标识符未定义，HLA 将自动在当前作用域级别声明该对象。
- en: 9.4 Compile-Time Expressions and Operators
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.4 编译时表达式和运算符
- en: The HLA CTL supports constant expressions in the CTL assignment statement. Unlike
    the runtime language (where you have to translate algebraic notation into a sequence
    of machine instructions), the HLA CTL allows a full set of arithmetic operations
    using familiar expression syntax. This gives the HLA CTL considerable power, especially
    when combined with the built-in compile-time functions the next section discusses.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: HLA CTL 支持在 CTL 赋值语句中使用常量表达式。与运行时语言不同（在运行时，你需要将代数符号转换为一系列机器指令），HLA CTL 允许使用熟悉的表达式语法进行完整的算术运算。这使得
    HLA CTL 在编译时表达式中具有相当大的能力，尤其是当与下一节讨论的内置编译时函数结合使用时。
- en: '[Table 9-1](ch09s04.html#compile-time_operators "Table 9-1. Compile-Time Operators")
    and [Table 9-2](ch09s04.html#operator_precedence_and_associativity "Table 9-2. Operator
    Precedence and Associativity") list operators that the HLA CTL supports in compile-time
    expressions.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](ch09s04.html#compile-time_operators "表 9-1. 编译时运算符") 和 [表 9-2](ch09s04.html#operator_precedence_and_associativity
    "表 9-2. 运算符优先级和结合性") 列出了 HLA CTL 在编译时表达式中支持的运算符。'
- en: Table 9-1. Compile-Time Operators
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1. 编译时运算符
- en: '| Operator(s) | Operand Types^([[a](#ftn.CHP-9-TFN-1)]) | Description |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 操作数类型^([[a](#ftn.CHP-9-TFN-1)]) | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `-` (unary) | numeric | Negates the specific numeric value (int, uns, real).
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `-`（一元运算符） | numeric | 对特定的数值（int, uns, real）进行取负运算。 |'
- en: '|   | cset | Returns the complement of the specified character set. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|   | cset | 返回指定字符集的补集。 |'
- en: '| `!` (unary) | integer | Inverts all the bits in the operand (bitwise `not`).
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `!`（一元运算符） | integer | 反转操作数中的所有位（按位 `not`）。 |'
- en: '|   | boolean | Boolean `not` of the operand. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|   | boolean | 操作数的布尔 `not`。 |'
- en: '| `*` | numericL * numericR | Multiplies the two operands. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `*` | numericL * numericR | 计算两个操作数的乘积。 |'
- en: '|   | csetL * csetR | Computes the intersection of the two sets. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|   | csetL * csetR | 计算两个集合的交集。 |'
- en: '| `div` | integerL divintegerR | Computes the integer quotient of the two integer
    (int/uns/dword) operands. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `div` | integerL divintegerR | 计算两个整数（int/uns/dword）操作数的整数商。 |'
- en: '| `mod` | integerL modintegerR | Computes the remainder of the division of
    the two integer (int/uns/dword) operands. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `mod` | integerL modintegerR | 计算两个整数（int/uns/dword）操作数的除法余数。 |'
- en: '| `/` | numericL / numericR | Computes the real quotient of the two numeric
    operands. Returns a real result even if both operands are integers. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `/` | numericL / numericR | 计算两个数值操作数的实数商。即使两个操作数都是整数，也返回实数结果。 |'
- en: '| `<<` | integerL << integerR | Shifts integerL operand to the left the number
    of bits specified by the integerR operand. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | integerL << integerR | 将 integerL 操作数向左移动由 integerR 操作数指定的位数。 |'
- en: '| `>>` | integerL >> integerR | Shifts integerL operand to the right the number
    of bits specified by the integerR operand. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | integerL >> integerR | 将 integerL 操作数向右移动由 integerR 操作数指定的位数。 |'
- en: '| `+` | numericL + numericR | Adds the two numeric operands. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `+` | numericL + numericR | 将两个数值操作数相加。 |'
- en: '|   | csetL + csetR | Computes the union of the two sets. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|   | csetL + csetR | 计算两个集合的并集。 |'
- en: '|   | strL + strR | Concatenates the two strings. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|   | strL + strR | 连接两个字符串。 |'
- en: '| `-` | numericL numericR | Computes the difference between numericL and numericR.
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `-` | numericL numericR | 计算 numericL 和 numericR 之间的差。 |'
- en: '|   | csetL - csetR | Computes the set difference of csetL - csetR. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|   | csetL - csetR | 计算 csetL - csetR 的集合差。 |'
- en: '| `=` or `==` | numericL = numericR | Returns true if the two operands have
    the same value. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `=` 或 `==` | numericL = numericR | 如果两个操作数具有相同的值，则返回真。 |'
- en: '|   | csetL = csetR | Returns true if the two sets are equal. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|   | csetL = csetR | 如果两个集合相等，则返回真。 |'
- en: '|   | strL = strR | Returns true if the two strings/chars are equal. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|   | strL = strR | 如果两个字符串/字符相等，则返回真。 |'
- en: '|   | typeL = typeR | Returns true if the two values are equal. They must be
    the same type. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|   | typeL = typeR | 如果两个值相等，则返回 true。它们必须是相同类型。 |'
- en: '| `<>` or `!=` | typeL <> typeR (sameas !=) | Returns false if the two (compatible)
    operands are not equal to one another (numeric, cset, or string). |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `<>` 或 `!=` | typeL <> typeR（与 != 相同） | 如果两个（兼容的）操作数不相等（数值、字符集或字符串），则返回 false。
    |'
- en: '| `<` | numericL < numericR | Returns true if numericL is less than numericR.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `<` | numericL < numericR | 如果 numericL 小于 numericR，则返回 true。 |'
- en: '|   | csetL < csetR | Returns true if csetL is a proper subset of csetR. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|   | csetL < csetR | 如果 csetL 是 csetR 的适当子集，则返回 true。 |'
- en: '|   | strL < strR | Returns true if strL is less than strR. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|   | strL < strR | 如果 strL 小于 strR，则返回 true。 |'
- en: '|   | booleanL < booleanR | Returns true if the left operand is less than the
    right operand (note: false < true). |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|   | booleanL < booleanR | 如果左操作数小于右操作数，则返回 true（注意：false < true）。 |'
- en: '|   | enumL < enumR | Returns true if enumL appears in the same enumlist as
    enumR and enumL appears first. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|   | enumL < enumR | 如果 enumL 出现在与 enumR 相同的枚举列表中，并且 enumL 出现得更早，则返回 true。
    |'
- en: '| `<=` | Same as < | Returns true if the left operand is less than or equal
    to the right operand. For character sets, this means that the left operand is
    a subset of the right operand. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 与 < 相同 | 如果左操作数小于或等于右操作数，则返回 true。对于字符集，意味着左操作数是右操作数的子集。 |'
- en: '| `>` | Same as < | Returns true if the left operand is greater than the right
    operand. For character sets, this means that the left operand is a proper superset
    of the right operand. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 与 < 相同 | 如果左操作数大于右操作数，则返回 true。对于字符集，意味着左操作数是右操作数的一个适当超集。 |'
- en: '| `>=` | Same as <= | Returns true if the left operand is greater than or equal
    to the right operand. For character sets, this means that the left operand is
    a superset of the right operand. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 与 <= 相同 | 如果左操作数大于或等于右操作数，则返回 true。对于字符集，意味着左操作数是右操作数的超集。 |'
- en: '| `&` | integerL & integerR | Computes the bitwise `and` of the two operands.
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `&` | integerL & integerR | 计算两个操作数的按位 `and`。 |'
- en: '|   | booleanL & booleanR | Computes the logical `and` of the two operands.
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|   | booleanL & booleanR | 计算两个操作数的逻辑 `and`。 |'
- en: '| `&#124;` | integerL &#124; integerR | Computes the bitwise `or` of the two
    operands. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | integerL &#124; integerR | 计算两个操作数的按位 `or`。 |'
- en: '|   | booleanL &#124; booleanR | Computes the logical `or` of the two operands.
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|   | booleanL &#124; booleanR | 计算两个操作数的逻辑 `or`。 |'
- en: '| `^` | integerL ^ integerR | Computes the bitwise `xor` of the two operands.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `^` | integerL ^ integerR | 计算两个操作数的按位 `xor`。 |'
- en: '|   | booleanL ^ booleanR | Computes the logical `xor` of the two operands.
    Note that this is equivalent to `booleanL <> booleanR`. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|   | booleanL ^ booleanR | 计算两个操作数的逻辑 `xor`。注意，这等同于 `booleanL <> booleanR`。
    |'
- en: '| `in` | charL in csetR | Returns true if charL is a member of csetR. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `in` | charL 在 csetR 中 | 如果 charL 是 csetR 的成员，则返回 true。 |'
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: ^([[a](#CHP-9-TFN-1)]) Type numeric is {int*XX*, uns*XX*, byte, word, dword,
    and real*XX*} values. Type cset is a character set operand. Type integer is {int*XX*,
    uns*XX*, byte, word, dword}. Type str is any string or character value. Type indicates
    an arbitrary HLA type. Other types specify an explicit HLA data type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[a](#CHP-9-TFN-1)]) 类型 numeric 是 {int*XX*, uns*XX*, byte, word, dword 和 real*XX*}
    值。类型 cset 是字符集操作数。类型 integer 是 {int*XX*, uns*XX*, byte, word, dword}。类型 str 是任何字符串或字符值。类型表示任意
    HLA 类型。其他类型指定一个显式的 HLA 数据类型。 |
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 9-2. Operator Precedence and Associativity
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-2. 运算符优先级和结合性 |
- en: '| Associativity | Precedence (Highest to Lowest) | Operator |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 结合性 | 优先级（从高到低） | 运算符 |'
- en: '| --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Right to left | 6 | `!` (unary) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 从右到左 | 6 | `!`（一元操作符） |'
- en: '|   |   | `-` (unary) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `-`（一元操作符） |'
- en: '| Left to right | 5 | `*` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 从左到右 | 5 | `*` |'
- en: '|   |   | `div` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `div` |'
- en: '|   |   | `mod` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `mod` |'
- en: '|   |   | `/` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `/` |'
- en: '|   |   | `>>` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `>>` |'
- en: '|   |   | `<<` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `<<` |'
- en: '| Left to right | 4 | `+` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 从左到右 | 4 | `+` |'
- en: '|   |   | `-` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `-` |'
- en: '| Left to right | 3 | `=` or `==` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 从左到右 | 3 | `=` 或 `==` |'
- en: '|   |   | `<>` or `!=` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `<>` 或 `!=` |'
- en: '|   |   | `<` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `<` |'
- en: '|   |   | `<=` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `<=` |'
- en: '|   |   | `>` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `>` |'
- en: '|   |   | `>=` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `>=` |'
- en: '| Left to right | 2 | `&` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 从左到右 | 2 | `&` |'
- en: '|   |   | `&#124;` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `&#124;` |'
- en: '|   |   | `^` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `^` |'
- en: '| Nonassociative | 1 | `in` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 非结合性 | 1 | `in` |'
- en: Of course, you can always override the default precedence and associativity
    of an operator by using parentheses in an expression.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以通过在表达式中使用括号来覆盖运算符的默认优先级和结合性。 |
- en: 9.5 Compile-Time Functions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.5 编译时函数 |
- en: HLA provides a wide range of compile-time functions you can use. These functions
    compute values during compilation the same way a high-level-language function
    computes values at runtime. The HLA compile-time language includes a wide variety
    of numeric, string, and symbol table functions that help you write sophisticated
    compile-time programs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: HLA提供了丰富的编译时函数供你使用。这些函数在编译期间计算值，方式与高级语言函数在运行时计算值类似。HLA的编译时语言包括各种数值、字符串和符号表函数，帮助你编写复杂的编译时程序。
- en: Most of the names of the built-in compile-time functions begin with the special
    symbol `@` and have names like `@sin` or `@length`. The use of these special identifiers
    prevents conflicts with common names you might want to use in your own programs
    (like `length`). The remaining compile-time functions (those that do not begin
    with `@`) are typically data conversion functions that use type names like `int8`
    and `real64`. You can even create your own compile-time functions using macros
    (which is discussed in [9.8 Macros (Compile-Time Procedures)](ch09s08.html "9.8
    Macros (Compile-Time Procedures)")).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内建的编译时函数名称以特殊符号`@`开头，名称类似于`@sin`或`@length`。使用这些特殊标识符可以避免与程序中可能使用的常见名称（例如`length`）发生冲突。剩余的编译时函数（那些不以`@`开头的）通常是数据转换函数，使用类型名称如`int8`和`real64`。你甚至可以通过宏来创建自己的编译时函数（宏的使用在[9.8
    宏（编译时过程）](ch09s08.html "9.8 Macros (Compile-Time Procedures)")中讨论）。
- en: HLA organizes the compile-time functions into various classes depending on the
    type of operation. For example, there are functions that convert constants from
    one form to another (such as string-to-integer conversion), there are many useful
    string functions, and HLA provides a full set of compile-time numeric functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: HLA根据操作类型将编译时函数组织成不同的类别。例如，有一些函数将常量从一种形式转换为另一种形式（例如字符串到整数的转换），还有许多有用的字符串函数，HLA提供了一整套编译时数值函数。
- en: The complete list of HLA compile-time functions is too lengthy to present here.
    Instead, a complete description of each of the compile-time objects and functions
    appears in the HLA reference manual (found at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/)); this section highlights
    a few of the functions in order to demonstrate their use. Later sections in this
    chapter, as well as future chapters, make extensive use of the various compile-time
    functions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: HLA编译时函数的完整列表过于庞大，无法在此呈现。相反，关于每个编译时对象和函数的完整描述可以在HLA参考手册中找到（可在[http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)或[http://www.artofasm.com/](http://www.artofasm.com/)查阅）；本节将突出介绍一些函数，以展示它们的使用方法。本章后续章节以及未来章节将广泛使用各种编译时函数。
- en: Perhaps the most important concept to understand about the compile-time functions
    is that they are equivalent to constants in your assembly language code (i.e.,
    the runtime program). For example, the compile-time function invocation `@sin(3.1415265358979328)`
    is roughly equivalent to specifying 0.0 at that point in your program.^([[119](#ftn.CHP-9-FN-2)])
    A function invocation like `@sin( x )` is legal only if `x` is a constant with
    a previous declaration at the point of the function call in the source file. In
    particular, `x` cannot be a runtime variable or other object whose value exists
    at runtime rather than compile time. Because HLA replaces compile-time function
    calls with their constant result, you may ask why you should even bother with
    compile-time functions. After all, it's probably more convenient to type *0.0*
    than it is to type *@sin(3.1415265358979328)* in your program. However, compile-time
    functions are handy for generating lookup tables and other mathematical results
    that may change whenever you change a `const` value in your program. [9.9 Writing
    Compile-Time "Programs"](ch09s09.html "9.9 Writing Compile-Time "Programs"") will
    explore this idea further.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 也许理解编译时函数最重要的概念是，它们在你的汇编语言代码（即运行时程序）中等同于常量。例如，编译时函数调用`@sin(3.1415265358979328)`大致相当于在程序中指定0.0。^([[119](#ftn.CHP-9-FN-2)])像`@sin(x)`这样的函数调用，只有在`x`是一个在函数调用点之前已声明的常量时才是合法的。特别是，`x`不能是运行时变量或其他在运行时而非编译时存在的对象。因为HLA将编译时函数调用替换为其常量结果，你可能会问为什么还要使用编译时函数。毕竟，在程序中输入*0.0*可能比输入`@sin(3.1415265358979328)`更方便。然而，编译时函数对于生成查找表和其他可能在你改变程序中的`const`值时发生变化的数学结果非常有用。[9.9
    编写编译时“程序”](ch09s09.html "9.9 Writing Compile-Time "Programs"")将进一步探讨这个想法。
- en: 9.5.1 Type-Conversion Compile-Time Functions
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.1 类型转换编译时函数
- en: 'Probably the most commonly used compile-time functions are the type-conversion
    functions. These functions take a single parameter of one type and convert that
    information to some specified type. These functions use several of the HLA built-in
    data type names as the function names. Functions in this category are the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的编译时函数可能是类型转换函数。这些函数接受一个类型的单一参数，并将该信息转换为指定的类型。这些函数使用多个HLA内建数据类型名称作为函数名。该类别中的函数包括：
- en: '`boolean`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`'
- en: '`int8`, `int16`, `int32`, `int64`, and `int128`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int8`、`int16`、`int32`、`int64`和`int128`'
- en: '`uns8`, `uns16`, `uns32`, `uns64`, and `uns128`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uns8`、`uns16`、`uns32`、`uns64`和`uns128`'
- en: '`byte`, `word`, `dword`, `qword`, and `lword` (these are effectively equivalent
    to `uns8`, `uns16`, `uns32`, `uns64`, and `uns128`, respectively)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`、`word`、`dword`、`qword`和`lword`（它们实际上等同于`uns8`、`uns16`、`uns32`、`uns64`和`uns128`）'
- en: '`real32`, `real64`, and `real80`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real32`、`real64`和`real80`'
- en: '`char`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`'
- en: '`string`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: '`cset`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cset`'
- en: '`text`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`'
- en: 'These functions accept a single constant expression parameter and, if at all
    reasonable, convert that expression''s value to the type specified by the type
    name. For example, the following function call returns the value −128 because
    it converts the string constant to the corresponding integer value:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数接受一个常量表达式参数，并且如果合理的话，将该表达式的值转换为指定类型的值。例如，以下函数调用返回值−128，因为它将字符串常量转换为对应的整数值：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Certain conversions don't make sense or have restrictions associated with them.
    For example, the `boolean` function will accept a string parameter, but that string
    must be "true" or "false" or the function will generate a compile-time error.
    Likewise, the numeric conversion functions (e.g., `int8`) allow a string operand,
    but the string operand must represent a legal numeric value. Some conversions
    (for example, `int8` with a character set parameter) simply don't make sense and
    are always illegal.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 某些转换是没有意义的，或者有相关的限制。例如，`boolean`函数会接受一个字符串参数，但该字符串必须是“true”或“false”，否则函数会生成编译时错误。同样，数字转换函数（例如，`int8`）允许一个字符串操作数，但该字符串操作数必须表示一个合法的数字值。某些转换（例如，带有字符集参数的`int8`）根本没有意义，并且始终是非法的。
- en: 'One of the most useful functions in this category is the `string` function.
    This function accepts nearly all the constant expression types, and it generates
    a string that represents the parameter''s data. For example, the invocation `string(
    128 )` produces the string `128` as the return result. This function is handy
    when you have a value that you wish to use where HLA requires a string. For example,
    the `#error` compile-time statement allows only a single-string operand. You can
    use the string function and the string concatenation operator (`+`) to easily
    get around this limitation. For example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别中最有用的函数之一是`string`函数。该函数接受几乎所有常量表达式类型，并生成一个表示参数数据的字符串。例如，调用`string(128)`会生成字符串`128`作为返回结果。当你有一个值需要在HLA中作为字符串使用时，这个函数非常方便。例如，`#error`编译时语句只允许一个字符串操作数。你可以使用`string`函数和字符串连接运算符（`+`）轻松绕过这个限制。例如：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that these type functions actually perform a conversion. This means that
    the bit pattern these functions return may be considerably different than the
    bit pattern you pass as an argument. For example, consider the following invocation
    of the `real32` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些类型函数实际上执行的是转换。这意味着这些函数返回的位模式可能与传递的参数的位模式有很大不同。例如，考虑以下对`real32`函数的调用：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now it turns out that $3F80_0000 is the hexadecimal equivalent of the `real32`
    value 1.0\. However, the preceding function invocation does not return 1.0; instead
    it attempts to convert the integer value $3F80_0000 (1,065,353,216) to a `real32`
    value but fails because the value is too large to exactly represent using a `real32`
    object. Contrast this with the following constant function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事实证明，$3F80_0000是`real32`值1.0的十六进制等价物。然而，前面的函数调用并不会返回1.0；相反，它试图将整数值$3F80_0000（1,065,353,216）转换为`real32`值，但失败了，因为该值太大，无法使用`real32`对象精确表示。与此相对比，以下常量函数：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This CTL function invocation returns the character `A` (because 65 is the ASCII
    code for `A`). Notice how the `char` function simply uses the bit pattern of the
    integer argument you pass it as an ASCII code, whereas the `real32` function attempts
    to translate the integer argument to a floating-point value. Although the semantics
    are quite different between these two functions, the bottom line is that they
    tend to do the intuitive operation, even at the expense of consistency.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 CTL 函数调用返回字符 `A`（因为 65 是 `A` 的 ASCII 码）。请注意，`char` 函数只是简单地使用你传递给它的整数参数的位模式作为
    ASCII 码，而 `real32` 函数试图将整数参数转换为浮点值。尽管这两个函数的语义差别很大，但归根结底，它们倾向于执行直观的操作，即使这牺牲了一定的统一性。
- en: 'Sometimes, however, you might not want these functions to do the "intuitive"
    thing. For example, you might want the `real32` function to simply treat the bit
    pattern you pass it as a `real32` value. To handle this situation, HLA provides
    a second set of type functions, which are simply the type names with an `@` prefix
    that treat the argument as a bit pattern of the final type. So if you really want
    to produce 1.0 from $3F80_0000, then you could use the following function invocation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能不希望这些函数做“直观”的操作。例如，你可能希望 `real32` 函数仅仅将你传入的位模式作为 `real32` 值来处理。为了处理这种情况，HLA
    提供了第二组类型函数，它们只是类型名称前加上 `@` 前缀，并将参数视为最终类型的位模式。因此，如果你真的希望从 `$3F80_0000` 生成 1.0，你可以使用以下函数调用：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Generally, type coercion of this form is somewhat advanced in the compile-time
    language, so you'll probably not use it very often. However, when it is needed,
    it's nice to have around.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，这种类型强制转换在编译时语言中是比较高级的，所以你可能不会经常使用它。然而，当它需要时，能够使用它还是很方便的。
- en: 9.5.2 Numeric Compile-Time Functions
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.2 数值编译时函数
- en: 'The functions in this category perform standard mathematical operations at
    compile time. These functions are handy for generating lookup tables and "parameterizing"
    your source code by recalculating functions on constants defined at the beginning
    of your program. Functions in this category include the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本类函数在编译时执行标准的数学操作。这些函数非常适合生成查找表，并通过在程序开始时重新计算已定义常量的函数来“参数化”源代码。本类函数包括以下内容：
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@abs(` *`n`* `)`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@abs(` *`n`* `)`'
- en: '| Absolute value of numeric argument |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 数值参数的绝对值 |'
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@ceil(` *`r`* `), @floor(` *`r`* `)`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ceil(` *`r`* `), @floor(` *`r`* `)`'
- en: '| Extract integer component of floating-point value |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 提取浮点值的整数部分 |'
- en: '|'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@sin(` *`r`* `)`, `@cos(` *`r`* `)`, `@tan(` *`r`* `)`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@sin(` *`r`* `)`, `@cos(` *`r`* `)`, `@tan(` *`r`* `)`'
- en: '| Standard trig functions |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 标准三角函数 |'
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@exp(` *`r`* `)`, `@log(` *`r`* `)`, `@log10(` *`r`* `)`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@exp(` *`r`* `)`, `@log(` *`r`* `)`, `@log10(` *`r`* `)`'
- en: '| Standard log/exponent functions |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 标准对数/指数函数 |'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@min(` *`list`* `)`, `@max(` *`list`* `)`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@min(` *`list`* `)`, `@max(` *`list`* `)`'
- en: '| Return min/max value from a list of values |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 从值列表中返回最小/最大值 |'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@random`, `@randomize`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@random`, `@randomize`'
- en: '| Return a pseudo-random `int32` value |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 返回伪随机的 `int32` 值 |'
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@sqrt(` *`n`* `)`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@sqrt(` *`n`* `)`'
- en: '| Computes the square root of its numeric argument (real result) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 计算数值参数的平方根（实数结果） |'
- en: See the HLA reference manual at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/) for more details on these
    functions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 详情请参见 HLA 参考手册 [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) 或 [http://www.artofasm.com/](http://www.artofasm.com/)。
- en: 9.5.3 Character-Classification Compile-Time Functions
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.3 字符分类编译时函数
- en: 'The functions in this group all return a boolean result. They test a character
    (or all the characters in a string) to see if it belongs to a certain class of
    characters. The functions in this category include the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本组函数均返回布尔结果。它们测试一个字符（或字符串中的所有字符），查看其是否属于某一类字符。该类别的函数包括以下内容：
- en: '`@isAlpha(` *`c`* `)`, `@isAlphanum(` *`c`* `)`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@isAlpha(` *`c`* `)`, `@isAlphanum(` *`c`* `)`'
- en: '`@isDigit(` *`c`* `)`, `@isxDigit(` *`c`* `)`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@isDigit(` *`c`* `)`, `@isxDigit(` *`c`* `)`'
- en: '`@isLower(` *`c`* `)`, `@isUpper(` *`c`* `)`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@isLower(` *`c`* `)`, `@isUpper(` *`c`* `)`'
- en: '`@isSpace(` *`c`* `)`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@isSpace(` *`c`* `)`'
- en: In addition to these character-classification functions, the HLA language provides
    a set of pattern-matching functions that you can also use to classify character
    and string data. See the HLA reference manual at for the discussion of these routines.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些字符分类函数，HLA 语言还提供了一组模式匹配函数，你也可以用来分类字符和字符串数据。有关这些例程的讨论，请参见 HLA 参考手册。
- en: 9.5.4 Compile-Time String Functions
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.4 编译时字符串函数
- en: The functions in this category operate on string parameters. Most return a string
    result, although a few (for example, `@length` and `@index`) return integer results.
    These functions do not directly affect the values of their parameters; instead,
    they return an appropriate result that you can assign back to the parameter if
    you wish to do so.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本类别中的函数操作字符串参数。大多数返回字符串结果，尽管有一些（例如 `@length` 和 `@index`）返回整数结果。这些函数不会直接影响它们参数的值；相反，它们返回一个合适的结果，如果你愿意，可以将其赋值回参数。
- en: '`@delete`, `@insert`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@delete`, `@insert`'
- en: '`@index`, `@rindex`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@index`, `@rindex`'
- en: '`@length`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@length`'
- en: '`@lowercase`, `@uppercase`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@lowercase`, `@uppercase`'
- en: '`@strbrk`, `@strspan`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@strbrk`, `@strspan`'
- en: '`@strset`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@strset`'
- en: '`@substr`, `@tokenize`, `@trim`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@substr`, `@tokenize`, `@trim`'
- en: For specific details concerning these functions, their parameters, and their
    types, see the HLA reference manual. Note that these are the compile-time equivalents
    of many of the string functions found in the HLA Standard Library.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些函数、它们的参数以及类型的具体细节，请参见 HLA 参考手册。请注意，这些是 HLA 标准库中许多字符串函数的编译时等效函数。
- en: 'The `@length` function deserves a special discussion because it is probably
    the most popular function in this category. It returns an `uns32` constant specifying
    the number of characters found in its string parameter. The syntax is the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`@length` 函数值得特别讨论，因为它可能是这个类别中最常用的函数。它返回一个 `uns32` 常量，指定其字符串参数中包含的字符数。语法如下：'
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: where *`string_expression`* represents any compile-time string expression. As
    noted, this function returns the length, in characters, of the specified expression.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *`string_expression`* 代表任何编译时字符串表达式。如前所述，这个函数返回指定表达式的字符长度。
- en: 9.5.5 Compile-Time Symbol Information
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.5 编译时符号信息
- en: During compilation HLA maintains an internal database known as the *symbol table*.
    The symbol table contains lots of useful information concerning all the identifiers
    you've defined up to a given point in the program. In order to generate machine
    code output, HLA needs to query this database to determine how to treat certain
    symbols. In your compile-time programs, it is often necessary to query the symbol
    table to determine how to handle an identifier or expression in your code. The
    HLA compile-time symbol-information functions handle this task.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，HLA 维护一个内部数据库，称为 *符号表*。符号表包含了关于你在程序中的某个点之前定义的所有标识符的许多有用信息。为了生成机器代码输出，HLA
    需要查询这个数据库以确定如何处理某些符号。在你的编译时程序中，通常需要查询符号表来决定如何处理代码中的标识符或表达式。HLA 编译时符号信息函数负责执行这一任务。
- en: 'Many of the compile-time symbol-information functions are well beyond the scope
    of this text. This chapter will present a few of the functions. For a complete
    list of the compile-time symbol-table functions, see the HLA reference manual.
    The functions we will consider in this chapter include the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编译时符号信息函数超出了本书的范围。本章将介绍其中的一些函数。有关编译时符号表函数的完整列表，请参见 HLA 参考手册。本章将讨论的函数包括以下内容：
- en: '`@size`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@size`'
- en: '`@defined`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@defined`'
- en: '`@typeName`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@typeName`'
- en: '`@elements`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@elements`'
- en: '`@elementSize`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@elementSize`'
- en: Without question, the `@size` function is probably the most important function
    in this group. Indeed, previous chapters have made use of this function already.
    The `@size` function requires a single HLA identifier or constant expression as
    a parameter. It returns the size, in bytes, of the data type of that object (or
    expression). If you supply an identifier, it can be a constant, type, or variable
    identifier. As you've seen in previous chapters, this function is invaluable for
    allocating storage via `mem.alloc` and allocating storage for arrays.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，`@size` 函数可能是这一组中最重要的函数。事实上，前面的章节已经使用过这个函数。`@size` 函数需要一个单一的 HLA 标识符或常量表达式作为参数。它返回该对象（或表达式）数据类型的字节大小。如果你提供一个标识符，它可以是常量、类型或变量标识符。正如你在前面的章节中看到的，这个函数在通过
    `mem.alloc` 分配存储和为数组分配存储时非常有用。
- en: 'Another very useful function in this group is the `@defined` function. This
    function accepts a single HLA identifier as a parameter. For example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组中另一个非常有用的函数是 `@defined` 函数。这个函数接受一个单一的 HLA 标识符作为参数。例如：
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function returns true if the identifier is defined at that point in the
    program; it returns false otherwise.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在程序的某个点上返回 `true`，如果标识符在该点已定义；否则返回 `false`。
- en: The `@typeName` function returns a string specifying the type name of the identifier
    or expression you supply as a parameter. For example, if `i32` is an `int32` object,
    then `@typeName( i32 )` returns the string `int32`. This function is useful for
    testing the types of objects you are processing in your compile-time programs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`@typeName` 函数返回一个字符串，指定你作为参数提供的标识符或表达式的类型名称。例如，如果 `i32` 是一个 `int32` 对象，那么
    `@typeName( i32 )` 将返回字符串 `int32`。这个函数对于测试你在编译时程序中处理的对象类型非常有用。'
- en: The `@elements` function requires an array identifier or expression. It returns
    the total number of array elements as the function result. Note that for multidimensional
    arrays this function returns the product of all the array dimensions.^([[120](#ftn.CHP-9-FN-3)])
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`@elements` 函数需要一个数组标识符或表达式。它返回数组元素的总数作为函数结果。需要注意的是，对于多维数组，这个函数返回所有数组维度的乘积。^([[120](#ftn.CHP-9-FN-3)])'
- en: The `@elementSize` function returns the size, in bytes, of an element of an
    array whose name you pass as a parameter. This function is extremely valuable
    for computing indices into an array (that is, this function computes the `element_size`
    component of the array index calculation; see [Chapter 4](ch04.html "Chapter 4. CONSTANTS,
    VARIABLES, AND DATA TYPES") for more details).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`@elementSize` 函数返回你作为参数传递的数组元素的大小（以字节为单位）。这个函数对于计算数组的索引非常有价值（也就是说，这个函数计算数组索引计算中的
    `element_size` 组件；更多细节请参见[第 4 章](ch04.html "第 4 章：常量、变量与数据类型")）。'
- en: 9.5.6 Miscellaneous Compile-Time Functions
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.6 杂项编译时函数
- en: 'The HLA compile-time language contains several additional functions that don''t
    fall into one of the categories above. Some of the more useful miscellaneous functions
    include the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 编译时语言包含一些不属于上述类别的额外函数。一些比较有用的杂项函数包括以下内容：
- en: '`@odd`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@odd`'
- en: '`@lineNumber`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@lineNumber`'
- en: '`@text`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@text`'
- en: The `@odd` function takes an ordinal value (i.e., nonreal numeric or character)
    as a parameter and returns true if the value is odd, false if it is even. The
    `@lineNumber` function requires no parameters; it returns the current line number
    in the source file. This function is quite useful for debugging compile-time (and
    runtime!) programs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`@odd` 函数接受一个序数值（即非实数的数字或字符）作为参数，如果该值是奇数，则返回 `true`，如果是偶数，则返回 `false`。`@lineNumber`
    函数不需要参数；它返回源文件中的当前行号。这个函数对于调试编译时（和运行时！）程序非常有用。'
- en: 'The `@text` function is probably the most useful function in this group. It
    requires a single-string parameter. It expands that string as text in place of
    the `@text` function call. This function is quite useful in conjunction with the
    compile-time string-processing functions. You can build an instruction (or a portion
    of an instruction) using the string-manipulation functions and then convert that
    string to program source code using the `@text` function. The following is a trivial
    example of this function in operation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`@text` 函数可能是这个组中最有用的函数。它需要一个单字符串参数，并将该字符串在 `@text` 函数调用处扩展为文本。这个函数与编译时字符串处理函数结合使用时非常有用。你可以使用字符串操作函数构建指令（或指令的一部分），然后通过
    `@text` 函数将该字符串转换为程序源代码。以下是这个函数在操作中的一个简单示例：'
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding sequence compiles to
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上述序列编译为
- en: '[PRE18]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 9.5.7 Compile-Time Type Conversions of Text Objects
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.7 编译时文本对象的类型转换
- en: 'Once you create a text constant in your program, it''s difficult to manipulate
    that object. The following example demonstrates a programmer''s desire to change
    the definition of a text symbol within a program:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在程序中创建了一个文本常量，就很难对该对象进行操作。以下示例展示了程序员希望在程序中更改文本符号定义的场景：
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The basic idea in this example is that the symbol `t` expands to `stdout.put`
    in the first half of the code, and it expands to `fileio.put` in the second half
    of the program. Unfortunately, this simple example will not work. The problem
    is that HLA will expand a text symbol in place almost anywhere it finds that symbol.
    This includes occurrences of `t` within a `?` statement. Therefore, the previous
    code expands to the following (incorrect) text:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的基本思路是，符号 `t` 在代码的前半部分展开为 `stdout.put`，而在程序的后半部分则展开为 `fileio.put`。不幸的是，这个简单的示例不会生效。问题在于
    HLA 会在几乎任何地方扩展文本符号。包括在 `?` 语句中的 `t`。因此，之前的代码扩展成了以下（不正确的）文本：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: HLA doesn't know how to deal with this `?` statement, so it generates a syntax
    error.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 不知道如何处理这个 `?` 语句，所以它会生成语法错误。
- en: 'At times you may not want HLA to expand a text object. Your code may want to
    process the string data held by the text object. HLA provides a couple of ways
    to deal with these two problems:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能不希望HLA展开文本对象。你的代码可能需要处理文本对象中持有的字符串数据。HLA提供了几种方法来处理这两个问题：
- en: '`@string(` *`identifier`* `)`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@string(` *`identifier`* `)`'
- en: '`@toString:`*`identifier`*'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@toString:`*`identifier`*'
- en: For `@string(` *`identifier`* `)`, HLA returns a string constant corresponding
    to the text data associated with the text object. In other words, this operator
    lets you treat a text object as though it were a string constant within an expression.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`@string(` *`identifier`* `)`，HLA返回与文本对象关联的字符串常量。换句话说，这个运算符允许你在表达式中将文本对象当作字符串常量来处理。
- en: Unfortunately, the `@string` function converts a text object to a string constant,
    not a string identifier. Therefore, you cannot say something like
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`@string`函数将文本对象转换为字符串常量，而不是字符串标识符。因此，你不能像这样写
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This doesn't work because `@string(t)` replaces itself with the string constant
    associated with the text object `t`. Given the former assignment to `t`, this
    statement expands to
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这不起作用，因为`@string(t)`将其自身替换为与文本对象`t`关联的字符串常量。根据之前对`t`的赋值，这个语句展开为
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This statement is still illegal.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句仍然是非法的。
- en: 'The `@toString:`*`identifier`* operator comes to the rescue in this case. The
    `@toString:` operator requires a text object as the associated identifier. It
    converts this text object to a string object (still maintaining the same string
    data) and then returns the identifier. Because the identifier is now a string
    object, you can assign a value to it (and change its type to something else, for
    example, `text`, if that''s what you need). To achieve the original goal, therefore,
    you''d use code like the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`@toString:`*`identifier`*运算符来帮忙。`@toString:`运算符要求一个文本对象作为关联标识符。它将这个文本对象转换为一个字符串对象（仍然保持相同的字符串数据），然后返回该标识符。因为标识符现在是一个字符串对象，你可以给它赋值（并将其类型更改为其他类型，例如`text`，如果需要的话）。因此，为了实现原始目标，你可以使用如下代码：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '* * *'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[119](#CHP-9-FN-2)]) Actually, because `@sin`'s parameter in this example
    is not exactly pi, you will get a small positive number instead of zero as the
    function result, but in theory you should get zero.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[119](#CHP-9-FN-2)]) 实际上，因为在这个例子中，`@sin`的参数并不完全是pi，所以你会得到一个小的正数而不是零作为函数结果，但理论上应该得到零。
- en: ^([[120](#CHP-9-FN-3)]) There is an `@dim` function that returns an array specifying
    the bounds on each dimension of a multidimensional array. See the documentation
    at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) or [http://www.artofasm.com/](http://www.artofasm.com/)
    for more details if you're interested in this function.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[120](#CHP-9-FN-3)]) 有一个`@dim`函数，返回一个数组，指定多维数组每个维度的边界。如果你对这个函数感兴趣，可以查看[http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)或[http://www.artofasm.com/](http://www.artofasm.com/)的文档获取更多详情。
- en: 9.6 Conditional Compilation (Compile-Time Decisions)
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.6 条件编译（编译时决策）
- en: 'HLA''s compile-time language provides an if statement, `#if`, that lets you
    make decisions at compile time. The `#if` statement has two main purposes: The
    traditional use of `#if` is to support *conditional compilation* (or *conditional
    assembly*), allowing you to include or exclude code during a compilation depending
    on the status of various symbols or constant values in your program. The second
    use of this statement is to support the standard if statement decision-making
    process in the HLA compile-time language. This section discusses these two uses
    for the HLA `#if` statement.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: HLA的编译时语言提供了一个`#if`语句，可以让你在编译时做出决策。`#if`语句有两个主要目的：传统用途是支持*条件编译*（或*条件汇编*），根据程序中各种符号或常量值的状态在编译过程中包含或排除代码。该语句的第二个用途是支持HLA编译时语言中的标准if语句决策过程。本节讨论了`#if`语句的这两种用途。
- en: 'The simplest form of the HLA compile-time `#if` statement uses the following
    syntax:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: HLA编译时`#if`语句的最简单形式使用以下语法：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that you do not place semicolons after the `#endif` clause. If you place
    a semicolon after the `#endif`, it becomes part of the source code, and this would
    be identical to inserting that semicolon immediately before the next item in the
    program.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`#endif`语句后面不应放置分号。如果在`#endif`后加上分号，它将成为源代码的一部分，这等同于在程序中的下一个项之前插入该分号。
- en: 'At compile time, HLA evaluates the expression in the parentheses after the
    `#if`. This must be a constant expression, and its type must be boolean. If the
    expression evaluates true, HLA continues to process the text in the source file
    as though the `#if` statement was not present. However, if the expression evaluates
    false, HLA treats all the text between the `#if` and the corresponding `#endif`
    clause as though it were a comment (that is, it ignores this text), as shown in
    [Figure 9-2](ch09s06.html#operation_of_an_hla_compile-time_number "Figure 9-2. Operation
    of an HLA compile-time #if statement").'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '在编译时，HLA 会评估 `#if` 后括号中的表达式。这个表达式必须是常量表达式，并且其类型必须是布尔类型。如果表达式求值为 true，HLA 会继续处理源文件中的文本，仿佛
    `#if` 语句不存在一样。然而，如果表达式求值为 false，HLA 会将 `#if` 和相应的 `#endif` 之间的所有文本视为注释（即忽略这些文本），如图
    [Figure 9-2](ch09s06.html#operation_of_an_hla_compile-time_number "Figure 9-2. HLA
    编译时 #if 语句的操作") 所示。'
- en: '![Operation of an HLA compile-time #if statement](tagoreillycom20100401nostarchimages578065.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![HLA 编译时 #if 语句的操作](tagoreillycom20100401nostarchimages578065.png)'
- en: Figure 9-2. Operation of an HLA compile-time `#if` statement
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2. HLA 编译时 `#if` 语句的操作
- en: 'Keep in mind that HLA''s constant expressions support a full expression syntax
    like you''d find in a high-level language like C or Pascal. The `#if` expression
    syntax is not limited to the syntax allowed by expressions in the HLA `if` statement.
    Therefore, it is perfectly reasonable to write fancy expressions like the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，HLA 的常量表达式支持完整的表达式语法，就像在 C 或 Pascal 等高级语言中找到的那样。`#if` 表达式的语法不限于 HLA `if`
    语句中允许的表达式语法。因此，编写如下复杂的表达式是完全合理的：
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Also keep in mind that the identifiers in a compile-time expression must all
    be `const` or `val` identifiers or an HLA compile-time function call (with appropriate
    parameters). In particular, remember that HLA evaluates these expressions at compile
    time so they cannot contain runtime variables.^([[121](#ftn.CHP-9-FN-4)]) HLA's
    compile-time language uses complete boolean evaluation, so any side effects that
    occur in the expression may produce undesired results.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要记住，编译时表达式中的标识符必须是 `const` 或 `val` 标识符，或是 HLA 编译时函数调用（并带有适当的参数）。特别需要注意的是，HLA
    在编译时评估这些表达式，因此它们不能包含运行时变量。^([[121](#ftn.CHP-9-FN-4)]) HLA 的编译时语言使用完整的布尔评估，因此表达式中出现的任何副作用可能会产生不期望的结果。
- en: 'The HLA `#if` statement supports optional `#elseif` and `#else` clauses that
    behave in the intuitive fashion. The complete syntax for the `#if` statement looks
    like the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 的 `#if` 语句支持可选的 `#elseif` 和 `#else` 子句，这些子句按直观的方式进行操作。`#if` 语句的完整语法如下所示：
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the first boolean expression evaluates true, then HLA processes the text
    up to the `#elseif` clause. It then skips all text (that is, treats it like a
    comment) until it encounters the `#endif` clause. HLA continues processing the
    text after the `#endif` clause in the normal fashion.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个布尔表达式求值为 true，那么 HLA 会处理直到 `#elseif` 子句的文本。然后，它会跳过所有文本（即将其视为注释），直到遇到 `#endif`
    子句。HLA 会继续按正常方式处理 `#endif` 子句之后的文本。
- en: If the first boolean expression above evaluates false, then HLA skips all the
    text until it encounters a `#elseif`, `#else`, or `#endif` clause. If it encounters
    a `#elseif` clause (as above), then HLA evaluates the boolean expression associated
    with that clause. If it evaluates true, HLA processes the text between the `#elseif`
    and the `#else` clauses (or to the `#endif` clause if the `#else` clause is not
    present). If, during the processing of this text, HLA encounters another `#elseif`
    or, as above, a `#else` clause, then HLA ignores all further text until it finds
    the corresponding `#endif`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上面的第一个布尔表达式求值为 false，那么 HLA 会跳过所有文本，直到遇到 `#elseif`、`#else` 或 `#endif` 子句。如果遇到
    `#elseif` 子句（如上所示），HLA 会评估与该子句相关联的布尔表达式。如果它求值为 true，HLA 会处理 `#elseif` 和 `#else`
    子句之间的文本（如果没有 `#else` 子句，则处理到 `#endif` 子句）。如果在处理这些文本时，HLA 遇到另一个 `#elseif` 或像上面那样的
    `#else` 子句，HLA 会忽略所有后续文本，直到找到相应的 `#endif`。
- en: If both the first and second boolean expressions in the previous example evaluate
    false, HLA skips their associated text and begins processing the text in the `#else`
    clause. As you can see, the `#if` statement behaves in a relatively intuitive
    fashion once you understand how HLA "executes" the body of these statements; the
    `#if` statement processes the text or treats it as a comment, depending on the
    state of the boolean expression. Of course, you can create a nearly infinite variety
    of different `#if` statement sequences by including zero or more `#elseif` clauses
    and optionally supplying the `#else` clause. Because the construction is identical
    to the HLA `if..then..elseif..else..endif` statement, there is no need to elaborate
    further here.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面示例中的第一个和第二个布尔表达式都为假，HLA 会跳过它们相关的文本并开始处理`#else`子句中的文本。如你所见，一旦理解了 HLA 如何“执行”这些语句的主体，`#if`语句的行为就变得相对直观；`#if`语句会根据布尔表达式的状态来处理文本或将其视为注释。当然，你可以通过包含零个或多个`#elseif`子句，并可选择性地提供`#else`子句，来创建几乎无限种不同的`#if`语句序列。由于这种构造与
    HLA 的`if..then..elseif..else..endif`语句完全相同，因此此处无需进一步详细说明。
- en: 'A very traditional use of conditional compilation is to develop software that
    you can easily configure for several different environments. For example, the
    `fcomip` instruction makes floating-point comparisons very easy, but this instruction
    is available only on Pentium Pro and later processors. If you want to use this
    instruction on the processors that support it and fall back to the standard floating-point
    comparison on the older processors, you would normally have to write two versions
    of the program—one with the `fcomip` instruction and one with the traditional
    floating-point comparison sequence. Unfortunately, maintaining two different source
    files (one for newer processors and one for older processors) is very difficult.
    Most engineers prefer to use conditional compilation to embed the separate sequences
    in the same source file. The following example demonstrates how to do this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译的一个非常传统的应用是开发可以轻松配置为多个不同环境的软件。例如，`fcomip`指令使得浮点比较变得非常容易，但该指令仅在 Pentium Pro
    及更高版本的处理器上可用。如果你希望在支持此指令的处理器上使用它，并在较旧的处理器上回退到标准的浮点比较，你通常需要编写两个版本的程序——一个使用`fcomip`指令，另一个使用传统的浮点比较序列。不幸的是，维护两个不同的源文件（一个针对较新的处理器，一个针对较旧的处理器）非常困难。大多数工程师更倾向于使用条件编译将不同的序列嵌入同一个源文件中。以下示例演示了如何实现这一点：
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As currently written, this code fragment will compile the three-instruction
    sequence in the `#else` clause and ignore the code between the `#if` and `#else`
    clauses (because the constant `PentProOrLater` is false). By changing the value
    of `PentProOrLater` to true, you can tell HLA to compile the single `fcomip` instruction
    rather than the three-instruction sequence. Of course, you can use the `PentProOrLater`
    constant in other `#if` statements throughout your program to control how HLA
    compiles your code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如当前编写的代码片段所示，它会在`#else`子句中编译三条指令序列，并忽略`#if`和`#else`子句之间的代码（因为常量`PentProOrLater`为假）。通过将`PentProOrLater`的值更改为真，你可以告诉
    HLA 编译单个`fcomip`指令，而不是三条指令的序列。当然，你可以在程序中的其他`#if`语句中使用`PentProOrLater`常量，以控制 HLA
    如何编译你的代码。
- en: 'Note that conditional compilation does not let you create a single *executable*
    that runs efficiently on all processors. When using this technique you will still
    have to create two executable programs (one for Pentium Pro and later processors,
    one for the earlier processors) by compiling your source file twice: During the
    first compilation you must set the `PentProOrLater` constant to false; during
    the second compilation you must set this constant to true. Although you must create
    two separate executables, you need only maintain a single source file.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，条件编译并不能让你创建一个能在所有处理器上高效运行的*可执行文件*。使用这种技术时，你仍然需要创建两个可执行程序（一个用于 Pentium Pro
    及更高版本的处理器，一个用于较早版本的处理器），通过编译源文件两次：第一次编译时必须将`PentProOrLater`常量设置为假；第二次编译时必须将该常量设置为真。尽管你需要创建两个独立的可执行文件，但只需维护一个源文件。
- en: 'If you are familiar with conditional compilation in other languages, such as
    the C/C++ language, you may be wondering if HLA supports a statement like C''s
    `#ifdef` statement. The answer is no, it does not. However, you can use the HLA
    compile-time function `@defined` to easily test to see if a symbol has been defined
    earlier in the source file. Consider the following modification to the preceding
    code that uses this technique:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他语言中的条件编译，例如C/C++语言，你可能会想知道HLA是否支持类似C语言中的`#ifdef`语句。答案是否定的，HLA不支持。但你可以使用HLA的编译时函数`@defined`轻松测试符号是否已在源文件中定义。考虑以下对前面代码的修改，使用了这种技巧：
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another common use of conditional compilation is to introduce debugging and
    testing code into your programs. A typical debugging technique that many HLA programmers
    use is to insert "print" statements at strategic points throughout their code;
    this enables them to trace through their code and display important values at
    various checkpoints. A big problem with this technique, however, is that they
    must remove the debugging code prior to completing the project. The software''s
    customer (or a student''s instructor) probably doesn''t want to see debugging
    output in the middle of a report the program produces. Therefore, programmers
    who use this technique tend to insert code temporarily and then remove the code
    once they run the program and determine what is wrong. There are at least two
    problems with this technique:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译的另一个常见用途是将调试和测试代码引入程序中。许多HLA程序员使用的典型调试技巧是在代码中的关键位置插入“print”语句；这使得他们能够在代码中跟踪并显示在不同检查点的关键值。然而，这种技巧的一个大问题是，在项目完成之前，他们必须删除调试代码。软件的客户（或学生的导师）可能不希望在程序生成的报告中看到调试输出。因此，使用这种技巧的程序员往往会暂时插入代码，然后在运行程序并确定问题所在后将代码移除。使用这种技巧至少有两个问题：
- en: Programmers often forget to remove some debugging statements, and this creates
    defects in the final program.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员常常忘记删除一些调试语句，这会导致最终程序中出现缺陷。
- en: After removing a debugging statement, these programmers often discover that
    they need that same statement to debug some different problem at a later time.
    Hence they are constantly inserting and removing the same statements over and
    over again.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移除调试语句后，这些程序员常常发现他们需要该语句来调试稍后出现的不同问题。因此，他们不断地插入和移除相同的语句。
- en: 'Conditional compilation can provide a solution to this problem. By defining
    a symbol (say, `debug`) to control debug output in your program, you can easily
    activate or deactivate *all* debugging output by simply modifying a single line
    of source code. The following code fragment demonstrates this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编译可以提供解决这个问题的方法。通过定义一个符号（例如`debug`）来控制程序中的调试输出，你可以通过简单地修改一行源代码，轻松地激活或停用*所有*调试输出。以下代码片段演示了这一点：
- en: '[PRE29]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As long as you surround all debugging output statements with an #if statement
    like the preceding, you don''t have to worry about debug output accidentally appearing
    in your final application. By setting the `debug` symbol to false, you can automatically
    disable all such output. Likewise, you don''t have to remove all your debugging
    statements from your programs once they''ve served their immediate purpose. By
    using conditional compilation, you can leave these statements in your code because
    they are so easy to deactivate. Later, if you decide you need to view this same
    debugging information during a compilation, you won''t have to reenter the debugging
    statement; you simply reactivate it by setting the `debug` symbol to true.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你像前面那样，用`#if`语句将所有调试输出语句包裹起来，就不必担心调试输出会意外出现在最终的应用程序中。通过将`debug`符号设置为`false`，你可以自动禁用所有此类输出。同样，你也不必在调试语句完成其即时功能后将其从程序中移除。通过使用条件编译，你可以将这些语句保留在代码中，因为它们很容易被停用。以后，如果你决定在编译过程中需要查看相同的调试信息，你不必重新输入调试语句；只需通过将`debug`符号设置为`true`来重新启用它。
- en: Although program configuration and debugging control are two of the more common,
    traditional uses for conditional compilation, don't forget that the `#if` statement
    provides the basic conditional statement in the HLA compile-time language. You
    will use the `#if` statement in your compile-time programs the same way you would
    use an `if` statement in HLA or some other language. Later sections in this text
    will present lots of examples of using the `#if` statement in this capacity.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管程序配置和调试控制是条件编译的两种更常见、传统的用途，但不要忘记，`#if` 语句提供了 HLA 编译时语言中的基本条件语句。你将像在 HLA 或其他语言中使用
    `if` 语句一样，在编译时程序中使用 `#if` 语句。本书后续部分将提供许多关于如何在这方面使用 `#if` 语句的示例。
- en: '* * *'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[121](#CHP-9-FN-4)]) Except, of course, as parameters to certain HLA compile-time
    functions like `@size` or `@typeName`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[121](#CHP-9-FN-4)]) 当然，除非作为某些 HLA 编译时函数的参数，如 `@size` 或 `@typeName`。
- en: 9.7 Repetitive Compilation (Compile-Time Loops)
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.7 重复编译（编译时循环）
- en: HLA's `#while..#endwhile` and `#for..#endfor` statements provide compile-time
    loop constructs. The `#while` statement tells HLA to process the same sequence
    of statements repetitively during compilation. This is very handy for constructing
    data tables as well as providing a traditional looping structure for compile-time
    programs. Although you will not employ the `#while` statement anywhere near as
    often as the `#if` statement, this compile-time control structure is very important
    when you write advanced HLA programs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 的 `#while..#endwhile` 和 `#for..#endfor` 语句提供了编译时循环结构。`#while` 语句告诉 HLA 在编译期间反复处理相同的语句序列。这对于构建数据表以及为编译时程序提供传统的循环结构非常有用。尽管你不会像使用
    `#if` 语句那样频繁使用 `#while` 语句，但当你编写高级 HLA 程序时，这个编译时控制结构非常重要。
- en: 'The `#while` statement uses the following syntax:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`#while` 语句的语法如下：'
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When HLA encounters the `#while` statement during compilation, it will evaluate
    the constant boolean expression. If the expression evaluates false, HLA will skip
    over the text between the `#while` and the `#endwhile` clauses (the behavior is
    similar to the `#if` statement if the expression evaluates false). If the expression
    evaluates true, then HLA will process the statements between the `#while` and
    `#endwhile` clauses and then "jump back" to the start of the `#while` statement
    in the source file and repeat this process, as shown in [Figure 9-3](ch09s07.html#hla_compile-time_number_symble_while_sta
    "Figure 9-3. HLA compile-time #while statement operation").'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HLA 在编译时遇到 `#while` 语句时，它将评估常量布尔表达式。如果表达式的值为假，HLA 将跳过 `#while` 和 `#endwhile`
    语句之间的文本（此行为类似于 `#if` 语句在表达式为假时的行为）。如果表达式的值为真，HLA 将处理 `#while` 和 `#endwhile` 语句之间的内容，然后“跳回”源文件中的
    `#while` 语句开始处，并重复这一过程，如 [图 9-3](ch09s07.html#hla_compile-time_number_symble_while_sta
    "图 9-3. HLA 编译时 `#while` 语句操作") 所示。
- en: '![HLA compile-time #while statement operation](tagoreillycom20100401nostarchimages578067.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![HLA 编译时 `#while` 语句操作](tagoreillycom20100401nostarchimages578067.png)'
- en: Figure 9-3. HLA compile-time `#while` statement operation
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3. HLA 编译时 `#while` 语句操作
- en: To understand how this process works, consider the program in [Example 9-2](ch09s07.html#number_symble_while.._number_symble_endw
    "Example 9-2. #while..#endwhile demonstration").
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个过程是如何工作的，请参阅 [示例 9-2](ch09s07.html#number_symble_while.._number_symble_endw
    "示例 9-2. `#while..#endwhile` 演示") 中的程序。
- en: Example 9-2. `#while..#endwhile` demonstration
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-2. `#while..#endwhile` 演示
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can probably surmise, the output from this program is the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，来自该程序的输出如下：
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What is not quite obvious is how this program generates this output. Remember,
    the `#while..#endwhile` construct is a compile-time language feature, not a runtime
    control construct. Therefore, the previous `#while` loop repeats five times during
    *compilation*. On each repetition of the loop, the HLA compiler processes the
    statements between the `#while` and `#endwhile` clauses. Therefore, the preceding
    program is really equivalent to the code that is shown in [Example 9-3](ch09s07.html#program_equivalent_to_the_code_in_listin
    "Example 9-3. Program equivalent to the code in Example 9-2").
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 不太明显的是，这个程序是如何生成输出的。请记住，`#while..#endwhile` 结构是一个编译时语言特性，而不是运行时控制结构。因此，之前的 `#while`
    循环在 *编译* 时重复执行五次。在每次循环重复时，HLA 编译器都会处理 `#while` 和 `#endwhile` 语句之间的内容。因此，前面的程序实际上等同于
    [示例 9-3](ch09s07.html#program_equivalent_to_the_code_in_listin "示例 9-3. 与示例 9-2
    中代码等效的程序") 中显示的代码。
- en: Example 9-3. Program equivalent to the code in [Example 9-2](ch09s07.html#number_symble_while.._number_symble_endw
    "Example 9-2. #while..#endwhile demonstration")
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-3. 与[示例 9-2](ch09s07.html#number_symble_while.._number_symble_endw "示例
    9-2. `#while..#endwhile`演示")中的代码等效的程序
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see in this example, the `#while` statement is very convenient for
    constructing repetitive-code sequences. This is especially invaluable for unrolling
    loops.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，`#while`语句非常方便用于构建重复代码序列。这对于展开循环尤其宝贵。
- en: 'HLA provides three forms of the `#for..#endfor` loop. These three loops take
    the following general form:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: HLA提供了三种形式的`#for..#endfor`循环。这三种循环具有以下通用形式：
- en: Example 9-4. HLA `#for` loops
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-4. HLA `#for`循环
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As its name suggests, *`valObject`* must be an object you've defined in a `val`
    declaration.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，*`valObject`*必须是你在`val`声明中定义的对象。
- en: 'For the first two forms of the `#for` loop above, the *`startExpr`* and *`endExpr`*
    components can be any HLA constant expression that yields an integer value. The
    first of these `#for` loops is semantically equivalent to the following `#while`
    code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述两种形式的`#for`循环，*`startExpr`*和*`endExpr`*组件可以是任何返回整数值的HLA常量表达式。这两种`#for`循环中的第一个语义上等同于以下`#while`代码：
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The second of these `#for` loops is semantically equivalent to the `#while`
    loop:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种`#for`循环中的第二种语义上等同于`#while`循环：
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The third of these `#for` loops (the one using the `in` keyword) is especially
    useful for processing individual items from some composite data type. This loop
    repeats once for each element, field, character, and so on of the composite value
    you specify for *`composite_expr`*. This can be an array, string, record, or character
    set expression. For arrays, this `#for` loop repeats once for each element of
    the array and on each iteration of the loop; the loop control variable contains
    the current element''s value. For example, the following compile-time loop displays
    the values 1, 10, 100, and 1,000:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种`#for`循环中的第三种（使用`in`关键字的循环）对于处理某些复合数据类型中的单个项特别有用。该循环会针对你为*`composite_expr`*指定的复合值中的每个元素、字段、字符等重复一次。这可以是数组、字符串、记录或字符集表达式。对于数组，该`#for`循环会针对数组的每个元素重复一次，并且在每次迭代时，循环控制变量包含当前元素的值。例如，以下编译时循环会显示值1、10、100和1,000：
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the *`composite_expr`* constant is a string constant, the `#for` loop repeats
    once for each character in the string and sets the value of the loop control variable
    to the current character. If the *`composite_expr`* constant expression is a record
    constant, then the loop will repeat once for each field of the record, and for
    each iteration the loop control variable will take on the *type and value* of
    the current field. If the *`composite_expr`* expression is a character set, the
    loop will repeat once for each character in the set, and the loop control variable
    will be assigned that character.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*`composite_expr`*常量是字符串常量，`#for`循环会针对字符串中的每个字符重复一次，并将循环控制变量的值设置为当前字符。如果*`composite_expr`*常量表达式是记录常量，则循环会针对记录的每个字段重复一次，并且在每次迭代时，循环控制变量将采用当前字段的*类型和值*。如果*`composite_expr`*表达式是字符集，则循环会针对集合中的每个字符重复一次，并将循环控制变量赋值为该字符。
- en: The `#for` loop actually turns out to be more useful than the `#while` loop
    because the larger number of compile-time loops you encounter repeat a fixed number
    of times (for example, processing a fixed number of array elements, macro parameters,
    and so on).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`#for`循环实际上比`#while`循环更有用，因为你遇到的大多数编译时循环会重复固定次数（例如，处理固定数量的数组元素、宏参数等）。'
- en: 9.8 Macros (Compile-Time Procedures)
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.8 宏（编译时过程）
- en: Macros are objects that a language processor replaces with other text during
    compilation. Macros are great devices for replacing long, repetitive sequences
    of text with much shorter sequences of text. In additional to the traditional
    role that macros play (e.g., `#define` in C/C++), HLA's macros also serve as the
    equivalent of a compile-time language procedure or function. Therefore, macros
    are very important in HLA's compile-time language—just as important as functions
    and procedures are in other high-level languages.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是语言处理器在编译期间用其他文本替换的对象。宏是替换长而重复的文本序列为较短文本序列的极好工具。除了宏在传统作用下的功能（例如C/C++中的`#define`），HLA的宏还充当编译时语言过程或函数的等效体。因此，宏在HLA的编译时语言中非常重要——就像其他高级语言中的函数和过程一样重要。
- en: Although macros are nothing new, HLA's implementation of macros far exceeds
    the macro-processing capabilities of most other programming languages (high level
    or low level). The following sections explore HLA's macro-processing facilities
    and the relationship between macros and other HLA CTL control constructs.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然宏并不新鲜，但HLA对宏的实现远超大多数其他编程语言（无论是高级语言还是低级语言）的宏处理能力。以下各节将探讨HLA的宏处理功能以及宏与其他HLA
    CTL控制结构之间的关系。
- en: 9.8.1 Standard Macros
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8.1 标准宏
- en: 'HLA supports a straightforward macro facility that lets you define macros in
    a manner that is similar to declaring a procedure. A typical, simple macro declaration
    takes the following form:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: HLA支持一个简单直接的宏功能，允许你以类似声明过程的方式定义宏。一个典型的简单宏声明形式如下：
- en: '[PRE38]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Although macro and procedure declarations are similar, there are several immediate
    differences between the two that are obvious from this example. First, of course,
    macro declarations use the reserved word `#macro` rather than procedure. Second,
    you do not begin the body of the macro with a begin *`macroname`*`;` clause. Finally,
    you will note that macros end with the `#endmacro` clause rather than `end` *`macroname`*`;`.
    The following code is a concrete example of a macro declaration:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管宏和过程声明相似，但从这个例子中可以明显看出两者之间有几个直接的区别。首先，当然，宏声明使用保留字`#macro`而不是`procedure`。其次，你不会以`begin
    *`macroname`*`;`语句开始宏的主体。最后，你会注意到宏以`#endmacro`语句结束，而不是`end *`macroname`*`;`。以下代码是一个宏声明的具体示例：
- en: '[PRE39]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Execution of this macro's code will compute the two's complement of the 64-bit
    value in EDX:EAX (see the description of extended-precision `neg` in [8.1.7 Extended-Precision
    neg Operations](ch08.html#extended-precision_neg_operations "8.1.7 Extended-Precision
    neg Operations")).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此宏的代码将计算EDX:EAX中的64位值的二补数（详见[8.1.7 扩展精度 neg 操作](ch08.html#extended-precision_neg_operations
    "8.1.7 扩展精度 neg 操作")的描述）。
- en: 'To execute the code associated with `neg64`, you simply specify the macro''s
    name at the point you want to execute these instructions. For example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行与`neg64`相关的代码，只需在你想执行这些指令的地方指定宏的名称。例如：
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that you do *not* follow the macro's name with a pair of empty parentheses
    as you would a procedure call (the reason for this will become clear a little
    later).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你*不*需要像调用过程那样，在宏的名称后跟一对空括号（稍后这个原因会变得很清楚）。
- en: 'Other than the lack of parentheses following `neg64`''s invocation,^([[122](#ftn.CHP-9-FN-5)])
    this looks just like a procedure call. You could implement this simple macro as
    a procedure using the following procedure declaration:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`neg64`调用后没有括号外，^([[122](#ftn.CHP-9-FN-5)])这看起来就像一个过程调用。你可以使用以下过程声明来实现这个简单的宏：
- en: '[PRE41]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note that the following two statements will both negate the value in EDX:EAX:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下两条语句都会对EDX:EAX中的值取反：
- en: '[PRE42]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The difference between these two (the macro invocation versus the procedure
    call) is the fact that macros expand their text inline, whereas a procedure call
    emits a call to the corresponding procedure elsewhere in the text. That is, HLA
    replaces the invocation `neg64;` directly with the following text:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者之间的区别（宏调用与过程调用）在于，宏会将其文本内联展开，而过程调用会发出一个调用，去调用文本中其它地方的相应过程。也就是说，HLA会将`neg64;`调用直接替换为以下文本：
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'On the other hand, HLA replaces the procedure call `neg64p();` with the single
    call instruction:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，HLA用单一的调用指令替代了过程调用`neg64p();`：
- en: '[PRE44]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Presumably, you've defined the `neg64p` procedure earlier in the program.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在程序中已经定义了`neg64p`过程。
- en: 'You should make the choice of macro versus procedure call on the basis of efficiency.
    Macros are slightly faster than procedure calls because you don''t execute the
    `call` and corresponding `ret` instructions. On the other hand, the use of macros
    can make your program larger because a macro invocation expands to the text of
    the macro''s body on each invocation. Procedure calls jump to a single instance
    of the procedure''s body. Therefore, if the macro body is large and you invoke
    the macro several times throughout your program, it will make your final executable
    much larger. Also, if the body of your macro executes more than a few simple instructions,
    the overhead of a `call/ret` sequence has little impact on the overall execution
    time of the code, so the execution time savings are nearly negligible. On the
    other hand, if the body of a procedure is very short (like the `neg64` example
    above), you''ll discover that the macro implementation is much faster and doesn''t
    expand the size of your program by much. A good rule of thumb is:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该根据效率来决定使用宏还是过程调用。宏比过程调用稍微快一些，因为你不需要执行`call`和相应的`ret`指令。另一方面，使用宏可能会使你的程序变大，因为每次调用宏时，宏的正文文本会被展开。过程调用则跳转到过程正文的单一实例。因此，如果宏的正文很大，并且你在程序中多次调用该宏，它会使最终的可执行文件变得更大。此外，如果宏的正文执行的指令超过几个简单的指令，`call/ret`序列的开销对总体执行时间几乎没有影响，因此执行时间的节省几乎可以忽略不计。另一方面，如果过程的正文非常短（像上面提到的`neg64`示例），你会发现宏实现更快，并且不会显著增加程序的大小。一个好的经验法则是：
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use macros for short, time-critical program units. Use procedures for longer
    blocks of code and when execution time is not as critical.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宏处理短小且时间敏感的程序单元。使用过程处理更长的代码块，且在执行时间不那么关键时使用过程。
- en: Macros have many other disadvantages over procedures. Macros cannot have local
    (automatic) variables, macro parameters work differently than procedure parameters,
    macros don't support (runtime) recursion, and macros are a little more difficult
    to debug than procedures (just to name a few disadvantages). Therefore, you shouldn't
    really use macros as a substitute for procedures except in cases where performance
    is absolutely critical.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 宏相对于过程还有许多其他缺点。宏不能有局部（自动）变量，宏参数与过程参数的工作方式不同，宏不支持（运行时）递归，而且宏比过程更难调试（仅举几项缺点）。因此，除非在性能至关重要的情况下，否则你不应将宏作为过程的替代品。
- en: 9.8.2 Macro Parameters
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8.2 宏参数
- en: Like procedures, macros allow you to define parameters that let you supply different
    data on each macro invocation. This lets you write generic macros whose behavior
    can vary depending on the parameters you supply. By processing these macro parameters
    at compile time, you can write very sophisticated macros.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 与过程类似，宏允许你定义参数，使你可以在每次调用宏时提供不同的数据。这使得你可以编写通用的宏，宏的行为可以根据你提供的参数而有所不同。通过在编译时处理这些宏参数，你可以编写非常复杂的宏。
- en: 'Macro parameter declaration syntax is very straightforward. You simply supply
    a list of parameter names within parentheses in a macro declaration:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 宏参数声明语法非常简单。在宏声明中，你只需在括号内提供参数名称的列表：
- en: '[PRE45]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that you do not associate a data type with a macro parameter as you do
    for procedural parameters. This is because HLA macros are generally `text` objects.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，宏参数不像过程参数那样与数据类型相关联。这是因为HLA宏通常是`text`类型对象。
- en: 'When you invoke a macro, you simply supply the actual parameters the same way
    you would for a procedure call:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用宏时，你只需像调用过程一样提供实际的参数：
- en: '[PRE46]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that a macro invocation that requires parameters expects you to enclose
    the parameter list within parentheses.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要求参数的宏调用期望你将参数列表包含在括号内。
- en: 9.8.2.1 Standard Macro Parameter Expansion
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.2.1 标准宏参数展开
- en: As the previous section explains, HLA automatically associates the type `text`
    with macro parameters. This means that during a macro expansion, HLA substitutes
    the text you supply as the actual parameter everywhere the formal parameter name
    appears. The semantics of "pass by textual substitution" are a little different
    than "pass by value" or "pass by reference," so it is worthwhile exploring those
    differences here.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一节所解释的，HLA会自动将`text`类型与宏参数关联。这意味着，在宏展开过程中，HLA会在每次出现正式参数名称的地方，替换为你提供的实际参数。所谓的“通过文本替换传递”与“按值传递”或“按引用传递”的语义有所不同，因此在此探讨这些差异是有价值的。
- en: 'Consider the following macro invocations, using the `neg64` macro from the
    previous section:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下宏调用，使用上一节中的 `neg64` 宏：
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'These two invocations expand into the following code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个调用会扩展为以下代码：
- en: '[PRE48]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that macro invocations do not make a local copy of the parameters (as
    "pass by value" does), nor do they pass the address of the actual parameter to
    the macro. Instead, a macro invocation of the form `neg64( edx, eax );` is equivalent
    to the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，宏调用并不会创建参数的局部副本（就像“按值传递”那样），也不会将实际参数的地址传递给宏。相反，`neg64( edx, eax );` 这种形式的宏调用相当于以下内容：
- en: '[PRE49]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Of course, the text objects immediately expand their string values inline, producing
    the former expansion for `neg64( edx, eax );`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，文本对象会立即展开其字符串值，在线扩展 `neg64( edx, eax );` 的前一个扩展。
- en: 'Note that macro parameters are not limited to memory, register, or constant
    operands as are instruction or procedure operands. Any text is fine as long as
    its expansion is legal wherever you use the formal parameter. Similarly, formal
    parameters may appear anywhere in the macro body, not just where memory, register,
    or constant operands are legal. Consider the following macro declaration and sample
    invocations:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，宏参数不限于内存、寄存器或常量操作数，就像指令或过程操作数一样。只要其扩展在使用正式参数的地方是合法的，任何文本都可以。类似地，正式参数可以出现在宏体中的任何位置，而不仅仅是在内存、寄存器或常量操作数合法的地方。考虑以下宏声明和示例调用：
- en: '[PRE50]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In general, HLA assumes that all text between commas constitutes a single macro
    parameter. If HLA encounters any opening bracketing symbols (left parentheses,
    left braces, or left brackets), then it will include all text up to the appropriate
    closing symbol, ignoring any commas that may appear within the bracketing symbols.
    This is why the `chkError` invocations above treat `cmp( eax, 0 )` and `test(
    1, bl )` as single parameters rather than as a pair of parameters. Of course,
    HLA does not consider commas (and bracketing symbols) within a string constant
    as the end of an actual parameter. So the following macro and invocation are perfectly
    legal:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，HLA 假定所有逗号之间的文本构成一个单一的宏参数。如果 HLA 遇到任何左括号、左大括号或左中括号符号，它会包括所有文本，直到遇到相应的闭合符号，忽略括号符号内可能出现的任何逗号。这就是为什么上面的
    `chkError` 调用将 `cmp( eax, 0 )` 和 `test( 1, bl )` 视为单个参数，而不是一对参数。当然，HLA 不会将字符串常量中的逗号（和括号符号）视为实际参数的结束。所以以下宏和调用是完全合法的：
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: HLA treats the string `Hello, world!` as a single parameter because the comma
    appears inside a literal string constant, just as your intuition suggests.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 将字符串 `Hello, world!` 视为单个参数，因为逗号出现在一个字面字符串常量内，就像你的直觉所建议的那样。
- en: 'If you are unfamiliar with textual macro parameter expansion in other languages,
    you should be aware that there are some problems you can run into when HLA expands
    your actual macro parameters. Consider the following macro declaration and invocation:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉其他语言中的文本宏参数扩展，应该注意到，当 HLA 扩展你的实际宏参数时，可能会遇到一些问题。考虑以下宏声明和调用：
- en: '[PRE52]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This example displays `Hello` five times during compilation rather than the
    eight times you might intuitively expect. This is because the `#for` statement
    above expands to
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在编译时会显示 `Hello` 五次，而不是你直觉上可能期待的八次。这是因为上面的 `#for` 语句扩展为：
- en: '[PRE53]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The actual parameter for *n* is `3+1`; because HLA expands this text directly
    in place of *n*, you get an erroneous text expansion. Of course, at compile time
    HLA computes `3+1*2` as the value 5 rather than as the value 8 (which you would
    get had HLA passed this parameter by value rather than by textual substitution).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* 的实际参数是 `3+1`；因为 HLA 会将此文本直接替换为 *n*，所以你会得到一个错误的文本扩展。当然，在编译时，HLA 会将 `3+1*2`
    计算为值 5，而不是值 8（如果 HLA 是通过值传递而不是文本替换传递这个参数，你将得到值 8）。'
- en: 'The common solution to this problem when passing numeric parameters that may
    contain compile-time expressions is to surround the formal parameter in the macro
    with parentheses; for example, you would rewrite the macro above as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 传递可能包含编译时表达式的数值参数时，解决此问题的常见方法是将宏中的正式参数括起来；例如，你可以将上面的宏重写如下：
- en: '[PRE54]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The earlier invocation would expand to the following code:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的调用将扩展为以下代码：
- en: '[PRE55]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This version of the macro produces the intuitive result.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的宏会产生直观的结果。
- en: If the number of actual parameters does not match the number of formal parameters,
    HLA will generate a diagnostic message during compilation. As with procedures,
    the number of actual parameters must agree with the number of formal parameters.
    If you would like to have optional macro parameters, then keep reading.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实际参数的数量与形式参数的数量不匹配，HLA 会在编译期间生成诊断消息。与过程一样，实际参数的数量必须与形式参数的数量一致。如果你想要有可选的宏参数，请继续阅读。
- en: 9.8.2.2 Macros with a Variable Number of Parameters
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.2.2 参数个数可变的宏
- en: 'You may have noticed by now that some HLA macros don''t require a fixed number
    of parameters. For example, the `stdout.put` macro in the HLA Standard Library
    allows one or more actual parameters. HLA uses a special array syntax to tell
    the compiler that you wish to allow a variable number of parameters in a macro
    parameter list. If you follow the last macro parameter in the formal parameter
    list with `[ ]`, then HLA will allow a variable number of actual parameters (zero
    or more) in place of that formal parameter. For example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，一些 HLA 宏不需要固定数量的参数。例如，HLA 标准库中的 `stdout.put` 宏允许一个或多个实际参数。HLA 使用一种特殊的数组语法来告诉编译器，你希望在宏参数列表中允许一个可变数量的参数。如果你在形式参数列表中的最后一个宏参数后加上
    `[ ]`，那么 HLA 将允许用零个或多个实际参数代替该形式参数。例如：
- en: '[PRE56]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note the last invocation especially. If a macro has any formal parameters, you
    must supply parentheses with the macro list after the macro invocation. This is
    true even if you supply zero actual parameters to a macro with a varying parameter
    list. Keep in mind this important difference between a macro with no parameters
    and a macro with a varying parameter list but no actual parameters.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意最后一次调用。如果一个宏有任何形式参数，在宏调用后，你必须为宏列表提供圆括号。即使你给一个具有变化参数列表的宏提供零个实际参数，这也是成立的。请记住，没有参数的宏与具有变化参数列表但没有实际参数的宏之间的这个重要区别。
- en: 'When HLA encounters a formal macro parameter with the `[ ]` suffix (which must
    be the last parameter in the formal parameter list), HLA creates a constant string
    array and initializes that array with the text associated with the remaining actual
    parameters in the macro invocation. You can determine the number of actual parameters
    assigned to this array using the `@elements` compile-time function. For example,
    `@elements( varying )` will return some value, 0 or greater, that specifies the
    total number of parameters associated with that parameter. The following declaration
    for `varParms` demonstrates how you might use this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HLA 遇到一个带有 `[ ]` 后缀的形式宏参数时（该参数必须是形式参数列表中的最后一个参数），HLA 会创建一个常量字符串数组，并用宏调用中剩余实际参数关联的文本初始化该数组。你可以使用
    `@elements` 编译时函数来确定分配给该数组的实际参数数量。例如，`@elements( varying )` 将返回一个值，0 或更大，指定与该参数关联的总参数数量。以下对
    `varParms` 的声明演示了如何使用这一点：
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Because HLA doesn''t allow arrays of `text` objects, the varying parameter
    must be an array of strings. This, unfortunately, means you must treat the varying
    parameters differently than you handle standard macro parameters. If you want
    some element of the varying string array to expand as text within the macro body,
    you can always use the `@text` function to achieve this. Conversely, if you want
    to use a nonvarying formal parameter as a string object, you can always use the
    `@string`( *`name`* ) function. The following example demonstrates this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 HLA 不允许 `text` 对象的数组，变化参数必须是一个字符串数组。不幸的是，这意味着你必须将变化参数与标准宏参数区分开来。如果你希望变化的字符串数组中的某个元素在宏体内展开为文本，你可以始终使用
    `@text` 函数来实现这一点。相反，如果你希望使用一个非变化的形式参数作为字符串对象，你可以始终使用 `@string` (*`name`*) 函数。以下示例演示了这一点：
- en: '[PRE58]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Of course, it would be a good idea, in a macro like the above, to verify that
    there are at least two parameters before attempting to reference element zero
    of the `optional` parameter. You can easily do this as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在像上面这样的宏中，最好先验证是否至少有两个参数，然后再尝试引用 `optional` 参数的零元素。你可以如下简单实现这一点：
- en: '[PRE59]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 9.8.2.3 Required vs. Optional Macro Parameters
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8.2.3 必需与可选宏参数
- en: As the previous section notes, HLA requires exactly one actual parameter for
    each nonvarying formal macro parameter. If there is no varying macro parameter
    (and there can be at most one), then the number of actual parameters must exactly
    match the number of formal parameters. If a varying formal parameter is present,
    then there must be at least as many actual macro parameters as there are nonvarying
    (or required) formal macro parameters. If there is a single, varying actual parameter,
    then a macro invocation may have zero or more actual parameters.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，HLA要求每个非变化的正式宏参数必须有一个实际参数。如果没有变化的宏参数（最多只能有一个），那么实际参数的数量必须完全匹配正式参数的数量。如果存在变化的正式参数，那么必须至少有与非变化（或必需）正式宏参数一样多的实际宏参数。如果有一个单一的变化实际参数，那么宏调用可以有零个或多个实际参数。
- en: 'There is one big difference between a macro invocation of a macro with no parameters
    and a macro invocation of a macro with a single, varying parameter that has no
    actual parameters: The macro with the varying parameter list must have an empty
    set of parentheses after it, while the macro invocation of the macro without any
    parameters does not allow this. You can use this fact to your advantage if you
    wish to write a macro that doesn''t have any parameters but you want to follow
    the macro invocation with `( )` so that it matches the syntax of a procedure call
    with no parameters. Consider the following macro:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个没有参数的宏和调用一个带有单个、变化参数且没有实际参数的宏之间有一个很大的区别：带有变化参数列表的宏后面必须有一对空的括号，而调用没有任何参数的宏时不允许这样做。如果你希望编写一个没有任何参数的宏，但又想让宏调用后跟着
    `( )`，以使其与没有参数的过程调用语法匹配，你可以利用这个事实。考虑以下宏：
- en: '[PRE60]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding macro requires invocations of the form `neg64();` to use the same
    syntax you would use for a procedure call. This feature is useful if you want
    the syntax of your parameterless macro invocations to match the syntax of a parameterless
    procedure call. It's not a bad idea to do this, just in the off chance you need
    to convert the macro to a procedure at some point (or vice versa, for that matter).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的宏要求调用形式为`neg64();`，以使用与过程调用相同的语法。如果你希望无参数宏调用的语法与无参数过程调用的语法匹配，这个特性非常有用。如果将来某个时候你需要将宏转换为过程（或者反过来），这么做也不失为一个好主意。
- en: 9.8.3 Local Symbols in a Macro
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8.3 宏中的局部符号
- en: 'Consider the following macro declaration:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下宏声明：
- en: '[PRE61]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The purpose of this macro is to simulate an instruction that jumps to the specified
    target location if the zero flag is set `and` the carry flag is set. Conversely,
    if either the zero flag is clear or the carry flag is clear, this macro transfers
    control to the instruction immediately following the macro invocation.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏的目的是模拟一个指令，当零标志被设置`and`进位标志被设置时，跳转到指定的目标位置。相反，如果零标志或进位标志之一被清除，则此宏将控制转移到宏调用后面的指令。
- en: 'There is a serious problem with this macro. Consider what happens if you use
    this macro more than once in your program:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏有一个严重的问题。考虑一下如果在程序中多次使用这个宏会发生什么：
- en: '[PRE62]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding macro invocations expand to the following code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的宏调用展开为以下代码：
- en: '[PRE63]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The problem with the expansion of these two macro invocations is that they both
    emit the same label, `NotTarget`, during macro expansion. When HLA processes this
    code it will complain about a duplicate symbol definition. Therefore, you must
    take care when defining symbols inside a macro because multiple invocations of
    that macro may lead to multiple definitions of that symbol.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个宏调用展开的问题是它们在宏展开时都会发出相同的标签`NotTarget`。当HLA处理这段代码时，它会抱怨重复的符号定义。因此，在宏内部定义符号时必须小心，因为该宏的多次调用可能会导致该符号的多重定义。
- en: HLA's solution to this problem is to allow the use of *local symbols* within
    a macro. Local macro symbols are unique to a specific invocation of a macro. For
    example, had `NotTarget` been a local symbol in the preceding `JZC` macro invocations,
    the program would have compiled properly because HLA treats each occurrence of
    `NotTarget` as a unique symbol.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: HLA解决这个问题的方法是允许在宏内使用*局部符号*。局部宏符号是特定宏调用的唯一标识符。例如，如果`NotTarget`在前面的`JZC`宏调用中是一个局部符号，程序会正常编译，因为HLA将每个`NotTarget`实例视为一个唯一的符号。
- en: 'HLA does not automatically make internal macro symbol definitions local to
    that macro.^([[123](#ftn.CHP-9-FN-6)]) Instead, you must explicitly tell HLA which
    symbols must be local. You do this in a macro declaration using the following
    generic syntax:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 并不会自动使内部宏符号定义仅限于该宏^([[123](#ftn.CHP-9-FN-6)])。相反，你必须显式地告诉 HLA 哪些符号必须是局部的。你可以在宏声明中使用以下通用语法来实现这一点：
- en: '[PRE64]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The list of local names is a sequence of one or more HLA identifiers separated
    by commas. Whenever HLA encounters this name in a particular macro invocation,
    it automatically substitutes some unique name for that identifier. For each macro
    invocation, HLA substitutes a different name for the local symbol.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 局部名称列表是由一个或多个 HLA 标识符组成的序列，这些标识符通过逗号分隔。每当 HLA 在特定的宏调用中遇到这个名称时，它会自动为该标识符替换为一个唯一的名称。对于每个宏调用，HLA
    会为局部符号替换为一个不同的名称。
- en: 'You can correct the problem with the `JZC` macro by using the following macro
    code:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下宏代码修正 `JZC` 宏的问题：
- en: '[PRE65]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now whenever HLA processes this macro it will automatically associate a unique
    symbol with each occurrence of `NotTarget`. This will prevent the duplicate-symbol
    error that occurs if you do not declare `NotTarget` as a local symbol.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当 HLA 处理这个宏时，它将自动为每个 `NotTarget` 的出现关联一个唯一符号。这将防止如果你没有将 `NotTarget` 声明为局部符号时发生重复符号错误。
- en: HLA implements local symbols by substituting a symbol like `_`*`nnnn`*`_` (where
    *`nnnn`* is a four-digit hexadecimal number) wherever the local symbol appears
    in a macro invocation. For example, a macro invocation of the form `JZC(` *`SomeLabel`*
    `);` might expand to
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 通过在宏调用中出现局部符号的地方替换为类似 `_`*`nnnn`*`_`（其中 *`nnnn`* 是一个四位十六进制数字）的符号来实现局部符号。例如，形如
    `JZC(` *`SomeLabel`* `);` 的宏调用可能展开为：
- en: '[PRE66]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: For each local symbol appearing within a macro expansion, HLA will generate
    a unique temporary identifier by simply incrementing this numeric value for each
    new local symbol it needs. As long as you do not explicitly create labels of the
    form `_`*`nnnn`*`_`*`Text`*`_` (where *`nnnn`* is a hexadecimal value), there
    will never be a conflict in your program. HLA explicitly reserves all symbols
    that begin and end with a single underscore for its own private use (and for use
    by the HLA Standard Library). As long as you honor this restriction, there should
    be no conflicts between HLA local symbol generation and labels in your own programs
    because all HLA-generated symbols begin and end with a single underscore.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个在宏扩展中出现的局部符号，HLA 将通过简单地为每个新局部符号递增数字值来生成一个唯一的临时标识符。只要你不显式地创建形如 `_`*`nnnn`*`_`*`Text`*`_`（其中
    *`nnnn`* 是一个十六进制值）的标签，就不会在你的程序中发生冲突。HLA 明确保留所有以单个下划线开头和结尾的符号供其私用（并供 HLA 标准库使用）。只要你遵守这个限制，HLA
    局部符号生成和你自己程序中的标签之间就不会发生冲突，因为所有 HLA 生成的符号都以单个下划线开头和结尾。
- en: 'HLA implements local symbols by effectively converting that local symbol to
    a text constant that expands to the unique symbol HLA generates for the local
    label. That is, HLA effectively treats local symbol declarations as indicated
    by the following example:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 通过有效地将局部符号转换为文本常量来实现局部符号，这个文本常量扩展为 HLA 为局部标签生成的唯一符号。也就是说，HLA 实际上将局部符号声明当作以下示例所示的那样处理：
- en: '[PRE67]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Whenever HLA expands this macro it will substitute `_010A_`*`Text`*`_` for each
    occurrence of `NotTarget` it encounters in the expansion. This analogy isn't perfect
    because the text symbol `NotTarget` in this example is still accessible after
    the macro expansion, whereas this is not the case when defining local symbols
    within a macro. But this does give you an idea of how HLA implements local symbols.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 HLA 扩展这个宏时，它将用 `_010A_`*`Text`*`_` 来替换扩展过程中遇到的每个 `NotTarget`。这个类比并不完美，因为在这个例子中，文本符号
    `NotTarget` 在宏扩展后仍然可访问，而在宏内定义局部符号时则不是这种情况。但这给你一个关于 HLA 如何实现局部符号的概念。
- en: 9.8.4 Macros as Compile-Time Procedures
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8.4 宏作为编译时过程
- en: Although programmers typically use macros to expand to some sequence of machine
    instructions, there is absolutely no requirement that a macro body contain any
    executable instructions. Indeed, many macros contain only compile-time language
    statements (for example, `#if`, `#while`, `#for`, `?` assignments, and the like).
    By placing only compile-time language statements in the body of a macro, you can
    effectively write compile-time procedures and functions using macros.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管程序员通常使用宏来扩展为一系列机器指令，但宏体中绝对没有要求必须包含任何可执行指令。实际上，许多宏仅包含编译时语言语句（例如，`#if`、`#while`、`#for`、`?`赋值语句等）。通过仅在宏体中放置编译时语言语句，您可以有效地使用宏编写编译时的过程和函数。
- en: 'The following `unique` macro is a good example of a compile-time function that
    returns a string result. Consider the definition of this macro:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`unique`宏是一个很好的示例，它是一个返回字符串结果的编译时函数。考虑以下宏的定义：
- en: '[PRE68]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Whenever your code references this macro, HLA replaces the macro invocation
    with the text `@string(theSym)`, which, of course, expands to some string like
    `_021F_`*`Text`*`_.` Therefore, you can think of this macro as a compile-time
    function that returns a string result.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您的代码引用此宏时，HLA会将宏调用替换为文本`@string(theSym)`，这当然会展开为类似于`_021F_`*`Text`*`_`这样的字符串。因此，您可以将这个宏视为一个返回字符串结果的编译时函数。
- en: Be careful that you don't take the function analogy too far. Remember, macros
    always expand to their body text at the point of invocation. Some expansions may
    not be legal at any arbitrary point in your programs. Fortunately, most compile-time
    statements are legal anywhere whitespace is legal in your programs. Therefore,
    macros behave as you would expect functions or procedures to behave during the
    execution of your compile-time programs.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要把函数类比推得太远。请记住，宏总是在调用点展开为其宏体文本。某些扩展可能在程序的任何任意位置都是不合法的。幸运的是，大多数编译时语句在程序中任何合法的空白位置都是合法的。因此，宏的行为与您在编译时程序执行过程中对函数或过程的预期行为一致。
- en: Of course, the only difference between a procedure and a function is that a
    function returns some explicit value, while procedures simply do some activity.
    There is no special syntax for specifying a compile-time function return value.
    As the example above indicates, simply specifying the value you wish to return
    as a statement in the macro body suffices. A compile-time procedure, on the other
    hand, would not contain any non-compile-time language statements that expand into
    some sort of data during macro invocation.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，过程和函数之间的唯一区别是，函数返回某个显式值，而过程仅执行某些活动。对于编译时函数的返回值，没有特殊的语法来指定。如上面的示例所示，只需将希望返回的值作为宏体中的一条语句指定即可。另一方面，编译时过程将不包含任何非编译时语言语句，这些语句在宏调用时会展开成某种数据。
- en: 9.8.5 Simulating Function Overloading with Macros
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8.5 使用宏模拟函数重载
- en: The C++ language supports a nifty feature known as *function overloading*. Function
    overloading lets you write several different functions or procedures that all
    have the same name. The difference between these functions is the types of their
    parameters or the number of parameters. A procedure declaration is unique in C++
    if it has a different number of parameters than other functions with the same
    name or if the types of its parameters differ from other functions with the same
    name. HLA does not directly support procedure overloading, but you can use macros
    to achieve the same result. This section explains how to use HLA's macros and
    the compile-time language to achieve function/procedure overloading.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言支持一个巧妙的特性，称为*函数重载*。函数重载允许您编写多个具有相同名称的不同函数或过程。这些函数的区别在于其参数的类型或参数的数量。如果一个过程声明与其他同名函数的参数数量不同，或者其参数类型与其他同名函数不同，那么它就是C++中的独特声明。HLA并不直接支持过程重载，但您可以使用宏来实现相同的结果。本节将解释如何使用HLA的宏和编译时语言来实现函数/过程重载。
- en: 'One good use for procedure overloading is to reduce the number of Standard
    Library routines you must remember how to use. For example, the HLA Standard Library
    provides five different "puti" routines that output an integer value: `stdout.puti128`,
    `stdout.puti64`, `stdout.puti32`, `stdout.puti16`, and `stdout.puti8`. The different
    routines, as their names suggest, output integer values according to the size
    of their integer parameter. In the C++ language (or another other language supporting
    procedure/function overloading) the engineer designing the input routines would
    probably have chosen to name them all `stdout.puti` and leave it up to the compiler
    to select the appropriate one based on the operand size.^([[124](#ftn.CHP-9-FN-7)])
    The macro in [Example 9-5](ch09s08.html#simple_procedure_overloading_based_on_op
    "Example 9-5. Simple procedure overloading based on operand size") demonstrates
    how to do this in HLA using the compile-time language to figure out the size of
    the parameter operand.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 程序重载的一个好处是可以减少你需要记住的标准库例程的数量。例如，HLA标准库提供了五个不同的“puti”例程来输出整数值：`stdout.puti128`、`stdout.puti64`、`stdout.puti32`、`stdout.puti16`
    和 `stdout.puti8`。这些不同的例程，正如它们的名称所示，根据整数参数的大小输出整数值。在C++语言（或其他支持过程/函数重载的语言）中，设计输入例程的工程师可能会选择将它们都命名为`stdout.puti`，并让编译器根据操作数的大小选择合适的例程。^([[124](#ftn.CHP-9-FN-7)])
    在[示例 9-5](ch09s08.html#simple_procedure_overloading_based_on_op "示例 9-5. 基于操作数大小的简单过程重载")中，宏演示了如何在HLA中使用编译时语言来确定参数操作数的大小。
- en: Example 9-5. Simple procedure overloading based on operand size
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-5. 基于操作数大小的简单过程重载
- en: '[PRE69]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The example above simply tests the size of the operand to determine which output
    routine to use. You can use other HLA compile-time functions, such as `@typename`,
    to do more sophisticated processing. Consider the program in [Example 9-6](ch09s08.html#procedure_overloading_based_on_operand_t
    "Example 9-6. Procedure overloading based on operand type"), which demonstrates
    a macro that overloads `stdout.puti32`, `stdout.putu32`, and `stdout.putd` depending
    on the type of the operand.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子只是通过测试操作数的大小来确定使用哪个输出例程。你还可以使用其他HLA编译时函数，如`@typename`，进行更复杂的处理。考虑[示例 9-6](ch09s08.html#procedure_overloading_based_on_operand_t
    "示例 9-6. 基于操作数类型的过程重载")中的程序，该程序演示了一个宏，它根据操作数的类型重载`stdout.puti32`、`stdout.putu32`和`stdout.putd`。
- en: Example 9-6. Procedure overloading based on operand type
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-6. 基于操作数类型的过程重载
- en: '[PRE70]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You can easily extend this macro to output 8- and 16-bit operands as well as
    32-bit operands. That is left as an exercise for the reader.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松扩展这个宏，以输出8位和16位的操作数以及32位的操作数。这个作为练习留给读者。
- en: The number of actual parameters is another way to resolve which overloaded procedure
    to call. If you specify a variable number of macro parameters (using the `[ ]`
    syntax; see the discussion in [9.8.2.2 Macros with a Variable Number of Parameters](ch09s08.html#macros_with_a_variable_number_of_paramet
    "9.8.2.2 Macros with a Variable Number of Parameters")), you can use the `@elements`
    compile-time function to determine exactly how many parameters are present and
    call the appropriate routine. The sample in [Example 9-7](ch09s08.html#using_the_number_of_parameters_to_resolv
    "Example 9-7. Using the number of parameters to resolve overloaded procedures")
    uses this trick to determine whether it should call `stdout.puti32` or `stdout.puti32Size`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 实际参数的数量是解决调用哪个重载过程的另一种方式。如果你指定了一个可变数量的宏参数（使用`[ ]`语法；详见[9.8.2.2 可变参数宏](ch09s08.html#macros_with_a_variable_number_of_paramet
    "9.8.2.2 可变参数宏")），你可以使用`@elements`编译时函数来确定到底有多少个参数，并调用适当的例程。[示例 9-7](ch09s08.html#using_the_number_of_parameters_to_resolv
    "示例 9-7. 使用参数数量解决重载过程")中的示例使用了这个技巧来确定是否应该调用`stdout.puti32`或`stdout.puti32Size`。
- en: Example 9-7. Using the number of parameters to resolve overloaded procedures
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-7. 使用参数数量解决重载过程
- en: '[PRE71]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: All the examples up to this point provide procedure overloading for Standard
    Library routines (specifically, the integer output routines). Of course, you are
    not limited to overloading procedures in the HLA Standard Library. You can create
    your own overloaded procedures as well. All you have to do is write a set of procedures,
    all with unique names, and then use a single macro to decide which routine to
    actually call based on the macro's parameters. Rather than call the individual
    routines, invoke the common macro and let it decide which procedure to actually
    call.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有示例都提供了标准库例程的过程重载（特别是整数输出例程）。当然，你并不限于在 HLA 标准库中进行过程重载，你也可以创建自己的重载过程。你需要做的就是编写一组具有唯一名称的过程，然后使用一个宏来根据宏的参数决定实际调用哪个例程。与其调用各个例程，不如调用公共宏，让它决定实际调用哪个过程。
- en: '* * *'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[122](#CHP-9-FN-5)]) To differentiate between macros and procedures, this
    text will use the term *invocation* when describing the use of a macro and *call*
    when describing the use of a procedure.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[122](#CHP-9-FN-5)]) 为了区分宏和过程，本书将在描述宏的使用时使用*调用*（invocation）一词，而描述过程的使用时则使用*调用*（call）一词。
- en: ^([[123](#CHP-9-FN-6)]) Sometimes you actually want the symbols to be global.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[123](#CHP-9-FN-6)]) 有时你实际上希望这些符号是全局的。
- en: ^([[124](#CHP-9-FN-7)]) By the way, the HLA Standard Library does this as well.
    Although it doesn't provide `stdout.puti`, it does provide `stdout.put`, which
    will choose an appropriate output routine based upon the parameter's type. This
    is a bit more flexible than a `puti` routine.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[124](#CHP-9-FN-7)]) 顺便说一句，HLA 标准库也这样做。尽管它没有提供 `stdout.puti`，但它提供了 `stdout.put`，该例程会根据参数的类型选择适当的输出例程。这比
    `puti` 例程更灵活。
- en: 9.9 Writing Compile-Time "Programs"
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.9 编写编译时“程序”
- en: The HLA compile-time language provides a powerful facility with which to write
    "programs" that execute while HLA is compiling your assembly language programs.
    Although it is possible to write some general-purpose programs using the HLA compile-time
    language, the real purpose of the HLA compile-time language is to allow you to
    write short programs *that write other programs*. In particular, the primary purpose
    of the HLA compile-time language is to automate the creation of large or complex
    assembly language sequences. The following subsections provide some simple examples
    of such compile-time programs.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 编译时语言提供了一个强大的功能，可以在 HLA 编译汇编语言程序时编写执行的“程序”。虽然使用 HLA 编译时语言编写一些通用程序是可能的，但
    HLA 编译时语言的真正目的是允许你编写短小的程序，*这些程序用于编写其他程序*。特别地，HLA 编译时语言的主要目的是自动化生成大型或复杂的汇编语言序列。以下小节提供了一些简单的编译时程序示例。
- en: 9.9.1 Constructing Data Tables at Compile Time
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9.1 在编译时构建数据表
- en: Earlier, this book suggested that you could write programs to generate large,
    complex lookup tables for your assembly language programs (see the discussion
    of tables in [8.4.3 Generating Tables](ch08s04.html#generating_tables "8.4.3 Generating
    Tables")). [Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC") provides examples
    in HLA but suggests that writing a separate program is unnecessary. This is true;
    you can generate most lookup tables you'll need using nothing more than the HLA
    compile-time language facilities. Indeed, filling in table entries is one of the
    principle uses of the HLA compile-time language. In this section we will take
    a look at using the HLA compile-time language to construct data tables during
    compilation.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 本书之前建议你可以编写程序为你的汇编语言程序生成大型、复杂的查找表（见[8.4.3 生成表格](ch08s04.html#generating_tables
    "8.4.3 生成表格")的讨论）。[第 8 章](ch08.html "第 8 章：高级算术")提供了 HLA 中的示例，但也建议编写一个独立程序并非必要。这是对的；你可以仅使用
    HLA 编译时语言功能生成大多数所需的查找表。事实上，填充表格条目是 HLA 编译时语言的主要用途之一。本节将介绍如何在编译过程中使用 HLA 编译时语言构建数据表。
- en: In [8.4.3 Generating Tables](ch08s04.html#generating_tables "8.4.3 Generating
    Tables"), you saw an example of an HLA program that writes a text file containing
    a lookup table for the trigonometric sine function. The table contains 360 entries
    with the index into the table specifying an angle in degrees. Each `int32` entry
    in the table contains the value sin(*angle* )*1,000 where *angle* is equal to
    the index into the table. [8.4.3 Generating Tables](ch08s04.html#generating_tables
    "8.4.3 Generating Tables") suggests running this program and then including the
    text output from that program into the actual program that used the resulting
    table. You can avoid much of this work by using the compile-time language. The
    HLA program in [Example 9-8](ch09s09.html#generating_a_sine_lookup_table_with_the
    "Example 9-8. Generating a sine lookup table with the compile-time language")
    includes a short compile-time code fragment that constructs this table of sines
    directly.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在[8.4.3 生成表格](ch08s04.html#generating_tables "8.4.3 生成表格")中，你看到过一个HLA程序的示例，该程序生成一个包含三角正弦函数查找表的文本文件。该表包含360个条目，表中的索引指定一个角度（以度为单位）。表中的每个`int32`条目包含值sin(*angle*)*1,000，其中*angle*等于表中的索引。[8.4.3
    生成表格](ch08s04.html#generating_tables "8.4.3 生成表格")建议运行该程序，然后将程序生成的文本输出包含到实际使用该表的程序中。你可以通过使用编译时语言避免大部分这项工作。[示例
    9-8](ch09s09.html#generating_a_sine_lookup_table_with_the "示例 9-8。使用编译时语言生成正弦查找表")中的HLA程序包含了一段简短的编译时代码，直接构造了这个正弦表。
- en: Example 9-8. Generating a sine lookup table with the compile-time language
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-8。使用编译时语言生成正弦查找表
- en: '[PRE72]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Another common use for the compile-time language is to build ASCII character
    lookup tables for use by the `xlat` instruction at runtime. Common examples include
    lookup tables for alphabetic case manipulation. The program in [Example 9-9](ch09s09.html#generating_case-conversion_tables_with_t
    "Example 9-9. Generating case-conversion tables with the compile-time language")
    demonstrates how to construct an uppercase conversion table and a lowercase conversion
    table.^([[125](#ftn.CHP-9-FN-8)]) Note the use of a macro as a compile-time procedure
    to reduce the complexity of the table-generating code:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时语言的另一个常见用途是为`xlat`指令在运行时生成ASCII字符查找表。常见的例子包括用于字母大小写转换的查找表。[示例 9-9](ch09s09.html#generating_case-conversion_tables_with_t
    "示例 9-9。使用编译时语言生成大小写转换表")中的程序展示了如何构造大写转换表和小写转换表。^([[125](#ftn.CHP-9-FN-8)]) 注意这里使用宏作为编译时过程来简化表生成代码的复杂度：
- en: Example 9-9. Generating case-conversion tables with the compile-time language
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-9。使用编译时语言生成大小写转换表
- en: '[PRE73]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: One important thing to note about this example is the fact that a semicolon
    does not follow the `emitCharRange` macro invocations. Macro invocations do not
    require a closing semicolon. Often, it is legal to go ahead and add one to the
    end of the macro invocation because HLA is normally very forgiving about having
    extra semicolons inserted into the code. In this case, however, the extra semicolons
    are illegal because they would appear between adjacent entries in the `TOlc` and
    `toUC` tables. Keep in mind that macro invocations don't require a semicolon,
    especially when using macro invocations as compile-time procedures.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中需要注意的一点是，`emitCharRange`宏调用后并没有跟随分号。宏调用不需要闭合的分号。通常情况下，往宏调用的末尾加一个分号是合法的，因为HLA通常对于代码中多余的分号是比较宽容的。然而，在这个例子中，多余的分号是非法的，因为它们会出现在`TOlc`和`toUC`表的相邻条目之间。请记住，宏调用不需要分号，尤其是在将宏调用用作编译时过程时。
- en: 9.9.2 Unrolling Loops
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9.2 展开循环
- en: In the chapter on low-level control structures, this text points out that you
    can unravel loops to improve the performance of certain assembly language programs.
    One problem with unraveling, or unrolling, loops is that you may need to do a
    lot of extra typing, especially if there are many loop iterations. Fortunately,
    HLA's compile-time language facilities, especially the `#while` and `#for` loops,
    come to the rescue. With a small amount of extra typing plus one copy of the loop
    body, you can unroll a loop as many times as you please.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在低级控制结构章节中，本文指出你可以通过展开循环来提高某些汇编语言程序的性能。展开循环的问题之一是，你可能需要做很多额外的输入，尤其是当循环迭代次数很多时。幸运的是，HLA的编译时语言功能，特别是`#while`和`#for`循环，能够提供帮助。只需稍加输入并加上一份循环体，你就可以根据需要展开循环多次。
- en: If you simply want to repeat the same exact code sequence some number of times,
    unrolling the code is especially trivial. All you have to do is wrap an HLA `#for..#endfor`
    loop around the sequence and count off a `val` object the specified number of
    times. For example, if you wanted to print `Hello World` 10 times, you could encode
    this as follows.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想将相同的代码序列重复执行若干次，展开代码尤其简单。你只需将一个HLA `#for..#endfor` 循环包裹在序列周围，并计数 `val`
    对象指定的次数。例如，如果你想打印`Hello World` 10次，可以按如下方式编码：
- en: '[PRE74]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Although the code above looks very similar to an HLA `for` loop you could write
    in your program, remember the fundamental difference: The preceding code simply
    consists of 10 straight `stdout.put` calls in the program. Were you to encode
    this using an HLA `for` loop, there would be only one call to `stdout.put` and
    lots of additional logic to loop back and execute that single call 10 times.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上面的代码看起来和你在程序中编写的HLA `for` 循环非常相似，但请记住其根本区别：前面的代码只是由10个直接的 `stdout.put` 调用组成。如果你用HLA
    `for` 循环来编码，这里只会有一个 `stdout.put` 调用，而会有很多额外的逻辑来循环回去并执行该调用10次。
- en: 'Unrolling loops becomes slightly more complicated if any instructions in that
    loop refer to the value of a loop control variable or another value, which changes
    with each iteration of the loop. A typical example is a loop that zeros the elements
    of an integer array:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环中的任何指令引用了循环控制变量的值或其他随着每次迭代而变化的值，展开循环将变得稍微复杂一些。一个典型的例子是将整数数组元素置零的循环：
- en: '[PRE75]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In this code fragment the loop uses the value of the loop control variable
    (in EBX) to index into array. Simply copying `mov( eax, array[ ebx*4 ]);` 20 times
    is not the proper way to unroll this loop. You must substitute an appropriate
    constant index in the range 0..76 (the corresponding loop indices, times 4) in
    place of `ebx*4` in this example. Correctly unrolling this loop should produce
    the following code sequence:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，循环使用了循环控制变量（在EBX中）的值来索引数组。简单地将 `mov( eax, array[ ebx*4 ]);` 复制20次并不是展开这个循环的正确方式。你必须将一个合适的常量索引（范围为0..76，即对应的循环索引，乘以4）代替示例中的
    `ebx*4`。正确展开该循环应该生成以下代码序列：
- en: '[PRE76]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can easily do this using the following compile-time code sequence:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下编译时代码序列轻松实现这一点：
- en: '[PRE77]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If the statements in a loop make use of the loop control variable's value, it
    is only possible to unroll such loops if those values are known at compile-time.
    You cannot unroll loops when user input (or other runtime information) controls
    the number of iterations.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果循环中的语句利用了循环控制变量的值，那么只有在这些值在编译时已知的情况下，才有可能展开这样的循环。当用户输入（或其他运行时信息）控制循环迭代次数时，无法展开循环。
- en: '* * *'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[125](#CHP-9-FN-8)]) Note that on modern processors, using a lookup table
    is probably not the most efficient way to convert between alphabetic cases. However,
    this is just an example of filling in the table using the compile-time language.
    The principles are correct, even if the code is not exactly the best it could
    be.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[125](#CHP-9-FN-8)]) 请注意，在现代处理器上，使用查找表可能不是将字母大小写转换的最有效方式。不过，这只是一个使用编译时语言填充表格的示例。即使代码不是最优的，原理依然是正确的。
- en: 9.10 Using Macros in Different Source Files
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.10 在不同源文件中使用宏
- en: 'Unlike procedures, macros do not have a fixed piece of code at some address
    in memory. Therefore, you cannot create external macros and link them with other
    modules in your program. However, it is very easy to share macros with different
    source files: Just put the macros you wish to reuse in a header file and include
    that file using the `#include` directive. You can make the macro available to
    any source file you choose using this simple trick.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 与过程不同，宏在内存中的某个地址没有固定的代码片段。因此，你不能创建外部宏并将其与程序中的其他模块链接。然而，分享宏与不同源文件之间非常容易：只需将你希望重用的宏放在一个头文件中，并使用
    `#include` 指令包含该文件。你可以通过这个简单的方法将宏提供给你选择的任何源文件。
- en: 9.11 For More Information
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.11 更多信息
- en: Although this chapter has spent a considerable amount of time describing various
    features of HLA's macro support and compile-time language features, the truth
    is this chapter has barely described what's possible with HLA. Indeed, this chapter
    made the claim that HLA's macro facilities are far more powerful than those provided
    by other assemblers; however, this chapter doesn't do HLA's macros justice. If
    you've ever used a language with decent macro facilities, you're probably wondering,
    "What's the big deal?" Well, the really sophisticated stuff is beyond the scope
    of this chapter. If you're interested in learning more about HLA's powerful macro
    facilities, please consult the HLA reference manual and the electronic editions
    of *The Art of Assembly Language* at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/). You'll discover that
    it's actually possible to create your own high-level languages using HLA's macro
    facilities. However, this chapter does not assume the reader has the prerequisite
    knowledge to do that type of programming (yet!), so this chapter defers that discussion
    to the material that you'll also find on the websites.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章花费了相当多的时间描述HLA的宏支持和编译时语言特性，事实上，本章几乎没有描述HLA的所有可能性。实际上，本章声称HLA的宏功能比其他汇编器提供的要强大得多；然而，本章并没有充分展现HLA的宏能力。如果你曾经使用过具有良好宏功能的语言，你可能会想：“这有什么大不了的？”其实，真正复杂的内容超出了本章的范围。如果你有兴趣了解更多HLA强大的宏功能，请查阅HLA参考手册以及《*汇编语言的艺术*》的电子版，网址是[http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)或[http://www.artofasm.com/](http://www.artofasm.com/)。你会发现，实际上可以使用HLA的宏功能创建你自己的高级语言。然而，本章并没有假设读者具备进行这类编程的先决知识（至少目前还没有！），因此本章将这部分内容留待在网站上找到的相关资料中讨论。
