- en: Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 宏与HLA编译时语言
- en: '![MACROS AND THE HLA COMPILE-TIME LANGUAGE](tagoreillycom20100401nostarchimages577853.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![宏与HLA编译时语言](tagoreillycom20100401nostarchimages577853.png.jpg)'
- en: This chapter discusses the HLA compile-time language. This discussion includes
    what is perhaps the most important component of the HLA compile-time language,
    *macros*. Many people judge the power of an assembler by the power of its macro
    processing capabilities. If you happen to be one of these people, you'll probably
    agree that HLA is one of the more powerful assemblers on the planet after reading
    this chapter, because HLA has one of the most powerful macro processing facilities
    of any computer language processing system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了HLA编译时语言。讨论的内容包括HLA编译时语言中最重要的组成部分之一——*宏*。许多人通过汇编器的宏处理能力来判断其强大程度。如果你恰好是这些人之一，那么在阅读完本章之后，你可能会同意HLA是地球上最强大的汇编器之一，因为HLA拥有任何计算机语言处理系统中最强大的宏处理功能之一。
- en: 9.1 Introduction to the Compile-Time Language (CTL)
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 编译时语言（CTL）简介
- en: HLA is actually two languages rolled into a single program. The *runtime language*
    is the standard 80x86/HLA assembly language you've been reading about in all the
    previous chapters. This is called the runtime language because the programs you
    write execute when you run the executable file. HLA contains an interpreter for
    a second language, the HLA compile-time language (CTL), which executes programs
    while HLA is compiling a program. The source code for the CTL program is embedded
    in an HLA assembly language source file; that is, HLA source files contain instructions
    for both the HLA CTL and the runtime program. HLA executes the CTL program during
    compilation. Once HLA completes compilation, the CTL program terminates; the CTL
    application is not a part of the runtime executable that HLA emits, although the
    CTL application can *write* part of the runtime program for you, and, in fact,
    this is the major purpose of the CTL (see [Figure 9-1](ch09.html#compile-time_versus_runtime_execution
    "Figure 9-1. Compile-time versus runtime execution")).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: HLA实际上是将两种语言合并到一个程序中。*运行时语言*是你在前面所有章节中阅读过的标准80x86/HLA汇编语言。这被称为运行时语言，因为你编写的程序在你运行可执行文件时执行。HLA包含了第二种语言的解释器——HLA编译时语言（CTL），它在HLA编译程序时执行程序。CTL程序的源代码嵌入在HLA汇编语言源文件中；也就是说，HLA源文件包含了HLA
    CTL和运行时程序的指令。HLA在编译过程中执行CTL程序。HLA完成编译后，CTL程序终止；CTL应用程序不是HLA生成的运行时可执行文件的一部分，尽管CTL应用程序可以*为你写*部分运行时程序，实际上，CTL的主要目的就是这个（见[图9-1](ch09.html#compile-time_versus_runtime_execution
    "图9-1. 编译时执行与运行时执行")）。
- en: '![Compile-time versus runtime execution](tagoreillycom20100401nostarchimages578063.png.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![编译时执行与运行时执行](tagoreillycom20100401nostarchimages578063.png.jpg)'
- en: Figure 9-1. Compile-time versus runtime execution
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1. 编译时执行与运行时执行
- en: 'It may seem confusing to have two separate languages built into the same compiler.
    Perhaps you''re even questioning why anyone would need a compile-time language.
    To understand the benefits of a compile-time language, consider the following
    statement that you should be very comfortable with at this point:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个编译器中内置两个独立的语言可能会让人感到困惑。也许你甚至在质疑，为什么需要编译时语言。为了理解编译时语言的好处，请考虑以下你现在应该非常熟悉的陈述：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This statement is neither a statement in the HLA language nor a call to some
    HLA Standard Library procedure. Instead, `stdout.put` is actually a statement
    in a CTL application provided by the HLA Standard Library. The `stdout.put` "application"
    processes the parameter list and generates calls to various other Standard Library
    procedures; it chooses the procedure to call based on the type of the parameter
    it is currently processing. For example, the `stdout.put` "application" above
    will emit the following statements to the runtime executable:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这条陈述既不是HLA语言中的一条语句，也不是对某个HLA标准库过程的调用。实际上，`stdout.put`是HLA标准库提供的CTL应用程序中的一条语句。`stdout.put`
    "应用程序"处理参数列表，并生成对其他标准库过程的调用；它根据当前处理的参数类型选择要调用的过程。例如，上述`stdout.put` "应用程序"将向运行时可执行文件输出以下语句：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Clearly the `stdout.put` statement is much easier to read and write than the
    sequence of statements that `stdout.put` emits in response to its parameter list.
    This is one of the more powerful capabilities of the HLA programming language:
    the ability to modify the language to simplify common programming tasks. Printing
    different data objects in a sequential fashion is a common task; the `stdout.put`
    "application" greatly simplifies this process.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`stdout.put` 语句比 `stdout.put` 为其参数列表发出的语句序列更容易阅读和编写。这是 HLA 编程语言更强大的功能之一：能够修改语言以简化常见的编程任务。按顺序打印不同数据对象是一个常见任务；`stdout.put`
    “应用”极大简化了这一过程。
- en: The HLA Standard Library is *loaded* with many HLA CTL examples. In addition
    to Standard Library usage, the HLA CTL is quite adept at handling "one-use" applications.
    A classic example is filling in the data for a lookup table. [Chapter 8](ch08.html
    "Chapter 8. ADVANCED ARITHMETIC") noted that it is possible to construct lookup
    tables using the HLA CTL. Not only is this possible, but it is often far less
    work to use the HLA CTL to construct these tables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 标准库中*充满了*许多 HLA CTL 示例。除了标准库的使用，HLA CTL 在处理“一次性”应用程序时也非常擅长。一个经典的例子是填充查找表的数据。[第8章](ch08.html
    "第8章. 高级算术")提到，使用 HLA CTL 构建查找表是可行的。不仅如此，使用 HLA CTL 构建这些表往往比其他方法省时省力。
- en: Although the CTL itself is relatively inefficient and you would not normally
    use it to write end-user applications, it does maximize the use of your time.
    By learning how to use the HLA CTL and applying it properly, you can develop assembly
    language applications as rapidly as high-level language applications (even faster
    because HLA's CTL lets you create very high-level-language constructs).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CTL 本身相对低效，通常不用于编写最终用户应用程序，但它最大化了你时间的使用。通过学习如何使用 HLA CTL 并正确应用它，你可以像开发高级语言应用程序一样快速开发汇编语言应用程序（甚至更快，因为
    HLA 的 CTL 允许你创建非常高级语言的构造）。
- en: '9.2 The #print and #error Statements'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 `#print` 和 `#error` 语句
- en: You may recall that [Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF ASSEMBLY
    LANGUAGE") began with the typical first program most people write when learning
    a new language, the "Hello, world!" program. It is only fitting for this chapter
    to present that same program when discussing the second language of this book.
    [Example 9-1](ch09s02.html#the_ctl_quotation_mark_hello_comma_world "Example 9-1. The
    CTL "Hello, world!" program") provides the basic "Hello, world!" program written
    in the HLA compile-time language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，[第1章](ch01.html "第1章. HELLO，世界汇编语言")以大多数人在学习新语言时编写的典型第一个程序——“Hello, world!”程序开始。当讨论本书的第二种语言时，呈现这个程序是非常合适的。[示例
    9-1](ch09s02.html#the_ctl_quotation_mark_hello_comma_world "示例 9-1. CTL “Hello,
    world!”程序")提供了用 HLA 编译时语言编写的基本“Hello, world!”程序。
- en: Example 9-1. The CTL "Hello, world!" program
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-1. CTL “Hello, world!”程序
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only CTL statement in this program is the `#print` statement. The remaining
    lines are needed just to keep the compiler happy (though we could have reduced
    the overhead to two lines by using a `unit` rather than a `program` declaration).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序中的唯一 CTL 语句是 `#print` 语句。其余的行仅仅是为了让编译器正常工作（尽管我们可以通过使用 `unit` 声明而非 `program`
    声明，将开销减少到两行）。
- en: 'The `#print` statement displays the textual representation of its argument
    list during the compilation of an HLA program. Therefore, if you compile the program
    above with the command `hla ctlHW.hla`, the HLA compiler will immediately print
    the text:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`#print` 语句在编译 HLA 程序时会显示其参数列表的文本表示。因此，如果你使用命令 `hla ctlHW.hla` 编译上面的程序，HLA
    编译器将立即打印出以下文本：'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that there is a big difference between the following two statements in
    an HLA source file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 HLA 源文件中，以下两个语句之间有很大的区别：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first statement prints `Hello World` (and a new line) during the compilation
    process. This first statement does not have any effect on the executable program.
    The second line doesn't affect the compilation process (other than the emission
    of code to the executable file). However, when you run the executable file, the
    second statement prints the string `Hello World` followed by a newline sequence.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句在编译过程中打印出 `Hello World`（并添加一个换行符）。这个第一个语句对可执行程序没有任何影响。第二行则不影响编译过程（除了向可执行文件发出代码）。然而，当你运行可执行文件时，第二个语句会打印出字符串
    `Hello World`，后跟一个换行符。
- en: 'The HLA/CTL `#print` statement uses the following basic syntax:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: HLA/CTL `#print` 语句使用以下基本语法：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that a semicolon does not terminate this statement. Semicolons terminate
    runtime statements; they generally do not terminate compile-time statements (there
    is one big exception, as you will see a little later).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，分号并不会终止此语句。分号终止的是运行时语句；通常不会终止编译时语句（有一个例外，稍后你会看到）。
- en: 'The `#print` statement must have at least one operand; if multiple operands
    appear in the parameter list, you must separate each operand with a comma ( just
    like `stdout.put`). If a particular operand is not a string constant, HLA will
    translate that constant to its corresponding string representation and print that
    string. Here''s an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`#print`语句必须至少有一个操作数；如果参数列表中有多个操作数，你必须用逗号分隔每个操作数（就像`stdout.put`一样）。如果某个操作数不是字符串常量，HLA会将该常量转换为相应的字符串表示并打印该字符串。下面是一个示例：'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You may specify named symbolic constants and constant expressions. However,
    all `#print` operands must be constants (either literal constants or constants
    you define in the `const` or `val` sections), and those constants must be defined
    before you use them in the `#print` statement. For example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定命名的符号常量和常量表达式。然而，所有的`#print`操作数必须是常量（无论是字面常量还是你在`const`或`val`部分定义的常量），这些常量必须在你使用它们的`#print`语句之前定义。例如：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The HLA `#print` statement is particularly invaluable for debugging CTL programs.
    This statement is also useful for displaying the progress of the compilation and
    displaying assumptions and default actions that take place during compilation.
    Other than displaying the text associated with the `#print` parameter list, the
    `#print` statement has no effect on the compilation of the program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: HLA的`#print`语句对于调试CTL程序特别有价值。这个语句还用于显示编译进度，展示编译过程中发生的假设和默认操作。除了显示与`#print`参数列表相关的文本外，`#print`语句对程序的编译没有其他影响。
- en: 'The `#error` statement allows a single-string constant operand. Like `#print`,
    this statement will display the string to the console during compilation. However,
    the `#error` statement treats the string as an error message and displays the
    string as part of an HLA error diagnostic. Further, the `#error` statement increments
    the error count, and this will cause HLA to stop the compilation (without assembling
    or linking) after processing the current source file. You would normally use the
    `#error` statement to display an error message during compilation if your CTL
    code discovers something that prevents it from creating valid code. For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`#error`语句允许一个单一的字符串常量操作数。和`#print`一样，这个语句会在编译时将字符串显示到控制台。然而，`#error`语句将该字符串视为错误信息，并作为HLA错误诊断的一部分显示该字符串。此外，`#error`语句会增加错误计数，这将导致HLA在处理完当前源文件后停止编译（不会汇编或链接）。通常，当你的CTL代码发现某些问题，无法生成有效代码时，你会使用`#error`语句在编译期间显示错误信息。例如：'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Like the `#print` statement, the `#error` statement does not end with a semicolon.
    Although `#error` allows only a single-string operand, it's very easy to print
    other values by using the compile-time string concatenation operator and several
    of the HLA built-in compile-time functions. You'll learn about these a little
    later in this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 和`#print`语句一样，`#error`语句也不以分号结尾。虽然`#error`只允许一个单一的字符串操作数，但通过使用编译时字符串连接操作符和几个HLA内建的编译时函数，你可以很容易地打印其他值。你将在本章稍后部分了解这些内容。
- en: 9.3 Compile-Time Constants and Variables
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 编译时常量和变量
- en: Just as the runtime language does, the compile-time language supports constants
    and variables. You declare compile-time constants in the `const` section, just
    as you would with the runtime language. You declare compile-time variables in
    the `val` section. Objects you declare in the `val` section are constants to the
    runtime language, but remember that you can change the value of an object you
    declare in the `val` section throughout the source file. Hence the term "compile-time
    variable." See [Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES, AND DATA
    TYPES") for more details.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像运行时语言一样，编译时语言也支持常量和变量。你可以像在运行时语言中一样在`const`部分声明编译时常量。在`val`部分声明编译时变量。你在`val`部分声明的对象对运行时语言来说是常量，但记住，你可以在整个源文件中改变你在`val`部分声明的对象的值。因此，称之为“编译时变量”。有关详细信息，请参见[第4章](ch04.html
    "第4章 常量、变量和数据类型")。
- en: The CTL assignment statement (`?`) computes the value of the constant expression
    to the right of the assignment operator (`:=`) and stores the result into the
    `val` object name appearing immediately to the left of the assignment operator.^([[118](#ftn.CHP-9-FN-1)])
    This example code may appear anywhere in your HLA source file, not just in the
    `val` section of the program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: CTL 赋值语句（`?`）计算赋值运算符（`:=`）右侧常量表达式的值，并将结果存储到赋值运算符左侧紧接的 `val` 对象名中。^([[118](#ftn.CHP-9-FN-1)])
    这个示例代码可以出现在 HLA 源文件的任何位置，而不仅仅是程序的 `val` 部分。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '* * *'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[118](#CHP-9-FN-1)]) If the identifier to the left of the assignment operator
    is undefined, HLA will automatically declare this object at the current scope
    level.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[118](#CHP-9-FN-1)]) 如果赋值运算符左侧的标识符未定义，HLA 将自动在当前作用域级别声明该对象。
- en: 9.4 Compile-Time Expressions and Operators
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.4 编译时表达式和运算符
- en: The HLA CTL supports constant expressions in the CTL assignment statement. Unlike
    the runtime language (where you have to translate algebraic notation into a sequence
    of machine instructions), the HLA CTL allows a full set of arithmetic operations
    using familiar expression syntax. This gives the HLA CTL considerable power, especially
    when combined with the built-in compile-time functions the next section discusses.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: HLA CTL 支持在 CTL 赋值语句中使用常量表达式。与运行时语言不同（在运行时，你需要将代数符号转换为一系列机器指令），HLA CTL 允许使用熟悉的表达式语法进行完整的算术运算。这使得
    HLA CTL 在编译时表达式中具有相当大的能力，尤其是当与下一节讨论的内置编译时函数结合使用时。
- en: '[Table 9-1](ch09s04.html#compile-time_operators "Table 9-1. Compile-Time Operators")
    and [Table 9-2](ch09s04.html#operator_precedence_and_associativity "Table 9-2. Operator
    Precedence and Associativity") list operators that the HLA CTL supports in compile-time
    expressions.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](ch09s04.html#compile-time_operators "表 9-1. 编译时运算符") 和 [表 9-2](ch09s04.html#operator_precedence_and_associativity
    "表 9-2. 运算符优先级和结合性") 列出了 HLA CTL 在编译时表达式中支持的运算符。'
- en: Table 9-1. Compile-Time Operators
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1. 编译时运算符
- en: '| Operator(s) | Operand Types^([[a](#ftn.CHP-9-TFN-1)]) | Description |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 操作数类型^([[a](#ftn.CHP-9-TFN-1)]) | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `-` (unary) | numeric | Negates the specific numeric value (int, uns, real).
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `-`（一元运算符） | numeric | 对特定的数值（int, uns, real）进行取负运算。 |'
- en: '|   | cset | Returns the complement of the specified character set. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|   | cset | 返回指定字符集的补集。 |'
- en: '| `!` (unary) | integer | Inverts all the bits in the operand (bitwise `not`).
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `!`（一元运算符） | integer | 反转操作数中的所有位（按位 `not`）。 |'
- en: '|   | boolean | Boolean `not` of the operand. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|   | boolean | 操作数的布尔 `not`。 |'
- en: '| `*` | numericL * numericR | Multiplies the two operands. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `*` | numericL * numericR | 计算两个操作数的乘积。 |'
- en: '|   | csetL * csetR | Computes the intersection of the two sets. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|   | csetL * csetR | 计算两个集合的交集。 |'
- en: '| `div` | integerL divintegerR | Computes the integer quotient of the two integer
    (int/uns/dword) operands. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `div` | integerL divintegerR | 计算两个整数（int/uns/dword）操作数的整数商。 |'
- en: '| `mod` | integerL modintegerR | Computes the remainder of the division of
    the two integer (int/uns/dword) operands. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `mod` | integerL modintegerR | 计算两个整数（int/uns/dword）操作数的除法余数。 |'
- en: '| `/` | numericL / numericR | Computes the real quotient of the two numeric
    operands. Returns a real result even if both operands are integers. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `/` | numericL / numericR | 计算两个数值操作数的实数商。即使两个操作数都是整数，也返回实数结果。 |'
- en: '| `<<` | integerL << integerR | Shifts integerL operand to the left the number
    of bits specified by the integerR operand. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | integerL << integerR | 将 integerL 操作数向左移动由 integerR 操作数指定的位数。 |'
- en: '| `>>` | integerL >> integerR | Shifts integerL operand to the right the number
    of bits specified by the integerR operand. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | integerL >> integerR | 将 integerL 操作数向右移动由 integerR 操作数指定的位数。 |'
- en: '| `+` | numericL + numericR | Adds the two numeric operands. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `+` | numericL + numericR | 将两个数值操作数相加。 |'
- en: '|   | csetL + csetR | Computes the union of the two sets. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|   | csetL + csetR | 计算两个集合的并集。 |'
- en: '|   | strL + strR | Concatenates the two strings. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|   | strL + strR | 连接两个字符串。 |'
- en: '| `-` | numericL numericR | Computes the difference between numericL and numericR.
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `-` | numericL numericR | 计算 numericL 和 numericR 之间的差。 |'
- en: '|   | csetL - csetR | Computes the set difference of csetL - csetR. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|   | csetL - csetR | 计算 csetL - csetR 的集合差。 |'
- en: '| `=` or `==` | numericL = numericR | Returns true if the two operands have
    the same value. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `=` 或 `==` | numericL = numericR | 如果两个操作数具有相同的值，则返回真。 |'
- en: '|   | csetL = csetR | Returns true if the two sets are equal. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|   | csetL = csetR | 如果两个集合相等，则返回真。 |'
- en: '|   | strL = strR | Returns true if the two strings/chars are equal. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|   | strL = strR | 如果两个字符串/字符相等，则返回真。 |'
- en: '|   | typeL = typeR | Returns true if the two values are equal. They must be
    the same type. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|   | typeL = typeR | 如果两个值相等，则返回 true。它们必须是相同类型。 |'
- en: '| `<>` or `!=` | typeL <> typeR (sameas !=) | Returns false if the two (compatible)
    operands are not equal to one another (numeric, cset, or string). |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `<>` 或 `!=` | typeL <> typeR（与 != 相同） | 如果两个（兼容的）操作数不相等（数值、字符集或字符串），则返回 false。
    |'
- en: '| `<` | numericL < numericR | Returns true if numericL is less than numericR.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `<` | numericL < numericR | 如果 numericL 小于 numericR，则返回 true。 |'
- en: '|   | csetL < csetR | Returns true if csetL is a proper subset of csetR. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|   | csetL < csetR | 如果 csetL 是 csetR 的适当子集，则返回 true。 |'
- en: '|   | strL < strR | Returns true if strL is less than strR. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|   | strL < strR | 如果 strL 小于 strR，则返回 true。 |'
- en: '|   | booleanL < booleanR | Returns true if the left operand is less than the
    right operand (note: false < true). |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|   | booleanL < booleanR | 如果左操作数小于右操作数，则返回 true（注意：false < true）。 |'
- en: '|   | enumL < enumR | Returns true if enumL appears in the same enumlist as
    enumR and enumL appears first. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|   | enumL < enumR | 如果 enumL 出现在与 enumR 相同的枚举列表中，并且 enumL 出现得更早，则返回 true。
    |'
- en: '| `<=` | Same as < | Returns true if the left operand is less than or equal
    to the right operand. For character sets, this means that the left operand is
    a subset of the right operand. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | 与 < 相同 | 如果左操作数小于或等于右操作数，则返回 true。对于字符集，意味着左操作数是右操作数的子集。 |'
- en: '| `>` | Same as < | Returns true if the left operand is greater than the right
    operand. For character sets, this means that the left operand is a proper superset
    of the right operand. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 与 < 相同 | 如果左操作数大于右操作数，则返回 true。对于字符集，意味着左操作数是右操作数的一个适当超集。 |'
- en: '| `>=` | Same as <= | Returns true if the left operand is greater than or equal
    to the right operand. For character sets, this means that the left operand is
    a superset of the right operand. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | 与 <= 相同 | 如果左操作数大于或等于右操作数，则返回 true。对于字符集，意味着左操作数是右操作数的超集。 |'
- en: '| `&` | integerL & integerR | Computes the bitwise `and` of the two operands.
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `&` | integerL & integerR | 计算两个操作数的按位 `and`。 |'
- en: '|   | booleanL & booleanR | Computes the logical `and` of the two operands.
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|   | booleanL & booleanR | 计算两个操作数的逻辑 `and`。 |'
- en: '| `&#124;` | integerL &#124; integerR | Computes the bitwise `or` of the two
    operands. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | integerL &#124; integerR | 计算两个操作数的按位 `or`。 |'
- en: '|   | booleanL &#124; booleanR | Computes the logical `or` of the two operands.
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|   | booleanL &#124; booleanR | 计算两个操作数的逻辑 `or`。 |'
- en: '| `^` | integerL ^ integerR | Computes the bitwise `xor` of the two operands.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `^` | integerL ^ integerR | 计算两个操作数的按位 `xor`。 |'
- en: '|   | booleanL ^ booleanR | Computes the logical `xor` of the two operands.
    Note that this is equivalent to `booleanL <> booleanR`. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|   | booleanL ^ booleanR | 计算两个操作数的逻辑 `xor`。注意，这等同于 `booleanL <> booleanR`。
    |'
- en: '| `in` | charL in csetR | Returns true if charL is a member of csetR. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `in` | charL 在 csetR 中 | 如果 charL 是 csetR 的成员，则返回 true。 |'
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: ^([[a](#CHP-9-TFN-1)]) Type numeric is {int*XX*, uns*XX*, byte, word, dword,
    and real*XX*} values. Type cset is a character set operand. Type integer is {int*XX*,
    uns*XX*, byte, word, dword}. Type str is any string or character value. Type indicates
    an arbitrary HLA type. Other types specify an explicit HLA data type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[a](#CHP-9-TFN-1)]) 类型 numeric 是 {int*XX*, uns*XX*, byte, word, dword 和 real*XX*}
    值。类型 cset 是字符集操作数。类型 integer 是 {int*XX*, uns*XX*, byte, word, dword}。类型 str 是任何字符串或字符值。类型表示任意
    HLA 类型。其他类型指定一个显式的 HLA 数据类型。 |
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 9-2. Operator Precedence and Associativity
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-2. 运算符优先级和结合性 |
- en: '| Associativity | Precedence (Highest to Lowest) | Operator |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 结合性 | 优先级（从高到低） | 运算符 |'
- en: '| --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Right to left | 6 | `!` (unary) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 从右到左 | 6 | `!`（一元操作符） |'
- en: '|   |   | `-` (unary) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `-`（一元操作符） |'
- en: '| Left to right | 5 | `*` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 从左到右 | 5 | `*` |'
- en: '|   |   | `div` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `div` |'
- en: '|   |   | `mod` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `mod` |'
- en: '|   |   | `/` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `/` |'
- en: '|   |   | `>>` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `>>` |'
- en: '|   |   | `<<` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `<<` |'
- en: '| Left to right | 4 | `+` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 从左到右 | 4 | `+` |'
- en: '|   |   | `-` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `-` |'
- en: '| Left to right | 3 | `=` or `==` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 从左到右 | 3 | `=` 或 `==` |'
- en: '|   |   | `<>` or `!=` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `<>` 或 `!=` |'
- en: '|   |   | `<` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `<` |'
- en: '|   |   | `<=` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `<=` |'
- en: '|   |   | `>` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `>` |'
- en: '|   |   | `>=` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `>=` |'
- en: '| Left to right | 2 | `&` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 从左到右 | 2 | `&` |'
- en: '|   |   | `&#124;` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `&#124;` |'
- en: '|   |   | `^` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|   |   | `^` |'
- en: '| Nonassociative | 1 | `in` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 非结合性 | 1 | `in` |'
- en: Of course, you can always override the default precedence and associativity
    of an operator by using parentheses in an expression.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以通过在表达式中使用括号来覆盖运算符的默认优先级和结合性。 |
- en: 9.5 Compile-Time Functions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.5 编译时函数 |
- en: HLA provides a wide range of compile-time functions you can use. These functions
    compute values during compilation the same way a high-level-language function
    computes values at runtime. The HLA compile-time language includes a wide variety
    of numeric, string, and symbol table functions that help you write sophisticated
    compile-time programs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: HLA提供了丰富的编译时函数供你使用。这些函数在编译期间计算值，方式与高级语言函数在运行时计算值类似。HLA的编译时语言包括各种数值、字符串和符号表函数，帮助你编写复杂的编译时程序。
- en: Most of the names of the built-in compile-time functions begin with the special
    symbol `@` and have names like `@sin` or `@length`. The use of these special identifiers
    prevents conflicts with common names you might want to use in your own programs
    (like `length`). The remaining compile-time functions (those that do not begin
    with `@`) are typically data conversion functions that use type names like `int8`
    and `real64`. You can even create your own compile-time functions using macros
    (which is discussed in [9.8 Macros (Compile-Time Procedures)](ch09s08.html "9.8
    Macros (Compile-Time Procedures)")).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内建的编译时函数名称以特殊符号`@`开头，名称类似于`@sin`或`@length`。使用这些特殊标识符可以避免与程序中可能使用的常见名称（例如`length`）发生冲突。剩余的编译时函数（那些不以`@`开头的）通常是数据转换函数，使用类型名称如`int8`和`real64`。你甚至可以通过宏来创建自己的编译时函数（宏的使用在[9.8
    宏（编译时过程）](ch09s08.html "9.8 Macros (Compile-Time Procedures)")中讨论）。
- en: HLA organizes the compile-time functions into various classes depending on the
    type of operation. For example, there are functions that convert constants from
    one form to another (such as string-to-integer conversion), there are many useful
    string functions, and HLA provides a full set of compile-time numeric functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: HLA根据操作类型将编译时函数组织成不同的类别。例如，有一些函数将常量从一种形式转换为另一种形式（例如字符串到整数的转换），还有许多有用的字符串函数，HLA提供了一整套编译时数值函数。
- en: The complete list of HLA compile-time functions is too lengthy to present here.
    Instead, a complete description of each of the compile-time objects and functions
    appears in the HLA reference manual (found at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/)); this section highlights
    a few of the functions in order to demonstrate their use. Later sections in this
    chapter, as well as future chapters, make extensive use of the various compile-time
    functions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: HLA编译时函数的完整列表过于庞大，无法在此呈现。相反，关于每个编译时对象和函数的完整描述可以在HLA参考手册中找到（可在[http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)或[http://www.artofasm.com/](http://www.artofasm.com/)查阅）；本节将突出介绍一些函数，以展示它们的使用方法。本章后续章节以及未来章节将广泛使用各种编译时函数。
- en: Perhaps the most important concept to understand about the compile-time functions
    is that they are equivalent to constants in your assembly language code (i.e.,
    the runtime program). For example, the compile-time function invocation `@sin(3.1415265358979328)`
    is roughly equivalent to specifying 0.0 at that point in your program.^([[119](#ftn.CHP-9-FN-2)])
    A function invocation like `@sin( x )` is legal only if `x` is a constant with
    a previous declaration at the point of the function call in the source file. In
    particular, `x` cannot be a runtime variable or other object whose value exists
    at runtime rather than compile time. Because HLA replaces compile-time function
    calls with their constant result, you may ask why you should even bother with
    compile-time functions. After all, it's probably more convenient to type *0.0*
    than it is to type *@sin(3.1415265358979328)* in your program. However, compile-time
    functions are handy for generating lookup tables and other mathematical results
    that may change whenever you change a `const` value in your program. [9.9 Writing
    Compile-Time "Programs"](ch09s09.html "9.9 Writing Compile-Time "Programs"") will
    explore this idea further.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 也许理解编译时函数最重要的概念是，它们在你的汇编语言代码（即运行时程序）中等同于常量。例如，编译时函数调用`@sin(3.1415265358979328)`大致相当于在程序中指定0.0。^([[119](#ftn.CHP-9-FN-2)])像`@sin(x)`这样的函数调用，只有在`x`是一个在函数调用点之前已声明的常量时才是合法的。特别是，`x`不能是运行时变量或其他在运行时而非编译时存在的对象。因为HLA将编译时函数调用替换为其常量结果，你可能会问为什么还要使用编译时函数。毕竟，在程序中输入*0.0*可能比输入`@sin(3.1415265358979328)`更方便。然而，编译时函数对于生成查找表和其他可能在你改变程序中的`const`值时发生变化的数学结果非常有用。[9.9
    编写编译时“程序”](ch09s09.html "9.9 Writing Compile-Time "Programs"")将进一步探讨这个想法。
- en: 9.5.1 Type-Conversion Compile-Time Functions
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.1 类型转换编译时函数
- en: 'Probably the most commonly used compile-time functions are the type-conversion
    functions. These functions take a single parameter of one type and convert that
    information to some specified type. These functions use several of the HLA built-in
    data type names as the function names. Functions in this category are the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的编译时函数可能是类型转换函数。这些函数接受一个类型的单一参数，并将该信息转换为指定的类型。这些函数使用多个HLA内建数据类型名称作为函数名。该类别中的函数包括：
- en: '`boolean`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`'
- en: '`int8`, `int16`, `int32`, `int64`, and `int128`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int8`、`int16`、`int32`、`int64`和`int128`'
- en: '`uns8`, `uns16`, `uns32`, `uns64`, and `uns128`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uns8`、`uns16`、`uns32`、`uns64`和`uns128`'
- en: '`byte`, `word`, `dword`, `qword`, and `lword` (these are effectively equivalent
    to `uns8`, `uns16`, `uns32`, `uns64`, and `uns128`, respectively)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`、`word`、`dword`、`qword`和`lword`（它们实际上等同于`uns8`、`uns16`、`uns32`、`uns64`和`uns128`）'
- en: '`real32`, `real64`, and `real80`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real32`、`real64`和`real80`'
- en: '`char`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`'
- en: '`string`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: '`cset`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cset`'
- en: '`text`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`'
- en: 'These functions accept a single constant expression parameter and, if at all
    reasonable, convert that expression''s value to the type specified by the type
    name. For example, the following function call returns the value −128 because
    it converts the string constant to the corresponding integer value:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数接受一个常量表达式参数，并且如果合理的话，将该表达式的值转换为指定类型的值。例如，以下函数调用返回值−128，因为它将字符串常量转换为对应的整数值：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Certain conversions don't make sense or have restrictions associated with them.
    For example, the `boolean` function will accept a string parameter, but that string
    must be "true" or "false" or the function will generate a compile-time error.
    Likewise, the numeric conversion functions (e.g., `int8`) allow a string operand,
    but the string operand must represent a legal numeric value. Some conversions
    (for example, `int8` with a character set parameter) simply don't make sense and
    are always illegal.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 某些转换是没有意义的，或者有相关的限制。例如，`boolean`函数会接受一个字符串参数，但该字符串必须是“true”或“false”，否则函数会生成编译时错误。同样，数字转换函数（例如，`int8`）允许一个字符串操作数，但该字符串操作数必须表示一个合法的数字值。某些转换（例如，带有字符集参数的`int8`）根本没有意义，并且始终是非法的。
- en: 'One of the most useful functions in this category is the `string` function.
    This function accepts nearly all the constant expression types, and it generates
    a string that represents the parameter''s data. For example, the invocation `string(
    128 )` produces the string `128` as the return result. This function is handy
    when you have a value that you wish to use where HLA requires a string. For example,
    the `#error` compile-time statement allows only a single-string operand. You can
    use the string function and the string concatenation operator (`+`) to easily
    get around this limitation. For example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别中最有用的函数之一是`string`函数。该函数接受几乎所有常量表达式类型，并生成一个表示参数数据的字符串。例如，调用`string(128)`会生成字符串`128`作为返回结果。当你有一个值需要在HLA中作为字符串使用时，这个函数非常方便。例如，`#error`编译时语句只允许一个字符串操作数。你可以使用`string`函数和字符串连接运算符（`+`）轻松绕过这个限制。例如：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that these type functions actually perform a conversion. This means that
    the bit pattern these functions return may be considerably different than the
    bit pattern you pass as an argument. For example, consider the following invocation
    of the `real32` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些类型函数实际上执行的是转换。这意味着这些函数返回的位模式可能与传递的参数的位模式有很大不同。例如，考虑以下对`real32`函数的调用：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now it turns out that $3F80_0000 is the hexadecimal equivalent of the `real32`
    value 1.0\. However, the preceding function invocation does not return 1.0; instead
    it attempts to convert the integer value $3F80_0000 (1,065,353,216) to a `real32`
    value but fails because the value is too large to exactly represent using a `real32`
    object. Contrast this with the following constant function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事实证明，$3F80_0000是`real32`值1.0的十六进制等价物。然而，前面的函数调用并不会返回1.0；相反，它试图将整数值$3F80_0000（1,065,353,216）转换为`real32`值，但失败了，因为该值太大，无法使用`real32`对象精确表示。与此相对比，以下常量函数：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This CTL function invocation returns the character `A` (because 65 is the ASCII
    code for `A`). Notice how the `char` function simply uses the bit pattern of the
    integer argument you pass it as an ASCII code, whereas the `real32` function attempts
    to translate the integer argument to a floating-point value. Although the semantics
    are quite different between these two functions, the bottom line is that they
    tend to do the intuitive operation, even at the expense of consistency.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 CTL 函数调用返回字符 `A`（因为 65 是 `A` 的 ASCII 码）。请注意，`char` 函数只是简单地使用你传递给它的整数参数的位模式作为
    ASCII 码，而 `real32` 函数试图将整数参数转换为浮点值。尽管这两个函数的语义差别很大，但归根结底，它们倾向于执行直观的操作，即使这牺牲了一定的统一性。
- en: 'Sometimes, however, you might not want these functions to do the "intuitive"
    thing. For example, you might want the `real32` function to simply treat the bit
    pattern you pass it as a `real32` value. To handle this situation, HLA provides
    a second set of type functions, which are simply the type names with an `@` prefix
    that treat the argument as a bit pattern of the final type. So if you really want
    to produce 1.0 from $3F80_0000, then you could use the following function invocation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能不希望这些函数做“直观”的操作。例如，你可能希望 `real32` 函数仅仅将你传入的位模式作为 `real32` 值来处理。为了处理这种情况，HLA
    提供了第二组类型函数，它们只是类型名称前加上 `@` 前缀，并将参数视为最终类型的位模式。因此，如果你真的希望从 `$3F80_0000` 生成 1.0，你可以使用以下函数调用：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Generally, type coercion of this form is somewhat advanced in the compile-time
    language, so you'll probably not use it very often. However, when it is needed,
    it's nice to have around.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，这种类型强制转换在编译时语言中是比较高级的，所以你可能不会经常使用它。然而，当它需要时，能够使用它还是很方便的。
- en: 9.5.2 Numeric Compile-Time Functions
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.2 数值编译时函数
- en: 'The functions in this category perform standard mathematical operations at
    compile time. These functions are handy for generating lookup tables and "parameterizing"
    your source code by recalculating functions on constants defined at the beginning
    of your program. Functions in this category include the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本类函数在编译时执行标准的数学操作。这些函数非常适合生成查找表，并通过在程序开始时重新计算已定义常量的函数来“参数化”源代码。本类函数包括以下内容：
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@abs(` *`n`* `)`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@abs(` *`n`* `)`'
- en: '| Absolute value of numeric argument |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 数值参数的绝对值 |'
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@ceil(` *`r`* `), @floor(` *`r`* `)`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ceil(` *`r`* `), @floor(` *`r`* `)`'
- en: '| Extract integer component of floating-point value |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 提取浮点值的整数部分 |'
- en: '|'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@sin(` *`r`* `)`, `@cos(` *`r`* `)`, `@tan(` *`r`* `)`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@sin(` *`r`* `)`, `@cos(` *`r`* `)`, `@tan(` *`r`* `)`'
- en: '| Standard trig functions |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 标准三角函数 |'
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@exp(` *`r`* `)`, `@log(` *`r`* `)`, `@log10(` *`r`* `)`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@exp(` *`r`* `)`, `@log(` *`r`* `)`, `@log10(` *`r`* `)`'
- en: '| Standard log/exponent functions |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 标准对数/指数函数 |'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@min(` *`list`* `)`, `@max(` *`list`* `)`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@min(` *`list`* `)`, `@max(` *`list`* `)`'
- en: '| Return min/max value from a list of values |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 从值列表中返回最小/最大值 |'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@random`, `@randomize`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@random`, `@randomize`'
- en: '| Return a pseudo-random `int32` value |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 返回伪随机的 `int32` 值 |'
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`@sqrt(` *`n`* `)`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@sqrt(` *`n`* `)`'
- en: '| Computes the square root of its numeric argument (real result) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 计算数值参数的平方根（实数结果） |'
- en: See the HLA reference manual at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/) for more details on these
    functions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 详情请参见 HLA 参考手册 [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) 或 [http://www.artofasm.com/](http://www.artofasm.com/)。
- en: 9.5.3 Character-Classification Compile-Time Functions
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.3 字符分类编译时函数
- en: 'The functions in this group all return a boolean result. They test a character
    (or all the characters in a string) to see if it belongs to a certain class of
    characters. The functions in this category include the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本组函数均返回布尔结果。它们测试一个字符（或字符串中的所有字符），查看其是否属于某一类字符。该类别的函数包括以下内容：
- en: '`@isAlpha(` *`c`* `)`, `@isAlphanum(` *`c`* `)`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@isAlpha(` *`c`* `)`, `@isAlphanum(` *`c`* `)`'
- en: '`@isDigit(` *`c`* `)`, `@isxDigit(` *`c`* `)`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@isDigit(` *`c`* `)`, `@isxDigit(` *`c`* `)`'
- en: '`@isLower(` *`c`* `)`, `@isUpper(` *`c`* `)`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@isLower(` *`c`* `)`, `@isUpper(` *`c`* `)`'
- en: '`@isSpace(` *`c`* `)`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@isSpace(` *`c`* `)`'
- en: In addition to these character-classification functions, the HLA language provides
    a set of pattern-matching functions that you can also use to classify character
    and string data. See the HLA reference manual at for the discussion of these routines.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些字符分类函数，HLA 语言还提供了一组模式匹配函数，你也可以用来分类字符和字符串数据。有关这些例程的讨论，请参见 HLA 参考手册。
- en: 9.5.4 Compile-Time String Functions
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.4 编译时字符串函数
- en: The functions in this category operate on string parameters. Most return a string
    result, although a few (for example, `@length` and `@index`) return integer results.
    These functions do not directly affect the values of their parameters; instead,
    they return an appropriate result that you can assign back to the parameter if
    you wish to do so.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本类别中的函数操作字符串参数。大多数返回字符串结果，尽管有一些（例如 `@length` 和 `@index`）返回整数结果。这些函数不会直接影响它们参数的值；相反，它们返回一个合适的结果，如果你愿意，可以将其赋值回参数。
- en: '`@delete`, `@insert`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@delete`, `@insert`'
- en: '`@index`, `@rindex`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@index`, `@rindex`'
- en: '`@length`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@length`'
- en: '`@lowercase`, `@uppercase`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@lowercase`, `@uppercase`'
- en: '`@strbrk`, `@strspan`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@strbrk`, `@strspan`'
- en: '`@strset`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@strset`'
- en: '`@substr`, `@tokenize`, `@trim`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@substr`, `@tokenize`, `@trim`'
- en: For specific details concerning these functions, their parameters, and their
    types, see the HLA reference manual. Note that these are the compile-time equivalents
    of many of the string functions found in the HLA Standard Library.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些函数、它们的参数以及类型的具体细节，请参见 HLA 参考手册。请注意，这些是 HLA 标准库中许多字符串函数的编译时等效函数。
- en: 'The `@length` function deserves a special discussion because it is probably
    the most popular function in this category. It returns an `uns32` constant specifying
    the number of characters found in its string parameter. The syntax is the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`@length` 函数值得特别讨论，因为它可能是这个类别中最常用的函数。它返回一个 `uns32` 常量，指定其字符串参数中包含的字符数。语法如下：'
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: where *`string_expression`* represents any compile-time string expression. As
    noted, this function returns the length, in characters, of the specified expression.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *`string_expression`* 代表任何编译时字符串表达式。如前所述，这个函数返回指定表达式的字符长度。
- en: 9.5.5 Compile-Time Symbol Information
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.5 编译时符号信息
- en: During compilation HLA maintains an internal database known as the *symbol table*.
    The symbol table contains lots of useful information concerning all the identifiers
    you've defined up to a given point in the program. In order to generate machine
    code output, HLA needs to query this database to determine how to treat certain
    symbols. In your compile-time programs, it is often necessary to query the symbol
    table to determine how to handle an identifier or expression in your code. The
    HLA compile-time symbol-information functions handle this task.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，HLA 维护一个内部数据库，称为 *符号表*。符号表包含了关于你在程序中的某个点之前定义的所有标识符的许多有用信息。为了生成机器代码输出，HLA
    需要查询这个数据库以确定如何处理某些符号。在你的编译时程序中，通常需要查询符号表来决定如何处理代码中的标识符或表达式。HLA 编译时符号信息函数负责执行这一任务。
- en: 'Many of the compile-time symbol-information functions are well beyond the scope
    of this text. This chapter will present a few of the functions. For a complete
    list of the compile-time symbol-table functions, see the HLA reference manual.
    The functions we will consider in this chapter include the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编译时符号信息函数超出了本书的范围。本章将介绍其中的一些函数。有关编译时符号表函数的完整列表，请参见 HLA 参考手册。本章将讨论的函数包括以下内容：
- en: '`@size`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@size`'
- en: '`@defined`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@defined`'
- en: '`@typeName`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@typeName`'
- en: '`@elements`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@elements`'
- en: '`@elementSize`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@elementSize`'
- en: Without question, the `@size` function is probably the most important function
    in this group. Indeed, previous chapters have made use of this function already.
    The `@size` function requires a single HLA identifier or constant expression as
    a parameter. It returns the size, in bytes, of the data type of that object (or
    expression). If you supply an identifier, it can be a constant, type, or variable
    identifier. As you've seen in previous chapters, this function is invaluable for
    allocating storage via `mem.alloc` and allocating storage for arrays.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，`@size` 函数可能是这一组中最重要的函数。事实上，前面的章节已经使用过这个函数。`@size` 函数需要一个单一的 HLA 标识符或常量表达式作为参数。它返回该对象（或表达式）数据类型的字节大小。如果你提供一个标识符，它可以是常量、类型或变量标识符。正如你在前面的章节中看到的，这个函数在通过
    `mem.alloc` 分配存储和为数组分配存储时非常有用。
- en: 'Another very useful function in this group is the `@defined` function. This
    function accepts a single HLA identifier as a parameter. For example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组中另一个非常有用的函数是 `@defined` 函数。这个函数接受一个单一的 HLA 标识符作为参数。例如：
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function returns true if the identifier is defined at that point in the
    program; it returns false otherwise.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在程序的某个点上返回 `true`，如果标识符在该点已定义；否则返回 `false`。
- en: The `@typeName` function returns a string specifying the type name of the identifier
    or expression you supply as a parameter. For example, if `i32` is an `int32` object,
    then `@typeName( i32 )` returns the string `int32`. This function is useful for
    testing the types of objects you are processing in your compile-time programs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`@typeName` 函数返回一个字符串，指定你作为参数提供的标识符或表达式的类型名称。例如，如果 `i32` 是一个 `int32` 对象，那么
    `@typeName( i32 )` 将返回字符串 `int32`。这个函数对于测试你在编译时程序中处理的对象类型非常有用。'
- en: The `@elements` function requires an array identifier or expression. It returns
    the total number of array elements as the function result. Note that for multidimensional
    arrays this function returns the product of all the array dimensions.^([[120](#ftn.CHP-9-FN-3)])
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`@elements` 函数需要一个数组标识符或表达式。它返回数组元素的总数作为函数结果。需要注意的是，对于多维数组，这个函数返回所有数组维度的乘积。^([[120](#ftn.CHP-9-FN-3)])'
- en: The `@elementSize` function returns the size, in bytes, of an element of an
    array whose name you pass as a parameter. This function is extremely valuable
    for computing indices into an array (that is, this function computes the `element_size`
    component of the array index calculation; see [Chapter 4](ch04.html "Chapter 4. CONSTANTS,
    VARIABLES, AND DATA TYPES") for more details).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`@elementSize` 函数返回你作为参数传递的数组元素的大小（以字节为单位）。这个函数对于计算数组的索引非常有价值（也就是说，这个函数计算数组索引计算中的
    `element_size` 组件；更多细节请参见[第 4 章](ch04.html "第 4 章：常量、变量与数据类型")）。'
- en: 9.5.6 Miscellaneous Compile-Time Functions
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.6 杂项编译时函数
- en: 'The HLA compile-time language contains several additional functions that don''t
    fall into one of the categories above. Some of the more useful miscellaneous functions
    include the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 编译时语言包含一些不属于上述类别的额外函数。一些比较有用的杂项函数包括以下内容：
- en: '`@odd`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@odd`'
- en: '`@lineNumber`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@lineNumber`'
- en: '`@text`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@text`'
- en: The `@odd` function takes an ordinal value (i.e., nonreal numeric or character)
    as a parameter and returns true if the value is odd, false if it is even. The
    `@lineNumber` function requires no parameters; it returns the current line number
    in the source file. This function is quite useful for debugging compile-time (and
    runtime!) programs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`@odd` 函数接受一个序数值（即非实数的数字或字符）作为参数，如果该值是奇数，则返回 `true`，如果是偶数，则返回 `false`。`@lineNumber`
    函数不需要参数；它返回源文件中的当前行号。这个函数对于调试编译时（和运行时！）程序非常有用。'
- en: 'The `@text` function is probably the most useful function in this group. It
    requires a single-string parameter. It expands that string as text in place of
    the `@text` function call. This function is quite useful in conjunction with the
    compile-time string-processing functions. You can build an instruction (or a portion
    of an instruction) using the string-manipulation functions and then convert that
    string to program source code using the `@text` function. The following is a trivial
    example of this function in operation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`@text` 函数可能是这个组中最有用的函数。它需要一个单字符串参数，并将该字符串在 `@text` 函数调用处扩展为文本。这个函数与编译时字符串处理函数结合使用时非常有用。你可以使用字符串操作函数构建指令（或指令的一部分），然后通过
    `@text` 函数将该字符串转换为程序源代码。以下是这个函数在操作中的一个简单示例：'
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding sequence compiles to
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上述序列编译为
- en: '[PRE18]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 9.5.7 Compile-Time Type Conversions of Text Objects
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.7 编译时文本对象的类型转换
- en: 'Once you create a text constant in your program, it''s difficult to manipulate
    that object. The following example demonstrates a programmer''s desire to change
    the definition of a text symbol within a program:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在程序中创建了一个文本常量，就很难对该对象进行操作。以下示例展示了程序员希望在程序中更改文本符号定义的场景：
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The basic idea in this example is that the symbol `t` expands to `stdout.put`
    in the first half of the code, and it expands to `fileio.put` in the second half
    of the program. Unfortunately, this simple example will not work. The problem
    is that HLA will expand a text symbol in place almost anywhere it finds that symbol.
    This includes occurrences of `t` within a `?` statement. Therefore, the previous
    code expands to the following (incorrect) text:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的基本思路是，符号 `t` 在代码的前半部分展开为 `stdout.put`，而在程序的后半部分则展开为 `fileio.put`。不幸的是，这个简单的示例不会生效。问题在于
    HLA 会在几乎任何地方扩展文本符号。包括在 `?` 语句中的 `t`。因此，之前的代码扩展成了以下（不正确的）文本：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: HLA doesn't know how to deal with this `?` statement, so it generates a syntax
    error.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 不知道如何处理这个 `?` 语句，所以它会生成语法错误。
- en: 'At times you may not want HLA to expand a text object. Your code may want to
    process the string data held by the text object. HLA provides a couple of ways
    to deal with these two problems:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '`@string(` *`identifier`* `)`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@toString:`*`identifier`*'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `@string(` *`identifier`* `)`, HLA returns a string constant corresponding
    to the text data associated with the text object. In other words, this operator
    lets you treat a text object as though it were a string constant within an expression.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the `@string` function converts a text object to a string constant,
    not a string identifier. Therefore, you cannot say something like
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This doesn't work because `@string(t)` replaces itself with the string constant
    associated with the text object `t`. Given the former assignment to `t`, this
    statement expands to
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This statement is still illegal.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@toString:`*`identifier`* operator comes to the rescue in this case. The
    `@toString:` operator requires a text object as the associated identifier. It
    converts this text object to a string object (still maintaining the same string
    data) and then returns the identifier. Because the identifier is now a string
    object, you can assign a value to it (and change its type to something else, for
    example, `text`, if that''s what you need). To achieve the original goal, therefore,
    you''d use code like the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '* * *'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: ^([[119](#CHP-9-FN-2)]) Actually, because `@sin`'s parameter in this example
    is not exactly pi, you will get a small positive number instead of zero as the
    function result, but in theory you should get zero.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: ^([[120](#CHP-9-FN-3)]) There is an `@dim` function that returns an array specifying
    the bounds on each dimension of a multidimensional array. See the documentation
    at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) or [http://www.artofasm.com/](http://www.artofasm.com/)
    for more details if you're interested in this function.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Conditional Compilation (Compile-Time Decisions)
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HLA''s compile-time language provides an if statement, `#if`, that lets you
    make decisions at compile time. The `#if` statement has two main purposes: The
    traditional use of `#if` is to support *conditional compilation* (or *conditional
    assembly*), allowing you to include or exclude code during a compilation depending
    on the status of various symbols or constant values in your program. The second
    use of this statement is to support the standard if statement decision-making
    process in the HLA compile-time language. This section discusses these two uses
    for the HLA `#if` statement.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest form of the HLA compile-time `#if` statement uses the following
    syntax:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that you do not place semicolons after the `#endif` clause. If you place
    a semicolon after the `#endif`, it becomes part of the source code, and this would
    be identical to inserting that semicolon immediately before the next item in the
    program.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'At compile time, HLA evaluates the expression in the parentheses after the
    `#if`. This must be a constant expression, and its type must be boolean. If the
    expression evaluates true, HLA continues to process the text in the source file
    as though the `#if` statement was not present. However, if the expression evaluates
    false, HLA treats all the text between the `#if` and the corresponding `#endif`
    clause as though it were a comment (that is, it ignores this text), as shown in
    [Figure 9-2](ch09s06.html#operation_of_an_hla_compile-time_number "Figure 9-2. Operation
    of an HLA compile-time #if statement").'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Operation of an HLA compile-time #if statement](tagoreillycom20100401nostarchimages578065.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2. Operation of an HLA compile-time `#if` statement
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that HLA''s constant expressions support a full expression syntax
    like you''d find in a high-level language like C or Pascal. The `#if` expression
    syntax is not limited to the syntax allowed by expressions in the HLA `if` statement.
    Therefore, it is perfectly reasonable to write fancy expressions like the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Also keep in mind that the identifiers in a compile-time expression must all
    be `const` or `val` identifiers or an HLA compile-time function call (with appropriate
    parameters). In particular, remember that HLA evaluates these expressions at compile
    time so they cannot contain runtime variables.^([[121](#ftn.CHP-9-FN-4)]) HLA's
    compile-time language uses complete boolean evaluation, so any side effects that
    occur in the expression may produce undesired results.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The HLA `#if` statement supports optional `#elseif` and `#else` clauses that
    behave in the intuitive fashion. The complete syntax for the `#if` statement looks
    like the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the first boolean expression evaluates true, then HLA processes the text
    up to the `#elseif` clause. It then skips all text (that is, treats it like a
    comment) until it encounters the `#endif` clause. HLA continues processing the
    text after the `#endif` clause in the normal fashion.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: If the first boolean expression above evaluates false, then HLA skips all the
    text until it encounters a `#elseif`, `#else`, or `#endif` clause. If it encounters
    a `#elseif` clause (as above), then HLA evaluates the boolean expression associated
    with that clause. If it evaluates true, HLA processes the text between the `#elseif`
    and the `#else` clauses (or to the `#endif` clause if the `#else` clause is not
    present). If, during the processing of this text, HLA encounters another `#elseif`
    or, as above, a `#else` clause, then HLA ignores all further text until it finds
    the corresponding `#endif`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: If both the first and second boolean expressions in the previous example evaluate
    false, HLA skips their associated text and begins processing the text in the `#else`
    clause. As you can see, the `#if` statement behaves in a relatively intuitive
    fashion once you understand how HLA "executes" the body of these statements; the
    `#if` statement processes the text or treats it as a comment, depending on the
    state of the boolean expression. Of course, you can create a nearly infinite variety
    of different `#if` statement sequences by including zero or more `#elseif` clauses
    and optionally supplying the `#else` clause. Because the construction is identical
    to the HLA `if..then..elseif..else..endif` statement, there is no need to elaborate
    further here.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'A very traditional use of conditional compilation is to develop software that
    you can easily configure for several different environments. For example, the
    `fcomip` instruction makes floating-point comparisons very easy, but this instruction
    is available only on Pentium Pro and later processors. If you want to use this
    instruction on the processors that support it and fall back to the standard floating-point
    comparison on the older processors, you would normally have to write two versions
    of the program—one with the `fcomip` instruction and one with the traditional
    floating-point comparison sequence. Unfortunately, maintaining two different source
    files (one for newer processors and one for older processors) is very difficult.
    Most engineers prefer to use conditional compilation to embed the separate sequences
    in the same source file. The following example demonstrates how to do this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As currently written, this code fragment will compile the three-instruction
    sequence in the `#else` clause and ignore the code between the `#if` and `#else`
    clauses (because the constant `PentProOrLater` is false). By changing the value
    of `PentProOrLater` to true, you can tell HLA to compile the single `fcomip` instruction
    rather than the three-instruction sequence. Of course, you can use the `PentProOrLater`
    constant in other `#if` statements throughout your program to control how HLA
    compiles your code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that conditional compilation does not let you create a single *executable*
    that runs efficiently on all processors. When using this technique you will still
    have to create two executable programs (one for Pentium Pro and later processors,
    one for the earlier processors) by compiling your source file twice: During the
    first compilation you must set the `PentProOrLater` constant to false; during
    the second compilation you must set this constant to true. Although you must create
    two separate executables, you need only maintain a single source file.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are familiar with conditional compilation in other languages, such as
    the C/C++ language, you may be wondering if HLA supports a statement like C''s
    `#ifdef` statement. The answer is no, it does not. However, you can use the HLA
    compile-time function `@defined` to easily test to see if a symbol has been defined
    earlier in the source file. Consider the following modification to the preceding
    code that uses this technique:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another common use of conditional compilation is to introduce debugging and
    testing code into your programs. A typical debugging technique that many HLA programmers
    use is to insert "print" statements at strategic points throughout their code;
    this enables them to trace through their code and display important values at
    various checkpoints. A big problem with this technique, however, is that they
    must remove the debugging code prior to completing the project. The software''s
    customer (or a student''s instructor) probably doesn''t want to see debugging
    output in the middle of a report the program produces. Therefore, programmers
    who use this technique tend to insert code temporarily and then remove the code
    once they run the program and determine what is wrong. There are at least two
    problems with this technique:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Programmers often forget to remove some debugging statements, and this creates
    defects in the final program.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After removing a debugging statement, these programmers often discover that
    they need that same statement to debug some different problem at a later time.
    Hence they are constantly inserting and removing the same statements over and
    over again.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conditional compilation can provide a solution to this problem. By defining
    a symbol (say, `debug`) to control debug output in your program, you can easily
    activate or deactivate *all* debugging output by simply modifying a single line
    of source code. The following code fragment demonstrates this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As long as you surround all debugging output statements with an #if statement
    like the preceding, you don''t have to worry about debug output accidentally appearing
    in your final application. By setting the `debug` symbol to false, you can automatically
    disable all such output. Likewise, you don''t have to remove all your debugging
    statements from your programs once they''ve served their immediate purpose. By
    using conditional compilation, you can leave these statements in your code because
    they are so easy to deactivate. Later, if you decide you need to view this same
    debugging information during a compilation, you won''t have to reenter the debugging
    statement; you simply reactivate it by setting the `debug` symbol to true.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Although program configuration and debugging control are two of the more common,
    traditional uses for conditional compilation, don't forget that the `#if` statement
    provides the basic conditional statement in the HLA compile-time language. You
    will use the `#if` statement in your compile-time programs the same way you would
    use an `if` statement in HLA or some other language. Later sections in this text
    will present lots of examples of using the `#if` statement in this capacity.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: ^([[121](#CHP-9-FN-4)]) Except, of course, as parameters to certain HLA compile-time
    functions like `@size` or `@typeName`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 9.7 Repetitive Compilation (Compile-Time Loops)
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HLA's `#while..#endwhile` and `#for..#endfor` statements provide compile-time
    loop constructs. The `#while` statement tells HLA to process the same sequence
    of statements repetitively during compilation. This is very handy for constructing
    data tables as well as providing a traditional looping structure for compile-time
    programs. Although you will not employ the `#while` statement anywhere near as
    often as the `#if` statement, this compile-time control structure is very important
    when you write advanced HLA programs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#while` statement uses the following syntax:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When HLA encounters the `#while` statement during compilation, it will evaluate
    the constant boolean expression. If the expression evaluates false, HLA will skip
    over the text between the `#while` and the `#endwhile` clauses (the behavior is
    similar to the `#if` statement if the expression evaluates false). If the expression
    evaluates true, then HLA will process the statements between the `#while` and
    `#endwhile` clauses and then "jump back" to the start of the `#while` statement
    in the source file and repeat this process, as shown in [Figure 9-3](ch09s07.html#hla_compile-time_number_symble_while_sta
    "Figure 9-3. HLA compile-time #while statement operation").'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![HLA compile-time #while statement operation](tagoreillycom20100401nostarchimages578067.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3. HLA compile-time `#while` statement operation
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this process works, consider the program in [Example 9-2](ch09s07.html#number_symble_while.._number_symble_endw
    "Example 9-2. #while..#endwhile demonstration").
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-2. `#while..#endwhile` demonstration
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can probably surmise, the output from this program is the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What is not quite obvious is how this program generates this output. Remember,
    the `#while..#endwhile` construct is a compile-time language feature, not a runtime
    control construct. Therefore, the previous `#while` loop repeats five times during
    *compilation*. On each repetition of the loop, the HLA compiler processes the
    statements between the `#while` and `#endwhile` clauses. Therefore, the preceding
    program is really equivalent to the code that is shown in [Example 9-3](ch09s07.html#program_equivalent_to_the_code_in_listin
    "Example 9-3. Program equivalent to the code in Example 9-2").
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-3. Program equivalent to the code in [Example 9-2](ch09s07.html#number_symble_while.._number_symble_endw
    "Example 9-2. #while..#endwhile demonstration")
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see in this example, the `#while` statement is very convenient for
    constructing repetitive-code sequences. This is especially invaluable for unrolling
    loops.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA provides three forms of the `#for..#endfor` loop. These three loops take
    the following general form:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-4. HLA `#for` loops
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As its name suggests, *`valObject`* must be an object you've defined in a `val`
    declaration.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first two forms of the `#for` loop above, the *`startExpr`* and *`endExpr`*
    components can be any HLA constant expression that yields an integer value. The
    first of these `#for` loops is semantically equivalent to the following `#while`
    code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The second of these `#for` loops is semantically equivalent to the `#while`
    loop:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The third of these `#for` loops (the one using the `in` keyword) is especially
    useful for processing individual items from some composite data type. This loop
    repeats once for each element, field, character, and so on of the composite value
    you specify for *`composite_expr`*. This can be an array, string, record, or character
    set expression. For arrays, this `#for` loop repeats once for each element of
    the array and on each iteration of the loop; the loop control variable contains
    the current element''s value. For example, the following compile-time loop displays
    the values 1, 10, 100, and 1,000:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the *`composite_expr`* constant is a string constant, the `#for` loop repeats
    once for each character in the string and sets the value of the loop control variable
    to the current character. If the *`composite_expr`* constant expression is a record
    constant, then the loop will repeat once for each field of the record, and for
    each iteration the loop control variable will take on the *type and value* of
    the current field. If the *`composite_expr`* expression is a character set, the
    loop will repeat once for each character in the set, and the loop control variable
    will be assigned that character.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The `#for` loop actually turns out to be more useful than the `#while` loop
    because the larger number of compile-time loops you encounter repeat a fixed number
    of times (for example, processing a fixed number of array elements, macro parameters,
    and so on).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 9.8 Macros (Compile-Time Procedures)
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros are objects that a language processor replaces with other text during
    compilation. Macros are great devices for replacing long, repetitive sequences
    of text with much shorter sequences of text. In additional to the traditional
    role that macros play (e.g., `#define` in C/C++), HLA's macros also serve as the
    equivalent of a compile-time language procedure or function. Therefore, macros
    are very important in HLA's compile-time language—just as important as functions
    and procedures are in other high-level languages.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Although macros are nothing new, HLA's implementation of macros far exceeds
    the macro-processing capabilities of most other programming languages (high level
    or low level). The following sections explore HLA's macro-processing facilities
    and the relationship between macros and other HLA CTL control constructs.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.1 Standard Macros
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HLA supports a straightforward macro facility that lets you define macros in
    a manner that is similar to declaring a procedure. A typical, simple macro declaration
    takes the following form:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Although macro and procedure declarations are similar, there are several immediate
    differences between the two that are obvious from this example. First, of course,
    macro declarations use the reserved word `#macro` rather than procedure. Second,
    you do not begin the body of the macro with a begin *`macroname`*`;` clause. Finally,
    you will note that macros end with the `#endmacro` clause rather than `end` *`macroname`*`;`.
    The following code is a concrete example of a macro declaration:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Execution of this macro's code will compute the two's complement of the 64-bit
    value in EDX:EAX (see the description of extended-precision `neg` in [8.1.7 Extended-Precision
    neg Operations](ch08.html#extended-precision_neg_operations "8.1.7 Extended-Precision
    neg Operations")).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the code associated with `neg64`, you simply specify the macro''s
    name at the point you want to execute these instructions. For example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that you do *not* follow the macro's name with a pair of empty parentheses
    as you would a procedure call (the reason for this will become clear a little
    later).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than the lack of parentheses following `neg64`''s invocation,^([[122](#ftn.CHP-9-FN-5)])
    this looks just like a procedure call. You could implement this simple macro as
    a procedure using the following procedure declaration:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note that the following two statements will both negate the value in EDX:EAX:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The difference between these two (the macro invocation versus the procedure
    call) is the fact that macros expand their text inline, whereas a procedure call
    emits a call to the corresponding procedure elsewhere in the text. That is, HLA
    replaces the invocation `neg64;` directly with the following text:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'On the other hand, HLA replaces the procedure call `neg64p();` with the single
    call instruction:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Presumably, you've defined the `neg64p` procedure earlier in the program.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'You should make the choice of macro versus procedure call on the basis of efficiency.
    Macros are slightly faster than procedure calls because you don''t execute the
    `call` and corresponding `ret` instructions. On the other hand, the use of macros
    can make your program larger because a macro invocation expands to the text of
    the macro''s body on each invocation. Procedure calls jump to a single instance
    of the procedure''s body. Therefore, if the macro body is large and you invoke
    the macro several times throughout your program, it will make your final executable
    much larger. Also, if the body of your macro executes more than a few simple instructions,
    the overhead of a `call/ret` sequence has little impact on the overall execution
    time of the code, so the execution time savings are nearly negligible. On the
    other hand, if the body of a procedure is very short (like the `neg64` example
    above), you''ll discover that the macro implementation is much faster and doesn''t
    expand the size of your program by much. A good rule of thumb is:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use macros for short, time-critical program units. Use procedures for longer
    blocks of code and when execution time is not as critical.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Macros have many other disadvantages over procedures. Macros cannot have local
    (automatic) variables, macro parameters work differently than procedure parameters,
    macros don't support (runtime) recursion, and macros are a little more difficult
    to debug than procedures (just to name a few disadvantages). Therefore, you shouldn't
    really use macros as a substitute for procedures except in cases where performance
    is absolutely critical.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.2 Macro Parameters
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like procedures, macros allow you to define parameters that let you supply different
    data on each macro invocation. This lets you write generic macros whose behavior
    can vary depending on the parameters you supply. By processing these macro parameters
    at compile time, you can write very sophisticated macros.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Macro parameter declaration syntax is very straightforward. You simply supply
    a list of parameter names within parentheses in a macro declaration:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that you do not associate a data type with a macro parameter as you do
    for procedural parameters. This is because HLA macros are generally `text` objects.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'When you invoke a macro, you simply supply the actual parameters the same way
    you would for a procedure call:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that a macro invocation that requires parameters expects you to enclose
    the parameter list within parentheses.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.2.1 Standard Macro Parameter Expansion
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the previous section explains, HLA automatically associates the type `text`
    with macro parameters. This means that during a macro expansion, HLA substitutes
    the text you supply as the actual parameter everywhere the formal parameter name
    appears. The semantics of "pass by textual substitution" are a little different
    than "pass by value" or "pass by reference," so it is worthwhile exploring those
    differences here.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following macro invocations, using the `neg64` macro from the
    previous section:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'These two invocations expand into the following code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that macro invocations do not make a local copy of the parameters (as
    "pass by value" does), nor do they pass the address of the actual parameter to
    the macro. Instead, a macro invocation of the form `neg64( edx, eax );` is equivalent
    to the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Of course, the text objects immediately expand their string values inline, producing
    the former expansion for `neg64( edx, eax );`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that macro parameters are not limited to memory, register, or constant
    operands as are instruction or procedure operands. Any text is fine as long as
    its expansion is legal wherever you use the formal parameter. Similarly, formal
    parameters may appear anywhere in the macro body, not just where memory, register,
    or constant operands are legal. Consider the following macro declaration and sample
    invocations:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In general, HLA assumes that all text between commas constitutes a single macro
    parameter. If HLA encounters any opening bracketing symbols (left parentheses,
    left braces, or left brackets), then it will include all text up to the appropriate
    closing symbol, ignoring any commas that may appear within the bracketing symbols.
    This is why the `chkError` invocations above treat `cmp( eax, 0 )` and `test(
    1, bl )` as single parameters rather than as a pair of parameters. Of course,
    HLA does not consider commas (and bracketing symbols) within a string constant
    as the end of an actual parameter. So the following macro and invocation are perfectly
    legal:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: HLA treats the string `Hello, world!` as a single parameter because the comma
    appears inside a literal string constant, just as your intuition suggests.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unfamiliar with textual macro parameter expansion in other languages,
    you should be aware that there are some problems you can run into when HLA expands
    your actual macro parameters. Consider the following macro declaration and invocation:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This example displays `Hello` five times during compilation rather than the
    eight times you might intuitively expect. This is because the `#for` statement
    above expands to
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The actual parameter for *n* is `3+1`; because HLA expands this text directly
    in place of *n*, you get an erroneous text expansion. Of course, at compile time
    HLA computes `3+1*2` as the value 5 rather than as the value 8 (which you would
    get had HLA passed this parameter by value rather than by textual substitution).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'The common solution to this problem when passing numeric parameters that may
    contain compile-time expressions is to surround the formal parameter in the macro
    with parentheses; for example, you would rewrite the macro above as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The earlier invocation would expand to the following code:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This version of the macro produces the intuitive result.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: If the number of actual parameters does not match the number of formal parameters,
    HLA will generate a diagnostic message during compilation. As with procedures,
    the number of actual parameters must agree with the number of formal parameters.
    If you would like to have optional macro parameters, then keep reading.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.2.2 Macros with a Variable Number of Parameters
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may have noticed by now that some HLA macros don''t require a fixed number
    of parameters. For example, the `stdout.put` macro in the HLA Standard Library
    allows one or more actual parameters. HLA uses a special array syntax to tell
    the compiler that you wish to allow a variable number of parameters in a macro
    parameter list. If you follow the last macro parameter in the formal parameter
    list with `[ ]`, then HLA will allow a variable number of actual parameters (zero
    or more) in place of that formal parameter. For example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note the last invocation especially. If a macro has any formal parameters, you
    must supply parentheses with the macro list after the macro invocation. This is
    true even if you supply zero actual parameters to a macro with a varying parameter
    list. Keep in mind this important difference between a macro with no parameters
    and a macro with a varying parameter list but no actual parameters.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'When HLA encounters a formal macro parameter with the `[ ]` suffix (which must
    be the last parameter in the formal parameter list), HLA creates a constant string
    array and initializes that array with the text associated with the remaining actual
    parameters in the macro invocation. You can determine the number of actual parameters
    assigned to this array using the `@elements` compile-time function. For example,
    `@elements( varying )` will return some value, 0 or greater, that specifies the
    total number of parameters associated with that parameter. The following declaration
    for `varParms` demonstrates how you might use this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Because HLA doesn''t allow arrays of `text` objects, the varying parameter
    must be an array of strings. This, unfortunately, means you must treat the varying
    parameters differently than you handle standard macro parameters. If you want
    some element of the varying string array to expand as text within the macro body,
    you can always use the `@text` function to achieve this. Conversely, if you want
    to use a nonvarying formal parameter as a string object, you can always use the
    `@string`( *`name`* ) function. The following example demonstrates this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Of course, it would be a good idea, in a macro like the above, to verify that
    there are at least two parameters before attempting to reference element zero
    of the `optional` parameter. You can easily do this as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 9.8.2.3 Required vs. Optional Macro Parameters
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the previous section notes, HLA requires exactly one actual parameter for
    each nonvarying formal macro parameter. If there is no varying macro parameter
    (and there can be at most one), then the number of actual parameters must exactly
    match the number of formal parameters. If a varying formal parameter is present,
    then there must be at least as many actual macro parameters as there are nonvarying
    (or required) formal macro parameters. If there is a single, varying actual parameter,
    then a macro invocation may have zero or more actual parameters.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one big difference between a macro invocation of a macro with no parameters
    and a macro invocation of a macro with a single, varying parameter that has no
    actual parameters: The macro with the varying parameter list must have an empty
    set of parentheses after it, while the macro invocation of the macro without any
    parameters does not allow this. You can use this fact to your advantage if you
    wish to write a macro that doesn''t have any parameters but you want to follow
    the macro invocation with `( )` so that it matches the syntax of a procedure call
    with no parameters. Consider the following macro:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding macro requires invocations of the form `neg64();` to use the same
    syntax you would use for a procedure call. This feature is useful if you want
    the syntax of your parameterless macro invocations to match the syntax of a parameterless
    procedure call. It's not a bad idea to do this, just in the off chance you need
    to convert the macro to a procedure at some point (or vice versa, for that matter).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.3 Local Symbols in a Macro
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following macro declaration:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The purpose of this macro is to simulate an instruction that jumps to the specified
    target location if the zero flag is set `and` the carry flag is set. Conversely,
    if either the zero flag is clear or the carry flag is clear, this macro transfers
    control to the instruction immediately following the macro invocation.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a serious problem with this macro. Consider what happens if you use
    this macro more than once in your program:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding macro invocations expand to the following code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The problem with the expansion of these two macro invocations is that they both
    emit the same label, `NotTarget`, during macro expansion. When HLA processes this
    code it will complain about a duplicate symbol definition. Therefore, you must
    take care when defining symbols inside a macro because multiple invocations of
    that macro may lead to multiple definitions of that symbol.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: HLA's solution to this problem is to allow the use of *local symbols* within
    a macro. Local macro symbols are unique to a specific invocation of a macro. For
    example, had `NotTarget` been a local symbol in the preceding `JZC` macro invocations,
    the program would have compiled properly because HLA treats each occurrence of
    `NotTarget` as a unique symbol.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA does not automatically make internal macro symbol definitions local to
    that macro.^([[123](#ftn.CHP-9-FN-6)]) Instead, you must explicitly tell HLA which
    symbols must be local. You do this in a macro declaration using the following
    generic syntax:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The list of local names is a sequence of one or more HLA identifiers separated
    by commas. Whenever HLA encounters this name in a particular macro invocation,
    it automatically substitutes some unique name for that identifier. For each macro
    invocation, HLA substitutes a different name for the local symbol.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'You can correct the problem with the `JZC` macro by using the following macro
    code:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now whenever HLA processes this macro it will automatically associate a unique
    symbol with each occurrence of `NotTarget`. This will prevent the duplicate-symbol
    error that occurs if you do not declare `NotTarget` as a local symbol.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: HLA implements local symbols by substituting a symbol like `_`*`nnnn`*`_` (where
    *`nnnn`* is a four-digit hexadecimal number) wherever the local symbol appears
    in a macro invocation. For example, a macro invocation of the form `JZC(` *`SomeLabel`*
    `);` might expand to
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: For each local symbol appearing within a macro expansion, HLA will generate
    a unique temporary identifier by simply incrementing this numeric value for each
    new local symbol it needs. As long as you do not explicitly create labels of the
    form `_`*`nnnn`*`_`*`Text`*`_` (where *`nnnn`* is a hexadecimal value), there
    will never be a conflict in your program. HLA explicitly reserves all symbols
    that begin and end with a single underscore for its own private use (and for use
    by the HLA Standard Library). As long as you honor this restriction, there should
    be no conflicts between HLA local symbol generation and labels in your own programs
    because all HLA-generated symbols begin and end with a single underscore.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA implements local symbols by effectively converting that local symbol to
    a text constant that expands to the unique symbol HLA generates for the local
    label. That is, HLA effectively treats local symbol declarations as indicated
    by the following example:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Whenever HLA expands this macro it will substitute `_010A_`*`Text`*`_` for each
    occurrence of `NotTarget` it encounters in the expansion. This analogy isn't perfect
    because the text symbol `NotTarget` in this example is still accessible after
    the macro expansion, whereas this is not the case when defining local symbols
    within a macro. But this does give you an idea of how HLA implements local symbols.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.4 Macros as Compile-Time Procedures
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although programmers typically use macros to expand to some sequence of machine
    instructions, there is absolutely no requirement that a macro body contain any
    executable instructions. Indeed, many macros contain only compile-time language
    statements (for example, `#if`, `#while`, `#for`, `?` assignments, and the like).
    By placing only compile-time language statements in the body of a macro, you can
    effectively write compile-time procedures and functions using macros.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `unique` macro is a good example of a compile-time function that
    returns a string result. Consider the definition of this macro:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Whenever your code references this macro, HLA replaces the macro invocation
    with the text `@string(theSym)`, which, of course, expands to some string like
    `_021F_`*`Text`*`_.` Therefore, you can think of this macro as a compile-time
    function that returns a string result.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Be careful that you don't take the function analogy too far. Remember, macros
    always expand to their body text at the point of invocation. Some expansions may
    not be legal at any arbitrary point in your programs. Fortunately, most compile-time
    statements are legal anywhere whitespace is legal in your programs. Therefore,
    macros behave as you would expect functions or procedures to behave during the
    execution of your compile-time programs.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the only difference between a procedure and a function is that a
    function returns some explicit value, while procedures simply do some activity.
    There is no special syntax for specifying a compile-time function return value.
    As the example above indicates, simply specifying the value you wish to return
    as a statement in the macro body suffices. A compile-time procedure, on the other
    hand, would not contain any non-compile-time language statements that expand into
    some sort of data during macro invocation.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.5 Simulating Function Overloading with Macros
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C++ language supports a nifty feature known as *function overloading*. Function
    overloading lets you write several different functions or procedures that all
    have the same name. The difference between these functions is the types of their
    parameters or the number of parameters. A procedure declaration is unique in C++
    if it has a different number of parameters than other functions with the same
    name or if the types of its parameters differ from other functions with the same
    name. HLA does not directly support procedure overloading, but you can use macros
    to achieve the same result. This section explains how to use HLA's macros and
    the compile-time language to achieve function/procedure overloading.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'One good use for procedure overloading is to reduce the number of Standard
    Library routines you must remember how to use. For example, the HLA Standard Library
    provides five different "puti" routines that output an integer value: `stdout.puti128`,
    `stdout.puti64`, `stdout.puti32`, `stdout.puti16`, and `stdout.puti8`. The different
    routines, as their names suggest, output integer values according to the size
    of their integer parameter. In the C++ language (or another other language supporting
    procedure/function overloading) the engineer designing the input routines would
    probably have chosen to name them all `stdout.puti` and leave it up to the compiler
    to select the appropriate one based on the operand size.^([[124](#ftn.CHP-9-FN-7)])
    The macro in [Example 9-5](ch09s08.html#simple_procedure_overloading_based_on_op
    "Example 9-5. Simple procedure overloading based on operand size") demonstrates
    how to do this in HLA using the compile-time language to figure out the size of
    the parameter operand.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-5. Simple procedure overloading based on operand size
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The example above simply tests the size of the operand to determine which output
    routine to use. You can use other HLA compile-time functions, such as `@typename`,
    to do more sophisticated processing. Consider the program in [Example 9-6](ch09s08.html#procedure_overloading_based_on_operand_t
    "Example 9-6. Procedure overloading based on operand type"), which demonstrates
    a macro that overloads `stdout.puti32`, `stdout.putu32`, and `stdout.putd` depending
    on the type of the operand.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-6. Procedure overloading based on operand type
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You can easily extend this macro to output 8- and 16-bit operands as well as
    32-bit operands. That is left as an exercise for the reader.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: The number of actual parameters is another way to resolve which overloaded procedure
    to call. If you specify a variable number of macro parameters (using the `[ ]`
    syntax; see the discussion in [9.8.2.2 Macros with a Variable Number of Parameters](ch09s08.html#macros_with_a_variable_number_of_paramet
    "9.8.2.2 Macros with a Variable Number of Parameters")), you can use the `@elements`
    compile-time function to determine exactly how many parameters are present and
    call the appropriate routine. The sample in [Example 9-7](ch09s08.html#using_the_number_of_parameters_to_resolv
    "Example 9-7. Using the number of parameters to resolve overloaded procedures")
    uses this trick to determine whether it should call `stdout.puti32` or `stdout.puti32Size`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-7. Using the number of parameters to resolve overloaded procedures
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: All the examples up to this point provide procedure overloading for Standard
    Library routines (specifically, the integer output routines). Of course, you are
    not limited to overloading procedures in the HLA Standard Library. You can create
    your own overloaded procedures as well. All you have to do is write a set of procedures,
    all with unique names, and then use a single macro to decide which routine to
    actually call based on the macro's parameters. Rather than call the individual
    routines, invoke the common macro and let it decide which procedure to actually
    call.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: ^([[122](#CHP-9-FN-5)]) To differentiate between macros and procedures, this
    text will use the term *invocation* when describing the use of a macro and *call*
    when describing the use of a procedure.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: ^([[123](#CHP-9-FN-6)]) Sometimes you actually want the symbols to be global.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: ^([[124](#CHP-9-FN-7)]) By the way, the HLA Standard Library does this as well.
    Although it doesn't provide `stdout.puti`, it does provide `stdout.put`, which
    will choose an appropriate output routine based upon the parameter's type. This
    is a bit more flexible than a `puti` routine.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 9.9 Writing Compile-Time "Programs"
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HLA compile-time language provides a powerful facility with which to write
    "programs" that execute while HLA is compiling your assembly language programs.
    Although it is possible to write some general-purpose programs using the HLA compile-time
    language, the real purpose of the HLA compile-time language is to allow you to
    write short programs *that write other programs*. In particular, the primary purpose
    of the HLA compile-time language is to automate the creation of large or complex
    assembly language sequences. The following subsections provide some simple examples
    of such compile-time programs.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 9.9.1 Constructing Data Tables at Compile Time
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, this book suggested that you could write programs to generate large,
    complex lookup tables for your assembly language programs (see the discussion
    of tables in [8.4.3 Generating Tables](ch08s04.html#generating_tables "8.4.3 Generating
    Tables")). [Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC") provides examples
    in HLA but suggests that writing a separate program is unnecessary. This is true;
    you can generate most lookup tables you'll need using nothing more than the HLA
    compile-time language facilities. Indeed, filling in table entries is one of the
    principle uses of the HLA compile-time language. In this section we will take
    a look at using the HLA compile-time language to construct data tables during
    compilation.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: In [8.4.3 Generating Tables](ch08s04.html#generating_tables "8.4.3 Generating
    Tables"), you saw an example of an HLA program that writes a text file containing
    a lookup table for the trigonometric sine function. The table contains 360 entries
    with the index into the table specifying an angle in degrees. Each `int32` entry
    in the table contains the value sin(*angle* )*1,000 where *angle* is equal to
    the index into the table. [8.4.3 Generating Tables](ch08s04.html#generating_tables
    "8.4.3 Generating Tables") suggests running this program and then including the
    text output from that program into the actual program that used the resulting
    table. You can avoid much of this work by using the compile-time language. The
    HLA program in [Example 9-8](ch09s09.html#generating_a_sine_lookup_table_with_the
    "Example 9-8. Generating a sine lookup table with the compile-time language")
    includes a short compile-time code fragment that constructs this table of sines
    directly.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-8. Generating a sine lookup table with the compile-time language
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Another common use for the compile-time language is to build ASCII character
    lookup tables for use by the `xlat` instruction at runtime. Common examples include
    lookup tables for alphabetic case manipulation. The program in [Example 9-9](ch09s09.html#generating_case-conversion_tables_with_t
    "Example 9-9. Generating case-conversion tables with the compile-time language")
    demonstrates how to construct an uppercase conversion table and a lowercase conversion
    table.^([[125](#ftn.CHP-9-FN-8)]) Note the use of a macro as a compile-time procedure
    to reduce the complexity of the table-generating code:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-9. Generating case-conversion tables with the compile-time language
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: One important thing to note about this example is the fact that a semicolon
    does not follow the `emitCharRange` macro invocations. Macro invocations do not
    require a closing semicolon. Often, it is legal to go ahead and add one to the
    end of the macro invocation because HLA is normally very forgiving about having
    extra semicolons inserted into the code. In this case, however, the extra semicolons
    are illegal because they would appear between adjacent entries in the `TOlc` and
    `toUC` tables. Keep in mind that macro invocations don't require a semicolon,
    especially when using macro invocations as compile-time procedures.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 9.9.2 Unrolling Loops
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the chapter on low-level control structures, this text points out that you
    can unravel loops to improve the performance of certain assembly language programs.
    One problem with unraveling, or unrolling, loops is that you may need to do a
    lot of extra typing, especially if there are many loop iterations. Fortunately,
    HLA's compile-time language facilities, especially the `#while` and `#for` loops,
    come to the rescue. With a small amount of extra typing plus one copy of the loop
    body, you can unroll a loop as many times as you please.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: If you simply want to repeat the same exact code sequence some number of times,
    unrolling the code is especially trivial. All you have to do is wrap an HLA `#for..#endfor`
    loop around the sequence and count off a `val` object the specified number of
    times. For example, if you wanted to print `Hello World` 10 times, you could encode
    this as follows.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Although the code above looks very similar to an HLA `for` loop you could write
    in your program, remember the fundamental difference: The preceding code simply
    consists of 10 straight `stdout.put` calls in the program. Were you to encode
    this using an HLA `for` loop, there would be only one call to `stdout.put` and
    lots of additional logic to loop back and execute that single call 10 times.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Unrolling loops becomes slightly more complicated if any instructions in that
    loop refer to the value of a loop control variable or another value, which changes
    with each iteration of the loop. A typical example is a loop that zeros the elements
    of an integer array:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In this code fragment the loop uses the value of the loop control variable
    (in EBX) to index into array. Simply copying `mov( eax, array[ ebx*4 ]);` 20 times
    is not the proper way to unroll this loop. You must substitute an appropriate
    constant index in the range 0..76 (the corresponding loop indices, times 4) in
    place of `ebx*4` in this example. Correctly unrolling this loop should produce
    the following code sequence:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can easily do this using the following compile-time code sequence:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If the statements in a loop make use of the loop control variable's value, it
    is only possible to unroll such loops if those values are known at compile-time.
    You cannot unroll loops when user input (or other runtime information) controls
    the number of iterations.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: ^([[125](#CHP-9-FN-8)]) Note that on modern processors, using a lookup table
    is probably not the most efficient way to convert between alphabetic cases. However,
    this is just an example of filling in the table using the compile-time language.
    The principles are correct, even if the code is not exactly the best it could
    be.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 9.10 Using Macros in Different Source Files
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike procedures, macros do not have a fixed piece of code at some address
    in memory. Therefore, you cannot create external macros and link them with other
    modules in your program. However, it is very easy to share macros with different
    source files: Just put the macros you wish to reuse in a header file and include
    that file using the `#include` directive. You can make the macro available to
    any source file you choose using this simple trick.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 9.11 For More Information
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this chapter has spent a considerable amount of time describing various
    features of HLA's macro support and compile-time language features, the truth
    is this chapter has barely described what's possible with HLA. Indeed, this chapter
    made the claim that HLA's macro facilities are far more powerful than those provided
    by other assemblers; however, this chapter doesn't do HLA's macros justice. If
    you've ever used a language with decent macro facilities, you're probably wondering,
    "What's the big deal?" Well, the really sophisticated stuff is beyond the scope
    of this chapter. If you're interested in learning more about HLA's powerful macro
    facilities, please consult the HLA reference manual and the electronic editions
    of *The Art of Assembly Language* at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/). You'll discover that
    it's actually possible to create your own high-level languages using HLA's macro
    facilities. However, this chapter does not assume the reader has the prerequisite
    knowledge to do that type of programming (yet!), so this chapter defers that discussion
    to the material that you'll also find on the websites.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
