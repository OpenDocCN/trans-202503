- en: Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![MACROS AND THE HLA COMPILE-TIME LANGUAGE](tagoreillycom20100401nostarchimages577853.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses the HLA compile-time language. This discussion includes
    what is perhaps the most important component of the HLA compile-time language,
    *macros*. Many people judge the power of an assembler by the power of its macro
    processing capabilities. If you happen to be one of these people, you'll probably
    agree that HLA is one of the more powerful assemblers on the planet after reading
    this chapter, because HLA has one of the most powerful macro processing facilities
    of any computer language processing system.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Introduction to the Compile-Time Language (CTL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HLA is actually two languages rolled into a single program. The *runtime language*
    is the standard 80x86/HLA assembly language you've been reading about in all the
    previous chapters. This is called the runtime language because the programs you
    write execute when you run the executable file. HLA contains an interpreter for
    a second language, the HLA compile-time language (CTL), which executes programs
    while HLA is compiling a program. The source code for the CTL program is embedded
    in an HLA assembly language source file; that is, HLA source files contain instructions
    for both the HLA CTL and the runtime program. HLA executes the CTL program during
    compilation. Once HLA completes compilation, the CTL program terminates; the CTL
    application is not a part of the runtime executable that HLA emits, although the
    CTL application can *write* part of the runtime program for you, and, in fact,
    this is the major purpose of the CTL (see [Figure 9-1](ch09.html#compile-time_versus_runtime_execution
    "Figure 9-1. Compile-time versus runtime execution")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Compile-time versus runtime execution](tagoreillycom20100401nostarchimages578063.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1. Compile-time versus runtime execution
  prefs: []
  type: TYPE_NORMAL
- en: 'It may seem confusing to have two separate languages built into the same compiler.
    Perhaps you''re even questioning why anyone would need a compile-time language.
    To understand the benefits of a compile-time language, consider the following
    statement that you should be very comfortable with at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement is neither a statement in the HLA language nor a call to some
    HLA Standard Library procedure. Instead, `stdout.put` is actually a statement
    in a CTL application provided by the HLA Standard Library. The `stdout.put` "application"
    processes the parameter list and generates calls to various other Standard Library
    procedures; it chooses the procedure to call based on the type of the parameter
    it is currently processing. For example, the `stdout.put` "application" above
    will emit the following statements to the runtime executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly the `stdout.put` statement is much easier to read and write than the
    sequence of statements that `stdout.put` emits in response to its parameter list.
    This is one of the more powerful capabilities of the HLA programming language:
    the ability to modify the language to simplify common programming tasks. Printing
    different data objects in a sequential fashion is a common task; the `stdout.put`
    "application" greatly simplifies this process.'
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library is *loaded* with many HLA CTL examples. In addition
    to Standard Library usage, the HLA CTL is quite adept at handling "one-use" applications.
    A classic example is filling in the data for a lookup table. [Chapter 8](ch08.html
    "Chapter 8. ADVANCED ARITHMETIC") noted that it is possible to construct lookup
    tables using the HLA CTL. Not only is this possible, but it is often far less
    work to use the HLA CTL to construct these tables.
  prefs: []
  type: TYPE_NORMAL
- en: Although the CTL itself is relatively inefficient and you would not normally
    use it to write end-user applications, it does maximize the use of your time.
    By learning how to use the HLA CTL and applying it properly, you can develop assembly
    language applications as rapidly as high-level language applications (even faster
    because HLA's CTL lets you create very high-level-language constructs).
  prefs: []
  type: TYPE_NORMAL
- en: '9.2 The #print and #error Statements'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may recall that [Chapter 1](ch01.html "Chapter 1. HELLO, WORLD OF ASSEMBLY
    LANGUAGE") began with the typical first program most people write when learning
    a new language, the "Hello, world!" program. It is only fitting for this chapter
    to present that same program when discussing the second language of this book.
    [Example 9-1](ch09s02.html#the_ctl_quotation_mark_hello_comma_world "Example 9-1. The
    CTL "Hello, world!" program") provides the basic "Hello, world!" program written
    in the HLA compile-time language.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-1. The CTL "Hello, world!" program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The only CTL statement in this program is the `#print` statement. The remaining
    lines are needed just to keep the compiler happy (though we could have reduced
    the overhead to two lines by using a `unit` rather than a `program` declaration).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#print` statement displays the textual representation of its argument
    list during the compilation of an HLA program. Therefore, if you compile the program
    above with the command `hla ctlHW.hla`, the HLA compiler will immediately print
    the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is a big difference between the following two statements in
    an HLA source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first statement prints `Hello World` (and a new line) during the compilation
    process. This first statement does not have any effect on the executable program.
    The second line doesn't affect the compilation process (other than the emission
    of code to the executable file). However, when you run the executable file, the
    second statement prints the string `Hello World` followed by a newline sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HLA/CTL `#print` statement uses the following basic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that a semicolon does not terminate this statement. Semicolons terminate
    runtime statements; they generally do not terminate compile-time statements (there
    is one big exception, as you will see a little later).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#print` statement must have at least one operand; if multiple operands
    appear in the parameter list, you must separate each operand with a comma ( just
    like `stdout.put`). If a particular operand is not a string constant, HLA will
    translate that constant to its corresponding string representation and print that
    string. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You may specify named symbolic constants and constant expressions. However,
    all `#print` operands must be constants (either literal constants or constants
    you define in the `const` or `val` sections), and those constants must be defined
    before you use them in the `#print` statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The HLA `#print` statement is particularly invaluable for debugging CTL programs.
    This statement is also useful for displaying the progress of the compilation and
    displaying assumptions and default actions that take place during compilation.
    Other than displaying the text associated with the `#print` parameter list, the
    `#print` statement has no effect on the compilation of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#error` statement allows a single-string constant operand. Like `#print`,
    this statement will display the string to the console during compilation. However,
    the `#error` statement treats the string as an error message and displays the
    string as part of an HLA error diagnostic. Further, the `#error` statement increments
    the error count, and this will cause HLA to stop the compilation (without assembling
    or linking) after processing the current source file. You would normally use the
    `#error` statement to display an error message during compilation if your CTL
    code discovers something that prevents it from creating valid code. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Like the `#print` statement, the `#error` statement does not end with a semicolon.
    Although `#error` allows only a single-string operand, it's very easy to print
    other values by using the compile-time string concatenation operator and several
    of the HLA built-in compile-time functions. You'll learn about these a little
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 Compile-Time Constants and Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as the runtime language does, the compile-time language supports constants
    and variables. You declare compile-time constants in the `const` section, just
    as you would with the runtime language. You declare compile-time variables in
    the `val` section. Objects you declare in the `val` section are constants to the
    runtime language, but remember that you can change the value of an object you
    declare in the `val` section throughout the source file. Hence the term "compile-time
    variable." See [Chapter 4](ch04.html "Chapter 4. CONSTANTS, VARIABLES, AND DATA
    TYPES") for more details.
  prefs: []
  type: TYPE_NORMAL
- en: The CTL assignment statement (`?`) computes the value of the constant expression
    to the right of the assignment operator (`:=`) and stores the result into the
    `val` object name appearing immediately to the left of the assignment operator.^([[118](#ftn.CHP-9-FN-1)])
    This example code may appear anywhere in your HLA source file, not just in the
    `val` section of the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[118](#CHP-9-FN-1)]) If the identifier to the left of the assignment operator
    is undefined, HLA will automatically declare this object at the current scope
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Compile-Time Expressions and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HLA CTL supports constant expressions in the CTL assignment statement. Unlike
    the runtime language (where you have to translate algebraic notation into a sequence
    of machine instructions), the HLA CTL allows a full set of arithmetic operations
    using familiar expression syntax. This gives the HLA CTL considerable power, especially
    when combined with the built-in compile-time functions the next section discusses.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-1](ch09s04.html#compile-time_operators "Table 9-1. Compile-Time Operators")
    and [Table 9-2](ch09s04.html#operator_precedence_and_associativity "Table 9-2. Operator
    Precedence and Associativity") list operators that the HLA CTL supports in compile-time
    expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1. Compile-Time Operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator(s) | Operand Types^([[a](#ftn.CHP-9-TFN-1)]) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-` (unary) | numeric | Negates the specific numeric value (int, uns, real).
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | cset | Returns the complement of the specified character set. |'
  prefs: []
  type: TYPE_TB
- en: '| `!` (unary) | integer | Inverts all the bits in the operand (bitwise `not`).
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | boolean | Boolean `not` of the operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | numericL * numericR | Multiplies the two operands. |'
  prefs: []
  type: TYPE_TB
- en: '|   | csetL * csetR | Computes the intersection of the two sets. |'
  prefs: []
  type: TYPE_TB
- en: '| `div` | integerL divintegerR | Computes the integer quotient of the two integer
    (int/uns/dword) operands. |'
  prefs: []
  type: TYPE_TB
- en: '| `mod` | integerL modintegerR | Computes the remainder of the division of
    the two integer (int/uns/dword) operands. |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | numericL / numericR | Computes the real quotient of the two numeric
    operands. Returns a real result even if both operands are integers. |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | integerL << integerR | Shifts integerL operand to the left the number
    of bits specified by the integerR operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | integerL >> integerR | Shifts integerL operand to the right the number
    of bits specified by the integerR operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | numericL + numericR | Adds the two numeric operands. |'
  prefs: []
  type: TYPE_TB
- en: '|   | csetL + csetR | Computes the union of the two sets. |'
  prefs: []
  type: TYPE_TB
- en: '|   | strL + strR | Concatenates the two strings. |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | numericL numericR | Computes the difference between numericL and numericR.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | csetL - csetR | Computes the set difference of csetL - csetR. |'
  prefs: []
  type: TYPE_TB
- en: '| `=` or `==` | numericL = numericR | Returns true if the two operands have
    the same value. |'
  prefs: []
  type: TYPE_TB
- en: '|   | csetL = csetR | Returns true if the two sets are equal. |'
  prefs: []
  type: TYPE_TB
- en: '|   | strL = strR | Returns true if the two strings/chars are equal. |'
  prefs: []
  type: TYPE_TB
- en: '|   | typeL = typeR | Returns true if the two values are equal. They must be
    the same type. |'
  prefs: []
  type: TYPE_TB
- en: '| `<>` or `!=` | typeL <> typeR (sameas !=) | Returns false if the two (compatible)
    operands are not equal to one another (numeric, cset, or string). |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | numericL < numericR | Returns true if numericL is less than numericR.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | csetL < csetR | Returns true if csetL is a proper subset of csetR. |'
  prefs: []
  type: TYPE_TB
- en: '|   | strL < strR | Returns true if strL is less than strR. |'
  prefs: []
  type: TYPE_TB
- en: '|   | booleanL < booleanR | Returns true if the left operand is less than the
    right operand (note: false < true). |'
  prefs: []
  type: TYPE_TB
- en: '|   | enumL < enumR | Returns true if enumL appears in the same enumlist as
    enumR and enumL appears first. |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Same as < | Returns true if the left operand is less than or equal
    to the right operand. For character sets, this means that the left operand is
    a subset of the right operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Same as < | Returns true if the left operand is greater than the right
    operand. For character sets, this means that the left operand is a proper superset
    of the right operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Same as <= | Returns true if the left operand is greater than or equal
    to the right operand. For character sets, this means that the left operand is
    a superset of the right operand. |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | integerL & integerR | Computes the bitwise `and` of the two operands.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | booleanL & booleanR | Computes the logical `and` of the two operands.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | integerL &#124; integerR | Computes the bitwise `or` of the two
    operands. |'
  prefs: []
  type: TYPE_TB
- en: '|   | booleanL &#124; booleanR | Computes the logical `or` of the two operands.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | integerL ^ integerR | Computes the bitwise `xor` of the two operands.
    |'
  prefs: []
  type: TYPE_TB
- en: '|   | booleanL ^ booleanR | Computes the logical `xor` of the two operands.
    Note that this is equivalent to `booleanL <> booleanR`. |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | charL in csetR | Returns true if charL is a member of csetR. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[a](#CHP-9-TFN-1)]) Type numeric is {int*XX*, uns*XX*, byte, word, dword,
    and real*XX*} values. Type cset is a character set operand. Type integer is {int*XX*,
    uns*XX*, byte, word, dword}. Type str is any string or character value. Type indicates
    an arbitrary HLA type. Other types specify an explicit HLA data type.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-2. Operator Precedence and Associativity
  prefs: []
  type: TYPE_NORMAL
- en: '| Associativity | Precedence (Highest to Lowest) | Operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Right to left | 6 | `!` (unary) |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `-` (unary) |'
  prefs: []
  type: TYPE_TB
- en: '| Left to right | 5 | `*` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `div` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `mod` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `/` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `>>` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `<<` |'
  prefs: []
  type: TYPE_TB
- en: '| Left to right | 4 | `+` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `-` |'
  prefs: []
  type: TYPE_TB
- en: '| Left to right | 3 | `=` or `==` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `<>` or `!=` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `<` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `<=` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `>` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `>=` |'
  prefs: []
  type: TYPE_TB
- en: '| Left to right | 2 | `&` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `&#124;` |'
  prefs: []
  type: TYPE_TB
- en: '|   |   | `^` |'
  prefs: []
  type: TYPE_TB
- en: '| Nonassociative | 1 | `in` |'
  prefs: []
  type: TYPE_TB
- en: Of course, you can always override the default precedence and associativity
    of an operator by using parentheses in an expression.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5 Compile-Time Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HLA provides a wide range of compile-time functions you can use. These functions
    compute values during compilation the same way a high-level-language function
    computes values at runtime. The HLA compile-time language includes a wide variety
    of numeric, string, and symbol table functions that help you write sophisticated
    compile-time programs.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the names of the built-in compile-time functions begin with the special
    symbol `@` and have names like `@sin` or `@length`. The use of these special identifiers
    prevents conflicts with common names you might want to use in your own programs
    (like `length`). The remaining compile-time functions (those that do not begin
    with `@`) are typically data conversion functions that use type names like `int8`
    and `real64`. You can even create your own compile-time functions using macros
    (which is discussed in [9.8 Macros (Compile-Time Procedures)](ch09s08.html "9.8
    Macros (Compile-Time Procedures)")).
  prefs: []
  type: TYPE_NORMAL
- en: HLA organizes the compile-time functions into various classes depending on the
    type of operation. For example, there are functions that convert constants from
    one form to another (such as string-to-integer conversion), there are many useful
    string functions, and HLA provides a full set of compile-time numeric functions.
  prefs: []
  type: TYPE_NORMAL
- en: The complete list of HLA compile-time functions is too lengthy to present here.
    Instead, a complete description of each of the compile-time objects and functions
    appears in the HLA reference manual (found at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/)); this section highlights
    a few of the functions in order to demonstrate their use. Later sections in this
    chapter, as well as future chapters, make extensive use of the various compile-time
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most important concept to understand about the compile-time functions
    is that they are equivalent to constants in your assembly language code (i.e.,
    the runtime program). For example, the compile-time function invocation `@sin(3.1415265358979328)`
    is roughly equivalent to specifying 0.0 at that point in your program.^([[119](#ftn.CHP-9-FN-2)])
    A function invocation like `@sin( x )` is legal only if `x` is a constant with
    a previous declaration at the point of the function call in the source file. In
    particular, `x` cannot be a runtime variable or other object whose value exists
    at runtime rather than compile time. Because HLA replaces compile-time function
    calls with their constant result, you may ask why you should even bother with
    compile-time functions. After all, it's probably more convenient to type *0.0*
    than it is to type *@sin(3.1415265358979328)* in your program. However, compile-time
    functions are handy for generating lookup tables and other mathematical results
    that may change whenever you change a `const` value in your program. [9.9 Writing
    Compile-Time "Programs"](ch09s09.html "9.9 Writing Compile-Time "Programs"") will
    explore this idea further.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.1 Type-Conversion Compile-Time Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Probably the most commonly used compile-time functions are the type-conversion
    functions. These functions take a single parameter of one type and convert that
    information to some specified type. These functions use several of the HLA built-in
    data type names as the function names. Functions in this category are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int8`, `int16`, `int32`, `int64`, and `int128`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uns8`, `uns16`, `uns32`, `uns64`, and `uns128`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte`, `word`, `dword`, `qword`, and `lword` (these are effectively equivalent
    to `uns8`, `uns16`, `uns32`, `uns64`, and `uns128`, respectively)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`real32`, `real64`, and `real80`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These functions accept a single constant expression parameter and, if at all
    reasonable, convert that expression''s value to the type specified by the type
    name. For example, the following function call returns the value −128 because
    it converts the string constant to the corresponding integer value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Certain conversions don't make sense or have restrictions associated with them.
    For example, the `boolean` function will accept a string parameter, but that string
    must be "true" or "false" or the function will generate a compile-time error.
    Likewise, the numeric conversion functions (e.g., `int8`) allow a string operand,
    but the string operand must represent a legal numeric value. Some conversions
    (for example, `int8` with a character set parameter) simply don't make sense and
    are always illegal.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most useful functions in this category is the `string` function.
    This function accepts nearly all the constant expression types, and it generates
    a string that represents the parameter''s data. For example, the invocation `string(
    128 )` produces the string `128` as the return result. This function is handy
    when you have a value that you wish to use where HLA requires a string. For example,
    the `#error` compile-time statement allows only a single-string operand. You can
    use the string function and the string concatenation operator (`+`) to easily
    get around this limitation. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that these type functions actually perform a conversion. This means that
    the bit pattern these functions return may be considerably different than the
    bit pattern you pass as an argument. For example, consider the following invocation
    of the `real32` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it turns out that $3F80_0000 is the hexadecimal equivalent of the `real32`
    value 1.0\. However, the preceding function invocation does not return 1.0; instead
    it attempts to convert the integer value $3F80_0000 (1,065,353,216) to a `real32`
    value but fails because the value is too large to exactly represent using a `real32`
    object. Contrast this with the following constant function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This CTL function invocation returns the character `A` (because 65 is the ASCII
    code for `A`). Notice how the `char` function simply uses the bit pattern of the
    integer argument you pass it as an ASCII code, whereas the `real32` function attempts
    to translate the integer argument to a floating-point value. Although the semantics
    are quite different between these two functions, the bottom line is that they
    tend to do the intuitive operation, even at the expense of consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, however, you might not want these functions to do the "intuitive"
    thing. For example, you might want the `real32` function to simply treat the bit
    pattern you pass it as a `real32` value. To handle this situation, HLA provides
    a second set of type functions, which are simply the type names with an `@` prefix
    that treat the argument as a bit pattern of the final type. So if you really want
    to produce 1.0 from $3F80_0000, then you could use the following function invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Generally, type coercion of this form is somewhat advanced in the compile-time
    language, so you'll probably not use it very often. However, when it is needed,
    it's nice to have around.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.2 Numeric Compile-Time Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The functions in this category perform standard mathematical operations at
    compile time. These functions are handy for generating lookup tables and "parameterizing"
    your source code by recalculating functions on constants defined at the beginning
    of your program. Functions in this category include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`@abs(` *`n`* `)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Absolute value of numeric argument |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ceil(` *`r`* `), @floor(` *`r`* `)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Extract integer component of floating-point value |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`@sin(` *`r`* `)`, `@cos(` *`r`* `)`, `@tan(` *`r`* `)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Standard trig functions |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`@exp(` *`r`* `)`, `@log(` *`r`* `)`, `@log10(` *`r`* `)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Standard log/exponent functions |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`@min(` *`list`* `)`, `@max(` *`list`* `)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Return min/max value from a list of values |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`@random`, `@randomize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Return a pseudo-random `int32` value |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`@sqrt(` *`n`* `)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Computes the square root of its numeric argument (real result) |'
  prefs: []
  type: TYPE_TB
- en: See the HLA reference manual at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/) for more details on these
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.3 Character-Classification Compile-Time Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The functions in this group all return a boolean result. They test a character
    (or all the characters in a string) to see if it belongs to a certain class of
    characters. The functions in this category include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@isAlpha(` *`c`* `)`, `@isAlphanum(` *`c`* `)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@isDigit(` *`c`* `)`, `@isxDigit(` *`c`* `)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@isLower(` *`c`* `)`, `@isUpper(` *`c`* `)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@isSpace(` *`c`* `)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these character-classification functions, the HLA language provides
    a set of pattern-matching functions that you can also use to classify character
    and string data. See the HLA reference manual at for the discussion of these routines.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.4 Compile-Time String Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functions in this category operate on string parameters. Most return a string
    result, although a few (for example, `@length` and `@index`) return integer results.
    These functions do not directly affect the values of their parameters; instead,
    they return an appropriate result that you can assign back to the parameter if
    you wish to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '`@delete`, `@insert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@index`, `@rindex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@length`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@lowercase`, `@uppercase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@strbrk`, `@strspan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@strset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@substr`, `@tokenize`, `@trim`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For specific details concerning these functions, their parameters, and their
    types, see the HLA reference manual. Note that these are the compile-time equivalents
    of many of the string functions found in the HLA Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@length` function deserves a special discussion because it is probably
    the most popular function in this category. It returns an `uns32` constant specifying
    the number of characters found in its string parameter. The syntax is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: where *`string_expression`* represents any compile-time string expression. As
    noted, this function returns the length, in characters, of the specified expression.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.5 Compile-Time Symbol Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During compilation HLA maintains an internal database known as the *symbol table*.
    The symbol table contains lots of useful information concerning all the identifiers
    you've defined up to a given point in the program. In order to generate machine
    code output, HLA needs to query this database to determine how to treat certain
    symbols. In your compile-time programs, it is often necessary to query the symbol
    table to determine how to handle an identifier or expression in your code. The
    HLA compile-time symbol-information functions handle this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the compile-time symbol-information functions are well beyond the scope
    of this text. This chapter will present a few of the functions. For a complete
    list of the compile-time symbol-table functions, see the HLA reference manual.
    The functions we will consider in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@size`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@defined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@typeName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@elements`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@elementSize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without question, the `@size` function is probably the most important function
    in this group. Indeed, previous chapters have made use of this function already.
    The `@size` function requires a single HLA identifier or constant expression as
    a parameter. It returns the size, in bytes, of the data type of that object (or
    expression). If you supply an identifier, it can be a constant, type, or variable
    identifier. As you've seen in previous chapters, this function is invaluable for
    allocating storage via `mem.alloc` and allocating storage for arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very useful function in this group is the `@defined` function. This
    function accepts a single HLA identifier as a parameter. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This function returns true if the identifier is defined at that point in the
    program; it returns false otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The `@typeName` function returns a string specifying the type name of the identifier
    or expression you supply as a parameter. For example, if `i32` is an `int32` object,
    then `@typeName( i32 )` returns the string `int32`. This function is useful for
    testing the types of objects you are processing in your compile-time programs.
  prefs: []
  type: TYPE_NORMAL
- en: The `@elements` function requires an array identifier or expression. It returns
    the total number of array elements as the function result. Note that for multidimensional
    arrays this function returns the product of all the array dimensions.^([[120](#ftn.CHP-9-FN-3)])
  prefs: []
  type: TYPE_NORMAL
- en: The `@elementSize` function returns the size, in bytes, of an element of an
    array whose name you pass as a parameter. This function is extremely valuable
    for computing indices into an array (that is, this function computes the `element_size`
    component of the array index calculation; see [Chapter 4](ch04.html "Chapter 4. CONSTANTS,
    VARIABLES, AND DATA TYPES") for more details).
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.6 Miscellaneous Compile-Time Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HLA compile-time language contains several additional functions that don''t
    fall into one of the categories above. Some of the more useful miscellaneous functions
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@odd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@lineNumber`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@odd` function takes an ordinal value (i.e., nonreal numeric or character)
    as a parameter and returns true if the value is odd, false if it is even. The
    `@lineNumber` function requires no parameters; it returns the current line number
    in the source file. This function is quite useful for debugging compile-time (and
    runtime!) programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@text` function is probably the most useful function in this group. It
    requires a single-string parameter. It expands that string as text in place of
    the `@text` function call. This function is quite useful in conjunction with the
    compile-time string-processing functions. You can build an instruction (or a portion
    of an instruction) using the string-manipulation functions and then convert that
    string to program source code using the `@text` function. The following is a trivial
    example of this function in operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sequence compiles to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 9.5.7 Compile-Time Type Conversions of Text Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you create a text constant in your program, it''s difficult to manipulate
    that object. The following example demonstrates a programmer''s desire to change
    the definition of a text symbol within a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic idea in this example is that the symbol `t` expands to `stdout.put`
    in the first half of the code, and it expands to `fileio.put` in the second half
    of the program. Unfortunately, this simple example will not work. The problem
    is that HLA will expand a text symbol in place almost anywhere it finds that symbol.
    This includes occurrences of `t` within a `?` statement. Therefore, the previous
    code expands to the following (incorrect) text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: HLA doesn't know how to deal with this `?` statement, so it generates a syntax
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'At times you may not want HLA to expand a text object. Your code may want to
    process the string data held by the text object. HLA provides a couple of ways
    to deal with these two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@string(` *`identifier`* `)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@toString:`*`identifier`*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `@string(` *`identifier`* `)`, HLA returns a string constant corresponding
    to the text data associated with the text object. In other words, this operator
    lets you treat a text object as though it were a string constant within an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the `@string` function converts a text object to a string constant,
    not a string identifier. Therefore, you cannot say something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This doesn't work because `@string(t)` replaces itself with the string constant
    associated with the text object `t`. Given the former assignment to `t`, this
    statement expands to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This statement is still illegal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@toString:`*`identifier`* operator comes to the rescue in this case. The
    `@toString:` operator requires a text object as the associated identifier. It
    converts this text object to a string object (still maintaining the same string
    data) and then returns the identifier. Because the identifier is now a string
    object, you can assign a value to it (and change its type to something else, for
    example, `text`, if that''s what you need). To achieve the original goal, therefore,
    you''d use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[119](#CHP-9-FN-2)]) Actually, because `@sin`'s parameter in this example
    is not exactly pi, you will get a small positive number instead of zero as the
    function result, but in theory you should get zero.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[120](#CHP-9-FN-3)]) There is an `@dim` function that returns an array specifying
    the bounds on each dimension of a multidimensional array. See the documentation
    at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/) or [http://www.artofasm.com/](http://www.artofasm.com/)
    for more details if you're interested in this function.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Conditional Compilation (Compile-Time Decisions)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HLA''s compile-time language provides an if statement, `#if`, that lets you
    make decisions at compile time. The `#if` statement has two main purposes: The
    traditional use of `#if` is to support *conditional compilation* (or *conditional
    assembly*), allowing you to include or exclude code during a compilation depending
    on the status of various symbols or constant values in your program. The second
    use of this statement is to support the standard if statement decision-making
    process in the HLA compile-time language. This section discusses these two uses
    for the HLA `#if` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest form of the HLA compile-time `#if` statement uses the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that you do not place semicolons after the `#endif` clause. If you place
    a semicolon after the `#endif`, it becomes part of the source code, and this would
    be identical to inserting that semicolon immediately before the next item in the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'At compile time, HLA evaluates the expression in the parentheses after the
    `#if`. This must be a constant expression, and its type must be boolean. If the
    expression evaluates true, HLA continues to process the text in the source file
    as though the `#if` statement was not present. However, if the expression evaluates
    false, HLA treats all the text between the `#if` and the corresponding `#endif`
    clause as though it were a comment (that is, it ignores this text), as shown in
    [Figure 9-2](ch09s06.html#operation_of_an_hla_compile-time_number "Figure 9-2. Operation
    of an HLA compile-time #if statement").'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operation of an HLA compile-time #if statement](tagoreillycom20100401nostarchimages578065.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2. Operation of an HLA compile-time `#if` statement
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that HLA''s constant expressions support a full expression syntax
    like you''d find in a high-level language like C or Pascal. The `#if` expression
    syntax is not limited to the syntax allowed by expressions in the HLA `if` statement.
    Therefore, it is perfectly reasonable to write fancy expressions like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Also keep in mind that the identifiers in a compile-time expression must all
    be `const` or `val` identifiers or an HLA compile-time function call (with appropriate
    parameters). In particular, remember that HLA evaluates these expressions at compile
    time so they cannot contain runtime variables.^([[121](#ftn.CHP-9-FN-4)]) HLA's
    compile-time language uses complete boolean evaluation, so any side effects that
    occur in the expression may produce undesired results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HLA `#if` statement supports optional `#elseif` and `#else` clauses that
    behave in the intuitive fashion. The complete syntax for the `#if` statement looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If the first boolean expression evaluates true, then HLA processes the text
    up to the `#elseif` clause. It then skips all text (that is, treats it like a
    comment) until it encounters the `#endif` clause. HLA continues processing the
    text after the `#endif` clause in the normal fashion.
  prefs: []
  type: TYPE_NORMAL
- en: If the first boolean expression above evaluates false, then HLA skips all the
    text until it encounters a `#elseif`, `#else`, or `#endif` clause. If it encounters
    a `#elseif` clause (as above), then HLA evaluates the boolean expression associated
    with that clause. If it evaluates true, HLA processes the text between the `#elseif`
    and the `#else` clauses (or to the `#endif` clause if the `#else` clause is not
    present). If, during the processing of this text, HLA encounters another `#elseif`
    or, as above, a `#else` clause, then HLA ignores all further text until it finds
    the corresponding `#endif`.
  prefs: []
  type: TYPE_NORMAL
- en: If both the first and second boolean expressions in the previous example evaluate
    false, HLA skips their associated text and begins processing the text in the `#else`
    clause. As you can see, the `#if` statement behaves in a relatively intuitive
    fashion once you understand how HLA "executes" the body of these statements; the
    `#if` statement processes the text or treats it as a comment, depending on the
    state of the boolean expression. Of course, you can create a nearly infinite variety
    of different `#if` statement sequences by including zero or more `#elseif` clauses
    and optionally supplying the `#else` clause. Because the construction is identical
    to the HLA `if..then..elseif..else..endif` statement, there is no need to elaborate
    further here.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very traditional use of conditional compilation is to develop software that
    you can easily configure for several different environments. For example, the
    `fcomip` instruction makes floating-point comparisons very easy, but this instruction
    is available only on Pentium Pro and later processors. If you want to use this
    instruction on the processors that support it and fall back to the standard floating-point
    comparison on the older processors, you would normally have to write two versions
    of the program—one with the `fcomip` instruction and one with the traditional
    floating-point comparison sequence. Unfortunately, maintaining two different source
    files (one for newer processors and one for older processors) is very difficult.
    Most engineers prefer to use conditional compilation to embed the separate sequences
    in the same source file. The following example demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As currently written, this code fragment will compile the three-instruction
    sequence in the `#else` clause and ignore the code between the `#if` and `#else`
    clauses (because the constant `PentProOrLater` is false). By changing the value
    of `PentProOrLater` to true, you can tell HLA to compile the single `fcomip` instruction
    rather than the three-instruction sequence. Of course, you can use the `PentProOrLater`
    constant in other `#if` statements throughout your program to control how HLA
    compiles your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that conditional compilation does not let you create a single *executable*
    that runs efficiently on all processors. When using this technique you will still
    have to create two executable programs (one for Pentium Pro and later processors,
    one for the earlier processors) by compiling your source file twice: During the
    first compilation you must set the `PentProOrLater` constant to false; during
    the second compilation you must set this constant to true. Although you must create
    two separate executables, you need only maintain a single source file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are familiar with conditional compilation in other languages, such as
    the C/C++ language, you may be wondering if HLA supports a statement like C''s
    `#ifdef` statement. The answer is no, it does not. However, you can use the HLA
    compile-time function `@defined` to easily test to see if a symbol has been defined
    earlier in the source file. Consider the following modification to the preceding
    code that uses this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common use of conditional compilation is to introduce debugging and
    testing code into your programs. A typical debugging technique that many HLA programmers
    use is to insert "print" statements at strategic points throughout their code;
    this enables them to trace through their code and display important values at
    various checkpoints. A big problem with this technique, however, is that they
    must remove the debugging code prior to completing the project. The software''s
    customer (or a student''s instructor) probably doesn''t want to see debugging
    output in the middle of a report the program produces. Therefore, programmers
    who use this technique tend to insert code temporarily and then remove the code
    once they run the program and determine what is wrong. There are at least two
    problems with this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: Programmers often forget to remove some debugging statements, and this creates
    defects in the final program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After removing a debugging statement, these programmers often discover that
    they need that same statement to debug some different problem at a later time.
    Hence they are constantly inserting and removing the same statements over and
    over again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conditional compilation can provide a solution to this problem. By defining
    a symbol (say, `debug`) to control debug output in your program, you can easily
    activate or deactivate *all* debugging output by simply modifying a single line
    of source code. The following code fragment demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as you surround all debugging output statements with an #if statement
    like the preceding, you don''t have to worry about debug output accidentally appearing
    in your final application. By setting the `debug` symbol to false, you can automatically
    disable all such output. Likewise, you don''t have to remove all your debugging
    statements from your programs once they''ve served their immediate purpose. By
    using conditional compilation, you can leave these statements in your code because
    they are so easy to deactivate. Later, if you decide you need to view this same
    debugging information during a compilation, you won''t have to reenter the debugging
    statement; you simply reactivate it by setting the `debug` symbol to true.'
  prefs: []
  type: TYPE_NORMAL
- en: Although program configuration and debugging control are two of the more common,
    traditional uses for conditional compilation, don't forget that the `#if` statement
    provides the basic conditional statement in the HLA compile-time language. You
    will use the `#if` statement in your compile-time programs the same way you would
    use an `if` statement in HLA or some other language. Later sections in this text
    will present lots of examples of using the `#if` statement in this capacity.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[121](#CHP-9-FN-4)]) Except, of course, as parameters to certain HLA compile-time
    functions like `@size` or `@typeName`.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7 Repetitive Compilation (Compile-Time Loops)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HLA's `#while..#endwhile` and `#for..#endfor` statements provide compile-time
    loop constructs. The `#while` statement tells HLA to process the same sequence
    of statements repetitively during compilation. This is very handy for constructing
    data tables as well as providing a traditional looping structure for compile-time
    programs. Although you will not employ the `#while` statement anywhere near as
    often as the `#if` statement, this compile-time control structure is very important
    when you write advanced HLA programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#while` statement uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When HLA encounters the `#while` statement during compilation, it will evaluate
    the constant boolean expression. If the expression evaluates false, HLA will skip
    over the text between the `#while` and the `#endwhile` clauses (the behavior is
    similar to the `#if` statement if the expression evaluates false). If the expression
    evaluates true, then HLA will process the statements between the `#while` and
    `#endwhile` clauses and then "jump back" to the start of the `#while` statement
    in the source file and repeat this process, as shown in [Figure 9-3](ch09s07.html#hla_compile-time_number_symble_while_sta
    "Figure 9-3. HLA compile-time #while statement operation").'
  prefs: []
  type: TYPE_NORMAL
- en: '![HLA compile-time #while statement operation](tagoreillycom20100401nostarchimages578067.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3. HLA compile-time `#while` statement operation
  prefs: []
  type: TYPE_NORMAL
- en: To understand how this process works, consider the program in [Example 9-2](ch09s07.html#number_symble_while.._number_symble_endw
    "Example 9-2. #while..#endwhile demonstration").
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-2. `#while..#endwhile` demonstration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can probably surmise, the output from this program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: What is not quite obvious is how this program generates this output. Remember,
    the `#while..#endwhile` construct is a compile-time language feature, not a runtime
    control construct. Therefore, the previous `#while` loop repeats five times during
    *compilation*. On each repetition of the loop, the HLA compiler processes the
    statements between the `#while` and `#endwhile` clauses. Therefore, the preceding
    program is really equivalent to the code that is shown in [Example 9-3](ch09s07.html#program_equivalent_to_the_code_in_listin
    "Example 9-3. Program equivalent to the code in Example 9-2").
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-3. Program equivalent to the code in [Example 9-2](ch09s07.html#number_symble_while.._number_symble_endw
    "Example 9-2. #while..#endwhile demonstration")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this example, the `#while` statement is very convenient for
    constructing repetitive-code sequences. This is especially invaluable for unrolling
    loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA provides three forms of the `#for..#endfor` loop. These three loops take
    the following general form:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-4. HLA `#for` loops
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As its name suggests, *`valObject`* must be an object you've defined in a `val`
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first two forms of the `#for` loop above, the *`startExpr`* and *`endExpr`*
    components can be any HLA constant expression that yields an integer value. The
    first of these `#for` loops is semantically equivalent to the following `#while`
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The second of these `#for` loops is semantically equivalent to the `#while`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The third of these `#for` loops (the one using the `in` keyword) is especially
    useful for processing individual items from some composite data type. This loop
    repeats once for each element, field, character, and so on of the composite value
    you specify for *`composite_expr`*. This can be an array, string, record, or character
    set expression. For arrays, this `#for` loop repeats once for each element of
    the array and on each iteration of the loop; the loop control variable contains
    the current element''s value. For example, the following compile-time loop displays
    the values 1, 10, 100, and 1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If the *`composite_expr`* constant is a string constant, the `#for` loop repeats
    once for each character in the string and sets the value of the loop control variable
    to the current character. If the *`composite_expr`* constant expression is a record
    constant, then the loop will repeat once for each field of the record, and for
    each iteration the loop control variable will take on the *type and value* of
    the current field. If the *`composite_expr`* expression is a character set, the
    loop will repeat once for each character in the set, and the loop control variable
    will be assigned that character.
  prefs: []
  type: TYPE_NORMAL
- en: The `#for` loop actually turns out to be more useful than the `#while` loop
    because the larger number of compile-time loops you encounter repeat a fixed number
    of times (for example, processing a fixed number of array elements, macro parameters,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 9.8 Macros (Compile-Time Procedures)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros are objects that a language processor replaces with other text during
    compilation. Macros are great devices for replacing long, repetitive sequences
    of text with much shorter sequences of text. In additional to the traditional
    role that macros play (e.g., `#define` in C/C++), HLA's macros also serve as the
    equivalent of a compile-time language procedure or function. Therefore, macros
    are very important in HLA's compile-time language—just as important as functions
    and procedures are in other high-level languages.
  prefs: []
  type: TYPE_NORMAL
- en: Although macros are nothing new, HLA's implementation of macros far exceeds
    the macro-processing capabilities of most other programming languages (high level
    or low level). The following sections explore HLA's macro-processing facilities
    and the relationship between macros and other HLA CTL control constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.1 Standard Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HLA supports a straightforward macro facility that lets you define macros in
    a manner that is similar to declaring a procedure. A typical, simple macro declaration
    takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Although macro and procedure declarations are similar, there are several immediate
    differences between the two that are obvious from this example. First, of course,
    macro declarations use the reserved word `#macro` rather than procedure. Second,
    you do not begin the body of the macro with a begin *`macroname`*`;` clause. Finally,
    you will note that macros end with the `#endmacro` clause rather than `end` *`macroname`*`;`.
    The following code is a concrete example of a macro declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Execution of this macro's code will compute the two's complement of the 64-bit
    value in EDX:EAX (see the description of extended-precision `neg` in [8.1.7 Extended-Precision
    neg Operations](ch08.html#extended-precision_neg_operations "8.1.7 Extended-Precision
    neg Operations")).
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the code associated with `neg64`, you simply specify the macro''s
    name at the point you want to execute these instructions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that you do *not* follow the macro's name with a pair of empty parentheses
    as you would a procedure call (the reason for this will become clear a little
    later).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than the lack of parentheses following `neg64`''s invocation,^([[122](#ftn.CHP-9-FN-5)])
    this looks just like a procedure call. You could implement this simple macro as
    a procedure using the following procedure declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the following two statements will both negate the value in EDX:EAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between these two (the macro invocation versus the procedure
    call) is the fact that macros expand their text inline, whereas a procedure call
    emits a call to the corresponding procedure elsewhere in the text. That is, HLA
    replaces the invocation `neg64;` directly with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, HLA replaces the procedure call `neg64p();` with the single
    call instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Presumably, you've defined the `neg64p` procedure earlier in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should make the choice of macro versus procedure call on the basis of efficiency.
    Macros are slightly faster than procedure calls because you don''t execute the
    `call` and corresponding `ret` instructions. On the other hand, the use of macros
    can make your program larger because a macro invocation expands to the text of
    the macro''s body on each invocation. Procedure calls jump to a single instance
    of the procedure''s body. Therefore, if the macro body is large and you invoke
    the macro several times throughout your program, it will make your final executable
    much larger. Also, if the body of your macro executes more than a few simple instructions,
    the overhead of a `call/ret` sequence has little impact on the overall execution
    time of the code, so the execution time savings are nearly negligible. On the
    other hand, if the body of a procedure is very short (like the `neg64` example
    above), you''ll discover that the macro implementation is much faster and doesn''t
    expand the size of your program by much. A good rule of thumb is:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use macros for short, time-critical program units. Use procedures for longer
    blocks of code and when execution time is not as critical.
  prefs: []
  type: TYPE_NORMAL
- en: Macros have many other disadvantages over procedures. Macros cannot have local
    (automatic) variables, macro parameters work differently than procedure parameters,
    macros don't support (runtime) recursion, and macros are a little more difficult
    to debug than procedures (just to name a few disadvantages). Therefore, you shouldn't
    really use macros as a substitute for procedures except in cases where performance
    is absolutely critical.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.2 Macro Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like procedures, macros allow you to define parameters that let you supply different
    data on each macro invocation. This lets you write generic macros whose behavior
    can vary depending on the parameters you supply. By processing these macro parameters
    at compile time, you can write very sophisticated macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Macro parameter declaration syntax is very straightforward. You simply supply
    a list of parameter names within parentheses in a macro declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that you do not associate a data type with a macro parameter as you do
    for procedural parameters. This is because HLA macros are generally `text` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you invoke a macro, you simply supply the actual parameters the same way
    you would for a procedure call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that a macro invocation that requires parameters expects you to enclose
    the parameter list within parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.2.1 Standard Macro Parameter Expansion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the previous section explains, HLA automatically associates the type `text`
    with macro parameters. This means that during a macro expansion, HLA substitutes
    the text you supply as the actual parameter everywhere the formal parameter name
    appears. The semantics of "pass by textual substitution" are a little different
    than "pass by value" or "pass by reference," so it is worthwhile exploring those
    differences here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following macro invocations, using the `neg64` macro from the
    previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'These two invocations expand into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that macro invocations do not make a local copy of the parameters (as
    "pass by value" does), nor do they pass the address of the actual parameter to
    the macro. Instead, a macro invocation of the form `neg64( edx, eax );` is equivalent
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the text objects immediately expand their string values inline, producing
    the former expansion for `neg64( edx, eax );`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that macro parameters are not limited to memory, register, or constant
    operands as are instruction or procedure operands. Any text is fine as long as
    its expansion is legal wherever you use the formal parameter. Similarly, formal
    parameters may appear anywhere in the macro body, not just where memory, register,
    or constant operands are legal. Consider the following macro declaration and sample
    invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, HLA assumes that all text between commas constitutes a single macro
    parameter. If HLA encounters any opening bracketing symbols (left parentheses,
    left braces, or left brackets), then it will include all text up to the appropriate
    closing symbol, ignoring any commas that may appear within the bracketing symbols.
    This is why the `chkError` invocations above treat `cmp( eax, 0 )` and `test(
    1, bl )` as single parameters rather than as a pair of parameters. Of course,
    HLA does not consider commas (and bracketing symbols) within a string constant
    as the end of an actual parameter. So the following macro and invocation are perfectly
    legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: HLA treats the string `Hello, world!` as a single parameter because the comma
    appears inside a literal string constant, just as your intuition suggests.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unfamiliar with textual macro parameter expansion in other languages,
    you should be aware that there are some problems you can run into when HLA expands
    your actual macro parameters. Consider the following macro declaration and invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This example displays `Hello` five times during compilation rather than the
    eight times you might intuitively expect. This is because the `#for` statement
    above expands to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The actual parameter for *n* is `3+1`; because HLA expands this text directly
    in place of *n*, you get an erroneous text expansion. Of course, at compile time
    HLA computes `3+1*2` as the value 5 rather than as the value 8 (which you would
    get had HLA passed this parameter by value rather than by textual substitution).
  prefs: []
  type: TYPE_NORMAL
- en: 'The common solution to this problem when passing numeric parameters that may
    contain compile-time expressions is to surround the formal parameter in the macro
    with parentheses; for example, you would rewrite the macro above as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The earlier invocation would expand to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This version of the macro produces the intuitive result.
  prefs: []
  type: TYPE_NORMAL
- en: If the number of actual parameters does not match the number of formal parameters,
    HLA will generate a diagnostic message during compilation. As with procedures,
    the number of actual parameters must agree with the number of formal parameters.
    If you would like to have optional macro parameters, then keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.2.2 Macros with a Variable Number of Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may have noticed by now that some HLA macros don''t require a fixed number
    of parameters. For example, the `stdout.put` macro in the HLA Standard Library
    allows one or more actual parameters. HLA uses a special array syntax to tell
    the compiler that you wish to allow a variable number of parameters in a macro
    parameter list. If you follow the last macro parameter in the formal parameter
    list with `[ ]`, then HLA will allow a variable number of actual parameters (zero
    or more) in place of that formal parameter. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note the last invocation especially. If a macro has any formal parameters, you
    must supply parentheses with the macro list after the macro invocation. This is
    true even if you supply zero actual parameters to a macro with a varying parameter
    list. Keep in mind this important difference between a macro with no parameters
    and a macro with a varying parameter list but no actual parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'When HLA encounters a formal macro parameter with the `[ ]` suffix (which must
    be the last parameter in the formal parameter list), HLA creates a constant string
    array and initializes that array with the text associated with the remaining actual
    parameters in the macro invocation. You can determine the number of actual parameters
    assigned to this array using the `@elements` compile-time function. For example,
    `@elements( varying )` will return some value, 0 or greater, that specifies the
    total number of parameters associated with that parameter. The following declaration
    for `varParms` demonstrates how you might use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Because HLA doesn''t allow arrays of `text` objects, the varying parameter
    must be an array of strings. This, unfortunately, means you must treat the varying
    parameters differently than you handle standard macro parameters. If you want
    some element of the varying string array to expand as text within the macro body,
    you can always use the `@text` function to achieve this. Conversely, if you want
    to use a nonvarying formal parameter as a string object, you can always use the
    `@string`( *`name`* ) function. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, it would be a good idea, in a macro like the above, to verify that
    there are at least two parameters before attempting to reference element zero
    of the `optional` parameter. You can easily do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 9.8.2.3 Required vs. Optional Macro Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the previous section notes, HLA requires exactly one actual parameter for
    each nonvarying formal macro parameter. If there is no varying macro parameter
    (and there can be at most one), then the number of actual parameters must exactly
    match the number of formal parameters. If a varying formal parameter is present,
    then there must be at least as many actual macro parameters as there are nonvarying
    (or required) formal macro parameters. If there is a single, varying actual parameter,
    then a macro invocation may have zero or more actual parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one big difference between a macro invocation of a macro with no parameters
    and a macro invocation of a macro with a single, varying parameter that has no
    actual parameters: The macro with the varying parameter list must have an empty
    set of parentheses after it, while the macro invocation of the macro without any
    parameters does not allow this. You can use this fact to your advantage if you
    wish to write a macro that doesn''t have any parameters but you want to follow
    the macro invocation with `( )` so that it matches the syntax of a procedure call
    with no parameters. Consider the following macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The preceding macro requires invocations of the form `neg64();` to use the same
    syntax you would use for a procedure call. This feature is useful if you want
    the syntax of your parameterless macro invocations to match the syntax of a parameterless
    procedure call. It's not a bad idea to do this, just in the off chance you need
    to convert the macro to a procedure at some point (or vice versa, for that matter).
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.3 Local Symbols in a Macro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following macro declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this macro is to simulate an instruction that jumps to the specified
    target location if the zero flag is set `and` the carry flag is set. Conversely,
    if either the zero flag is clear or the carry flag is clear, this macro transfers
    control to the instruction immediately following the macro invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a serious problem with this macro. Consider what happens if you use
    this macro more than once in your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding macro invocations expand to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The problem with the expansion of these two macro invocations is that they both
    emit the same label, `NotTarget`, during macro expansion. When HLA processes this
    code it will complain about a duplicate symbol definition. Therefore, you must
    take care when defining symbols inside a macro because multiple invocations of
    that macro may lead to multiple definitions of that symbol.
  prefs: []
  type: TYPE_NORMAL
- en: HLA's solution to this problem is to allow the use of *local symbols* within
    a macro. Local macro symbols are unique to a specific invocation of a macro. For
    example, had `NotTarget` been a local symbol in the preceding `JZC` macro invocations,
    the program would have compiled properly because HLA treats each occurrence of
    `NotTarget` as a unique symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA does not automatically make internal macro symbol definitions local to
    that macro.^([[123](#ftn.CHP-9-FN-6)]) Instead, you must explicitly tell HLA which
    symbols must be local. You do this in a macro declaration using the following
    generic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The list of local names is a sequence of one or more HLA identifiers separated
    by commas. Whenever HLA encounters this name in a particular macro invocation,
    it automatically substitutes some unique name for that identifier. For each macro
    invocation, HLA substitutes a different name for the local symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can correct the problem with the `JZC` macro by using the following macro
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever HLA processes this macro it will automatically associate a unique
    symbol with each occurrence of `NotTarget`. This will prevent the duplicate-symbol
    error that occurs if you do not declare `NotTarget` as a local symbol.
  prefs: []
  type: TYPE_NORMAL
- en: HLA implements local symbols by substituting a symbol like `_`*`nnnn`*`_` (where
    *`nnnn`* is a four-digit hexadecimal number) wherever the local symbol appears
    in a macro invocation. For example, a macro invocation of the form `JZC(` *`SomeLabel`*
    `);` might expand to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: For each local symbol appearing within a macro expansion, HLA will generate
    a unique temporary identifier by simply incrementing this numeric value for each
    new local symbol it needs. As long as you do not explicitly create labels of the
    form `_`*`nnnn`*`_`*`Text`*`_` (where *`nnnn`* is a hexadecimal value), there
    will never be a conflict in your program. HLA explicitly reserves all symbols
    that begin and end with a single underscore for its own private use (and for use
    by the HLA Standard Library). As long as you honor this restriction, there should
    be no conflicts between HLA local symbol generation and labels in your own programs
    because all HLA-generated symbols begin and end with a single underscore.
  prefs: []
  type: TYPE_NORMAL
- en: 'HLA implements local symbols by effectively converting that local symbol to
    a text constant that expands to the unique symbol HLA generates for the local
    label. That is, HLA effectively treats local symbol declarations as indicated
    by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Whenever HLA expands this macro it will substitute `_010A_`*`Text`*`_` for each
    occurrence of `NotTarget` it encounters in the expansion. This analogy isn't perfect
    because the text symbol `NotTarget` in this example is still accessible after
    the macro expansion, whereas this is not the case when defining local symbols
    within a macro. But this does give you an idea of how HLA implements local symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.4 Macros as Compile-Time Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although programmers typically use macros to expand to some sequence of machine
    instructions, there is absolutely no requirement that a macro body contain any
    executable instructions. Indeed, many macros contain only compile-time language
    statements (for example, `#if`, `#while`, `#for`, `?` assignments, and the like).
    By placing only compile-time language statements in the body of a macro, you can
    effectively write compile-time procedures and functions using macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `unique` macro is a good example of a compile-time function that
    returns a string result. Consider the definition of this macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Whenever your code references this macro, HLA replaces the macro invocation
    with the text `@string(theSym)`, which, of course, expands to some string like
    `_021F_`*`Text`*`_.` Therefore, you can think of this macro as a compile-time
    function that returns a string result.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful that you don't take the function analogy too far. Remember, macros
    always expand to their body text at the point of invocation. Some expansions may
    not be legal at any arbitrary point in your programs. Fortunately, most compile-time
    statements are legal anywhere whitespace is legal in your programs. Therefore,
    macros behave as you would expect functions or procedures to behave during the
    execution of your compile-time programs.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the only difference between a procedure and a function is that a
    function returns some explicit value, while procedures simply do some activity.
    There is no special syntax for specifying a compile-time function return value.
    As the example above indicates, simply specifying the value you wish to return
    as a statement in the macro body suffices. A compile-time procedure, on the other
    hand, would not contain any non-compile-time language statements that expand into
    some sort of data during macro invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.5 Simulating Function Overloading with Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C++ language supports a nifty feature known as *function overloading*. Function
    overloading lets you write several different functions or procedures that all
    have the same name. The difference between these functions is the types of their
    parameters or the number of parameters. A procedure declaration is unique in C++
    if it has a different number of parameters than other functions with the same
    name or if the types of its parameters differ from other functions with the same
    name. HLA does not directly support procedure overloading, but you can use macros
    to achieve the same result. This section explains how to use HLA's macros and
    the compile-time language to achieve function/procedure overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'One good use for procedure overloading is to reduce the number of Standard
    Library routines you must remember how to use. For example, the HLA Standard Library
    provides five different "puti" routines that output an integer value: `stdout.puti128`,
    `stdout.puti64`, `stdout.puti32`, `stdout.puti16`, and `stdout.puti8`. The different
    routines, as their names suggest, output integer values according to the size
    of their integer parameter. In the C++ language (or another other language supporting
    procedure/function overloading) the engineer designing the input routines would
    probably have chosen to name them all `stdout.puti` and leave it up to the compiler
    to select the appropriate one based on the operand size.^([[124](#ftn.CHP-9-FN-7)])
    The macro in [Example 9-5](ch09s08.html#simple_procedure_overloading_based_on_op
    "Example 9-5. Simple procedure overloading based on operand size") demonstrates
    how to do this in HLA using the compile-time language to figure out the size of
    the parameter operand.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-5. Simple procedure overloading based on operand size
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The example above simply tests the size of the operand to determine which output
    routine to use. You can use other HLA compile-time functions, such as `@typename`,
    to do more sophisticated processing. Consider the program in [Example 9-6](ch09s08.html#procedure_overloading_based_on_operand_t
    "Example 9-6. Procedure overloading based on operand type"), which demonstrates
    a macro that overloads `stdout.puti32`, `stdout.putu32`, and `stdout.putd` depending
    on the type of the operand.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-6. Procedure overloading based on operand type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: You can easily extend this macro to output 8- and 16-bit operands as well as
    32-bit operands. That is left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: The number of actual parameters is another way to resolve which overloaded procedure
    to call. If you specify a variable number of macro parameters (using the `[ ]`
    syntax; see the discussion in [9.8.2.2 Macros with a Variable Number of Parameters](ch09s08.html#macros_with_a_variable_number_of_paramet
    "9.8.2.2 Macros with a Variable Number of Parameters")), you can use the `@elements`
    compile-time function to determine exactly how many parameters are present and
    call the appropriate routine. The sample in [Example 9-7](ch09s08.html#using_the_number_of_parameters_to_resolv
    "Example 9-7. Using the number of parameters to resolve overloaded procedures")
    uses this trick to determine whether it should call `stdout.puti32` or `stdout.puti32Size`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-7. Using the number of parameters to resolve overloaded procedures
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: All the examples up to this point provide procedure overloading for Standard
    Library routines (specifically, the integer output routines). Of course, you are
    not limited to overloading procedures in the HLA Standard Library. You can create
    your own overloaded procedures as well. All you have to do is write a set of procedures,
    all with unique names, and then use a single macro to decide which routine to
    actually call based on the macro's parameters. Rather than call the individual
    routines, invoke the common macro and let it decide which procedure to actually
    call.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[122](#CHP-9-FN-5)]) To differentiate between macros and procedures, this
    text will use the term *invocation* when describing the use of a macro and *call*
    when describing the use of a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[123](#CHP-9-FN-6)]) Sometimes you actually want the symbols to be global.
  prefs: []
  type: TYPE_NORMAL
- en: ^([[124](#CHP-9-FN-7)]) By the way, the HLA Standard Library does this as well.
    Although it doesn't provide `stdout.puti`, it does provide `stdout.put`, which
    will choose an appropriate output routine based upon the parameter's type. This
    is a bit more flexible than a `puti` routine.
  prefs: []
  type: TYPE_NORMAL
- en: 9.9 Writing Compile-Time "Programs"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HLA compile-time language provides a powerful facility with which to write
    "programs" that execute while HLA is compiling your assembly language programs.
    Although it is possible to write some general-purpose programs using the HLA compile-time
    language, the real purpose of the HLA compile-time language is to allow you to
    write short programs *that write other programs*. In particular, the primary purpose
    of the HLA compile-time language is to automate the creation of large or complex
    assembly language sequences. The following subsections provide some simple examples
    of such compile-time programs.
  prefs: []
  type: TYPE_NORMAL
- en: 9.9.1 Constructing Data Tables at Compile Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, this book suggested that you could write programs to generate large,
    complex lookup tables for your assembly language programs (see the discussion
    of tables in [8.4.3 Generating Tables](ch08s04.html#generating_tables "8.4.3 Generating
    Tables")). [Chapter 8](ch08.html "Chapter 8. ADVANCED ARITHMETIC") provides examples
    in HLA but suggests that writing a separate program is unnecessary. This is true;
    you can generate most lookup tables you'll need using nothing more than the HLA
    compile-time language facilities. Indeed, filling in table entries is one of the
    principle uses of the HLA compile-time language. In this section we will take
    a look at using the HLA compile-time language to construct data tables during
    compilation.
  prefs: []
  type: TYPE_NORMAL
- en: In [8.4.3 Generating Tables](ch08s04.html#generating_tables "8.4.3 Generating
    Tables"), you saw an example of an HLA program that writes a text file containing
    a lookup table for the trigonometric sine function. The table contains 360 entries
    with the index into the table specifying an angle in degrees. Each `int32` entry
    in the table contains the value sin(*angle* )*1,000 where *angle* is equal to
    the index into the table. [8.4.3 Generating Tables](ch08s04.html#generating_tables
    "8.4.3 Generating Tables") suggests running this program and then including the
    text output from that program into the actual program that used the resulting
    table. You can avoid much of this work by using the compile-time language. The
    HLA program in [Example 9-8](ch09s09.html#generating_a_sine_lookup_table_with_the
    "Example 9-8. Generating a sine lookup table with the compile-time language")
    includes a short compile-time code fragment that constructs this table of sines
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-8. Generating a sine lookup table with the compile-time language
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common use for the compile-time language is to build ASCII character
    lookup tables for use by the `xlat` instruction at runtime. Common examples include
    lookup tables for alphabetic case manipulation. The program in [Example 9-9](ch09s09.html#generating_case-conversion_tables_with_t
    "Example 9-9. Generating case-conversion tables with the compile-time language")
    demonstrates how to construct an uppercase conversion table and a lowercase conversion
    table.^([[125](#ftn.CHP-9-FN-8)]) Note the use of a macro as a compile-time procedure
    to reduce the complexity of the table-generating code:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-9. Generating case-conversion tables with the compile-time language
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: One important thing to note about this example is the fact that a semicolon
    does not follow the `emitCharRange` macro invocations. Macro invocations do not
    require a closing semicolon. Often, it is legal to go ahead and add one to the
    end of the macro invocation because HLA is normally very forgiving about having
    extra semicolons inserted into the code. In this case, however, the extra semicolons
    are illegal because they would appear between adjacent entries in the `TOlc` and
    `toUC` tables. Keep in mind that macro invocations don't require a semicolon,
    especially when using macro invocations as compile-time procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 9.9.2 Unrolling Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the chapter on low-level control structures, this text points out that you
    can unravel loops to improve the performance of certain assembly language programs.
    One problem with unraveling, or unrolling, loops is that you may need to do a
    lot of extra typing, especially if there are many loop iterations. Fortunately,
    HLA's compile-time language facilities, especially the `#while` and `#for` loops,
    come to the rescue. With a small amount of extra typing plus one copy of the loop
    body, you can unroll a loop as many times as you please.
  prefs: []
  type: TYPE_NORMAL
- en: If you simply want to repeat the same exact code sequence some number of times,
    unrolling the code is especially trivial. All you have to do is wrap an HLA `#for..#endfor`
    loop around the sequence and count off a `val` object the specified number of
    times. For example, if you wanted to print `Hello World` 10 times, you could encode
    this as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the code above looks very similar to an HLA `for` loop you could write
    in your program, remember the fundamental difference: The preceding code simply
    consists of 10 straight `stdout.put` calls in the program. Were you to encode
    this using an HLA `for` loop, there would be only one call to `stdout.put` and
    lots of additional logic to loop back and execute that single call 10 times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unrolling loops becomes slightly more complicated if any instructions in that
    loop refer to the value of a loop control variable or another value, which changes
    with each iteration of the loop. A typical example is a loop that zeros the elements
    of an integer array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code fragment the loop uses the value of the loop control variable
    (in EBX) to index into array. Simply copying `mov( eax, array[ ebx*4 ]);` 20 times
    is not the proper way to unroll this loop. You must substitute an appropriate
    constant index in the range 0..76 (the corresponding loop indices, times 4) in
    place of `ebx*4` in this example. Correctly unrolling this loop should produce
    the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily do this using the following compile-time code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: If the statements in a loop make use of the loop control variable's value, it
    is only possible to unroll such loops if those values are known at compile-time.
    You cannot unroll loops when user input (or other runtime information) controls
    the number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[125](#CHP-9-FN-8)]) Note that on modern processors, using a lookup table
    is probably not the most efficient way to convert between alphabetic cases. However,
    this is just an example of filling in the table using the compile-time language.
    The principles are correct, even if the code is not exactly the best it could
    be.
  prefs: []
  type: TYPE_NORMAL
- en: 9.10 Using Macros in Different Source Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike procedures, macros do not have a fixed piece of code at some address
    in memory. Therefore, you cannot create external macros and link them with other
    modules in your program. However, it is very easy to share macros with different
    source files: Just put the macros you wish to reuse in a header file and include
    that file using the `#include` directive. You can make the macro available to
    any source file you choose using this simple trick.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.11 For More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this chapter has spent a considerable amount of time describing various
    features of HLA's macro support and compile-time language features, the truth
    is this chapter has barely described what's possible with HLA. Indeed, this chapter
    made the claim that HLA's macro facilities are far more powerful than those provided
    by other assemblers; however, this chapter doesn't do HLA's macros justice. If
    you've ever used a language with decent macro facilities, you're probably wondering,
    "What's the big deal?" Well, the really sophisticated stuff is beyond the scope
    of this chapter. If you're interested in learning more about HLA's powerful macro
    facilities, please consult the HLA reference manual and the electronic editions
    of *The Art of Assembly Language* at [http://webster.cs.ucr.edu/](http://webster.cs.ucr.edu/)
    or [http://www.artofasm.com/](http://www.artofasm.com/). You'll discover that
    it's actually possible to create your own high-level languages using HLA's macro
    facilities. However, this chapter does not assume the reader has the prerequisite
    knowledge to do that type of programming (yet!), so this chapter defers that discussion
    to the material that you'll also find on the websites.
  prefs: []
  type: TYPE_NORMAL
