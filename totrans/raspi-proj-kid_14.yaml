- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: COMPUTER GAMES WITH THE SENSE HAT
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Sense HAT 进行计算机游戏
- en: IN THE FINAL PROJECT IN THIS BOOK, YOU’LL USE THE SENSE HAT HARDWARE AND PYTHON
    CODE TO BUILD A VERSION OF THE CLASSIC GAME OF ROCK, PAPER, SCISSORS — BUT WITH
    A TWIST. YOU’LL PROGRAM A COLORFUL LED MATRIX AND A JOYSTICK TO ADD A GAME DISPLAY
    AND CONTROL TO YOUR PROGRAM.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最终项目中，你将使用 Sense HAT 硬件和 Python 代码，制作经典游戏石头、剪子、布的一个版本——不过有所改动。你将编程一个五彩斑斓的
    LED 矩阵和一个摇杆，为你的程序添加游戏显示和控制功能。
- en: In late 2015, the European Space Agency (ESA) sent a supply rocket to replenish
    the International Space Station (ISS). Among the cargo were two Raspberry Pi computers,
    each fitted with a special add-on board known as the *Astro Pi*. These were sent
    in preparation for the inaugural visit of Major Tim Peake, a British astronaut.
    Each Astro Pi boasts an array of hardware and sensors and an 8 × 8 LED display—perfect
    for taking and displaying readings such as temperature, pressure, acceleration,
    and magnetic field strength.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年底，欧洲航天局（ESA）向国际空间站（ISS）发送了一枚补给火箭。其中包括两台 Raspberry Pi 计算机，每台都安装了一个特殊的附加板，名为
    *Astro Pi*。这些设备是为英国宇航员蒂姆·皮克上校的首次访问做准备的。每个 Astro Pi 都配备了硬件和传感器阵列，并拥有一个 8 × 8 的
    LED 显示屏——非常适合用来采集和显示诸如温度、压力、加速度和磁场强度等读数。
- en: Previously, in the summer of 2015, the Raspberry Pi Foundation held a competition
    for children to write a program or experiment for the Astro Pi that would run
    aboard the ISS. During Peake’s stay, the Astro Pi ran the preloaded experiments
    designed by the winners. The Astro Pi will stay onboard the ISS until 2021, and,
    provided you meet the qualifications to take part, you can still enter the competitions.
    Find more details at *[https://astro-pi.org/](https://astro-pi.org/)*. Who knows—maybe
    you’ll be inspired to write your own program to run in space aboard the ISS, shown
    in [Figure 14-1](ch14.xhtml#ch14fig01).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此前，在 2015 年夏季，Raspberry Pi 基金会举办了一项比赛，鼓励孩子们为 Astro Pi 编写程序或实验，计划在国际空间站上运行。在皮克的驻留期间，Astro
    Pi 运行了获胜者设计的预加载实验。Astro Pi 将一直留在国际空间站直到 2021 年，如果你符合参赛资格，仍然可以参加比赛。更多细节请见 *[https://astro-pi.org/](https://astro-pi.org/)*。谁知道呢，也许你会受到启发，编写自己的程序，在国际空间站上运行，见[图
    14-1](ch14.xhtml#ch14fig01)。
- en: In December of that year, the Astro Pi became available for sale to the public,
    rebranded as the Sense HAT. The Sense HAT you can buy today consists of exactly
    the same hardware and sensor set found on the Astro Pi.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年 12 月，Astro Pi 开始面向公众销售，并更名为 Sense HAT。你今天可以购买的 Sense HAT 硬件和传感器与 Astro
    Pi 完全相同。
- en: '![Image](../images/14fig01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14fig01.jpg)'
- en: '**FIGURE 14-1** The International Space Station'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 14-1** 国际空间站'
- en: The Sense HAT’s LED display can serve as a screen, making it the perfect tool
    for creating games. In this chapter, you’ll use it to program a twist on the classic
    game of rock, paper, scissors. This version—called rock, paper, scissors, lizard,
    Spock—introduces new possibilities to mix up the gameplay.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Sense HAT 的 LED 显示屏可以作为屏幕使用，使其成为制作游戏的完美工具。在本章中，你将用它编程制作经典的石头、剪子、布游戏的变种。这一版本——称为石头、剪子、布、蜥蜴、斯波克——为游戏玩法带来了新的可能性。
- en: First, though, you’ll look at simple programs in order to explore the Sense
    HAT’s key features. You’ll scroll text, make an interactive temperature display,
    and use a tool called an array to draw a basic image. These skills also stand
    alone, and you can adapt them for your own projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，首先你将查看一些简单的程序，以便探索 Sense HAT 的关键特性。你将滚动文本，制作一个互动的温度显示，并使用一个叫做数组的工具来绘制基本图像。这些技能也可以独立使用，你可以将它们适应到自己的项目中。
- en: WHAT YOU’LL NEED
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你将需要的工具
- en: 'Here’s what you’ll need to build this game project:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你构建这个游戏项目所需的工具：
- en: Raspberry Pi 3 or 4 (suggested)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 3 或 4（建议使用）
- en: Sense HAT
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sense HAT
- en: USB portable battery (optional)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB 便携电池（可选）
- en: Small Phillips-head screwdriver
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型十字螺丝刀
- en: WHAT IS THE SENSE HAT?
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 Sense HAT？
- en: Let’s take a look at the Sense HAT’s sensors and hardware, shown in [Figure
    14-2](ch14.xhtml#ch14fig02).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Sense HAT 的传感器和硬件，如[图 14-2](ch14.xhtml#ch14fig02)所示。
- en: '![Image](../images/14fig02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14fig02.jpg)'
- en: '**FIGURE 14-2** The Sense HAT and its parts'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 14-2** Sense HAT 及其组件'
- en: 'The Sense HAT parts are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Sense HAT 的部件如下：
- en: '**Multicolor 8 × 8 LED matrix** You can use these 64 programmable LED lights
    to scroll messages or to display data from the sensors, animations, or simple
    games.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**多彩 8 × 8 LED 矩阵** 你可以使用这 64 个可编程 LED 灯来滚动消息，或者显示传感器数据、动画或简单的游戏。'
- en: '**Temperature sensor** This built-in sensor is accurate to about 2°C (approximately
    4°F) in the 0-65°C (32-150°F) range. It’s useful for measuring the temperature
    of your surrounding environment.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**温度传感器** 这个内置传感器在 0-65°C（32-150°F）范围内的准确度约为 2°C（约 4°F）。它可以用于测量周围环境的温度。'
- en: '**Magnetometer** Works like a compass by detecting magnetic field strengths.
    You can use its readings to measure magnetic fields and find compass points relative
    to north.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**磁力计** 通过检测磁场强度来像指南针一样工作。你可以使用它的读数来测量磁场并找到相对于北方的方向。'
- en: '**Accelerometer** Measures acceleration in the directions of up, down, and
    across. You can use this to track movements, or modify it to create a controller
    for a game.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**加速度计** 测量上下和横向的加速度。你可以利用它来跟踪运动，或将其改造为游戏控制器。'
- en: '**Multidirectional joystick** Can be used to move characters in a game or as
    a selection tool for options.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**多方向摇杆** 可以用于在游戏中移动角色，或作为选项的选择工具。'
- en: GETTING STARTED WITH THE SENSE HAT
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始使用 Sense HAT
- en: Setting up the Sense HAT is extremely easy, because it was designed to work
    with the Raspberry Pi. Take the Sense HAT and slide it onto the GPIO pins. Firmly
    push it down to secure it into place. Then take the Raspberry Pi’s offset mounts
    (these should come with your Sense HAT) and screw them into the Sense HAT. Fitting
    these mounts will keep the board from moving around when you’re using the joystick.
    Next, plug in your power supply and boot up your Raspberry Pi.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Sense HAT 非常简单，因为它是专为树莓派设计的。将 Sense HAT 插入 GPIO 引脚，并将其按紧固定到位。然后，取下树莓派的偏移安装架（这些应该随
    Sense HAT 一起提供），并将其固定到 Sense HAT 上。安装这些支架可以防止在使用摇杆时板子移动。接下来，插入电源并启动树莓派。
- en: You’ll now have a look at some basic programs that will show off the various
    features and capabilities of the Sense HAT.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一些基本程序，展示 Sense HAT 的各种功能和能力。
- en: Scrolling Text Across the Sense HAT
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Sense HAT 上滚动文本
- en: Let’s write your first program, which will scroll a message across the LED display.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写第一个程序，滚动显示一条信息。
- en: Making the Text Scroll
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使文本滚动
- en: Open your Python editor, start a new file, and enter the program in [Listing
    14-1](ch14.xhtml#ch14ex01).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Python 编辑器，启动一个新文件，并在 [Listing 14-1](ch14.xhtml#ch14ex01) 中输入程序代码。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**LISTING 14-1** Scrolling a message across the LED display'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Listing 14-1** 滚动显示信息'
- en: Start by importing the `SenseHat` module ❶. Then create a line of code ❷ that’s
    responsible for scrolling the message. Replace the text between the quotation
    marks with your own, save the file as *scroll_text.py*, and press **F5** to run
    it. Your message will scroll across the LEDs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入 `SenseHat` 模块 ❶。然后创建一行代码 ❷，负责滚动显示消息。将引号中的文本替换为你自己的消息，保存文件为 *scroll_text.py*，并按
    **F5** 运行。你的信息将会滚动显示在 LED 上。
- en: Changing the Color of the Text
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更改文本的颜色
- en: You can change the color of the text by altering its red, green, and blue (RGB)
    values. You can combine any amount of red, green, and blue using values between
    0 and 255, where 0 is none and 255 is the maximum amount, to create an overall
    color.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过更改文本的红色、绿色和蓝色（RGB）值来更改文本的颜色。你可以使用 0 到 255 之间的值将红色、绿色和蓝色的任意组合结合起来，其中 0 表示无颜色，255
    表示最大颜色量，从而创建出一种整体颜色。
- en: 'Replace the last line of code from [Listing 14-1](ch14.xhtml#ch14ex01) with
    the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [Listing 14-1](ch14.xhtml#ch14ex01) 中的最后一行代码替换为以下内容：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code sets the color to the maximum red value (255) and the minimum green
    and blue values (0) to change the text to red. Save and run the program code as
    before.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将颜色设置为最大红色值（255）和最小绿色与蓝色值（0），从而将文本颜色更改为红色。像之前一样保存并运行程序代码。
- en: Play around with other color variations. Change the color values at the end
    of the line of code, and then run the program to see the colors change. The following
    table lists color values you could use.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试其他颜色变体。更改代码行末尾的颜色值，然后运行程序查看颜色变化。下表列出了你可以使用的颜色值。
- en: '| **COLOR** | **RGB VALUES** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **颜色** | **RGB 值** |'
- en: '| --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Pink | 255, 102, 255 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 粉色 | 255, 102, 255 |'
- en: '| Yellow | 255, 255, 0 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 黄色 | 255, 255, 0 |'
- en: '| Orange | 255, 128, 0 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 橙色 | 255, 128, 0 |'
- en: '| Purple | 102, 0, 102 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 紫色 | 102, 0, 102 |'
- en: '| Light blue | 0, 255, 255 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 浅蓝色 | 0, 255, 255 |'
- en: Taking a Temperature Reading
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测量温度
- en: Now you’ll combine the code that scrolls text with the Sense HAT’s temperature
    sensor to display the temperature of your surroundings. Open a new Python file
    and enter the code in [Listing 14-2](ch14.xhtml#ch14ex02).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将结合滚动文本的代码和Sense HAT的温度传感器，显示周围环境的温度。打开一个新的Python文件，并输入[清单14-2](ch14.xhtml#ch14ex02)中的代码。
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**LISTING 14-2** Scrolling the temperature across the LED display'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单14-2** 在LED显示屏上滚动温度'
- en: Again, begin by importing the `SenseHat` module. Then tell the temperature sensor
    to take a reading and store this value in a variable named `temp` ❶. Next, print
    out the value ❷. On the last line, use the same code as you did in [Listing 14-1](ch14.xhtml#ch14ex01)
    to scroll text, but make the message the value from the `temp` variable ❸.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，首先导入`SenseHat`模块。然后命令温度传感器进行读取，并将此值存储在名为`temp` ❶的变量中。接下来，打印出该值 ❷。在最后一行，使用与[清单14-1](ch14.xhtml#ch14ex01)中相同的代码来滚动文本，但将消息改为来自`temp`变量的值
    ❸。
- en: Now the temperature (in degrees Celsius) will scroll across the LED display.
    If the number seems high, that’s because the sensor is located near the Raspberry
    Pi’s CPU, which gets hot. So the reading is probably 5 or 6 degrees Celsius above
    your environment. If you want a more accurate temperature reading, you can subtract
    6 from the reading by replacing line ❶ with **`temp = sense.get_temperature()
    - 6`**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在温度（以摄氏度为单位）将滚动显示在LED屏幕上。如果温度看起来比较高，那是因为传感器靠近树莓派的CPU，CPU会发热。因此，读取的温度可能比实际环境温度高出5到6摄氏度。如果你想要更准确的温度读取，可以通过将第❶行替换为**`temp
    = sense.get_temperature() - 6`**来减去6度。
- en: Making a Real-Time Temperature Display
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 制作实时温度显示
- en: Our program so far takes a single temperature reading at the moment when you
    execute the program. This isn’t useful if you want to monitor a change in temperature,
    so you’ll edit the code to update the temperature readings continuously. You’ll
    also use the LEDs to make a virtual thermometer, rather than representing the
    temperature as a number. You’ll do this by assigning the value of the temperature
    reading to a number of pixels, creating an LED thermometer. Open a new Python
    file and copy out [Listing 14-3](ch14.xhtml#ch14ex03), which that shows this program.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的程序仅在执行程序的瞬间读取一次温度。如果你想监控温度变化，这种方式就不太实用了，因此你需要编辑代码，使其持续更新温度读数。你还将利用LED来制作虚拟温度计，而不是将温度表示为数字。你将通过将温度读取值分配给多个像素，创建一个LED温度计。打开一个新的Python文件，复制[清单14-3](ch14.xhtml#ch14ex03)中的代码，这段程序演示了如何实现这个功能。
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**LISTING 14-3** Making an updating virtual thermometer'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单14-3** 制作更新的虚拟温度计'
- en: Start the program by importing the `SenseHat` modules. Then assign two colors
    for the temperature display. In this example, use `red` ❶ to represent the current
    temperature and `blue` ❷ to represent the rest of the scale.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入`SenseHat`模块来启动程序。然后为温度显示分配两种颜色。在这个示例中，使用`red` ❶表示当前温度，使用`blue` ❷表示其余的温度范围。
- en: Next, create a `while` loop to ensure that the program repeats, updating the
    temperature ❸. As before, take the temperature reading and store the value in
    `temp` ❹ and then print the value ❺.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个`while`循环，确保程序重复运行，并不断更新温度 ❸。和之前一样，读取温度并将值存储在`temp` ❹中，然后打印出该值 ❺。
- en: Calculate how many LEDs should be red and how many should be blue ❻. Each LED
    represents a degree, so if the temperature were 26°C, you would want the first
    26 LEDs to be red and the rest to be blue (the blue LEDs, would mark temperature
    values 27°C and above). The code indicates that the LEDs should be blue if their
    number is greater than the temperature and red if they are equal to or lower than
    the temperature. These color values are then written to the LED display ❼.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 计算应该有多少个LED显示红色，多少个LED显示蓝色 ❻。每个LED代表一个温度单位，因此如果温度是26°C，你希望前26个LED是红色的，其余的LED是蓝色的（蓝色LED表示温度为27°C或更高）。代码中指示，如果LED的编号大于温度，则应显示蓝色；如果编号小于或等于温度，则显示红色。然后将这些颜色值写入LED显示屏
    ❼。
- en: As the temperature changes, the looping program will recalculate the combination
    of red and blue LEDs. You’ll have more red LEDs as it gets hotter and more blue
    LEDs as it gets colder. [Figure 14-3](ch14.xhtml#ch14fig03) shows the LED thermometer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着温度的变化，循环程序将重新计算红色和蓝色LED的组合。温度越高，红色LED越多；温度越低，蓝色LED越多。[图14-3](ch14.xhtml#ch14fig03)展示了LED温度计。
- en: '![Image](../images/14fig03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14fig03.jpg)'
- en: '**FIGURE 14-3** The Sense HAT real-time temperature sensor'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**图14-3** Sense HAT 实时温度传感器'
- en: Save the program as *temp.py* and run it. Try adjusting the temperature by safely
    placing your Sense HAT near a heat source or maybe putting the Sense HAT in the
    fridge for a few minutes!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序保存为 *temp.py* 并运行。尝试通过将 Sense HAT 安全地放置在热源附近或将其放入冰箱几分钟来调整温度！
- en: Building a Compass
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建一个指南针
- en: The Sense HAT has an onboard magnetometer that you can use as a compass to calculate
    the Sense HAT’s position in relation to magnetic north. Open a new Python file
    and try this out now, using the code in [Listing 14-4](ch14.xhtml#ch14ex04).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Sense HAT 配备了一个内置的磁力计，你可以用它作为指南针，计算 Sense HAT 相对于磁北的位置。打开一个新的 Python 文件，并尝试使用[清单
    14-4](ch14.xhtml#ch14ex04)中的代码。
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**LISTING 14-4** Finding the magnetic north'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 14-4** 寻找磁北'
- en: Add the first three lines of code, which are the standard imports and assignments.
    Then create a `while` loop to keep the program repeating; this way, as in the
    thermometer project, the Sense HAT will continuously update its location. Next,
    take a reading from the magnetometer ❶, and store it in a variable named `north`.
    Print out the value ❷ and then add a 1-second pause ❸ in order to allow you to
    settle in a position before the next reading is taken.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 添加前三行代码，这是标准的导入和赋值操作。然后创建一个 `while` 循环，使程序不断重复；这样，像在温度计项目中一样，Sense HAT 会不断更新其位置。接下来，从磁力计
    ❶ 读取数据，并将其存储在名为 `north` 的变量中。打印出该值 ❷，然后添加一个 1 秒钟的暂停 ❸，以便在下次读取前让你有时间稳定位置。
- en: Save and run the program. Move the Sense HAT around and watch the readings change.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行程序。移动 Sense HAT，观察读数的变化。
- en: Making a Magical Sparkle Screen
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 制作一个神奇的闪光屏幕
- en: This nice little program from the Raspberry Pi Foundation turns the Sense HAT
    LED display into a wall of sparkling colors, as shown in [Figure 14-4](ch14.xhtml#ch14fig04).
    It selects a random LED and assigns it a random color, turns that LED on, and
    then pauses for one-tenth of a second before selecting and turning on another
    random LED with a random color. This pattern continuously loops, creating a sparkling
    show. Stick a transparent object on top, and you’ll have your own mood light.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个来自树莓派基金会的简单程序将 Sense HAT LED 显示屏变成了一个闪亮的色彩墙，如[图 14-4](ch14.xhtml#ch14fig04)所示。它选择一个随机
    LED 并分配一个随机颜色，点亮该 LED，然后暂停十分之一秒后，选择并点亮另一个随机 LED，并赋予它一个随机颜色。这个模式不断循环，创造出闪光的效果。把一个透明物体放在顶部，你就能拥有自己的氛围灯。
- en: '![Image](../images/14fig04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14fig04.jpg)'
- en: '**FIGURE 14-4** The Sense HAT sparkles.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 14-4** Sense HAT 闪光效果。'
- en: Open Python and save a new file as *sparkles.py*. Enter the code from [Listing
    14-5](ch14.xhtml#ch14ex05).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Python 并保存一个新文件，命名为 *sparkles.py*。输入[清单 14-5](ch14.xhtml#ch14ex05)中的代码。
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**LISTING 14-5** Choosing random LEDs and colors'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 14-5** 选择随机的 LED 和颜色'
- en: Begin the program by importing the `SenseHat` module. Then import the `randint()`
    function from the `random` module ❶. The `randit()` function, short for *random
    integer*, selects a random integer (a nondecimal number) to use in the program,
    which will give you the random color selection. Next, import the `sleep()` function
    to add a short delay to the program ❷.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入 `SenseHat` 模块开始程序。然后从 `random` 模块导入 `randint()` 函数 ❶。`randint()` 函数是 *随机整数*
    的缩写，用于在程序中选择一个随机整数（即非小数数字），它将为你提供随机的颜色选择。接下来，导入 `sleep()` 函数来给程序添加一个短暂的延迟 ❷。
- en: Create a `while True` loop so the program continuously selects new random LEDs
    and gives them new random colors, creating the sparkling effect ❸. In this `while
    True` loop, build up the details of the random LED. First, the LED’s position
    is selected using random integers for the x- and y-coordinates on the display.
    The x position is a random value between 0 and 7 ❹ that’s stored in a variable
    named `x`. The y value is also a random value between 0 and 7, and it’s stored
    in a variable named `y` ❺. Although you have eight LEDs across and down, in programming
    we start numbering from zero, so the first LED is in position 0, and the second
    is in position 1\. This means that the eighth LED is number 7.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `while True` 循环，使程序不断选择新的随机 LED，并为它们分配新的随机颜色，从而产生闪光效果 ❸。在这个 `while True`
    循环中，构建随机 LED 的细节。首先，LED 的位置是通过为显示屏上的 x 和 y 坐标选择随机整数来确定的。x 位置是一个介于 0 和 7 之间的随机值
    ❹，并将其存储在一个名为 `x` 的变量中。y 值也是介于 0 和 7 之间的随机值，存储在名为 `y` 的变量中 ❺。尽管你有八个 LED 横向和纵向排列，但在编程中我们从零开始编号，因此第一个
    LED 位置是 0，第二个是位置 1。这意味着第八个 LED 是编号 7。
- en: Second, create variables for red, green, and blue, which the program will then
    combine at random to create the LED’s random color. Store the RGB values in the
    variables `r`, `g`, and `b` ❻ ❼ ❽.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，为红色、绿色和蓝色创建变量，程序将随机组合这些颜色，生成 LED 的随机颜色。将 RGB 值存储在变量 `r`、`g` 和 `b` 中 ❻ ❼
    ❽。
- en: Finally, combine all these values and write them to the LEDs with `sense.set_pixel()`
    ❾ followed by the `x`, `y`, `r`, `g`, and `b` variables. When the program runs,
    it will choose a random value for each of those five variables. Finish by adding
    a small pause ❿ before the program loops. Save and run the program, and enjoy
    the light show!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将所有这些值合并并使用 `sense.set_pixel()` ❾ 写入 LED，后跟 `x`、`y`、`r`、`g` 和 `b` 变量。当程序运行时，它会为这五个变量选择一个随机值。最后添加一个小的暂停
    ❿，然后程序进入循环。保存并运行程序，享受这场灯光秀吧！
- en: Creating an Image with the LED Display
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 LED 显示屏创建图像
- en: Images are made up of pixels, which you can think of as tiny dots of color.
    If you treat each individual LED on the Sense HAT display as a pixel, you can
    create an 8 × 8 pixel image, as shown in [Figure 14-5](ch14.xhtml#ch14fig05).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图像由像素组成，你可以将它们看作是微小的彩色点。如果你把每个 Sense HAT 显示屏上的 LED 当作一个像素，你可以创建一个 8 × 8 像素的图像，如
    [图14-5](ch14.xhtml#ch14fig05) 所示。
- en: '![Image](../images/14fig05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14fig05.jpg)'
- en: '**FIGURE 14-5** An 8 × 8 pixel drawing'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**图14-5** 8 × 8 像素绘图'
- en: In this program, you’ll use an array to hold the position and color of each
    LED. An *array* is a list that uses more than one line. Like a list, an array
    is used for holding data, which can be numbers, strings, or symbols. For example,
    `shopping = ['eggs', 'chocolate', 'bread']` is a list. You enclose the lists in
    square brackets, `[ ]`, and can select any item in the list by referring to its
    index number. As you know, the item in the first position (eggs) is 0, the next
    item (chocolate) is 1, then 2, and so on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，你将使用一个数组来保存每个 LED 的位置和颜色。*数组*是一个使用多行的列表。像列表一样，数组用于保存数据，可以是数字、字符串或符号。例如，`shopping
    = ['eggs', 'chocolate', 'bread']` 是一个列表。你将列表用方括号 `[ ]` 括起来，并可以通过引用索引编号来选择列表中的任何项目。如你所知，第一个位置的项目（eggs）是
    0，接下来的项目（chocolate）是 1，然后是 2，以此类推。
- en: Your array will contain 64 entries, one for each LED. This way, you can control
    each LED individually, turning it on or off and setting the color. For simplicity,
    the array is divided into eight lines consisting of eight entries each, mimicking
    the layout of the LED display. Start a new Python file and save it as *face.py*.
    Enter the program code in [Listing 14-6](ch14.xhtml#ch14ex06) to create a smiley
    face emoji.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数组将包含 64 个条目，每个条目对应一个 LED。这样，你就可以单独控制每个 LED，开关它并设置颜色。为简单起见，数组被分为八行，每行包含八个条目，模仿了
    LED 显示屏的布局。创建一个新的 Python 文件并保存为 *face.py*。输入 [清单14-6](ch14.xhtml#ch14ex06) 中的程序代码，创建一个笑脸表情符号。
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**LISTING 14-6** Drawing a smiley face emoji'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 14-6** 绘制一个笑脸表情符号'
- en: 'Start the program by importing the `SenseHat` module. Then assign RGB values
    to four color variables: `R` for red ❶, `O` for black ❷, `B` for blue ❸, and `Y`
    for yellow ❹. To create black as we see it, you have to turn off all the color
    by setting the RGB to 0, 0, 0 ❷. Of course, you can also adjust the RGB values
    to create your own customized colors for the face.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入 `SenseHat` 模块来启动程序。然后将 RGB 值分配给四个颜色变量：`R` 代表红色 ❶，`O` 代表黑色 ❷，`B` 代表蓝色 ❸，`Y`
    代表黄色 ❹。为了创建我们所见的黑色，你需要通过将 RGB 设置为 0, 0, 0 来关闭所有颜色 ❷。当然，你也可以调整 RGB 值，创建你自己的自定义颜色。
- en: Next, create an array called `face` ❺ to hold the color and position of each
    LED. Populate the array with the proper color variables ❻. Each of the list’s
    eight lines contains eight individual entries. Typing `B, B, B, B, B, B, B, B`,
    for example, would set the top line of LEDs to blue, because the variable `B`
    represents the RGB value for blue.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `face` ❺ 的数组，用来保存每个 LED 的颜色和位置。用适当的颜色变量 ❻ 填充数组。每行列表包含八个条目。例如，输入 `B,
    B, B, B, B, B, B, B` 会将 LED 显示屏的顶部一行设置为蓝色，因为变量 `B` 代表蓝色的 RGB 值。
- en: Note that the final line of the array doesn’t end with a comma. This indicates
    that it’s the end of the array, and Python should expect no more values. Close
    the array with a closing square bracket.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数组的最后一行没有以逗号结尾。这表示数组的结束，Python 应该不再期待更多的值。用一个右方括号来关闭数组。
- en: Finally, tell Python to write the elements in the array to the LED display ❼.
    This turns on each LED with the relevant color, building up the image.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，告诉 Python 将数组中的元素写入 LED 显示屏 ❼。这将点亮每个 LED，并赋予其相应的颜色，从而构建出图像。
- en: Save and run the program. You’ll see a smiley face appear on the Sense HAT display,
    as shown in [Figure 14-6](ch14.xhtml#ch14fig06).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行程序。您将在Sense HAT显示器上看到一个微笑的脸，如[图14-6](ch14.xhtml#ch14fig06)所示。
- en: '![Image](../images/14fig06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14fig06.jpg)'
- en: '**FIGURE 14-6** Smiley face displayed on the Sense HAT'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**图14-6** 微笑脸显示在Sense HAT上'
- en: Have a go at creating another face—or maybe an animal, car, plane, or tree.
    You may find it helpful to draw your image ahead of time by shading in squares
    in a similar 8 × 8 square grid.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建另一个图形——也许是一个动物、汽车、飞机或树。你可能会发现提前通过在类似的8 × 8方格中填充方块来绘制图像会很有帮助。
- en: '[Figure 14-7](ch14.xhtml#ch14fig07) shows some examples. Can you guess what
    they are?'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-7](ch14.xhtml#ch14fig07)显示了一些示例。你能猜出它们是什么吗？'
- en: '![Image](../images/14fig07.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14fig07.jpg)'
- en: '**FIGURE 14-7** Try displaying one of these icons on your Sense HAT.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**图14-7** 尝试在Sense HAT上显示这些图标。'
- en: Creating Images with the Grid Draw Program
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Grid Draw程序创建图像
- en: Creating images by using an array is fun but can be time-consuming. Using an
    array can also become frustrating if you’re trying to draw something precisely.
    Another way to create images is to use 8x8GridDraw, an interactive program designed
    to make creating images on Sense HAT a lot easier.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组创建图像虽然很有趣，但也可能很耗时。如果您试图精确地绘制某个图形，使用数组可能会让人沮丧。创建图像的另一种方法是使用8x8GridDraw，这是一个交互式程序，旨在使在Sense
    HAT上创建图像变得更加容易。
- en: 'Once installed, the 8x8GridDraw program allows you to do the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，8x8GridDraw程序允许您执行以下操作：
- en: Create an image on an 8 × 8 grid and write it directly to the LED display.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在8 × 8的网格上创建图像并直接将其写入LED显示器。
- en: Choose from nine colors.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从九种颜色中进行选择。
- en: Export the image as a set of code, which you can add to your Python program.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像导出为一组代码，您可以将其添加到您的Python程序中。
- en: Export and save the image as a PNG file.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出并保存图像为PNG文件。
- en: Rotate the image on the LED display.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在LED显示器上旋转图像。
- en: Add new frames to create a simple animation.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新帧以创建简单的动画。
- en: 'This project will be slightly more involved than those you’ve done so far in
    this chapter, so I’ll walk you through it step-by-step:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目会比您在本章中完成的那些稍微复杂一些，所以我会一步一步地指导您：
- en: '**Install the software:** To install the software, open the terminal window
    and enter the following:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安装软件：** 要安装该软件，请打开终端窗口并输入以下命令：'
- en: '[PRE7]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This installs the software library, which enables you to export and save your
    image as a small 8 × 8 pixel PNG file.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将安装软件库，使您能够将图像导出并保存为一个小的8 × 8像素PNG文件。
- en: 'Next, install the main program by entering this command:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，输入以下命令安装主程序：
- en: '[PRE8]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This downloads the required files to a new folder. Once completed, you’ll have
    a new folder that contains several programs related to 8x8GridDraw.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会将所需文件下载到一个新文件夹中。完成后，您将拥有一个新文件夹，其中包含多个与8x8GridDraw相关的程序。
- en: '**Create an image:** Let’s have a go at creating an image. First, you need
    to start the program. Return to the terminal and enter the following:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建图像：** 让我们尝试创建一个图像。首先，您需要启动程序。返回终端并输入以下命令：'
- en: '[PRE9]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This command navigates to the program folder for 8x8Grid-Draw. To run the program,
    enter this:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令导航到8x8Grid-Draw程序文件夹。要运行程序，请输入以下命令：
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This loads the main window, shown in [Figure 14-8](ch14.xhtml#ch14fig08).
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将加载主窗口，如[图14-8](ch14.xhtml#ch14fig08)所示。
- en: '![Image](../images/14fig08.jpg)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/14fig08.jpg)'
- en: '**FIGURE 14-8** The Sense HAT Grid Editor'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图14-8** Sense HAT网格编辑器'
- en: Clicking a circle on the grid will fill the square surrounding it with color.
    To change the color, select a new color from the right side. To turn off an LED,
    double-click the square, and it will return to the original transparent outline.
    You draw images by filling particular squares with chosen colors. Go ahead and
    create a simple image.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击网格上的圆圈将填充周围的方块颜色。要更改颜色，从右侧选择一个新的颜色。要关闭LED，双击该方块，它将恢复到原始的透明轮廓。您通过填充特定方块并选择颜色来绘制图像。继续尝试创建一个简单的图像吧。
- en: '**Display the image:** Once you have created your image (like the tree in [Figure
    14-9](ch14.xhtml#ch14fig09)), you can write the image into your Sense HAT. Locate
    and then click the **Play on LEDs** button. Your image will show up on the Sense
    HAT’s LEDs. Check it out!![Image](../images/14fig09.jpg)'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**显示图像：** 一旦您创建了图像（如[图14-9](ch14.xhtml#ch14fig09)中的树），您可以将图像写入Sense HAT。找到并点击**LED上播放**按钮，您的图像将出现在Sense
    HAT的LED上。快来看看吧！！[Image](../images/14fig09.jpg)'
- en: '**FIGURE 14-9** Click the **Play on LEDs** button to make your drawing appear
    on the Sense HAT.'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图14-9** 点击**LED上播放**按钮，将您的绘图显示在Sense HAT上。'
- en: '**Export the image:** Once you have completed your image, you can export it.
    You could export it as code and then add it to your other programs, but it’s much
    easier to export it as a PNG, so that’s what you’ll do now.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导出图像：** 完成图像后，你可以导出它。你可以将其导出为代码，然后将其添加到其他程序中，但导出为PNG格式要简单得多，所以现在你就会这么做。'
- en: Click the **Export to PNG** button on the GUI and save the file in the *RPi_8
    x 8 GridDraw* folder ([Figure 14-10](ch14.xhtml#ch14fig10)). To load the image,
    it needs to be located in the same folder as your program code, so you may need
    to copy your image from this folder into the same folder where your Python program
    code is saved.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击图形用户界面上的**导出为PNG**按钮，并将文件保存在*RPi_8 x 8 GridDraw*文件夹中（[图 14-10](ch14.xhtml#ch14fig10)）。要加载该图像，必须将其与程序代码位于同一文件夹中，因此你可能需要将图像从该文件夹复制到保存Python程序代码的文件夹中。
- en: '![Image](../images/14fig10.jpg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Image](../images/14fig10.jpg)'
- en: '**FIGURE 14-10** Exporting your file as a PNG will save it in the *RPi_8x8
    GridDraw* folder.'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 14-10** 将文件导出为PNG格式会将其保存在*RPi_8x8 GridDraw*文件夹中。'
- en: 'This will produce a small 8 × 8 PNG file, which you can load onto the Sense
    HAT with the following line of code written into your Python program:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成一个小的8 × 8 PNG文件，你可以使用以下代码将其加载到Sense HAT中：
- en: '[PRE11]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that you can create drawings, you have everything you need to program a
    game of rock, paper, scissors, lizard, Spock.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建图像了，你具备了编写石头、剪刀、布、蜥蜴、斯波克游戏所需的一切。
- en: BUILDING THE ROCK, PAPER, SCISSORS, LIZARD, SPOCK GAME
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建石头、剪刀、布、蜥蜴、斯波克游戏
- en: '**NOTE**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This variation on the game was originally created by Sam Kass and Karen Bryla
    (*[http://www.samkass.com/theories/rpssl.html](http://www.samkass.com/theories/rpssl.html)*)*.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个游戏的变种最初由Sam Kass和Karen Bryla创建（* [http://www.samkass.com/theories/rpssl.html](http://www.samkass.com/theories/rpssl.html)）*。'
- en: You’re probably already familiar with rock, paper, scissors. You and an opponent
    play by forming a rock, a piece of paper, or a pair of scissors with your hands;
    each object beats—and gets beaten by—a different one. The issue with the original
    game is that it’s too easy to predict the outcome (because only three possible
    results exist, other than a tie). During season two of the popular TV show *The
    Big Bang Theory*, the character Sheldon makes the classic game more exciting and
    challenging by using an alternative version that adds Spock and lizard to the
    three original choices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经熟悉了石头、剪刀、布。你和对手通过用手形成一块石头、一张纸或者一把剪刀来玩，每个物品击败—并被—另外的物品击败。原始游戏的问题是，结果太容易预测（因为只有三种可能的结果，除了平局）。在热门电视剧《生活大爆炸》的第二季中，角色谢尔顿通过使用一种替代版本将经典游戏变得更加刺激和具有挑战性，该版本将斯波克和蜥蜴添加到原本的三种选择中。
- en: To play Spock, you use the Vulcan hand sign from the TV series *Star Trek*.
    To play a lizard, you make your hand into a sock-puppet-like mouth.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示斯波克，你可以使用来自电视剧*星际迷航*的瓦肯手势。要表示蜥蜴，你可以将手做成类似袜子木偶的嘴巴形状。
- en: Wondering how they work? Well, Spock smashes scissors and vaporizes the rock.
    However, he is poisoned by the lizard and disproved by the paper. The lizard poisons
    Spock and eats the paper, but it is crushed by the rock and decapitated by the
    scissors. Gruesome! Adding these options creates more possible combinations and
    makes the overall game much more exciting and less predictable. [Figure 14-11](ch14.xhtml#ch14fig11)
    shows all of the hand signs (arrows are pointing at the move that is defeated
    by the move at a given arrow’s origin).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道它们如何工作吗？斯波克击败剪刀并蒸发石头。然而，他会被蜥蜴毒死，并被纸张驳斥。蜥蜴毒死斯波克并吃掉纸张，但它会被石头压碎并被剪刀砍头。太血腥了！添加这些选项创造了更多可能的组合，使整个游戏更刺激，且不易预测。[图
    14-11](ch14.xhtml#ch14fig11)展示了所有手势（箭头指向被给定箭头起点的手势所击败的动作）。
- en: In our version of the game, RPSLS, the player will select one of the five options
    by scrolling through the five images with the Sense HAT’s joystick. The player
    presses the joystick in, like a button, to select an option. Then the Raspberry
    Pi will randomly select its option. The game will compare both options and choose
    a winner. The player will then be able to choose to play another game or quit.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们版本的游戏RPSLS中，玩家将通过使用Sense HAT的摇杆滚动五个图像中的一个来选择其中一个选项。玩家按下摇杆，就像按下按钮一样来选择一个选项。然后，树莓派会随机选择一个选项。游戏将比较两个选项并选出一个胜者。然后，玩家可以选择继续玩下一局或者退出游戏。
- en: '![Image](../images/14fig11.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/14fig11.jpg)'
- en: '**FIGURE 14-11** How to play rock, paper, scissors, lizard, Spock'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 14-11** 如何玩石头、剪刀、布、蜥蜴、斯波克'
- en: First you need an 8 × 8 PNG image for each option. You can either make these
    yourself or download the example ones used in this chapter from *[https://www.nostarch.com/raspiforkids/](https://www.nostarch.com/raspiforkids/)*
    and save them in the folder you’re using for this project. Note that if you create
    your own images, you’ll need to save them as *0.png*, *1.png*, *2.png*, *3.png*,
    and *4.png*. These are the image filenames the program will look for.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为每个选项准备一张 8 × 8 的 PNG 图像。你可以自己制作这些图像，或者从 *[https://www.nostarch.com/raspiforkids/](https://www.nostarch.com/raspiforkids/)*
    下载本章使用的示例图像，并将它们保存在你为这个项目使用的文件夹中。请注意，如果你自己创建图像，你需要将它们保存为 *0.png*、*1.png*、*2.png*、*3.png*
    和 *4.png*。这些是程序将要查找的图像文件名。
- en: Importing Modules and Creating the Variables
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入模块并创建变量
- en: Open your Python editor and add the code in [Listing 14-7](ch14.xhtml#ch14ex07).
    Save the program as *RPSLS.py*, and make sure the program file is saved into the
    same folder as the images are saved in, or the program won’t know where to find
    them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 Python 编辑器，添加 [Listing 14-7](ch14.xhtml#ch14ex07) 中的代码。将程序保存为 *RPSLS.py*，并确保程序文件保存在与图像相同的文件夹中，否则程序将无法找到它们。
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**LISTING 14-7** Adding the modules and global variables'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 14-7** 添加模块和全局变量'
- en: Begin the program by importing the `SenseHat` module ❶ that enables the player
    to control the joystick, scroll text, and display images on the LED matrix. Then
    import the `random` module to enable the Raspberry Pi to select a random number
    and the `time` module to add small pauses.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入 `SenseHat` 模块 ❶ 开始程序，该模块使玩家能够控制摇杆、滚动文本并在 LED 矩阵上显示图像。接着导入 `random` 模块，以便树莓派能够选择一个随机数，并导入
    `time` 模块来添加短暂的暂停。
- en: Next, set up three global variables, which you’ll be able to access from anywhere
    in the program (unlike local variables defined inside a particular function, which
    can be accessed only within that function).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置三个全局变量，程序中的任何地方都可以访问这些变量（与定义在特定函数内部的局部变量不同，局部变量只能在该函数内访问）。
- en: The first variable ❷ stores the player’s choice of rock, paper, scissors, lizard,
    or Spock. You use the second variable ❸ to store the amount of time the Raspberry
    Pi has to make its move. The number will be random, creating the illusion that
    the Raspberry Pi is taking its time to select its choice. You use the next variable
    ❹ to store the Raspberry Pi’s choice for later use. Finally, create a variable
    named `gameRunning` ❺ to hold the status of the game. The value `True` means the
    game is currently running.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量 ❷ 存储玩家选择的石头、剪刀、布、蜥蜴或斯波克。你使用第二个变量 ❸ 来存储树莓派做出选择的时间。这个时间将是随机的，制造出树莓派花时间选择的假象。接下来使用第三个变量
    ❹ 来存储树莓派的选择，以便稍后使用。最后，创建一个名为 `gameRunning` ❺ 的变量，用于保存游戏的状态。值为 `True` 表示游戏正在进行。
- en: Preparing the Game
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 准备游戏
- en: The code in [Listing 14-8](ch14.xhtml#ch14ex08) prepares the Sense HAT for the
    RPSLS game.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 14-8](ch14.xhtml#ch14ex08) 中的代码为 RPSLS 游戏准备了 Sense HAT。'
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**LISTING 14-8** Creating the initial game settings'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 14-8** 创建初始游戏设置'
- en: First, initialize the Sense HAT ❶ and load the first image for the game ❷. Then
    reduce the brightness of the LEDs ❸. This is useful if the LEDs are too bright;
    dimmer lights are better for your eyes. You can adjust this later to suit your
    tastes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，初始化 Sense HAT ❶ 并加载游戏的第一张图像 ❷。然后调低 LED 的亮度 ❸。如果 LED 太亮，这个步骤很有用；较暗的灯光对眼睛更友好。你可以稍后根据自己的喜好调整亮度。
- en: 'For the start of the game, set `playersChoice` to `0` ❹. This is the first
    option in the list that the player can select. Remember that in programming, the
    first option in a list is in position `0`. The `PlayersChoice` variable will hold
    a number between `0` and `4` that represents the player’s option: `0` is rock,
    `1` is Spock, `2` is paper, `3` is lizard, and `4` is scissors. The player will
    get to select an option when the game begins by scrolling through the options
    with the joystick.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开始时，将 `playersChoice` 设置为 `0` ❹。这是玩家可以选择的列表中的第一个选项。请记住，在编程中，列表中的第一个选项是位置
    `0`。`PlayersChoice` 变量将保存一个介于 `0` 和 `4` 之间的数字，表示玩家的选择：`0` 代表石头，`1` 代表斯波克，`2` 代表布，`3`
    代表蜥蜴，`4` 代表剪刀。游戏开始时，玩家可以通过摇杆浏览选项来选择一个。
- en: Setting Up the Player’s Choice
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置玩家选择
- en: Now, you’ll create the function that will convert the player’s choice from a
    number into its corresponding rock, paper, scissors, lizard, or Spock image. Enter
    the code in [Listing 14-9](ch14.xhtml#ch14ex09).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将创建一个函数，将玩家的选择从数字转换为对应的石头、剪刀、布、蜥蜴或斯波克图像。输入 [Listing 14-9](ch14.xhtml#ch14ex09)
    中的代码。
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**LISTING 14-9** Setting up the player’s choice'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 14-9** 设置玩家的选择'
- en: Create and name the function ❶ that checks which option the player has selected
    with the joystick (the option is stored as a number, and then that number is converted
    into the name of the option).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并命名函数❶，该函数检查玩家通过操纵杆选择了哪个选项（选项存储为一个数字，然后将该数字转换为选项的名称）。
- en: This function uses conditionals ❷ to check each number and then assigns the
    name of the option for each number that’s selected. The first conditional checks
    whether the value `0` is selected and returns `Rock` if it is. If `0` isn’t selected,
    the program checks for the number `1`. If `1` is selected, the program returns
    `Spock`, and if it isn’t, the program checks for the number `2`. The program continues
    until it has checked for every possible selection.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用条件判断❷来检查每个数字，然后为每个被选中的数字分配对应的选项名称。第一个条件判断检查是否选择了值为`0`的选项，如果是，则返回`Rock`（石头）。如果没有选择`0`，程序会检查是否选择了`1`。如果选择了`1`，程序返回`Spock`（斯波克），如果没有选择`1`，程序会继续检查数字`2`。程序会一直继续检查直到所有可能的选择都被检查完。
- en: Selecting an Object
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择一个对象
- en: The next section of the program creates a function that holds the main gameplay
    mechanics. The player will use the Sense HAT’s joystick to scroll through the
    five options. The LED display will show each option as the player scrolls through.
    To select one, the player must click using the joystick. Add the code in [Listing
    14-10](ch14.xhtml#ch14ex10) to your program.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的下一部分创建了一个包含主要游戏机制的函数。玩家将使用Sense HAT的操纵杆滚动浏览五个选项。当玩家滚动浏览时，LED显示屏将显示每个选项。要选择一个选项，玩家必须使用操纵杆点击。将[Listing
    14-10](ch14.xhtml#ch14ex10)中的代码添加到你的程序中。
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**LISTING 14-10** Coding the player’s object selection'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 14-10** 编码玩家的对象选择'
- en: Begin this function by importing the global variables you created earlier ❶.
    Add your `while running = True` statement, which indicates that the game is in
    play.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入之前创建的全局变量❶开始这个函数。添加你的`while running = True`语句，表示游戏正在进行中。
- en: Rotate the image displayed on the LEDs so it’s oriented correctly with respect
    to the joystick ❷. Now start checking for joystick movements ❸, called *events*
    in the Sense HAT stick events.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转LED上显示的图像，使其与操纵杆正确对齐❷。现在开始检查操纵杆的移动❸，这些移动在Sense HAT的操纵杆事件中被称为*事件*。
- en: First the program checks whether the joystick has been `pressed` (moved) and
    whether `playersChoice` is set to a value of less than 5\. If the value is less
    than 5, the player hasn’t reached the end of the images. At the start of the program,
    you assigned `playersChoice` a value of 0, which means that the conditional on
    line ❹ is `True` when you first run the program, because 0 is less than 5, so
    the next lines of code run.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，程序检查操纵杆是否已被`按下`（移动），并且检查`playersChoice`是否小于5。如果值小于5，说明玩家还没有到达图像的末尾。在程序开始时，你将`playersChoice`的值设置为0，这意味着在第一次运行程序时，❹行的条件为`True`，因为0小于5，因此接下来的代码行会被执行。
- en: Now check whether the joystick has been moved up, using `event.direction ==
    'up'` ❺. The line below prints out the name of the option that the player selected.
    You won’t normally see this when playing the game, as RPSLS is designed to be
    stand-alone. However, this line is useful for testing that the selection part
    of the program is working correctly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查操纵杆是否向上移动，使用`event.direction == 'up'` ❺。下面的代码将打印出玩家选择的选项名称。在游戏过程中你通常不会看到这个输出，因为RPSLS被设计为独立运行。然而，这一行代码对于测试程序中的选择部分是否正常工作非常有用。
- en: The program then loads the first image file, *0.png*, which is the image of
    the rock ❻. The next line increases the `playersChoice` variable by 1, which loads
    *1.png* the next time the joystick is moved up. Eventually, the `playersChoice`
    value will reach the top value of 5, the last option in the list, Spock ❼. At
    this point, there are no other options to select in the list, so `playersChoice`
    returns to 0, loading the rock image again. This loop continues until the player
    selects an object by pressing the middle button with the joystick ❽; this acts
    like pressing ENTER and therefore selects the player’s choice of option. This
    sets the `running` variable to `False`, which stops the loop. The break at line
    ❾ moves the program into the next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 程序随后加载第一个图片文件，*0.png*，它是石头的图片 ❻。接下来的代码会将`playersChoice`变量增加1，下一次摇杆向上移动时会加载*1.png*。最终，`playersChoice`值会达到列表中的最大值5，对应最后一个选项，斯波克
    ❼。此时，列表中没有其他选项可以选择，因此`playersChoice`会回到0，重新加载石头的图片。这个循环将继续，直到玩家通过按下摇杆中的间接按钮 ❽来选择一个物品，这就像按下ENTER键，因此选择了玩家的选项。此时，`running`变量设置为`False`，从而停止循环。第❾行的break将程序带到下一个部分。
- en: Notifying the Player of Their Option Choice
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通知玩家他们的选项
- en: Once the player has selected an object, the code in [Listing 14-11](ch14.xhtml#ch14ex11)
    will notify them of their option choice.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家选择物品后，[Listing 14-11](ch14.xhtml#ch14ex11)中的代码将通知玩家他们的选择。
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**LISTING 14-11** Notifying the player of their choice'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 14-11** 通知玩家其选择'
- en: The line at ❶ is an optional test to see whether the program has selected the
    correct image file; remove it once you are happy that the program is running correctly
    by commenting out that line with a hash mark. The line at ❷ runs your object number
    through the `number_to``_name(number)` function, which you wrote in [Listing 14-9](ch14.xhtml#ch14ex09).
    This converts your number into the name of the option and returns that name so
    it can be scrolled as text across the LEDs. This name of the option is stored
    in the `playerMessage` variable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第❶行是一个可选的测试，检查程序是否选择了正确的图片文件；当你确认程序正确运行后，可以通过加上井号注释掉该行。第❷行通过`number_to_name(number)`函数将物品编号传入，该函数你在[Listing
    14-9](ch14.xhtml#ch14ex09)中编写过。该函数将数字转换为选项名称，并返回该名称，以便在LED上显示。选项的名称会被存储在`playerMessage`变量中。
- en: Coding the Raspberry Pi’s Selection
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写树莓派的选择代码
- en: Now it’s the Raspberry Pi’s turn to select its object. Copy the code from [Listing
    14-12](ch14.xhtml#ch14ex12) into your program.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到树莓派选择它的物品了。将[Listing 14-12](ch14.xhtml#ch14ex12)中的代码复制到你的程序中。
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**LISTING 14-12** Coding the Raspberry Pi’s object selection'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 14-12** 编写树莓派的物品选择代码'
- en: Use the `random.randrange()` function ❶ to get the program to generate a number
    between 5 and 50\. Then store this number in a variable named `count`. This `count`
    value creates a delay of 0.10 to 5 seconds between the player selecting their
    option and the Raspberry Pi’s selection. During this delay, the five images are
    repeatedly displayed and changed, creating the illusion that the Raspberry Pi
    is scrolling through the options and thinking about which option to choose.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`random.randrange()`函数 ❶生成一个5到50之间的数字，然后将该数字存储在名为`count`的变量中。此`count`值为玩家选择选项与树莓派选择之间创建0.10到5秒之间的延迟。在此期间，五张图片会反复显示和更换，营造出树莓派在浏览选项并思考选择哪个的错觉。
- en: The images are selected on line ❷, where the program picks a random number between
    0 and 5\. Each number is associated with an image file. On line ❸, make the `computer_choice`
    value into a string and add the `.png` extension so that the name you pass to
    `sense.load_image()` matches the name of one of the image files. That image file
    is loaded.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图片在第❷行被选择，程序会从0到5之间随机选择一个数字。每个数字都对应一个图片文件。在第❸行，将`computer_choice`的值转化为字符串并添加`.png`扩展名，这样传递给`sense.load_image()`的文件名就会与其中一个图片文件的名字匹配，随后该图片文件被加载。
- en: Use a small pause to allow the player to view the image before the loop runs
    again and displays another image. Subtract a value of 1 from `count` ❹ to keep
    the count decreasing; this ensures that the delay will eventually reach 0 and
    run out.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个小的暂停来让玩家在循环再次运行并显示另一张图片之前查看该图片。通过从`count`中减去1 ❹来保持计数递减，这确保延迟最终会达到0并结束。
- en: If the `count` value is greater than 1, the loop continues, an image is displayed,
    and 1 is subtracted from `count`. This continues until the count reaches 0\. Then
    the current image displayed is selected as the Raspberry Pi’s choice; it has made
    its selection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`count`值大于1，循环继续，显示一张图像，并从`count`中减去1。这将一直持续，直到count值达到0。然后，当前显示的图像被选定为树莓派的选择；它已经做出了选择。
- en: Displaying the Raspberry Pi’s Choice
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示树莓派的选择
- en: In the next section of the program, shown in [Listing 14-13](ch14.xhtml#ch14ex13),
    you tell the player which option the Raspberry Pi selected by showing it on the
    Sense HAT.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的下一部分，如[Listing 14-13](ch14.xhtml#ch14ex13)所示，你将通过在Sense HAT上显示来告诉玩家树莓派选择了哪个选项。
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**LISTING 14-13** Displaying the Raspberry Pi’s selection'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 14-13** 显示树莓派的选择'
- en: Store the program’s choice in the `number` variable ❶ so you can use `number`
    to represent the Pi’s choice in the rest of the program.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序的选择存储在`number`变量中❶，以便在程序的其他部分使用`number`来表示树莓派的选择。
- en: Set the image rotation to the correct angle ❷. Then scroll a message across
    the LED display, announcing the Raspberry Pi’s choice ❸. The code `text_colour=[0,
    150, 255]`, where the three values represent the RGB value, sets the color of
    the text. You can also adjust the speed of the scroll to any value between 0 and
    1.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像旋转调整到正确的角度❷。然后，在LED显示屏上滚动一条消息，宣布树莓派的选择❸。代码`text_colour=[0, 150, 255]`，其中三个值代表RGB值，设置文本的颜色。你还可以调整滚动的速度，设定在0到1之间的任何值。
- en: Next, load the image corresponding to the number that the Raspberry Pi selected
    ❹. If, for example, the Raspberry Pi selected option number 3, the program would
    load and display the image of the lizard. Add a short pause ❺ before the program
    calculates the winner of the game.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，加载与树莓派选择的数字对应的图像❹。例如，如果树莓派选择了第3个选项，程序将加载并显示蜥蜴的图像。在程序计算游戏的赢家之前，添加一个短暂的暂停❺。
- en: Choosing a Winner
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择一个赢家
- en: The final part of the `mainGame()` function, shown in [Listing 14-14](ch14.xhtml#ch14ex14),
    compares the player’s option with the Raspberry Pi’s option and calculates the
    winner of that round. This uses a branch of math called *modulus*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainGame()`函数的最后部分，如[Listing 14-14](ch14.xhtml#ch14ex14)所示，比较玩家的选项与树莓派的选项，并计算该轮的赢家。这使用了一种叫做*模运算*的数学分支。'
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**LISTING 14-14** Calculating the winner'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 14-14** 计算赢家'
- en: First, create a variable called `result` ❶ to store a particular value, which
    you’ll use to determine who won. The math behind the calculation is interesting.
    In general, this line subtracts the value that corresponds to the Pi’s option
    choice away from the player’s choice value (which already has 1 subtracted from
    it). For example, if the Pi’s value is 5 and the player’s value is 3, you’d calculate
    5 - (3 - 1) to 5 - 2, which equals 3\. The modulo of this number by 5 is then
    found; the *modulo* is the remainder from the division. In this example, the answer
    would be 2, because 3 goes into 5 once with a remainder of 2\. The number 2 is
    then used to determine whether the player or the Pi has won the game.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`result`❶的变量来存储一个特定的值，您将用它来确定谁赢了。这个计算背后的数学原理很有趣。通常，这一行代码将树莓派选项对应的值从玩家选项值中减去（玩家选项已经减去1）。例如，如果树莓派的值是5，而玩家的值是3，您会计算5
    - (3 - 1)，即5 - 2，结果为3。然后，求这个数字对5的模；*模*是除法的余数。在这个例子中，答案是2，因为3除以5的商是0，余数是2。数字2随后用于确定玩家或树莓派是否赢得了游戏。
- en: If the `result` value is equal to 0, both players picked the same option, and
    the game ends in a tie ❷. Make the message `Player and Pi Tie!` scroll across
    the LED display ❸. Again, you can adjust the color and speed of the text scroll.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`result`值等于0，说明两位玩家选择了相同的选项，游戏以平局结束❷。使消息`Player and Pi Tie!`滚动显示在LED屏幕上❸。同样，你可以调整文本滚动的颜色和速度。
- en: If the value of `result` is greater than or equal to 3, your option beats the
    Raspberry Pi’s option, and you win the game ❹. Make the message `Player Wins!`
    scroll across the LED display ❺.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`result`的值大于或等于3，说明你的选项击败了树莓派的选项，你赢得了游戏❹。使消息`Player Wins!`滚动显示在LED屏幕上❺。
- en: The final possible outcome of the game is that the Raspberry Pi’s choice beats
    yours ❻. This is the case if anything other than the first two possibilities occurs.
    If this happens, scroll a message telling the player that the Raspberry Pi wins.
    You can customize the color and the speed of the message ❼.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的最终可能结果是树莓派的选择胜过你的选择❻。如果发生前三种以外的任何情况，就会出现这种情况。如果发生这种情况，显示一条消息告诉玩家树莓派获胜。你可以自定义消息的颜色和速度❼。
- en: 'This completes all of the code for the `mainGame()` function that controls
    the essential gameplay mechanics of rock, paper, scissors, lizard, Spock. To recap:
    the function enables the player to select an option and then makes the Raspberry
    Pi select an option (after a delay, to make it seem like the Pi is thinking).
    It then compares the two options to calculate the winner of the game and scrolls
    a message updating the player on the outcome.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了`mainGame()`函数的所有代码，控制着石头、剪子、布、蜥蜴、斯波克游戏的基本玩法机制。回顾一下：这个函数让玩家选择一个选项，然后让树莓派选择一个选项（延迟一段时间，使其看起来像是树莓派在思考）。接着，它比较两个选项来计算游戏的胜者，并滚动一条更新玩家结果的消息。
- en: Starting a New Game
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开始新游戏
- en: You’re almost done! [Listing 14-15](ch14.xhtml#ch14ex15) is the initial welcome
    section of the game. It introduces the game and then runs the `mainGame()` function
    (whereas before you were simply defining the `mainGame()` function). After a round
    has finished, it also gives the player the option to play again by moving the
    joystick up or to end the game by moving the joystick down.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你快完成了！[Listing 14-15](ch14.xhtml#ch14ex15)是游戏的初始欢迎部分。它介绍了游戏，然后运行`mainGame()`函数（而之前你只是定义了`mainGame()`函数）。一轮结束后，它还提供了玩家通过向上移动摇杆重新开始游戏或通过向下移动摇杆结束游戏的选项。
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**LISTING 14-15** Starting the game'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 14-15** 启动游戏'
- en: Begin by adding the welcome message. You can customize this, but in my experience,
    I’ve found that simple messages work best, since most players just want the game
    to begin. Then add a second message that tells the player how to select an option.
    Again, feel free to adjust the color and scroll speed for each message. If at
    first you want a slower scroll speed, try setting it to 0.60 instead. Once you
    are familiar with the game, you’ll want to just get on with it and not wait for
    slow scrolling text.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时添加欢迎消息。你可以自定义消息，但根据我的经验，我发现简单的消息效果最佳，因为大多数玩家只希望游戏开始。然后添加第二条消息，告诉玩家如何选择选项。再次强调，可以调整每条消息的颜色和滚动速度。如果一开始你想要更慢的滚动速度，可以将其设置为0.60。一旦你熟悉了游戏，你就不想再等待慢速滚动的文本了。
- en: Then add `sense.load_image("0.png")`, the code that loads the first image, and
    shows it on the LED display. This is your rock image.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加`sense.load_image("0.png")`，该代码加载第一张图片并显示在LED显示屏上。这是你的石头图片。
- en: These three lines will run only the first time the program is executed, because
    you don’t need to have the welcome message and instructions show every time you
    play the game, just the first time it loads. Therefore, keep these lines of code
    outside the `mainGame()` function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行代码只会在程序第一次执行时运行，因为你不需要每次玩游戏时都显示欢迎消息和说明，而是只需要在程序第一次加载时显示。因此，将这些代码行保留在`mainGame()`函数外。
- en: Play Again?
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重新开始游戏？
- en: End your program with code that checks whether the player wants to play again.
    Add the code in [Listing 14-16](ch14.xhtml#ch14ex16).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 用代码结束你的程序，检查玩家是否想要再次玩游戏。将代码添加到[Listing 14-16](ch14.xhtml#ch14ex16)中。
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**LISTING 14-16** Starting a new game'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 14-16** 开始新游戏'
- en: For this, use a `while` loop named `gameRunning`, which you set to `True`; as
    long as the variable is set to `True`, the game will keep running ❶.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，使用一个名为`gameRunning`的`while`循环，并将其设置为`True`；只要变量设置为`True`，游戏就会继续运行❶。
- en: Now create another variable to hold a value that indicates whether the player
    wants to play again ❷. Use a value of 1 to signify the player wants to start a
    new game. A value of 0 would mean that the player doesn’t want to play again.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建另一个变量，用来保存一个值，表示玩家是否想要重新开始游戏❷。使用值1表示玩家想要开始一局新游戏。值为0则表示玩家不想重新开始游戏。
- en: The next line of code calls the `mainGame()` function, which holds the main
    gameplay elements and starts the game. After the first game is completed, a message
    scrolls across the LED display asking the player whether they wish to play again
    ❸. Now, because the `play_again` variable is set to 1 ❹, the program waits for
    the player to move the joystick ❺. If the player moves the joystick up, the variable
    `play_again` is set to a value of 0 ❻. This breaks the `play_again` loop ❹ and
    returns to the main loop, which loads the `mainGame()` function ❸ and begins the
    game again.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: If the player moves the joystick down ❼, a message appears, informing the player
    that the game is ending ❽. The `play_again` variable is reset to 0 ❾ and, most
    important, the `gameRunning` variable is set to `False` ❿. So when the program
    loops back to the beginning, `gameRunning` no longer has a value of `True`, which
    means the `mainGame()` function doesn’t load, and the program ends. To play the
    game again, you’d have to start up the entire program by pressing F5.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: This completes the program code for rock, paper, scissors, lizard, Spock. Double-check
    that your five images are saved into the same folder as the program code, and
    then give it a test run. A lot of indentation levels need to be exact, so ensure
    that you double-check them if your program doesn’t run the way you expect it to.
    Have fun!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: WRAPPING UP
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have RPSLS working, you can customize your version of the game. Why
    not try creating your own images for rock, paper, scissors, lizard, Spock? Add
    sound effects or a scoring system. Adapt the code so that you can play another
    human being rather than your Raspberry Pi. Also, if you want to see Sheldon in
    full effect, check out [*https://www.youtube.com/watch?v=hoV-SNpdyW8*](https://www.youtube.com/watch?v=hoV-SNpdyW8).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: AGES 11+
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 12 Fun Projects
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/f0168-01.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: The Raspberry Pi^® is an inexpensive, pocketsized computer that will help you
    build and code your own hardware projects.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '*Raspberry Pi Projects for Kids* will show you how to harness the power of
    the Raspberry Pi to create 12 cool projects using simple code and common materials
    like a webcam, a microphone, and LED lights. Step-by-step instructions and detailed
    diagrams guide you through each project.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'After a brief introduction to the Python programming language, you’ll learn
    how to:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bull.jpg) Create an LED night-light that turns itself on
    and off'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bull.jpg) Set up a Raspberry Pi camera to take selfies and
    videos'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bull.jpg) Set up a webcam to stream video to your cell phone'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bull.jpg) Manipulate environments in Minecraft^®'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bull.jpg) Hijack local radio waves to play your own songs
    and recordings'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bull.jpg) Configure the Raspberry Pi to send texts to a
    cell phone'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bull.jpg) Track your family members’ locations via Wi-Fi
    and Bluetooth'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/bull.jpg) Create an MP3 player'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bull.jpg) 创建一个 MP3 播放器'
- en: '![Image](../images/bull.jpg) Set up a camera to take motion-triggered photos
    of wildlife'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bull.jpg) 设置相机，拍摄野生动物的运动触发照片'
- en: '![Image](../images/bull.jpg) Control the electronics in your home with your
    cell phone'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bull.jpg) 使用手机控制家中的电子设备'
- en: '![Image](../images/bull.jpg) Teach the Raspberry Pi to read aloud posts from
    your Twitter feed'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bull.jpg) 教授 Raspberry Pi 从你的 Twitter 动态中朗读帖子'
- en: '![Image](../images/bull.jpg) Play rock, paper, scissors against the Raspberry
    Pi'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bull.jpg) 与 Raspberry Pi 一起玩石头剪刀布'
- en: '*Raspberry Pi Projects for Kids* will deliver hours of fun and endless inspiration!'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*Raspberry Pi 项目：为孩子们* 将带来数小时的乐趣和无尽的灵感！'
- en: ABOUT THE AUTHOR
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 关于作者
- en: Dan Aldred is a computer science teacher, freelance writer, and hacker. He has
    championed the use of the Raspberry Pi as a tool for learning and creativity,
    and is a Raspberry Pi Certified Educator. Aldred led the winning team of students
    for the first Astro Pi competition; their code is now orbiting Earth aboard the
    International Space Station. He currently lives in the United Kingdom.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Dan Aldred 是一位计算机科学教师、自由作家和黑客。他一直倡导使用 Raspberry Pi 作为学习和创造力的工具，并且是 Raspberry
    Pi 认证教育者。Aldred 曾领导赢得首届 Astro Pi 比赛的学生团队；他们的代码现在在国际空间站绕地球运行。他目前居住在英国。
- en: '![Image](../images/f0168-02.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0168-02.jpg)'
- en: '***THE FINEST IN GEEK ENTERTAINMENT™***'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '***极客娱乐中的顶级之选™***'
- en: '[www.nostarch.com](http://www.nostarch.com)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.nostarch.com](http://www.nostarch.com)'
- en: Footnote
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚注
- en: Chapter 9
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第9章
- en: ^([1](ch09.xhtml#rch09fn01)) [https://www.ripe.net/about-us/press-centre/understanding-ip-addressing](https://www.ripe.net/about-us/press-centre/understanding-ip-addressing)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.xhtml#rch09fn01)) [https://www.ripe.net/about-us/press-centre/understanding-ip-addressing](https://www.ripe.net/about-us/press-centre/understanding-ip-addressing)
