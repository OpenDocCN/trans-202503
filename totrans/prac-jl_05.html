<html><head></head><body>
<h2 class="h" id="ch04"><span epub:type="pagebreak" id="page_83" class="calibre1"/><strong class="calibre2"><span class="big">4</span><br class="calibre3"/>THE PLOTTING SYSTEM</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">There is nothing worse than a sharp image of a fuzzy concept.</em></p>
<p class="center1">—Ansel Adams</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">This chapter introduces the large and rich subject of visualization in Julia. Plots and diagrams play a role in scientific communication equal in importance to words and equations. Julia’s plotting ecosystem is diverse and powerful; you’ll be able to craft a solution to any type of visualization challenge without leaving the language. The ability to keep both your calculation and its visualization within a single program simplifies the process of exploring and reporting results.</p>
<p class="indent">Plotting in Julia is a hotspot of rapid development. This is mostly good, as it means new features and packages arise regularly. The downside, however, is a higher than average incidence of conflicts among packages, incomplete documentation, and bugs, exacerbated by the frequent need for plotting routines to depend on external graphics libraries. With this in mind, I’ve confined the treatment in this chapter to packages that seem to be stable <span epub:type="pagebreak" id="page_84"/>and mature. The examples here should work over the long term. I’ve avoided discussing some potentially useful packages that still have too many rough edges.</p>
<h3 class="h2" id="ch04lev1"><strong class="calibre2">Plots</strong></h3>
<p class="noindent">The main, and in a sense “official,” plotting package for Julia is <code>Plots</code>. Later in the book we’ll explore other graphical methods, but this chapter is about the package at the center of Julia’s visualization universe.</p>
<p class="indent"><code>Plots</code> is not in the standard library, so we need to install it in the package manager with <span class="codestrong1">add Plots</span>. The initial installation will take some time, as <code>Plots</code> has many dependencies, all of which need to be (automatically) installed as well. Precompilation of this assortment of packages will take a few minutes.</p>
<p class="indent"><code>Plots</code> is a unique approach to providing a programming language with plotting abilities. It’s often described as a plotting <em class="calibre11">metapackage</em>, because <code>Plots</code> doesn’t do any actual plotting on its own. Rather, it orchestrates the creation of visualizations by calling on a choice of <em class="calibre11">backends</em>.</p>
<h3 class="h2" id="ch04lev2"><strong class="calibre2">The Backend System</strong></h3>
<p class="noindent">The backend is the package that actually draws the picture. Each backend has particular strengths and weaknesses, and is suitable for a different type of application. The job of <code>Plots</code> is to provide a unified interface to all of the backends and to apply a degree of intelligence in translating our plotting call into a form that the backend can understand. It tries to figure out what we mean and how to produce the plot we want.</p>
<p class="indent">The advantage of using a plotting metapackage is that we can change the backend used in a program without having to change the plotting commands. During research, we may want to have a simulation code produce rough plots directly in the terminal or 3D plots that we can rotate with the mouse. Later, we may want to run the simulation again, but this time save publication-quality plots to disk. With the <code>Plots</code> system, we can accomplish that by simply changing one line of code that selects a different backend.</p>
<p class="indent">Some of <code>Plots</code>’s backends are automatically installed when we install the package, but we’ll need to install others manually, as separate packages (these are subject to change, but we’ll be prompted to install a missing backend when we try to use it). When we <code>add</code> the <code>Plots</code> package, one backend that always comes along for the ride is the default backend. Recently this default has been <code>GR</code>, a reasonably fast and featureful plotting engine. To see the list of available backends, execute the <span class="codestrong1">backends()</span> function in the REPL. To see the currently active backend, execute the <span class="codestrong1">backend()</span> function.</p>
<p class="indent">To activate a backend, we use the appropriate name that <code>backends()</code> returns to form a function and simply call it. If it’s installed, the function responds by confirming the name of the package. If not, we’ll get an error message explaining that we need to <code>add</code> it.</p>
<p class="indent">Here is part of a REPL session showing the process:<span epub:type="pagebreak" id="page_85"/></p>
<pre class="calibre13">   julia&gt; <span class="codestrong">using Plots</span>

<span class="ent">➊</span> julia&gt; <span class="codestrong">backends()</span>
   10-element Vector{Symbol}:
    :pyplot
    :unicodeplots
    :plotly
    :plotlyjs
    :gr
    :pgfplo
    :pgfplotsx
    :inspectdr
    :hdf5
    :gaston

<span class="ent">➋</span> julia&gt; <span class="codestrong">backend()</span>
   Plots.GRBackend()

<span class="ent">➌</span> julia&gt; <span class="codestrong">unicodeplots()</span>
   Plots.UnicodePlotsBackend()

   julia&gt; <span class="codestrong">hdf5()</span>
   ERROR: ArgumentError: Package HDF5 not found in current path:
   - Run `import Pkg; Pkg.add("HDF5")` to install the HDF5 package.

<span class="ent">➍</span> (@v1.6) pkg&gt; <span class="codestrong">add HDF5</span>
      Resolving package versions...
       Updating `~/.julia/environments/v1.6/Project.toml`
     [f67ccb44] + HDF5 v0.15.6
     No Changes to `~/.julia/environments/v1.6/Manifest.toml`

   julia&gt; <span class="codestrong">hdf5()</span>
   Plots.HDF5Backend()

   julia&gt; <span class="codestrong">backend()</span>
   Plots.HDF5Backend()</pre>
<p class="indent">Asking for available backends <span class="ent">➊</span> returns a list in the form of a <code>Vector</code> of <code>Symbol</code>s, indicated by the leading colons. “Symbols and Metaprogramming” on <a href="ch06.xhtml#ch06lev3" class="calibre10">page 167</a> will explain the <code>Symbol</code> data type, but for now, think of it as a string.</p>
<p class="indent">Asking for the current backend <span class="ent">➋</span> returns <code>Plots.GRBackend()</code>. The multiple names for each backend is somewhat confusing, as the capitalized form used to refer to a package differs from the lowercase form used to activate it. The form that <code>backend()</code> returns isn’t used for anything.</p>
<p class="indent"><span epub:type="pagebreak" id="page_86"/>The next move is to make <code>UnicodePlots</code> the current backend <span class="ent">➌</span>; the operation was confirmed. Then we change our mind and decide to plot with HDF5, but our attempt to switch to it gives us an error because it’s not in the load path. Apparently we never added it to the environment. After adding HDF5 in package mode <span class="ent">➍</span>, we switch to it and call <code>backend()</code> to confirm.</p>
<p class="indent">The package system doesn’t consider the various backends to be dependencies of <code>Plots</code>. This was a deliberate choice to spare users from having to install all of the backends when installing <code>Plots</code>, as there are many of them, and most users will need only a modest subset. This creates occasional incompatibilities, however, as <code>Plots</code> and its various backends evolve, since the package system cannot automatically keep them in sync. If something doesn’t work, try a different backend if possible; otherwise, search the web and the resources in “Further Reading” on <a href="ch04.xhtml#fur4" class="calibre10">page 121</a> for a resolution.</p>
<h3 class="h2" id="ch04lev3"><strong class="calibre2">Modes of Interaction with Plots</strong></h3>
<p class="noindent">If you are following along in Pluto, you can enter each plotting command in a new cell and produce a sequence of figures embedded in the page. If you’re using the REPL, each plot should reuse the display window opened by the first, replacing the existing plot. If you want to close that window, use the statement <code>closeall()</code>. Closing it using your window manager sometimes leads to errors in the REPL, a known bug.</p>
<p class="indent">If you’re saving plot commands in a program file, you may have noticed that you don’t see any output when you run it. First, you need to include the statement <code>gui()</code> at the point in the program where you want to display the current state of the plot. However, the plot window thus created will vanish when the program exits, perhaps so quickly that you may not be able to see the window at all. You need to make the program pause until you’re done admiring your plot. One way is to insert the <code>readline()</code> statement directly after <code>gui()</code>. This statement waits for input at the terminal. When you’re ready to dismiss the plot window, simply press <small class="calibre5">RETURN</small> and it will vanish, and the program will continue.</p>
<h3 class="h2" id="ch04lev4"><strong class="calibre2">2D Plots</strong></h3>
<p class="noindent">The term <em class="calibre11">2D plot</em> refers to a variety of visualizations involving maps between two variables. The basic type, a <em class="calibre11">line plot</em>, takes the form of a curve, or set of curves, for functions of a single variable, where typically the independent variable is represented by the horizontal x-axis and the dependent variable by the vertical y-axis in a rectangular coordinate system. The <em class="calibre11">polar coordinate plot</em> maps an angle to the distance from some origin, in a polar coordinate system. A third common type is a <em class="calibre11">parametric plot</em>, where both variables depend on a third variable, called the parameter. These three basic types, along with other varieties such as bar and pie charts and scatterplots, are all called <em class="calibre11">two-dimensional plots</em>, and they are all handled by the <code>plot()</code> function provided by the <code>Plots</code> package and understood by all of its backends.</p>
<p class="indent"><span epub:type="pagebreak" id="page_87"/>For the examples in this section, any backend will work, but I suggest sticking with the default setup when you execute <code>using Plots</code>. This will always be a relatively stable and performant engine that displays color plots either in a new window when using the REPL, or on the page when using Pluto or VS Code. In all of the examples in this chapter, <code>using Plots</code> is assumed.</p>
<p class="indent">The <code>plot()</code> function accepts arguments of various kinds, and, as mentioned previously, usually does what we expect. It returns a result in the form of a plot object. In the REPL, a notebook interface such as Pluto, or another interactive environment, it immediately displays the plot, unless we suppress the output by following the call with a semicolon. We can display the plot later with a call to <code>gui()</code> or by storing the plot object in a variable and simply evaluating it.</p>
<h4 class="h3" id="ch04lev1sec1"><strong class="calibre2"><em class="calibre4">Plotting from Vectors</em></strong></h4>
<p class="noindent">We can call the function with a single <code>Vector</code> argument:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">gr()</span>
Plots.GRBackend()

julia&gt; <span class="codestrong">plot([0, 3, 1, 4, 1])</span></pre>
<p class="indent">This plots the numbers in the <code>Vector</code>, in order, against an independent variable that gives their index. <a href="ch04.xhtml#ch4fig1" class="calibre10">Figure 4-1</a> shows the plot.</p>
<div class="image1"><img alt="Image" id="ch4fig1" src="../images/ch04fig01.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-1: Plotting a single vector</em></p>
<p class="indent">We get a legend, which at the moment is not very informative. We’ll learn shortly how to adjust this, and change other things about the graph, but first let’s look at the different ways we can use <code>plot()</code>.<span epub:type="pagebreak" id="page_88"/></p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">I’ve created grayscale versions of all the examples in this chapter for printing, but the original color output from each plot command is available from the book’s supplementary website at</em> <a href="https://julia.lee-phillips.org" class="calibre10">https://julia.lee-phillips.org</a><em class="calibre11">.</em></p>
</div>
<p class="indent">The second form supplies both <em class="calibre11">x</em>- and <em class="calibre11">y</em>-variables, with two <code>Vector</code>s:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">plot([0, 0.13, 0.38, 0.88, 1.88], [0, 3, 1, 4, 1])</span></pre>
<p class="indent">The result (<a href="ch04.xhtml#ch4fig2" class="calibre10">Figure 4-2</a>) shows the same <em class="calibre11">y</em>-values plotted at different horizontal locations.</p>
<div class="image1"><img alt="Image" id="ch4fig2" src="../images/ch04fig02.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-2: Plotting a vector versus another vector</em></p>
<h4 class="h3" id="ch04lev1sec2"><strong class="calibre2"><em class="calibre4">Plotting Functions</em></strong></h4>
<p class="noindent">To plot a function, we can supply a vector as the first argument and a second vector created by broadcasting the function over the first argument (see “Broadcasting” on <a href="ch02.xhtml#ch02lev1sec13" class="calibre10">page 51</a>):</p>
<pre class="calibre13">julia&gt; <span class="codestrong">f(x) = sin(1/x)</span>
f (generic function with 1 method)

julia&gt; <span class="codestrong">x = π/1000</span>:π<span class="codestrong">/1000:</span>π
0.0031415926535897933:0.0031415926535897933:3.14

julia&gt; <span class="codestrong">plot(x, f.(x))</span></pre>
<p class="indent">In this example we first create a function, <code>f()</code>, using the succinct one-line function definition syntax. Next we define a range and store it in <span class="codeitalic1">x</span>; the range <span epub:type="pagebreak" id="page_89"/>excludes <code>0</code> to avoid the singularity there. The <code>plot()</code> command has two <code>Vector</code> arguments, as before. The range is instantiated into a <code>Vector</code> and the dot after <code>f()</code> broadcasts the function over <code>x</code>, returning a <code>Vector</code> for the dependent variable. <a href="ch04.xhtml#ch4fig3" class="calibre10">Figure 4-3</a> shows the result.</p>
<div class="image1"><img alt="Image" id="ch4fig3" src="../images/ch04fig03.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-3: A plot of a function broadcast over a vector</em></p>
<p class="indent">We can see the plot becoming inaccurate as we approach the origin and the π<code>/1000</code> resolution fails to keep up with the rapid oscillations in that region.</p>
<p class="indent">The <code>plot()</code> function and its comrades offer a convenient shorthand. Instead of supplying the second argument as a broadcast expression that explicitly creates a vector, we can simply write the name of a function, or construct an anonymous function. The <code>plot()</code> function will broadcast the function we name over the independent variable vector that we pass in the first argument.</p>
<p class="indent">In other words, we can write <code>plot(x, f.(x))</code> as simply <code>plot(x, f)</code>. If we had not already defined <code>f()</code>, we could insert an anonymous function directly as <code>plot(x, s -&gt; sin(1/s))</code>. These three ways of calling <code>plot()</code> are all equivalent.</p>
<p class="indent">We can even leave out the independent variable and supply only a function name or an anonymous function. In this case, <code>plot()</code> will plot the function for us, choosing the locations of the independent variable and handling singularities automatically. We can supply a domain on the horizontal axis using a second and third argument, with default values of –5 and 5. If we use a <code>Vector</code> of functions in the first argument, we’ll get a plot of all of them on the same axes. Using the same definition for <code>f</code>, executing <code>plot([sin, cos, f], -</code>π<code>,</code> π<code>)</code> produces <a href="ch04.xhtml#ch4fig4" class="calibre10">Figure 4-4</a>.<span epub:type="pagebreak" id="page_90"/></p>
<div class="image1"><img alt="Image" id="ch4fig4" src="../images/ch04fig04.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-4: Plotting three functions</em></p>
<p class="indent">In this use of <code>plot()</code>, we supply the names of the functions. We’re not <em class="calibre11">calling</em> these functions, so we omit the parentheses. Plotting is a common application for anonymous functions (see “Creating Anonymous Functions” on <a href="ch02.xhtml#ch02lev1sec12" class="calibre10">page 51</a>). This is their purpose: to pass a function as an argument to another function, in this case <code>plot()</code>.</p>
<h4 class="h3" id="ch04lev1sec3"><strong class="calibre2"><em class="calibre4">Plotting Vectors of Vectors or Functions</em></strong></h4>
<p class="noindent">If we supply vectors of vectors in the first two argument positions, <code>plot()</code> will cycle through both arguments, reusing elements as necessary. For example, if we call <code>plot([x1, x2], [y1, y2])</code>, we’ll get a plot of <code>y1</code> versus <code>x1</code> and <code>y2</code> versus <code>x2</code>, both on the same set of axes. But if we call <code>plot(x1, [y1, y2])</code>, we’ll get a plot of <code>y1</code> versus <code>x1</code> and <code>y2</code> versus <code>x1</code>. If we call <code>plot([x1, x2], y1)</code>, we’ll see <code>y1</code> versus <code>x1</code> and <code>y1</code> versus <code>x2</code>.</p>
<p class="indent">We’ll get the same results if we use horizontal concatenation; in other words, <code>plot([x1, x2], [y1, y2])</code> produces the same plot as <code>plot([x1 x2],</code> <code>[y1 y2])</code>. When given <code>Matrix</code> arguments, <code>plot()</code> plots by columns. We can even call <code>plot([x1, x2], [y1 y2])</code>, mixing a vector of vectors with a matrix, and <code>plot()</code> will know what we mean and draw the same graph as in the two preceding examples.</p>
<p class="indent">If we use <em class="calibre11">vertical</em> concatenation, we will simply create longer vectors. We can use this to plot different functions over different ranges:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">x = 0:5π/1000:5π</span>
julia&gt; <span class="codestrong">plot([x; 5π .+ x], [sin.(x); -exp.(-x .* 0.2) .* sin.(x)])</span></pre>
<p class="indent">In this example, we join the <code>x</code> vector to itself shifted to the right by 5π and supply the result as the independent variable. Against that, we plot a <code>sin</code> <span epub:type="pagebreak" id="page_91"/>function joined to the same function multiplied by a decaying exponential (note the use of broadcast notation throughout). <a href="ch04.xhtml#ch4fig5" class="calibre10">Figure 4-5</a> shows the result.</p>
<div class="image1"><img alt="Image" id="ch4fig5" src="../images/ch04fig05.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-5: Joining vectors to model a damped oscillation</em></p>
<p class="indent">The graph can be interpreted as an initially frictionless oscillation with damping applied at <em class="calibre11">x</em> = 5π.</p>
<h4 class="h3" id="ch04lev1sec4"><strong class="calibre2"><em class="calibre4">Displaying and Mutating</em></strong></h4>
<p class="noindent">I mentioned earlier that we cause the display of a plot in a program file with the call <code>gui()</code>. But how does the <code>gui()</code> function know what plot to display? The plotting system maintains a <em class="calibre11">current plot</em> in the global namespace, along with other settings and state related to the display of graphics. This is convenient during interactive plotting, as it allows us to incrementally adjust and add things to the current plot by mutating it. The mutating version of <code>plot()</code> is <code>plot!()</code>, following the convention (see “Functions That Mutate Their Arguments” on <a href="ch02.xhtml#ch02lev1sec17" class="calibre10">page 56</a>).</p>
<p class="indent">Using mutation, we can produce <a href="ch04.xhtml#ch4fig4" class="calibre10">Figure 4-4</a> with these three lines:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">plot(sin,</span> -π<span class="codestrong">,</span> π<span class="codestrong">)</span>


julia&gt; <span class="codestrong">plot!(cos)</span>


julia&gt; <span class="codestrong">plot!(f)</span></pre>
<p class="indent">The <code>plot!()</code> function maintains the domain established in the first call. We can use the mutating form to change many aspects of the plot, in addition to adding curves.</p>
<p class="indent"><span epub:type="pagebreak" id="page_92"/>The <code>plot()</code> and <code>plot!()</code> functions return plot objects, which we can assign to variables. The reason we see a plot when we call the function in the REPL or in a notebook is that Julia calls <code>gui()</code> automatically in interactive contexts whenever a plot object is returned from an expression. If we’ve assigned some plots to variables, anytime we want to see one, we can simply type its name in the REPL and press <small class="calibre5">RETURN</small>. In a program file, we can supply the plot object as an argument to <code>gui()</code>.</p>
<p class="indent">If we give <code>plot!()</code> a plot object as its first argument, it will mutate that plot instead of the current plot. For example, if we execute <code>ps = plot(sin)</code>, then <code>ps</code> is a plot of the <code>sin()</code> function. A call to <code>plot!(ps, cos)</code> will do two things: it will mutate <code>ps</code>, adding a <code>cos()</code> curve to it, and it will return the result, so that the altered plot pops up on the screen. Making the same call using the non-mutating version, <code>plot()</code>, will display the plot with both curves, but won’t alter <code>ps</code>.</p>
<p class="indent">We can supply any number of plot objects as arguments to <code>plot()</code>, and it will arrange them automatically into a grid. See “Layouts” on <a href="ch04.xhtml#ch04lev12" class="calibre10">page 117</a> for details on how to get more control over this arrangement.</p>
<p class="indent">This REPL session creates several plots and then combines them:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">parabola = plot(x -&gt; x^2);</span>


julia&gt; <span class="codestrong">ps = plot(sin, 0, 2π);</span>


julia&gt; <span class="codestrong">plot!(ps, cos);</span>


julia&gt; <span class="codestrong">plot(ps, plot(f), plot(s -&gt; s^3), parabola)</span></pre>
<p class="indent">All the lines end with a semicolon except the last, where we want to see the plot. First we give the variable <code>parabola</code> the value of a plot object depicting a parabola, constructed with an anonymous function. The value of the variable is now a data type representing a complete plot, with axes, tick marks, and so on. We don’t specify a domain, so the parabola is plotted from –5 to 5.</p>
<p class="indent">Then we assign <code>ps</code> to a plot of the <code>sin</code> function, this time with a domain from 0 to 2π.</p>
<p class="indent">Next we decide we would like <code>ps</code> to also contain a <code>cos</code> curve, so we change it; <code>plot!()</code> will keep the existing domain.</p>
<p class="indent">The final line creates the plot shown in <a href="ch04.xhtml#ch4fig6" class="calibre10">Figure 4-6</a>.<span epub:type="pagebreak" id="page_93"/></p>
<div class="image1"><img alt="Image" id="ch4fig6" src="../images/ch04fig06.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-6: Plotting four plot objects</em></p>

<p class="indent">We call <code>plot()</code> with four plot-object arguments. The first and last are the two plot-holding variables, the second is a plot object created directly with a <code>plot()</code> function on the previous <code>f</code> function, and the third uses an anonymous function.</p>
<h4 class="h3" id="ch04lev1sec5"><strong class="calibre2"><em class="calibre4">Creating Parametric Plots</em></strong></h4>
<p class="noindent">Parametric plots in the plane are also classified with 2D plots because there is one independent variable, now called the <em class="calibre11">parameter</em>. In this type of plot, <em class="calibre11">x</em> and <em class="calibre11">y</em> both depend on the parameter. If we pass two arguments that are both functions to <code>plot()</code>, it recognizes this as the signature for a parametric plot and produces a graph with the <em class="calibre11">x</em>-dependence given by the first function and the <em class="calibre11">y</em>-dependence given by the second (where, as usual, <em class="calibre11">x</em> is plotted on the horizontal axis and <em class="calibre11">y</em> on the vertical). We must specify the domain for the parameter with two additional arguments; however, there is no default as when plotting non-parametric functions.</p>
<p class="indent">Parametric plotting allows us to render various complex shapes and such plots as circles and spirals, as shown in <a href="ch04.xhtml#ch4fig7" class="calibre10">Figure 4-7</a>.<span epub:type="pagebreak" id="page_94"/></p>
<div class="image1"><img alt="Image" id="ch4fig7" src="../images/ch04fig07.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-7: Two parametric plots</em></p>
<p class="indent">The left-hand plot is produced with the call <code>circle = plot(sin, cos, 0, 2</code>π<code>)</code> and the spiral in the right-hand plot is created by <code>spiral = plot(r -&gt; r*sin(r),</code> <code>r -&gt; r*cos(r), 0, 8</code>π<code>)</code>. We draw the composite figure by calling <code>plot(circle,</code> <code>spiral)</code>.</p>
<p class="indent">As in the case of regular function plotting, the independent variable, in this case the parameter, can be implicit, as in the call we used to draw the circle. When the functions to be plotted are too complex to allow this, as in the spiral example, we must employ a dummy variable, which we named <code>r</code> in this case.</p>
<h4 class="h3" id="ch04lev1sec6"><strong class="calibre2"><em class="calibre4">Making Polar Plots</em></strong></h4>
<p class="noindent">A polar plot uses the conventional polar coordinate system rather than a rectangular coordinate system. The independent variable is the angle, measured counterclockwise from the horizontal axis, and the dependent variable is the distance from the origin.</p>
<p class="indent"><a href="ch04.xhtml#ch4fig8" class="calibre10">Figure 4-8</a> shows two simple plots in polar coordinates. The <code>plot()</code> function renders the coordinate grid to reflect the symmetry of the polar geometry.</p>
<div class="image1"><span epub:type="pagebreak" id="page_95"/><img alt="Image" id="ch4fig8" src="../images/ch04fig08.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-8: Two polar plots</em></p>
<p class="indent">We created the plot on the left with <code>plot(0:2</code>π<code>/500:2</code>π<code>, t -&gt; 1 + 0.2*sin(8t); proj=:polar)</code> and the spiral on the right with <code>plot(0:8</code>π<code>/200:8</code>π<code>, t -&gt; t; proj=: polar)</code>. The first arguments in these calls are arrays of angular coordinates, and the second arguments are functions mapping the angle to the distance from the origin, using <code>t</code> as a dummy variable. The argument <code>proj=:polar</code> tells <code>plot()</code> to make a polar plot. This is a keyword argument, as explained in “Optional and Keyword Arguments” on <a href="ch04.xhtml#ch04lev5" class="calibre10">page 96</a>.</p>
<h4 class="h3" id="ch04lev1sec7"><strong class="calibre2"><em class="calibre4">Making Scatterplots</em></strong></h4>
<p class="noindent">The 2D plots we’ve seen so far draw a continuous line through a set of points. Sometimes we need to plot a collection of dots or other markers, each at a particular (<em class="calibre11">x</em>, <em class="calibre11">y</em>) position: a <em class="calibre11">scatterplot</em>. The <code>scatter()</code> function works identically to the <code>plot()</code> function, but it draws point collections rather than curves.</p>
<p class="indent">As an example application, suppose we wanted to visualize the output of the iterated map:</p>

<div class="image"><img alt="Image" src="../images/math95.jpg" class="calibre6"/></div>
<p class="noindent">This simple map produces a fascinating variety of patterns with an unpredictable dependence on <em class="calibre11">a</em>. The Julia version is:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">function ginger(x, y, a)</span>
           <span class="codestrong">x2 = 1.0 - y + a*abs(x)</span>
           <span class="codestrong">y2 = x</span>
           <span class="codestrong">x2, y2</span>
       <span class="codestrong">end</span></pre>
<p class="indent">I’ve named it after the common nickname for the map: the <em class="calibre11">gingerbread man</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_96"/>We’ll store the sequence of values in two vectors, <code>x</code> and <code>y</code>, initialized with the starting coordinates, and iterate 4,000 times:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">x = [20.0]; y = [9.0];</span>
julia&gt; <span class="codestrong">for i in 1:4000</span>
        <span class="ent">➊</span> <span class="codestrong">x2, y2 = ginger(x[end], y[end], 1.76)</span>
           <span class="codestrong">push!(x, x2)</span>
           <span class="codestrong">push!(y, y2)</span>
       <span class="codestrong">end</span></pre>
<p class="indent">The listing uses a form of <em class="calibre11">destructuring</em> <span class="ent">➊</span>. The <code>ginger()</code> function returns a tuple with its first member stored in <code>x2</code> and its second in <code>y2</code>.</p>
<p class="indent">After running this loop, we can see what’s in <code>x</code> and <code>y</code> with a scatterplot. The call <code>scatter(x, y; ms=0.5, legend=false)</code> produces the plot shown in <a href="ch04.xhtml#ch4fig9" class="calibre10">Figure 4-9</a>.</p>
<div class="image1"><img alt="Image" id="ch4fig9" src="../images/ch04fig09.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-9: The gingerbread man iterated map</em></p>
<p class="indent">In the call to <code>scatter()</code>, after the <code>x</code> and <code>y</code> arguments, we add something new after a semicolon. These two <em class="calibre11">optional keyword arguments</em> affect the plot’s appearance, as explained in the next section.</p>
<h3 class="h2" id="ch04lev5"><strong class="calibre2">Optional and Keyword Arguments</strong></h3>
<p class="noindent">In a function definition, we can supply default values for arguments. Doing so makes those arguments <em class="calibre11">optional</em>, as the user can call the function without using them:<span epub:type="pagebreak" id="page_97"/></p>
<pre class="calibre13">julia&gt; <span class="codestrong">g(x, y=2) = x + y</span>
g (generic function with 2 methods)

julia&gt; <span class="codestrong">g(4)</span>
6

julia&gt; <span class="codestrong">g(4, 9)</span>
13</pre>
<p class="indent">In this example, the definition of <code>g()</code> includes the default value of <code>2</code> for <code>y</code>. If we call it with no second argument, it returns <code>x + 2</code>. When we do supply a second argument, it uses that instead.</p>
<p class="indent">So far we’ve learned how to define and call functions with <em class="calibre11">positional arguments</em>. Values are assigned based on the order in which we put them in the argument list when calling the function, whether they’re optional or not.</p>
<p class="indent">Julia also has <em class="calibre11">keyword arguments</em>, identified by name rather than position. Unlike some other languages, we must make a distinction when defining a function between its positional and keyword arguments; we separate them with a semicolon, as in this example:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">p(x; y=2) = x + y</span>
   p (generic function with 1 method)

<span class="ent">➊</span> julia&gt; <span class="codestrong">p(4)</span>
   6

   julia&gt; <span class="codestrong">p(4, 5)</span>
   ERROR: MethodError: no method matching p(::Int64, ::Int64)
   Closest candidates are:
     p(::Any; y) at REPL[346]:1

   julia&gt; <span class="codestrong">p(4; y=5)</span>
   9</pre>
<p class="indent">Here we define <code>p()</code> to have one positional argument and one keyword argument, named <code>y</code>, with the default value of <code>2</code>. We can call <code>p()</code> omitting the keyword argument <span class="ent">➊</span>, because the default makes it optional. If we supply two positional arguments, that returns an error because the function takes only one. Make sure you understand the difference between the functions <code>g()</code> and <code>p()</code>: they differ only in their function signatures.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">When calling a function we have the option to use a comma instead of a semicolon because there’s no chance of ambiguity; however, the semicolon is required in function definitions.</em></p>
</div>
<p class="indent">The plotting functions in the <code>Plots</code> ecosystem use positional arguments for data or functions and keyword arguments for setting plot options. Because all the plot options have default values, we haven’t had to use them until now.<span epub:type="pagebreak" id="page_98"/></p>
<h3 class="h2" id="ch04lev6"><strong class="calibre2">Basic Plot Settings</strong></h3>
<p class="noindent">To adjust a plot’s appearance, we use keyword arguments. There are four components that can make up a visualization made with the <code>Plots</code> package, and each one has a collection of settings that applies to it.</p>
<p class="indent">These four components are <em class="calibre11">plot</em>, <em class="calibre11">subplot</em>, <em class="calibre11">axis</em>, and <em class="calibre11">series</em>. Plots can contain subplots, and either of those can contain axes or series.</p>
<p class="indent">The overall illustration is called the plot; it contains other plots, the subplots, when there are more than one, as in <a href="ch04.xhtml#ch4fig6" class="calibre10">Figure 4-6</a>. Settings such as an overall title and background color apply to the plot.</p>
<p class="indent">Within a plot, each subplot can have its own title, background color, margin, and many other settings.</p>
<p class="indent">The actual curves or other visualizations of functions or data are the series, and a subplot can contain many series.</p>
<p class="indent">Each subplot contains an axis object. Its settings determine such things as whether the coordinate axes are drawn with arrows, the color of tick labels, or the numbers on the coordinate axes.</p>
<p class="indent">For the most part, we can simply use the appropriate keyword to set the desired <em class="calibre11">attribute</em> of our visualization, and the plotting system will apply it where it makes sense. But when designing complicated visualizations, we sometimes need to target specific components.</p>
<p class="indent">The official plotting system documentation at <a href="https://docs.juliaplots.org/stable/" class="calibre10"><em class="calibre11">https://docs.juliaplots.org/stable/</em></a> contains the complete list of attributes for all components, as well as which attributes are supported by which backends. The following list provides the most important ones and gives examples of their effects:</p>
<h4 class="h4a" id="ch04lev1sec1a"><strong class="calibre2">Titles</strong></h4>
<ul class="calibre12">
<li class="noindent1">Overall title: <code>plot_title</code></li>
<li class="noindent1">Title for subplot: <code>title</code></li>
<li class="noindent1">Title for legend: <code>legendtitle</code></li></ul>
<h4 class="h4a" id="ch04lev1sec1b"><strong class="calibre2">Other labels</strong></h4>
<ul class="calibre12">
<li class="noindent1">Legend text: <code>label</code></li>
<li class="noindent1">Legend existence and position: <code>legend</code></li>
<li class="noindent1">Axis labels: <code>[x,y]guide</code></li>
<li class="noindent1">Label anywhere: <code>annotation=(x, y, "Text")</code></li>
</ul>
<h4 class="h4a" id="ch04lev1sec1c"><strong class="calibre2">Font colors</strong></h4>
<ul class="calibre12">
<li class="noindent1">Overall title: <code>plot_titlefontcolor</code></li>

<li class="noindent1">Subplot title: <code>titlefontcolor</code></li>

<li class="noindent1">Legend: <code>legendfontcolor</code></li>

<li class="noindent1">Axis labels: <code>[x,y]guidefontcolor</code></li></ul>
<h4 class="h4a" id="ch04lev1sec1d"><span epub:type="pagebreak" id="page_99" class="calibre1"/><strong class="calibre2">Area colors</strong></h4>
<ul class="calibre12">
<li class="noindent1">Margin area: <code>background_outside</code></li>

<li class="noindent1">Plot area only: <code>background_inside</code></li></ul>
<h4 class="h4a" id="ch04lev1sec1e"><strong class="calibre2">Curves</strong></h4>
<ul class="calibre12">
<li class="noindent1">Line color: <code>lc</code></li>

<li class="noindent1">Line width: <code>lw</code></li>

<li class="noindent1">Line style: <code>ls</code></li></ul>
<h4 class="h4a" id="ch04lev1sec1f"><strong class="calibre2">Scatterplots</strong></h4>
<ul class="calibre12">
<li class="noindent1">Marker shape: <code>shape</code></li>

<li class="noindent1">Marker color: <code>mc</code></li>

<li class="noindent1">Marker size: <code>ms</code></li></ul>

<h4 class="h4a" id="ch04lev1sec1g"><strong class="calibre2">Contour plots</strong></h4>
<ul class="calibre12">
<li class="noindent1">Give contours labels (Boolean): <code>clabels</code></li>

<li class="noindent1">Contour levels: <code>levels</code></li></ul>
<h4 class="h4a" id="ch04lev1sec1h"><strong class="calibre2">Axes and ticks</strong></h4>
<ul class="calibre12">
<li class="noindent1">Reverse axis (Boolean): <code>[x,y]flip</code></li>

<li class="noindent1">Rotation of tick labels: <code>[x,y]rotation</code></li>

<li class="noindent1">Draw axis: <code>showaxis [x,y]ticks</code></li>

<li class="noindent1">Frame style: <code>framestyle</code></li></ul>
<h4 class="h4a" id="ch04lev1sec1i"><strong class="calibre2">Grid</strong></h4>
<ul class="calibre12">
<li class="noindent1">Draw a grid (Boolean): <code>grid</code></li>

<li class="noindent1">Gridline opacity: <code>gridalpha [0,1]</code></li>

<li class="noindent1">Gridline style: <code>gridstyle</code></li></ul>
<h4 class="h4a" id="ch04lev1sec1j"><strong class="calibre2">Coordinate system</strong></h4>
<ul class="calibre12">
<li class="noindent1">Use polar coordinates: <code>:proj=polar</code></li></ul>
<h4 class="h4a" id="ch04lev1sec1k"><strong class="calibre2">Sizes and margins</strong></h4>
<ul class="calibre12">
<li class="noindent1">Margin around subplot: <code>[left,right,top,bottom]margin</code></li>

<li class="noindent1">Overall plot size: <code>sizes(a, b)</code> (in px)</li>

<li class="noindent1">Subplot aspect ratio: <code>ratio</code></li></ul>
<p class="indent">Each of the keywords in these lists has a set of abbreviations and alternative spellings, all listed in the official documentation. I’ve picked one version in each case; it’s not always the briefest alternative, but a choice designed to be memorable and to avoid confusion.</p>
<p class="indent"><span epub:type="pagebreak" id="page_100"/>The purposes of a few of these settings will not be clear until we discuss them later, but I’ve listed them all here for easy reference.</p>
<h4 class="h3" id="ch04lev1sec8"><strong class="calibre2"><em class="calibre4">Font Attributes</em></strong></h4>
<p class="noindent">To form the keyword for setting a font attribute such as the font size or family, look up the corresponding name for setting the font color in the attribute list shown earlier, and substitute the desired attribute, such as <code>fontsize</code> or <code>fontfamily</code> in place of <code>fontcolor</code>. For example, to make the plot title have a size of 30pt, use the setting <code>plot_titlefontsize=30</code>.</p>
<p class="indent">The font <em class="calibre11">families</em> are dependent on which backend is in use. A list for the GR backend is at <a href="https://gr-framework.org/fonts.html" class="calibre10"><em class="calibre11">https://gr-framework.org/fonts.html</em></a>. Some of the more useful families, which also may be available in other backends, are Times (Roman, Italic, Bold), Courier, Bookman, DejaVu Sans, and Computer Modern. Supply the setting as a string. If we set the attribute <code>fontfamily</code>, that will apply to all or most of the text on the plot. For example, to get the ticks, axis labels, and other annotations in Computer Modern, but the title in Times, we’d call <code>plot(...; fontfamily="Computer Modern", legendfontfamily="Times")</code>.</p>
<p class="indent">If we mutate a plot that contains subplots, and we’re adding or changing attributes that apply to subplots, we must specify which subplot to mutate, unless we want our changes to apply to all of them. This is the purpose of the <code>subplot</code> keyword. Set it to an integer indexing the subplots as they appear in the <code>plot()</code> statement. For example, for two graphs displayed side by side with <code>plot(p1, p2)</code>, we can put a label on the horizontal axis of <code>p2</code> with <code>plot</code>!(<code>; xguide</code> <code>="Time", subplot=2)</code>. Without the <code>subplot</code> keyword, both plots would get the label.</p>
<h4 class="h3" id="ch04lev1sec9"><strong class="calibre2"><em class="calibre4">The Frame Styles</em></strong></h4>
<p class="noindent">The <code>framestyle</code> setting determines the type of axis. <a href="ch04.xhtml#ch4fig10" class="calibre10">Figure 4-10</a> displays the six possibilities.</p>
<div class="image1"><img alt="Image" id="ch4fig10" src="../images/ch04fig10.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-10: The six possible frame styles</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_101"/>We set the attribute to the symbol version of the term printed on the graph. For example, to get the style in the lower-left corner, we’d use the setting <code>framestyle=:zerolines</code>.</p>
<h3 class="h2" id="ch04lev7"><strong class="calibre2">Working with Plot Settings</strong></h3>
<p class="noindent">Now we can understand the call to <code>scatter(x, y; ms=0.5, legend=false)</code> that produced <a href="ch04.xhtml#ch4fig9" class="calibre10">Figure 4-9</a>. After the first two positional arguments, the arrays holding the points to be plotted, we have a semicolon indicating the start of the keyword arguments. The first sets a small marker size and the second turns off the legend.</p>
<p class="indent">Let’s use some combinations of the basic attributes listed in “Basic Plot Settings” on <a href="ch04.xhtml#ch04lev6" class="calibre10">page 98</a> to solve some other visualization problems.</p>
<h4 class="h3" id="ch04lev1sec10"><strong class="calibre2"><em class="calibre4">Aspect Ratio and Title Font Size</em></strong></h4>
<p class="noindent">The following program creates a simple plot with two subplots displaying a circle and a parabola:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">p1 = plot(sin, cos, 0, 2π; title="A Circle", ratio=1,</span>
                 <span class="codestrong">grid=false, ticks=false, legend=false)</span>

julia&gt; <span class="codestrong">p2 = plot(x -&gt; x^2, -1, 1; title="A Parabola",</span>
                 <span class="codestrong">gridalpha=0.4, gridstyle=:dot, legend=false)</span>

julia&gt; <span class="codestrong">plot(p1, p2; plot_title="Two Shapes", plot_titlefontsize=20)</span></pre>
<p class="indent">Here we use the <code>ratio</code> keyword to set the aspect ratio in the first line. You may have noticed that what is supposed to be a circle in <a href="ch04.xhtml#ch4fig7" class="calibre10">Figure 4-7</a> is rendered as a noncircular ellipse. The default size of Julia’s plots is not square, but is instead longer than it is tall, so the circle is stretched horizontally. If it matters, as it does in this case, we can use <code>ratio</code> to fix the problem. We also turned off the grid and ticks on this plot.</p>
<p class="indent">The default grid in most backends is quite light, so we made it more prominent by increasing the <code>gridalpha</code> in the plot of the parabola. The default for this is <code>0.1</code>.</p>
<p class="indent">The last line creates the combined plot with an overall title set a little larger than the default. <a href="ch04.xhtml#ch4fig11" class="calibre10">Figure 4-11</a> shows the result.<span epub:type="pagebreak" id="page_102"/></p>
<div class="image1"><img alt="Image" id="ch4fig11" src="../images/ch04fig11.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-11: A plot with two subplots</em></p>
<p class="indent">To get more space between the two subplots, we can, for example, set a <code>rightmargin</code> on the left subplot. Before setting margins, execute <span class="codestrong1">using Plots</span> <span class="codestrong1">.PlotMeasures</span>, which lets us use literal dimensions in margin settings; for example, <code>rightmargin=10mm</code>. Other available dimensions are <code>inch</code>, <code>cm</code>, <code>px</code>, and <code><em class="calibre11">pt</em></code>.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">The</em> <span class="codeitalic1">plot_title</span> <em class="calibre11">is a recent addition to the plotting system, and its implementation is incomplete. If we choose larger font sizes for the title, it will overlap the titles of the subplots, and there is no straightforward way to fix that.</em></p>
</div>
<h4 class="h3" id="ch04lev1sec11"><strong class="calibre2"><em class="calibre4">Labels and Legend Positioning</em></strong></h4>
<p class="noindent">For our next example, let’s make a plot of <em class="calibre11">x</em><sup class="calibre23"><em class="calibre11">n</em></sup> for a few values of <em class="calibre11">n</em>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">plot()</span>

julia&gt; <span class="codestrong">for n = 1:5</span>
           <span class="codestrong">plot!(x -&gt; x^n; lw=3, ls=:auto, label=n)</span>
       <span class="codestrong">end</span>

julia&gt; <span class="codestrong">plot!(; legend=:topleft, legendtitle="Exponent")</span></pre>
<p class="indent">First we’ll clear any existing plots with an empty <code>plot()</code> command, and then mutate the empty plot once for each function. Since the <code>for</code> loop doesn’t return a result, we won’t see anything until the final call after the loop, which simply makes some plot settings. In the plotting statements, the <code>label</code> setting defines the text associated with that plot in the legend. It expects a string (or symbol), but can convert the integer <code>n</code>. The <code>lw</code> setting makes the lines thicker <span epub:type="pagebreak" id="page_103"/>than the default. The <code>ls</code> setting is for the line style. It can take the values <code>:auto</code>, <code>:solid</code>, <code>:dash</code>, <code>:dot</code>, <code>:dashdot</code>, or <code>:dashdotdot</code>. The option used here, <code>:auto</code>, cycles through the other five styles, reusing them if the plot has more than five curves. It’s a good choice for print when we can’t use color. <a href="ch04.xhtml#ch4fig12" class="calibre10">Figure 4-12</a> shows the results.</p>
<div class="image1"><img alt="Image" id="ch4fig12" src="../images/ch04fig12.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-12: The five line styles</em></p>
<p class="indent">The final <code>plot()</code> statement sets <code>legend</code> to place it at the top left of the plot. We can use other similar positioning symbols, optionally preceded by <code>outer</code> to place the legend outside the axes. For more precise positioning we can use an <code>(x, y)</code> tuple specifying the coordinates of the legend box. Finally, we can set <code>legend=false</code> to omit the legend.</p>
<h4 class="h3" id="ch04lev1sec12"><strong class="calibre2"><em class="calibre4">LaTeX Titles and Label Positioning by Data</em></strong></h4>
<p class="noindent">Let’s plot the same functions with a different style of labeling. We’ll use annotations to place labels indicating each exponent on top of each corresponding curve, as shown in <a href="ch04.xhtml#ch4lis1" class="calibre10">Listing 4-1</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">plot()</span>

julia&gt; <span class="codestrong">for n = 1:5</span>
           <span class="codestrong">xlabel = (0.2 + 0.12n)</span>
        <span class="ent">➊</span> <span class="codestrong">ylabel = xlabel^n</span>
           <span class="codestrong">plot!(x -&gt; x^n; lw=3, ls=:auto,</span>
                      <span class="codestrong">annotation=(xlabel, ylabel, n),</span>
                      <span class="codestrong">annotationfontsize=25)</span>
       <span class="codestrong">end</span>


julia&gt; <span class="codestrong">using LaTeXStrings</span>

julia&gt; <span class="codestrong">plot!(; legend=false, xguide="x", yguide="y", guidefontsize=18,</span>
        <span class="ent">➋</span> <span class="codestrong">title=L"x^n \textrm{~labeled~by~}n", titlefontsize=30)</span></pre>
<p class="list" id="ch4lis1"><span epub:type="pagebreak" id="page_104"/><em class="calibre11">Listing 4-1: Using calculated labels and a LaTeX title</em></p>
<p class="indent">Here we calculate coordinates for each of the five labels within the loop. The x-coordinate increases to the right with the exponent, to space out the labels so they don’t overlap. The label’s y-coordinate <span class="ent">➊</span> is the same function of <em class="calibre11">x</em> as the curves we’re plotting, to ensure that they lie precisely on the curves that they’re labeling.</p>
<p class="indent">The setting for the <code>annotation</code> has <code>n</code>, a variable holding an integer, where there should be a <code>String</code>, but the <code>plot()</code> function converts it for us.</p>
<p class="indent">We then import a package we haven’t seen before: <code>LaTeXStrings</code> (note the capitalization) lets us put math in our plot titles and annotations using LaTeX syntax. Even non-LaTeX users may still need equations in graphs occasionally, and LaTeX’s math syntax is straightforward. Check “Further Reading” on <a href="ch04.xhtml#fur4" class="calibre10">page 121</a> for a link to a guide. After importing this package, we can prepend <code>L</code> to any string to turn it into a LaTeX string. In a context where typesetting is possible, such as in a plot, Julia will typeset the string appropriately. The entire string is in LaTeX math mode, where all letters are treated as mathematical symbols. Therefore, if we need some normal text, as we did in this example <span class="ent">➋</span>, we must wrap it in a LaTeX command to force it to be set as such. Within these text segments, indicate spaces with a tilde (<code>~</code>). The plot in <a href="ch04.xhtml#ch4fig13" class="calibre10">Figure 4-13</a> shows the result of this REPL session.</p>
<div class="image1"><img alt="Image" id="ch4fig13" src="../images/ch04fig13.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-13: Using calculated labels and a LaTeX title</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_105"/>In addition to the settings for individual plot elements, two others make larger-scale changes. The <code>thickness_scaling</code> setting is useful for creating a version of the plot with better legibility for presentation. It thickens everything, including tick labels. It affects the margins as well, however, and can change the positioning of plot elements. Setting the values between 1 and 1.7 produces useful results. Use values less than 1 to create a spindly version of the plot.</p>
<h4 class="h3" id="ch04lev1sec13"><strong class="calibre2"><em class="calibre4">Regression Lines</em></strong></h4>
<p class="noindent">The <code>smooth</code> setting draws a line of best fit, calculated by linear regression, through each curve or dataset on the plot.</p>
<p class="indent">Let’s return to the gingerbread map and, using the same initial conditions, calculate 20,000 iterations with <em class="calibre11">a</em> = 1<em class="calibre11">.</em>6, again storing the results in the <code>x</code> and <code>y Vector</code>s. We’ll make two subplots. The first will be a scatterplot similar to <a href="ch04.xhtml#ch4fig9" class="calibre10">Figure 4-9</a>, but with a regression line showing the average orientation of the points. The second will plot the first 100 values of <code>x</code> versus iteration number, with a regression line showing the trend of a gradually increasing distance from the origin:</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">sc = scatter(x, y; smooth=true, ms=1, legend=false,</span>
                       <span class="codestrong">xguide="x", yguide="y", guidefontsize=18)</span>

   julia&gt; <span class="codestrong">pl = plot(x[1:100]; smooth=true, legend=false)</span>

<span class="ent">➊</span> julia&gt; <span class="codestrong">pl = plot!(x[1:100]; lc=:lightgray, legend=false,</span>
                     <span class="codestrong">xguide="iteration", yguide="x", guidefontsize=18)</span>

   julia&gt; <span class="codestrong">plot(sc, pl, plot_title="Gingerbread map with a = 1.6",</span>
               <span class="codestrong">plot_titlefontsize=22)</span></pre>
<p class="indent">First we create a scatterplot of the map as before, adding the trend line with the setting <code>smooth=true</code>, and assign the result to <code>sc</code>. Then we plot the initial 100 <em class="calibre11">x</em>-values, also with a trend line. Plotting the two subplots together with a title gives us <a href="ch04.xhtml#ch4fig14" class="calibre10">Figure 4-14</a>.<span epub:type="pagebreak" id="page_106"/></p>
<div class="image1"><img alt="Image" id="ch4fig14" src="../images/ch04fig14.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-14: Trends in the gingerbread map</em></p>
<p class="indent">As before, the <code>plot_title</code> attribute creates an overall title for the two plots. We wanted the plotted curve and the calculated trend line to have different styles, but there’s no setting for this, so we resorted to a trick, over-plotting the curve in a different style but without a trend line <span class="ent">➊</span>.</p>
<h3 class="h2" id="ch04lev8"><strong class="calibre2">Saving Plots</strong></h3>
<p class="noindent">When you’re ready to save your creation to disk, call <span class="codestrong1">savefig(</span><span class="codestrongitalic">p</span><span class="codestrong1">,</span> <span class="codestrongitalic">path</span><span class="codestrong1">)</span> where <span class="codeitalic1">p</span> is the variable holding the visualization and <span class="codeitalic1">path</span> is the location where you would like the image file stored. The filename extension to <span class="codeitalic1">path</span> determines the format, but different backends support different types of images. PDF and PNG should always be available, and SVG is also widely supported.</p>
<p class="indent">If we omit <code>p</code>, it defaults to the current plot. A common workflow is to repeatedly mutate a plot, making adjustments until it’s satisfactory, and then call <code>savefig(</code><span class="codeitalic1">path</span><code>)</code>.</p>
<h3 class="h2" id="ch04lev9"><strong class="calibre2">Detail Insets</strong></h3>
<p class="noindent">An inset plot is a small plot inside the frame of a larger one. It’s often used to provide a magnified view of a section of the outer plot. Julia’s plotting system has a built-in function for creating this type of detail inset, called <code>lens!()</code>. It exists only in a mutating form because the inset plot makes sense only as an addition to an existing plot.</p>
<p class="indent">The first argument to <code>lens!()</code> either is an existing plot or is omitted to indicate the current plot. The next two arguments are vectors defining the rectangular region to be magnified. The required argument <code>inset</code> specifies <span epub:type="pagebreak" id="page_107"/>which subplot gets the inset as well as the inset’s position and size. The diagram in <a href="ch04.xhtml#ch4fig15" class="calibre10">Figure 4-15</a> shows how to use these arguments.</p>
<div class="image1"><img alt="Image" id="ch4fig15" src="../images/ch04fig15.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-15: How to make an inset</em></p>
<p class="indent"><a href="ch04.xhtml#ch4fig15" class="calibre10">Figure 4-15</a> uses a blank plot with a grid for illustration. The annotations “width” and “height” refer to the width and height of the outer plot. The complete command that created the inset is shown near the bottom of the plot.</p>
<p class="indent">As an application for <code>lens!()</code>, I constructed another instance of the gingerbread map, this time with <em class="calibre11">a</em> = 1<em class="calibre11">.</em>4 and 100,000 iterations to produce more detail. The following two lines first create the scatterplot and then add the inset:</p>
<pre class="calibre13">scatter(x, y; ms=0.1, legend=false)

lens!([-26, -22], [31, 38];
      inset=(1, bbox(0.1, 0, 0.3, 0.3)),
   <span class="ent">➊</span> ticks=false, framestyle=:box, subplot=2,
      linecolor=:green, linestyle=:dot)</pre>
<p class="indent">In the call to <code>lens!()</code>, the settings <span class="ent">➊</span> for the <code>ticks</code> and <code>Framestyle</code> apply to the inset plot, while the <code>linecolor</code> and <code>linestyle</code> settings apply to the drawing of the magnifying glass that delineates the expanded area. A full frame style is a good choice for an inset plot.</p>
<p class="indent"><a href="ch04.xhtml#ch4fig16" class="calibre10">Figure 4-16</a> shows the result. I’ve used the inset plot to magnify one of the corners of the gingerbread map, showing the pattern of points within it.<span epub:type="pagebreak" id="page_108"/></p>
<div class="image1"><img alt="Image" id="ch4fig16" src="../images/ch04fig16.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-16: Using a detail inset to magnify a section of the gingerbread map</em></p>
<p class="indent">The setting <code>subplot=2</code> in the call that creates the inset ensures that the other graph settings in that call apply only to the inset, which becomes the second subplot. By referring to the number of the subplot, we could create an inset within the inset, if we were so inclined.</p>
<h3 class="h2" id="ch04lev10"><strong class="calibre2">3D Plots</strong></h3>
<p class="noindent">Several types of plots visualize a quantity that depends on two independent variables. When in rectangular coordinates, the dependent variable is conventionally called <em class="calibre11">z</em>, and the two independent variables are called <em class="calibre11">x</em> and <em class="calibre11">y</em>. The three common ways to represent such a relationship are with a surface plot, a heatmap, or a contour plot. Which is most effective depends on the nature of the data and the features we’re trying to clarify.</p>
<h4 class="h3" id="ch04lev1sec14"><strong class="calibre2"><em class="calibre4">Surface Plots</em></strong></h4>
<p class="noindent">After importing the plotting package with <code>using Plots</code>, we have access to several 3D plotting routines. For a <em class="calibre11">surface plot</em>, we use the <code>surface()</code> function to create a perspective rendering of a 2D surface embedded in a 3D space, with the height and coloring of the surface indicating the <em class="calibre11">z</em>-value.</p>
<p class="indent">Here are a few additional settings that apply to surface plots:</p>
<ul class="calibre12">
<li class="noindent1">Draw a colorbar: <code>colorbar</code> (<code>true</code> or <code>false</code>)</li>
<li class="noindent1">Opacity of the surface: <code>fillalpha</code></li>
<li class="noindent1">Angle of view: <code>camera</code> (azimuth, elevation) (in degrees)</li>
<li class="noindent1"><span epub:type="pagebreak" id="page_109"/>Colorbar title: <code>cbtitle</code></li>
<li class="noindent1">Surface palette: <code>c</code></li></ul>
<p class="indent">Let’s put some of these settings to use in making a surface plot of a Gaussian distribution of two variables. After defining a vector <em class="calibre11">x</em> to go from –1 to 1, we can use anonymous function syntax to plot the surface with the following:</p>
<pre class="calibre13">surface(x, x, (x, y) -&gt; exp(-(0.05x^2 + y^2)/.1);
        fillalpha=0.5, camera=(45, 50), c=[Gray(0), Gray(0.8)],
        xrotation=45, yrotation=-45)</pre>
<p class="indent">We use an alpha less than 1 in order to see through the surface, and rotated the axis tick labels to make them easier to read and to keep them from colliding where the axes meet. <a href="ch04.xhtml#ch4fig17" class="calibre10">Figure 4-17</a> shows the surface plot.</p>
<div class="image1"><img alt="Image" id="ch4fig17" src="../images/ch04fig17.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-17: A surface plot</em></p>
<p class="indent">The <code>c</code> setting defines the palette used to color the surface. There are several ways to define the palette; the one used earlier, with a number of colors in a <code>Vector</code>, creates a palette by smoothly interpolating between them. <code>Gray(0)</code> is black, <code>Gray(1)</code> is white, and so on. We can also define colors with <code>RGB(r, g, b)</code>, where <code>r</code>, <code>g</code>, and <code>b</code> are the red, green, and blue components, also ranging from <code>0</code> (absent) to <code>1</code> (fully saturated). Over 600 color names are available as symbols, including both memorable names such as <code>:red</code> and <code>:blue</code> and meaningless ones such as <code>:seashell3</code> and <code>:oldlace</code>.</p>
<p class="indent">Instead of a <code>Vector</code> of colors, we can supply a symbol giving the name of a predefined palette, of which there are scores listed at <a href="https://docs.juliaplots.org/latest/generated/colorschemes/" class="calibre10"><em class="calibre11">https://docs.juliaplots.org/latest/generated/colorschemes/</em></a>. The more useful ones have names such as <span epub:type="pagebreak" id="page_110"/><code>:blues</code> or <code>:grays</code> that use one hue and vary the saturation and lightness, but there are plenty to choose from for special purposes.</p>
<h4 class="h3" id="ch04lev1sec15"><strong class="calibre2"><em class="calibre4">Heatmaps</em></strong></h4>
<p class="noindent">A heatmap also visualizes a mapping of two independent variables to one dependent variable, but the values of the independent variable are indicated by a color or gray value. The call is similar to a surface plot, but uses the <code>heatmap()</code> function:</p>
<pre class="calibre13">heatmap(x, x, (x, y) -&gt; exp(-(0.05x^2 + y^2)/.1);
               c=:grays)</pre>
<p class="indent">This call creates the heatmap shown in <a href="ch04.xhtml#ch4fig18" class="calibre10">Figure 4-18</a>.</p>
<div class="image1"><img alt="Image" id="ch4fig18" src="../images/ch04fig18.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-18: A heatmap of a 2D Gaussian</em></p>
<p class="indent">Color palettes for heatmaps work the same way as for surface plots.</p>
<h4 class="h3" id="ch04lev1sec16"><strong class="calibre2"><em class="calibre4">Contour Plots</em></strong></h4>
<p class="noindent">Contour plots are similar to heatmaps, but they use isolines rather than color to indicate the values of the independent variable. Here are a few important attributes specific to contour plots:</p>
<ul class="calibre12">
<li class="noindent1">Number of contours or specific contour levels: <code>levels</code> (integer or vector of levels)</li>

<li class="noindent1">Draw contour labels (Boolean): <code>clabels</code></li>

<li class="noindent1">Fill areas between contours (Boolean): <code>fill</code></li></ul>
<p class="indent"><span epub:type="pagebreak" id="page_111"/>If we supply an integer for <code>levels</code>, Julia will draw that many contours. If we also set <code>clabels</code> to <code>true</code>, it will label the contour lines with the values they represent. Unfortunately, these numerical labels are printed with too many digits and often become crowded. If we set <code>levels</code> to a <code>Vector</code> of numbers, the plot will have contours at just those values, and their labels will be printed using the same precision used for the <code>levels</code>. The following example shows this use of <code>levels</code> and <code>clabels</code>:</p>
<pre class="calibre13">contour(x, x, (x, y) -&gt; exp(-(0.05x^2 + y^2)/.1);
               clabels=true, levels=[0.1, 0.3, 0.5, 0.7, 0.9, 1.0],
               colorbar=false, framestyle=:box)</pre>
<p class="indent">This call uses the same <code>x</code> vector and plots the same function as the surface plot and heatmap examples shown in <a href="ch04.xhtml#ch4fig17" class="calibre10">Figures 4-17</a> and <a href="ch04.xhtml#ch4fig18" class="calibre10">4-18</a>. The result, in <a href="ch04.xhtml#ch4fig19" class="calibre10">Figure 4-19</a>, shows the labels with one digit of precision.</p>
<div class="image1"><img alt="Image" id="ch4fig19" src="../images/ch04fig19.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-19: A labeled contour plot</em></p>
<p class="indent">The <code>:box framestyle</code> works well with contour plots. Eliminating the color bar is also a good idea. We can color the lines by setting a <code>c</code>, but this doesn’t always work well with every backend. If we find stray colors creeping into the contour lines, we can fix it with <code>c=:black</code>.</p>
<p class="indent">Line styles such as <code>:dot</code> work, but not <code>:auto</code>.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">When using filled contours with some backends, including</em> <span class="codeitalic1">GR</span><em class="calibre11">, and manually set contour levels, we must include a level greater than or equal to the maximum of the data, or the graph will not be properly drawn.</em></p>
</div>
<p class="indent">The <code>fill</code> attribute, when set to <code>true</code>, adds colors between the contour lines, resulting in a kind of discrete heatmap with contours. The <code>c</code> attribute <span epub:type="pagebreak" id="page_112"/>defines the palette for these colors. The <code>contourf()</code> function is an alias for <code>contour()</code> with <code>fill=true</code>.</p>
<p class="indent">Let’s repeat the previous contour plot (<a href="ch04.xhtml#ch4fig19" class="calibre10">Figure 4-19</a>), but this time leave the color bar in, turn on the <code>fill</code>, and use a grayscale palette:</p>
<pre class="calibre13">contour(x, x, (x, y) -&gt; exp(-(0.05x^2 + y^2)/.1);
               clabels=true, levels=[0.1, 0.3, 0.5, 0.7, 0.9, 1.0],
               fill=true, c=[Gray(0.4), :white])</pre>
<p class="indent"><a href="ch04.xhtml#ch4fig20" class="calibre10">Figure 4-20</a> shows the filled contour plot.</p>
<div class="image1"><img alt="Image" id="ch4fig20" src="../images/ch04fig20.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-20: A filled contour plot</em></p>
<p class="indent">In this case, having both contour labels and a color bar is somewhat redundant, as they carry the same information, but this may make the plot easier to interpret. There is an art to scientific visualization in creating a result that is both intuitively clear and quantitatively precise.</p>
<h4 class="h3" id="ch04lev1sec17"><strong class="calibre2"><em class="calibre4">3D Parametric Plots</em></strong></h4>
<p class="noindent">Parametric plots in 3D work just as they do in 2D, but they trace a path through 3D space, with three functions of the single parameter giving the x-, y-, and z-coordinates. Unlike in 2D parametric plots, we must supply three vectors, and it doesn’t work with functions. Here is an example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">t = 0:2π/100:2π;</span>

julia&gt; <span class="codestrong">xp = sin.(3 .* t);</span>

julia&gt; <span class="codestrong">yp = cos.(3 .* t);</span>

julia&gt; <span class="codestrong">zp = t .* 0.2</span>

julia&gt; <span class="codestrong">plot(xp, yp, zp; lw=3, gridalpha=0.4, camera=(30, 50))</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_113"/>The <code>plot()</code> function knows what to do when supplied with three vectors as positional arguments, producing the resulting 3D parametric plot shown in <a href="ch04.xhtml#ch4fig21" class="calibre10">Figure 4-21</a>.</p>
<div class="image1"><img alt="Image" id="ch4fig21" src="../images/ch04fig21.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-21: An example of a 3D parametric plot</em></p>
<p class="indent">We can use the attributes for lines as for ordinary 2D plots, and set the camera angle as for surface plots.</p>
<h4 class="h3" id="ch04lev1sec18"><strong class="calibre2"><em class="calibre4">Vector Plots</em></strong></h4>
<p class="noindent">A vector field maps every point in space to a vector, which can be represented by an arrow. The <code>Plots</code> package offers vector plots created with the <code>quiver()</code> function. Its first two arguments are <code>x</code> and <code>y Vector</code>s containing the coordinates of the start of the vectors. The displacements from those coordinates to the vectors’ endpoints are stored in two other <code>Vector</code>s, placed in a <code>Tuple</code>, and assigned to a keyword argument also called <code>quiver</code>.</p>
<p class="indent">The following example shows how to use <code>quiver()</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">xc = 0:.3:π;</span>

julia&gt; <span class="codestrong">yc = sin.(xc);</span>

julia&gt; <span class="codestrong">quiver(xc, yc; quiver=(xc .- π/2, yc .- 0.25), lw=3)</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_114"/>These three lines produce the vector plot in <a href="ch04.xhtml#ch4fig22" class="calibre10">Figure 4-22</a>.</p>
<div class="image1"><img alt="Image" id="ch4fig22" src="../images/ch04fig22.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-22: A vector plot using</em> <span class="codeitalic">quiver()</span></p>
<p class="indent">The <code>quiver()</code> function accepts all the attributes for curves; here we set the line width to get thicker arrows.</p>
<h4 class="h3" id="ch04lev1sec19"><strong class="calibre2"><em class="calibre4">3D Scatterplots</em></strong></h4>
<p class="noindent"><code>Plots</code> can extend scatterplots into the third dimension. One way to visualize a 3D distribution of some quantity is to plot a regular 3D grid of markers while setting some marker attribute, such as size or opacity, to a function of the quantity. First we need to establish the grid by making <code>x</code>, <code>y</code>, and <code>z</code> <code>Vector</code>s:</p>
<pre class="calibre13">x = []; y = []; z = [];

for i in 0:20, j in 0:20, k in 0:20
    push!(x, i/10 - 1)
    push!(y, j/10 - 1)
    push!(z, k/10 - 1)
end</pre>
<p class="indent">This will create the coordinate arrays ranging from –1 to 1.</p>
<p class="indent">Let’s imagine a planet sitting in the center of our grid. We could plot the shape of the gravitational potential due to the planet by first defining a potential function and then using it to set the marker size:</p>
<pre class="calibre13">pot(x, y, z) = 1 / sqrt(x^2 + y^2 + z^2)
scatter(x, y, z;  ms=min.(pot.(x, y, z), 5), ma=0.4, legend=false)</pre>
<p class="indent"><span epub:type="pagebreak" id="page_115"/>The potential becomes large near the planet, so we need to limit the marker size with the <code>min()</code> function. It actually becomes infinite at (0, 0, 0), but Julia handles that gracefully. The result is shown in <a href="ch04.xhtml#ch4fig23" class="calibre10">Figure 4-23</a>.</p>
<div class="image1"><img alt="Image" id="ch4fig23" src="../images/ch04fig23.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-23: A 3D scatterplot</em></p>
<p class="indent">We set an opacity to allow us to see through the markers. This is the same <code>scatter()</code> function that we used in 2D, but Julia knows what to do if we give it three positional arguments.</p>
<h3 class="h2" id="ch04lev11"><strong class="calibre2">Useful Backends</strong></h3>
<p class="noindent"><code>GR</code>, the current default backend, has the merit of being fast and capable of producing most basic categories of visualization.</p>
<p class="indent">A few other backends are available for special purposes, but most of them require us to <code>add</code> them in the package manager before use.</p>
<h4 class="h3" id="ch04lev1sec20"><strong class="calibre2"><em class="calibre4">UnicodePlots</em></strong></h4>
<p class="noindent">The <code>unicodeplots</code> backend plots directly in the terminal. It’s good for a quick look at some data, which it plots using characters. We can also use it to generate plots to paste into an email, but obviously it’s not suited to making figures for publication, and it can’t save plots.</p>
<p class="indent">To produce quick plots in the terminal, first execute <span class="codestrong1">add UnicodePlots</span> in package mode, then call <span class="codestrong1">unicodeplots()</span> to activate the backend.</p>
<p class="indent">The <code>unicodeplots</code> backend doesn’t support every plot type. It can make 2D plots, including scatterplots, but not contour or surface plots. However, <code>unicodeplots</code> can render colored heatmaps in the terminal.<span epub:type="pagebreak" id="page_116"/></p>
<h4 class="h3" id="ch04lev1sec21"><strong class="calibre2"><em class="calibre4">PyPlot</em></strong></h4>
<p class="noindent">The <code>pyplot</code> backend uses Python’s Matplotlib, so it may be a good choice for those already familiar with that system. Although it can sometimes be a bit slow, it creates better plots than the default in some cases.</p>
<h4 class="h3" id="ch04lev1sec22"><strong class="calibre2"><em class="calibre4">PlotlyJS</em></strong></h4>
<p class="noindent">With the <code>plotlyjs</code> backend we can create interactive graphs for the web. Saving the plot with the <em class="calibre11">.html</em> file extension creates a file containing an HTML fragment that we can paste into a web page. The fragment loads some third-party JavaScript that supplies interactive controls for panning, zooming, and, for 3D plots, rotating in 3D space. Other forms of interactivity vary appropriately with the plot type. Two-dimensional plots display data values as the user hovers over the curve, and surface plots draw contours on the surfaces at the <em class="calibre11">z</em>-value of the mouse pointer.</p>
<p class="indent">Plotting is not at all fast, although the results look good and interaction is impressively responsive. Contour plots are better with <code>plotlyjs</code> than with <code>GR</code>, especially for colored contours, but the attributes for linewidth or linestyle have no effect, and manual levels don’t work.</p>
<p class="indent">When plotting from the REPL, a separate window pops up for each plot, using the same JavaScript interactivity as in the HTML files.</p>
<h4 class="h3" id="ch04lev1sec23"><strong class="calibre2"><em class="calibre4">PGFPlots and PGFPlotsX</em></strong></h4>
<p class="noindent">I won’t say much about these, because they are useful only to those who have LaTeX installed and some knowledge of the LaTeX graphing system PGFPlots. Those who do use these systems should be aware of the two Julia interfaces to them. The difference between the two versions is that <code>PGFPlotsX</code>’s syntax is closer to what’s used directly in LaTeX. With <code>PGFPlots</code>, we can make extraordinary visualizations that are difficult to achieve through other means. LaTeX users who aren’t familiar with the system may want to acquaint themselves. This backend does depend on a LaTeX installation—not a trivial requirement.</p>
<h4 class="h3" id="ch04lev1sec24"><strong class="calibre2"><em class="calibre4">HDF5</em></strong></h4>
<p class="noindent">HDF5 stands for Hierarchical Data Format, version 5. This backend does not display plots directly; its purpose is to bundle data and plots together into an HDF file. For anyone who uses HDF in their research, this package will be essential, but others will have no use for it.</p>
<p class="indent">The backend not only writes HDF files, it also can read them into the Julia session for display with other <code>Plots</code> backends.</p>
<h4 class="h3" id="ch04lev1sec25"><strong class="calibre2"><em class="calibre4">Gaston</em></strong></h4>
<p class="noindent"><code>Gaston</code> is an interface to gnuplot and depends on a gnuplot installation. This backend will be of interest to those already using that venerable and powerful graphics program.</p>
<p class="indent"><span epub:type="pagebreak" id="page_117"/><code>Gaston</code> is fast and powerful, because gnuplot is fast and powerful. If you routinely need to make complex 3D plots that the other backends can’t handle, or need more fine control over plots for publication, installing gnuplot and using it with <code>Gaston</code> may be the best choice.</p>
<h3 class="h2" id="ch04lev12"><strong class="calibre2">Layouts</strong></h3>
<p class="noindent">Earlier in this chapter we saw that the <code>plot()</code> function will arrange graphs in a grid if we pass it a number of plot objects. Sometimes we need more control over the arrangement of subplots in an illustration. In such cases, we turn to the <code>Layout</code> system.</p>
<p class="indent">The plotting package’s method for composing plots into larger illustrations is one of the jewels of the system. Considering the complexity that it allows, it’s remarkably intuitive to use.</p>
<p class="indent">In the following demonstrations, the <code>Vector s</code> contains six plots, each displaying a prominent digit, from 1 to 6. This will make it clear where the layout engine positions each plot.</p>
<p class="indent">If you’d like to follow along, you’ll need to create your own <code>s</code> vector, with plots of your choosing.</p>
<h4 class="h3" id="ch04lev1sec26"><strong class="calibre2"><em class="calibre4">Making Simple Rectangular Layouts</em></strong></h4>
<p class="noindent">To replace the default square grid of plots with a different rectangular arrangement, supply the desired number of rows and columns as a tuple assigned to the <code>layout</code> attribute:</p>
<pre class="calibre13">plot(s[1], s[2], s[3], s[4]; layout=(1, 4))</pre>
<p class="indent">As <a href="ch04.xhtml#ch4fig24" class="calibre10">Figure 4-24</a> shows, this call arranges the plots using one row and four columns.</p>
<div class="image1"><img alt="Image" id="ch4fig24" src="../images/ch04fig24.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-24: A one-row layout</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_118"/>The number of plots implied in the layout tuple must match exactly the number of subplots. The default in this case would be equivalent to <code>layout=(2, 2)</code>.</p>
<h4 class="h3" id="ch04lev1sec27"><strong class="calibre2"><em class="calibre4">Using grid()</em></strong></h4>
<p class="noindent">The simple layouts in the previous example make all the subplots the same size. To control the heights and widths of the rows and columns, use the <code>grid()</code> function, as in the following example:</p>
<pre class="calibre13">plot(s[1], s[2], s[3], s[4];
     layout=grid(2, 2; widths=(0.2, 0.8), heights=(0.7, 0.3)))</pre>
<p class="indent">This call creates the layout in <a href="ch04.xhtml#ch4fig25" class="calibre10">Figure 4-25</a>. We can omit either the <code>height</code> or the <code>width</code> specification to get equalized lengths in that direction.</p>
<div class="image1"><img alt="Image" id="ch4fig25" src="../images/ch04fig25.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-25: A layout using the</em> <span class="codeitalic">grid()</span> <em class="calibre11">function</em></p>
<p class="indent">When using <code>grid()</code>, the dimensions can add up to less than 1, which will simply leave some blank space, but they should not add to greater than 1.</p>
<h4 class="h3" id="ch04lev1sec28"><strong class="calibre2"><em class="calibre4">Creating Complex Layouts Using @layout</em></strong></h4>
<p class="noindent">We can create layouts of arbitrary complexity. The next level requires the use of the <code>@layout</code> macro. We haven’t seen macros yet; they’re introduced in “Macros” on <a href="ch06.xhtml#ch06lev4" class="calibre10">page 170</a>. For now, I’ll show how to use this particular macro to create graph layouts. We’ll be better equipped to understand how it works under the hood after we learn a bit more about the language.</p>
<p class="indent">The <code>@layout</code> macro creates a layout that follows the shape of a matrix that we supply to the macro. We use spaces to place subplots horizontally and <span epub:type="pagebreak" id="page_119"/>newlines or semicolons to place them vertically, as when constructing actual matrices. However, these <code>@layout</code> matrices don’t need to have matching dimensions. As in the following example, the rows can have different numbers of elements. I use <code>a</code> to represent a subplot, but we can use any identifiers. They have no meaning, as the layout engine just uses the plots in the order we supply them in the <code>plot()</code> function. Here’s a simple use of the macro:</p>
<pre class="calibre13">plot(s[1], s[2], s[3], s[4], s[5], s[6];
     layout =  @layout [ a a a
                          a a
                           a   ] )</pre>
<p class="indent"><a href="ch04.xhtml#ch4fig26" class="calibre10">Figure 4-26</a> shows the resulting layout. Observe how the arrangement of subplots follows the arrangement of the <code>a</code> placeholders used in the macro.</p>
<div class="image1"><img alt="Image" id="ch4fig26" src="../images/ch04fig26.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-26: Using the <span class="codeitalic">@layout</span> macro</em></p>
<p class="indent">The use of <code>@layout</code> in this form equalizes the space allotted to the subplots. To change the height or width of any of them, use the notation in the following example:</p>
<pre class="calibre13">plot(s[1], s[2], s[3], s[4], s[5], s[6];
     layout =  @layout [ a a a
                          a{0.68w} a
                            a{0.5h} ])</pre>
<p class="indent">The specifications inside the curly brackets are width or height as a fraction of the entire plot. This call creates the layout in <a href="ch04.xhtml#ch4fig27" class="calibre10">Figure 4-27</a>.<span epub:type="pagebreak" id="page_120"/></p>
<div class="image1"><img alt="Image" id="ch4fig27" src="../images/ch04fig27.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-27: Using the <span class="codeitalic">@layout</span> macro with dimension specifications</em></p>
<p class="indent">We can achieve even greater flexibility in layouts by using a call to <code>grid()</code> within the <code>@layout</code> argument, as in the following example:</p>
<pre class="calibre13">plot(s[1], s[2], s[3], s[4], s[5], s[6];
     layout=@layout [ grid(2, 2) a{0.3w}
                            b{0.2h} ])</pre>
<p class="indent">The number of subplots passed to the <code>@layout</code> macro must equal the number in the positional arguments to <code>plots()</code>. The <code>grid(2, 2)</code> call here accounts for four subplots, and the remaining two are represented by <code>a</code> and <code>b</code>. <a href="ch04.xhtml#ch4fig28" class="calibre10">Figure 4-28</a> shows the result.</p>
<div class="image1"><img alt="Image" id="ch4fig28" src="../images/ch04fig28.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-28: Using subgrids within a layout</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_121"/>“Detail Insets” on <a href="ch04.xhtml#ch04lev9" class="calibre10">page 106</a> explained how to create inset plots that magnified a section of a main plot. We can use the <code>inset</code> and <code>subplot</code> attributes that we used there to make any kind of inset, not merely one using <code>lens!()</code>, and we can combine it with any layout.</p>
<p class="indent">After creating the layout in the previous example, we can add an inset to it with this call:</p>
<pre class="calibre13">plot!(x -&gt; sin(7x); inset=bbox(0.2, 0.2, 0.3, 0.3), subplot=7,
      background_inside=RGBA(1, 1, 1, 0.3), lw=5, framestyle=:box,
      legend=false, lc=:black)</pre>
<p class="indent">The <code>inset</code> attribute is set to a <code>bbox</code>. Since we didn’t supply it with a positional argument, the <code>bbox</code> parameters will position the plot relative to the entire layout, rather than any particular subplot. The <code>subplot=7</code> setting makes the inset into a new subplot, which is necessary to make this work as intended, as the layout already has six subplots. <code>RGBA</code> is similar to the <code>RGB</code> that we saw before, but with a final parameter for the opacity.</p>
<p class="indent"><a href="ch04.xhtml#ch4fig29" class="calibre10">Figure 4-29</a> shows the result of adding the inset.</p>
<div class="image1"><img alt="Image" id="ch4fig29" src="../images/ch04fig29.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 4-29: Adding a floating inset to a layout</em></p>
<h3 class="h2" id="ch04lev13"><strong class="calibre2">Conclusion</strong></h3>
<p class="noindent">This chapter covered everything about the <code>Plots</code> package that you’ll need for most scientific graphics: the main types of plots, lenses and annotations, how to customize appearance, and how to lay out sets of graphs to form a composite illustration. In <a href="ch07.xhtml" class="calibre10">Chapter 7</a> we’ll find out how to make animations and explore some packages to create diagrams, and in <a href="ch08.xhtml" class="calibre10">Chapter 8</a> we’ll revisit the plotting system to learn about plot recipes.<span epub:type="pagebreak" id="page_122"/></p>
<div class="box">
<p class="boxtitle-d" id="fur4"><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">The official reference for the <code>Plots</code> package is available at <a href="https://docs.juliaplots.org/latest/" class="calibre10"><em class="calibre11">https://docs.juliaplots.org/latest/</em></a>.</li>
<li class="noindent1">Here’s where you can find a video about <code>Plots</code>
 by its creator: <a href="http://www.breloff.com/plots-video" class="calibre10"><em class="calibre11">http://www.breloff.com/plots-video</em></a>.</li>
<li class="noindent1">For a useful guide to making publication-quality plots, visit <a href="https://nextjournal.com/leandromartinez98/tips-to-create-beautiful-publication-quality-plots-in-julia" class="calibre10"><em class="calibre11">https://nextjournal.com/leandromartinez98/tips-to-create-beautiful-publication-quality-plots-in-julia</em></a>.</li>
<li class="noindent1">More information on the HDF5 format is available at <a href="https://www.hdfgroup.org/solutions/hdf5" class="calibre10"><em class="calibre11">https://www.hdfgroup.org/solutions/hdf5</em></a>.</li>
<li class="noindent1">Documentation on using HDF5 files in Julia is available at <a href="https://juliaio.github.io/HDF5.jl/stable/" class="calibre10"><em class="calibre11">https://juliaio.github.io/HDF5.jl/stable/</em></a>.</li>
<li class="noindent1">For more information on predefined palettes for plots, visit <a href="https://docs.juliaplots.org/latest/generated/colorschemes/" class="calibre10"><em class="calibre11">https://docs.juliaplots.org/latest/generated/colorschemes/</em></a>.</li>
<li class="noindent1">The <code>Gaston</code> headquarters, at <a href="https://mbaz.github.io/Gaston.jl/stable" class="calibre10"><em class="calibre11">https://mbaz.github.io/Gaston.jl/stable</em></a>, contains a well-chosen illustration.</li>
<li class="noindent1">Information and software downloads for gnuplot are available at <a href="http://gnuplot.info" class="calibre10"><em class="calibre11">http://gnuplot.info</em></a>.</li>
<li class="noindent1">The basics of LaTeX math syntax are available at <a href="https://www.cs.princeton.edu/courses/archive/spr10/cos433/Latex/latex-guide.pdf" class="calibre10"><em class="calibre11">https://www.cs.princeton.edu/courses/archive/spr10/cos433/Latex/latex-guide.pdf</em></a> (see Section 7).</li>
<li class="noindent1">Documentation on a Julia wrapper over the powerful <em class="calibre11">plotly.js</em> interactive plotting system is available through the <code>plotlyjs</code> package: <a href="https://plotly.com/julia/" class="calibre10"><em class="calibre11">https://plotly.com/julia/</em></a>.</li>
</ul>
</div>
</body></html>