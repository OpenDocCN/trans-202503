<html><head></head><body>
<h2 class="h2"><span epub:type="pagebreak" id="page_116"/><span epub:type="pagebreak" id="page_117"/><span class="big">5</span><br/>GUI: GETTING USERS INTERESTED</h2> &#13;
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">GUI (pronounced gooey) stands for graphical user interface. This is just a fancy term for any program that has graphical elements as opposed to just being text-based. Graphical elements can consist of static images or drawings, as we explored in the previous chapter, or interactive elements like buttons and menus. Aside from just graphical elements, GUIs introduce the <em>event</em> paradigm—events trigger actions. An event can be anything from a key press or mouse click to a timer going off. Racket not only supports building mini-applications, but also stand-alone executables.</p>&#13;
<p class="indent">In this chapter, we’ll bring our old friend the cycloid to life with an animation, learn some new (card) tricks, and make the Tower of Hanoi more than just an intellectual exercise.</p>&#13;
<h3 class="h3" id="ch00lev1sec_29"><span epub:type="pagebreak" id="page_118"/>Introduction to GUIs</h3>&#13;
<p class="noindent">Racket GUI programming makes use of the <em>racket/gui/base</em> library, which can be imported with the <code>(require racket/gui/base)</code> statement. Alternatively, you may use the language switch <code>#lang racket/gui</code>, which includes both the base Racket libraries and the GUI library. Here’s a little code snippet that does nothing more than create and display a window frame 300 by 200 pixels.</p>&#13;
<pre>#lang racket/gui&#13;
&#13;
(define frame&#13;
  (new frame%&#13;
       [label "I'm a GUI!"]&#13;
       [width 300]&#13;
       [height 200]))&#13;
&#13;
(send frame show #t)</pre>&#13;
<p class="indent">You should note that the frame size is the size of the exterior window and includes the size of the title bar and any window borders. The frame interior will be somewhat smaller.</p>&#13;
<p class="indent">The code below shows something a bit more exciting that demonstrates the basic idea of how to respond to an event.</p>&#13;
<pre>   #lang racket/gui&#13;
   &#13;
   (define main-frame&#13;
     (new frame%&#13;
          [label "I'm a GUI Too!"]&#13;
          [width 300]&#13;
          [height 100]))&#13;
   &#13;
   (define msg&#13;
  <span class="ent">➊</span> (new message%&#13;
       <span class="ent">➋</span> [parent main-frame]&#13;
          [auto-resize #t]&#13;
          [label "Hi, there!"]))&#13;
 &#13;
<span class="ent">➌</span> (new button%&#13;
        [parent main-frame]&#13;
        [label "Click Me"]&#13;
     <span class="ent">➍</span> [callback (λ (button event)&#13;
                   (send msg set-label "You didn't say may I!"))])&#13;
   &#13;
   (send main-frame show #t)</pre>&#13;
<p class="indent">The <code>message%</code> object <span class="ent">➊</span> creates a label with the text “Hi, there!” (<code>message%</code> objects are a bit more powerful than you might expect; they can also contain a bitmap as the label). GUI objects must normally specify the parent frame that they are contained in <span class="ent">➋</span>. We’ve also defined the <code>auto-resize</code> parameter <span epub:type="pagebreak" id="page_119"/>so that the message control will expand if the text is larger than it was initialized with.</p>&#13;
<p class="indent">Next we create a <code>button%</code> object <span class="ent">➌</span> and make it a child of the <code>main-frame</code> window. Buttons can respond to being clicked on with the mouse. This is handled with a <code>callback</code> option <span class="ent">➍</span>. This takes a function (in this case a lambda expression) that accepts two parameters. When the button is clicked, the window event processor will pass the callback function a pointer to the button object and an event object that contains information about the event (we don’t use them here; we just need to know that the button was clicked). In our case, we send the <code>msg</code> object a command for it to set its label to a new value.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch5fig1">Figure 5-1</a> shows how the thing will look (depending on your operating system, it may be slightly different).</p>&#13;
<div class="image"><img alt="Image" src="../images/05fig01.jpg"/></div>&#13;
<p class="figcap" id="ch5fig1"><em>Figure 5-1: Simple GUI application</em></p>&#13;
<p class="indent">Let’s try our hand at a bit of animation. We’ll begin simply, by just moving a little red circle across the screen:</p>&#13;
<pre>   #lang racket/gui&#13;
   &#13;
   (define RADIUS 8) &#13;
   (define DIAMETER (* 2 RADIUS))&#13;
   &#13;
   (define loc-x RADIUS)&#13;
   (define loc-y 35)&#13;
   &#13;
   (define main-frame&#13;
     (new frame%&#13;
          [label "I'm a GUI Too!"]&#13;
          [width 300]&#13;
          [height 100]))&#13;
   &#13;
   (define canvas&#13;
     (new canvas% [parent main-frame]&#13;
       <span class="ent">➊</span> [paint-callback&#13;
           (λ (canvas dc)&#13;
             (send dc set-smoothing 'smoothed)&#13;
             (send dc set-text-foreground "blue")&#13;
             <span epub:type="pagebreak" id="page_120"/>(send dc draw-text "Having a ball!" 0 0)&#13;
             (send dc set-brush "red" 'solid)&#13;
             (send dc draw-ellipse (- loc-x RADIUS) (- loc-y RADIUS) DIAMETER DIAMETER))]))&#13;
   &#13;
   (define timer&#13;
   <span class="ent">➋</span> (new timer%&#13;
       <span class="ent">➌</span> [notify-callback&#13;
           (λ ()&#13;
          <span class="ent">➍</span> (set! loc-x (add1 loc-x))&#13;
          <span class="ent">➎</span> (send canvas refresh-now))]))&#13;
          &#13;
   (send main-frame show #t)&#13;
&#13;
<span class="ent">➏</span> (send timer start 50)</pre>&#13;
<p class="indent">In this code, we create a <code>canvas%</code> object within the <code>frame%</code> object. This is the same canvas object we explored in the previous chapter, so all the drawing commands we saw previously are available. The <code>canvas</code> object supports a <code>paint-callback</code> event <span class="ent">➊</span>. This event is triggered whenever the canvas needs to be repainted (note that a drawing context, <code>dc</code>, is provided to the callback function). By default it’s triggered when the canvas is first displayed, but we force it to be refreshed by using a <code>timer%</code> object <span class="ent">➋</span>. The canvas object draws the ball at <code>(loc-x, loc-y)</code>, so our timer will update the <code>loc-x</code> value every time it’s called. The timer responds to an event called <code>notify-callback</code> <span class="ent">➌</span>. When this event is triggered, it forces the canvas to refresh itself by sending it a <code>refresh-now</code> message <span class="ent">➎</span>. The timer callback also increments the <code>loc-x</code> variable <span class="ent">➍</span>. This entire process is kicked off with the last line of code. We send the timer object a message to start triggering itself every 50 milliseconds <span class="ent">➏</span>.</p>&#13;
<p class="indent">We didn’t use it here, but the timer can also be stopped by sending it a <code>stop</code> message. The <code>timer%</code> object also supports a <code>just-once?</code> option, if the timer only needs to be triggered a single time. This can also be specified with the <code>start</code> message. For example calling the following code would cause the timer to stop and then to be triggered a single time after waiting one second.</p>&#13;
<pre>&gt; <span class="codestrong1">(send timer stop)</span>&#13;
&gt; <span class="codestrong1">(send timer start 1000 #t)</span></pre>&#13;
<p class="indent">If we wanted the ball to bounce back and forth, we could revise <code>timer</code> as follows:</p>&#13;
<pre>(define timer&#13;
  (let ([delta 2])&#13;
    (new timer%&#13;
         [notify-callback&#13;
          (λ ()&#13;
            (cond [(&lt;= loc-x RADIUS) (set! delta 2)]&#13;
                  [(&gt;= loc-x (- (send canvas get-width) RADIUS)) (set! delta -2)])&#13;
            <span epub:type="pagebreak" id="page_121"/>(set! loc-x (+ loc-x delta))&#13;
            (send canvas refresh-now))])))</pre>&#13;
<p class="indent">This time we define the variable <code>delta</code>, which is either positive or negative depending on which direction the ball is moving. We also add a <code>cond</code> statement to detect when the ball has reached one of the edges of the canvas and change the direction.</p>&#13;
<h3 class="h3" id="ch00lev1sec_30">Animating a Cycloid</h3>&#13;
<p class="noindent">In the last chapter, we saw how to plot the cycloid curve, which is generated by a point on the perimeter of a circle as it rolls without slipping on a straight line. In this section, we’ll produce an animation so that we can see this motion in action. The end result will be an animation of a rolling circle with a point on the circle tracing out the cycloid as it moves along. A snapshot of the animation is shown in <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/05fig02.jpg"/></div>&#13;
<p class="figcap" id="ch5fig2"><em>Figure 5-2: Animated cycloid</em></p>&#13;
<p class="indent">We once again avail ourselves of the <code>infix</code> package to make it easier to enter algebraic expressions. We’ll also use the <em>plot</em> library that we used before:</p>&#13;
<pre>#lang at-exp racket/gui &#13;
(require infix plot)</pre>&#13;
<p class="indent">Next we see that the <code>cycloid</code> function is unchanged from the one we used before.</p>&#13;
<pre><span epub:type="pagebreak" id="page_122"/>(define r 30)&#13;
(define angle 0)&#13;
&#13;
(define (cycloid t) @${vector[r*(t - sin[t]),  r*(1-cos[t])]})&#13;
(define (circle t) @${vector[r*angle + r*sin[t], r + r*cos[t]]})</pre>&#13;
<p class="indent">Again <code>r</code> is the radius of the circle used to define the cycloid. The <code>angle</code> variable is used to define the rotation angle at any point in the animation. The <code>circle</code> function will be used to create a parametric plot of the actual circle we’re rotating (shown in green in the figure).</p>&#13;
<p class="indent">To create the blue line segment that runs from the center of the circle to the edge as well as the red end points of the line, we’ll use the following two functions. The parameter <code>t</code> is the rotation angle.</p>&#13;
<pre>(define (line t)&#13;
  (let ([x @${r*(t - sin[t])}]&#13;
        [y @${r*(1 - cos[t])}]&#13;
        [x0 (* r angle)]&#13;
        [y0 r])&#13;
    (lines (list (vector x0 y0) (vector x y))&#13;
           #:width 2&#13;
           #:color "blue")))&#13;
&#13;
(define (end-points t)&#13;
  (let ([x @${r*(t - sin[t])}]&#13;
        [y @${r*(1 - cos[t])}]&#13;
        [x0 (* r angle)]&#13;
        [y0 r])&#13;
    (points (list (vector x0 y0) (vector x y))&#13;
            #:size 10&#13;
            #:sym 'fullcircle1&#13;
            #:color "red"&#13;
            #:fill-color "red")))</pre>&#13;
<p class="indent">There should be no surprises here: <em>x</em> and <em>y</em> end-point values are computed using basic trigonometry (see the solution to the cycloid problem in the previous chapter). We also examined using <code>lines</code> and <code>points</code> in the previous chapter.</p>&#13;
<p class="indent">Finally, we get to the actual plot routine:</p>&#13;
<pre>(plot-decorations? #f)&#13;
&#13;
(define (cycloid-plot dc)&#13;
  (plot/dc (list&#13;
            (axes)&#13;
            (parametric circle 0 (* 2 pi) #:color "green")&#13;
         <span class="ent">➊</span> (parametric cycloid 0 angle #:color "red")&#13;
         <span class="ent">➋</span> (line angle)&#13;
         <span epub:type="pagebreak" id="page_123"/><span class="ent">➌</span> (end-points angle))&#13;
        <span class="ent">➍</span> dc 10 25 300 150&#13;
           #:x-min 0&#13;
           #:x-max (* r 2 pi)&#13;
           #:y-min 0&#13;
           #:y-max (* r pi)))</pre>&#13;
<p class="indent">In order to plot within the GUI, we must use a special version of <code>plot</code> called <code>plot/dc</code> since this time we want the output to go to the drawing context. Note the difference between <code>plot</code> and <code>plot/dc</code> <span class="ent">➍</span>. Here we specify the drawing context, the <em>x</em> and <em>y</em> location for the plot, and the plot width and height. The other parameters are the same as for <code>plot</code>. The bulk of this code specifies the specific objects we want to plot. Of note are: the cycloid itself <span class="ent">➊</span>, the line connecting the circle center to edge <span class="ent">➋</span>, and the line end points <span class="ent">➌</span>. The code <code>(plot-decorations? #f)</code>, at the beginning of the listing, turns off some of the axis info so that we have a cleaner plot.</p>&#13;
<p class="indent">To actually generate the animation, we make some minor changes to the window code we saw earlier:</p>&#13;
<pre>(define main-frame&#13;
  (new frame%&#13;
       [label "The Plot Thickens"]&#13;
       [width 350]&#13;
       [height 250]))&#13;
&#13;
(define canvas&#13;
  (new canvas% [parent main-frame]&#13;
       [paint-callback&#13;
        (λ (canvas dc)&#13;
          (send dc set-smoothing 'smoothed)&#13;
       <span class="ent">➊</span> (cycloid-plot dc)&#13;
          (send dc set-text-foreground "blue")&#13;
          (send dc draw-text "Animated Cycloid" 10 180))]))&#13;
&#13;
(define timer&#13;
  (new timer%&#13;
       [notify-callback&#13;
        (λ ()&#13;
        <span class="ent">➋</span> (set! angle (+ 0.1 angle))&#13;
        <span class="ent">➌</span> (when (&gt; angle (* 2 pi)) (set! angle 0))&#13;
           (send canvas refresh-now))]))&#13;
       &#13;
(send main-frame show #t)&#13;
&#13;
(send timer start 10)</pre>&#13;
<p class="indent">Specifially, we update the rotation angle <span class="ent">➋</span> on each timer tick, and reset the angle to zero <span class="ent">➌</span> when the circle rotation reaches 2<em>π</em> degrees. The plot actually gets produced with <code>cycloid-plot dc</code> <span class="ent">➊</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/>Having completed a couple of warm-up exercises to familiarize ourselves with some basic GUI functionality, let’s take a look at something a bit more ambitious—something we can dazzle our friends with.</p>&#13;
<h3 class="h3" id="ch00lev1sec_31">Pick a Card</h3>&#13;
<p class="noindent">Let’s perform a little magic with our computer. In this trick, we deal out a 5-by-5 matrix of cards in some random order, face up. The participant mentally picks one of the cards and indicates which row the card resides in. The cards are then reshuffled and dealt out again in a 5-by-5 matrix. The subject is again asked to pick the row that the card appears on. The selected card is then revealed with great fanfare. Our Racket version of the game is shown in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>. The card images used here are available under the GPL<sup><a href="footnote.xhtml#ch05foot_1" id="ch05foot1">1</a></sup> thanks to Chris Aguilar.<sup><a href="footnote.xhtml#ch05foot_2" id="ch05foot2">2</a></sup></p>&#13;
<div class="image"><img alt="Image" src="../images/p0125-01.jpg"/></div>&#13;
<p class="figcap" id="ch5fig3"><em>Figure 5-3: Pick-a-card trick</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_125"/>It’s clear that if the cards were properly shuffled and re-dealt, it would be impossible to select the proper card without some possibility of error. Like all tricks, this one involves a bit of deception. The mechanism behind this trick is actually quite simple. In the following diagram, we indicate each card by a letter.</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0125-02.jpg"/></div>&#13;
<p class="indent">Suppose the <code>N</code> is selected in row 2, column 3. We can randomly swap the columns without affecting the selected row. After doing this, we may end up with something that looks like the following.</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0126-01.jpg"/></div>&#13;
<p class="indent">We now have something that looks quite different, but we still have the <code>N</code> in row 2 (but now in column 1). In an essential step that further adds to the illusion, we transpose the rows and columns (by transpose, we mean the rows become columns and the columns become rows—that is, row 1 becomes column 1, row 2 becomes column 2, and so on). Doing so results in the following arrangement.</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0126-03.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_126"/>The resulting matrix now looks nothing like the original, but notice that the <code>N</code> is now in column 2 instead of row 2. Once the subject indicates row 1 as the proper row (which was originally column 1), we immediately have the location (row 1, column 2—originally row 2). Since we transposed rows and columns, the player is unknowingly revealing the row and column the card resides in.</p>&#13;
<p class="indent">Swapping rows and columns and transposing rows with columns is standard fare in the mathematical discipline of <em>linear algebra</em>. We’ll make use of the Racket <em>matrix</em> library, which provides the functionality that we need. Given this, our code begins with the following:</p>&#13;
<pre>#lang racket/gui&#13;
(require math/matrix)&#13;
&#13;
(define selected-row -1)&#13;
(define selected-col -1)&#13;
(define show-card #t)</pre>&#13;
<p class="indent">The <code>define</code> expressions are used to keep track of the program state.</p>&#13;
<p class="indent">The card bitmaps will be kept in a vector called <code>card-deck</code>. The root names of the card images being used are stored in another vector, called <code>card-names</code>. The following code reads the card images in from a subfolder called <code>Card PNGs</code>:</p>&#13;
<pre>(define card-names&#13;
  #("01H" "02H" "03H" "04H" "05H" "06H" "07H" "08H" "09H" "10H" "11H" "12H" "13H"&#13;
    "01C" "02C" "03C" "04C" "05C" "06C" "07C" "08C" "09C" "10C" "11C" "12C" "13C"&#13;
    "01D" "02D" "03D" "04D" "05D" "06D" "07D" "08D" "09D" "10D" "11D" "12D" "13D"&#13;
    "01S" "02S" "03S" "04S" "05S" "06S" "07S" "08S" "09S" "10S" "11S" "12S" "13S"))&#13;
&#13;
&#13;
(define card-deck &#13;
  (for/vector ([card-name (in-vector card-names)]) &#13;
    <span epub:type="pagebreak" id="page_127"/>(read-bitmap (build-path "Card PNGs" (string-append card-name ".png")))))&#13;
&#13;
(define card-width (send (vector-ref card-deck 0) get-width))&#13;
(define card-height (send (vector-ref card-deck 0) get-height))</pre>&#13;
<p class="indent">Note that we’ve used <code>build-path</code> to construct an operating system–agnostic pathname.</p>&#13;
<p class="indent">Since we’ll want to be able to shuffle the cards, the following code will place the <code>card-deck</code> in a random order:</p>&#13;
<pre>(define (shuffle-deck)&#13;
  (for ([i (in-range 52)])&#13;
    (let ([j (random 52)]&#13;
          [t (vector-ref card-deck i)])&#13;
      (vector-set! card-deck i (vector-ref card-deck j))&#13;
      (vector-set! card-deck j t))))</pre>&#13;
<p class="indent">The <code>card-deck</code> vector is just a linear list of the card bitmaps. To be able to present them in the arrangement to be shown on the display, we define a Racket <code>display-matrix</code> that holds the indexes into the <code>card-deck</code> vector. We also create <code>get-card</code>, which enables us to access any bitmap given the row and column it resides in.</p>&#13;
<pre>(define display-matrix&#13;
  (build-matrix SIZE SIZE (λ (r c) (+ (* r SIZE) c))))&#13;
&#13;
(define (get-card r c)&#13;
  (vector-ref card-deck (matrix-ref display-matrix r c)))</pre>&#13;
<p class="indent">In this section, we’ve explained the basic mechanism behind the trick and defined some data structures to hold the puzzle objects (the cards and their images). In the next section, we’ll exploit Racket’s layout mechanism to generate an attractive tableau.</p>&#13;
<h4 class="h4" id="ch00lev2sec_37"><strong><em>GUI Layout</em></strong></h4>&#13;
<p class="noindent">We’ve used buttons, the message control, and the canvas control before, but we displayed them in the default order, which just stacks one on top of the other. In this case we need something a bit more sophisticated. Racket provides two layout controls that are sufficient for our purposes: <code>horizontal-panel%</code> and <code>vertical-panel%</code>. The <code>vertical-panel%</code> control allows us to stack controls vertically, as shown on the left side of <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>. In the code below, we use the <code>horizontal-panel%</code> to house the <code>vertical-panel%</code> and the canvas used to draw the card faces.</p>&#13;
<pre>(define main-frame&#13;
  (new frame%&#13;
       [label "Pick a Card"]&#13;
       [width 550]&#13;
       [height 650]))&#13;
&#13;
<span epub:type="pagebreak" id="page_128"/>(define main-panel (new horizontal-panel%&#13;
                        [parent main-frame]))&#13;
&#13;
(define control-panel (new vertical-panel%&#13;
                           [parent main-panel]&#13;
                           [min-width 100]&#13;
                           [stretchable-width 100]))&#13;
&#13;
(define MARGIN 10)     ; in pixels&#13;
(define SIZE 5)        ; card rows and columns&#13;
(define MSG-HEIGHT 20) ; height of msg label&#13;
&#13;
(define canvas&#13;
  (new canvas%&#13;
       [parent main-panel]&#13;
       [min-width 400]&#13;
       [paint-callback&#13;
        (λ (canvas dc)&#13;
          (send dc set-smoothing 'smoothed)&#13;
          (for* ([r (in-range SIZE)] ; draw the cards&#13;
                 [c (in-range SIZE)])&#13;
            (send dc draw-bitmap (get-card r c)&#13;
                  (+ MARGIN (* c (+ MARGIN card-width)))&#13;
                  (+ MSG-HEIGHT MARGIN (* r (+ MARGIN card-height)))))&#13;
       <span class="ent">➊</span> (when show-card ; draw red border on selected card&#13;
            (let* ([off-x (/ MARGIN 2)]&#13;
                   [off-y (+ off-x MSG-HEIGHT)])&#13;
              (send dc set-pen "red" 3 'solid)&#13;
              (send dc set-brush (new brush% [style 'transparent]))&#13;
              (send dc draw-rectangle&#13;
                    (+ off-x (* selected-col (+ MARGIN card-width)))&#13;
                    (+ off-y (* selected-row (+ MARGIN card-height)))&#13;
                    (+ card-width MARGIN) (+ card-height MARGIN))&#13;
              (send dc set-pen "black" 2 'solid)))&#13;
         )]))</pre>&#13;
<p class="indent">Most of the code for <code>canvas</code> should be familiar, but the section starting with <code>when</code> <span class="ent">➊</span> uses a state variable called <code>show-card</code> that’s set to true when it’s time to reveal the selected card (via a red border around the card).</p>&#13;
<h4 class="h4" id="ch00lev2sec_38"><strong><em>Building the Controls</em></strong></h4>&#13;
<p class="noindent">We want a message control to be shown in the upper left portion of the application to act as a prompt to the user. Let’s add the code to do that now. Begin with the following code.</p>&#13;
<pre><span epub:type="pagebreak" id="page_129"/>(define msg&#13;
  (new message%&#13;
       [parent control-panel]&#13;
       [min-height MSG-HEIGHT]&#13;
       [label "Select again."]))</pre>&#13;
<p class="indent">To dress up our buttons, we need an image of an arrow. Rather than go out and try to find a bitmap of an arrow, it’s a simple matter to construct one on the fly, as we do here via a sequence of <code>path</code> statements to generate a polygon in the shape of an arrow:</p>&#13;
<pre>(define arrow ; bitmap&#13;
  (let* ([image (make-bitmap 50 40)]&#13;
         [dc (new bitmap-dc% [bitmap image])]&#13;
         [path (new dc-path%)])&#13;
    (send dc set-brush (new brush% [color "blue"]))&#13;
    (send path move-to  0 10)&#13;
    (send path line-to 30 10)&#13;
    (send path line-to 30  0)&#13;
    (send path line-to 50 20)&#13;
    (send path line-to 30 40)&#13;
    (send path line-to 30 30)&#13;
    (send path line-to  0 30)&#13;
    (send path line-to  0 10)&#13;
    (send dc draw-path path)&#13;
    image))</pre>&#13;
<p class="indent">Here’s a slightly more concise way to write this:</p>&#13;
<pre>(define arrow ; bitmap&#13;
  (let* ([image (make-bitmap 50 40)]&#13;
         [dc (new bitmap-dc% [bitmap image])]&#13;
         [path (new dc-path%)])&#13;
    (send dc set-brush (new brush% [color "blue"]))&#13;
    (send path move-to  0 10)&#13;
    (send path&#13;
          lines '(&#13;
                 (30 . 10)&#13;
                 (30 . 0)&#13;
                 (50 . 20)&#13;
                 (30 . 40)&#13;
                 (30 . 30)&#13;
                 ( 0 . 30)&#13;
                 ( 0 . 10)))&#13;
    (send dc draw-path path)&#13;
    image))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_130"/>Now that we have our arrow, we also need buttons to select the card row. We’ll use the following code:</p>&#13;
<pre>(define (gen-row-button r)&#13;
  (new button%&#13;
       [parent control-panel]&#13;
       [label arrow]&#13;
       [min-width 80]&#13;
       [min-height 50]&#13;
       [vert-margin (/ (+ MARGIN (- card-height 50)) 2)]&#13;
       [callback (λ (button event)&#13;
                   (select-row r))]))&#13;
 &#13;
(for ([i (in-range SIZE)])&#13;
  (gen-row-button i))</pre>&#13;
<p class="indent">Note we’ve used the card height to adjust the button margins so that they line up properly with the row of card images.</p>&#13;
<h4 class="h4" id="ch00lev2sec_39"><strong><em>Control Logic</em></strong></h4>&#13;
<p class="noindent">Now that we’ve specified the basic GUI components, we move on to the control logic where we make the puzzle interactive. The logic to swap the columns of the <code>display-matrix</code> is given in the following <code>swap-cols</code> function. It takes two column numbers and swaps the columns of <code>display-matrix</code> as required. We’re going to say a few words about how this works, but if you’re not familiar with linear algebra, you may want to take this function as a black box that works as expected and skim over the next section.</p>&#13;
<pre>(define (swap-cols c1 c2)&#13;
  (let ([swap-matrix (make-swap c1 c2)])&#13;
    (matrix* display-matrix swap-matrix)))</pre>&#13;
<h4 class="h4" id="ch00lev2sec_40"><strong><em>Linear Algebra Zone</em></strong></h4>&#13;
<p class="noindent">As you will recall from linear algebra, there are three elementary matrix operations.</p>&#13;
<ul>&#13;
<li class="noindent">Interchange two rows (or columns).</li>&#13;
<li class="noindent">Multiply each element in a row (or column) by a number.</li>&#13;
<li class="noindent">Multiply a row (or column) by a number and add the result to  another row (or column).</li>&#13;
</ul>&#13;
<p class="indent">All these operations can be performed by matrix multiplication. For our purposes we only need to implement the ability to interchange columns, but if <em>M</em> and <em>R</em> are matrices such that <em>RM</em> = <em>M</em><sub><em>r</em></sub>, where certain rows of <em>M</em> are swapped, then <em>MR</em> = <em>M</em><sub><em>c</em></sub> produces a matrix with the corresponding columns <span epub:type="pagebreak" id="page_131"/>swapped. As an example we define <em>M</em> and <em>R</em> as follows:</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0131-01.jpg"/></div>&#13;
<p class="indent">Then we can swap the first two rows or first two columns of <em>M</em> as follows:</p>&#13;
<div class="image1"><img alt="Image" src="../images/05fig03.jpg"/></div>&#13;
<p class="indent">Racket supplies a matrix multiplication operator, <code>matrix*</code>, but unfortunately does not provide built-in row or column swapping operations, so we must create our own. The following <code>make-swap</code> function takes two row numbers and returns a matrix with the corresponding matrix rows swapped. We employ this in conjunction with the Racket-supplied matrix multiplication operator in the <code>swap-cols</code> function given above. Since <code>swap-matrix</code> is the second argument in the multiplication, it performs a column swap instead of a row swap.</p>&#13;
<pre>(define (make-swap r1 r2)&#13;
  (define (swap-func r c)&#13;
    (cond [(= r r1) (if (= c r2) 1 0)]&#13;
          [(= r r2) (if (= c r1) 1 0)]&#13;
          [(= r c) 1]&#13;
          [else 0]))&#13;
  (build-matrix SIZE SIZE swap-func))</pre>&#13;
<p class="indent">The function <code>build-matrix</code> is defined in the Racket <em>matrix</em> library. It constructs a new matrix by populating it with elements computed by <code>swap-func</code>.</p>&#13;
<h4 class="h4" id="ch00lev2sec_41"><strong><em>Wrapping Up the GUI</em></strong></h4>&#13;
<p class="noindent">When the user makes their first row selection, the following code runs:</p>&#13;
<pre> (define (first-row-selection r)&#13;
   (set! selected-col r)&#13;
   (send msg set-label "Select again.")&#13;
<span class="ent">➊</span> (for ([i (in-range SIZE)])&#13;
    (let ([j (random SIZE)]&#13;
          [t (vector-ref card-deck i)])&#13;
   <span class="ent">➋</span> (set! display-matrix (swap-cols i j))))&#13;
<span class="ent">➌</span> (set! display-matrix (matrix-transpose display-matrix))&#13;
   (send canvas refresh-now))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_132"/>You may be wondering why the first thing it does is set <code>selected-col</code> with the selected row <code>r</code>. The reason is that the selected row will become the selected column after the built-in <code>matrix-transpose</code> is executed <span class="ent">➌</span>. We perform a series of column swaps to jumble up the displayed equation without affecting the row order <span class="ent">➊</span> <span class="ent">➋</span>).</p>&#13;
<p class="indent">The second time the user makes a row selection, the <code>show-selection</code> function runs.</p>&#13;
<pre>(define (show-selection r)&#13;
  (send msg set-label "Tada!")&#13;
  {set! selected-row r}&#13;
  (set! show-card #t)&#13;
  (send canvas refresh-now))</pre>&#13;
<p class="indent">This function sets the <code>show-card</code> variable and triggers the canvas to refresh and reveal the selected card.</p>&#13;
<p class="indent">To initialize the entire process, we have the <code>restart</code> function:</p>&#13;
<pre>(define (restart)&#13;
  (shuffle-deck)&#13;
  (send msg set-label "Select a row.")&#13;
  (set! show-card #f)&#13;
  (set! selected-row -1)&#13;
  (set! selected-col -1)&#13;
  (send canvas refresh-now))&#13;
  &#13;
(restart)&#13;
&#13;
(send main-frame show #t)</pre>&#13;
<p class="indent">Let’s see what happens when a user clicks on a button. Way back when we created the arrow buttons, we assigned them a callback function called <code>select-row</code> along with the appropriate row number. Depending on the state variables <code>selected-row</code> and <code>selected-col</code>, the function will perform different actions.</p>&#13;
<pre>(define (select-row r)&#13;
  (cond [(&lt; selected-col 0) (first-row-selection r)]&#13;
        [(&lt; selected-row 0) (show-selection r)]&#13;
        [else (send msg set-label "Restart.")]))</pre>&#13;
<p class="indent">If <code>selected-col</code> is less than zero (meaning this is the first selection), it runs <code>first-row-selection</code>. If <code>selected-row</code> is less than zero (meaning this is the second selection), it runs <code>show-selection</code> to reveal the selected card. If neither of these are true (meaning both selections have been made), it prompts the user to reset the program by pressing the Play Again button.</p>&#13;
<p class="indent">Our card trick application has exercised much of Racket’s GUI capabilities, but there’s nothing quite like seeing objects flying around the screen. In the next section, we’ll convert our command line version of the Tower of Hanoi into an interactive animated puzzle.</p>&#13;
<h3 class="h3" id="ch00lev1sec_32">Control Tower</h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_133"/>Back in <a href="ch03.xhtml">Chapter 3</a>, we looked at a simple function that solved the Tower of Hanoi puzzle. The function returned a list that contained the moves required to solve the puzzle. This is of course not a very satisfying way to visualize how the solution progresses. In this section we’ll remedy that omission by animating the solution and learn a bit more about Racket widgets in the process. Widgets are graphical objects used to provide input to an application (such as buttons, text boxes, and pick lists) or display information (such as progress bars and labels).</p>&#13;
<p class="indent">The code to solve the puzzle (<code>hanoi</code>) is repeated below. It still does exactly what we need. Recall that it returns a list of moves, each of which is a list containing the peg to move from and the peg to move to. It can be placed anywhere after the <code>#lang racket/gui</code> command.</p>&#13;
<pre>(define (hanoi n f t)&#13;
  (if (= 1 n) (list (list f t))&#13;
      (let* ([u (- 3 (+ f t))] ; determine unused peg&#13;
             [m1 (hanoi (sub1 n) f u)] ; move n-1 disks from f to u&#13;
             [m2 (list f t)] ; move single disk from f to t&#13;
             [m3 (hanoi (sub1 n) u t)]); move disks from u to t&#13;
        (append m1 (cons m2 m3)))))</pre>&#13;
<p class="indent">The program we’ll build in the following sections will accommodate from 1 to 10 disks. <a href="ch05.xhtml#ch5fig4">Figure 5-4</a> illustrates some basic parameters we’ll be using in the rest of this section. As shown, each peg will be assigned a number from 0 to 2. Each position on a peg also has a designated value. These values will be used as parameters to various functions to control the source and target location of the disks.</p>&#13;
<div class="image"><img alt="Image" src="../images/05fig04.jpg"/></div>&#13;
<p class="figcap" id="ch5fig4"><em>Figure 5-4: Tower of Hanoi parameters</em></p>&#13;
<h4 class="h4" id="ch00lev2sec_42"><strong><em>Setting Up</em></strong></h4>&#13;
<p class="noindent">We’ll begin with some useful constants.</p>&#13;
<pre>#lang racket/gui&#13;
&#13;
(define MAX-DISKS 9)&#13;
(define UNIT 15)&#13;
(define PEG-X (+ (* 3 UNIT) (* MAX-DISKS (/ UNIT 2))))&#13;
(define PEG-Y (* 2 UNIT))&#13;
(define START-Y (+ PEG-Y (* UNIT MAX-DISKS)))&#13;
(define PEG-DIST (* UNIT (add1 MAX-DISKS)))&#13;
(define RADIUS (/ UNIT 2))&#13;
<span epub:type="pagebreak" id="page_134"/>(define ANIMATION-INTERVAL 1) ; ms&#13;
(define MOVE-DIST 2)</pre>&#13;
<p class="indent">To enable scalability, we define the constant <code>UNIT</code> as a basic unit of measure (in pixels). By basing all the other measurements on this value, we can scale the entire interface by changing this one number. Constants <code>PEG-X</code> and <code>PEG-Y</code> are the location of the first peg. Constant <code>PEG-DIST</code> is the distance between pegs and <code>START-Y</code> is the <em>y</em> location of a disk in the bottommost position (position 1). Constant <code>RADIUS</code> is used to curve the ends of the disks and pegs. And constant <code>ANIMATION-INTERVAL</code> defines the time in milliseconds between animation updates, and <code>MOVE-DIST</code> defines how far a disk moves on each animation update. These last two parameters may need to be adjusted depending on the performance characteristics of the computer the code runs on.</p>&#13;
<p class="indent">Here are the main window elements. There should be no surprises here.</p>&#13;
<pre>(define main-frame&#13;
  (new frame%&#13;
       [label "Tower of Hanoi"]&#13;
       [width (+ (* 7 UNIT) (* 3 PEG-DIST))]))&#13;
&#13;
(define main-panel (new vertical-panel%&#13;
                        [parent main-frame]))&#13;
&#13;
(define canvas&#13;
  (new canvas%&#13;
       [parent main-panel]&#13;
       [min-height (+ START-Y UNIT)]&#13;
       [paint-callback (λ (canvas dc) (update-canvas dc))]))&#13;
&#13;
(define control-panel1&#13;
  (new horizontal-panel%&#13;
       [parent main-panel]))&#13;
&#13;
(define control-panel2&#13;
  (new horizontal-panel%&#13;
       [parent main-panel]))</pre>&#13;
<p class="indent">We’ll examine <code>update-canvas</code> in greater detail later.</p>&#13;
<p class="indent">The following defines are for variables that will be updated during the progress of the animation.</p>&#13;
<pre>(define num-disks 8)&#13;
(define delta-x 0) &#13;
(define delta-y 0)&#13;
(define target-x 0) &#13;
(define target-y 0)&#13;
(define source-peg 0)&#13;
(define dest-peg 0)&#13;
(define current-disk 0)&#13;
<span epub:type="pagebreak" id="page_135"/>(define current-x 0)&#13;
(define current-y 0)&#13;
(define peg-disks (make-vector 3 0))&#13;
(define move-list '())&#13;
(define total-moves 0)&#13;
(define move-num 0)&#13;
(define in-motion #f)&#13;
(define mode 'stoppd)</pre>&#13;
<p class="indent">The <code>peg-disks</code> variable is a three-element vector that’s used to represent the three pegs. Each element of the vector will be populated with a list of numbers that represent the disks that reside on the respective pegs. Most of the other variables are fairly descriptive of their purpose, but we’ll provide more detail as we progress through the section.</p>&#13;
<p class="indent">To give you an idea of what we’re building, <a href="ch05.xhtml#ch5fig5">Figure 5-5</a> is a snapshot of the final application with a disk movement in progress.</p>&#13;
<div class="image"><img alt="Image" src="../images/05fig05.jpg"/></div>&#13;
<p class="figcap" id="ch5fig5"><em>Figure 5-5: Tower of Hanoi GUI</em></p>&#13;
<p class="indent">In the next section, we’ll describe the interface widgets that we’ll use within the GUI.</p>&#13;
<h4 class="h4" id="ch00lev2sec_43"><strong><em>Row 1 Widgets</em></strong></h4>&#13;
<p class="noindent">The first row of controls (shown immediately below the canvas in <a href="ch05.xhtml#ch5fig5">Figure 5-5</a>) is housed in the horizontal panel <code>control-panel1</code>. We’ll describe each in the order they’re added to the panel.</p>&#13;
<p class="indent">First, there’s a basic button control that has a callback function that calls <code>reset</code> (provided the animation isn’t already in progress), which restores everything back to the start state.</p>&#13;
<pre>(define btn-reset&#13;
  (new button%&#13;
       [parent control-panel1]&#13;
       [label "Reset"]&#13;
       [callback (λ (button event)&#13;
                   (when (not in-motion) (reset)))]))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_136"/>Next we have a <code>text-field%</code> widget. This is a basic text entry box. We use it to allow the user to specify the number of disks to use for the animation (via <code>init-value</code>, which is used to initialize a number of other controls as well).</p>&#13;
<pre>(define text-disks&#13;
  (new text-field%&#13;
       [parent control-panel1]&#13;
       [label "Disks: "]&#13;
       [stretchable-width #f]&#13;
       [init-value "8"]))</pre>&#13;
<p class="indent">Following the text box, we have a handy slider control. The slider provides an alternative method to select the number of disks. The callback function will update the text box containing the disk count based on the position of the slider. This is done by getting the value of the slider and sending it to the text box widget. The purpose of the remaining parameters should be fairly self-evident.</p>&#13;
<pre>(define slider-disks&#13;
  (new slider%&#13;
       [parent control-panel1]&#13;
       [label #f]&#13;
       [stretchable-width #f]&#13;
       [min-width 100]&#13;
       [style (list' horizontal 'plain)]&#13;
       [min-value 1]&#13;
       [max-value MAX-DISKS]&#13;
       [init-value 8]&#13;
       [callback (λ (slider event)&#13;
                   (send text-disks&#13;
                         set-value&#13;
                         (number-&gt;string (send slider-disks get-value))))]))</pre>&#13;
<p class="indent">The final element of the first row is a progress bar. Here we’re using a Racket <code>gauge%</code> widget. To update this control, it just needs to be sent a number indicating the value to show (the number must be within the specified range).</p>&#13;
<pre>(define gauge&#13;
  (new gauge%&#13;
       [parent control-panel1]&#13;
       [label "Progress: "]&#13;
       [stretchable-width #f]&#13;
       [min-width 100]&#13;
       (range 100)))</pre>&#13;
<h4 class="h4" id="ch00lev2sec_44"><span epub:type="pagebreak" id="page_137"/><strong><em>Row 2 Widgets</em></strong></h4>&#13;
<p class="indent">The second row of controls is housed in the horizontal panel <code>control-panel2</code>. First up is a button that allows the user to step through the solution of the puzzle one move at a time.</p>&#13;
<pre>(new button%&#13;
     [parent control-panel2]&#13;
     [label "Step"]&#13;
     [callback (λ (button event)&#13;
                 (when (not in-motion)&#13;
                   (when (equal? move-list '()) (reset))&#13;
                   (set! in-motion #t)&#13;
                   (set! mode 'step)&#13;
                   (send msg set-label "Running...")&#13;
                   (init-next-step)&#13;
                   (send timer start ANIMATION-INTERVAL)))])</pre>&#13;
<p class="indent">The state variable <code>in-motion</code> is used to flag whether an animation is currently in progress. If so, this variable is checked to ensure that the action isn’t re-triggered before the step is complete. The <code>move-list</code> variable contains the list of moves provided by the solver, <code>hanoi</code>. If the list is empty, the solution has already been generated; in that case, the program is automatically reset. The variable <code>mode</code> can have one of three values:</p>&#13;
<div class="bq5">&#13;
<p class="noindent">’<code>stopped</code>. Waiting on user input.</p>&#13;
<p class="noindent">’<code>step</code>. Performing a single step.</p>&#13;
<p class="noindent">’<code>solve</code>. Solution animation in progress.</p>&#13;
</div>&#13;
<p class="noindent">Then <code>init-next-step</code> sets up all the state variables to perform the next step of the solution.</p>&#13;
<p class="indent">Next we have the button that triggers the full-blown solution.</p>&#13;
<pre>(new button%&#13;
     [parent control-panel2]&#13;
     [label "Solve"]&#13;
     [callback (λ (button event)&#13;
                 (when (not in-motion)&#13;
                   (let ([old num-disks]&#13;
                         [new (validate-disks)])&#13;
                  <span class="ent">➊</span> (when (or (equal? move-list '()) (not (= old new)))&#13;
                       (set! num-disks new)&#13;
                       (reset))&#13;
                     (set! in-motion #t)&#13;
                     (set! mode 'solve)&#13;
                     (send msg set-label "Running...")&#13;
                     (init-next-step)&#13;
                     (send timer start ANIMATION-INTERVAL))))])</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_138"/>The callback for this button is similar to the one for the step button, but this time we also check to see whether the user has changed the number of disks <span class="ent">➊</span> , in which case the program is reset to reflect the new number of disks before the animation is run. It also sets the <code>mode</code> variable to ’<code>solve</code>. (If you’re bothered by the fact that <code>(object:button . . . )</code> prints out in the DrRacket window when this is executed, you can wrap this in a <code>void</code> form.)</p>&#13;
<p class="indent">The next button is quite simple: it sets <code>mode</code> to ’<code>step</code>. The mode is checked at the end of each step, so this will automatically cause the animation to stop. It can be resumed by pressing either the Solve or the Step button.</p>&#13;
<pre>(new button%&#13;
     [parent control-panel2]&#13;
     [label "Pause"]&#13;
     [callback (λ (button event)&#13;
                 (set! mode 'step))])</pre>&#13;
<p class="indent">The last control in the panel is a standard <code>message%</code> widget. It’s used to display the current state of the program.</p>&#13;
<pre>(define msg&#13;
  (new message%&#13;
       [parent control-panel2]&#13;
       [auto-resize #t]&#13;
       [label "Ready"]))</pre>&#13;
<h4 class="h4" id="ch00lev2sec_45"><strong><em>Getting in Position</em></strong></h4>&#13;
<p class="noindent">Now let’s look at a couple of functions that determine how to position the disks on the canvas. Each disk has a number from 1 to <code>MAX-DISKS</code> that determines the size of the disk. The <code>disk-x</code> function is passed the disk number and the number of the peg the disk resides on; it then returns the x-coordinate of the disk. The <code>disk-y</code> function is passed the disk position on a peg (see <a href="ch05.xhtml#ch5fig4">Figure 5-4</a>) and returns the y-coordinate.</p>&#13;
<pre>(define (disk-x n peg)&#13;
  (let ([w (* (add1 n) UNIT)])&#13;
    (- (+ PEG-X (* peg PEG-DIST)) (/ w 2) (/ UNIT -2))))&#13;
    &#13;
(define (disk-y pos)&#13;
  (- START-Y (* pos UNIT)))</pre>&#13;
<p class="indent">A disk is actually just a rounded rectangle. We’re going to add a little bling to our disks by including a gradient. This will make our disks look a little more disk-like. If you look closely at <a href="ch05.xhtml#ch5fig5">Figure 5-5</a>, you’ll notice that the disks are not a flat color, but give the appearance of being cylindrical. To this end we define a function <code>make-gradient</code>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_139"/>(define (make-gradient start stop c1 c2)&#13;
  (new linear-gradient%&#13;
       [x0 start] [y0 0]&#13;
       [x1 stop] [y1 0]&#13;
       [stops&#13;
        (list (list 0   (make-object color% c1))&#13;
              (list 0.5 (make-object color% c2))&#13;
              (list 1   (make-object color% c1)))]))</pre>&#13;
<p class="indent">This function returns a Racket <code>linear-gradient%</code> object that can be applied to a brush. The <code>start</code> and <code>stop</code> parameters are the screen <em>x</em> locations where the gradient is to start and end. Variable <code>c1</code> is the color at the ends of the gradient, and <code>c2</code> is the color in the center of the gradient. Linear gradients work by defining a line segment whose end points are given by (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>) and (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>). The colors are applied perpendicularly along the line. That’s why for our purposes we can just set the <em>y</em> values to 0. The colors are varied along the line by defining a list of <em>stop</em> positions. Each position defines the position along the line to apply a color. The position is a number between 0 and 1, where 0 is the color at the start of the line and 1 is the color at the end of the line; any number between 0 and 1 would designate a color at some point along the line.</p>&#13;
<p class="indent">To actually draw a disk, we use the following <code>draw-disk</code> function. We pass this function a drawing context, a disk number, a peg number, and a position on the peg.</p>&#13;
<pre>(define (draw-disk dc n peg pos)&#13;
  (let* ([w (* (add1 n) UNIT)]&#13;
         [x (disk-x n peg)]&#13;
         [y (disk-y pos)])&#13;
    (send dc set-brush&#13;
          (new brush%&#13;
               [gradient (make-gradient x (+ x w) "Green" "GreenYellow")]))&#13;
    (send dc draw-rounded-rectangle x y w UNIT RADIUS)))</pre>&#13;
<p class="indent">Inside we compute the width of the disk and the x-and y-coordinates. We then create a brush using our <code>make-gradient</code> function to create a linear gradient with which we draw a rounded rectangle to represent a disk.</p>&#13;
<p class="indent">The following functions draw the disks. The <code>draw-peg-disks</code> draws all the disks on a single peg. It’s passed a drawing context, a peg number, and a list containing the disks that need to be drawn. The <code>draw-disks</code> function calls <code>draw-peg-disks</code> once for each peg.</p>&#13;
<pre>(define (draw-peg-disks dc peg disks)&#13;
  (define (loop disks pos)&#13;
    (when (&gt; pos 0)&#13;
      (let ([n (first disks)]&#13;
            [r (rest disks)])&#13;
        (draw-disk dc n peg pos)&#13;
        (loop r (sub1 pos)))))&#13;
  <span epub:type="pagebreak" id="page_140"/>(loop disks (length disks)))&#13;
  &#13;
(define (draw-disks dc)&#13;
  (for ([peg (in-range 3)])&#13;
    (draw-peg-disks dc peg (vector-ref peg-disks peg))))</pre>&#13;
<p class="indent">Here we have <code>draw-base</code>, which draws the base with the pegs (notice the pegs also use a linear gradient).</p>&#13;
<pre>(define (draw-base dc)&#13;
  (for ([i (in-range 3)])&#13;
    (let ([x (+ PEG-X (* i PEG-DIST))])&#13;
      (send dc set-brush&#13;
            (new brush%&#13;
                 [gradient (make-gradient x (+ x UNIT) "Chocolate" "DarkOrange")]))&#13;
      (send dc draw-rounded-rectangle x PEG-Y UNIT (+ UNIT (- START-Y PEG-Y)) RADIUS)))&#13;
  (send dc set-brush (new brush% [color "Chocolate"]))&#13;
  (send dc draw-rectangle UNIT START-Y (+ (* 4 UNIT) (* 3 PEG-DIST)) UNIT))</pre>&#13;
<p class="indent">The actual drawing process originates with <code>update-canvas</code> as given here. Aside from calling <code>draw-base</code> and <code>draw-disks</code> as described above, it checks to see if there’s currently a disk in motion (determined by <code>current-disk</code> being greater than zero). If this is the case, it also renders the disk being animated.</p>&#13;
<pre>(define (update-canvas dc)&#13;
  (draw-base dc)&#13;
  (draw-disks dc)&#13;
  (when (current-disk . &gt; . 0)&#13;
    (let* ([w (* (add1 current-disk) UNIT)]&#13;
           [x current-x]&#13;
           [y current-y])&#13;
      (send dc set-brush&#13;
            (new brush%&#13;
                 [gradient (make-gradient x (+ x w) "Green" "GreenYellow")]))&#13;
      (send dc draw-rounded-rectangle x y w UNIT RADIUS))))</pre>&#13;
<h4 class="h4" id="ch00lev2sec_46"><strong><em>Controlling the Animation</em></strong></h4>&#13;
<p class="noindent">We’re now going to look at a couple of functions used to initialize the state variables at two key points in the process: at the start of the solution, and before each step. The first is called <code>reset</code>.</p>&#13;
<pre>  (define (reset)&#13;
 <span class="ent">➊</span> (set! num-disks (validate-disks))&#13;
    (set! delta-x 0)&#13;
    (set! delta-y 0)&#13;
    <span epub:type="pagebreak" id="page_141"/>(set! current-disk 0)&#13;
 <span class="ent">➋</span> (set! move-list (hanoi num-disks 0 2))&#13;
    (set! total-moves (length move-list))&#13;
    (set! move-num 0)&#13;
 <span class="ent">➌</span> (vector-set! peg-disks 0 (range 1 (+ 1 num-disks)))&#13;
    (vector-set! peg-disks 1 '())&#13;
 <span class="ent">➍</span> (vector-set! peg-disks 2 '())&#13;
    (send canvas refresh-now))&#13;
&#13;
<span class="ent">➎</span> (define (init-next-step)&#13;
    (let ([move (first move-list)])&#13;
      (set! source-peg (first move))&#13;
      (set! dest-peg (second move))&#13;
      (set! delta-x 0)&#13;
      (set! delta-y (- MOVE-DIST))&#13;
      (set! target-y (/ UNIT 2))&#13;
      (set! move-list (rest move-list))&#13;
      (let* ([source-disks (vector-ref peg-disks source-peg)]&#13;
             [pos (length source-disks)])&#13;
        (set! current-disk (first source-disks))&#13;
        (set! current-x (disk-x current-disk source-peg))&#13;
        (set! current-y (disk-y pos))&#13;
        (vector-set! peg-disks source-peg&#13;
                     (rest source-disks)))))&#13;
                   &#13;
 <span class="ent">➏</span> (define (validate-disks)&#13;
     (let* ([disks-str (send text-disks get-value)]&#13;
            [n (string-&gt;number disks-str)])&#13;
       (if (and (integer? n) (&lt; 0 n (add1 MAX-DISKS)))&#13;
           (begin&#13;
             (send slider-disks set-value n)&#13;
             (send msg set-label "  Ready")&#13;
             n)&#13;
           (begin&#13;
             (send text-disks set-value (number-&gt;string num-disks))&#13;
             (send msg set-label "  Disks out of range.")&#13;
             num-disks))))</pre>&#13;
<p class="indent">The code above begins by assigning the requested number of disks to the variable <code>num-disks</code> via a call to <code>validate-disks</code> <span class="ent">➊</span> (<code>validate-disks</code> <span class="ent">➏</span> ensures that the user has entered a proper number of disks; if not, it reverts back to the previous valid entry). Following this, a list of moves is generated based on the requested number of disks <span class="ent">➋</span>. Next, we initialize the <code>peg-disks</code> vector with the disks on each peg <span class="ent">➌</span> <span class="ent">➍</span>. The <code>init-next-step</code> function <span class="ent">➎</span> works by extracting the next move from the move list to determine the source and destination pegs, target locations, and parameters for the disk to be moved.</p>&#13;
<p class="indent">We finally arrive at the <code>move-disk</code> code responsible for the main animation update process. It processes a single move step in three phases: the <span epub:type="pagebreak" id="page_142"/>target disk moving up and off the source peg, the disk moving left or right toward the destination peg, and the disk moving down to its final resting place. In the code below, <code>update-progress</code> is used to update the progress bar. It’s called by <code>move-disk</code> at the end of each step <span class="ent">➎</span>.</p>&#13;
<pre>(define (update-progress)&#13;
  (send gauge set-value (inexact-&gt;exact (floor (* 100 (/ move-num total-moves))))))&#13;
&#13;
(define (move-disk)&#13;
  (cond [((abs delta-y) . &gt; . 0)&#13;
         (begin&#13;
        <span class="ent">➊</span> (set! current-y (+ current-y delta-y))&#13;
           (when ((abs (- target-y current-y)) . &lt; . MOVE-DIST)&#13;
             (set! current-y target-y)&#13;
             (if (delta-y . &lt; . 0) &#13;
                 (begin ; was moving up&#13;
                   (set! target-x (disk-x current-disk dest-peg))&#13;
                   (set! delta-x (sgn (- dest-peg source-peg)))&#13;
                   (set! delta-y 0))&#13;
                 (begin ; was moving down&#13;
                   (set! move-num (add1 move-num))&#13;
                <span class="ent">➋</span> (vector-set! peg-disks dest-peg&#13;
                        (cons current-disk (vector-ref peg-disks dest-peg)))&#13;
                   (if (equal? mode 'step)&#13;
                       (begin&#13;
                         (send timer stop)&#13;
                         (set! current-disk 0)&#13;
                         (set! in-motion #f)&#13;
                         (set! mode 'stopped)&#13;
                         (send msg set-label "Ready")&#13;
                         (set! delta-y 0))&#13;
                       (if (&gt; (length move-list) 0)&#13;
                           (init-next-step)&#13;
                           (begin&#13;
                             (send timer stop)&#13;
                             (send msg set-label "Done!")&#13;
                             (set mode 'stopped)&#13;
                             (set! in-motion #f)&#13;
                             (set! delta-y 0))))))))]&#13;
        &#13;
     <span class="ent">➌</span> [((abs delta-x) . &gt; . 0)&#13;
         (begin&#13;
        <span class="ent">➍</span> (set! current-x (+ current-x delta-x))&#13;
           (when ((abs (- target-x current-x)) . &lt; . MOVE-DIST)&#13;
             (set! current-x target-x)&#13;
             (set! target-y (* PEG-DIST (- dest-peg source-peg)))&#13;
             (set! delta-y MOVE-DIST)&#13;
             <span epub:type="pagebreak" id="page_143"/>(let ([tdisks (length (vector-ref peg-disks dest-peg))])&#13;
               (set! target-y (disk-y (add1 tdisks))))&#13;
             (set! delta-x 0)))]&#13;
        &#13;
        [else (send timer stop)])&#13;
        &#13;
<span class="ent">➎</span> (update-progress)&#13;
<span class="ent">➏</span> (send canvas refresh-now))</pre>&#13;
<p class="indent">Before <code>move-disk</code> is called, the target disk source and destination parameters would all have been established by a call to <code>init-next-step</code>.</p>&#13;
<p class="indent">The code for vertical movement starts <span class="ent">➊</span>, and the current y-coordinate for the disk is updated. A check is then made to see whether the disk is at its target location. If the disk is at its target location and was moving up, a new x-coordinate target and travel delta for the disk are set. If the disk was moving down, the destination peg is updated by adding the animated disk to the list <span class="ent">➋</span>. If the animation is in ’<code>step</code> mode, the animation timer is turned off and state variables are set to indicate the step is complete. Otherwise, the animation is in ’<code>solve</code> mode, so a check is made to see if any moves remain. If any moves remain, <code>init-next-step</code> is called; otherwise, the timer is stopped.</p>&#13;
<p class="indent">The check for horizontal movement is made at <span class="ent">➌</span>. The x-coordinate of the disk is updated with a subsequent check to see whether the disk is at its target location <span class="ent">➍</span>. If so, it sets up the state variables so that the next time <code>move-disk</code> is triggered, the disk begins to move down. At the end of every step, the progress meter and canvas are updated <span class="ent">➎</span> <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch00lev2sec_47"><strong><em>Wrapping Things Up</em></strong></h4>&#13;
<p class="noindent">The remaining items needed to get things going are given below. First, we define <code>timer</code> with a callback to <code>move-disk</code>. Next, <code>reset</code> is called to initialize all the state variables. And finally, we show the main window.</p>&#13;
<pre>(define timer&#13;
    (new timer% [notify-callback move-disk]))&#13;
&#13;
(reset)&#13;
&#13;
(send main-frame show #t)</pre>&#13;
<p class="indent">In addition to a nice little application to explore various facets of the Tower of Hanoi puzzle, in the process of building this application, we’ve utilized a significant number (but not all) of the widgets provided by the DrRacket environment.</p>&#13;
<h3 class="h3" id="ch00lev1sec_33"><span epub:type="pagebreak" id="page_144"/>Summary</h3>&#13;
<p class="noindent">In this chapter, we began with a couple of simple GUI applications and built up to a fairly full-featured application where we were exposed to a number of the elements needed to build a robust application. Later in the book, we’ll see how to bundle this functionality into a stand-alone application that can be run independent of the DrRacket environment. But, next up, we’ll be exploring how to access and analyze data in its various incarnations.</p>&#13;
</body></html>