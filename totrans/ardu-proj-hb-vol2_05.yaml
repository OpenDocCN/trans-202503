- en: '**LCDs**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ultrasonic Range Finder**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll create a simple ultrasonic range finder with a screen
    that displays the distance of an object up to 5 meters from the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0106-01.jpg)![Image](../images/p0107-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HD44780 16x2 LCD screen**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HC-SR04 ultrasonic sensor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**50k-ohm potentiometer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARY REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LiquidCrystal**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ultrasonic range finder sends out a burst of ultrasound and listens for
    the echo that bounces off an object. The Arduino sends out a short pulse on the
    trigger pin to send the ultrasonic burst, then listens for a pulse on the echo
    pin using the `pulseIn` function.
  prefs: []
  type: TYPE_NORMAL
- en: This duration between sending and receiving the pulse is equal to the time taken
    by the ultrasound to travel to the object and back to the sensor. The Arduino
    converts this time to distance and displays it on the LCD screen. You can find
    an HC-SR04 unit ([Figure 13-1](ch13.xhtml#ch13fig1)) from one of the sources listed
    in the “[Retailer List](app02.xhtml#ch00lev1sec170)” on [page 249](app02.xhtml#page_249),
    or you can search online for *HC-SR04 ultrasonic module*.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 13-1:** The HC-SR04 ultrasonic sensor'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f13-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An LCD (liquid crystal display) screen is made of two sheets of polarizing material
    with a liquid crystal solution between them. Current passing through the solution
    makes the screen opaque, so by controlling which areas of the screen current passes
    through, the Arduino creates an image or, in this case, characters. You’ll need
    an LCD screen that’s compatible with the Hitachi HD44780 driver for it to work
    with the Arduino; there are lots of them out there and you can usually identify
    them by their 16-pin interface. We’ll use the LiquidCrystal library to send characters
    to the LCD screen (refer to the primer if you need a refresher on libraries).
    The LiquidCrystal library maps the characters and uses the `print` commands to
    send messages to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**PREPARING THE LCD SCREEN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LCD screen will probably require a bit of assembly. Your screen should have
    come with 16 holes, as shown in [Figure 13-2](ch13.xhtml#ch13fig2), and a separate
    strip of header pins. Break off a row of 16 pins from the strip. Insert the shorter
    side of the pins into the 16 LCD holes. You’ll need to solder these in place;
    the primer has a quick soldering guide if you need pointers. Solder the far-right
    and far-left pins first to hold the strip in place and wait a moment for them
    to set. Then solder each pin in turn. Holding the iron to the pins for too long
    will damage them, so solder them only for a couple of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 13-2:** A 16×2 LCD screen'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f13-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Place your LCD screen in the breadboard, inserting the header pins into the
    breadboard holes. Also place the potentiometer in the breadboard, and use jumper
    wires to connect your LCD screen, Arduino, and potentiometer as shown in the following
    table. The pins of the LCD screen should be labeled or numbered, either on the
    back or the front. If not, they usually start at 1 from the left when the pins
    are along the top. There are a number of connections from the LCD screen to Arduino
    GND, so use the breadboard ground rail to make multiple connections to the Arduino
    GND pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|  **LCD SCREEN**  | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 VSS | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 2 VDD | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 3 VO contrast | Potentiometer center pin |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 4 RS | Pin 11 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 5 R/W | Pin 10 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 6 Enable | Pin 9 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 7 D0 | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 8 D1 | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 9 D2 | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10 D3 | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 11 D4 | Pin 7 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 12 D5 | Pin 6 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 13 D6 | Pin 5 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 14 D7 | Pin 4 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 15 A BcL+ | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 16 K BcL– | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: You should have already connected the center pin of the 50kohm potentiometer
    to LCD pin 3 (VO). Now connect one of the outer potentiometer pins to GND and
    the other to +5V. Twist the potentiometer to control the contrast of your LCD
    screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Backlit LCD screens will have resistors built in, but if you have a nonbacklit
    LCD screen, insert a 220-ohm resistor between LCD 15 and +5V. Check the data sheet
    for your screen if you’re unsure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the ultrasonic sensor module to your breadboard and connect VCC to +5V,
    Trig to Arduino pin 13, Echo to Arduino pin 12, and GND to GND, as shown in the
    following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **ULTRASONIC SENSOR** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Trig | Pin 13 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Echo | Pin 12 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Connect your breadboard rails to Arduino +5V and GND for power.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that your setup matches the circuit diagram in [Figure 13-3](ch13.xhtml#ch13fig3),
    and upload the code in “[The Sketch](ch13.xhtml#ch00lev1sec54)” on [page 112](ch13.xhtml#page_112).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 13-3:** The circuit diagram for the ultrasonic range finder'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f13-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch first calls on the LiquidCrystal library and defines the LCD pins
    connected to the Arduino. Pin 13 on the Arduino, connected to the trigger pin
    of the sensor, sends an ultrasonic signal out, and Arduino pin 12, connected to
    the echo pin of the sensor, receives the returning signal. The Arduino converts
    the time between sending and receiving the signal into distance and displays the
    result on the LCD screen, in both inches and centimeters. This sketch can be found
    on the Arduino site, so I’ve copied it here exactly as it appears there.
  prefs: []
  type: TYPE_NORMAL
- en: /*
  prefs: []
  type: TYPE_NORMAL
- en: Created 3 Nov 2008 by David A. Mellis;
  prefs: []
  type: TYPE_NORMAL
- en: Modified 30 Aug 2011 by Tom Igoe
  prefs: []
  type: TYPE_NORMAL
- en: This example code is in the public domain.
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <LiquidCrystal.h>'
  prefs: []
  type: TYPE_NORMAL
- en: LiquidCrystal lcd(11, 10, 9, 7, 6, 5, 4);
  prefs: []
  type: TYPE_NORMAL
- en: int pingPin = 13;
  prefs: []
  type: TYPE_NORMAL
- en: int inPin = 12;
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.begin(16, 2);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("testing...");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: // Establish variables for duration of the ping,
  prefs: []
  type: TYPE_NORMAL
- en: '// and the distance result in inches and centimeters:'
  prefs: []
  type: TYPE_NORMAL
- en: // long duration, inches, cm;
  prefs: []
  type: TYPE_NORMAL
- en: // The PING))) is triggered by a HIGH pulse of 2 ms or more
  prefs: []
  type: TYPE_NORMAL
- en: '// Give a short LOW pulse beforehand to ensure a clean HIGH pulse:'
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(pingPin, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(pingPin, LOW);
  prefs: []
  type: TYPE_NORMAL
- en: delayMicroseconds(2);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(pingPin, HIGH);
  prefs: []
  type: TYPE_NORMAL
- en: delayMicroseconds(10);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(pingPin, LOW);
  prefs: []
  type: TYPE_NORMAL
- en: '// The same pin is used to read the signal from the PING))):'
  prefs: []
  type: TYPE_NORMAL
- en: // a HIGH pulse whose duration is the time (in microseconds)
  prefs: []
  type: TYPE_NORMAL
- en: // from the sending of the ping to the reception of its echo off
  prefs: []
  type: TYPE_NORMAL
- en: // of an object.
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(inPin, INPUT);
  prefs: []
  type: TYPE_NORMAL
- en: duration = pulseIn(inPin, HIGH);
  prefs: []
  type: TYPE_NORMAL
- en: // Convert the time into a distance
  prefs: []
  type: TYPE_NORMAL
- en: inches = microsecondsToInches(duration);
  prefs: []
  type: TYPE_NORMAL
- en: cm = microsecondsToCentimeters(duration);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.clear();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(0, 0);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(inches);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("in, ");
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(cm);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("cm");
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: long microsecondsToInches(long microseconds) {
  prefs: []
  type: TYPE_NORMAL
- en: // According to Parallax's datasheet for the PING))),
  prefs: []
  type: TYPE_NORMAL
- en: // there are 73.746 ms/in (i.e. sound travels at 1130 fps).
  prefs: []
  type: TYPE_NORMAL
- en: // This gives the distance traveled by the ping, outbound,
  prefs: []
  type: TYPE_NORMAL
- en: // and return, so divide by 2 to get the distance of the obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: return microseconds / 74 / 2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: long microsecondsToCentimeters(long microseconds) {
  prefs: []
  type: TYPE_NORMAL
- en: // The speed of sound is 340 m/s or 29 ms/cm.
  prefs: []
  type: TYPE_NORMAL
- en: // The ping travels out and back, so to find the distance
  prefs: []
  type: TYPE_NORMAL
- en: // of the object, take half of the distance traveled.
  prefs: []
  type: TYPE_NORMAL
- en: return microseconds / 29 / 2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *Nothing is displayed on the LCD screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure you’ve connected power to the breadboard rails and the connections
    match the tables given earlier.
  prefs: []
  type: TYPE_NORMAL
- en: • Turn the potentiometer to change the contrast of the screen until you see
    text.
  prefs: []
  type: TYPE_NORMAL
- en: • If the screen has garbled messages on it, you have not wired it up correctly;
    recheck your wiring against [Figure 13-3](ch13.xhtml#ch13fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '**14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Digital Thermometer**
  prefs: []
  type: TYPE_NORMAL
- en: This project will add an LM35 temperature sensor to an LCD screen and Arduino
    to give you a digital thermometer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0114-01.jpg)![Image](../images/p0115-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HD44780 16×2 LCD screen**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LM35 temperature sensor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**50k-ohm potentiometer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARY REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LiquidCrystal**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino takes the voltage reading from the same LM35 temperature sensor
    we used in Project 12 and converts that value to temperature in degrees Celsius.
    The sketch then changes this value to Fahrenheit by multiplying the value by 9,
    dividing the result by 5, and adding 32\. The LiquidCrystal library does all the
    hard work in displaying the temperature on the LCD screen using the `lcd.print`
    command. This project can easily be adapted with more sensors for an all-around
    weather center.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, prepare the LCD screen according to “[Preparing the LCD Screen](ch13.xhtml#ch00lev1sec52)”
    on [page 109](ch13.xhtml#page_109). Then follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert your LCD screen and potentiometer into the breadboard; then use your
    breadboard and jumper wires to make the connections for the LCD screen as shown
    in the following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LCD SCREEN** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 VSS | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 2 VDD | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 3 VO contrast | Potentiometer center pin |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 4 RS | Pin 12 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 5 R/W | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 6 Enable | Pin 11 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 7 D0 | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 8 D1 | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 9 D2 | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10 D3 | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 11 D4 | Pin 5 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 12 D5 | Pin 4 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 13 D6 | Pin 3 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 14 D7 | Pin 2 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 15 A BcL+ | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 16 K BcL– | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Connect the GND and +5V rails to Arduino GND and +5V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should have already connected the center pin of the 50k-ohm potentiometer
    to LCD pin 3 (VO). Now connect one of the outer pins to GND and the other to +5V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the center pin of the LM35 temperature sensor to Arduino A0, the left
    pin to the +5V rail, and the right pin to the GND rail, as shown in the following
    table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LM35 SENSOR** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Left | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Center | A0 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Right | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Make sure your setup matches the circuit diagram shown in Figure 14-2, and upload
    the code in “[The Sketch](ch14.xhtml#ch00lev1sec58)” on [page 118](ch14.xhtml#page_118).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 14-1:** The circuit diagram for the digital thermometer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f14-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch uses the LiquidCrystal library to display a value on the screen according
    to what the LM35 sensor detects. The LM35 sensor sends a reading to Arduino pin
    A0, which is read as voltage. The sketch converts the voltage reading to a temperature
    value in Celsius, and then it uses a couple of calculations to show the final
    reading in Fahrenheit. The sketch updates and displays the reading every second.
  prefs: []
  type: TYPE_NORMAL
- en: '#include <LiquidCrystal.h> // Call the LCD library'
  prefs: []
  type: TYPE_NORMAL
- en: '#define sensor A0 // Pin connected to LM35 sensor (A0)'
  prefs: []
  type: TYPE_NORMAL
- en: int Vin; // Reads the value from the Arduino pin
  prefs: []
  type: TYPE_NORMAL
- en: float Temperature; // Receives the voltage value converted to temp
  prefs: []
  type: TYPE_NORMAL
- en: float TF; // Receives the converted value in °F
  prefs: []
  type: TYPE_NORMAL
- en: LiquidCrystal lcd(12, 11, 5, 4, 3, 2); // Pins connected the LCD
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.begin(16, 2); // The display is 16x2
  prefs: []
  type: TYPE_NORMAL
- en: 'lcd.print("Temperature: "); // Sends text to the LCD'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: // Reads the A0 pin and stores the value in Vin
  prefs: []
  type: TYPE_NORMAL
- en: Vin = analogRead (sensor);
  prefs: []
  type: TYPE_NORMAL
- en: // Converts voltage value to temperature and
  prefs: []
  type: TYPE_NORMAL
- en: // stores value in Temperature (in °C)
  prefs: []
  type: TYPE_NORMAL
- en: Temperature = (500 * Vin) / 1023;
  prefs: []
  type: TYPE_NORMAL
- en: TF = ((9 * Temperature) / 5) + 32; // Changes °C to °F
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(0, 1); // Move cursor of LCD to next line
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(TF); // Display the temperature on the LCD screen
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(" F"); // Write F for the Fahrenheit scale
  prefs: []
  type: TYPE_NORMAL
- en: delay(1000); // Wait for a second before reading the pin again
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *Nothing is displayed on the LCD screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure you’ve connected power to the breadboard rails and that the connections
    match the tables given earlier.
  prefs: []
  type: TYPE_NORMAL
- en: • Turn the potentiometer to change the contrast of the screen until you see
    text.
  prefs: []
  type: TYPE_NORMAL
- en: • If the screen has garbled messages on it, you probably haven’t wired it up
    correctly; recheck your wiring against Figure 14-2.
  prefs: []
  type: TYPE_NORMAL
- en: • If the value shown seems too high, make sure the LM35 sensor is firmly inserted
    in the breadboard and allow a moment for the reading to stabilize.
  prefs: []
  type: TYPE_NORMAL
- en: '**15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bomb Decoder Game**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll build a code-breaking bomb-decoding game. We’ll use an
    LCD screen and a keypad to give the players instructions and take input.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0119-01.jpg)![Image](../images/p0120-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HD44780 16×2 LCD screen**'
  prefs: []
  type: TYPE_NORMAL
- en: '**10k-ohm potentiometer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Piezo sounder**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3×4 membrane keypad**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3 220-ohm resistors**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red LED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Yellow LED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Green LED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARIES REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LiquidCrystal**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Keypad**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tone**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you power up the Arduino, one player enters a four-digit code to start
    the bomb timer. They give the timer to another player, who presses the * button
    to begin decoding the bomb—this player (the “defuser”) must crack the code entered
    by the first player to defuse the bomb in time. If the defuser presses a wrong
    key, they can press # to delete their input and start again. If they enter the
    wrong code or the timer reaches zero, the bomb detonates and they lose.'
  prefs: []
  type: TYPE_NORMAL
- en: During the game, the yellow LED flashes and the piezo sounder beeps in time
    to the countdown. The LCD screen displays the countdown and code input. When the
    bomb detonates, all the LEDs flash and the piezo sounds an explosion.
  prefs: []
  type: TYPE_NORMAL
- en: A good way to take this game further would be to ask the defuser four questions,
    each giving the defuser one digit of the bomb code. The defuser has a set time
    to answer the questions and input the four-digit code. Answer incorrectly or too
    late, and the bomb explodes!
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If required, prepare the LCD screen by soldering the header pins as described
    in “[Preparing the LCD Screen](ch13.xhtml#ch00lev1sec52)” on [page 109](ch13.xhtml#page_109).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place your LCD screen in the breadboard, inserting the header pins into the
    breadboard holes. Also place the potentiometer in the breadboard, and use the
    breadboard and jumper wires to connect your LCD screen, Arduino, and potentiometer
    as shown in the following table. There are multiple GND connections, so use the
    breadboard rail to make those connections to the Arduino GND pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LCD SCREEN** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 VSS | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 2 VDD | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 3 VO contrast | Potentiometer center pin |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 4 RS | Pin 7 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 5 R/W | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 6 Enable | Pin 8 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 7 D0 | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|  8 D1  | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 9 D2 | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10 D3 | No connection |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 11 D4 | Pin 10 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 12 D5 | Pin 11 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 13 D6 | Pin 12 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 14 D7 | Pin 13 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 15 A BcL+ | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 16 K BcL– | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: You should have already connected the center pin of the 10k-ohm potentiometer
    to LCD pin 3 (VO). Now connect one of the outer pins to GND and the other to +5V,
    as shown in [Figure 15-1](ch15.xhtml#ch15fig1). This controls the contrast of
    your LCD screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 15-1:** The potentiometer controls the contrast of your LCD screen.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f15-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Looking at the keypad head-on, as in [Figure 15-2](ch15.xhtml#ch15fig2), the
    pins are numbered 1–7 from left to right. Connect the keypad pins as shown in
    the following table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 15-2:** The 3×4 numeric keypad with seven pin connections'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f15-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '| **KEYPAD** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 1 | Pin 5 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 2 | Pin A5 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 3 | Pin A4 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 4 | Pin A2 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 5 | Pin A1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 6 | Pin A0 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Pin 7 | Pin A3 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Connect the piezo sounder’s red wire directly to Arduino pin 9 and its black
    wire to Arduino GND.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **PIEZO SOUNDER** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Red wire | Pin 9 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Black wire | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Place the green LED in the breadboard, connecting the short, negative leg to
    the negative breadboard rail via a 220-ohm resistor. Connect the green LED’s long,
    positive leg to pin 2\. Do the same with the yellow LED to pin 3 and the red LED
    to pin 4, as shown in [Figure 15-3](ch15.xhtml#ch15fig3) and the table that follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 15-3:** Connect the LEDs to the Arduino via a 220-ohm resistor.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f15-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '| **LEDS** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Negative legs | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Green positive leg | Pin 2 via 220-ohm resistor |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Yellow positive leg | Pin 3 via 220-ohm resistor |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Red positive leg | Pin 4 via 220-ohm resistor |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Connect the positive and negative breadboard power rails to +5V and GND, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your completed project circuit matches [Figure 15-4](ch15.xhtml#ch15fig4),
    remember to add the required libraries to your *Libraries* folder, and then upload
    the code in “[The Sketch](ch15.xhtml#ch00lev1sec63)” on [page 127](ch15.xhtml#page_127).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 15-4:** The circuit diagram for the bomb decoder game'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f15-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**PLAYING THE GAME**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 15-5](ch15.xhtml#ch15fig5) shows the different stages of playing the
    game.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 15-5:** Playing the game'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f15-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enter the code to set up the bomb.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bomb confirms the code entered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The timer starts the countdown sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The yellow LED flashes in time to the countdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the keypad to another player (the defuser). They press the * button on
    the keypad, then enter the defuse code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The screen does not show the numbers entered to defuse the bomb.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the correct code is entered, the bomb is defused . . .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: . . . but if not . . . Boom!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All libraries and code can be downloaded from* [https://www.nostarch.com/arduinohandbook2/](https://www.nostarch.com/arduinohandbook2/).'
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch calls on the Keypad, LiquidCrystal, and Tone libraries. LiquidCrystal
    is included in your IDE, but you’ll have to download Keypad and Tone from the
    book’s resources at *[https://www.nostarch.com/arduinohandbook2/](https://www.nostarch.com/arduinohandbook2/)*
    and save them in your *Libraries* folder for the Arduino (see the primer for details
    on how to do that if you’re unsure).
  prefs: []
  type: TYPE_NORMAL
- en: First the sketch defines the timer duration, password length, LED pins, and
    keypad. It requests a code input from the first player by displaying “Enter Code:”
    and then stores that value as the bomb defusal code. When the second player (the
    defuser) presses *, the timer starts and waits for a code to be entered, and the
    yellow LED flashes in time to the countdown. If the code the defuser enters does
    not match the defusal code, the text “The Bomb Has Exploded!” displays on the
    screen and the LEDs and piezo indicate an explosion. If the defuser’s input is
    correct, the timer stops, the green LED lights, and the message “Bomb Defused”
    displays on the screen. The bomb will also explode if the timer reaches zero with
    no input. When the game ends, the code resets, ready for another game.
  prefs: []
  type: TYPE_NORMAL
- en: // Original code by Joey Meyer and Chase Cooley
  prefs: []
  type: TYPE_NORMAL
- en: // and used with kind permission
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Keypad.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <LiquidCrystal.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Tone.h>'
  prefs: []
  type: TYPE_NORMAL
- en: Tone tone1;
  prefs: []
  type: TYPE_NORMAL
- en: int Scount = 10; // Change this to the number of seconds to start from
  prefs: []
  type: TYPE_NORMAL
- en: int Mcount = 5;  // Change this to the number of minutes to start from
  prefs: []
  type: TYPE_NORMAL
- en: int Hcount = 0;  // Count hours
  prefs: []
  type: TYPE_NORMAL
- en: int DefuseTimer = 0; // Set timer to 0
  prefs: []
  type: TYPE_NORMAL
- en: long secMillis = 0; // Store last time for second add
  prefs: []
  type: TYPE_NORMAL
- en: long interval = 1000; // Interval for seconds
  prefs: []
  type: TYPE_NORMAL
- en: char password[4]; // Number of characters in password
  prefs: []
  type: TYPE_NORMAL
- en: int currentLength = 0; // Defines number currently writing
  prefs: []
  type: TYPE_NORMAL
- en: int i = 0;
  prefs: []
  type: TYPE_NORMAL
- en: char entered[4];
  prefs: []
  type: TYPE_NORMAL
- en: int ledPin = 4;  // Red LED
  prefs: []
  type: TYPE_NORMAL
- en: int ledPin2 = 3; // Yellow LED
  prefs: []
  type: TYPE_NORMAL
- en: int ledPin3 = 2; // Green LED
  prefs: []
  type: TYPE_NORMAL
- en: // The pins we use on the LCD
  prefs: []
  type: TYPE_NORMAL
- en: LiquidCrystal lcd(7, 8, 10, 11, 12, 13);
  prefs: []
  type: TYPE_NORMAL
- en: const byte ROWS = 4; // Four rows
  prefs: []
  type: TYPE_NORMAL
- en: const byte COLS = 3; // Three columns
  prefs: []
  type: TYPE_NORMAL
- en: char keys[ROWS][COLS] = {
  prefs: []
  type: TYPE_NORMAL
- en: '{''1'', ''2'', ''3''},'
  prefs: []
  type: TYPE_NORMAL
- en: '{''4'', ''5'', ''6''},'
  prefs: []
  type: TYPE_NORMAL
- en: '{''7'', ''8'', ''9''},'
  prefs: []
  type: TYPE_NORMAL
- en: '{''*'', ''0'', ''#''}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: byte rowPins[ROWS] = {5, A5, A4, A2}; // Connect to the row pinouts
  prefs: []
  type: TYPE_NORMAL
- en: // of the keypad
  prefs: []
  type: TYPE_NORMAL
- en: byte colPins[COLS] = {A1, A0, A3}; // Connect to the column pinouts
  prefs: []
  type: TYPE_NORMAL
- en: // of the keypad
  prefs: []
  type: TYPE_NORMAL
- en: Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(ledPin, OUTPUT);  // Sets the digital pin as output
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(ledPin2, OUTPUT); // Sets the digital pin as output
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(ledPin3, OUTPUT); // Sets the digital pin as output
  prefs: []
  type: TYPE_NORMAL
- en: tone1.begin(9);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.begin(16, 2);
  prefs: []
  type: TYPE_NORMAL
- en: Serial.begin(9600);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.clear();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(0,0);
  prefs: []
  type: TYPE_NORMAL
- en: 'lcd.print("Enter Code: ");'
  prefs: []
  type: TYPE_NORMAL
- en: while (currentLength < 4) {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(currentLength + 6, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.cursor();
  prefs: []
  type: TYPE_NORMAL
- en: char key = keypad.getKey();
  prefs: []
  type: TYPE_NORMAL
- en: key == NO_KEY;
  prefs: []
  type: TYPE_NORMAL
- en: if (key != NO_KEY) {
  prefs: []
  type: TYPE_NORMAL
- en: if ((key != '*')&&(key != '#')) {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(key);
  prefs: []
  type: TYPE_NORMAL
- en: password[currentLength] = key;
  prefs: []
  type: TYPE_NORMAL
- en: currentLength++;
  prefs: []
  type: TYPE_NORMAL
- en: tone1.play(NOTE_C6, 200);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (currentLength == 4) {
  prefs: []
  type: TYPE_NORMAL
- en: delay(500);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.noCursor();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.clear();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.home();
  prefs: []
  type: TYPE_NORMAL
- en: 'lcd.print("You''ve Entered: ");'
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(6, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(password[0]);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(password[1]);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(password[2]);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(password[3]);
  prefs: []
  type: TYPE_NORMAL
- en: tone1.play(NOTE_E6, 200);
  prefs: []
  type: TYPE_NORMAL
- en: delay(3000);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.clear();
  prefs: []
  type: TYPE_NORMAL
- en: currentLength = 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: timer();
  prefs: []
  type: TYPE_NORMAL
- en: char key2 = keypad.getKey(); // Get the key
  prefs: []
  type: TYPE_NORMAL
- en: if (key2 == '*') {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.clear();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(0, 0);
  prefs: []
  type: TYPE_NORMAL
- en: 'lcd.print("Code: ");'
  prefs: []
  type: TYPE_NORMAL
- en: while (currentLength < 4) {
  prefs: []
  type: TYPE_NORMAL
- en: timer();
  prefs: []
  type: TYPE_NORMAL
- en: char key2 = keypad.getKey();
  prefs: []
  type: TYPE_NORMAL
- en: if (key2 == '#') {
  prefs: []
  type: TYPE_NORMAL
- en: currentLength = 0;
  prefs: []
  type: TYPE_NORMAL
- en: lcd.clear();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(0, 0);
  prefs: []
  type: TYPE_NORMAL
- en: 'lcd.print("Code: ");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if (key2 != NO_KEY) {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(currentLength + 7, 0);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.cursor();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(key2);
  prefs: []
  type: TYPE_NORMAL
- en: entered[currentLength] = key2;
  prefs: []
  type: TYPE_NORMAL
- en: currentLength++;
  prefs: []
  type: TYPE_NORMAL
- en: tone1.play(NOTE_C6, 200);
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.noCursor();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(currentLength + 6, 0);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("*");
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(currentLength + 7, 0);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.cursor();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (currentLength == 4) {
  prefs: []
  type: TYPE_NORMAL
- en: if (entered[0] == password[0] && entered[1] == password[1] && entered[2] ==
    password[2] &&entered[3] == password[3]) {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.noCursor();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.clear();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.home();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("Bomb Defused");
  prefs: []
  type: TYPE_NORMAL
- en: currentLength = 0;
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(ledPin3, HIGH);
  prefs: []
  type: TYPE_NORMAL
- en: delay(2500);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(0, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("Reset the Bomb");
  prefs: []
  type: TYPE_NORMAL
- en: delay(1000000);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.noCursor();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.clear();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.home();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("Wrong Password!");
  prefs: []
  type: TYPE_NORMAL
- en: if (Hcount > 0) {
  prefs: []
  type: TYPE_NORMAL
- en: Hcount = Hcount - 1;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (Mcount > 0) {
  prefs: []
  type: TYPE_NORMAL
- en: Mcount = Mcount - 59;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (Scount > 0) {
  prefs: []
  type: TYPE_NORMAL
- en: Scount = Scount - 59;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: delay(1500);
  prefs: []
  type: TYPE_NORMAL
- en: currentLength = 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void timer() {
  prefs: []
  type: TYPE_NORMAL
- en: Serial.print(Scount);
  prefs: []
  type: TYPE_NORMAL
- en: Serial.println();
  prefs: []
  type: TYPE_NORMAL
- en: if (Hcount <= 0) { // If timer reaches 0, LCD displays explosion
  prefs: []
  type: TYPE_NORMAL
- en: if ( Mcount < 0 ) {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.noCursor();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.clear();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.home();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("The Bomb Has ");
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(0, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("Exploded!");
  prefs: []
  type: TYPE_NORMAL
- en: while (Mcount < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(ledPin, HIGH); // Sets the LED on
  prefs: []
  type: TYPE_NORMAL
- en: tone1.play(NOTE_A2, 90);
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(ledPin, LOW); // Sets the LED off
  prefs: []
  type: TYPE_NORMAL
- en: tone1.play(NOTE_A2, 90);
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(ledPin2, HIGH); // Sets the LED on
  prefs: []
  type: TYPE_NORMAL
- en: tone1.play(NOTE_A2, 90);
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(ledPin2, LOW); // Sets the LED off
  prefs: []
  type: TYPE_NORMAL
- en: tone1.play(NOTE_A2, 90);
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(ledPin3, HIGH); // Sets the LED on
  prefs: []
  type: TYPE_NORMAL
- en: tone1.play(NOTE_A2, 90);
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(ledPin3, LOW); // Sets the LED off
  prefs: []
  type: TYPE_NORMAL
- en: tone1.play(NOTE_A2, 90);
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(0, 1); // Sets cursor to 2nd line
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("Timer:");
  prefs: []
  type: TYPE_NORMAL
- en: if (Hcount >= 10) {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(7, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(Hcount);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (Hcount < 10) {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(7, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.write("0");
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(8, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(Hcount);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(":");
  prefs: []
  type: TYPE_NORMAL
- en: if (Mcount >= 10) {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(10, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(Mcount);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (Mcount < 10) {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(10, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.write("0");
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(11, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(Mcount);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print (":");
  prefs: []
  type: TYPE_NORMAL
- en: if (Scount >= 10) {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(13, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(Scount);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (Scount < 10) {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(13, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.write("0");
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(14, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(Scount);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (Hcount < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: Hcount = 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (Mcount < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: Hcount --;
  prefs: []
  type: TYPE_NORMAL
- en: Mcount = 59;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (Scount < 1) { // If 60 do this operation
  prefs: []
  type: TYPE_NORMAL
- en: Mcount --; // Add 1 to Mcount
  prefs: []
  type: TYPE_NORMAL
- en: Scount = 59; // Reset Scount
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (Scount > 0) { // Do this operation 59 times
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long currentMillis = millis();
  prefs: []
  type: TYPE_NORMAL
- en: if (currentMillis - secMillis > interval) {
  prefs: []
  type: TYPE_NORMAL
- en: tone1.play(NOTE_G5, 200);
  prefs: []
  type: TYPE_NORMAL
- en: secMillis = currentMillis;
  prefs: []
  type: TYPE_NORMAL
- en: Scount --; // Add 1 to Scount
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(ledPin2, HIGH); // Sets the LED on
  prefs: []
  type: TYPE_NORMAL
- en: delay(10); // Waits for a second
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(ledPin2, LOW); // Sets the LED off
  prefs: []
  type: TYPE_NORMAL
- en: delay(10); // Waits for a second
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *Nothing is displayed on the LCD screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure you’ve connected power to the breadboard rails and the connections
    match the tables in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: • Turn the potentiometer to change the contrast of the screen until you see
    text.
  prefs: []
  type: TYPE_NORMAL
- en: • If the screen has garbled messages on it, you haven’t wired it up correctly;
    recheck your wiring against the circuit diagram in [Figure 15-4](ch15.xhtml#ch15fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** *The LEDs do not light when expected.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Check your wiring against the circuit diagram in [Figure 15-4](ch15.xhtml#ch15fig4)
    and ensure that the short leg of the LED is connected to the ground rail of the
    breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: • It’s easy to forget to add power to the breadboard rails, so make sure you
    connect the ground and power rails on either side of the breadboard to the Arduino
    with a jumper wire.
  prefs: []
  type: TYPE_NORMAL
- en: • Check that your LEDs and resistors are firmly inserted into the breadboard
    and they line up with one another.
  prefs: []
  type: TYPE_NORMAL
- en: • If the wrong LED lights up, you’ve probably connected to the wrong pin numbers
    by mistake, so just change them around.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** *The piezo sounder does not make a noise.*'
  prefs: []
  type: TYPE_NORMAL
- en: • The positive red wire of the sounder should be connected to pin 9 and the
    black ground wire to GND. If the sounder does still not make a noise, try replacing
    it with another one.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** *When the keypad is pressed, the numbers are incorrect or do not register.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure the connections of the keypad to the Arduino match the circuit diagram
    in [Figure 15-4](ch15.xhtml#ch15fig4) exactly.
  prefs: []
  type: TYPE_NORMAL
- en: • The configuration is set up specifically for this project’s 3×4 numeric keypad,
    so if your keypad is different, check the data sheet to find out which pins you
    need to connect.
  prefs: []
  type: TYPE_NORMAL
- en: '**16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serial LCD Screen**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll take a 16×2 character LCD screen and a serial module to
    create a serial LCD that’s controlled by only two wires.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0134-01.jpg)![Image](../images/p0135-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Female-to-male jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HD44780 16×2 LCD screen**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serial LCD screen module**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARIES REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wire**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LiquidCrystal_I2C**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LCD screens are very useful in projects, but they use up a lot of pins on the
    Arduino. This means that if you’re incorporating them into a more complex project,
    you might run out of pins. Thankfully there is a solution: use a *serial* LCD
    screen. Serial LCDs use the communication protocol *I2C*, which stands for *Inter-Integrated
    Circuit*, and differ from normal 16×2 LCD screens in that they can be controlled
    by your Arduino with only power and two pins.'
  prefs: []
  type: TYPE_NORMAL
- en: Serial LCD screens usually come in kit form and require you to solder header
    pins, which I’ll cover later in the chapter. You’ll usually receive the 16×2 LCD
    screen and the serial module separately, as shown in [Figure 16-1](ch16.xhtml#ch16fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 16-1:** 16×2 LCD screen and serial module'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f16-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PREPARING THE SERIAL LCD SCREEN**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The serial module has a strip of 16 header pins already attached to one side.
    Turn the LCD screen over and you’ll see 16 corresponding holes, as shown in [Figure
    16-2](ch16.xhtml#ch16fig2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 16-2:** The reverse side of the LCD screen'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f16-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Place the serial controller header pins into those holes, as shown in [Figure
    16-3](ch16.xhtml#ch16fig3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 16-3:** Insert the serial module into the LCD screen holes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f16-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Carefully add a small amount of solder to each of the pins to make a connection
    and hold the serial monitor to the screen. Turn to the primer for a quick soldering
    guide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your serial LCD screen has an assigned address that your Arduino needs in order
    to communicate with it. The addresses differ depending on the make, so you need
    to check the address of your specific screen, as you’ll need it for the sketch
    later. To check the address, connect the LCD screen to your Arduino and run a
    quick sketch to scan the module—or you could also refer to the data sheet for
    your screen.
  prefs: []
  type: TYPE_NORMAL
- en: Connect your female-to-male jumper wires to the four pins on the controller
    for the LCD screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wire up the serial LCD screen to the Arduino with GND to GND, VCC to +5V, SDA
    to Arduino pin A4, and SCL to Arduino pin A5, as shown in the following table
    and the circuit diagram in [Figure 16-4](ch16.xhtml#ch16fig4).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **SERIAL LCD SCREEN** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| SDA | Pin A4 (SDA) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| SCL | Pin A5 (SCL) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**FIGURE 16-4:** The circuit diagram for the serial LCD screen'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f16-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Upload the following sketch to the Arduino. We’ll get the address in *hexadecimal*,
    a number system that uses letters and numbers in an abbreviated form to represent
    a much larger number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '#include <Wire.h>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void setup() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wire.begin();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.begin(9600);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.println("I2C Scanner");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void loop() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: byte error, address;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: int nDevices;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.println("Scanning...");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nDevices = 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for (address = 1; address < 127; address++)  {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wire.beginTransmission(address);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: error = Wire.endTransmission();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (error == 0) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print("I2C device found at address 0x");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (address < 16)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print("0");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print(address, HEX);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.println(" !");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nDevices++;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: else if (error == 4) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print("Unknown error at address 0x");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (address < 16)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.print("0");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.println(address, HEX);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (nDevices == 0)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.println("No I2C devices found\n");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: else
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serial.println("done\n");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: delay(5000); // Wait 5 seconds for next scan
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The sketch scans for all addresses on the Arduino’s I2C bus and displays the
    output in the Serial Monitor, as shown in [Figure 16-5](ch16.xhtml#ch16fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 16-5:** The hexadecimal number of your module will be shown in the
    IDE Serial Monitor.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f16-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The address is the number that comes after the 0x. In my case that is 27, so
    I need to make a note of 0x27\. You’ll use this address in the final sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This sketch calls on the Wire and LiquidCrystal_I2C libraries. The Wire library
    is included in the Arduino IDE, but you will need to install the LiquidCrystal_I2C
    library by downloading it from *[https://www.nostarch.com/arduinohandbook2/](https://www.nostarch.com/arduinohandbook2/)*.
    The libraries allow the Arduino to control the module using serial communication
    via just the SDA and SCL pins.
  prefs: []
  type: TYPE_NORMAL
- en: Change the code at ➊ so that the `0x27` is replaced with the address you just
    noted from your scan in the test sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Wire.h> // Call the wire library'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <LiquidCrystal_I2C.h> // Call the I2C library'
  prefs: []
  type: TYPE_NORMAL
- en: LiquidCrystal_I2C lcd(0x27➊,16,2); // Set LCD address to 0x27 for a
  prefs: []
  type: TYPE_NORMAL
- en: // 16-character and 2-line display
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: lcd.begin(); // Initialize the lcd
  prefs: []
  type: TYPE_NORMAL
- en: lcd.backlight();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("Arduino Handbook"); // Print a message to the LCD
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() { // Loop around again
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: There is a potentiometer built into the module to control the contrast of the
    LCD screen, shown in [Figure 16-6](ch16.xhtml#ch16fig6). Turn this carefully with
    a small screwdriver until the contrast on the screen looks right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 16-6:** The small blue box on the back of the module is a potentiometer
    to control the contrast.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f16-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but nothing shows on the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Double-check that the SDA and SCL pins are connected to the correct Arduino
    pins. If the LCD screen is lit but shows no characters, carefully turn the small
    potentiometer at the back of the module until the letters appear.
  prefs: []
  type: TYPE_NORMAL
- en: • If the screen still shows nothing and all the connections are correct, it
    may be that the solder on the header pins is not making a clean connection or
    you have soldered more than one pin together. Heat the area again with your soldering
    iron to melt the solder, and then use a solder sucker to remove any excess and
    resolder the header pins.
  prefs: []
  type: TYPE_NORMAL
- en: '**17'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ultrasonic People Counter**
  prefs: []
  type: TYPE_NORMAL
- en: This project teaches you how to use the HC-SR04 ultrasonic sensor to sense when
    people pass and then show that count on a serial LCD screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0141-01.jpg)![Image](../images/p0142-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mini-breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires, male-to-male and female-to-male**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serial LCD screen module**'
  prefs: []
  type: TYPE_NORMAL
- en: '**220-ohm resistor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HC-SR04 ultrasonic sensor**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARIES REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**NewPing**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wire**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LiquidCrystal_I2C**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: People counters are often used in shops or tourist attractions to count the
    number of visitors, but you could also use one to record the volume of traffic
    on a highway or in a parking lot, or to count how many times someone entered your
    room while you were out!
  prefs: []
  type: TYPE_NORMAL
- en: The ultrasonic sensor we’ll use is the HC-SR04, shown in [Figure 17-1](ch17.xhtml#ch17fig1),
    which you first saw in Project 13\. It uses an ultrasonic signal, or *ping*, to
    calculate the distance between the sensor and an object. In this project we’ll
    use this function to count every time someone or something passes in front of
    the sensor. An LED will flash when a count is registered, and the serial LCD screen
    will show the total number counted.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 17-1:** The HC-SR04 ultrasonic sensor uses a ping to calculate distances.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f17-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the female-to-male jumper wires to connect the HC-SR04 ultrasonic sensor
    to the Arduino with the VCC pin to Arduino +5V, GND to GND, and Trig and Echo
    to pins 7 and 8 on the Arduino, respectively, as shown in the following table
    and in [Figure 17-2](ch17.xhtml#ch17fig2). Use the mini-breadboard for multiple
    connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **ULTRASONIC SENSOR** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Trig | Pin 7 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Echo | Pin 8 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**FIGURE 17-2:** The connections from the ultrasonic sensor'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f17-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Make sure to download the LiquidCrystal I2C and NewPing libraries and add them
    to the relevant folder on your computer (see the primer for guidance). The Wire
    library comes with the Arduino IDE, so you do not need to add it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the serial LCD screen to the Arduino as follows, using the mini-breadboard
    to connect to +5V.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **SERIAL LCD SCREEN** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| SDA | Pin A4 (SDA) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| SCL | Pin A5 (SCL) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Insert the LED into the mini-breadboard so that the shorter, negative (GND)
    leg is to the left and the longer, positive (+5V) leg is to the right, as shown
    in the following table and in [Figure 17-3](ch17.xhtml#ch17fig3). Connect the
    220-ohm resistor to the positive leg of the LED, making sure the other leg of
    the resistor straddles the break in the breadboard. Connect this other resistor
    leg to pin 13 on the Arduino. Connect the shorter leg of the LED to GND on the
    Arduino.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **LED** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| +5V | Pin 13 via 220-ohm resistor |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '**FIGURE 17-3:** We use the mini-breadboard to hold the LED and for multiple
    connections to the Arduino +5V.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f17-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Make sure your final circuit looks like [Figure 17-4](ch17.xhtml#ch17fig4),
    and then upload the code in “[The Sketch](ch17.xhtml#ch00lev1sec72)” on [page
    146](ch17.xhtml#page_146) to the Arduino.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 17-4:** The circuit diagram for the ultrasonic people counter'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f17-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch begins by calling on the LiquidCrystal I2C, NewPing, and Wire libraries
    to control the serial LCD screen and ultrasonic sensor. Next it defines the ultrasonic
    sensor Trig and Echo pins as Arduino pins 7 and 8, respectively. We set the maximum
    distance for the sensor to read to 200 centimeters (any reading beyond 200 centimeters
    is ignored). Then we define pin 13 on the Arduino as the LED, which will be our
    counting indicator, and create variables to hold the distance and number of people.
    We create a `count` state so the Arduino can determine a valid record, and then
    we define the type of LCD screen. We initiate the LCD screen so that `People:`
    is printed to the screen, and set the LED pin as an output.
  prefs: []
  type: TYPE_NORMAL
- en: The loop section sends a ping from the sensor and if the ping that’s returned
    is from a distance of more than 100 centimeters, the space in front of the sensor
    is considered empty and nothing is registered. If the distance recorded is less
    than 100 centimeters, it means something is within range in front of the sensor.
    In order for the `people:` variable to increment, someone has to move in front
    of the sensor, then out of the way. The sensor will keep counting every time a
    valid register is received, and the latest total is shown on the LCD screen.
  prefs: []
  type: TYPE_NORMAL
- en: The sensor could be placed to one side of an entrance, facing across the threshold,
    so as someone enters the sensor picks it up and registers a count. If the sensor
    is pointing toward a wall that’s less than 100 centimeters away, you’ll need to
    change the following line of code to a distance less than the distance to the
    wall; otherwise, the sensor will record a count every time the wall is detected.
  prefs: []
  type: TYPE_NORMAL
- en: if (distance < 100 && distance != 0 && !count)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full code:'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <LiquidCrystal_I2C.h> // Call on the libraries'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <NewPing.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Wire.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#define TRIGGER_PIN 7  // Ultrasonic sensor trig to Arduino pin 7'
  prefs: []
  type: TYPE_NORMAL
- en: '#define ECHO_PIN 8     // Ultrasonic sensor echo to Arduino pin 8'
  prefs: []
  type: TYPE_NORMAL
- en: '#define MAX_DISTANCE 200'
  prefs: []
  type: TYPE_NORMAL
- en: NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE);
  prefs: []
  type: TYPE_NORMAL
- en: int LEDPin = 13; // Set LED to pin 13
  prefs: []
  type: TYPE_NORMAL
- en: int distance; // Variable for distance
  prefs: []
  type: TYPE_NORMAL
- en: int people = 0; // Variable for number of people
  prefs: []
  type: TYPE_NORMAL
- en: boolean count = false; // State for counting
  prefs: []
  type: TYPE_NORMAL
- en: LiquidCrystal_I2C lcd(0x27, 16, 2);
  prefs: []
  type: TYPE_NORMAL
- en: void setup() { // Run once to set up the LCD screen and LED
  prefs: []
  type: TYPE_NORMAL
- en: lcd.begin();
  prefs: []
  type: TYPE_NORMAL
- en: lcd.backlight();
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(LEDPin, OUTPUT); // Set the LED as an output
  prefs: []
  type: TYPE_NORMAL
- en: 'lcd.print("People:"); // Print People: to the LCD screen'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() { // This loops forever to check for number of people
  prefs: []
  type: TYPE_NORMAL
- en: delay(50);
  prefs: []
  type: TYPE_NORMAL
- en: distance = sonar.ping_cm(); // Ping every 50 milliseconds
  prefs: []
  type: TYPE_NORMAL
- en: // If more than 100 cm away, don't count
  prefs: []
  type: TYPE_NORMAL
- en: if (distance > 100 && count) {
  prefs: []
  type: TYPE_NORMAL
- en: count = false;
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(LEDPin, LOW);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // If less than 100 cm away, count 1
  prefs: []
  type: TYPE_NORMAL
- en: if (distance < 100 && distance != 0 && !count) {
  prefs: []
  type: TYPE_NORMAL
- en: count = true;
  prefs: []
  type: TYPE_NORMAL
- en: people ++; // Keep adding 1 per count
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(LEDPin, HIGH);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(10, 0);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(people); // Print number of people to LCD screen
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The code compiles, but nothing shows on the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Double-check that the SDA and SCL pins are connected to the correct Arduino
    pins.
  prefs: []
  type: TYPE_NORMAL
- en: • If the LCD screen is lit up but nothing shows, carefully turn the small potentiometer
    at the back of the module to change the contrast until the letters appear.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** *The sensor does not register a count or the LED does not light when
    expected.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure that the ultrasonic sensor trigger pin is connected to Arduino pin
    7 and the Echo pin to Arduino pin 8, and that power is connected to GND and +5V.
  prefs: []
  type: TYPE_NORMAL
- en: • If a count is registered and the LED does not light, recheck that the short
    leg of the LED is connected to GND and the long leg to +5V. The resistor should
    straddle the break in the breadboard and be connected to the LED’s long leg on
    one side and Arduino pin 13 on the other.
  prefs: []
  type: TYPE_NORMAL
- en: • Remember that the positioning of the sensor is important. If the distance
    to a fixed object (like a wall) is less than the distance in the sketch, the count
    will be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: '• Your device may have a different address than the one we’ve used here. To
    check the address of your device, use the I2C scanner sketch available on the
    Arduino website (*[http://playground.arduino.cc/Main/I2cScanner](http://playground.arduino.cc/Main/I2cScanner)*).
    Run the sketch with your device attached to the Arduino and open the IDE Serial
    Monitor, and you should see the address of your device. Update the following line
    in this sketch with the address shown:'
  prefs: []
  type: TYPE_NORMAL
- en: LiquidCrystal_I2C lcd(0x27,16,2);
  prefs: []
  type: TYPE_NORMAL
- en: '**18'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nokia 5110 LCD Screen Pong Game**
  prefs: []
  type: TYPE_NORMAL
- en: This project shows you how to connect a Nokia 5110 LCD screen to your Arduino
    to recreate a *Pong*-style arcade game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0149-01.jpg)![Image](../images/p0150-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breadboard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nokia 5110 LCD screen**'
  prefs: []
  type: TYPE_NORMAL
- en: '**4 10k-ohm resistors**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 1k-ohm resistors**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 50k-ohm potentiometers**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nokia 5110 LCD screens were used for all Nokia phones a few years back, so you
    should find plenty available online. We’ll wire one up to the Arduino and create
    a simple *Pong*-style game by adding some potentiometers as controllers.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*See Project 13 for instructions on soldering header pins, and see the primer
    for general soldering instructions if you haven’t soldered before.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The screen is 84×48 pixels, which, with spaces between the characters so they
    aren’t touching, gives us a 12×6-character screen. The screen works in the same
    way as the LCD screen in Project 13: by sending current through the liquid crystal
    from the Arduino to make certain pixels opaque and form letters or images.'
  prefs: []
  type: TYPE_NORMAL
- en: Most screens come with the header pins separate for ease of transport, so you
    may need to solder them in place if you want to plug the screen into a breadboard.
    You’ll need to solder a strip of eight header pins into the row of holes on one
    side of the screen, as you can see in [Figure 18-1](ch18.xhtml#ch18fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 18-1:** The reverse of the Nokia 5110 LCD screen showing the pin connections'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f18-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This project connects to +3.3V on the Arduino, rather than +5V.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Insert the Nokia 5110 screen into the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Nokia screen has eight pins. Insert a 10k-ohm resistor for Nokia pins 1,
    3, 4, and 5, making sure they straddle the center break. Insert a 1k-ohm resistor
    for Nokia pins 2 and 7, as shown in [Figure 18-2](ch18.xhtml#ch18fig2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 18-2:** Insert the resistors for the Nokia LCD screen as shown here.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f18-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**WARNING**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*It’s really important to use the +3.3V power from the Arduino for the Nokia
    5110 screen and not +5V for this project; otherwise, you will damage the screen.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use jumper wires to make the connections from the Nokia screen to Arduino pins
    3–7 and to the breadboard power rails. Make sure to add the right value resistor
    to the correct pin, as shown in the following table. Some breakout boards may
    have the pins in different locations, so match the pin names on the Nokia screen
    with the Arduino pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **NOKIA 5110 SCREEN** | **RESISTOR** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 RESET | 10k-ohm | Pin 6 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 2 CE | 1k-ohm | Pin 7 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 3 DC | 10k-ohm | Pin 5 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 4 DIN | 10k-ohm | Pin 4 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 5 CLK | 10k-ohm | Pin 3 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 6 VCC | None | +3.3V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 7 Light | 1k-ohm | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 8 GND | None | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Insert the potentiometers into the breadboard as shown in [Figure 18-3](ch18.xhtml#ch18fig3).
    Connect the center pin of one potentiometer to Arduino A0 and the center pin of
    the other potentiometer to Arduino A1\. Connect an outer pin of each potentiometer
    to the +5V rail of the breadboard and the other outer pins to the GND rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the power rails of the breadboard to +5V and GND on the Arduino (this
    is for the potentiometers only).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that your setup matches [Figure 18-3](ch18.xhtml#ch18fig3), and upload
    the code in “[The Sketch](ch18.xhtml#ch00lev1sec76)” below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 18-3:** The circuit diagram for the Nokia 5110 LCD Screen *Pong* Game'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f18-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The game starts with two bars on opposite sides of the screen and a ball bouncing
    between them. The object of the game is to use the potentiometers to move the
    bars like paddles, hitting the ball back and forth to stop it from going out of
    the play (beyond the screen perimeter). The ball bounces off the bars and gradually
    gets faster and faster. The game is over when the ball goes beyond the screen
    limit, at which point the display will invert and the game will start over again.
    Note that the ball can appear quite faint the faster it moves, due to the limitation
    of the screen graphics.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the sketch defines the pins connected to the Nokia 5110 LCD
    screen. It then defines the size of the screen, which is the area of our game
    that counts as in-play, and the size and starting positions of the bars and ball.
    The potentiometers read the analog signal from Arduino pins A0 and A1 and move
    their corresponding bars onscreen depending on how they’re twisted. The calculations
    that follow determine whether the ball and the bar have met at certain coordinates.
    If they have, the ball bounces back; if they haven’t, it means the bar has missed
    the ball, so the screen inverts and flashes to indicate the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: // Arduino Pong by Onur Avun and reproduced with kind permission
  prefs: []
  type: TYPE_NORMAL
- en: '#define PIN_SCE   7'
  prefs: []
  type: TYPE_NORMAL
- en: '#define PIN_RESET 6'
  prefs: []
  type: TYPE_NORMAL
- en: '#define PIN_DC    5'
  prefs: []
  type: TYPE_NORMAL
- en: '#define PIN_SDIN  4'
  prefs: []
  type: TYPE_NORMAL
- en: '#define PIN_SCLK  3'
  prefs: []
  type: TYPE_NORMAL
- en: '#define LCD_C     LOW'
  prefs: []
  type: TYPE_NORMAL
- en: '#define LCD_D     HIGH'
  prefs: []
  type: TYPE_NORMAL
- en: '#define LCD_X     84'
  prefs: []
  type: TYPE_NORMAL
- en: '#define LCD_Y     6'
  prefs: []
  type: TYPE_NORMAL
- en: int barWidth = 16;
  prefs: []
  type: TYPE_NORMAL
- en: int barHeight = 4;
  prefs: []
  type: TYPE_NORMAL
- en: int ballPerimeter = 4;
  prefs: []
  type: TYPE_NORMAL
- en: unsigned int bar1X = 0;
  prefs: []
  type: TYPE_NORMAL
- en: unsigned int bar1Y = 0;
  prefs: []
  type: TYPE_NORMAL
- en: unsigned int bar2X = 0;
  prefs: []
  type: TYPE_NORMAL
- en: unsigned int bar2Y = LCD_Y * 8 - barHeight;
  prefs: []
  type: TYPE_NORMAL
- en: int ballX = 0;
  prefs: []
  type: TYPE_NORMAL
- en: int ballY = 0;
  prefs: []
  type: TYPE_NORMAL
- en: boolean isBallUp = false;
  prefs: []
  type: TYPE_NORMAL
- en: boolean isBallRight = true;
  prefs: []
  type: TYPE_NORMAL
- en: byte pixels[LCD_X][LCD_Y];
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long lastRefreshTime;
  prefs: []
  type: TYPE_NORMAL
- en: const int refreshInterval = 150;
  prefs: []
  type: TYPE_NORMAL
- en: byte gameState = 1;
  prefs: []
  type: TYPE_NORMAL
- en: byte ballSpeed = 2;
  prefs: []
  type: TYPE_NORMAL
- en: byte player1WinCount = 0;
  prefs: []
  type: TYPE_NORMAL
- en: byte player2WinCount = 0;
  prefs: []
  type: TYPE_NORMAL
- en: byte hitCount = 0;
  prefs: []
  type: TYPE_NORMAL
- en: void setup() {
  prefs: []
  type: TYPE_NORMAL
- en: LcdInitialise();
  prefs: []
  type: TYPE_NORMAL
- en: restartGame();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() {
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long now = millis();
  prefs: []
  type: TYPE_NORMAL
- en: if (now - lastRefreshTime > refreshInterval) {
  prefs: []
  type: TYPE_NORMAL
- en: update();
  prefs: []
  type: TYPE_NORMAL
- en: refreshScreen();
  prefs: []
  type: TYPE_NORMAL
- en: lastRefreshTime = now;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void restartGame() {
  prefs: []
  type: TYPE_NORMAL
- en: ballSpeed = 1;
  prefs: []
  type: TYPE_NORMAL
- en: gameState = 1;
  prefs: []
  type: TYPE_NORMAL
- en: ballX = random(0, 60);
  prefs: []
  type: TYPE_NORMAL
- en: ballY = 20;
  prefs: []
  type: TYPE_NORMAL
- en: isBallUp = false;
  prefs: []
  type: TYPE_NORMAL
- en: isBallRight = true;
  prefs: []
  type: TYPE_NORMAL
- en: hitCount = 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void refreshScreen() {
  prefs: []
  type: TYPE_NORMAL
- en: if (gameState == 1) {
  prefs: []
  type: TYPE_NORMAL
- en: for (int y = 0; y < LCD_Y; y++) {
  prefs: []
  type: TYPE_NORMAL
- en: for (int x = 0; x < LCD_X; x++) {
  prefs: []
  type: TYPE_NORMAL
- en: byte pixel = 0x00;
  prefs: []
  type: TYPE_NORMAL
- en: int realY = y * 8;
  prefs: []
  type: TYPE_NORMAL
- en: // Draw ball if in frame
  prefs: []
  type: TYPE_NORMAL
- en: if (x >= ballX && x <= ballX + ballPerimeter -1 && ballY +
  prefs: []
  type: TYPE_NORMAL
- en: ballPerimeter > realY && ballY < realY + 8 ) {
  prefs: []
  type: TYPE_NORMAL
- en: byte ballMask = 0x00;
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < realY + 8 - ballY; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: ballMask = ballMask >> 1;
  prefs: []
  type: TYPE_NORMAL
- en: if (i < ballPerimeter)
  prefs: []
  type: TYPE_NORMAL
- en: ballMask = 0x80 | ballMask;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: pixel = pixel | ballMask;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Draw bars if in frame
  prefs: []
  type: TYPE_NORMAL
- en: if (x >= bar1X && x <= bar1X + barWidth -1 && bar1Y +
  prefs: []
  type: TYPE_NORMAL
- en: barHeight > realY && bar1Y < realY + 8 ) {
  prefs: []
  type: TYPE_NORMAL
- en: byte barMask = 0x00;
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < realY + 8 - bar1Y; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: barMask = barMask >> 1;
  prefs: []
  type: TYPE_NORMAL
- en: if (i < barHeight)
  prefs: []
  type: TYPE_NORMAL
- en: barMask = 0x80 | barMask;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: pixel = pixel | barMask;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (x >= bar2X && x <= bar2X + barWidth -1 && bar2Y +
  prefs: []
  type: TYPE_NORMAL
- en: barHeight > realY && bar2Y < realY + 8 ) {
  prefs: []
  type: TYPE_NORMAL
- en: byte barMask = 0x00;
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = 0; i < realY + 8 - bar2Y; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: barMask = barMask >> 1;
  prefs: []
  type: TYPE_NORMAL
- en: if (i < barHeight)
  prefs: []
  type: TYPE_NORMAL
- en: barMask = 0x80 | barMask;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: pixel = pixel | barMask;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_D, pixel);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (gameState == 2) {'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void update() {
  prefs: []
  type: TYPE_NORMAL
- en: if (gameState == 1) {
  prefs: []
  type: TYPE_NORMAL
- en: int barMargin = LCD_X - barWidth;
  prefs: []
  type: TYPE_NORMAL
- en: int pot1 = analogRead(A0); // Read pots and set bar positions
  prefs: []
  type: TYPE_NORMAL
- en: int pot2 = analogRead(A1);
  prefs: []
  type: TYPE_NORMAL
- en: bar1X = pot1 / 2 * LCD_X / 512;
  prefs: []
  type: TYPE_NORMAL
- en: bar2X = pot2 / 2 * LCD_X / 512;
  prefs: []
  type: TYPE_NORMAL
- en: if (bar1X > barMargin) bar1X = barMargin;
  prefs: []
  type: TYPE_NORMAL
- en: if (bar2X > barMargin) bar2X = barMargin;
  prefs: []
  type: TYPE_NORMAL
- en: // Move the ball now
  prefs: []
  type: TYPE_NORMAL
- en: if (isBallUp)
  prefs: []
  type: TYPE_NORMAL
- en: ballY -= ballSpeed;
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: ballY += ballSpeed;
  prefs: []
  type: TYPE_NORMAL
- en: if (isBallRight)
  prefs: []
  type: TYPE_NORMAL
- en: ballX += ballSpeed;
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: ballX -= ballSpeed;
  prefs: []
  type: TYPE_NORMAL
- en: // Check collisions
  prefs: []
  type: TYPE_NORMAL
- en: if (ballX < 1) {
  prefs: []
  type: TYPE_NORMAL
- en: isBallRight = true;
  prefs: []
  type: TYPE_NORMAL
- en: ballX = 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if (ballX > LCD_X - ballPerimeter - 1) {
  prefs: []
  type: TYPE_NORMAL
- en: isBallRight = false;
  prefs: []
  type: TYPE_NORMAL
- en: ballX = LCD_X - ballPerimeter;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (ballY < barHeight) {
  prefs: []
  type: TYPE_NORMAL
- en: if (ballX + ballPerimeter >= bar1X && ballX <= bar1X + barWidth) {
  prefs: []
  type: TYPE_NORMAL
- en: // Ball bounces from bar1
  prefs: []
  type: TYPE_NORMAL
- en: isBallUp = false;
  prefs: []
  type: TYPE_NORMAL
- en: if (ballX + ballPerimeter / 2 < bar1X + barWidth / 2)
  prefs: []
  type: TYPE_NORMAL
- en: isBallRight = false;
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: isBallRight = true;
  prefs: []
  type: TYPE_NORMAL
- en: ballY = barHeight;
  prefs: []
  type: TYPE_NORMAL
- en: if (++hitCount % 10 == 0 && ballSpeed < 5)
  prefs: []
  type: TYPE_NORMAL
- en: ballSpeed++;
  prefs: []
  type: TYPE_NORMAL
- en: '} else { // Player 2 wins'
  prefs: []
  type: TYPE_NORMAL
- en: gameState = 2;
  prefs: []
  type: TYPE_NORMAL
- en: player2WinCount++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (ballY + ballPerimeter > LCD_Y * 8 - barHeight) {
  prefs: []
  type: TYPE_NORMAL
- en: if (ballX + ballPerimeter >= bar2X && ballX <= bar2X + barWidth) {
  prefs: []
  type: TYPE_NORMAL
- en: // Ball bounces from bar2
  prefs: []
  type: TYPE_NORMAL
- en: isBallUp = true;
  prefs: []
  type: TYPE_NORMAL
- en: if (ballX + ballPerimeter / 2 < bar2X + barWidth / 2)
  prefs: []
  type: TYPE_NORMAL
- en: isBallRight = false;
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: isBallRight = true;
  prefs: []
  type: TYPE_NORMAL
- en: ballY = LCD_Y * 8 - barHeight - ballPerimeter;
  prefs: []
  type: TYPE_NORMAL
- en: if (++hitCount % 10 == 0 && ballSpeed < 5)
  prefs: []
  type: TYPE_NORMAL
- en: ballSpeed++;
  prefs: []
  type: TYPE_NORMAL
- en: '} else { // Player 1 wins'
  prefs: []
  type: TYPE_NORMAL
- en: gameState = 2;
  prefs: []
  type: TYPE_NORMAL
- en: player1WinCount++;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (gameState == 2) {'
  prefs: []
  type: TYPE_NORMAL
- en: for (int i =0; i < 4; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_C, 0x0D); // LCD in inverse mode.
  prefs: []
  type: TYPE_NORMAL
- en: delay(300);
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_C, 0x0C); // LCD in inverse mode.
  prefs: []
  type: TYPE_NORMAL
- en: delay(300);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: restartGame();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void LcdInitialise(void) {
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(PIN_SCE, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(PIN_RESET, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(PIN_DC, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(PIN_SDIN, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: pinMode(PIN_SCLK, OUTPUT);
  prefs: []
  type: TYPE_NORMAL
- en: delay(200);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(PIN_RESET, LOW);
  prefs: []
  type: TYPE_NORMAL
- en: delay(500);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(PIN_RESET, HIGH);
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_C, 0x21 );  // LCD Extended Commands
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_C, 0xB1 );  // Set LCD Vop (Contrast)
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_C, 0x04 );  // Set Temp coefficent. //0x04
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_C, 0x14 );  // LCD bias mode 1:48\. //0x13
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_C, 0x0C );  // LCD in normal mode.
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_C, 0x20 );
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_C, 0x80 );  // Select X Address 0 of the LCD ram
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_C, 0x40 );  // Select Y Address 0 of the LCD ram
  prefs: []
  type: TYPE_NORMAL
- en: LcdWrite(LCD_C, 0x0C );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void LcdWrite(byte dc, byte data) {
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(PIN_DC, dc);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(PIN_SCE, LOW);
  prefs: []
  type: TYPE_NORMAL
- en: shiftOut(PIN_SDIN, PIN_SCLK, MSBFIRST, data);
  prefs: []
  type: TYPE_NORMAL
- en: digitalWrite(PIN_SCE, HIGH);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *Nothing is displayed on the LCD screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure you’ve connected power to the LCD screen direct to the Arduino +3.3V
    power pin and the connections match the tables in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure your resistors line up with the correct LCD pins, as well as the
    wires to the Arduino pins.
  prefs: []
  type: TYPE_NORMAL
- en: • If the backlight of the LCD screen is lit but there is no image, you may have
    some wires mixed up; they need to match the circuit in [Figure 18-3](ch18.xhtml#ch18fig3)
    exactly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q.** *When the player turns the potentiometer, one or both of the bars do
    not move.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure the potentiometers are connected firmly in the breadboard and that
    the wires connecting to the power rails and Arduino line up with the potentiometer
    pins.
  prefs: []
  type: TYPE_NORMAL
- en: • Remember that the potentiometers require +5V power and GND from the Arduino.
    These pins should be hooked up to the breadboard power rails via jumper wires.
  prefs: []
  type: TYPE_NORMAL
- en: • Make sure you also use jumper wires to connect the corresponding power rails
    on either side of the breadboard to each other.
  prefs: []
  type: TYPE_NORMAL
- en: '**19'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OLED Breathalyzer**
  prefs: []
  type: TYPE_NORMAL
- en: In this project we’ll use the MQ3 alcohol sensor and an OLED LCD screen to make
    a mini-breathalyzer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0159-01.jpg)![Image](../images/p0160-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**PARTS REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arduino board**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Female-to-male jumper wires**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Keyes MQ3 alcohol sensor module**'
  prefs: []
  type: TYPE_NORMAL
- en: '**OLED monochrome screen (128×64)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LIBRARIES REQUIRED**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SPI**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wire**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adafruit_GFX**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adafruit_SSD1306**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WORKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MQ3 is part of a family of gas sensors that also includes the MQ2, sensitive
    to methane, butane, and smoke; the MQ4, sensitive to compressed natural gas; the
    MQ6, sensitive to butane and LPG gas; and the MQ7, sensitive to carbon monoxide.
    The MQ3 is sensitive to alcohol and ethanol, so it’s the one we’ll use in our
    breathalyzer.
  prefs: []
  type: TYPE_NORMAL
- en: '**DISCLAIMER**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This project is for amusement only and should not be used to accurately determine
    anyone’s alcohol intake.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Keyes MQ3 module ([Figure 19-1](ch19.xhtml#ch19fig1)) has the wiring we
    need for this project, including a built-in potentiometer and resistor. The three
    pin connections on the module are OUT, VCC, and GND.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 19-1:** The Keyes MQ3 alcohol sensor module. As with most MQ sensors,
    the module has a small heater inside with an electrochemical sensor used to measure
    the gas level. The value of the reading is sent to the OUT pin, which is then
    read by an analog pin on our Arduino.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f19-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To display the sensor readings, we’ll use an OLED screen ([Figure 19-2](ch19.xhtml#ch19fig2)).
    OLED, which stands for *organic light-emitting diode*, is a light-emitting technology
    composed of a thin, multilayered organic film placed between an anode and cathode.
    When voltage is applied, an image is created through *electroluminescence*, which
    means the screen does not require a backlight. Our OLED screen is an I2C 128×64
    monochrome version, meaning we can control it using only two pins to the Arduino
    and it measures 128 pixels by 64 pixels. This screen uses the same communication
    protocol as our serial LCD in Project 16 and is explained further there.
  prefs: []
  type: TYPE_NORMAL
- en: '**FIGURE 19-2:** 128×64 OLED monochrome screen. When the MQ3 reads the value,
    the Arduino sends a message to the OLED screen indicating whether or not alcohol
    has been detected.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f19-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As mentioned earlier, the MQ3 uses an internal heater as part of the sensor
    process. This heater can reach 120–140 degrees when powered, so take care when
    handling it when it’s in use.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**THE BUILD**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you use the sensor for the first time, you need to “burn it in.” This
    process, which simply involves powering it up for a few hours to heat the mechanism
    inside, improves the sensor’s accuracy. To do this, connect the VCC and GND pins
    of the sensor to +5V and GND on your Arduino, respectively, using female-to-male
    jumper wires. When you power the Arduino, it will send the correct voltage to
    the MQ3\. Leave it powered for two to three hours—you may notice a burning smell
    and the sensor will get hot, but this is normal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the sensor is burned in, disconnect the power to the Arduino and connect
    the sensor to the Arduino using the female-to-male jumper wires, with the MQ3’s
    OUT pin connected to Arduino pin A0, and the power and GND still connected as
    before (see the following table).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **MQ3 ALCOHOL SENSOR** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| OUT | Pin A0 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +5V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Next, connect the OLED screen to the Arduino as shown in the following table,
    with SCL connected to pin A5, SDA to pin A4, VCC to +3.3V, and GND to GND.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **OLED SCREEN** | **ARDUINO** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| SCL | Pin A5 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| SDA | Pin A4 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| VCC | +3.3V |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| GND | GND |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: This project requires a number of libraries to work correctly; the SPI and Wire
    libraries are built into the Arduino IDE, but we also need the Adafruit_GFX and
    Adafruit_SSD1306 libraries to control the OLED screen. Both are available from
    *[https://www.nostarch.com/arduinohandbook2/](https://www.nostarch.com/arduinohandbook2/)*.
    Refer to the primer if you need a reminder on how to add libraries to the IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that your setup matches the circuit diagram in [Figure 19-3](ch19.xhtml#ch19fig3),
    and upload the code in “[The Sketch](ch19.xhtml#ch00lev1sec80)” below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**FIGURE 19-3:** The circuit diagram for the OLED breathalyzer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image](../images/f19-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The heater inside the MQ3 sensor needs to heat up for about 4 minutes before
    it can operate accurately. The sketch has a timer so that when you power it up
    for the first time, the values won’t appear onscreen until the required time has
    passed. The “Warming up” text will display with a small countdown bar until the
    sensor is ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**THE SKETCH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sketch starts by calling on the SPI, Wire, Adafruit_GFX, and Adafruit_SSD1306
    libraries to control communication and the OLED screen. We assign a time for the
    warm-up session (4 minutes) and set the analog pin as Arduino A0.
  prefs: []
  type: TYPE_NORMAL
- en: Next we set up the OLED screen. The Arduino sends different messages to the
    screen depending on the value read from the analog pin. For instance, if the sensor
    reading is above 200, the Arduino will ask you if you’ve had a beer. If the reading
    is below this value, the Arduino will say you’re sober. The minimum level of alcohol
    the MQ3 will read is about 180\. For anything over 450, the breathalyzer will
    let you know you’re drunk!
  prefs: []
  type: TYPE_NORMAL
- en: The sketch loops every second to read the analog sensor. To use the breathalyzer,
    wait for the sensor to heat up for 4 minutes, then gently breathe onto the sensor.
    Try not to get the sensor wet or expose it to a smoky environment, as this will
    affect the reading.
  prefs: []
  type: TYPE_NORMAL
- en: // Re-created with kind permission from Nick Koumaris educ8s.tv
  prefs: []
  type: TYPE_NORMAL
- en: // Call the SPI, Wire, Adafruit_GFX, and Adafruit_SDD1306 libraries
  prefs: []
  type: TYPE_NORMAL
- en: '#include <SPI.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Wire.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Adafruit_GFX.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <Adafruit_SSD1306.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#define OLED_RESET 4 // Define the OLED screen'
  prefs: []
  type: TYPE_NORMAL
- en: int TIME_UNTIL_WARMUP = 4; // Time for the warm-up delay in minutes
  prefs: []
  type: TYPE_NORMAL
- en: unsigned long time;
  prefs: []
  type: TYPE_NORMAL
- en: int analogPin = 0; // Set analog pin as A0
  prefs: []
  type: TYPE_NORMAL
- en: int val = 0; // Set a value to read from the analog pin
  prefs: []
  type: TYPE_NORMAL
- en: Adafruit_SSD1306 display(OLED_RESET);
  prefs: []
  type: TYPE_NORMAL
- en: void setup() { // Set up the OLED screen
  prefs: []
  type: TYPE_NORMAL
- en: display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  prefs: []
  type: TYPE_NORMAL
- en: display.clearDisplay();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void loop() { // Take the reading and show it onscreen
  prefs: []
  type: TYPE_NORMAL
- en: delay(100);
  prefs: []
  type: TYPE_NORMAL
- en: val = readAlcohol();
  prefs: []
  type: TYPE_NORMAL
- en: printTitle();
  prefs: []
  type: TYPE_NORMAL
- en: printWarming();
  prefs: []
  type: TYPE_NORMAL
- en: time = millis() / 1000;
  prefs: []
  type: TYPE_NORMAL
- en: time /= 60;
  prefs: []
  type: TYPE_NORMAL
- en: if (time <= TIME_UNTIL_WARMUP) { // If warm-up is less than 4 mins
  prefs: []
  type: TYPE_NORMAL
- en: time = map(time, 0, TIME_UNTIL_WARMUP, 0, 100); // Show countdown
  prefs: []
  type: TYPE_NORMAL
- en: display.drawRect(10, 50, 110, 10, WHITE); // Empty bar
  prefs: []
  type: TYPE_NORMAL
- en: display.fillRect(10, 50, time, 10, WHITE);
  prefs: []
  type: TYPE_NORMAL
- en: '} else { // When warm-up time has passed'
  prefs: []
  type: TYPE_NORMAL
- en: // the value and message are printed on the screen
  prefs: []
  type: TYPE_NORMAL
- en: printTitle();
  prefs: []
  type: TYPE_NORMAL
- en: printAlcohol(val);
  prefs: []
  type: TYPE_NORMAL
- en: printAlcoholLevel(val);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: display.display();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void printTitle() { // Position and text of title on the screen
  prefs: []
  type: TYPE_NORMAL
- en: display.clearDisplay();
  prefs: []
  type: TYPE_NORMAL
- en: display.setTextSize(1);
  prefs: []
  type: TYPE_NORMAL
- en: display.setTextColor(WHITE);
  prefs: []
  type: TYPE_NORMAL
- en: display.setCursor(22, 0);
  prefs: []
  type: TYPE_NORMAL
- en: display.println("Breath Analyzer");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void printWarming() { // Warm-up message
  prefs: []
  type: TYPE_NORMAL
- en: display.setTextSize(1);
  prefs: []
  type: TYPE_NORMAL
- en: display.setTextColor(WHITE);
  prefs: []
  type: TYPE_NORMAL
- en: display.setCursor(30, 24);
  prefs: []
  type: TYPE_NORMAL
- en: display.println("Warming up");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void printAlcohol(int value) { // Print alcohol value to screen
  prefs: []
  type: TYPE_NORMAL
- en: display.setTextSize(2);
  prefs: []
  type: TYPE_NORMAL
- en: display.setTextColor(WHITE);
  prefs: []
  type: TYPE_NORMAL
- en: display.setCursor(50, 10);
  prefs: []
  type: TYPE_NORMAL
- en: display.println(val);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void printAlcoholLevel(int value) { // Print message to screen
  prefs: []
  type: TYPE_NORMAL
- en: display.setTextSize(1);
  prefs: []
  type: TYPE_NORMAL
- en: display.setTextColor(WHITE);
  prefs: []
  type: TYPE_NORMAL
- en: display.setCursor(20, 25);
  prefs: []
  type: TYPE_NORMAL
- en: if (value < 200) { // If value read is less than 200, you are sober
  prefs: []
  type: TYPE_NORMAL
- en: display.println("You are sober...");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (value >= 200 && value < 280) {
  prefs: []
  type: TYPE_NORMAL
- en: display.println("You had a beer?");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (value >= 280 && value < 350) {
  prefs: []
  type: TYPE_NORMAL
- en: display.println("Two or more beers.");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (value >= 350 && value < 450) {
  prefs: []
  type: TYPE_NORMAL
- en: display.println("I smell VODKA!");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if (value > 450) {
  prefs: []
  type: TYPE_NORMAL
- en: display.println("You are drunk!");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // Finds average by summing three readings and
  prefs: []
  type: TYPE_NORMAL
- en: // dividing by 3 for better accuracy
  prefs: []
  type: TYPE_NORMAL
- en: int readAlcohol() {
  prefs: []
  type: TYPE_NORMAL
- en: int val = 0;
  prefs: []
  type: TYPE_NORMAL
- en: int val1;
  prefs: []
  type: TYPE_NORMAL
- en: int val2;
  prefs: []
  type: TYPE_NORMAL
- en: int val3;
  prefs: []
  type: TYPE_NORMAL
- en: display.clearDisplay();
  prefs: []
  type: TYPE_NORMAL
- en: val1 = analogRead(analogPin);
  prefs: []
  type: TYPE_NORMAL
- en: delay(10);
  prefs: []
  type: TYPE_NORMAL
- en: val2 = analogRead(analogPin);
  prefs: []
  type: TYPE_NORMAL
- en: delay(10);
  prefs: []
  type: TYPE_NORMAL
- en: val3 = analogRead(analogPin);
  prefs: []
  type: TYPE_NORMAL
- en: val = (val1 + val2 + val3) / 3;
  prefs: []
  type: TYPE_NORMAL
- en: return val;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**TROUBLESHOOTING**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Q.** *The display is not showing readings correctly.*'
  prefs: []
  type: TYPE_NORMAL
- en: • Recheck that your wiring matches the diagram in [Figure 19-3](ch19.xhtml#ch19fig3).
  prefs: []
  type: TYPE_NORMAL
- en: • If all your wiring is in the correct place, make sure you’ve carried out the
    earlier step to burn the sensor in by leaving it powered for a few hours.
  prefs: []
  type: TYPE_NORMAL
- en: • To check whether your components are faulty, temporarily swap a potentiometer
    in for the sensor. Connect the center pin of the potentiometer to A0 and add power
    to either side. If the potentiometer is working okay, it means your sensor is
    probably faulty, so replace your sensor—they are very inexpensive.
  prefs: []
  type: TYPE_NORMAL
