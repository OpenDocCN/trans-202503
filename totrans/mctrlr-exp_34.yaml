- en: '**I  Other Chips**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**I.1 PAL Truth Tables**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Programmable array logic (PAL) and generic array logic (GAL) devices were early
    technologies for programmable logic that predate CPLD and FPGA devices. Programming
    methods were often unique to the brand of the chip, while the pinout and functionality
    were compatible between vendors. These days, they are mostly dumped for retrocomputing
    emulation and repair projects.
  prefs: []
  type: TYPE_NORMAL
- en: DuPAL is an open suite of tools for PAL reverse engineering, available as Battaglia
    (2020). It consists of a hardware board with an Atmega chip for applying inputs
    and sampling outputs of a PAL chip, and GUI tools in Java that can export observations
    or test potential chip configurations.
  prefs: []
  type: TYPE_NORMAL
- en: DuPAL does not read the raw memory out of the chip, so it is limited to states
    that can be externally observed from inputs and outputs. This gets confusing when
    output values are fed back as inputs, sometimes with a delay for synchronous logic.
  prefs: []
  type: TYPE_NORMAL
- en: Surply (2015) describes the use of an Arduino Uno to dump the truth table of
    a PAL16L8 chip from a pinball machine. The truth tables were too large to reduce
    with Karnaugh mapping, but Surply was able to use the Quine-McCluskey method in
    the form of Niels Serup’s Electruth library for Python to minimize the PAL’s truth
    table in a few hours, revealing the address space of the machine’s many I/O ports.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0406-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure I.1: MMI PAL16R6B'
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to dump these chips visually. PALs mark truth table bits
    with electromigration fuses. These work by running too much current through a
    very thin metal trace, causing the metal to flow along the path of the current,
    which breaks the trace.
  prefs: []
  type: TYPE_NORMAL
- en: '**I.2 Mifare Classic Gate Recovery**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nohl et al. (2008) describes a successful reverse engineering of a then-secret
    cryptographic algorithm used by NXP’s Mifare Classic RFID tags. The chip, shown
    in [Figure I.2](app09.xhtml#chIfig2), is barely a millimeter square, available
    in 1K and 4K versions.
  prefs: []
  type: TYPE_NORMAL
- en: Nohl required both surface and delayered photographs for this recovery, then
    used edge detection and pattern matching to recognize the standard-cell library
    of the chip. Though there are many thousands of gates on the chip, there are only
    seventy or so unique logic cells. The gate tileset has been published as SRL (2012b).
  prefs: []
  type: TYPE_NORMAL
- en: Of the six chip layers, the upper ones obscured cell identification. These were
    removed by mechanical polishing rather than through chemical etching. Images were
    then stitched with Hugin, and as Degate had not yet been written, custom Matlab
    scripts were used to perform standard cell identification.
  prefs: []
  type: TYPE_NORMAL
- en: After the Mifare Classic was reverse engineered, Plötz and Nohl (2011) followed
    with details of reverse engineering the Legic Prime RFID tag. The authors dumped
    their custom Matlab scripts for Degate, and published their tile set as SRL (2012a).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0408-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure I.2: Mifare Classic'
  prefs: []
  type: TYPE_NORMAL
