- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**USING EXTRASENSORY PERCEPTION TO WARD OFF FOG OF WAR**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**利用超感知能力驱散战争迷雾**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: '*Fog of war* (often shortened to just *fog*) is a mechanism that game developers
    commonly use to limit a player’s situational awareness and hide information about
    the game environment. Fog is often a literal lack of sight in massive online battle
    arena (MOBA) games, but the concept also includes any lack or obscurity of pertinent
    gameplay information. Cloaked figures, dark rooms, and enemies hiding behind walls
    are all forms of fog.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*战争迷雾*（通常简称为*迷雾*）是一种游戏开发者常用的机制，用来限制玩家的环境感知并隐藏关于游戏环境的信息。迷雾在大型多人在线战术竞技游戏（MOBA）中通常表现为视觉上的缺失，但这个概念还包括任何相关的游戏信息缺失或模糊。隐形人物、黑暗房间和隐藏在墙后面的敌人都是迷雾的一种形式。'
- en: Game hackers can reduce or even completely remove fog using an *extrasensory
    perception (ESP)* hack. An ESP hack uses hooking, memory manipulation, or both
    to force a game to display hidden information. These hacks take advantage of the
    fact that some types of fog are often implemented on the client side, as opposed
    to the server side, meaning that the game clients still contain information (partial
    or complete) about what is being hidden.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏黑客可以使用*超感知能力（ESP）*黑客技术来减少或完全去除战争迷雾。ESP黑客通过钩取、内存操作或两者结合，强制游戏显示隐藏信息。这些黑客利用了这样的事实：某些类型的迷雾通常是在客户端实现的，而不是服务器端，这意味着游戏客户端仍然包含有关隐藏内容的部分或完整信息。
- en: In this chapter, you will learn how to implement different types of ESP hacks.
    First, you’ll learn to light up dark environments. Next, you’ll use x-ray vision
    to see through walls. Finally, you’ll learn about zoom hacking, tweaking heads-up
    displays, and other simple ESP hacks that can reveal all sorts of useful (but
    otherwise hidden) information about the game you’re playing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何实现不同类型的ESP黑客技术。首先，您将学习如何点亮黑暗环境。接下来，您将使用X光视觉透视墙壁。最后，您将了解缩放黑客技术、调整信息显示以及其他简单的ESP黑客，这些都可以揭示游戏中各种有用的（但通常隐藏的）信息。
- en: '**Background Knowledge**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**背景知识**'
- en: This chapter starts the transition from hacking, puppeteering, and reverse engineering
    to coding. From here on out, you’ll be learning how to actually code your own
    hacks. To keep on topic, everything I’ve talked about thus far will be treated
    as background knowledge. If you see a technique used that you don’t quite remember,
    such as memory scanning, setting memory breakpoints, hooking, or writing memory,
    flip back to the relevant chapters and study them a bit more before continuing.
    Throughout the text, you’ll find notes to remind you where you can brush up on
    certain topics.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始从黑客技术、操控和逆向工程转向编码。从现在开始，您将学习如何实际编写自己的黑客技术。为了保持话题一致，迄今为止我讨论的所有内容都将视为背景知识。如果您看到一个您不太记得的技术，例如内存扫描、设置内存断点、钩取或写入内存，请翻回相关章节，稍作复习再继续阅读。在整个文本中，您将看到一些提示，提醒您可以在哪些地方回顾某些话题。
- en: Specifically, this chapter will talk a lot about Direct3D. In “[Applying Jump
    Hooks and VF Hooks to Direct3D](ch08.xhtml#ch00lev1sec174)” on [page 175](ch08.xhtml#page_175),
    I explained how to hook into a game’s Direct3D drawing loop. The example code
    for that chapter includes a fully featured Direct3D hooking engine in *GameHackingExamples/Chapter8_Direct3DHook*.
    A lot of the hacks in this chapter build on that hook, and their example code
    can be found in the *main.cpp* file of the Direct3D hook code. You can run the
    compiled application from *GameHackingExamples/Chapter8_Direct3DApplication* to
    see the hacks in action on a test application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将大量讨论Direct3D。在《"[将Jump Hooks和VF Hooks应用于Direct3D](ch08.xhtml#ch00lev1sec174)"》的[第175页](ch08.xhtml#page_175)中，我解释了如何将钩子插入游戏的Direct3D绘图循环。该章节的示例代码包括一个功能齐全的Direct3D钩取引擎，位于*GameHackingExamples/Chapter8_Direct3DHook*。本章中的许多黑客技术都建立在这个钩子基础上，示例代码可以在Direct3D钩子代码的*main.cpp*文件中找到。您可以从*GameHackingExamples/Chapter8_Direct3DApplication*运行编译后的应用程序，在测试应用程序上看到黑客技术的实际效果。
- en: '**Revealing Hidden Details with Lighthacks**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过Lighthacks揭示隐藏细节**'
- en: '*Lighthacks* increase lighting in dark environments, allowing you to clearly
    see enemies, treasure chests, pathways, and anything else that is normally obscured
    by darkness. Lighting is often a cosmetic change that’s added at a game’s graphical
    layer, and it can usually be directly modified with a hook on the graphics layer.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lighthacks*增加了黑暗环境中的光照，使您可以清楚地看到敌人、宝箱、路径以及任何通常被黑暗掩盖的东西。光照通常是在游戏的图形层中添加的装饰性变化，通常可以通过图形层的钩子直接修改。'
- en: Optimal lighting depends on camera orientation, environment layout, and even
    specific traits of a game’s engine, and you can manipulate any of these factors
    to create lighthacks. But the easiest way is simply to add more light to a room.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳光照效果取决于相机的朝向、环境布局，甚至游戏引擎的具体特性，你可以操控这些因素来创建光照破解。然而，最简单的方法就是给房间添加更多的光源。
- en: '***Adding a Central Ambient Light Source***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***添加中央环境光源***'
- en: The online resources for this book include two small lighthack examples. The
    first is the `enableLightHackDirectional()` function in *main.cpp*, which is shown
    in [Listing 9-1](ch09.xhtml#ch9exe1).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的在线资源包括两个小型光照破解示例。第一个是 *main.cpp* 中的 `enableLightHackDirectional()` 函数，如 [清单
    9-1](ch09.xhtml#ch9exe1) 中所示。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: A directional lighthack*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-1：方向光照破解*'
- en: This code is called from the `EndScene()` hook, and it adds light to the scene
    by creating a light source called `light`. The code sets `light.Type` to directional,
    which means the light source will act like a spotlight and project light in a
    specific direction. The code then sets the red, green, and blue values of `light.Diffuse`
    to 0.5, 0.5, and 0.5, giving the light an off-white shine when reflected from
    a surface. Next, it sets `light.Direction` to an arbitrary point in the three-dimensional
    space. Finally, the code uses the game’s Direct3D device to set up the light at
    index 0 and enable lighting effects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从 `EndScene()` 钩子中调用，通过创建一个名为 `light` 的光源向场景添加光照。代码将 `light.Type` 设置为方向光，这意味着光源将像聚光灯一样投射光线到特定方向。然后，代码将
    `light.Diffuse` 的红、绿、蓝值分别设置为 0.5、0.5 和 0.5，使光源在从表面反射时呈现淡白色光泽。接下来，它将 `light.Direction`
    设置为三维空间中的一个任意点。最后，代码使用游戏的 Direct3D 设备在索引 0 处设置光源并启用光照效果。
- en: '**NOTE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the example application, the light shines up and to the right from the
    bottom left of the scene. You may need to change this location depending on how
    your target game is rendered.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*在示例应用程序中，光源从场景的左下角向上和向右照射。你可能需要根据目标游戏的渲染方式来改变这个位置。*'
- en: 'Note that inserting the light at index 0 works for this proof of concept, but
    it won’t always work. Games typically have multiple light sources defined, and
    setting your light at an index the game uses might override critical lighting
    effects. In practice, you might try setting the index to an arbitrarily high number.
    There’s an issue with this type of lighthack, though: directional lights will
    be blocked by objects such as walls, creatures, and terrain, meaning shadows can
    still be cast. Directional lights work great for wide-open spaces, but not so
    well for tightly wound corridors or underground caves.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在索引 0 处插入光源适用于这个概念验证，但并非始终有效。游戏通常定义了多个光源，设置光源的索引可能会覆盖游戏使用的关键光照效果。实际上，你可以尝试将索引设置为一个任意较高的数字。然而，这种光照破解方法存在一个问题：方向光会被墙壁、生物和地形等物体阻挡，这意味着阴影仍然会被投射。方向光在开阔空间中效果很好，但对于狭窄的走廊或地下洞穴效果不佳。
- en: '***Increasing the Absolute Ambient Light***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***增加绝对环境光***'
- en: 'The other lighthack method, seen in the `enableLightHackAmbient()` function,
    is far more aggressive than the one in [Listing 9-1](ch09.xhtml#ch9exe1). It affects
    the light level globally, rather than adding an extra light source. Here’s what
    the code looks like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种光照破解方法，如 `enableLightHackAmbient()` 函数中所见，比 [清单 9-1](ch09.xhtml#ch9exe1)
    中的更为激进。它会全球性地影响光照强度，而不是增加额外的光源。以下是代码的样子：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This lighthack sets the absolute ambient light (which you indicate by passing
    `D3DRS_AMBIENT` to the `SetRenderState()` function) to a medium-strength white.
    The `D3DCOLOR_XRGB` macro sets that strength, taking `100` as its parameters for
    the red, green, and blue levels. This lights up objects using an omnidirectional
    white light, effectively revealing everything at the cost of shadows and other
    lighting-based details.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个光照破解方法将绝对环境光（通过将 `D3DRS_AMBIENT` 传递给 `SetRenderState()` 函数来指示）设置为中等强度的白色。`D3DCOLOR_XRGB`
    宏设置了该强度，以 `100` 作为红、绿、蓝级别的参数。这会使用全向白光照亮物体，从而有效地揭示所有物体，但会失去阴影和其他基于光照的细节。
- en: '***Creating Other Types of Lighthacks***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建其他类型的光照破解***'
- en: There are many other ways to create lighthacks, but they differ from game to
    game. One creative way to affect the light in a game is to NOP the code that the
    game uses to call the `device->SetRenderState()` function. Since this function
    is used to set up the global ambient light strength, disabling calls to it leaves
    Direct3D at the default light settings and makes everything visible. This is perhaps
    the most powerful type of lighthack, but it requires your bot to know the address
    of the lighting code to NOP.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建光照作弊的方法有很多，但它们因游戏而异。一种创造性的方法是禁用游戏调用`device->SetRenderState()`函数的代码。由于此函数用于设置全局环境光强度，禁用对它的调用会使Direct3D保持默认的光照设置，从而使一切都变得可见。这也许是最强大的光照作弊方法，但它要求你的机器人知道光照代码的地址才能禁用它。
- en: There are also memory-based lighthacks. In some games, players and creatures
    emit light of different colors and strengths, often depending on attributes like
    their equipment, mount, or active spells. If you understand the structure of the
    game’s creature list, you can directly modify the values that determine a creature’s
    light level.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还有基于内存的光照作弊。在一些游戏中，玩家和生物会根据其装备、坐骑或活跃的法术发出不同颜色和强度的光。若你了解游戏生物列表的结构，就可以直接修改决定生物光照强度的值。
- en: For instance, imagine a game in which characters emit a bluish ball of light
    when under a healing or strengthening spell. Somewhere in the game’s memory are
    values associated with each creature that tell the game the color and intensity
    of light the creature should emit. If you can locate these values in memory, you
    can change them so that the creatures effectively emit orbs of light. This type
    of lighthack is commonly used in games with a 2D top-down style, since the orbs
    around individual creatures produce a cool artistic effect while shedding light
    on important parts of the screen. In 3D games, however, this sort of hack just
    turns creatures into blobs of light that run around.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设在某个游戏中，角色在施加治疗或强化法术时会发出一团蓝色的光球。在游戏的内存中，存在与每个生物相关的值，这些值告诉游戏该生物应该发出什么颜色和强度的光。如果你能在内存中找到这些值，你就可以改变它们，使生物有效地发出光球。这种类型的光照作弊通常用于2D俯视风格的游戏，因为围绕个别生物的光球产生了一种很酷的艺术效果，同时还可以照亮屏幕上的重要部分。然而，在3D游戏中，这种作弊方法只会将生物变成四处跑动的光团。
- en: You can also hook the `SetLight()` member function at index 51 in the VF table
    of the game’s Direct3D device. Then, whenever your hook callback is invoked, you
    can modify the properties of the intercepted `D3DLIGHT9` light structure before
    passing it to the original function. You might, for instance, change all lights
    to the `D3DLIGHT_POINT` type, causing any existing light sources in the game to
    radiate light in every direction like a light bulb. This type of lighthack is
    very powerful and accurate, but it can produce some disturbing visuals. It also
    tends to break in any environment that has no lighting, and opaque obstacles still
    block point light sources.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在游戏的Direct3D设备的VF表中挂钩`SetLight()`成员函数的第51个索引。然后，每当调用你的挂钩回调时，你可以在将其传递给原始函数之前修改拦截到的`D3DLIGHT9`光照结构的属性。例如，你可以将所有光源更改为`D3DLIGHT_POINT`类型，导致游戏中的任何现有光源像灯泡一样四面八方地发光。这种类型的光照作弊非常强大且精确，但它可能会产生一些令人不安的视觉效果。而且，它通常在没有光照的环境中失效，且不透明的障碍物仍然会阻挡点光源。
- en: Lighthacks are very powerful, but they don’t reveal anything. If information
    is hidden behind an obstacle, rather than by darkness, you’ll need a wallhack
    to reveal it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 光照作弊非常强大，但它不会揭示任何内容。如果信息被障碍物而不是黑暗所隐藏，你将需要使用透视墙壁作弊来揭示它。
- en: '**Revealing Sneaky Enemies with Wallhacks**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**用透视墙壁作弊揭示狡猾的敌人**'
- en: You can use *wallhacks* to show enemies that are hidden by walls, floors, and
    other obstacles. There are a few ways to create these hacks, but the most common
    method takes advantage of a type of rendering known as *z-buffering*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*透视墙壁作弊*来显示被墙壁、地板和其他障碍物隐藏的敌人。创建这些作弊的方法有几种，但最常见的方法是利用一种叫做*z-buffering*的渲染技术。
- en: '***Rendering with Z-Buffering***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Z-Buffering渲染***'
- en: 'Most graphics engines, including Direct3D, support z-buffering, which is a
    way to make sure that when there are overlapping objects in a scene, only the
    top object is drawn. Z-buffering works by “drawing” the scene to a two-dimensional
    array that describes how close the object at each pixel on the screen is to the
    viewer. Think of the array’s indices as axes: they correspond to the x-axis (right
    and left) and y-axis (up and down) for each pixel on the screen. Each value stored
    in the array is the z-axis value for a pixel.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数图形引擎，包括Direct3D，都支持z缓冲，它是一种确保在场景中有重叠物体时，只绘制最上面物体的方式。z缓冲通过将场景“绘制”到一个二维数组来工作，这个数组描述了屏幕上每个像素的物体离观察者的远近。可以将数组的索引看作是坐标轴：它们对应于屏幕上每个像素的x轴（左右）和y轴（上下）。数组中存储的每个值都是某个像素的z轴值。
- en: When a new object appears, whether it is actually drawn on the screen is decided
    by the z-buffer array. If the spot at the object’s x- and y-position is already
    filled in the array, that means there’s another object at that pixel on the screen.
    The new object will appear only if it has a lower z-axis value (that is, if it’s
    closer to the viewer) than the pixel already there. When the scene is finished
    being drawn to the array, it is flushed to the screen.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新物体出现时，它是否真的绘制到屏幕上由z缓冲数组决定。如果物体的x和y位置在数组中已经被填充，那就意味着屏幕上的那个像素位置已有其他物体。如果新物体的z轴值更低（也就是离观察者更近），它才会出现在这个位置。当场景绘制完成后，数组会被刷新到屏幕上。
- en: To illustrate this, imagine a three-dimensional space that needs to be drawn
    to a two-dimensional canvas by some game with 4×4-pixel viewport. The z-buffer
    for this scenario would look like [Figure 9-1](ch09.xhtml#ch9fig1).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，假设一个三维空间需要通过某个游戏绘制到一个4×4像素的二维视口上。这个场景的z缓冲看起来会像[图9-1](ch09.xhtml#ch9fig1)。
- en: '![image](../images/f09-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f09-01.jpg)'
- en: '*Figure 9-1: An empty z-buffer*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：空的z缓冲*'
- en: To start, the game draws a blue background that completely fills the viewport
    and is located as far away on the z-axis as possible; let’s say the highest z-value
    is 100\. Next, the game draws a 2×2-pixel red rectangle at position (0,0) with
    a z-position of 5\. Finally, the game draws a 2×2-pixel green rectangle at position
    (1,1) with a z-position of 3\. The z-buffer would now look like [Figure 9-2](ch09.xhtml#ch9fig2).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，游戏绘制一个完全填充视口的蓝色背景，并将其放置在z轴上尽可能远的位置；假设最高的z值是100。接着，游戏在位置(0,0)绘制一个2×2像素的红色矩形，z位置为5。最后，游戏在位置(1,1)绘制一个2×2像素的绿色矩形，z位置为3。此时，z缓冲看起来像[图9-2](ch09.xhtml#ch9fig2)。
- en: '![image](../images/f09-02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f09-02.jpg)'
- en: '*Figure 9-2: A filled z-buffer*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：填充后的z缓冲*'
- en: The z-buffer neatly handled overlapping objects based on their z-positions.
    The green square that’s closest on the z-axis overlaps the red square that’s a
    bit farther away, and both squares overlap the blue background, which is very
    far away.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: z缓冲根据物体的z位置巧妙地处理了重叠物体。离z轴最近的绿色方块会覆盖离它稍远的红色方块，而两个方块又会覆盖远离屏幕的蓝色背景。
- en: This behavior allows a game to draw its map, players, creatures, details, and
    particles without worrying about what is actually visible to the player. This
    is a huge optimization for game developers, but it exposes a large area of attack.
    Since all game models are *always* given to the graphics engine, you can use hooks
    to detect objects that the player can’t actually see.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为允许游戏在不需要担心玩家实际看到什么的情况下绘制地图、玩家、怪物、细节和粒子。这对于游戏开发者来说是一个巨大的优化，但也暴露了一个巨大的攻击面。由于所有游戏模型*总是*被提供给图形引擎，你可以使用钩子来检测玩家看不见的物体。
- en: '***Creating a Direct3D Wallhack***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建一个Direct3D墙hack***'
- en: You can create wallhacks that manipulate z-buffering in Direct3D using a hook
    on the `DrawIndexedPrimitive()` function, which is called when a game draws a
    3D model to the screen. When an enemy player model is drawn, a wallhack of this
    type disables z-buffering, calls the original function to draw the model, and
    then reenables z-buffering. This causes the enemy model to be drawn on top of
    everything else in the scene, regardless of what’s in front of it. Some wallhacks
    can also render specific models in a solid color, such as red for enemies and
    green for allies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`DrawIndexedPrimitive()`函数上设置钩子来创建操控z缓冲的透视墙hack，这个函数在游戏绘制3D模型到屏幕时会被调用。当敌方玩家模型被绘制时，这种类型的墙hack会禁用z缓冲，调用原始函数绘制模型，然后重新启用z缓冲。这样，敌方模型就会被绘制在场景中的所有其他物体之上，不管它前面有什么。某些墙hack还可以将特定模型以纯色显示，比如敌人用红色，盟友用绿色。
- en: '**Toggling Z-Buffering**'
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**切换Z缓冲区**'
- en: 'The Direct3D hook in *main.cpp* from *GameHackingExamples/Chapter8_ Direct3DHook*
    has this example wallhack in the `onDrawIndexedPrimitive()` function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 来自*GameHackingExamples/Chapter8_ Direct3DHook*的*main.cpp*中的Direct3D钩子有这个例子透视墙，位于`onDrawIndexedPrimitive()`函数中：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function is used as a callback for a hook on `DrawIndexedPrimitive()` at
    VF index 82 of the game’s Direct3D device. Every model the game draws passes through
    this function, accompanied by some model-specific properties. By inspecting a
    subset of the properties, namely the `numVertices` and `primCount` values, the
    hook detects when an enemy model is drawn and commences the wallhack. In this
    example, the values representing an enemy model are `24` and `12`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数作为对`DrawIndexedPrimitive()`的钩子回调函数，位于游戏的Direct3D设备的VF索引82处。游戏绘制的每个模型都会经过这个函数，并伴随一些模型特有的属性。通过检查其中一部分属性，特别是`numVertices`和`primCount`值，钩子能够检测到何时绘制一个敌人模型，并启动透视墙。在这个例子中，表示敌人模型的值是`24`和`12`。
- en: 'The magic happens inside the `if()` statement. Using just a few lines of code,
    the wallhack draws the model in a way that ignores z-buffering, like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法发生在`if()`语句内部。只需要几行代码，透视墙就能以忽略z缓冲区的方式绘制模型，如下所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Simply put, this code disables z-buffering when drawing the enemy model and
    reenables it afterward. With z-buffering off, the enemy is drawn in front of everything.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这段代码在绘制敌人模型时禁用z缓冲区，并在绘制后重新启用它。禁用z缓冲区后，敌人会绘制在所有其他物体前面。
- en: '**Changing an Enemy Texture**'
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更改敌人的纹理**'
- en: 'When a model is rendered onscreen, a *texture* is used to skin the model. Textures
    are 2D images that are stretched around 3D models to apply the colors and patterns
    that make up the model’s 3D artwork. To change the way an enemy looks when it’s
    drawn in your wallhack, you can set it to be drawn with a different texture, as
    in this example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模型在屏幕上渲染时，*纹理*被用来为模型贴图。纹理是二维图像，拉伸并包裹在三维模型上，用以应用构成模型三维艺术作品的颜色和图案。要改变敌人在你的透视墙（wallhack）中显示的方式，你可以将其设置为使用不同的纹理，就像这个例子一样：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first block of this code loads the texture from a file and is executed only
    once—when the hook is initialized. The full example code does this in an `initialize()`
    function, which gets called the first time the `EndScene()` hook callback is invoked.
    The second block of this code happens right before the call to the original `DrawIndexedPrimitive()`
    function in the wallhack, and it causes the model to be drawn with the custom
    texture.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第一个块加载纹理文件，并且只会执行一次——当钩子被初始化时。完整的示例代码在`initialize()`函数中执行此操作，这个函数在第一次调用`EndScene()`钩子回调时被调用。第二个代码块发生在调用原始`DrawIndexedPrimitive()`函数之前，它使模型使用自定义纹理绘制。
- en: '***Fingerprinting the Model You Want to Reveal***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指纹识别你想要显示的模型***'
- en: The trickiest part to creating a good wallhack is finding the right values for
    `numVertices` and `primCount`. To do this, you can create a tool that logs every
    unique combination of the two variables and allows you to iterate over the list
    using your keyboard. Working example code for this tool won’t be useful in the
    example application provided with this chapter, but I’ll give you some high-level
    implementation details.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个好的透视墙的最棘手部分是找到正确的`numVertices`和`primCount`值。为了做到这一点，你可以创建一个工具，记录所有这两个变量的唯一组合，并允许你使用键盘在列表中遍历。这个工具的工作示例代码在本章提供的示例应用中可能并不有用，但我会给你一些高层的实现细节。
- en: 'First, in the global scope, you’d declare a structure that has members to store
    the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在全局作用域中，你需要声明一个结构体，它包含成员用于存储以下内容：
- en: • `numVertices` and `primCount`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: • `numVertices`和`primCount`
- en: • A `std::set` of this structure (let’s call it `seenParams`)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个此结构的`std::set`（我们称之为`seenParams`）
- en: • An instance of that structure (let’s call it `currentParams`)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个该结构的实例（我们称之为`currentParams`）
- en: The `std::set` requires a comparator for this structure, so you’d also declare
    a comparison functor that calls `memcmp()` to compare two of the structures using
    `memcmp()`. Each time the `DrawIndexedPrimitive()` callback is invoked, your hack
    could create a structure instance with the intercepted values and pass it to a
    `seenParams.insert()` function, which should insert the parameter pair into the
    list only if the pair isn’t already there.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::set`需要一个比较器来比较该结构，因此你还需要声明一个比较函数对象，使用`memcmp()`来比较两个结构体。每当调用`DrawIndexedPrimitive()`回调时，你的透视墙可以创建一个结构实例，并传递到`seenParams.insert()`函数中，该函数只有在该参数对不在列表中时才会插入它。'
- en: 'Using the `GetAsyncKeyState()` Windows API function, you could then detect
    when the spacebar is pressed and execute something similar to this pseudocode:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GetAsyncKeyState()` Windows API 函数，你可以检测空格键是否被按下，并执行类似以下伪代码的操作：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This would set `currentParams` to the next pair in `seenParams` when the spacebar
    is pressed. With this code in place, you could use code similar to a wallhack
    to change the texture of models matching `currentParams.numVertices` and `currentParams.primCount`.
    The tool could also draw those values on the screen so you could see them and
    write them down.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当按下空格键时，`currentParams` 会被设置为 `seenParams` 中的下一个对。通过这段代码，你可以使用类似于壁hack的代码，改变与
    `currentParams.numVertices` 和 `currentParams.primCount` 匹配的模型的纹理。工具还可以将这些值绘制在屏幕上，以便你看到它们并将其记录下来。
- en: With a tool like this, finding the proper models is as easy as starting up a
    game in a mode where your character won’t die (against a friend, in a customization
    mode, and so on), running the bot, and pressing the spacebar until each model
    you need is highlighted. Once you have the values for your target models, you’ll
    modify the `numVertices` and `primCount` check in your wallhack so it knows which
    models to highlight.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像这样的工具，找到合适的模型就像在一个角色不会死亡的模式下启动游戏（与朋友对战、在自定义模式下等），运行机器人，然后按空格键直到每个需要的模型被高亮显示。一旦你得到了目标模型的数值，就可以修改你的壁hack中的
    `numVertices` 和 `primCount` 检查，让它知道需要高亮显示哪些模型。
- en: '**NOTE**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Character models are commonly made up of smaller models for individual body
    segments, and games often show different models of a character at different distances.
    That means a game may have 20 or more models for one type of character. Even in
    that case, selecting only one model (say, the enemy’s torso) to show in your wallhack
    may be enough.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*角色模型通常由多个较小的模型组成，用于显示身体各个部位，而且游戏通常会在不同的距离显示同一角色的不同模型。这意味着一个游戏可能会为一种类型的角色有20个或更多的模型。即便如此，选择仅一个模型（比如敌人的躯干）在壁hack中显示，可能就足够了。*'
- en: '**Getting a Wider Field of Vision with Zoomhacks**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Zoomhacks获得更广的视野**'
- en: Many games in the MOBA and real-time strategy (RTS) genres use a 3D top-down
    style that makes them immune to wallhacks. They also use darkness on the map as
    a type of fog, but showing the dark areas using a lighthack doesn’t give any extra
    information; models hidden inside the fog are known only to the game server, not
    to the client.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 许多MOBA和即时战略（RTS）类型的游戏使用3D俯视风格，使它们免受壁hack的影响。它们还使用地图上的黑暗区域作为一种迷雾，但使用光hack显示黑暗区域并不会提供任何额外的信息；迷雾中的模型只有游戏服务器知道，而客户端无法看到。
- en: 'This style makes most types of ESP hacks useless: there’s little unknown information
    to reveal, so these hacks only augment your view of the information you can already
    see. One type of ESP hack, however, can still be helpful. *Zoomhacks* let you
    zoom out much farther than a game normally allows, effectively revealing large
    portions of the map that you couldn’t see otherwise—and thus getting around the
    game’s wallhack and lighthack immunity.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格使得大多数类型的ESP作弊无效：几乎没有未知信息可以揭示，因此这些作弊只会增强你已经能看到的信息。然则，有一种类型的ESP作弊仍然有帮助。*Zoomhacks*
    让你可以将视野缩小到游戏通常允许的范围之外，从而有效地显示出你否则无法看到的地图大片区域——因此可以绕过游戏的壁hack和光hack免疫。
- en: '***Using NOPing Zoomhacks***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用NOPing Zoomhacks***'
- en: MOBA and RTS games typically allow players a variable but limited amount of
    zoom. The simplest type of zoomhack finds the value of the *zoom factor* (a multiplier
    that changes as the zoom level changes, typically a `float` or `double`) and overwrites
    it with a larger value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MOBA和RTS游戏通常允许玩家进行可变的但有限的缩放。最简单的类型的zoomhack是找到*缩放因子*（一个随着缩放级别变化而变化的乘数，通常是`float`或`double`）并用更大的值覆盖它。
- en: 'To find the zoom factor, fire up Cheat Engine and search for a `float` with
    an unknown initial value. (To brush up on Cheat Engine, head over to “[Cheat Engine’s
    Memory Scanner](ch01.xhtml#ch00lev1sec9)” on [page 5](ch01.xhtml#page_5).) For
    rescans, repeat the following process until there are only a few values left to
    find the zoom factor:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到缩放因子，启动Cheat Engine并搜索一个初始值未知的 `float`。（要复习Cheat Engine，请参考[《Cheat Engine的内存扫描器》](ch01.xhtml#ch00lev1sec9)在[第5页](ch01.xhtml#page_5)的内容。）对于重新扫描，请重复以下过程，直到只剩下少数几个值，以找到缩放因子：
- en: Go to the game window and zoom in.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到游戏窗口并放大视野。
- en: Search for an increased value in Cheat Engine.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Cheat Engine中搜索增大的值。
- en: Go to the game window and zoom out.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到游戏窗口并缩小视野。
- en: Search for a decreased value in Cheat Engine.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Cheat Engine中搜索减小的值。
- en: Try to get the value list down to one option. To confirm that the remaining
    value is the zoom factor, freeze it in Cheat Engine and see how zoom behaves in-game;
    freezing the proper value will disable zooming. If you fail to find the zoom factor
    using a `float` search, retry the search using a `double`. If both searches fail,
    try them again but correspond zooming in with decreased values and zooming out
    with increased values instead. Once you’ve found the zoom factor in memory, you
    can write a small bot to overwrite it to the zoom factor that best suits you.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将值列表缩小到一个选项。为了确认剩下的值是缩放因子，将其在 Cheat Engine 中冻结并查看游戏中的缩放行为；冻结正确的值将禁用缩放。如果无法通过`float`搜索找到缩放因子，请尝试使用`double`进行搜索。如果两次搜索都失败，请再次尝试，但将缩放与减小的值对应，放大与增大的值对应。一旦找到内存中的缩放因子，你可以编写一个小的机器人来覆盖它为最适合你的缩放因子。
- en: 'More advanced zoomhacks NOP the game code responsible for making sure the zoom
    factor is within a set range. You should be able to find this code with OllyDbg.
    Set a memory on-write breakpoint on the zoom factor, zoom in-game to trigger the
    breakpoint, and inspect the code at the breakpoint. (To hone your OllyDbg memory
    breakpoint skills, flip to “[Controlling OllyDbg Through the Command Line](ch02.xhtml#ch00lev1sec55)”
    on [page 43](ch02.xhtml#page_43).) You should see the code that modified the zoom
    factor. Zoom limitation code is typically easy to spot: constants that match the
    minimum and maximum zoom values are a dead giveaway.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的缩放黑客方法会将负责确保缩放因子在设定范围内的游戏代码NOP掉。你应该能够使用OllyDbg找到这段代码。设置一个针对缩放因子的内存写入断点，在游戏中缩放以触发断点，然后检查断点处的代码。（要提升你的OllyDbg内存断点技能，翻到[第43页](ch02.xhtml#page_43)的“[通过命令行控制OllyDbg](ch02.xhtml#ch00lev1sec55)”部分。）你应该能看到修改缩放因子的代码。缩放限制代码通常很容易辨认：与最小和最大缩放值匹配的常量就是明显的提示。
- en: If you can’t find the limitation code using this method, then the limitation
    may be applied when the graphics are redrawn at a new zoom level, rather than
    when the zoom factor changes. In this case, switch your breakpoint to memory on-read
    and look for the same clues.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这种方法无法找到限制代码，那么这个限制可能是在新缩放级别下重新绘制图形时应用的，而不是缩放因子变化时。在这种情况下，将断点切换到内存读取时，寻找相同的线索。
- en: '***Scratching the Surface of Hooking Zoomhacks***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***触及缩放黑客的表面***'
- en: You can also create zoomhacks by using a Direct3D hook on the function `device->SetTransform(type,
    matrix)`, but this requires a deep understanding of how a game sets up the player’s
    perspective. There are a few different ways to manage perspective, but you control
    zoom level using either *view* (transform type `D3DTS_VIEW`) or *projection* (transform
    type `D3DTS_PROJECTION`).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在`device->SetTransform(type, matrix)`函数上使用Direct3D钩子来创建缩放黑客，但这需要深入理解游戏是如何设置玩家视角的。有几种不同的方式来管理视角，但你可以通过*视图*（变换类型`D3DTS_VIEW`）或*投影*（变换类型`D3DTS_PROJECTION`）来控制缩放级别。
- en: Properly manipulating transform matrices that control view and projection requires
    some pretty extensive knowledge of the mathematics behind 3D graphics, though,
    so I stay away from this method at all costs—and I’ve never had trouble simply
    manipulating the zoom factor. If you’re interested in this kind of hack, though,
    I recommend reading a 3D game programming book to learn more about 3D mathematics
    first.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正确操作控制视图和投影的变换矩阵需要相当深入的3D图形数学知识，因此我会尽量避免使用这种方法——而且我从未遇到过仅仅操作缩放因子会有问题。如果你对这种技巧感兴趣，我建议你先阅读一本3D游戏编程书籍，了解更多关于3D数学的内容。
- en: But sometimes, even a zoomhack isn’t enough. Some useful information may remain
    hidden as a part of a game’s internal state or may simply be hard for a player
    to determine at a moment’s glance. For these situations, a heads-up display is
    the tool for the job.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，即使是缩放黑客也不够。一些有用的信息可能会作为游戏的内部状态隐藏，或者可能对于玩家来说一眼难以看出。在这些情况下，抬头显示（HUD）就是合适的工具。
- en: '**Displaying Hidden Data with HUDs**'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过HUD显示隐藏数据**'
- en: A *heads-up display (HUD)* is a type of ESP hack that displays critical game
    information in an overlay. HUDs often resemble a game’s existing interface for
    displaying information like your remaining ammunition, a mini-map, your current
    health level, any active ability cooldowns, and so on. HUDs typically display
    either historical or aggregated information, and they’re mostly used on MMORPGs.
    They are often text based, but some also contain sprites, shapes, and other small
    visual effects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*抬头显示（HUD）* 是一种 ESP 黑客，它以叠加的形式显示关键的游戏信息。HUD 通常类似于游戏现有的界面，用于显示诸如剩余弹药、迷你地图、当前健康值、任何正在进行的技能冷却时间等信息。HUD
    通常显示历史信息或汇总数据，主要用于 MMORPG。它们通常是文本为主，但也有些包含精灵图、形状以及其他小型视觉效果。'
- en: 'The HUDs you can create depend on what data is available in the game. Common
    data points are these:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建的 HUD 取决于游戏中可用的数据。常见的数据点有：
- en: • Experience gain per hour (exp/h)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: • 每小时经验增长（exp/h）
- en: • Creature kills per hour (KPH)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: • 每小时击杀生物数（KPH）
- en: • Damage per second (DPS)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: • 每秒伤害（DPS）
- en: • Gold looted per hour (GPH)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: • 每小时获得金币（GPH）
- en: • Healing per minute
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: • 每分钟治疗量
- en: • Estimated time until next level
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: • 预计达到下一级所需时间
- en: • Amount of gold spent on supplies
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: • 花费在物资上的金币数量
- en: • Overall gold value of items looted
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: • 被盗物品的总金币价值
- en: More advanced custom HUDs may display large tables containing items looted,
    supplies used, the number of kills for each type of creature, and the names of
    players that have recently been seen.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的自定义 HUD 可能会显示包含已获得物品、使用的物资、每种生物的击杀数，以及最近被看到的玩家名称的大表格。
- en: Beyond what you’ve already learned about reading memory, hooking graphics engines,
    and displaying customized data, there’s not much else I can teach you about how
    to create a HUD. Most games have a simple enough architecture that you can easily
    obtain most of the information you need from memory. Then, you can run some basic
    hourly, percentage, or summation calculations to get the data into a usable format.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你已经学习的关于读取内存、挂钩图形引擎和显示自定义数据的内容外，我没什么别的可以教你如何创建 HUD 的知识。大多数游戏的架构足够简单，你可以轻松地从内存中获取所需的大部分信息。然后，你可以进行一些基本的按小时、百分比或总和的计算，将数据转化为可用的格式。
- en: '***Creating an Experience HUD***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建经验 HUD***'
- en: Imagine you want a HUD that displays your current level, hourly experience,
    and how long you’ll have to play before your character levels up. First, you could
    use Cheat Engine to find the variables that contain your level and experience.
    When you know those values, you can use either a game-specific algorithm or a
    hardcoded experience table to calculate the experience required to reach the next
    level.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你希望一个 HUD 显示你的当前等级、每小时经验以及距离角色升级还需要多长时间。首先，你可以使用 Cheat Engine 查找包含你等级和经验的变量。当你知道这些值后，你可以使用游戏特定的算法或硬编码的经验表来计算达到下一级所需的经验。
- en: 'When you know how much experience you need to level up, you can calculate your
    hourly experience. Put into pseudocode, that process might look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道了升级所需的经验量后，你可以计算每小时经验。用伪代码表示，这个过程可能是这样的：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To find your hourly experience, `hourlyExp`, you’d store your experience and
    the time when your HUD first starts; these are `startExp` and `startTime`, respectively.
    This example also assumes `currentLevel` and `currentExp` are previously defined,
    where `currentLevel` is the character’s level and `currentExp` is the current
    amount of experience.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到每小时经验 `hourlyExp`，你需要存储你的经验值和 HUD 启动时的时间；这些分别是 `startExp` 和 `startTime`。这个例子还假设
    `currentLevel` 和 `currentExp` 已经定义，其中 `currentLevel` 是角色的等级，`currentExp` 是当前的经验值。
- en: With these values, `hourlyExp` can be calculated by multiplying a ratio ➊ of
    the time units in an hour to the time that has passed by the experience gained
    since `startTime` ➋. In this case, the time unit is a millisecond, so the time
    units get multiplied by 1,000.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些值，`hourlyExp` 可以通过将时间单位比例 ➊（即一个小时内的时间单位与已经过去的时间之间的比值）乘以从 `startTime` 以来获得的经验来计算
    ➋。在这个例子中，时间单位是毫秒，所以时间单位需要乘以 1,000。
- en: Next, `currentExp` is subtracted from `nextExp` to determine the remaining experience
    ➌ to level up. To calculate how many hours are left to level up, your remaining
    experience is divided by your hourly experience ➍.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`currentExp` 从 `nextExp` 中减去，以确定升级所需的剩余经验 ➌。为了计算还需要多少小时才能升级，剩余经验除以每小时经验
    ➍。
- en: 'When you have all this information, you can finally display it onscreen. Using
    the Direct3D hooking engine provided in this book’s example code, you’d draw the
    text using this call inside the `EndScene()` hook callback:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有所有这些信息时，你就可以最终将其显示在屏幕上。使用本书示例代码中提供的Direct3D hooking引擎，你可以在`EndScene()`钩子回调函数中通过这个调用来绘制文本：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That’s all you need for a working, experience-tracking HUD. Variations of these
    same equations can be used to calculate KPH, DPS, GPH, and other useful time-based
    measures. Furthermore, you can use the `drawText()` function of the Direct3D hook
    to display any information you can locate and normalize. The hook also contains
    `addSpriteImage()` and `drawSpriteImage()` functions that you can use to draw
    your own custom images, allowing you to make your HUDs as fancy as you want.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一个有效的经验跟踪HUD所需要的一切。这些相同公式的变体可以用来计算KPH、DPS、GPH和其他有用的基于时间的度量。此外，你可以使用Direct3D钩子的`drawText()`函数来显示任何你能找到并规范化的信息。钩子还包含`addSpriteImage()`和`drawSpriteImage()`函数，你可以用它们来绘制自定义图像，让你的HUD变得更加炫酷。
- en: '***Using Hooks to Locate Data***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用钩子定位数据***'
- en: Memory reading isn’t the only way to get data for a custom HUD. You can also
    gather information by counting the number of times a specific model is drawn by
    the `DrawIndexedPrimitive()` function, hooking the game’s internal functions responsible
    for drawing certain types of text, or even intercepting function calls responsible
    for processing data packets from the game server. The methods you use to do this
    will be drastically different for every game, and finding those methods will require
    you to pair everything you’ve learned from this book with your own ingenuity and
    programming instincts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 读取内存并不是获取自定义HUD数据的唯一方式。你还可以通过计算`DrawIndexedPrimitive()`函数绘制特定模型的次数、钩取游戏内部负责绘制某些类型文本的函数，甚至拦截负责处理来自游戏服务器的数据包的函数调用来收集信息。你用来实现这些的方式会因每个游戏而大不相同，找到这些方法将需要你将本书中学到的所有知识与自己的创造力和编程直觉结合起来。
- en: For instance, to create a HUD that displays how many enemies are on the map,
    you could use the model-fingerprinting methods used by wallhacks to count the
    number of enemies and output that number to the screen. This method is better
    than creating a way to read the list of enemies from memory, since it doesn’t
    require new memory addresses every time the game patches.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建一个显示地图上有多少敌人的HUD，你可以使用墙壁透视（wallhacks）中使用的模型指纹识别方法来计算敌人的数量，并将这个数字输出到屏幕上。这个方法比从内存中读取敌人列表更好，因为它不需要在每次游戏更新时都找到新的内存地址。
- en: Another example is displaying a list of enemy cooldowns, which would require
    you to intercept incoming packets that tell the client which spell effects to
    display. You could then correlate certain spells with certain enemies based on
    spell and enemy location, spell type, and so on, and use that information to track
    spells each enemy has used. If you correlate the data with a database of cooldown
    times, you can display exactly when each enemy spell can be used again. This is
    especially powerful because most games don’t store enemy cooldowns in memory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是显示敌人的技能冷却列表，这需要你拦截告知客户端显示哪些技能效果的传入数据包。然后，你可以根据技能和敌人位置、技能类型等，将某些技能与某些敌人关联，并利用这些信息来追踪每个敌人使用过的技能。如果你将这些数据与冷却时间数据库关联，你可以准确地显示每个敌人技能何时可以再次使用。这非常强大，因为大多数游戏并不会将敌人的技能冷却存储在内存中。
- en: '**An Overview of Other ESP Hacks**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**其他ESP黑客概述**'
- en: In addition to the hacks discussed in this chapter, there are a number of ESP
    hacks that don’t have common names and are specific to certain genres or even
    certain games. I’ll quickly take you through the theory, background, and architecture
    of some of these hacks.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章讨论的黑客技巧外，还有一些没有通用名称、专门针对某些类型或甚至某些特定游戏的ESP黑客。我将简要介绍一些这些黑客的理论、背景和架构。
- en: '**Range Hacks**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围黑客**'
- en: Range hacks use a method similar to wallhacks to detect when the models for
    different types of champions or heroes are drawn. Then they draw circles on the
    ground around each hero model. The radius of each circle corresponds to the maximum
    attack range of the champion or hero it surrounds, effectively showing you areas
    where you can be damaged by each enemy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 范围黑客使用类似于墙壁透视（wallhacks）的方法来检测不同类型的英雄或角色的模型何时被绘制。然后，它们会在每个英雄模型周围绘制圆圈。每个圆圈的半径对应于包围该英雄的最大攻击范围，从而有效地显示你可以被每个敌人攻击的区域。
- en: '**Loading-Screen HUDs**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**加载屏幕HUD**'
- en: Loading-screen HUDs are common in MOBA and RTS games that require all players
    to sit through a loading screen while everyone’s game is starting up. These hacks
    take advantage of the fact that such games often have websites where historical
    player statistics can be queried. You can write a bot that automatically queries
    the statistics of each player in the game and seamlessly displays the information
    as an overlay on your loading screen, allowing you to study your enemies before
    launching into battle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 加载屏幕 HUD 在 MOBA 和 RTS 游戏中很常见，这些游戏要求所有玩家在游戏启动时都要经历一个加载屏幕。这些黑客利用了这些游戏通常有网站，可以查询历史玩家统计信息的事实。你可以编写一个自动查询每个玩家统计信息的机器人，并将信息无缝地显示为加载屏幕上的叠加层，让你在战斗前了解敌人的情况。
- en: '**Pick-Phase HUDs**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择阶段 HUD**'
- en: Pick-phase HUDs are similar to their loading-screen cousins, but they are displayed
    during the pregame phase when each player is picking a champion or hero to play.
    Instead of showing enemy statistics, pick-phase HUDs show statistics about allies.
    This allows you to quickly assess the strengths and weaknesses of your allies
    so you can make better decisions about which character to play.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 选择阶段 HUD 与加载屏幕的 HUD 类似，但它们显示在每个玩家选择一个角色或英雄的预游戏阶段。与显示敌人统计数据不同，选择阶段的 HUD 显示的是盟友的统计信息。这使你能够快速评估盟友的优缺点，从而做出更好的决策，选择适合的角色。
- en: '**Floor Spy Hacks**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**楼层间谍黑客**'
- en: Floor spy hacks are common in older 2D top-down games that have different distinct
    floors or platforms. If you’re on the top floor, you might want to know what’s
    going on downstairs before you go charging in. You can write floor spy hacks that
    modify the current floor value (typically an `unsigned int`) to a different floor
    above or below you, allowing you to spy on other floors.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 楼层间谍黑客在较旧的 2D 自上而下游戏中很常见，这些游戏具有不同的楼层或平台。如果你在顶层，你可能希望在冲进去之前了解楼下发生了什么。你可以编写楼层间谍黑客，修改当前楼层值（通常是
    `unsigned int`），将其更改为你上方或下方的其他楼层，从而让你窥探其他楼层的情况。
- en: Games often recalculate the current floor value every frame based on player
    position, so NOPs are sometimes required to keep the value from being reset every
    time a frame is redrawn. Finding the current floor value and the code to NOP would
    be similar to finding the zoom factor, as discussed in “[Using NOPing Zoomhacks](ch09.xhtml#ch00lev1sec196)”
    on [page 197](ch09.xhtml#page_197).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏通常会根据玩家的位置每帧重新计算当前楼层值，因此有时需要使用 NOP 操作来防止每次重绘帧时楼层值被重置。找到当前楼层值以及 NOP 代码的方法与查找缩放因子类似，正如在《[使用
    NOP 缩放黑客](ch09.xhtml#ch00lev1sec196)》一节中所讨论的，在[第 197 页](ch09.xhtml#page_197)上。
- en: '**Closing Thoughts**'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: ESP hacks are powerful ways to obtain extra information about a game. Some of
    them can be done pretty easily through Direct3D hooks or simple memory editing.
    Others require you to learn about a game’s internal data structures and hook proprietary
    functions, giving you a reason to employ your reverse engineering skills.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ESP 黑客是获取游戏额外信息的强大方式。有些黑客可以通过 Direct3D 钩子或简单的内存编辑轻松完成，而其他一些则需要你了解游戏的内部数据结构并钩住专有函数，这样你就可以运用你的逆向工程技能。
- en: If you want to experiment with ESP hacks, study and tweak the example code for
    this chapter. For practice with more specific ESP hacks, I encourage you to go
    out and find some games to play around with.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试 ESP 黑客，可以研究并调整本章的示例代码。为了更具体地练习 ESP 黑客，我鼓励你去找一些游戏来进行探索。
