- en: '[6](nsp-boxall502581-0008.xhtml#rch06)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[6](nsp-boxall502581-0008.xhtml#rch06)'
- en: Using Hardware Timers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用硬件定时器
- en: '![](images/nsp-boxall502581-ct.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-boxall502581-ct.jpg)'
- en: We use timers to determine when we want a period of time to elapse before an
    action takes place, which can be incredibly useful. For example, you can set an
    interrupt to trigger when a timer reaches a certain value. Timers operate in the
    background; while the microcontroller runs your code, the timers are counting
    away.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用定时器来确定在某个动作发生前需要经过多长时间，这非常有用。例如，你可以设置一个中断，当定时器达到某个值时触发。定时器在后台运行；当微控制器执行代码时，定时器在不断计数。
- en: 'In this chapter, you’ll learn about:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: • Various timers in your ATmega328P-PU microcontroller
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 你在 ATmega328P-PU 微控制器中的各种定时器
- en: • Timer overflow interrupts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 定时器溢出中断
- en: • Clear Timer on Compare Match interrupts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 比较匹配中断时清除定时器
- en: I’ll show you how to run parts of code on a regular basis, create longer delays
    for repetitive actions, and examine the accuracy of internal timers. You’ll also
    learn a more efficient method of addressing individual bits inside a register.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你展示如何定期运行部分代码，为重复的操作创建更长的延迟，并检查内部定时器的准确性。你还将学习一种更高效的方法，来处理寄存器内的单个位。
- en: '[Introducing Timers](nsp-boxall502581-0008.xhtml#rah0801)'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[定时器简介](nsp-boxall502581-0008.xhtml#rah0801)'
- en: Both our AVR microcontrollers have several timers, each of which contains an
    incrementing counting variable whose value is stored in a *counter register* .
    Once a counter reaches its maximum value, a bit in a register changes, and the
    counter resets to zero and starts over. Beyond using timers to trigger interrupts,
    you can use them to measure elapsed time with some clever arithmetic based on
    the incrementing variable’s progress.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 AVR 微控制器都有多个定时器，每个定时器包含一个递增的计数变量，其值存储在*计数寄存器* 中。一旦计数器达到最大值，寄存器中的一个位会改变，计数器会重置为零并重新开始。除了使用定时器触发中断外，你还可以利用它们通过一些巧妙的算术计算来测量经过的时间，基于递增变量的进度。
- en: The ATmega328P-PU has three timers—TIMER0, TIMER1, and TIMER2—with their own
    counter registers. TIMER0 and TIMER2 are 8-bit counters with a maximum value of
    255\. TIMER1 is a 16-bit counter and has a maximum value of 65,535\. The ATtiny85
    also has timers, but as the ATmega is more versatile given its higher number of
    I/O pins, we’ll only discuss the latter in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ATmega328P-PU 有三个定时器——TIMER0、TIMER1 和 TIMER2——每个定时器都有自己的计数寄存器。TIMER0 和 TIMER2
    是 8 位计数器，最大值为 255。TIMER1 是 16 位计数器，最大值为 65,535。ATtiny85 也有定时器，但由于 ATmega 具有更多的
    I/O 引脚，功能更强大，本章我们只讨论 ATmega。
- en: Timers need a *clock source* to count accurate periods of time. A clock source
    is an oscillator circuit with an output that changes between high and low at a
    precise frequency. You can use either the internal or an external clock source.
    In this chapter we’ll use the microcontroller’s internal clock source, and I’ll
    show you how to use an external clock source when this is necessary in later chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器需要一个 *时钟源* 来准确计数时间周期。时钟源是一个振荡电路，其输出在精确的频率下在高低之间变化。你可以使用内部时钟源或外部时钟源。在本章中，我们将使用微控制器的内部时钟源，稍后的章节中我会向你展示如何在需要时使用外部时钟源。
- en: 'Up to this point, our microcontrollers have been running at a speed of 1 MHz,
    and you can use their internal clock sources to drive the timers. We determine
    the period of time between each increment of the timer’s counter with this simple
    formula:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的微控制器以 1 MHz 的速度运行，你可以使用它们的内部时钟源来驱动定时器。我们通过这个简单的公式来确定定时器计数器每次增量之间的时间间隔：
- en: '*T* = 1 / *f*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* = 1 / *f*'
- en: where *f* is frequency in Hz and *T* is time in seconds. For example, we calculate
    the period at 1 MHz as *T* = 1 / 1,000,000, which results in a value of one millionth
    of a second, known as one microsecond.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *f* 是频率（Hz），*T* 是时间（秒）。例如，我们计算 1 MHz 时的周期为 *T* = 1 / 1,000,000，结果是百万分之一秒，也就是一微秒。
- en: 'You can adjust the length of the period by using a *prescaler* , a number used
    to divide the frequency to increase the period time. You use the prescaler when
    you need to measure amounts of time that exceed the default duration of one of
    the timers. Five prescalers are available: 1, 8, 64, 256, and 1,024.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 *预分频器* 来调整周期的长度，预分频器是一个数字，用来将频率除以，从而增加周期时间。当你需要测量超出定时器默认时长的时间时，可以使用预分频器。提供五种预分频器：1、8、64、256
    和 1,024。
- en: 'To calculate a period altered by a prescaler, we use the following formula:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算通过预分频器调整的周期，我们使用以下公式：
- en: '*T* = 1 / (1,000,000 / *p* )'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* = 1 / (1,000,000 / *p* )'
- en: where *T* is time in seconds and *p* is the prescaler value. We can then determine
    the length of time before a given register resets. For example, to determine the
    length of time elapsed before reset for TIMER1, you would multiply the resulting
    value of *T* for your chosen prescaler by the maximum value of the TIMER1 counter
    (65,535). If your prescaler is 8, your time per period is 0.00008 seconds, so
    you’d multiply 65,535 by 0.00008 to get 0.52428 seconds. This means TIMER1 will
    reset after 0.52428 seconds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*T*是秒数，*p*是预分频器的值。然后我们可以确定在给定寄存器重置之前的时间长度。例如，为了确定TIMER1重置前经过的时间长度，你需要将所选预分频器的*T*值与TIMER1计数器的最大值（65,535）相乘。如果你的预分频器是8，那么每个周期的时间为0.00008秒，因此你需要将65,535乘以0.00008，得到0.52428秒。这意味着TIMER1将在0.52428秒后重置。
- en: I’ve already calculated the values for the TIMER1 counter, for your convenience;
    they’re listed in [Table 6-1](nsp-boxall502581-0016.xhtml#tab0601) .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为你计算了TIMER1计数器的值，方便你参考；它们列在[表6-1](nsp-boxall502581-0016.xhtml#tab0601)中。
- en: '| Table 6-1 : Prescaler Values for the TCCR1B Register at 1 MHz and Their Period
    Times |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 表6-1：在1 MHz下TCCR1B寄存器的预分频器值及其周期时间 |'
- en: '| --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Prescaler type | Period (s) | Bit 2 | Bit 1 | Bit 0 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 预分频器类型 | 周期（秒） | 位2 | 位1 | 位0 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| /1 (none) | 0.000001 | 0 | 0 | 0 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| /1 (无) | 0.000001 | 0 | 0 | 0 |'
- en: '| /8 | 0.000008 | 0 | 1 | 0 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| /8 | 0.000008 | 0 | 1 | 0 |'
- en: '| /64 | 0.000064 | 0 | 1 | 1 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| /64 | 0.000064 | 0 | 1 | 1 |'
- en: '| /256 | 0.000256 | 1 | 0 | 0 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| /256 | 0.000256 | 1 | 0 | 0 |'
- en: '| /1024 | 0.001024 | 1 | 0 | 1 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| /1024 | 0.001024 | 1 | 0 | 1 |'
- en: That’s enough theory for now. In the following projects we’ll put timers to
    work, to increase your understanding.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先不讨论更多理论。在接下来的项目中，我们将使用计时器来加深你的理解。
- en: '[Project 27: Experimenting with Timer Overflow and Interrupts](nsp-boxall502581-0008.xhtml#rpro27)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目27：实验计时器溢出和中断](nsp-boxall502581-0008.xhtml#rpro27)'
- en: In the first of our timer demonstrations, you’ll learn how to trigger an ISR
    once a timer counter overflows, using TIMER1\. You’ll also experiment with prescalers
    to alter the length of time before the counter resets.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个计时器演示中，你将学习如何在计时器计数器溢出时触发一个中断服务程序（ISR），使用的是TIMER1。你还将通过实验使用预分频器来改变计数器重置前的时间长度。
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0801)'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[硬件部分](nsp-boxall502581-0008.xhtml#rbh0801)'
- en: 'For this project, you’ll need the following hardware:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将需要以下硬件：
- en: • USBasp programmer
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • USBasp 编程器
- en: • Solderless breadboard
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 无焊接面包板
- en: • ATmega328P-PU microcontroller
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • ATmega328P-PU 微控制器
- en: • Jumper wires
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 跳线电缆
- en: • Two LEDs
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个LED
- en: • Two 560 Ω resistors
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 两个560 Ω电阻
- en: Assemble the circuit as shown in [Figure 6-1](nsp-boxall502581-0016.xhtml#f06001)
    .
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图6-1](nsp-boxall502581-0016.xhtml#f06001)中的示意图组装电路。
- en: '![Schematic diagram for Project 27](images/nsp-boxall502581-f06001.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![项目27的电路图](images/nsp-boxall502581-f06001.jpg)'
- en: 'Figure 6-1: Schematic for [Project 27](nsp-boxall502581-0016.xhtml#pro27)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：[项目27](nsp-boxall502581-0016.xhtml#pro27)的电路图
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the same way you have for the previous projects.
    Once completed, keep your circuit together, as you’ll use it for the [next project](nsp-boxall502581-0016.xhtml#pro28)
    as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你组装好电路后，将USBasp通过无焊接面包板连接到你的微控制器，方法与之前的项目相同。完成后，保持电路连接，因为你将会在[下一个项目](nsp-boxall502581-0016.xhtml#pro28)中继续使用它。
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0802)'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[代码部分](nsp-boxall502581-0008.xhtml#rbh0802)'
- en: Open a terminal window, navigate to the *Project 27* subfolder of this book’s
    *Chapter 6* folder, and enter the command `make flash` . The toolchain should
    compile the program file and upload the data to the microcontroller as usual.
    At this point the LED connected to PB0 should blink rapidly, and the LED connected
    to PB1 should quickly flicker on and off about every half-second (every 0.52428 seconds,
    to be exact!).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到本书*第六章*文件夹中的*项目27*子文件夹，并输入命令`make flash`。工具链应编译程序文件并像往常一样将数据上传到微控制器。此时，连接到PB0的LED应该快速闪烁，连接到PB1的LED应该大约每半秒（精确来说是每0.52428秒）快速闪烁一次。
- en: 'Let’s see how this works. Open the *main.c* file for Project 27:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。打开*main.c*文件以查看项目27：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code includes the function `initOVI()` to initialize TIMER1 for use. First,
    we include the library for interrupts ❶ and define the timer operations ❷—this
    is the code that runs when the timer resets. We then set the prescaler to 8 by
    setting the second bit of the TCCR1B register ❸. This causes the TIMER1 register
    to reset every 0.52428 seconds. Next, we set the TIMSK1 register with 1 as the
    first bit ❹ to enable an interrupt to be called every time the TIMER1 counter
    overflows and resets to initialize the timer operations we defined earlier, and
    call `sei()` to enable interrupts ❺.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了 `initOVI()` 函数来初始化 TIMER1 以供使用。首先，我们包含中断的库 ❶ 并定义定时器操作 ❷——这是定时器重置时执行的代码。然后，我们通过设置
    TCCR1B 寄存器的第二位 ❸ 将预分频器设置为 8。这会导致 TIMER1 寄存器每 0.52428 秒重置一次。接着，我们将 TIMSK1 寄存器的第
    1 位设置为 1 ❹，以便每当 TIMER1 计数器溢出并重置时调用中断，从而初始化我们之前定义的定时器操作，并调用 `sei()` 启用中断 ❺。
- en: Once operating, the LED should blink on and off as instructed in `int main(void)`
    , and the TIMER1 counter will count away at 125 kHz (remember, our clock speed
    is 1 MHz, and we’re using a prescaler of 8), so each counter increment takes 0.000008 seconds.
    With such a tiny length of time for each count, it only takes 0.52428 seconds
    to count from 0 to 65,535, at which point the TIMER1 counter overflows and the
    code calls the interrupt code ❷, which blinks the other LED briefly. TIMER1 resets
    to zero and starts counting again.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始运行，LED 应按照 `int main(void)` 中的指示闪烁，且 TIMER1 计数器将以 125 kHz 的速度递增（记住，我们的时钟速度是
    1 MHz，且我们使用了 8 的预分频器），因此每次计数增量需要 0.000008 秒。由于每次计数的时间如此短，计数从 0 到 65,535 仅需 0.52428
    秒，此时 TIMER1 计数器溢出，代码会调用中断代码 ❷，短暂闪烁另一个 LED。TIMER1 会重置为零并重新开始计数。
- en: Though this code sets the prescaler to 8 using the TCCR1B register, you can
    also select other prescalers by setting bits 2, 1, and 0 of the register using
    the values shown in [Table 6-1](nsp-boxall502581-0016.xhtml#tab0601) . Spend some
    time changing the bits for the TCCR1B register with your [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    hardware to experiment with the way this impacts the timing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码通过 TCCR1B 寄存器将预分频器设置为 8，你也可以通过设置寄存器的第 2 位、1 位和 0 位，选择其他预分频器，具体值见[表 6-1](nsp-boxall502581-0016.xhtml#tab0601)。花些时间用你的[项目
    27](nsp-boxall502581-0016.xhtml#pro27)硬件更改 TCCR1B 寄存器的位，实验一下这对定时的影响。
- en: In the [next project](nsp-boxall502581-0016.xhtml#pro28) , I’ll show you how
    to run a section of code on a recurring, regular basis.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[下一个项目](nsp-boxall502581-0016.xhtml#pro28)中，我将向你展示如何定期、规律地运行一段代码。
- en: '[Project 28: Using a CTC Timer for Repetitive Actions](nsp-boxall502581-0008.xhtml#rpro28)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目 28：使用 CTC 定时器进行重复动作](nsp-boxall502581-0008.xhtml#rpro28)'
- en: '*Clear Timer on Compare Match (CTC)* is a different method of timing that calls
    an ISR once a timer’s counter has reached a certain value, then resets the timer
    to zero and starts it counting again. The CTC timing mode is useful when you want
    to run a section of code on a recurring basis.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*比较匹配清零模式（CTC）* 是一种不同的计时方法，它在定时器计数器达到某个特定值时调用 ISR，然后将定时器重置为零并重新开始计数。CTC 定时模式在你需要定期运行一段代码时非常有用。'
- en: In this project, you’ll learn how to trigger an ISR every time a counter reaches
    15 seconds, again using TIMER1\. To determine the duration value, first calculate
    the number of elapsed periods per second for the timer, using the values in [Table
    6-1](nsp-boxall502581-0016.xhtml#tab0601) . We’ll use the 1,024 prescaler (if
    you need a longer duration, you can use an appropriate prescaler). This gives
    us 14,648 periods (rounded down), to which we add 1 to account for the time required
    for the timer to be reset back to zero. Our code should now check the TIMER1 counter
    value. Once it reaches 14,649, the code calls the ISR and then resets the counter
    to zero.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将学习如何在计数器达到 15 秒时触发 ISR，再次使用 TIMER1。为了确定持续时间值，首先需要根据[表 6-1](nsp-boxall502581-0016.xhtml#tab0601)中的值计算每秒钟定时器经过的周期数。我们将使用
    1,024 的预分频器（如果需要更长的持续时间，你可以选择适当的预分频器）。这样我们就得到 14,648 个周期（向下取整），然后加上 1 以考虑定时器重置回零所需的时间。我们的代码现在应该检查
    TIMER1 的计数器值。一旦计数器达到 14,649，代码就会调用 ISR，然后将计数器重置为零。
- en: Use the same hardware for this project as for [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    . With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the same way you have for the previous projects.
    Again, keep the circuit together when you’re done so you can use it in the [next
    project](nsp-boxall502581-0016.xhtml#pro29) .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，使用与[项目27](nsp-boxall502581-0016.xhtml#pro27)相同的硬件。电路组装好后，通过无焊接面包板以与前一个项目相同的方式将USBasp连接到你的微控制器。完成后，保持电路完整，以便你能在[下一个项目](nsp-boxall502581-0016.xhtml#pro29)中使用它。
- en: Open a terminal window, navigate to the *Project 28* subfolder of this book’s
    *Chapter 6* folder, and enter the command `make flash` . Once the project’s code
    has been uploaded to the microcontroller the LED connected to PB0 should start
    to blink rapidly, and the LED connected to PB1 should briefly turn on and off
    every 15 seconds.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端窗口，导航到本书*第6章*文件夹中的*项目28*子文件夹，然后输入命令`make flash`。一旦项目的代码上传到微控制器，连接到PB0的LED应该开始快速闪烁，连接到PB1的LED每15秒短暂开关一次。
- en: 'Let’s see how this works. Open the *main.c* file for [Project 28](nsp-boxall502581-0016.xhtml#pro28)
    :'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的。打开[项目28](nsp-boxall502581-0016.xhtml#pro28)的*main.c*文件：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code includes an `initCTC()` function ❸, which we use to set up our timer.
    We tell the code to run the ISR when the timer reaches the value 14,649 by setting
    OCR1A to `14649` ❹. Then we set the prescaler to 1,024 ❺ and turn on the timer
    compare interrupt feature ❻.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包括一个`initCTC()`函数❸，我们用它来设置定时器。我们通过将OCR1A设置为`14649`❹，告诉代码当定时器达到14649时运行ISR。然后我们将预分频器设置为1,024❺，并打开定时器比较中断功能❻。
- en: The main code begins by running the `initCTC()` function, then merrily blinks
    the LED connected to PB0\. Once the TIMER1 counter reaches 14,649 (our 15-second
    mark), the ISR code ❶ will run. Inside the ISR, the code first resets TIMER1 to
    zero ❷, then blinks the LED connected to PB1.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 主代码首先运行`initCTC()`函数，然后开始愉快地闪烁连接到PB0的LED。一旦TIMER1计数器达到14649（即我们的15秒标记），ISR代码❶将会运行。在ISR内部，代码首先将TIMER1重置为零❷，然后闪烁连接到PB1的LED。
- en: You should now understand how to execute an ISR after a set period of time.
    Experiment with prescalers and values for some practice, then we’ll move on to
    using CTC for longer delays in code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该理解如何在设定时间后执行ISR。尝试使用不同的预分频器和数值进行练习，接着我们将继续使用CTC来实现更长的延迟时间。
- en: '[Project 29: Using CTC Timers for Repetitive Actions with Longer Delays](nsp-boxall502581-0008.xhtml#rpro29)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目29：使用CTC定时器进行带有更长延迟的重复动作](nsp-boxall502581-0008.xhtml#rpro29)'
- en: Sometimes you’ll want to set up a recurring event over a longer period than
    the one in [Project 28](nsp-boxall502581-0016.xhtml#pro28) —perhaps every 15 minutes
    rather than every 15 seconds. Due to the size of the OCR1A register (65,535) we
    can’t just enter a very large number to count up to a long period of time and
    expect the CTC timer to work, so we need to use a small workaround. We set up
    a CTC timer as per [Project 28](nsp-boxall502581-0016.xhtml#pro28) that triggers
    the ISR once per second. We then count those seconds, and when the desired delay
    has elapsed, we call a function to execute the required code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要设置一个比[项目28](nsp-boxall502581-0016.xhtml#pro28)中更长时间的重复事件——例如，每15分钟而不是每15秒。由于OCR1A寄存器的大小（65,535），我们不能直接输入一个非常大的数字来计数到长时间并指望CTC定时器工作，所以我们需要使用一个小的变通方法。我们按照[项目28](nsp-boxall502581-0016.xhtml#pro28)的设置配置一个CTC定时器，每秒触发一次ISR。然后我们计算这些秒数，当所需的延迟时间过去时，我们调用一个函数来执行所需的代码。
- en: 'In more detail, to set up a longer period between recurring events, we do the
    following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，为了设置更长的周期以进行重复事件，我们做如下操作：
- en: 1\. Use a global variable to store the target delay value we wish to use for
    our period (measured in seconds).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 使用一个全局变量来存储我们希望用于周期的目标延迟值（以秒为单位）。
- en: 2\. Use another global variable to store the number of elapsed seconds in the
    delay.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 使用另一个全局变量来存储延迟中经过的秒数。
- en: 3\. Set the CTC timer to watch for durations of one second.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 将CTC定时器设置为监控1秒的持续时间。
- en: 4\. Have the ISR (called every second) add one to the elapsed seconds variable,
    then check that it has reached the target delay value—and if so, execute the required
    code.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 每秒调用一次ISR，使其将已过秒数变量加1，然后检查是否达到了目标延迟值——如果达到了，则执行所需的代码。
- en: With this approach you can implement a variation of multitasking, as you’ll
    see in the following project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你可以实现一种变体的多任务处理，如下一个项目中所示。
- en: Use the same hardware as in [Project 28](nsp-boxall502581-0016.xhtml#pro28)
    . With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the same way you have for the previous projects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与 [项目 28](nsp-boxall502581-0016.xhtml#pro28) 相同的硬件。组装好电路后，通过无焊面包板将 USBasp
    连接到微控制器，就像你在之前的项目中所做的那样。
- en: Next, open a terminal window, navigate to the *Project 29* subfolder of this
    book’s *Chapter 6* folder, and enter the command `make flash` . The tool chain
    should compile the program file and then upload the data to the microcontroller.
    At this point the LED connected to PB0 should blink rapidly, and the LED connected
    to PB1 should briefly turn on and off every second.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开一个终端窗口，导航到本书 *第 6 章* 文件夹下的 *项目 29* 子文件夹，并输入命令 `make flash`。工具链应编译程序文件并将数据上传到微控制器。此时，连接到
    PB0 的 LED 应该快速闪烁，连接到 PB1 的 LED 每秒短暂地开关一次。
- en: 'Let’s see how this works. Open the *main.c* file for [Project 29](nsp-boxall502581-0016.xhtml#pro29)
    :'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。打开 [项目 29](nsp-boxall502581-0016.xhtml#pro29) 的 *main.c* 文件：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this stage you should be quite familiar with most of this code, such as the
    `ISR()` function, but there are a few new components. First, there are two new
    global variables, `uint16_t target` ❶ and `uint16_t targetCount` ❷. We set `target`
    to the number of seconds to wait while the required code runs ❸. In this example
    `target` is set to 1, but you can set it to anything up to 32,767 (for 546.116 . . .
    minutes), as this is the highest value that can be stored in a 16-bit integer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，您应该已经对大部分代码非常熟悉，例如 `ISR()` 函数，但也有一些新的组件。首先，有两个新的全局变量，`uint16_t target`
    ❶ 和 `uint16_t targetCount` ❷。我们将 `target` 设置为运行所需代码时等待的秒数 ❸。在此示例中，`target` 设置为
    1，但您可以将其设置为任何数值，最大可设置为 32,767（约 546.116 分钟），因为这是 16 位整数所能存储的最大值。
- en: The ISR uses the variable `targetCount` to accumulate elapsed seconds, as every
    time the code calls the ISR (once per second), it increments `targetCount` by
    1 ❹. When the code calls the ISR, it checks to see if `target Count` matches `target`
    ❺. If so, the code resets TIMER1 to zero ❻, then runs the required code via the
    function `targetFunction()` ❼, and finally resets `targetCount` back to zero ❽,
    allowing the process to start again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ISR 使用变量 `targetCount` 来累计经过的秒数，因为每当代码调用 ISR（每秒一次）时，它会将 `targetCount` 增加 1 ❹。当代码调用
    ISR 时，它会检查 `targetCount` 是否与 `target` 相匹配 ❺。如果匹配，代码会将 TIMER1 重置为零 ❻，然后通过函数 `targetFunction()`
    执行所需的代码 ❼，最后将 `targetCount` 重置为零 ❽，使得该过程可以重新开始。
- en: Although our example runs the `targetFunction()` code once per second, remember
    that you can easily increase the duration by changing the value for `target` .
    For example, to run `targetFunction()` every 5 minutes, change `target` to 300
    (5 minutes × 60 seconds = 300 seconds).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的示例每秒运行一次 `targetFunction()` 代码，但请记住，您可以通过更改 `target` 的值轻松增加时间间隔。例如，要每 5
    分钟运行一次 `targetFunction()`，将 `target` 设置为 300（5 分钟 × 60 秒 = 300 秒）。
- en: Now that you’ve had some opportunities to experiment with the AVR’s ATmega’s
    timers, I’d like to briefly discuss the accuracy of the internal timers themselves.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有机会尝试 AVR 的 ATmega 定时器，我想简要讨论一下内部定时器的准确性。
- en: '[Examining the Accuracy of the Internal Timer](nsp-boxall502581-0008.xhtml#rah0802)'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[检查内部定时器的准确性](nsp-boxall502581-0008.xhtml#rah0802)'
- en: You may be wondering how accurately the internal timer can keep time. You can
    easily check this by running the [Project 29](nsp-boxall502581-0016.xhtml#pro29)
    code (with a one-second interval) and measuring the results with a digital storage
    oscilloscope, as shown in [Figure 6-2](nsp-boxall502581-0016.xhtml#f06002) .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道内部定时器能多准确地保持时间。您可以通过运行 [项目 29](nsp-boxall502581-0016.xhtml#pro29) 代码（每秒一次）并使用数字存储示波器测量结果，轻松验证这一点，正如
    [图 6-2](nsp-boxall502581-0016.xhtml#f06002) 所示。
- en: '![Displaying the outputs from Project 29 in two channels of a digital storage
    oscilloscope](images/nsp-boxall502581-f06002.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![在数字存储示波器的两个通道中显示项目 29 的输出](images/nsp-boxall502581-f06002.jpg)'
- en: 'Figure 6-2: Measuring the outputs of [Project 29](nsp-boxall502581-0016.xhtml#pro29)
    using a DSO'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：使用数字存储示波器测量 [项目 29](nsp-boxall502581-0016.xhtml#pro29) 的输出
- en: The blinking LED on PB0 is connected to channel 1 (the upper signal) of the
    DSO, while the LED on PB2 that `targetFunction()` controls is connected to channel
    2 (the lower signal). You should see the signal rise and fall as the LED on PB0
    turns on then off every 100 milliseconds. The signal for the first LED stays low
    while the code controlling the second LED on PB1 operates, as the microcontroller
    cannot operate two things at the same time. After the one second has elapsed,
    the other LED on PB0 connected to channel 1 turns on and off as directed by `targetFunction()`
    , and the whole process repeats.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 连接在PB0上的闪烁LED连接到示波器的第1通道（上信号），而`targetFunction()`控制的PB2上的LED连接到第2通道（下信号）。你应该能看到信号随着PB0上的LED每100毫秒开启和关闭而上升和下降。第一个LED的信号保持低电平，而控制第二个LED（在PB1上）的代码仍在运行，因为微控制器无法同时操作两个任务。在1秒钟后，连接在PB0上的另一个LED会按照`targetFunction()`的指示开启和关闭，整个过程会重复。
- en: In this case the DSO has measured the frequency for the second LED as 1.018
    Hz, or 1.018 times per second—this is awfully close to the required 1 second.
    Considering we’re not using any external timing hardware on the circuit, this
    is a good outcome. However, if you’d like to run much longer delay periods, you’ll
    need to take such slight variances into account. For example, that 0.018 Hz imbalance
    from 1 second can equate to 5.4 seconds over a 5-minute period (the actual time
    of 5.4 seconds is calculated by multiplying 0.018 Hz by 300 seconds). Keep this
    in mind in your future timing projects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，示波器测得第二个LED的频率为1.018 Hz，即每秒1.018次——这非常接近所需的1秒。考虑到我们没有在电路中使用任何外部定时硬件，这是一个不错的结果。然而，如果你希望运行更长时间的延迟，你需要考虑这种微小的变化。例如，从1秒的0.018
    Hz偏差可能在5分钟内积累成5.4秒（5.4秒的实际时间是通过将0.018 Hz乘以300秒计算出来的）。在未来的定时项目中，请记住这一点。
- en: '[Addressing Registers with Bitwise Operations](nsp-boxall502581-0008.xhtml#rah0803)'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[通过位运算进行寄存器寻址](nsp-boxall502581-0008.xhtml#rah0803)'
- en: 'From the beginning of this book, we’ve been addressing various registers using
    the binary number format. For example, with an ATmega328P-PU, we use the following
    two lines of code to set pin PB0 as an output and turn it on:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书开始，我们一直使用二进制数字格式寻址各种寄存器。例如，使用ATmega328P-PU时，我们使用以下两行代码将PB0引脚设置为输出并打开它：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method has worked well for us so far, but it requires us to consider every
    bit in the register every time we address one or more bits inside the entire register.
    In this section I’ll show you how to use bitwise operations, which allow us to
    change just a particular bit (or bits) in a register, leaving the others as they
    were. This will be useful for future projects in the book and beyond, as it allows
    you to easily set individual or multiple bits without worrying about changing
    all the bits in a register at once.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法到目前为止效果良好，但它要求我们每次寻址一个或多个位时，都必须考虑寄存器中的每一位。在本节中，我将向你展示如何使用位运算，位运算允许我们仅更改寄存器中的特定位（或多个位），而保持其他位不变。这对于书中的未来项目以及以后的项目都非常有用，因为它让你能够轻松设置单个位或多个位，而不必担心一次更改寄存器中的所有位。
- en: '[Addressing Individual Bits in a Register](nsp-boxall502581-0008.xhtml#rbh0803)'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[在寄存器中寻址单个位](nsp-boxall502581-0008.xhtml#rbh0803)'
- en: 'By default, all bits in a register are set to 0 (low, or off) when we reset
    or turn on the microcontroller. We then set bits to 1 (high, or on) or 0 when
    required, using the following operations:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们重置或开启微控制器时，寄存器中的所有位都被设置为0（低电平或关闭）。然后，我们根据需要将位设置为1（高电平或开启）或0，使用以下操作：
- en: Turning a bit to high
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个位设置为高
- en: 'Use the following code to turn a bit to high (on) by setting it to 1:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码将一个位设置为高电平（开启），方法是将其设置为1：
- en: '[PRE4]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For example, to turn on the output from PORTB’s PB7, you would use the following
    line, since 7 is the bit number in the PORTB register matching pin PB7:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要打开PORTB的PB7输出，可以使用以下代码行，因为7是与PB7引脚相匹配的PORTB寄存器中的位号：
- en: '[PRE5]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This allows you to turn on PB7 without needing to concern yourself with the
    status of the other bits in the register.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使你能够在不需要关注寄存器中其他位状态的情况下打开PB7。
- en: Toggling a bit between high and low
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高电平和低电平之间切换位
- en: 'To *toggle* a bit is to change it from its current state to the alternate state
    (from off to on, or vice versa). Use the following code to do so:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*切换*一个位是指将其从当前状态更改为另一个状态（从关闭变为开启，或反之）。可以使用以下代码来实现：'
- en: '[PRE6]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For example, to toggle the output from PORTB’s PB3 you would use the following
    line, as the bit number in the PORTB register matching pin PB3 is 3:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要切换PORTB的PB3的输出，可以使用以下代码，因为PORTB寄存器中与PB3引脚对应的位编号是3：
- en: '[PRE7]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To demonstrate this, you can blink an LED connected to PB3 with a 250 ms delay
    by using the following two lines in your code’s `for (;;)` loop:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了演示这一点，你可以通过在代码的`for (;;)`循环中使用以下两行代码，在PB3上连接的LED以250毫秒的延迟进行闪烁：
- en: '[PRE8]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By using bitwise operations you also save space, as the LED blinking example
    only requires two lines of code instead of four.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用位运算，你还可以节省空间，因为LED闪烁的示例只需要两行代码，而不是四行。
- en: Turning a bit to low
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将位设置为低电平
- en: 'Use the following code to turn a bit to low (off) by setting it to 0:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码将某一位设置为低电平（关闭），即将其设置为0：
- en: '[PRE9]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For example, to turn off the output from PORTB’s PB7 you would use the following
    line, as 7 is the bit number in the PORTB register matching pin PB7:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要关闭PORTB的PB7输出，你可以使用以下代码，因为7是PORTB寄存器中与PB7引脚对应的位编号：
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using bitwise operations in this way is more efficient than the binary number
    format we used to work with register bits earlier. However, you can improve on
    this method even further by using the name of the register bit instead of the
    number, which makes it easier to determine which bit is being altered. For example,
    say you want to set bit 0 of TIMSK1 on to enable the TIMER1 overflow interrupt
    used in [Project 27](nsp-boxall502581-0016.xhtml#pro27) . Instead of using `TIMSK1
    = 0b00000001` , you can use `TIMSK1 |= (1 << TOIE1)` .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用位运算比我们之前用来处理寄存器位的二进制数字格式更高效。不过，你还可以进一步改进这种方法，通过使用寄存器位的名称而不是数字，这样可以更容易地确定正在更改哪个位。例如，假设你要设置TIMSK1的位0，以启用[TIMER1溢出中断](nsp-boxall502581-0016.xhtml#pro27)。你可以使用`TIMSK1
    |= (1 << TOIE1)`，而不是使用`TIMSK1 = 0b00000001`。
- en: 'To determine which register bit name to use for the corresponding bit number
    ( `TOIE1` rather than `0b00000001` in the previous example), check the data sheets
    for your microcontrollers. If you have not already done so, you can download the
    full data sheets in Adobe PDF format from the Microchip website:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定使用哪个寄存器位名来对应位编号（例如，在之前的示例中使用`TOIE1`而非`0b00000001`），请查阅你的微控制器的数据手册。如果你还没有下载，可以从Microchip官网以Adobe
    PDF格式下载完整的数据手册：
- en: ATtiny85 data sheet [https://www.microchip.com/wwwproducts/en/ATtiny85/](https://www.microchip.com/wwwproducts/en/ATtiny85/)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ATtiny85数据手册 [https://www.microchip.com/wwwproducts/en/ATtiny85/](https://www.microchip.com/wwwproducts/en/ATtiny85/)
- en: ATmega data sheet [https://www.microchip.com/wwwproducts/en/ATmega328p/](https://www.microchip.com/wwwproducts/en/ATmega328p/)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ATmega数据手册 [https://www.microchip.com/wwwproducts/en/ATmega328p/](https://www.microchip.com/wwwproducts/en/ATmega328p/)
- en: You can then learn the bit names to match a given register, such as the TIMSK1
    register, which appears in section 16.11.8 of the ATmega328P-PU’s data sheet,
    as shown in [Figure 6-3](nsp-boxall502581-0016.xhtml#f06003) .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以学习位名称，以便匹配给定的寄存器，例如TIMSK1寄存器，它出现在ATmega328P-PU数据手册的16.11.8节中，如[图6-3](nsp-boxall502581-0016.xhtml#f06003)所示。
- en: '![Image of the TIMSK1 register with bit labels included](images/nsp-boxall502581-f06003.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![TIMSK1寄存器及位标签的图像](images/nsp-boxall502581-f06003.jpg)'
- en: 'Figure 6-3: The ATmega328P-PU TIMSK1 register'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3：ATmega328P-PU TIMSK1寄存器
- en: Now that you can address a single bit inside a register, next I’ll show you
    how to address two or more bits in the same register without affecting other bits.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以访问寄存器中的单个位，接下来我将向你展示如何在不影响其他位的情况下，访问同一寄存器中的两个或更多位。
- en: '[Addressing Multiple Bits in a Register](nsp-boxall502581-0008.xhtml#rbh0804)'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[在寄存器中操作多个位](nsp-boxall502581-0008.xhtml#rbh0804)'
- en: 'You can also change more than one bit in a single register at the same time
    (again, without worrying about the bits that you’re not changing) using bitwise
    operations. Note, however, that you have to perform the same operation on all
    the bits—for example, you can turn three bits on in one line, but you can’t turn
    two on and one off in one line. If you need to do the latter, use the binary number
    method instead. Here’s how this works:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以同时更改一个寄存器中的多个位（同样，无需担心你没有改变的位），通过位运算来实现。不过需要注意的是，你必须对所有位执行相同的操作——例如，你可以在一行中将三个位设置为高电平，但不能在一行中将两个位设置为高电平，一个设置为低电平。如果你需要后者，请改用二进制数字方法。下面是如何操作：
- en: Turning multiple bits high
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个位设置为高电平
- en: 'To turn two bits on at once, use the following code:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要同时打开两个位，可以使用以下代码：
- en: '[PRE11]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For example, to turn on the output from PORTB’s PB0 and PB7, you could use:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要同时打开PORTB的PB0和PB7的输出，你可以使用：
- en: '[PRE12]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can add additional addressing to the same line. For example, you could
    turn on PB0, PB3, and PB7 as follows:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在同一行中添加额外的寻址。例如，你可以如下所示开启PB0、PB3和PB7：
- en: '[PRE13]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You could use this method to address up to seven bits. If you want to change
    all bits, then use the usual `PORT` `x` function.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用这种方法来寻址最多七个位。如果你想更改所有位，那么就使用常规的`PORT` `x`函数。
- en: Toggling multiple bits between high and low
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高电平和低电平之间切换多个位
- en: 'To toggle multiple bits high or low at once, use the following code:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要同时切换多个位的高低，可以使用以下代码：
- en: '[PRE14]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For example, to toggle the output from PORTB’s PB0 and PB3 you could use:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要切换PORTB的PB0和PB3的输出，可以使用：
- en: '[PRE15]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Again, you can add additional addressing to the same line. For example, to
    toggle PB0, PB3, and PB7, you could use:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，你可以在同一行中添加额外的寻址。例如，要切换PB0、PB3和PB7，你可以使用：
- en: '[PRE16]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Turning multiple bits low
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个位设为低电平
- en: To turn multiple bits off at once, use the following code.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要一次性关闭多个位，可以使用以下代码。
- en: '[PRE17]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this case we use the `&~` characters between the bracketed operations, rather
    than the pipe ( `|` ) character. For example, to turn off the output from PORTB’s
    PB7 and PB0, you could use:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在括号操作之间使用`&~`字符，而不是管道符（`|`）字符。例如，要关闭PORTB的PB7和PB0的输出，可以使用：
- en: '[PRE18]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And to turn off PB0, PB3, and PB7 all at once you could use:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要同时关闭PB0、PB3和PB7，你可以使用：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we’ve reviewed all these bitwise operations for addressing registers,
    let’s see how we could use them to improve some of our earlier code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了所有这些用于寻址寄存器的位操作，让我们看看如何利用它们来改进我们之前的代码。
- en: '[Project 30: Experimenting with Overflow Timers Using Bitwise Operations](nsp-boxall502581-0008.xhtml#rpro30)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目30：使用位操作实验溢出定时器](nsp-boxall502581-0008.xhtml#rpro30)'
- en: This project has the same results as [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    , but I’ve rewritten the code to take advantage of bitwise operations for addressing
    registers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的结果与[项目27](nsp-boxall502581-0016.xhtml#pro27)相同，但我已经重写了代码，利用位操作来寻址寄存器。
- en: Use the same hardware used in [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    . With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the usual way. Open a terminal window, navigate to
    the *Project 30* subfolder of this book’s *Chapter 6* folder, and enter the command
    `make flash` . Once the code has been uploaded to the microcontroller the LED
    connected to PB0 should start to blink rapidly, and the LED connected to PB1 should
    quickly flicker on and off every 0.52428 seconds.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与[项目27](nsp-boxall502581-0016.xhtml#pro27)相同的硬件。组装好电路后，将USBasp通过无焊接面包板连接到你的微控制器。打开一个终端窗口，进入本书*第6章*文件夹中的*项目30*子文件夹，并输入命令`make
    flash`。上传代码到微控制器后，连接到PB0的LED应该开始快速闪烁，而连接到PB1的LED则会每0.52428秒快速闪烁一次。
- en: 'To see how the updated code works, open the *main.c* file for [Project 30](nsp-boxall502581-0016.xhtml#pro30)
    :'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更新后的代码如何工作，打开[项目30](nsp-boxall502581-0016.xhtml#pro30)中的*main.c*文件：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this code, the LED blinks on and off in turn when the code calls the ISR
    ❶❷. When setting the prescaler, we only need to set `CS11` to 1 ❸, as `CS10` remains
    0 for a prescaler of 8, as you’ll recall from [Table 6-1](nsp-boxall502581-0016.xhtml#tab0601)
    . (Remember, bits are 0 by default.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，当代码调用ISR ❶❷时，LED会依次闪烁。当设置预分频器时，我们只需要将`CS11`设置为1 ❸，因为`CS10`保持为0，表示预分频器为8，这一点可以从[表6-1](nsp-boxall502581-0016.xhtml#tab0601)中回忆起。（记住，位的默认值是0。）
- en: We enable the TIMER1 overflow interrupts by setting bit `TOIE1` of the TIMSK1
    register to 1 ❹, then set the PB0 and PB1 pins of PORTB to outputs for our LEDs
    ❺. Finally, we toggle PB0 on and off in order to flash the LED ❻.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将TIMSK1寄存器的`TOIE1`位设置为1 ❹来启用TIMER1溢出中断，然后将PORTB的PB0和PB1引脚设置为输出，以控制我们的LED
    ❺。最后，我们反转PB0的状态，以便闪烁LED ❻。
- en: I encourage you to spend some time getting comfortable with the registers we
    have used so far in the book—PORTB, DDRB, and so on—and experimenting with previous
    projects to familiarize yourself with bitwise methods of addressing registers.
    These methods will come in handy in the [next chapter](nsp-boxall502581-0017.xhtml#ch07)
    , as we begin using pulse-width modulation to experiment with LEDs, motors, and
    more.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你花些时间熟悉到目前为止在本书中使用的寄存器——PORTB、DDRB等，并通过之前的项目进行实验，熟悉寄存器的位操作方法。这些方法在[下一章](nsp-boxall502581-0017.xhtml#ch07)中会非常有用，因为我们将开始使用脉宽调制来实验LED、马达等。
