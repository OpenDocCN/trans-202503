- en: '[6](nsp-boxall502581-0008.xhtml#rch06)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[6](nsp-boxall502581-0008.xhtml#rch06)'
- en: Using Hardware Timers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用硬件定时器
- en: '![](images/nsp-boxall502581-ct.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-boxall502581-ct.jpg)'
- en: We use timers to determine when we want a period of time to elapse before an
    action takes place, which can be incredibly useful. For example, you can set an
    interrupt to trigger when a timer reaches a certain value. Timers operate in the
    background; while the microcontroller runs your code, the timers are counting
    away.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用定时器来确定在某个动作发生前需要经过多长时间，这非常有用。例如，你可以设置一个中断，当定时器达到某个值时触发。定时器在后台运行；当微控制器执行代码时，定时器在不断计数。
- en: 'In this chapter, you’ll learn about:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: • Various timers in your ATmega328P-PU microcontroller
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 你在 ATmega328P-PU 微控制器中的各种定时器
- en: • Timer overflow interrupts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 定时器溢出中断
- en: • Clear Timer on Compare Match interrupts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 比较匹配中断时清除定时器
- en: I’ll show you how to run parts of code on a regular basis, create longer delays
    for repetitive actions, and examine the accuracy of internal timers. You’ll also
    learn a more efficient method of addressing individual bits inside a register.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你展示如何定期运行部分代码，为重复的操作创建更长的延迟，并检查内部定时器的准确性。你还将学习一种更高效的方法，来处理寄存器内的单个位。
- en: '[Introducing Timers](nsp-boxall502581-0008.xhtml#rah0801)'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[定时器简介](nsp-boxall502581-0008.xhtml#rah0801)'
- en: Both our AVR microcontrollers have several timers, each of which contains an
    incrementing counting variable whose value is stored in a *counter register* .
    Once a counter reaches its maximum value, a bit in a register changes, and the
    counter resets to zero and starts over. Beyond using timers to trigger interrupts,
    you can use them to measure elapsed time with some clever arithmetic based on
    the incrementing variable’s progress.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 AVR 微控制器都有多个定时器，每个定时器包含一个递增的计数变量，其值存储在*计数寄存器* 中。一旦计数器达到最大值，寄存器中的一个位会改变，计数器会重置为零并重新开始。除了使用定时器触发中断外，你还可以利用它们通过一些巧妙的算术计算来测量经过的时间，基于递增变量的进度。
- en: The ATmega328P-PU has three timers—TIMER0, TIMER1, and TIMER2—with their own
    counter registers. TIMER0 and TIMER2 are 8-bit counters with a maximum value of
    255\. TIMER1 is a 16-bit counter and has a maximum value of 65,535\. The ATtiny85
    also has timers, but as the ATmega is more versatile given its higher number of
    I/O pins, we’ll only discuss the latter in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ATmega328P-PU 有三个定时器——TIMER0、TIMER1 和 TIMER2——每个定时器都有自己的计数寄存器。TIMER0 和 TIMER2
    是 8 位计数器，最大值为 255。TIMER1 是 16 位计数器，最大值为 65,535。ATtiny85 也有定时器，但由于 ATmega 具有更多的
    I/O 引脚，功能更强大，本章我们只讨论 ATmega。
- en: Timers need a *clock source* to count accurate periods of time. A clock source
    is an oscillator circuit with an output that changes between high and low at a
    precise frequency. You can use either the internal or an external clock source.
    In this chapter we’ll use the microcontroller’s internal clock source, and I’ll
    show you how to use an external clock source when this is necessary in later chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器需要一个 *时钟源* 来准确计数时间周期。时钟源是一个振荡电路，其输出在精确的频率下在高低之间变化。你可以使用内部时钟源或外部时钟源。在本章中，我们将使用微控制器的内部时钟源，稍后的章节中我会向你展示如何在需要时使用外部时钟源。
- en: 'Up to this point, our microcontrollers have been running at a speed of 1 MHz,
    and you can use their internal clock sources to drive the timers. We determine
    the period of time between each increment of the timer’s counter with this simple
    formula:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的微控制器以 1 MHz 的速度运行，你可以使用它们的内部时钟源来驱动定时器。我们通过这个简单的公式来确定定时器计数器每次增量之间的时间间隔：
- en: '*T* = 1 / *f*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* = 1 / *f*'
- en: where *f* is frequency in Hz and *T* is time in seconds. For example, we calculate
    the period at 1 MHz as *T* = 1 / 1,000,000, which results in a value of one millionth
    of a second, known as one microsecond.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *f* 是频率（Hz），*T* 是时间（秒）。例如，我们计算 1 MHz 时的周期为 *T* = 1 / 1,000,000，结果是百万分之一秒，也就是一微秒。
- en: 'You can adjust the length of the period by using a *prescaler* , a number used
    to divide the frequency to increase the period time. You use the prescaler when
    you need to measure amounts of time that exceed the default duration of one of
    the timers. Five prescalers are available: 1, 8, 64, 256, and 1,024.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 *预分频器* 来调整周期的长度，预分频器是一个数字，用来将频率除以，从而增加周期时间。当你需要测量超出定时器默认时长的时间时，可以使用预分频器。提供五种预分频器：1、8、64、256
    和 1,024。
- en: 'To calculate a period altered by a prescaler, we use the following formula:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算通过预分频器调整的周期，我们使用以下公式：
- en: '*T* = 1 / (1,000,000 / *p* )'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* = 1 / (1,000,000 / *p* )'
- en: where *T* is time in seconds and *p* is the prescaler value. We can then determine
    the length of time before a given register resets. For example, to determine the
    length of time elapsed before reset for TIMER1, you would multiply the resulting
    value of *T* for your chosen prescaler by the maximum value of the TIMER1 counter
    (65,535). If your prescaler is 8, your time per period is 0.00008 seconds, so
    you’d multiply 65,535 by 0.00008 to get 0.52428 seconds. This means TIMER1 will
    reset after 0.52428 seconds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: I’ve already calculated the values for the TIMER1 counter, for your convenience;
    they’re listed in [Table 6-1](nsp-boxall502581-0016.xhtml#tab0601) .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 6-1 : Prescaler Values for the TCCR1B Register at 1 MHz and Their Period
    Times |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| Prescaler type | Period (s) | Bit 2 | Bit 1 | Bit 0 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| /1 (none) | 0.000001 | 0 | 0 | 0 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| /8 | 0.000008 | 0 | 1 | 0 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| /64 | 0.000064 | 0 | 1 | 1 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| /256 | 0.000256 | 1 | 0 | 0 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| /1024 | 0.001024 | 1 | 0 | 1 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: That’s enough theory for now. In the following projects we’ll put timers to
    work, to increase your understanding.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 27: Experimenting with Timer Overflow and Interrupts](nsp-boxall502581-0008.xhtml#rpro27)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: In the first of our timer demonstrations, you’ll learn how to trigger an ISR
    once a timer counter overflows, using TIMER1\. You’ll also experiment with prescalers
    to alter the length of time before the counter resets.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0801)'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following hardware:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two LEDs
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 560 Ω resistors
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 6-1](nsp-boxall502581-0016.xhtml#f06001)
    .
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 27](images/nsp-boxall502581-f06001.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: Schematic for [Project 27](nsp-boxall502581-0016.xhtml#pro27)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the same way you have for the previous projects.
    Once completed, keep your circuit together, as you’ll use it for the [next project](nsp-boxall502581-0016.xhtml#pro28)
    as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0802)'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 27* subfolder of this book’s
    *Chapter 6* folder, and enter the command `make flash` . The toolchain should
    compile the program file and upload the data to the microcontroller as usual.
    At this point the LED connected to PB0 should blink rapidly, and the LED connected
    to PB1 should quickly flicker on and off about every half-second (every 0.52428 seconds,
    to be exact!).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works. Open the *main.c* file for Project 27:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code includes the function `initOVI()` to initialize TIMER1 for use. First,
    we include the library for interrupts ❶ and define the timer operations ❷—this
    is the code that runs when the timer resets. We then set the prescaler to 8 by
    setting the second bit of the TCCR1B register ❸. This causes the TIMER1 register
    to reset every 0.52428 seconds. Next, we set the TIMSK1 register with 1 as the
    first bit ❹ to enable an interrupt to be called every time the TIMER1 counter
    overflows and resets to initialize the timer operations we defined earlier, and
    call `sei()` to enable interrupts ❺.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Once operating, the LED should blink on and off as instructed in `int main(void)`
    , and the TIMER1 counter will count away at 125 kHz (remember, our clock speed
    is 1 MHz, and we’re using a prescaler of 8), so each counter increment takes 0.000008 seconds.
    With such a tiny length of time for each count, it only takes 0.52428 seconds
    to count from 0 to 65,535, at which point the TIMER1 counter overflows and the
    code calls the interrupt code ❷, which blinks the other LED briefly. TIMER1 resets
    to zero and starts counting again.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Though this code sets the prescaler to 8 using the TCCR1B register, you can
    also select other prescalers by setting bits 2, 1, and 0 of the register using
    the values shown in [Table 6-1](nsp-boxall502581-0016.xhtml#tab0601) . Spend some
    time changing the bits for the TCCR1B register with your [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    hardware to experiment with the way this impacts the timing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In the [next project](nsp-boxall502581-0016.xhtml#pro28) , I’ll show you how
    to run a section of code on a recurring, regular basis.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 28: Using a CTC Timer for Repetitive Actions](nsp-boxall502581-0008.xhtml#rpro28)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '*Clear Timer on Compare Match (CTC)* is a different method of timing that calls
    an ISR once a timer’s counter has reached a certain value, then resets the timer
    to zero and starts it counting again. The CTC timing mode is useful when you want
    to run a section of code on a recurring basis.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll learn how to trigger an ISR every time a counter reaches
    15 seconds, again using TIMER1\. To determine the duration value, first calculate
    the number of elapsed periods per second for the timer, using the values in [Table
    6-1](nsp-boxall502581-0016.xhtml#tab0601) . We’ll use the 1,024 prescaler (if
    you need a longer duration, you can use an appropriate prescaler). This gives
    us 14,648 periods (rounded down), to which we add 1 to account for the time required
    for the timer to be reset back to zero. Our code should now check the TIMER1 counter
    value. Once it reaches 14,649, the code calls the ISR and then resets the counter
    to zero.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Use the same hardware for this project as for [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    . With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the same way you have for the previous projects.
    Again, keep the circuit together when you’re done so you can use it in the [next
    project](nsp-boxall502581-0016.xhtml#pro29) .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 28* subfolder of this book’s
    *Chapter 6* folder, and enter the command `make flash` . Once the project’s code
    has been uploaded to the microcontroller the LED connected to PB0 should start
    to blink rapidly, and the LED connected to PB1 should briefly turn on and off
    every 15 seconds.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works. Open the *main.c* file for [Project 28](nsp-boxall502581-0016.xhtml#pro28)
    :'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code includes an `initCTC()` function ❸, which we use to set up our timer.
    We tell the code to run the ISR when the timer reaches the value 14,649 by setting
    OCR1A to `14649` ❹. Then we set the prescaler to 1,024 ❺ and turn on the timer
    compare interrupt feature ❻.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The main code begins by running the `initCTC()` function, then merrily blinks
    the LED connected to PB0\. Once the TIMER1 counter reaches 14,649 (our 15-second
    mark), the ISR code ❶ will run. Inside the ISR, the code first resets TIMER1 to
    zero ❷, then blinks the LED connected to PB1.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: You should now understand how to execute an ISR after a set period of time.
    Experiment with prescalers and values for some practice, then we’ll move on to
    using CTC for longer delays in code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 29: Using CTC Timers for Repetitive Actions with Longer Delays](nsp-boxall502581-0008.xhtml#rpro29)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you’ll want to set up a recurring event over a longer period than
    the one in [Project 28](nsp-boxall502581-0016.xhtml#pro28) —perhaps every 15 minutes
    rather than every 15 seconds. Due to the size of the OCR1A register (65,535) we
    can’t just enter a very large number to count up to a long period of time and
    expect the CTC timer to work, so we need to use a small workaround. We set up
    a CTC timer as per [Project 28](nsp-boxall502581-0016.xhtml#pro28) that triggers
    the ISR once per second. We then count those seconds, and when the desired delay
    has elapsed, we call a function to execute the required code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'In more detail, to set up a longer period between recurring events, we do the
    following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Use a global variable to store the target delay value we wish to use for
    our period (measured in seconds).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Use another global variable to store the number of elapsed seconds in the
    delay.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Set the CTC timer to watch for durations of one second.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Have the ISR (called every second) add one to the elapsed seconds variable,
    then check that it has reached the target delay value—and if so, execute the required
    code.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this approach you can implement a variation of multitasking, as you’ll
    see in the following project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Use the same hardware as in [Project 28](nsp-boxall502581-0016.xhtml#pro28)
    . With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the same way you have for the previous projects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Next, open a terminal window, navigate to the *Project 29* subfolder of this
    book’s *Chapter 6* folder, and enter the command `make flash` . The tool chain
    should compile the program file and then upload the data to the microcontroller.
    At this point the LED connected to PB0 should blink rapidly, and the LED connected
    to PB1 should briefly turn on and off every second.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works. Open the *main.c* file for [Project 29](nsp-boxall502581-0016.xhtml#pro29)
    :'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this stage you should be quite familiar with most of this code, such as the
    `ISR()` function, but there are a few new components. First, there are two new
    global variables, `uint16_t target` ❶ and `uint16_t targetCount` ❷. We set `target`
    to the number of seconds to wait while the required code runs ❸. In this example
    `target` is set to 1, but you can set it to anything up to 32,767 (for 546.116 . . .
    minutes), as this is the highest value that can be stored in a 16-bit integer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The ISR uses the variable `targetCount` to accumulate elapsed seconds, as every
    time the code calls the ISR (once per second), it increments `targetCount` by
    1 ❹. When the code calls the ISR, it checks to see if `target Count` matches `target`
    ❺. If so, the code resets TIMER1 to zero ❻, then runs the required code via the
    function `targetFunction()` ❼, and finally resets `targetCount` back to zero ❽,
    allowing the process to start again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Although our example runs the `targetFunction()` code once per second, remember
    that you can easily increase the duration by changing the value for `target` .
    For example, to run `targetFunction()` every 5 minutes, change `target` to 300
    (5 minutes × 60 seconds = 300 seconds).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve had some opportunities to experiment with the AVR’s ATmega’s
    timers, I’d like to briefly discuss the accuracy of the internal timers themselves.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[Examining the Accuracy of the Internal Timer](nsp-boxall502581-0008.xhtml#rah0802)'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be wondering how accurately the internal timer can keep time. You can
    easily check this by running the [Project 29](nsp-boxall502581-0016.xhtml#pro29)
    code (with a one-second interval) and measuring the results with a digital storage
    oscilloscope, as shown in [Figure 6-2](nsp-boxall502581-0016.xhtml#f06002) .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the outputs from Project 29 in two channels of a digital storage
    oscilloscope](images/nsp-boxall502581-f06002.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: Measuring the outputs of [Project 29](nsp-boxall502581-0016.xhtml#pro29)
    using a DSO'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The blinking LED on PB0 is connected to channel 1 (the upper signal) of the
    DSO, while the LED on PB2 that `targetFunction()` controls is connected to channel
    2 (the lower signal). You should see the signal rise and fall as the LED on PB0
    turns on then off every 100 milliseconds. The signal for the first LED stays low
    while the code controlling the second LED on PB1 operates, as the microcontroller
    cannot operate two things at the same time. After the one second has elapsed,
    the other LED on PB0 connected to channel 1 turns on and off as directed by `targetFunction()`
    , and the whole process repeats.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: In this case the DSO has measured the frequency for the second LED as 1.018
    Hz, or 1.018 times per second—this is awfully close to the required 1 second.
    Considering we’re not using any external timing hardware on the circuit, this
    is a good outcome. However, if you’d like to run much longer delay periods, you’ll
    need to take such slight variances into account. For example, that 0.018 Hz imbalance
    from 1 second can equate to 5.4 seconds over a 5-minute period (the actual time
    of 5.4 seconds is calculated by multiplying 0.018 Hz by 300 seconds). Keep this
    in mind in your future timing projects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[Addressing Registers with Bitwise Operations](nsp-boxall502581-0008.xhtml#rah0803)'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the beginning of this book, we’ve been addressing various registers using
    the binary number format. For example, with an ATmega328P-PU, we use the following
    two lines of code to set pin PB0 as an output and turn it on:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method has worked well for us so far, but it requires us to consider every
    bit in the register every time we address one or more bits inside the entire register.
    In this section I’ll show you how to use bitwise operations, which allow us to
    change just a particular bit (or bits) in a register, leaving the others as they
    were. This will be useful for future projects in the book and beyond, as it allows
    you to easily set individual or multiple bits without worrying about changing
    all the bits in a register at once.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[Addressing Individual Bits in a Register](nsp-boxall502581-0008.xhtml#rbh0803)'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, all bits in a register are set to 0 (low, or off) when we reset
    or turn on the microcontroller. We then set bits to 1 (high, or on) or 0 when
    required, using the following operations:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Turning a bit to high
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to turn a bit to high (on) by setting it to 1:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For example, to turn on the output from PORTB’s PB7, you would use the following
    line, since 7 is the bit number in the PORTB register matching pin PB7:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This allows you to turn on PB7 without needing to concern yourself with the
    status of the other bits in the register.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Toggling a bit between high and low
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To *toggle* a bit is to change it from its current state to the alternate state
    (from off to on, or vice versa). Use the following code to do so:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For example, to toggle the output from PORTB’s PB3 you would use the following
    line, as the bit number in the PORTB register matching pin PB3 is 3:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To demonstrate this, you can blink an LED connected to PB3 with a 250 ms delay
    by using the following two lines in your code’s `for (;;)` loop:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By using bitwise operations you also save space, as the LED blinking example
    only requires two lines of code instead of four.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Turning a bit to low
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following code to turn a bit to low (off) by setting it to 0:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For example, to turn off the output from PORTB’s PB7 you would use the following
    line, as 7 is the bit number in the PORTB register matching pin PB7:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using bitwise operations in this way is more efficient than the binary number
    format we used to work with register bits earlier. However, you can improve on
    this method even further by using the name of the register bit instead of the
    number, which makes it easier to determine which bit is being altered. For example,
    say you want to set bit 0 of TIMSK1 on to enable the TIMER1 overflow interrupt
    used in [Project 27](nsp-boxall502581-0016.xhtml#pro27) . Instead of using `TIMSK1
    = 0b00000001` , you can use `TIMSK1 |= (1 << TOIE1)` .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine which register bit name to use for the corresponding bit number
    ( `TOIE1` rather than `0b00000001` in the previous example), check the data sheets
    for your microcontrollers. If you have not already done so, you can download the
    full data sheets in Adobe PDF format from the Microchip website:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: ATtiny85 data sheet [https://www.microchip.com/wwwproducts/en/ATtiny85/](https://www.microchip.com/wwwproducts/en/ATtiny85/)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: ATmega data sheet [https://www.microchip.com/wwwproducts/en/ATmega328p/](https://www.microchip.com/wwwproducts/en/ATmega328p/)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: You can then learn the bit names to match a given register, such as the TIMSK1
    register, which appears in section 16.11.8 of the ATmega328P-PU’s data sheet,
    as shown in [Figure 6-3](nsp-boxall502581-0016.xhtml#f06003) .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Image of the TIMSK1 register with bit labels included](images/nsp-boxall502581-f06003.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: The ATmega328P-PU TIMSK1 register'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can address a single bit inside a register, next I’ll show you
    how to address two or more bits in the same register without affecting other bits.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[Addressing Multiple Bits in a Register](nsp-boxall502581-0008.xhtml#rbh0804)'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also change more than one bit in a single register at the same time
    (again, without worrying about the bits that you’re not changing) using bitwise
    operations. Note, however, that you have to perform the same operation on all
    the bits—for example, you can turn three bits on in one line, but you can’t turn
    two on and one off in one line. If you need to do the latter, use the binary number
    method instead. Here’s how this works:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Turning multiple bits high
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn two bits on at once, use the following code:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For example, to turn on the output from PORTB’s PB0 and PB7, you could use:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can add additional addressing to the same line. For example, you could
    turn on PB0, PB3, and PB7 as follows:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在同一行中添加额外的寻址。例如，你可以如下所示开启PB0、PB3和PB7：
- en: '[PRE13]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You could use this method to address up to seven bits. If you want to change
    all bits, then use the usual `PORT` `x` function.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用这种方法来寻址最多七个位。如果你想更改所有位，那么就使用常规的`PORT` `x`函数。
- en: Toggling multiple bits between high and low
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高电平和低电平之间切换多个位
- en: 'To toggle multiple bits high or low at once, use the following code:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要同时切换多个位的高低，可以使用以下代码：
- en: '[PRE14]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For example, to toggle the output from PORTB’s PB0 and PB3 you could use:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要切换PORTB的PB0和PB3的输出，可以使用：
- en: '[PRE15]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Again, you can add additional addressing to the same line. For example, to
    toggle PB0, PB3, and PB7, you could use:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，你可以在同一行中添加额外的寻址。例如，要切换PB0、PB3和PB7，你可以使用：
- en: '[PRE16]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Turning multiple bits low
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个位设为低电平
- en: To turn multiple bits off at once, use the following code.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要一次性关闭多个位，可以使用以下代码。
- en: '[PRE17]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this case we use the `&~` characters between the bracketed operations, rather
    than the pipe ( `|` ) character. For example, to turn off the output from PORTB’s
    PB7 and PB0, you could use:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在括号操作之间使用`&~`字符，而不是管道符（`|`）字符。例如，要关闭PORTB的PB7和PB0的输出，可以使用：
- en: '[PRE18]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And to turn off PB0, PB3, and PB7 all at once you could use:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要同时关闭PB0、PB3和PB7，你可以使用：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we’ve reviewed all these bitwise operations for addressing registers,
    let’s see how we could use them to improve some of our earlier code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了所有这些用于寻址寄存器的位操作，让我们看看如何利用它们来改进我们之前的代码。
- en: '[Project 30: Experimenting with Overflow Timers Using Bitwise Operations](nsp-boxall502581-0008.xhtml#rpro30)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[项目30：使用位操作实验溢出定时器](nsp-boxall502581-0008.xhtml#rpro30)'
- en: This project has the same results as [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    , but I’ve rewritten the code to take advantage of bitwise operations for addressing
    registers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的结果与[项目27](nsp-boxall502581-0016.xhtml#pro27)相同，但我已经重写了代码，利用位操作来寻址寄存器。
- en: Use the same hardware used in [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    . With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the usual way. Open a terminal window, navigate to
    the *Project 30* subfolder of this book’s *Chapter 6* folder, and enter the command
    `make flash` . Once the code has been uploaded to the microcontroller the LED
    connected to PB0 should start to blink rapidly, and the LED connected to PB1 should
    quickly flicker on and off every 0.52428 seconds.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与[项目27](nsp-boxall502581-0016.xhtml#pro27)相同的硬件。组装好电路后，将USBasp通过无焊接面包板连接到你的微控制器。打开一个终端窗口，进入本书*第6章*文件夹中的*项目30*子文件夹，并输入命令`make
    flash`。上传代码到微控制器后，连接到PB0的LED应该开始快速闪烁，而连接到PB1的LED则会每0.52428秒快速闪烁一次。
- en: 'To see how the updated code works, open the *main.c* file for [Project 30](nsp-boxall502581-0016.xhtml#pro30)
    :'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更新后的代码如何工作，打开[项目30](nsp-boxall502581-0016.xhtml#pro30)中的*main.c*文件：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this code, the LED blinks on and off in turn when the code calls the ISR
    ❶❷. When setting the prescaler, we only need to set `CS11` to 1 ❸, as `CS10` remains
    0 for a prescaler of 8, as you’ll recall from [Table 6-1](nsp-boxall502581-0016.xhtml#tab0601)
    . (Remember, bits are 0 by default.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，当代码调用ISR ❶❷时，LED会依次闪烁。当设置预分频器时，我们只需要将`CS11`设置为1 ❸，因为`CS10`保持为0，表示预分频器为8，这一点可以从[表6-1](nsp-boxall502581-0016.xhtml#tab0601)中回忆起。（记住，位的默认值是0。）
- en: We enable the TIMER1 overflow interrupts by setting bit `TOIE1` of the TIMSK1
    register to 1 ❹, then set the PB0 and PB1 pins of PORTB to outputs for our LEDs
    ❺. Finally, we toggle PB0 on and off in order to flash the LED ❻.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将TIMSK1寄存器的`TOIE1`位设置为1 ❹来启用TIMER1溢出中断，然后将PORTB的PB0和PB1引脚设置为输出，以控制我们的LED
    ❺。最后，我们反转PB0的状态，以便闪烁LED ❻。
- en: I encourage you to spend some time getting comfortable with the registers we
    have used so far in the book—PORTB, DDRB, and so on—and experimenting with previous
    projects to familiarize yourself with bitwise methods of addressing registers.
    These methods will come in handy in the [next chapter](nsp-boxall502581-0017.xhtml#ch07)
    , as we begin using pulse-width modulation to experiment with LEDs, motors, and
    more.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你花些时间熟悉到目前为止在本书中使用的寄存器——PORTB、DDRB等，并通过之前的项目进行实验，熟悉寄存器的位操作方法。这些方法在[下一章](nsp-boxall502581-0017.xhtml#ch07)中会非常有用，因为我们将开始使用脉宽调制来实验LED、马达等。
