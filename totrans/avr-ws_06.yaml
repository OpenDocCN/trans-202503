- en: '[6](nsp-boxall502581-0008.xhtml#rch06)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Hardware Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-ct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We use timers to determine when we want a period of time to elapse before an
    action takes place, which can be incredibly useful. For example, you can set an
    interrupt to trigger when a timer reaches a certain value. Timers operate in the
    background; while the microcontroller runs your code, the timers are counting
    away.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: • Various timers in your ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Timer overflow interrupts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Clear Timer on Compare Match interrupts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll show you how to run parts of code on a regular basis, create longer delays
    for repetitive actions, and examine the accuracy of internal timers. You’ll also
    learn a more efficient method of addressing individual bits inside a register.
  prefs: []
  type: TYPE_NORMAL
- en: '[Introducing Timers](nsp-boxall502581-0008.xhtml#rah0801)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both our AVR microcontrollers have several timers, each of which contains an
    incrementing counting variable whose value is stored in a *counter register* .
    Once a counter reaches its maximum value, a bit in a register changes, and the
    counter resets to zero and starts over. Beyond using timers to trigger interrupts,
    you can use them to measure elapsed time with some clever arithmetic based on
    the incrementing variable’s progress.
  prefs: []
  type: TYPE_NORMAL
- en: The ATmega328P-PU has three timers—TIMER0, TIMER1, and TIMER2—with their own
    counter registers. TIMER0 and TIMER2 are 8-bit counters with a maximum value of
    255\. TIMER1 is a 16-bit counter and has a maximum value of 65,535\. The ATtiny85
    also has timers, but as the ATmega is more versatile given its higher number of
    I/O pins, we’ll only discuss the latter in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Timers need a *clock source* to count accurate periods of time. A clock source
    is an oscillator circuit with an output that changes between high and low at a
    precise frequency. You can use either the internal or an external clock source.
    In this chapter we’ll use the microcontroller’s internal clock source, and I’ll
    show you how to use an external clock source when this is necessary in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to this point, our microcontrollers have been running at a speed of 1 MHz,
    and you can use their internal clock sources to drive the timers. We determine
    the period of time between each increment of the timer’s counter with this simple
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T* = 1 / *f*'
  prefs: []
  type: TYPE_NORMAL
- en: where *f* is frequency in Hz and *T* is time in seconds. For example, we calculate
    the period at 1 MHz as *T* = 1 / 1,000,000, which results in a value of one millionth
    of a second, known as one microsecond.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can adjust the length of the period by using a *prescaler* , a number used
    to divide the frequency to increase the period time. You use the prescaler when
    you need to measure amounts of time that exceed the default duration of one of
    the timers. Five prescalers are available: 1, 8, 64, 256, and 1,024.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate a period altered by a prescaler, we use the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T* = 1 / (1,000,000 / *p* )'
  prefs: []
  type: TYPE_NORMAL
- en: where *T* is time in seconds and *p* is the prescaler value. We can then determine
    the length of time before a given register resets. For example, to determine the
    length of time elapsed before reset for TIMER1, you would multiply the resulting
    value of *T* for your chosen prescaler by the maximum value of the TIMER1 counter
    (65,535). If your prescaler is 8, your time per period is 0.00008 seconds, so
    you’d multiply 65,535 by 0.00008 to get 0.52428 seconds. This means TIMER1 will
    reset after 0.52428 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve already calculated the values for the TIMER1 counter, for your convenience;
    they’re listed in [Table 6-1](nsp-boxall502581-0016.xhtml#tab0601) .
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 6-1 : Prescaler Values for the TCCR1B Register at 1 MHz and Their Period
    Times |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Prescaler type | Period (s) | Bit 2 | Bit 1 | Bit 0 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| /1 (none) | 0.000001 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| /8 | 0.000008 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| /64 | 0.000064 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| /256 | 0.000256 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| /1024 | 0.001024 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: That’s enough theory for now. In the following projects we’ll put timers to
    work, to increase your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 27: Experimenting with Timer Overflow and Interrupts](nsp-boxall502581-0008.xhtml#rpro27)'
  prefs: []
  type: TYPE_NORMAL
- en: In the first of our timer demonstrations, you’ll learn how to trigger an ISR
    once a timer counter overflows, using TIMER1\. You’ll also experiment with prescalers
    to alter the length of time before the counter resets.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0801)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Two 560 Ω resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 6-1](nsp-boxall502581-0016.xhtml#f06001)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 27](images/nsp-boxall502581-f06001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: Schematic for [Project 27](nsp-boxall502581-0016.xhtml#pro27)'
  prefs: []
  type: TYPE_NORMAL
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the same way you have for the previous projects.
    Once completed, keep your circuit together, as you’ll use it for the [next project](nsp-boxall502581-0016.xhtml#pro28)
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0802)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 27* subfolder of this book’s
    *Chapter 6* folder, and enter the command `make flash` . The toolchain should
    compile the program file and upload the data to the microcontroller as usual.
    At this point the LED connected to PB0 should blink rapidly, and the LED connected
    to PB1 should quickly flicker on and off about every half-second (every 0.52428 seconds,
    to be exact!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works. Open the *main.c* file for Project 27:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code includes the function `initOVI()` to initialize TIMER1 for use. First,
    we include the library for interrupts ❶ and define the timer operations ❷—this
    is the code that runs when the timer resets. We then set the prescaler to 8 by
    setting the second bit of the TCCR1B register ❸. This causes the TIMER1 register
    to reset every 0.52428 seconds. Next, we set the TIMSK1 register with 1 as the
    first bit ❹ to enable an interrupt to be called every time the TIMER1 counter
    overflows and resets to initialize the timer operations we defined earlier, and
    call `sei()` to enable interrupts ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Once operating, the LED should blink on and off as instructed in `int main(void)`
    , and the TIMER1 counter will count away at 125 kHz (remember, our clock speed
    is 1 MHz, and we’re using a prescaler of 8), so each counter increment takes 0.000008 seconds.
    With such a tiny length of time for each count, it only takes 0.52428 seconds
    to count from 0 to 65,535, at which point the TIMER1 counter overflows and the
    code calls the interrupt code ❷, which blinks the other LED briefly. TIMER1 resets
    to zero and starts counting again.
  prefs: []
  type: TYPE_NORMAL
- en: Though this code sets the prescaler to 8 using the TCCR1B register, you can
    also select other prescalers by setting bits 2, 1, and 0 of the register using
    the values shown in [Table 6-1](nsp-boxall502581-0016.xhtml#tab0601) . Spend some
    time changing the bits for the TCCR1B register with your [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    hardware to experiment with the way this impacts the timing.
  prefs: []
  type: TYPE_NORMAL
- en: In the [next project](nsp-boxall502581-0016.xhtml#pro28) , I’ll show you how
    to run a section of code on a recurring, regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 28: Using a CTC Timer for Repetitive Actions](nsp-boxall502581-0008.xhtml#rpro28)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Clear Timer on Compare Match (CTC)* is a different method of timing that calls
    an ISR once a timer’s counter has reached a certain value, then resets the timer
    to zero and starts it counting again. The CTC timing mode is useful when you want
    to run a section of code on a recurring basis.'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll learn how to trigger an ISR every time a counter reaches
    15 seconds, again using TIMER1\. To determine the duration value, first calculate
    the number of elapsed periods per second for the timer, using the values in [Table
    6-1](nsp-boxall502581-0016.xhtml#tab0601) . We’ll use the 1,024 prescaler (if
    you need a longer duration, you can use an appropriate prescaler). This gives
    us 14,648 periods (rounded down), to which we add 1 to account for the time required
    for the timer to be reset back to zero. Our code should now check the TIMER1 counter
    value. Once it reaches 14,649, the code calls the ISR and then resets the counter
    to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Use the same hardware for this project as for [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    . With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the same way you have for the previous projects.
    Again, keep the circuit together when you’re done so you can use it in the [next
    project](nsp-boxall502581-0016.xhtml#pro29) .
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 28* subfolder of this book’s
    *Chapter 6* folder, and enter the command `make flash` . Once the project’s code
    has been uploaded to the microcontroller the LED connected to PB0 should start
    to blink rapidly, and the LED connected to PB1 should briefly turn on and off
    every 15 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works. Open the *main.c* file for [Project 28](nsp-boxall502581-0016.xhtml#pro28)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code includes an `initCTC()` function ❸, which we use to set up our timer.
    We tell the code to run the ISR when the timer reaches the value 14,649 by setting
    OCR1A to `14649` ❹. Then we set the prescaler to 1,024 ❺ and turn on the timer
    compare interrupt feature ❻.
  prefs: []
  type: TYPE_NORMAL
- en: The main code begins by running the `initCTC()` function, then merrily blinks
    the LED connected to PB0\. Once the TIMER1 counter reaches 14,649 (our 15-second
    mark), the ISR code ❶ will run. Inside the ISR, the code first resets TIMER1 to
    zero ❷, then blinks the LED connected to PB1.
  prefs: []
  type: TYPE_NORMAL
- en: You should now understand how to execute an ISR after a set period of time.
    Experiment with prescalers and values for some practice, then we’ll move on to
    using CTC for longer delays in code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 29: Using CTC Timers for Repetitive Actions with Longer Delays](nsp-boxall502581-0008.xhtml#rpro29)'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you’ll want to set up a recurring event over a longer period than
    the one in [Project 28](nsp-boxall502581-0016.xhtml#pro28) —perhaps every 15 minutes
    rather than every 15 seconds. Due to the size of the OCR1A register (65,535) we
    can’t just enter a very large number to count up to a long period of time and
    expect the CTC timer to work, so we need to use a small workaround. We set up
    a CTC timer as per [Project 28](nsp-boxall502581-0016.xhtml#pro28) that triggers
    the ISR once per second. We then count those seconds, and when the desired delay
    has elapsed, we call a function to execute the required code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more detail, to set up a longer period between recurring events, we do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Use a global variable to store the target delay value we wish to use for
    our period (measured in seconds).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Use another global variable to store the number of elapsed seconds in the
    delay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Set the CTC timer to watch for durations of one second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Have the ISR (called every second) add one to the elapsed seconds variable,
    then check that it has reached the target delay value—and if so, execute the required
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this approach you can implement a variation of multitasking, as you’ll
    see in the following project.
  prefs: []
  type: TYPE_NORMAL
- en: Use the same hardware as in [Project 28](nsp-boxall502581-0016.xhtml#pro28)
    . With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the same way you have for the previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: Next, open a terminal window, navigate to the *Project 29* subfolder of this
    book’s *Chapter 6* folder, and enter the command `make flash` . The tool chain
    should compile the program file and then upload the data to the microcontroller.
    At this point the LED connected to PB0 should blink rapidly, and the LED connected
    to PB1 should briefly turn on and off every second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works. Open the *main.c* file for [Project 29](nsp-boxall502581-0016.xhtml#pro29)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At this stage you should be quite familiar with most of this code, such as the
    `ISR()` function, but there are a few new components. First, there are two new
    global variables, `uint16_t target` ❶ and `uint16_t targetCount` ❷. We set `target`
    to the number of seconds to wait while the required code runs ❸. In this example
    `target` is set to 1, but you can set it to anything up to 32,767 (for 546.116 . . .
    minutes), as this is the highest value that can be stored in a 16-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: The ISR uses the variable `targetCount` to accumulate elapsed seconds, as every
    time the code calls the ISR (once per second), it increments `targetCount` by
    1 ❹. When the code calls the ISR, it checks to see if `target Count` matches `target`
    ❺. If so, the code resets TIMER1 to zero ❻, then runs the required code via the
    function `targetFunction()` ❼, and finally resets `targetCount` back to zero ❽,
    allowing the process to start again.
  prefs: []
  type: TYPE_NORMAL
- en: Although our example runs the `targetFunction()` code once per second, remember
    that you can easily increase the duration by changing the value for `target` .
    For example, to run `targetFunction()` every 5 minutes, change `target` to 300
    (5 minutes × 60 seconds = 300 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve had some opportunities to experiment with the AVR’s ATmega’s
    timers, I’d like to briefly discuss the accuracy of the internal timers themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '[Examining the Accuracy of the Internal Timer](nsp-boxall502581-0008.xhtml#rah0802)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be wondering how accurately the internal timer can keep time. You can
    easily check this by running the [Project 29](nsp-boxall502581-0016.xhtml#pro29)
    code (with a one-second interval) and measuring the results with a digital storage
    oscilloscope, as shown in [Figure 6-2](nsp-boxall502581-0016.xhtml#f06002) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the outputs from Project 29 in two channels of a digital storage
    oscilloscope](images/nsp-boxall502581-f06002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: Measuring the outputs of [Project 29](nsp-boxall502581-0016.xhtml#pro29)
    using a DSO'
  prefs: []
  type: TYPE_NORMAL
- en: The blinking LED on PB0 is connected to channel 1 (the upper signal) of the
    DSO, while the LED on PB2 that `targetFunction()` controls is connected to channel
    2 (the lower signal). You should see the signal rise and fall as the LED on PB0
    turns on then off every 100 milliseconds. The signal for the first LED stays low
    while the code controlling the second LED on PB1 operates, as the microcontroller
    cannot operate two things at the same time. After the one second has elapsed,
    the other LED on PB0 connected to channel 1 turns on and off as directed by `targetFunction()`
    , and the whole process repeats.
  prefs: []
  type: TYPE_NORMAL
- en: In this case the DSO has measured the frequency for the second LED as 1.018
    Hz, or 1.018 times per second—this is awfully close to the required 1 second.
    Considering we’re not using any external timing hardware on the circuit, this
    is a good outcome. However, if you’d like to run much longer delay periods, you’ll
    need to take such slight variances into account. For example, that 0.018 Hz imbalance
    from 1 second can equate to 5.4 seconds over a 5-minute period (the actual time
    of 5.4 seconds is calculated by multiplying 0.018 Hz by 300 seconds). Keep this
    in mind in your future timing projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[Addressing Registers with Bitwise Operations](nsp-boxall502581-0008.xhtml#rah0803)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the beginning of this book, we’ve been addressing various registers using
    the binary number format. For example, with an ATmega328P-PU, we use the following
    two lines of code to set pin PB0 as an output and turn it on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method has worked well for us so far, but it requires us to consider every
    bit in the register every time we address one or more bits inside the entire register.
    In this section I’ll show you how to use bitwise operations, which allow us to
    change just a particular bit (or bits) in a register, leaving the others as they
    were. This will be useful for future projects in the book and beyond, as it allows
    you to easily set individual or multiple bits without worrying about changing
    all the bits in a register at once.
  prefs: []
  type: TYPE_NORMAL
- en: '[Addressing Individual Bits in a Register](nsp-boxall502581-0008.xhtml#rbh0803)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, all bits in a register are set to 0 (low, or off) when we reset
    or turn on the microcontroller. We then set bits to 1 (high, or on) or 0 when
    required, using the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Turning a bit to high
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to turn a bit to high (on) by setting it to 1:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example, to turn on the output from PORTB’s PB7, you would use the following
    line, since 7 is the bit number in the PORTB register matching pin PB7:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows you to turn on PB7 without needing to concern yourself with the
    status of the other bits in the register.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Toggling a bit between high and low
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To *toggle* a bit is to change it from its current state to the alternate state
    (from off to on, or vice versa). Use the following code to do so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example, to toggle the output from PORTB’s PB3 you would use the following
    line, as the bit number in the PORTB register matching pin PB3 is 3:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To demonstrate this, you can blink an LED connected to PB3 with a 250 ms delay
    by using the following two lines in your code’s `for (;;)` loop:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By using bitwise operations you also save space, as the LED blinking example
    only requires two lines of code instead of four.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Turning a bit to low
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following code to turn a bit to low (off) by setting it to 0:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example, to turn off the output from PORTB’s PB7 you would use the following
    line, as 7 is the bit number in the PORTB register matching pin PB7:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using bitwise operations in this way is more efficient than the binary number
    format we used to work with register bits earlier. However, you can improve on
    this method even further by using the name of the register bit instead of the
    number, which makes it easier to determine which bit is being altered. For example,
    say you want to set bit 0 of TIMSK1 on to enable the TIMER1 overflow interrupt
    used in [Project 27](nsp-boxall502581-0016.xhtml#pro27) . Instead of using `TIMSK1
    = 0b00000001` , you can use `TIMSK1 |= (1 << TOIE1)` .
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine which register bit name to use for the corresponding bit number
    ( `TOIE1` rather than `0b00000001` in the previous example), check the data sheets
    for your microcontrollers. If you have not already done so, you can download the
    full data sheets in Adobe PDF format from the Microchip website:'
  prefs: []
  type: TYPE_NORMAL
- en: ATtiny85 data sheet [https://www.microchip.com/wwwproducts/en/ATtiny85/](https://www.microchip.com/wwwproducts/en/ATtiny85/)
  prefs: []
  type: TYPE_NORMAL
- en: ATmega data sheet [https://www.microchip.com/wwwproducts/en/ATmega328p/](https://www.microchip.com/wwwproducts/en/ATmega328p/)
  prefs: []
  type: TYPE_NORMAL
- en: You can then learn the bit names to match a given register, such as the TIMSK1
    register, which appears in section 16.11.8 of the ATmega328P-PU’s data sheet,
    as shown in [Figure 6-3](nsp-boxall502581-0016.xhtml#f06003) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image of the TIMSK1 register with bit labels included](images/nsp-boxall502581-f06003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: The ATmega328P-PU TIMSK1 register'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can address a single bit inside a register, next I’ll show you
    how to address two or more bits in the same register without affecting other bits.
  prefs: []
  type: TYPE_NORMAL
- en: '[Addressing Multiple Bits in a Register](nsp-boxall502581-0008.xhtml#rbh0804)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also change more than one bit in a single register at the same time
    (again, without worrying about the bits that you’re not changing) using bitwise
    operations. Note, however, that you have to perform the same operation on all
    the bits—for example, you can turn three bits on in one line, but you can’t turn
    two on and one off in one line. If you need to do the latter, use the binary number
    method instead. Here’s how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: Turning multiple bits high
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn two bits on at once, use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example, to turn on the output from PORTB’s PB0 and PB7, you could use:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can add additional addressing to the same line. For example, you could
    turn on PB0, PB3, and PB7 as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You could use this method to address up to seven bits. If you want to change
    all bits, then use the usual `PORT` `x` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Toggling multiple bits between high and low
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To toggle multiple bits high or low at once, use the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For example, to toggle the output from PORTB’s PB0 and PB3 you could use:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, you can add additional addressing to the same line. For example, to
    toggle PB0, PB3, and PB7, you could use:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Turning multiple bits low
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To turn multiple bits off at once, use the following code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case we use the `&~` characters between the bracketed operations, rather
    than the pipe ( `|` ) character. For example, to turn off the output from PORTB’s
    PB7 and PB0, you could use:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And to turn off PB0, PB3, and PB7 all at once you could use:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we’ve reviewed all these bitwise operations for addressing registers,
    let’s see how we could use them to improve some of our earlier code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 30: Experimenting with Overflow Timers Using Bitwise Operations](nsp-boxall502581-0008.xhtml#rpro30)'
  prefs: []
  type: TYPE_NORMAL
- en: This project has the same results as [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    , but I’ve rewritten the code to take advantage of bitwise operations for addressing
    registers.
  prefs: []
  type: TYPE_NORMAL
- en: Use the same hardware used in [Project 27](nsp-boxall502581-0016.xhtml#pro27)
    . With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the usual way. Open a terminal window, navigate to
    the *Project 30* subfolder of this book’s *Chapter 6* folder, and enter the command
    `make flash` . Once the code has been uploaded to the microcontroller the LED
    connected to PB0 should start to blink rapidly, and the LED connected to PB1 should
    quickly flicker on and off every 0.52428 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how the updated code works, open the *main.c* file for [Project 30](nsp-boxall502581-0016.xhtml#pro30)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the LED blinks on and off in turn when the code calls the ISR
    ❶❷. When setting the prescaler, we only need to set `CS11` to 1 ❸, as `CS10` remains
    0 for a prescaler of 8, as you’ll recall from [Table 6-1](nsp-boxall502581-0016.xhtml#tab0601)
    . (Remember, bits are 0 by default.)
  prefs: []
  type: TYPE_NORMAL
- en: We enable the TIMER1 overflow interrupts by setting bit `TOIE1` of the TIMSK1
    register to 1 ❹, then set the PB0 and PB1 pins of PORTB to outputs for our LEDs
    ❺. Finally, we toggle PB0 on and off in order to flash the LED ❻.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to spend some time getting comfortable with the registers we
    have used so far in the book—PORTB, DDRB, and so on—and experimenting with previous
    projects to familiarize yourself with bitwise methods of addressing registers.
    These methods will come in handy in the [next chapter](nsp-boxall502581-0017.xhtml#ch07)
    , as we begin using pulse-width modulation to experiment with LEDs, motors, and
    more.
  prefs: []
  type: TYPE_NORMAL
