<html><head></head><body>
<h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_462"/><span epub:type="pagebreak" id="page_463"/><strong><span class="big">14</span><br/>ITERATORS</strong></h2>&#13;
<p class="quote"><em>Say “friend” and enter.<br/>—J.R.R. Tolkein</em>, The Lord of the Rings</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">Iterators are the STL component that provides the interface between containers and algorithms to manipulate them. An iterator is an interface to a type that knows how to traverse a particular sequence and exposes simple, pointer-like operations to elements.</p>&#13;
<p class="indent">Every iterator supports at least the following operations:</p>&#13;
<ul>&#13;
<li class="noindent">Access the current element (<code>operator*</code>) for reading and/or writing</li>&#13;
<li class="noindent">Go to the next element (<code>operator++</code>)</li>&#13;
<li class="noindent">Copy construct</li>&#13;
</ul>&#13;
<p class="indent">Iterators are categorized based on which additional operations they support. These categories determine which algorithms are available and what you can do with an iterator in your generic code. In this chapter, you’ll learn about these iterator categories, convenience functions, and adapters.</p>&#13;
<h3 class="h3" id="ch14lev1sec1"><span epub:type="pagebreak" id="page_464"/><strong>Iterator Categories</strong></h3>&#13;
<p class="noindent">An iterator’s category determines the operations it supports. These operations include reading and writing elements, iterating forward and backward, reading multiple times, and accessing random elements.</p>&#13;
<p class="indent">Because code that accepts an iterator is usually generic, the iterator’s type is typically a template parameter that you can encode with concepts, which you learned about in “Concepts” on <a href="ch06.xhtml#page_163">page 163</a>. Although you probably won't have to interact with iterators directly (unless you’re writing a library), you’ll still need to know the iterator categories so you don’t try to apply an algorithm to inappropriate iterators. If you do, you’re likely to get cryptic compiler errors. Recall from “Type Checking in Templates” on <a href="ch06.xhtml#page_161">page 161</a> that because of how templates instantiate, error messages generated from inappropriate type arguments are usually inscrutable.</p>&#13;
<h4 class="h4" id="ch14lev2sec1"><strong><em>Output Iterators</em></strong></h4>&#13;
<p class="noindent">You can use an <em>output iterator</em> to write into and increment but nothing else. Think of an output iterator as a bottomless pit that you throw data into.</p>&#13;
<p class="indent">When using an output iterator, you write, then increment, then write, then increment, ad nauseam. Once you’ve written to an output iterator, you cannot write again until you’ve incremented at least once. Likewise, once you’ve incremented an output iterator, you cannot increment again before writing.</p>&#13;
<p class="indent">To write to an output iterator, dereference the iterator using the dereference operator (<code>*</code>) and assign a value to the resulting reference. To increment an output iterator, use <code>operator++</code> or <code>operator++(int)</code>.</p>&#13;
<p class="indent">Again, unless you’re writing a C++ library, it’s unlikely that you’ll have to <em>implement</em> your own output iterator types; however, you’ll <em>use</em> them quite a lot.</p>&#13;
<p class="indent">One prominent usage is writing into containers as if they were output iterators. For this, you use insert iterators.</p>&#13;
<h5 class="h5" id="ch14lev3sec1"><strong>Insert Iterators</strong></h5>&#13;
<p class="noindent">An <em>insert iterator</em> (or <em>inserter</em>) is an output iterator that wraps a container and transforms writes (assignments) into insertions. Three insert iterators exist in the STL’s <code>&lt;iterator&gt;</code> header as class templates:</p>&#13;
<ul>&#13;
<li class="noindent"><code>std::back_insert_iterator</code></li>&#13;
<li class="noindent"><code>std::front_insert_iterator</code></li>&#13;
<li class="noindent"><code>std::insert_iterator</code></li>&#13;
</ul>&#13;
<p class="indent">The STL also offers three convenience functions for building these iterators:</p>&#13;
<ul>&#13;
<li class="noindent"><code>std::back_inserter</code></li>&#13;
<li class="noindent"><code>std::front_inserter</code></li>&#13;
<li class="noindent"><code>std::inserter</code></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_465"/>The <code>back_insert_iterator</code> transforms iterator writes into calls to the container’s <code>push_back</code>, whereas <code>front_insert_iterator</code> calls to <code>push_front</code>. Both of these insert iterators expose a single constructor that accepts a container reference, and their corresponding convenience functions take a single argument. Obviously, the wrapped container must implement the appropriate method. For example, a <code>vector</code> won’t work with a <code>front_insert_iterator</code>, and a <code>set</code> won’t work with either of them.</p>&#13;
<p class="indent">The <code>insert_iterator</code> takes two constructor arguments: a container to wrap and an iterator pointing into a position in that container. The <code>insert_iterator</code> then transforms writes into calls to the container’s <code>insert</code> method, and it will pass the position you provided on construction as the first argument. For example, you use the <code>insert_iterator</code> to insert into the middle of a sequential container or to add elements into a <code>set</code> with a hint.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Internally, all the insert iterators completely ignore <code>operator++</code>, <code>operator++(int)</code>, and <code>operator*</code>. Containers don’t need this intermediate step between insertions, but it’s generally a requirement for output iterators.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch14.xhtml#ch14ex01">Listing 14-1</a> illustrates the basic usages of the three insert iterators by adding elements to a <code>deque</code>.</p>&#13;
<pre>#include &lt;deque&gt;&#13;
#include &lt;iterator&gt;&#13;
&#13;
TEST_CASE("Insert iterators convert writes into container insertions.") {&#13;
  std::deque&lt;int&gt; dq;&#13;
  auto back_instr = std::back_inserter(dq); <span class="ent">➊</span>&#13;
  *back_instr = 2; <span class="ent">➋</span> // 2&#13;
  ++back_instr; <span class="ent">➌</span>&#13;
  *back_instr = 4; <span class="ent">➍</span> // 2 4&#13;
  ++back_instr;&#13;
&#13;
  auto front_instr = std::front_inserter(dq); <span class="ent">➎</span>&#13;
  *front_instr = 1; <span class="ent">➏</span> // 1 2 4&#13;
  ++front_instr;&#13;
&#13;
  auto instr = std::inserter(dq, dq.begin()+2); <span class="ent">➐</span>&#13;
  *instr = 3; <span class="ent">➑</span> // 1 2 3 4&#13;
  instr++;&#13;
&#13;
  REQUIRE(dq[0] == 1);&#13;
  REQUIRE(dq[1] == 2);&#13;
  REQUIRE(dq[2] == 3);&#13;
  REQUIRE(dq[3] == 4); <span class="ent">➒</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex01"/><em>Listing 14-1: Insert iterators convert writes into container insertions.</em></p>&#13;
<p class="indent">First, you build a <code>back_insert_iterator</code> with <code>back_inserter</code> to wrap a <code>deque</code> called <code>dq</code> <span class="ent">➊</span>. When you write into the <code>back_insert_iterator</code>, it translates the write into a <code>push_back</code>, so the <code>deque</code> contains a single element, <code>2</code> <span class="ent">➋</span>. Because <span epub:type="pagebreak" id="page_466"/>output iterators require incrementing before you can write again, you follow with an increment <span class="ent">➌</span>. When you write <code>4</code> to the <code>back_insert_iterator</code>, it again translates the write into a <code>push_back</code> so the <code>deque</code> contains the elements <code>2 4</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">Next, you build a <code>front_insert_iterator</code> with <code>front_inserter</code> to wrap <code>dq</code> <span class="ent">➎</span>. Writing <code>1</code> into this newly constructed inserter results in a call to <code>push_front</code>, so the deque contains the elements <code>1 2 4</code> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Finally, you build an <code>insert_iterator</code> with <code>inserter</code> by passing <code>dq</code> and an iterator pointing to its third element (<code>4</code>). When you write 3 into this inserter <span class="ent">➑</span>, it inserts just before the element pointed to by the iterator you passed at construction <span class="ent">➐</span>. This results in <code>dq</code> containing the elements <code>1 2 3 4</code> <span class="ent">➒</span>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14tab01">Table 14-1</a> summarizes the insert iterators.</p>&#13;
<p class="tabcap"><a id="ch14tab01"/><strong>Table 14-1:</strong> Summary of Insert Iterators</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Class</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Convenience function</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Delegated function</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Example containers</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>back_insert_iterator</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>back_inserter</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>push_back</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">vectors, deques, lists</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>front_insert_iterator</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>front_inserter</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>push_front</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">deques, lists</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>insert_iterator</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>inserter</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>insert</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">vectors, deques, lists, sets</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch14lev3sec2"><strong>List of Supported Output Iterator Operations</strong></h5>&#13;
<p class="noindent"><a href="ch14.xhtml#ch14tab02">Table 14-2</a> summarizes the output iterator’s supported operations.</p>&#13;
<p class="tabcap"><a id="ch14tab02"/><strong>Table 14-2:</strong> Output Iterator’s Supported Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>*</code><span class="codestrong">itr</span><code>=</code><span class="codestrong">t</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Writes into the output iterator. After operation, iterator is incrementable but not necessarily dereferencable.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>++</code><span class="codestrong">itr</span></p>&#13;
<p class="taba"><span class="codestrong">itr</span><code>++</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Increments the iterator. After operation, iterator is either dereferencable or exhausted (past the end) but is not necessarily incrementable.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codeitalicstrong">iterator-type</span><code>{</code> <span class="codestrong">itr</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Copy-constructs an iterator from <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch14lev2sec2"><strong><em>Input Iterators</em></strong></h4>&#13;
<p class="noindent">You can use an <em>input iterator</em> to <em>read from</em>, <em>increment</em>, and check for equality. It’s the foil to the output iterator. You can only iterate through an input iterator once.</p>&#13;
<p class="indent">The usual pattern when reading from an input iterator is to obtain a half-open range with a <em>begin</em> and an <em>end</em> iterator. To read through the range, you read the <code>begin</code> iterator using <code>operator*</code> followed by an increment with <code>operator++</code>. Next, you evaluate whether the iterator equals <code>end</code>. If it does, you’ve exhausted the range. If it doesn’t, you can continue reading/incrementing.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Input iterators are the magic that makes the range expressions discussed in “Range-Based <code>for</code> Loops” on <a href="ch08.xhtml#page_234">page 234</a> work.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_467"/>A canonical usage of an input iterator is to wrap a program’s standard input (usually the keyboard). Once you’ve read a value from standard input, it’s gone. You cannot go back to the beginning and replay. This behavior matches an input iterator’s supported operations really well.</p>&#13;
<p class="indent">In “A Crash Course in Iterators” on <a href="ch13.xhtml#page_412">page 412</a>, you learned that every container exposes iterators with <code>begin</code>/<code>cbegin</code>/<code>end</code>/<code>cend</code> methods. All of these methods are <em>at least</em> input iterators (and they might support additional functionality). For example, <a href="ch14.xhtml#ch14ex02">Listing 14-2</a> illustrates how to extract a range from a <code>forward_list</code> and manipulate the iterators manually for reading.</p>&#13;
<pre>#include &lt;forward_list&gt;&#13;
&#13;
TEST_CASE("std::forward_list begin and end provide input iterators") {&#13;
  const std::forward_list&lt;int&gt; easy_as{ 1, 2, 3 }; <span class="ent">➊</span>&#13;
  auto itr = easy_as.begin(); <span class="ent">➋</span>&#13;
  REQUIRE(*itr == 1); <span class="ent">➌</span>&#13;
  itr++; <span class="ent">➍</span>&#13;
  REQUIRE(*itr == 2);&#13;
  itr++;&#13;
  REQUIRE(*itr == 3);&#13;
  itr++;&#13;
  REQUIRE(itr == easy_as.end()); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex02"/><em>Listing 14-2: Interacting with input iterators from a <code>forward_list</code></em></p>&#13;
<p class="indent">You create a <code>forward_list</code> containing three elements <span class="ent">➊</span>. The container’s constness means the elements are immutable, so the iterators support only read operations. You extract an iterator with the <code>begin</code> method of <code>forward_list</code> <span class="ent">➋</span>. Using <code>operator*</code>, you extract the element pointed to by <code>itr</code> <span class="ent">➌</span> and follow up with the obligatory incrementation <span class="ent">➍</span>. Once you’ve exhausted the range by reading/incrementing, <code>itr</code> equals the <code>end</code> of the <code>forward_list</code> <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14tab03">Table 14-3</a> summarizes the input iterator’s supported operations.</p>&#13;
<p class="tabcap"><a id="ch14tab03"/><strong>Table 14-3:</strong> Input Iterator’s Supported Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>*</code><span class="codestrong">itr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dereferences the pointed-to member. Might or might not be read-only.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">itr</span><code>-&gt;</code><span class="codestrong">mbr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Dereferences the member <span class="codestrong">mbr</span> of the object pointed-to by <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>++</code><span class="codestrong">itr</span></p>&#13;
<p class="taba"><span class="codestrong">itr</span><code>++</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Increments the iterator. After operation, iterator is either dereferencable or exhausted (past the end).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">itr1</span> <code>==</code> <span class="codestrong">itr2</span></p>&#13;
<p class="taba"><span class="codestrong">itr1</span>  <code>!=</code>  <span class="codestrong">itr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Compares whether the iterators are equal (pointing to the same element).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codeitalicstrong">iterator-type</span><code>{</code> <span class="codestrong">itr</span>  <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Copy-constructs an iterator from <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch14lev2sec3"><strong><em>Forward Iterators</em></strong></h4>&#13;
<p class="noindent">A <em>forward iterator</em> is an input iterator with additional features: a forward iterator can also traverse multiple times, default construct, and copy assign. You can use a forward iterator in place of an input iterator in all cases.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_468"/>All STL containers provide forward iterators. Accordingly, the <code>forward_list</code> used in <a href="ch14.xhtml#ch14ex02">Listing 14-2</a> actually provides a forward iterator (which is also an input iterator).</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14ex03">Listing 14-3</a> updates <a href="ch14.xhtml#ch14ex02">Listing 14-2</a> to iterate over the <code>forward_list</code> multiple times.</p>&#13;
<pre>TEST_CASE("std::forward_list’s begin and end provide forward iterators") {&#13;
  const std::forward_list&lt;int&gt; easy_as{ 1, 2, 3 }; <span class="ent">➊</span>&#13;
  auto itr1 = easy_as.begin(); <span class="ent">➋</span>&#13;
  auto itr2{ itr1 }; <span class="ent">➌</span>&#13;
  int double_sum{};&#13;
  while (itr1 != easy_as.end()) <span class="ent">➍</span>&#13;
    double_sum += *(itr1++);&#13;
  while (itr2 != easy_as.end()) <span class="ent">➎</span>&#13;
    double_sum += *(itr2++);&#13;
  REQUIRE(double_sum == 12); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex03"/><em>Listing 14-3: Traversing a forward iterator twice</em></p>&#13;
<p class="indent">Again you create a <code>forward_list</code> containing three elements <span class="ent">➊</span>. You extract an iterator called <code>itr1</code> with the <code>begin</code> method of <code>forward_list</code> <span class="ent">➋</span>, then create a copy called <code>itr2</code> <span class="ent">➌</span>. You exhaust <code>itr1</code> <span class="ent">➍</span> and <code>itr2</code> <span class="ent">➎</span>, iterating over the range twice while summing both times. The resulting <code>double_sum</code> equals 12 <span class="ent">➏</span>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14tab04">Table 14-4</a> summarizes the forward iterator’s supported operations.</p>&#13;
<p class="tabcap"><a id="ch14tab04"/><strong>Table 14-4:</strong> Forward Iterator’s Supported Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>*</code><span class="codestrong">itr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dereferences the pointed-to member. Might or might not be read-only.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">itr</span><code>-&gt;</code><span class="codestrong">mbr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Dereferences the member <span class="codestrong">mbr</span> of the object pointed-to by <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>++</code><span class="codestrong">itr</span></p>&#13;
<p class="taba"><span class="codestrong">itr</span><code>++</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Increments the iterator so it points to the next element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">itr1</span> <code>==</code> <span class="codestrong">itr2</span></p>&#13;
<p class="taba"><span class="codestrong">itr1</span> <code>!=</code> <span class="codestrong">itr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Compares whether the iterators are equal (pointing to the same element).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codeitalicstrong">iterator-type</span><code>{}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Default constructs an iterator.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codeitalicstrong">iterator-type</span><code>{</code> <span class="codestrong">itr</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Copy-constructs an iterator from <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">itr1</span> <code>=</code> <span class="codestrong">itr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Assigns an iterator <span class="codestrong">itr1</span> from <span class="codestrong">itr2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch14lev2sec4"><strong><em>Bidirectional Iterators</em></strong></h4>&#13;
<p class="noindent">A <em>bidirectional iterator</em> is a forward iterator that can also iterate backward. You can use a bidirectional iterator in place of a forward or input iterator in all cases.</p>&#13;
<p class="indent">Bidirectional iterators permit backward iteration with <code>operator--</code> and <code>operator—(int)</code>. The STL containers that provide bidirectional iterators are <code>array, list</code>, <code>deque, vector</code>, and all of the ordered associative containers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_469"/><a href="ch14.xhtml#ch14ex04">Listing 14-4</a> illustrates how to iterate in both directions using the bidirectional iterator of <code>list</code>.</p>&#13;
<pre>#include &lt;list&gt;&#13;
&#13;
TEST_CASE("std::list begin and end provide bidirectional iterators") {&#13;
  const std::list&lt;int&gt; easy_as{ 1, 2, 3 }; <span class="ent">➊</span>&#13;
  auto itr = easy_as.begin(); <span class="ent">➋</span>&#13;
  REQUIRE(*itr == 1); <span class="ent">➌</span>&#13;
  itr++; <span class="ent">➍</span>&#13;
  REQUIRE(*itr == 2);&#13;
  itr--; <span class="ent">➎</span>&#13;
  REQUIRE(*itr == 1); <span class="ent">➏</span>&#13;
  REQUIRE(itr == easy_as.cbegin());&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex04"/><em>Listing 14-4: The <code>std::list</code> methods <code>begin</code> and <code>end</code> provide bidirectional iterators.</em></p>&#13;
<p class="indent">Here, you create a <code>list</code> containing three elements <span class="ent">➊</span>. You extract an iterator called <code>itr</code> with the <code>begin</code> method of <code>list</code> <span class="ent">➋</span>. As with the input and forward iterators, you can dereference <span class="ent">➌</span> and increment <span class="ent">➍</span> the iterator. Additionally, you can decrement the iterator <span class="ent">➎</span> so you can go back to elements you’ve already iterated over <span class="ent">➏</span>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14tab05">Table 14-5</a> summarizes a bidirectional iterator’s supported operations.</p>&#13;
<p class="tabcap"><a id="ch14tab05"/><strong>Table 14-5:</strong> Bidirectional Iterator’s Supported Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>*</code><span class="codestrong">itr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dereferences the pointed-to member. Might or might not be read-only.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">itr</span><code>-&gt;</code><span class="codestrong">mbr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Dereferences the member <span class="codestrong">mbr</span> of the object pointed to by <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>++</code><span class="codestrong">itr</span></p>&#13;
<p class="taba"><span class="codestrong">itr</span><code>++</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Increments the iterator so it points to the next element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>--</code><span class="codestrong">itr</span></p>&#13;
<p class="taba"><span class="codestrong">itr</span><code>--</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Decrements the iterator so it points to the previous element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">itr1</span> <code>==</code> <span class="codestrong">itr2</span></p>&#13;
<p class="taba"><span class="codestrong">itr1</span> <code>!=</code> <span class="codestrong">itr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Compares whether the iterators are equal (pointing to the same element).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codeitalicstrong">iterator-type</span><code>{}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Default constructs an iterator.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codeitalicstrong">iterator-type</span><code>{</code>  <span class="codestrong">itr</span>  <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Copy-constructs an iterator from <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">itr1</span>  <code>=</code>  <span class="codestrong">itr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Assigns an iterator <span class="codestrong">itr1</span> from <span class="codestrong">itr2</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch14lev2sec5"><strong><em>Random-Access Iterators</em></strong></h4>&#13;
<p class="noindent">A <em>random-access iterator</em> is a bidirectional iterator that supports random element access. You can use a random-access iterator in place of bidirectional, forward, and input iterators in all cases.</p>&#13;
<p class="indent">Random-access iterators permit random access with <code>operator[]</code> and also iterator arithmetic, such as adding or subtracting integer values and subtracting other iterators to find distances. The STL containers that provide <span epub:type="pagebreak" id="page_470"/>random-access iterators are <code>array</code><code>, vector</code>, and <code>deque</code>. <a href="ch14.xhtml#ch14ex05">Listing 14-5</a> illustrates how to access arbitrary elements using a random-access iterator from a <code>vector</code>.</p>&#13;
<pre>#include &lt;vector&gt;&#13;
&#13;
TEST_CASE("std::vector begin and end provide random-access iterators") {&#13;
  const std::vector&lt;int&gt; easy_as{ 1, 2, 3 }; <span class="ent">➊</span>&#13;
  auto itr = easy_as.begin(); <span class="ent">➋</span>&#13;
  REQUIRE(itr[0] == 1); <span class="ent">➌</span>&#13;
  itr++; <span class="ent">➍</span>&#13;
  REQUIRE(*(easy_as.cbegin() + 2) == 3); <span class="ent">➎</span>&#13;
  REQUIRE(easy_as.cend() - itr == 2); <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex05"/><em>Listing 14-5: Interacting with a random-access iterator</em></p>&#13;
<p class="indent">You create a <code>vector</code> containing three elements <span class="ent">➊</span>. You extract an iterator called <code>itr</code> with the <code>begin</code> method of <code>vector</code> <span class="ent">➋</span>. Because this is a random-access iterator, you can use <code>operator[]</code> to dereference arbitrary elements <span class="ent">➌</span>. Of course, you can still increment the iterator using <code>operator++</code> <span class="ent">➍</span>. You can also add to or subtract from an iterator to access elements at a given offset <span class="ent">➎</span><span class="ent">➏</span>.</p>&#13;
<h5 class="h5" id="ch14lev3sec3"><strong>List of Supported Random-Access Iterator Operations</strong></h5>&#13;
<p class="noindent"><a href="ch14.xhtml#ch14tab06">Table 14-6</a> summarizes the random-access iterator’s supported operations.</p>&#13;
<p class="tabcap"><a id="ch14tab06"/><strong>Table 14-6:</strong> Random-Access Iterator’s Supported Operations</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Notes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">itr</span><code>[</code><span class="codestrong">n</span><code>]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dereferences the element with index <span class="codestrong">n</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">itr</span><code>+</code><span class="codestrong">n</span></p>&#13;
<p class="taba"><span class="codestrong">itr</span><code>-</code><span class="codestrong">n</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the iterator at offset <span class="codestrong">n</span> from <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">itr2</span><code>-</code><span class="codestrong">itr1</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Computes the distance between <span class="codestrong">itr1</span> and <span class="codestrong">itr2</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>*</code><span class="codestrong">itr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Dereferences the pointed-to member. Might or might not be read-only.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">itr</span><code>-&gt;</code><span class="codestrong">mbr</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Dereferences the member <span class="codestrong">mbr</span> of the object pointed to by <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>++</code><span class="codestrong">itr</span></p>&#13;
<p class="taba"><span class="codestrong">itr</span><code>++</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Increments the iterator so it points to the next element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>--</code><span class="codestrong">itr</span></p>&#13;
<p class="taba"><span class="codestrong">itr</span><code>--</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Decrements the iterator so it points to the previous element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">itr1</span>  <code>==</code>  <span class="codestrong">itr2</span></p>&#13;
<p class="taba"><span class="codestrong">itr1</span>  <code>!=</code>  <span class="codestrong">itr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Compares whether the iterators are equal (pointing to the same element).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codeitalicstrong">iterator-type</span><code>{}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Default constructs an iterator.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codeitalicstrong">iterator-type</span><code>{</code>  <span class="codestrong">itr</span>  <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Copy-constructs an iterator from <span class="codestrong">itr</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">itr1</span>  <code>&lt;</code>  <span class="codestrong">itr2</span></p>&#13;
<p class="taba"><span class="codestrong">itr1</span>  <code>&gt;</code>  <span class="codestrong">itr2</span></p>&#13;
<p class="taba"><span class="codestrong">itr1</span>  <code>&lt;=</code>  <span class="codestrong">itr2</span></p>&#13;
<p class="taba"><span class="codestrong">itr1</span>  <code>&gt;=</code>  <span class="codestrong">itr2</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Performs the corresponding comparison to the iterators’ positions.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch14lev2sec6"><span epub:type="pagebreak" id="page_471"/><strong><em>Contiguous Iterators</em></strong></h4>&#13;
<p class="noindent">A <em>contiguous iterator</em> is a random-access iterator with elements adjacent in memory. For a contiguous iterator <code>itr</code>, all elements <code>itr[n]</code> and <code>itr[n+1]</code> satisfy the following relation for all valid selections of indices <code>n</code> and offsets <code>i</code>:</p>&#13;
<pre>&amp;itr[n] + i == &amp;itr[n+i]</pre>&#13;
<p class="indent">The <code>vector</code> and <code>array</code> containers provide contiguous iterators, but <code>list</code> and <code>deque</code> don’t.</p>&#13;
<h4 class="h4" id="ch14lev2sec7"><strong><em>Mutable Iterators</em></strong></h4>&#13;
<p class="noindent">All forward iterators, bidirectional iterators, random-access iterators, and contiguous iterators can support read-only or read-and-write modes. If an iterator supports read and write, you can assign values to the references returned by dereferencing an iterator. Such iterators are called <em>mutable iterators</em>. For example, a bidirectional iterator that supports reading and writing is called a mutable bidirectional iterator.</p>&#13;
<p class="indent">In each of the examples so far, the containers used to underpin the iterators have been <code>const</code>. This produces iterators to <code>const</code> objects, which are of course not writable. <a href="ch14.xhtml#ch14ex06">Listing 14-6</a> extracts a mutable, random-access iterator from a (non-<code>const</code>) <code>deque</code>, allowing you to write into arbitrary elements of the container.</p>&#13;
<pre>#include &lt;deque&gt;&#13;
&#13;
TEST_CASE("Mutable random-access iterators support writing.") {&#13;
  std::deque&lt;int&gt; easy_as{ 1, 0, 3 }; <span class="ent">➊</span>&#13;
  auto itr = easy_as.begin(); <span class="ent">➋</span>&#13;
  itr[1] = 2; <span class="ent">➌</span>&#13;
  itr++; <span class="ent">➍</span>&#13;
  REQUIRE(*itr == 2); <span class="ent">➎</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex06"/><em>Listing 14-6: A mutable random-access iterator permits writing.</em></p>&#13;
<p class="indent">You construct a <code>deque</code> containing three elements <span class="ent">➊</span> and then obtain an iterator pointing to the first element <span class="ent">➋</span>. Next, you write the value 2 to the second element <span class="ent">➌</span>. Then, you increment the iterator so it points to the element you just modified <span class="ent">➍</span>. When you dereference the pointed-to element, you get back the value you wrote in <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14fig01">Figure 14-1</a> illustrates the relationship between the input iterator and all its more featureful descendants.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_472"/><img src="../images/fig14_1.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch14fig01"><em>Figure 14-1: Input iterator categories and their nested relationships</em></p>&#13;
<p class="indent">To summarize, the input iterator supports only read and increment. Forward iterators are also input iterators, so they also support read and increment but additionally allow you to iterate over their range multiple times (“multi-pass”). Bidirectional iterators are also forward iterators, but they additionally permit decrement operations. Random access iterators are also bidirectional iterators, but you can access arbitrary elements in the sequence directly. Finally, contiguous iterators are random-access iterators that guarantee their elements are contiguous in memory.</p>&#13;
<h3 class="h3" id="ch14lev1sec2"><strong>Auxiliary Iterator Functions</strong></h3>&#13;
<p class="noindent">If you write generic code dealing with iterators, you should use <em>auxiliary iter</em><em>ator functions</em> from the <code>&lt;iterator&gt;</code> header to manipulate iterators rather than using the supported operations directly. These iterator functions perform common tasks of traversing, swapping, and computing distances between iterators. The major advantage of using the auxiliary functions instead of direct iterator manipulation is that the auxiliary functions will inspect an iterator’s type traits and determine the most efficient method for performing the desired operation. Additionally, auxiliary iterator functions make generic code even more generic because it will work with the widest range of iterators.</p>&#13;
<h4 class="h4" id="ch14lev2sec8"><strong><em>std::advance</em></strong></h4>&#13;
<p class="noindent">The <code>std::advance</code> auxiliary iterator function allows you to increment or decrement by the desired amount. This function template accepts an iterator reference and an integer value corresponding to the distance you want to move the iterator:</p>&#13;
<pre>void std::advance(InputIterator&amp;<span class="ent">➊</span> itr, Distance<span class="ent">➋</span> d);</pre>&#13;
<p class="indent">The <code>InputIterator</code> template parameter must be at least an input iterator <span class="ent">➊</span>, and the <code>Distance</code> template parameter is usually an integer <span class="ent">➋</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_473"/>The <code>advance</code> function doesn’t perform bounds checking, so you must ensure that you’ve not exceeded the valid range for the iterator’s position.</p>&#13;
<p class="indent">Depending on the iterator’s category, <code>advance</code> will perform the most efficient operation that achieves the desired effect:</p>&#13;
<p class="bq"><strong>Input iterator</strong> The <code>advance</code> function will invoke <code>itr++</code> the correct number of times; <code>dist</code> cannot be negative.</p>&#13;
<p class="bq"><strong>Bidirectional iterator</strong> The function will invoke <code>itr++</code> or <code>itr--</code> the correct number of times.</p>&#13;
<p class="bq"><strong>Random access iterator</strong> It will invoke <code>itr+=dist</code>; <code>dist</code> can be negative.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Random-access iterators will be more efficient than lesser iterators with <code>advance</code>, so you might want to use <code>operator+=</code> instead of <code>advance</code> if you want to forbid the worst-case (linear-time) performance.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch14.xhtml#ch14ex07">Listing 14-7</a> illustrates how to use <code>advance</code> to manipulate a random-access iterator.</p>&#13;
<pre>#include &lt;iterator&gt;&#13;
&#13;
TEST_CASE("advance modifies input iterators") {&#13;
  std::vector&lt;unsigned char&gt; mission{ <span class="ent">➊</span>&#13;
    0x9e, 0xc4, 0xc1, 0x29,&#13;
    0x49, 0xa4, 0xf3, 0x14,&#13;
    0x74, 0xf2, 0x99, 0x05,&#13;
    0x8c, 0xe2, 0xb2, 0x2a&#13;
  };&#13;
  auto itr = mission.begin(); <span class="ent">➋</span>&#13;
  std::advance(itr, 4); <span class="ent">➌</span>&#13;
  REQUIRE(*itr == 0x49);&#13;
  std::advance(itr, 4); <span class="ent">➍</span>&#13;
  REQUIRE(*itr == 0x74);&#13;
  std::advance(itr, -8); <span class="ent">➎</span>&#13;
  REQUIRE(*itr == 0x9e);&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex07"/><em>Listing 14-7: Using <code>advance</code> to manipulate a contiguous iterator</em></p>&#13;
<p class="indent">Here, you initialize a <code>vector</code> called <code>mission</code> with 16 <code>unsigned char</code> objects <span class="ent">➊</span>. Next, you extract an iterator called <code>itr</code> using the <code>begin</code> method of <code>mission</code> <span class="ent">➋</span> and invoke <code>advance</code> on <code>itr</code> to advance four elements so it points at the fourth element (with value 0x49) <span class="ent">➌</span>. You advance again four elements to the eighth element (with value 0x74) <span class="ent">➍</span>. Finally, you invoke advance with −8 to retreat eight values, so the iterator again points to the first element (with value 0x9e) <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch14lev2sec9"><strong><em>std::next and std::prev</em></strong></h4>&#13;
<p class="noindent">The <code>std::next</code> and <code>std::prev</code> auxiliary iterator functions are function templates that compute offsets from a given iterator. They return a new iterator <span epub:type="pagebreak" id="page_474"/>pointing to the desired element without modifying the original iterator, as demonstrated here:</p>&#13;
<pre>ForwardIterator std::next(ForwardIterator&amp; itr<span class="ent">➊</span>, Distance d=1<span class="ent">➋</span>);&#13;
BidirectionalIterator std::prev(BidirectionalIterator&amp; itr<span class="ent">➌</span>, Distance d=1<span class="ent">➍</span>);</pre>&#13;
<p class="indent">The function <code>next</code> accepts at least a forward iterator <span class="ent">➊</span> and optionally a distance <span class="ent">➋</span>, and it returns an iterator pointing to the corresponding offset. This offset can be negative if <code>itr</code> is bidirectional. The <code>prev</code> function template works like <code>next</code> in reverse: it accepts at least a bidirectional iterator <span class="ent">➌</span> and optionally a distance <span class="ent">➍</span> (which can be negative).</p>&#13;
<p class="indent">Neither <code>next</code> nor <code>prev</code> performs bounds checking. This means you must be absolutely sure that your math is correct and that you’re staying within the sequence; otherwise, you’ll get undefined behavior.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For both <code>next</code> and <code>prev</code>, <code>itr</code> remains unchanged unless it’s an rvalue, in which case <code>advance</code> is used for efficiency.</em></p>&#13;
</div>&#13;
<p class="indent"><a href="ch14.xhtml#ch14ex08">Listing 14-8</a> illustrates how to use <code>next</code> to obtain a new iterator pointing to the element at a given offset.</p>&#13;
<pre>#include &lt;iterator&gt;&#13;
&#13;
TEST_CASE("next returns iterators at given offsets") {&#13;
  std::vector&lt;unsigned char&gt; mission{&#13;
    0x9e, 0xc4, 0xc1, 0x29,&#13;
    0x49, 0xa4, 0xf3, 0x14,&#13;
    0x74, 0xf2, 0x99, 0x05,&#13;
    0x8c, 0xe2, 0xb2, 0x2a&#13;
  };&#13;
  auto itr1 = mission.begin(); <span class="ent">➊</span>&#13;
  std::advance(itr1, 4); <span class="ent">➋</span>&#13;
  REQUIRE(*itr1 == 0x49); <span class="ent">➌</span>&#13;
&#13;
  auto itr2 = std::next(itr1); <span class="ent">➍</span>&#13;
  REQUIRE(*itr2 == 0xa4); <span class="ent">➎</span>&#13;
&#13;
  auto itr3 = std::next(itr1, 4); <span class="ent">➏</span>&#13;
  REQUIRE(*itr3 == 0x74); <span class="ent">➐</span>&#13;
&#13;
  REQUIRE(*itr1 == 0x49); <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex08"/><em>Listing 14-8: Using <code>next</code> to obtain offsets from an iterator</em></p>&#13;
<p class="indent">As in <a href="ch14.xhtml#ch14ex07">Listing 14-7</a>, you initialize a vector containing 16 <code>unsigned char</code>s and extract an iterator <code>itr1</code> pointing to the first element <span class="ent">➊</span>. You use <code>advance</code> to increment the iterator four elements <span class="ent">➋</span> so it points to the element with the value 0x49 <span class="ent">➌</span>. The first use of <code>next</code> omits a distance argument, which defaults to 1 <span class="ent">➍</span>. This produces a new iterator, <code>itr2</code>, which is one past <code>itr1</code> <span class="ent">➎</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_475"/>You invoke <code>next</code> a second time with a distance argument of 4 <span class="ent">➏</span>. This produces another new iterator, <code>itr3</code>, which points to four past the element of <code>itr1</code> <span class="ent">➐</span>. Neither of these invocations affects the original iterator <code>itr1</code> <span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch14lev2sec10"><strong><em>std::distance</em></strong></h4>&#13;
<p class="noindent">The <code>std::distance</code> auxiliary iterator function enables you to compute the distance between two input iterators <code>itr1</code> and <code>itr2</code>:</p>&#13;
<pre>Distance std::distance(InputIterator itr1, InputIterator itr2);</pre>&#13;
<p class="indent">If the iterators are not random access, <code>itr2</code> must refer to an element after <code>itr1</code>. It’s a good idea to ensure that <code>itr2</code> comes after <code>itr1</code>, because you’ll get undefined behavior if you accidentally violate this requirement and the iterators are not random access.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14ex09">Listing 14-9</a> illustrates how to compute the distance between two random access iterators.</p>&#13;
<pre>#include &lt;iterator&gt;&#13;
&#13;
TEST_CASE("distance returns the number of elements between iterators") {&#13;
  std::vector&lt;unsigned char&gt; mission{ <span class="ent">➊</span>&#13;
    0x9e, 0xc4, 0xc1, 0x29,&#13;
    0x49, 0xa4, 0xf3, 0x14,&#13;
    0x74, 0xf2, 0x99, 0x05,&#13;
    0x8c, 0xe2, 0xb2, 0x2a&#13;
  };&#13;
  auto eighth = std::next(mission.begin(), 8); <span class="ent">➋</span>&#13;
  auto fifth = std::prev(eighth, 3); <span class="ent">➌</span>&#13;
  REQUIRE(std::distance(fifth, eighth) == 3); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex09"/><em>Listing 14-9: Using <code>distance</code> to obtain the distance between iterators</em></p>&#13;
<p class="indent">After initializing your <code>vector</code> <span class="ent">➊</span>, you create an iterator pointing to the <code>eighth</code> element using <code>std::next</code> <span class="ent">➋</span>. You use <code>std::prev</code> on <code>eighth</code> to obtain an iterator to the <code>fifth</code> element by passing 3 as the second argument <span class="ent">➌</span>. When you pass <code>fifth</code> and <code>eighth</code> as the arguments to distance, you get 3 <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch14lev2sec11"><strong><em>std::iter_swap</em></strong></h4>&#13;
<p class="noindent">The <code>std::iter_swap</code> auxiliary iterator function allows you to swap the values pointed to by two forward iterators <code>itr1</code> and <code>itr2</code>:</p>&#13;
<pre>Distance std::iter_swap(ForwardIterator itr1, ForwardIterator itr2);</pre>&#13;
<p class="indent">The iterators don’t need to have the same type, as long as their pointed-to types are assignable to one another. <a href="ch14.xhtml#ch14ex10">Listing 14-10</a> illustrates how to use <code>iter_swap</code> to exchange two <code>vector</code> elements.</p>&#13;
<pre><span epub:type="pagebreak" id="page_476"/>#include &lt;iterator&gt;&#13;
&#13;
TEST_CASE("iter_swap swaps pointed-to elements") {&#13;
  std::vector&lt;long&gt; easy_as{ 3, 2, 1 }; <span class="ent">➊</span>&#13;
  std::iter_swap(easy_as.begin()<span class="ent">➋</span>, std::next(easy_as.begin(), 2)<span class="ent">➌</span>);&#13;
  REQUIRE(easy_as[0] == 1); <span class="ent">➍</span>&#13;
  REQUIRE(easy_as[1] == 2);&#13;
  REQUIRE(easy_as[2] == 3);&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex10"/><em>Listing 14-10: Using <code>iter_swap</code> to exchange pointed-to elements</em></p>&#13;
<p class="indent">After you construct a <code>vector</code> with the elements <code>3 2 1</code> <span class="ent">➊</span>, you invoke <code>iter_swap</code> on the first element <span class="ent">➋</span> and the last element <span class="ent">➌</span>. After the exchange, the <code>vector</code> contains the elements <code>1 2 3</code> <span class="ent">➍</span>.</p>&#13;
<h3 class="h3" id="ch14lev1sec3"><strong>Additional Iterator Adapters</strong></h3>&#13;
<p class="noindent">In addition to insert iterators, the STL provides move iterator adapters and reverse iterator adapters to modify iterator behavior.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The STL also provides stream iterator adapters, which you’ll learn about in <a href="ch16.xhtml#ch16">Chapter 16</a> alongside streams.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch14lev2sec12"><strong><em>Move Iterator Adapters</em></strong></h4>&#13;
<p class="noindent">A <em>move iterator adapter</em> is a class template that converts all iterator accesses into move operations. The convenience function template <code>std::make_move_iterator</code> in the <code>&lt;iterator&gt;</code> header accepts a single iterator argument and returns a move iterator adapter.</p>&#13;
<p class="indent">The canonical use of a move iterator adapter is to move a range of objects into a new container. Consider the toy class <code>Movable</code> in <a href="ch14.xhtml#ch14ex11">Listing 14-11</a>, which stores an <code>int</code> value called <code>id</code>.</p>&#13;
<pre>struct Movable{&#13;
  Movable(int id) : id{ id } { } <span class="ent">➊</span>&#13;
  Movable(Movable&amp;&amp; m) {&#13;
    id = m.id; <span class="ent">➋</span>&#13;
    m.id = -1; <span class="ent">➌</span>&#13;
  }&#13;
  int id;&#13;
};</pre>&#13;
<p class="listing"><a id="ch14ex11"/><em>Listing 14-11: The <code>Movable</code> class stores an <code>int</code>.</em></p>&#13;
<p class="indent">The <code>Movable</code> constructor takes an <code>int</code> and stores it into its <code>id</code> field <span class="ent">➊</span>. Movable is also move constructible; it will steal the <code>id</code> from its move-constructor argument <span class="ent">➋</span>, replacing it with −1 <span class="ent">➌</span>.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14ex12">Listing 14-12</a> constructs a <code>vector</code> of <code>Movable</code> objects called <code>donor</code> and moves them into a <code>vector</code> called <code>recipient</code>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_477"/>#include &lt;iterator&gt;&#13;
&#13;
TEST_CASE("move iterators convert accesses into move operations") {&#13;
  std::vector&lt;Movable&gt; donor; <span class="ent">➊</span>&#13;
  donor.emplace_back(1); <span class="ent">➋</span>&#13;
  donor.emplace_back(2);&#13;
  donor.emplace_back(3);&#13;
  std::vector&lt;Movable&gt; recipient{&#13;
    std::make_move_iterator(donor.begin()), <span class="ent">➌</span>&#13;
    std::make_move_iterator(donor.end()),&#13;
  };&#13;
  REQUIRE(donor[0].id == -1); <span class="ent">➍</span>&#13;
  REQUIRE(donor[1].id == -1);&#13;
  REQUIRE(donor[2].id == -1);&#13;
  REQUIRE(recipient[0].id == 1); <span class="ent">➎</span>&#13;
  REQUIRE(recipient[1].id == 2);&#13;
  REQUIRE(recipient[2].id == 3);&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex12"/><em>Listing 14-12: Using the move iterator adapter to convert iterator operations into move operations</em></p>&#13;
<p class="indent">Here, you default construct a <code>vector</code> called <code>donor</code> <span class="ent">➊</span>, which you use to <code>emplace_back</code> three <code>Movable</code> objects with <code>id</code> fields 1, 2, and 3 <span class="ent">➋</span>. You then use the range constructor of <code>vector</code> with the  <code>begin</code> and <code>end</code> iterators of <code>donor</code>, which you pass to <code>make_move_iterator</code> <span class="ent">➌</span>. This converts all iterator operations into move operations, so the move constructor of <code>Movable</code> gets called. As a result, all the elements of <code>donor</code> are in a moved-from state <span class="ent">➍</span>, and all the elements of <code>recipient</code> match the previous elements of <code>donor</code> <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch14lev2sec13"><strong><em>Reverse Iterator Adapters</em></strong></h4>&#13;
<p class="noindent">A <em>reverse iterator adapter</em> is a class template that swaps an iterator’s increment and decrement operators. The net effect is that you can reverse the input to an algorithm by applying a reverse iterator adapter. One common scenario where you might want to use a reverse iterator is when searching backward from the end of a container. For example, perhaps you’ve been pushing logs onto the end of a <code>deque</code> and want to find the latest entry that meets some criterion.</p>&#13;
<p class="indent">Almost all containers in <a href="ch13.xhtml#ch13">Chapter 13</a> expose reverse iterators with <code>rbegin</code>/<code>rend</code>/<code>crbegin</code>/<code>crend</code> methods. For example, you can create a container with the reverse sequence of another container, as shown in <a href="ch14.xhtml#ch14ex13">Listing 14-13</a>.</p>&#13;
<pre>TEST_CASE("reverse iterators can initialize containers") {&#13;
  std::list&lt;int&gt; original{ 3, 2, 1 }; <span class="ent">➊</span>&#13;
  std::vector&lt;int&gt; easy_as{ original.crbegin(), original.crend() }; <span class="ent">➋</span>&#13;
  REQUIRE(easy_as[0] == 1); <span class="ent">➌</span>&#13;
  REQUIRE(easy_as[1] == 2);&#13;
  REQUIRE(easy_as[2] == 3);&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex13"/><em>Listing 14-13: Creating a container with the reverse of another container’s elements</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_478"/>Here, you create a <code>list</code> containing the elements <code>3 2 1</code> <span class="ent">➊</span>. Next, you construct a <code>vector</code> with the reverse of the sequence by using the <code>crbegin</code> and <code>crend</code> methods <span class="ent">➋</span>. The <code>vector</code> contains <code>1 2 3</code>, the reverse of the list elements <span class="ent">➌</span>.</p>&#13;
<p class="indent">Although containers usually expose reverse iterators directly, you can also convert a normal iterator into a reverse iterator manually. The convenience function template <code>std::make_reverse_iterator</code> in the <code>&lt;iterator&gt;</code> header accepts a single iterator argument and returns a reverse iterator adapter.</p>&#13;
<p class="indent">Reverse iterators are designed to work with half-open ranges that are exactly opposite of normal half-open ranges. Internally, a <em>reverse half-open range</em> has an <code>rbegin</code> iterator that refers to 1 past a half-open range’s <code>end</code> and an <code>rend</code> iterator that refers to the half-open range’s <code>begin</code>, as shown in <a href="ch14.xhtml#ch14fig02">Figure 14-2</a>.</p>&#13;
<div class="image"><img src="../images/fig14_2.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch14fig02"><em>Figure 14-2: A reverse half-open range</em></p>&#13;
<p class="indent">However, these implementation details are all transparent to the user. The iterators dereference as you would expect. As long as the range isn’t empty, you can dereference the reverse-begin iterator, and it will return the first element. But you <em>cannot</em> dereference the reverse-end iterator.</p>&#13;
<p class="indent">Why introduce this representational complication? With this design, you can easily swap the begin and end iterators of a half-open range to produce a reverse half-open range. For example, <a href="ch14.xhtml#ch14ex14">Listing 14-14</a> uses <code>std::make_reverse_iterator</code> to convert normal iterators to reverse iterators, accomplishing the same task as <a href="ch14.xhtml#ch14ex13">Listing 14-13</a>.</p>&#13;
<pre>TEST_CASE("make_reverse_iterator converts a normal iterator") {&#13;
  std::list&lt;int&gt; original{ 3, 2, 1 };&#13;
  auto begin = std::make_reverse_iterator(original.cend()); <span class="ent">➊</span>&#13;
  auto end = std::make_reverse_iterator(original.cbegin()); <span class="ent">➋</span>&#13;
  std::vector&lt;int&gt; easy_as{ begin, end }; <span class="ent">➌</span>&#13;
  REQUIRE(easy_as[0] == 1);&#13;
  REQUIRE(easy_as[1] == 2);&#13;
  REQUIRE(easy_as[2] == 3);&#13;
}</pre>&#13;
<p class="listing"><a id="ch14ex14"/><em>Listing 14-14: The <code>make_reverse_iterator</code> function converts a normal iterator to a reverse iterator</em></p>&#13;
<p class="indent">Pay special attention to the iterators you’re extracting from <code>original</code>. To create the <code>begin</code> iterator, you extract an <code>end</code> iterator from <code>original</code> and pass it to <code>make_reverse_iterator</code> <span class="ent">➊</span>. The reverse iterator adapter will swap increment and decrement operators, but it needs to start in the right place. Likewise, you need to terminate at the original’s beginning, so you pass the result of <code>cbegin</code> to <code>make_reverse_iterator</code> to produce the correct end <span class="ent">➋</span>. Passing these to the range constructor of <code>easy_as</code> <span class="ent">➌</span> produces identical results to <a href="ch14.xhtml#ch14ex13">Listing 14-13</a>.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_479"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>All reverse iterators expose a <code>base</code> method, which will convert the reverse iterator back into a normal iterator.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch14lev1sec4"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this short chapter, you learned all the iterator categories: output, input, forward, bidirectional, random-access, and contiguous. Knowing the basic properties of each category provides you with a framework for understanding how containers connect with algorithms. The chapter also surveyed iterator adapters, which enable you to customize iterator behavior, and the auxiliary iterator functions, which help you write generic code with iterators.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>14-1.</strong> Create a corollary to <a href="ch14.xhtml#ch14ex08">Listing 14-8</a> using <code>std::prev</code> rather than <code>std::next</code>.</p>&#13;
<p class="noindent"><strong>14-2.</strong> Write a function template called <code>sum</code> that accepts a half-open range of <code>int</code> objects and returns the sum of the sequence.</p>&#13;
<p class="noindent"><strong>14-3.</strong> Write a program that uses the <code>Stopwatch</code> class in <a href="ch12.xhtml#ch12ex25">Listing 12-25</a> to determine the runtime performance of <code>std::advance</code> when given a forward iterator from a large  <code>std::forward_list</code> and a large  <code>std::vector</code>. How does the runtime change with the number of elements in the container? (Try hundreds of thousands or millions of elements.)</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>The C++ Standard Library: A Tutorial and Reference</em>, 2nd Edition, by Nicolai M. Josuttis (Addison-Wesley Professional, 2012)</li>&#13;
<li class="noindent"><em>C++ Templates: The Complete Guide</em>, 2nd Edition, by David Vandevoorde et al. (Addison-Wesley, 2017)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>