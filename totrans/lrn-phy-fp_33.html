<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="appa"><span epub:type="pagebreak" id="page_581"/>APPENDIX<br/>INSTALLING HASKELL</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">This appendix explains how to install the Glasgow Haskell Compiler and libraries other people have written.</p>&#13;
<h3 class="h3" id="appalev1">Installing GHC</h3>&#13;
<p class="noindent">The Glasgow Haskell Compiler (GHC) is the Haskell compiler we use in this book. It is free, open source software anyone can download and install.</p>&#13;
<p class="indent">The installation procedure depends on which operating system you use. For GNU/Linux and macOS users, I recommend going to <a href="https://www.haskell.org"><em>https://www.haskell.org</em></a> and choosing <strong>Downloads</strong>. Follow the instructions for your operating system. You will know you have succeeded when you can start the GHCi interactive compiler, usually by typing <code>ghci</code> at the command prompt. At this point, you are ready to get started with <a href="ch01.xhtml">Chapter 1</a>. In addition to GHC itself, the installation method you use will install either Cabal or Stack. Cabal and Stack are the two most common tools for installing additional library packages. I describe their use later in this appendix.</p>&#13;
<p class="indent">For Microsoft Windows users, I recommend following the instructions at <a href="https://www.fpcomplete.com/haskell/get-started/windows">https://www.fpcomplete.com/haskell/get-started/windows</a>. FPComplete is a <span epub:type="pagebreak" id="page_582"/>company that provides services for industrial Haskell users. The installer they provide will install both the Glasgow Haskell Compiler and the Stack library package manager. You will know you have succeeded when you can start the GHCi interactive compiler and obtain a GHCi prompt by typing <code>stack ghci</code> at the PowerShell prompt. At this point, you are ready to get started with <a href="ch01.xhtml">Chapter 1</a>.</p>&#13;
<h3 class="h3" id="appalev2">Installing a Text Editor</h3>&#13;
<p class="noindent">To write source code files, you will need a text editor. You can use a basic text editor like Notes on macOS or gedit on Linux, or you can choose from a number of more sophisticated text editors available. These more sophisticated editors often have helpful features for programmers, like text highlighting, that can often be configured to be sensitive to the language you are programming in.</p>&#13;
<p class="indent">You can find advice for getting your Haskell environment to work smoothly with your editor on the Haskell wiki at <a href="https://wiki.haskell.org/Haskell"><em>https://wiki.haskell.org/Haskell</em></a>. Good editors for Haskell are Emacs, Vim, Visual Studio Code, and Atom. Simple text editors like Notes are typically included with the operating system. Emacs is available at <a href="https://www.gnu.org/software/emacs">https://www.gnu.org/software/emacs</a>, Vim is available at <a href="https://www.vim.org">https://www.vim.org</a>, Atom is available at <a href="https://atom.io">https://atom.io</a>, and Visual Studio Code is available at <a href="https://code.visualstudio.com">https://code.visualstudio.com</a>. Follow the instructions for your operating system. (Users who want to run Emacs on macOS should download it from <a href="https://emacsforosx.com">https://emacsforosx.com</a>. This link provides standard Emacs built to run in the macOS environment. Since it is standard Emacs, it is possible to reliably customize it according to the advice you find online. The first stop in customization is <a href="https://www.emacswiki.org">https://www.emacswiki.org</a>.)</p>&#13;
<h3 class="h3" id="appalev3">Installing Gnuplot</h3>&#13;
<p class="noindent">Beginning in <a href="ch07.xhtml">Chapter 7</a>, we use <code>gnuplot</code> to make graphs. <code>Gnuplot</code> is a stand-alone graphing program, independent of Haskell, with a web page at <a href="http://gnuplut.info"><em>http://gnuplut.info</em></a>. Installing <code>gnuplot</code> so that it can be used with Haskell is a two-step process. First, you must install the <code>gnuplot</code> program so that it works independently from Haskell. Second, you must install the Haskell <code>gnuplot</code> package so that Haskell code can access <code>gnuplot</code>’s functionality. This section deals with installing the <code>gnuplot</code> program, while the following section explains how to install the Haskell <code>gnuplot</code> package.</p>&#13;
<p class="indent">The process for installing the <code>gnuplot</code> program depends on your operating system. For GNU/Linux, you can usually use your package manager. For example, on Ubuntu Linux, the command</p>&#13;
<pre>$ <span class="codestrong1">sudo apt install gnuplot</span></pre>&#13;
<p class="noindent">will install the <code>gnuplot</code> program.</p>&#13;
<p class="indent">On macOS, I recommend the Homebrew package manager at <a href="https://brew.sh">https://brew.sh</a>. After you follow the instructions to install Homebrew, you can issue the following command to install the <code>gnuplot</code> program:</p>&#13;
<pre>$ <span class="codestrong1">brew install gnuplot</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_583"/>On Microsoft Windows, follow the instructions at <a href="http://www.gnuplot.info"><em>http://www.gnuplot.info</em></a> to download the <code>gnuplot</code> installer for Windows. Run the installer, which asks a series of questions about where to install things and other installation details. Make a note of the directory in which <code>gnuplot</code> gets installed (perhaps <em>C:</em>\<em>Program Files</em>\<em>gnuplot</em>\<em>bin</em>). You can accept the default settings for all of the installer’s questions except one: when the installer gives the opportunity to “Add application directory to your PATH environment variable,” check that box. After the installer has completed its work, there is one more thing you must do. Using a file browser, navigate to the directory where <code>gnuplot</code> is installed and find the file named <em>wgnuplot</em>_<em>pipes</em>. Copy this file to a new file in the same directory called <em>pgnuplot</em>. If the file is named <em>wgnuplot</em>_<em>pipes.exe</em>, copy it to a new file in the same directory called <em>pgnuplot.exe</em>. This will allow Haskell to use <code>gnuplot</code>.</p>&#13;
<p class="indent">At this point, whatever your operating system, you should be able to run the <code>gnuplot</code> program independently from Haskell. From a command line, you would type the following:</p>&#13;
<pre>$ <span class="codestrong1">gnuplot</span></pre>&#13;
<p class="indent">After starting <code>gnuplot</code>, you should be able to issue a command at the <code>gnuplot</code> prompt, such as</p>&#13;
<pre>gnuplot&gt; <span class="codestrong1">plot cos(x)</span></pre>&#13;
<p class="noindent">and a window containing a plot should pop open. Once you succeed in installing the <code>gnuplot</code> program, you are ready to install the Haskell <code>gnuplot</code> package, which lets you control <code>gnuplot</code> from Haskell.</p>&#13;
<h3 class="h3" id="appalev4">Installing Haskell Library Packages</h3>&#13;
<p class="noindent">There are functions other people have written that we will want to use that are not included in the Prelude (the standard collection of functions available by default). Such functions exist in library modules that can be imported in our source code file or loaded directly into GHCi. There is a standard set of library modules that comes with GHC, and there are others you can install with Cabal or Stack. Library modules outside of the standard libraries are organized into <em>packages</em>, each containing one or more modules.</p>&#13;
<p class="indent">Suppose we want access to the <code>plotFunc</code> function in the <code>Graphics.Gnuplot</code> <code>.Simple</code> module provided by the Haskell <code>gnuplot</code> package. We must install the <code>gnuplot</code> package.</p>&#13;
<p class="indent">The two major tools for installing Haskell library packages are Cabal and Stack. You need to use only one of these. At least one of them will be available by following the instructions for GHC installation.</p>&#13;
<p class="indent">Cabal (Common Architecture for Building Applications and Libraries) existed first. At the time it was written (around 2005), it was considered very important to minimize the number of required downloads, so Cabal was <span epub:type="pagebreak" id="page_584"/>designed to install a global set of packages, and all applications were supposed to build against this common set of packages. And again, in the interest of efficiency, Cabal allowed only one version of each package to be installed.</p>&#13;
<p class="indent">This led to a problem: many libraries were evolving quickly, adding features and changing their interfaces. A common problem encountered was that an application might build against libraries that, in turn, depended on different versions of a common ancestor. This sometimes required uninstalling and reinstalling all of your packages, and occasionally reloading different versions of all your packages to build a new application. The problem was called “dependency hell” or “Cabal hell,” and the name tells you all you need to know about how painful it was.</p>&#13;
<p class="indent">The solution was to allow multiple versions of packages to be installed, and Cabal now allows this.</p>&#13;
<p class="indent">The Stack system provides many of the same features as Cabal, and in fact can smoothly work alongside it, but its goals are slightly different. Stack is aimed at meeting the requirements of commercial users who need assurance that their applications will build even as the Haskell library infrastructure evolves. Stack calls this goal “reproducible builds.” To get reproducible builds, Stack’s default mode of operation is to let you specify a compiler version and a set of curated packages known to work properly with that compiler. The curated sets include more than 2,000 packages, so you are likely to find most of what you need there (and if you don’t, it’s not hard to specify the additional packages you want downloaded and built). The upside of this apparent complexity is that not only does your Haskell program build the same way each time, it runs the same way.</p>&#13;
<p class="indent">Stack and Cabal are generally able to avoid the problem of inconsistent dependencies breaking the builds of large, complicated projects. There is a price for this, though. They may download many more packages than you expect. Stack, in particular, may download multiple compilers to ensure that the packages and compiler are known to produce consistent results. This may seem unnecessary, but it’s required by the way the GHC compiler works. For important, but fussy, technical reasons, the GHC compiler does not have a standardized “application binary interface” (ABI). This means you can’t use libraries compiled with one version of GHC with an application compiled by another. This is not a bug—it turns out that to get a pure functional language with lazy evaluation and decent performance, you need to give up something. And one of those somethings is a stable ABI.</p>&#13;
<h4 class="h4" id="appalev5">Using Cabal</h4>&#13;
<p class="noindent">To load a module into GHCi, the working directory must have access to the module. For a module outside the standard modules provided by the GHC installation itself, the package that contains the module must be installed. There are two ways to install a package using Cabal: globally, so that the package can be accessed from any directory, and locally, so that it can be accessed only from the current working directory.</p>&#13;
<h5 class="h5" id="appalev6"><span epub:type="pagebreak" id="page_585"/>Using Cabal to Install a Package Globally</h5>&#13;
<p class="noindent">To install the <code>gnuplot</code> package globally, issue the following command:</p>&#13;
<pre>$ <span class="codestrong1">cabal install --lib gnuplot</span></pre>&#13;
<p class="indent">On my computer, this command creates or changes the file <em>/home/walck/ .ghc/x86_64-linux-8.10.5/environments/default</em>, which contains the list of globally installed Haskell packages. After you have installed one or more packages globally, a Cabal command such as the one we just issued may fail to install a new package if Cabal cannot find a version of the requested package that is compatible with existing globally installed packages. One way to solve this problem is to rename the file containing the global package list and then try to install all of the packages you want simultaneously. For example, to install the <code>gnuplot</code>, <code>gloss</code>, and <code>cyclotomic</code> packages simultaneously, you would issue the following command:</p>&#13;
<pre>$ <span class="codestrong1">cabal install --lib gnuplot gloss cyclotomic</span></pre>&#13;
<p class="indent">Because we renamed the global package list, Cabal will not find a global package list and consequently will make a new one.</p>&#13;
<h5 class="h5" id="appalev7">Using Cabal to Install a Package Locally</h5>&#13;
<p class="noindent">To install the <code>gnuplot</code> package locally (in the current working directory), issue the following command:</p>&#13;
<pre>$ <span class="codestrong1">cabal install --lib gnuplot --package-env .</span></pre>&#13;
<p class="indent">The dot at the end of the command refers to the current working directory. This command creates or changes a file with a name like <em>.ghc.environment .x86_64-linux-8.10.5</em> in the current working directory. This file contains a list of packages installed locally (in the current working directory). After you have installed one or more packages locally in some directory, a Cabal command such as the one we just issued may fail to install a new package if Cabal cannot find a version of the requested package that is compatible with existing locally installed packages. One way to solve this problem is to rename the file containing the local package list and then try to install all of the packages you want simultaneously. For example, to install the <code>gnuplot</code>, <code>gloss</code>, and <code>cyclotomic</code> packages simultaneously, you would issue the following command:</p>&#13;
<pre>$ <span class="codestrong1">cabal install --lib gnuplot gloss cyclotomic --package-env .</span></pre>&#13;
<p class="indent">Because we renamed the local package list, Cabal will not find a local package list and consequently will make a new one.</p>&#13;
<h4 class="h4" id="appalev8"><span epub:type="pagebreak" id="page_586"/>Using Stack</h4>&#13;
<p class="noindent">To install the <code>gnuplot</code> package using Stack, issue the command</p>&#13;
<pre>$ <span class="codestrong1">stack install gnuplot</span></pre>&#13;
<p class="noindent">at the command prompt. Stack keeps track of more things behind the scenes than Cabal does, and global installation with Stack is usually all you need.</p>&#13;
<p class="indent">After installing the <code>gnuplot</code> package, you can load the <code>Graphics.Gnuplot</code> <code>.Simple</code> module into GHCi. If you are using Stack, you should start GHCi with <code>stack ghci</code> rather than <code>ghci</code>. In this way, Stack will be able to find the modules of the packages you have installed.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Graphics.Gnuplot.Simple</span>&#13;
Prelude Graphics.Gnuplot.Simple&gt; <span class="codestrong1">:t plotFunc</span>&#13;
plotFunc&#13;
  :: (Graphics.Gnuplot.Value.Atom.C a,&#13;
      Graphics.Gnuplot.Value.Tuple.C a) =&gt;&#13;
     [Attribute] -&gt; [a] -&gt; (a -&gt; a) -&gt; IO ()</pre>&#13;
<p class="indent">Here we ask for the type of the function <code>plotFunc</code>, simply to show that it is available now that we’ve loaded the module that defines it.</p>&#13;
<p class="indent">To use the <code>plotFunc</code> function in a source code file, include the line</p>&#13;
<pre>import Graphics.Gnuplot.Simple</pre>&#13;
<p class="noindent">at the top of your source code file.</p>&#13;
<h3 class="h3" id="appalev9">Installing Gloss</h3>&#13;
<p class="noindent">Beginning in <a href="ch13.xhtml">Chapter 13</a> we use <code>gloss</code> to make animations. Unlike <code>gnuplot</code>, <code>gloss</code> is not a stand-alone program; it is only a Haskell package. However, <code>gloss</code> uses the freeglut graphics libraries to do its work, and the freeglut functionality is supplied by non-Haskell libraries that must be installed separately from the <code>gloss</code> package itself. So, like installing <code>gnuplot</code>, installing <code>gloss</code> is a two-step process. First, you must install the non-Haskell freeglut libraries. Second, you must install the Haskell <code>gloss</code> package.</p>&#13;
<p class="indent">The procedure for installing the freeglut libraries depends on your operating system. For a GNU/Linux system, a command such as</p>&#13;
<pre>$ <span class="codestrong1">sudo apt install freeglut3</span></pre>&#13;
<p class="noindent">should do the trick. On macOS, a command like</p>&#13;
<pre>$ <span class="codestrong1">brew install freeglut3</span></pre>&#13;
<p class="noindent">is what you want. You will need to install the <code>brew</code> package manager to use this command. On macOS, you may also need the <code>xquartz</code> package to use freeglut, which you can install with</p>&#13;
<pre>$ <span class="codestrong1">brew install xquartz</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_587"/>For a Microsoft Windows system, search the web for “freeglut windows” and follow the instructions you find.</p>&#13;
<p class="indent">After you install the freeglut libraries, you can install the <code>gloss</code> package with a command like</p>&#13;
<pre>$ <span class="codestrong1">cabal install --lib gloss</span></pre>&#13;
<p class="noindent">or</p>&#13;
<pre>$ <span class="codestrong1">stack install gloss</span></pre>&#13;
<p class="noindent">depending on whether you are using Cabal or Stack.</p>&#13;
<h3 class="h3" id="appalev10">Installing Diagrams</h3>&#13;
<p class="noindent">Beginning in <a href="ch22.xhtml">Chapter 22</a> we use the <code>diagrams</code> package to visualize vector fields. Actually, the <code>diagrams</code> package is just a wrapper around three packages called <code>diagrams-core</code>, <code>diagrams-lib</code>, and <code>diagrams-contrib</code>. The purpose of the wrapper is to make it easier to install because you can issue one command instead of three. We will use two of these three packages plus one other. We will use <code>diagrams-core</code>, <code>diagrams-lib</code>, and <code>diagrams-cairo</code>.</p>&#13;
<p class="indent">Similar to <code>gloss</code>, the <code>diagrams-cairo</code> package uses some graphics libraries to do its work, and you must install these non-Haskell libraries separately from the <code>diagrams-cairo</code> package itself. So, like installing <code>gnuplot</code> and <code>gloss</code>, installing <code>diagrams</code> is a two-step process. First, you must install the non-Haskell graphics libraries. Second, you must install the Haskell <code>diagrams</code> packages.</p>&#13;
<p class="indent">The graphics libraries needed are called <code>cairo</code> and <code>pango</code>. The procedure for installing these libraries depends on your operating system. For a GNU/Linux system, a command such as</p>&#13;
<pre>$ <span class="codestrong1">sudo apt install libcairo2-dev libpango1.0-dev</span></pre>&#13;
<p class="noindent">should do the trick. On macOS, you can use a similar command with the <code>brew</code> package manager.</p>&#13;
<p class="indent">After you’ve installed the <code>cairo</code> and <code>pango</code> libraries, you can install the <code>diagrams</code> packages with a command like</p>&#13;
<pre>$ <span class="codestrong1">cabal install --lib diagrams-core diagrams-lib diagrams-cairo</span></pre>&#13;
<p class="noindent">or</p>&#13;
<pre>$ <span class="codestrong1">stack install diagrams-core diagrams-lib diagrams-cairo</span></pre>&#13;
<p class="noindent">depending on whether you are using Cabal or Stack.</p>&#13;
<h3 class="h3" id="appalev11">Setting Up Your Coding Environment</h3>&#13;
<p class="noindent">As this book progresses, our code gets more complicated because we use modules other people have written and modules that we have written ourselves. We want to load some of our code into GHCi, and we also want to <span epub:type="pagebreak" id="page_588"/>write stand-alone programs. Thus, we need a way to stay organized so that we have access to the modules we need so we are empowered to do the things we want to do. There are two main ways to stay organized:</p>&#13;
<p class="numberlistr">(1) Keep all of your source code files in a single directory. This includes files intended for loading into GHCi as well as stand-alone programs. Install packages so that this directory has access to them. Arrange for this directory to have access to the modules from the book.</p>&#13;
<p class="numberlistr">(2) Create a fresh directory for each project you work on. See that this directory has access to whatever modules and packages the project needs. Each directory might have a <em>.cabal</em> file and, if you are using <code>stack</code>, a <em>stack.yaml</em> file. These files describe the requirements for your project.</p>&#13;
<p class="indent">I recommend method (1), at least until you see some advantage in making a new directory for a new project. For the purposes of this book, the exercises you are asked to do are not so large that each demands its own directory.</p>&#13;
<h4 class="h4" id="appalev12">What We Want in a Coding Environment</h4>&#13;
<p class="noindent">Before I give two specific suggestions for organizing your coding environment, let’s lay out what we are trying to achieve. What follows are four desired properties we want our coding environment to have:</p>&#13;
<p class="alphats">(a) We want to be able to load a source code file we have written into GHCi with GHCi’s <code>:l</code> command. Such a source code file may or may not have a module name. Such a source code file also may or may not import modules using Haskell’s <code>import</code> keyword.</p>&#13;
<p class="alphats">(b) We want to be able to load a module that someone else has written, such as <code>Graphics.Gnuplot.Simple</code>, into GHCi with GHCi’s <code>:m</code> command.</p>&#13;
<p class="alphats">(c) We want to be able to produce an executable program from a source code file we have written. Such a source code file may or may not import modules using Haskell’s <code>import</code> keyword.</p>&#13;
<p class="alphats">(d) We want to be able to use the modules defined in this book by loading them into GHCi and by writing source code to <code>import</code> them.</p>&#13;
<p class="indent">To load a source code file into GHCi, as desired in (a), we will need to start GHCi in the directory where our file lives. If our source code file imports modules, it needs access to them. If a module our source code file imports is provided by a package, the current working directory must have access to that package. This can be either local or global access, as defined earlier in this appendix. If the module is defined in a source code file, such as one of the modules written in this book, that file must live in the working directory, or in a place where GHC knows to look for it.</p>&#13;
<p class="indent">To load a module written by someone else into GHCi, as desired in (b), the working directory needs to have access to the package that provides <span epub:type="pagebreak" id="page_589"/>the module we wish to load. This can be local or global access, as described earlier.</p>&#13;
<p class="indent">Producing a stand-alone program, as desired in (c), is the subject of <a href="ch12.xhtml">Chapter 12</a>. There, we discuss three methods to produce a stand-alone program: one using GHC, one using Cabal, and one using Stack. Using Cabal or Stack as described in that chapter is a form of method (2) since we are allowed to have only one <em>.cabal</em> file in each directory. However, that <em>.cabal</em> file is allowed to specify multiple stand-alone programs, so it is possible to use Cabal or Stack with method (1).</p>&#13;
<p class="indent">To achieve (d), the simplest thing is to put all of the module-defining <em>.hs</em> files (such as <em>Mechanics3D.hs</em>, which defines the <code>Mechanics3D</code> module) into your working directory. Since the source code file you write is also in this directory, GHC will look for modules your source code file imports in the working directory when you load your file into GHCi, or when you compile it with GHC.</p>&#13;
<p class="indent">The following two sections give specific suggestions about where to put the modules defined in this book, which you can download at <a href="https://lpfp.io">https://lpfp.io</a>. The two suggestions are alternatives, so you need to follow only one of them.</p>&#13;
<h4 class="h4" id="appalev13">All Code in One Directory</h4>&#13;
<p class="noindent">As suggested earlier, the simplest method for staying organized is to put everything in one directory. This includes:</p>&#13;
<ul class="bull">&#13;
<li class="noindent">Source code files you intend to load into GHCi</li>&#13;
<li class="noindent">Source code files you intend to compile into executable programs</li>&#13;
<li class="noindent">Source code files, such as <em>Mechanics3D.hs</em>, for the modules defined in this book</li>&#13;
</ul>&#13;
<p class="indent">This one directory will be your working directory for all of your Haskell work. If you continue to program in Haskell, you will outgrow this method. You will want to work on different projects with different purposes and different needs, and you won’t want all of your code in one directory. When you get to this point, there are many ways forward. The Cabal and Stack tools offer many ways to organize your work.</p>&#13;
<p class="indent">For now, we need to make sure our one working directory has access to all of the packages we need for the projects in this book. The following command, to be entered as one long line at a command prompt, will locally install all the packages we need for this book.</p>&#13;
<pre>$ <span class="codestrong1">cabal install --lib gnuplot gloss not-gloss spatial-math diagrams-lib</span>&#13;
  <span class="codestrong1">diagrams-cairo --package-env .</span></pre>&#13;
<p class="indent">One disadvantage of this method is that we can load the book modules with GHCi’s <code>:l</code> command but not with GHCi’s <code>:m</code> command, and this means we can load only one book module into GHCi at a time. This could be inconvenient if we want access in GHCi to functions defined in different book modules. One way around this is to make a new source code file that <span epub:type="pagebreak" id="page_590"/>imports all the modules we want, and then load that source code file into GHCi with <code>:l</code>.</p>&#13;
<p class="indent">Another way around this disadvantage is to use the Stack tool to manage the modules from this book, as explained in the next section.</p>&#13;
<h4 class="h4" id="appalev14">One Way to Use Stack</h4>&#13;
<p class="noindent">The Cabal and Stack tools provide many (maybe too many) ways for you to organize your work in Haskell. Here we will look at one way in detail. In this method, we still have one directory that contains all of our Haskell work, but this directory has two subdirectories: one for the book modules, and one for stand-alone programs. So there are three places where source code files can exist. They can live in the main working directory, they can live in the module subdirectory, or they can live in the stand-alone program subdirectory. A source code file you intend to load into GHCi will probably live in the main working directory.</p>&#13;
<p class="indent">Stack needs two configuration files to manage things. One is named <em>LPFP.cabal</em>, and the other is named <em>stack.yaml</em>. These two files will live in the main working directory. The file <em>LPFP.cabal</em> describes the modules we want to have access to, as well as the executable programs we want Stack to build for us. <a href="#app01ex01">Listing A-1</a> gives this file.</p>&#13;
<pre id="appalist1">cabal-version:  1.12&#13;
&#13;
name:           LPFP&#13;
version:        1.0&#13;
description:    Code for the book Learn Physics with Functional Programming&#13;
homepage:       http://lpfp.io&#13;
author:         Scott N. Walck&#13;
maintainer:     walck@lvc.edu&#13;
copyright:      2022 Scott N. Walck&#13;
license:        BSD3&#13;
license-file:   LICENSE&#13;
build-type:     Simple&#13;
&#13;
library&#13;
  exposed-modules:&#13;
      Charge, CoordinateSystems, Current, ElectricField, Electricity, Geometry&#13;
    , Integrals, Lorentz, MagneticField, Maxwell, Mechanics1D, Mechanics3D&#13;
    , MOExamples, MultipleObjects, Newton2, SimpleVec&#13;
  hs-source-dirs: src&#13;
  build-depends:&#13;
      base &gt;=4.7 &amp;&amp; &lt;5, gnuplot, spatial-math, gloss, not-gloss, diagrams-lib&#13;
    , diagrams-cairo, containers&#13;
  default-language: Haskell2010&#13;
&#13;
executable LPFP-VisTwoSprings&#13;
  main-is: VisTwoSprings.hs&#13;
  hs-source-dirs: app&#13;
  <span epub:type="pagebreak" id="page_591"/>build-depends: LPFP, base &gt;=4.7 &amp;&amp; &lt;5, not-gloss&#13;
  default-language: Haskell2010&#13;
&#13;
executable LPFP-GlossWave&#13;
  main-is: GlossWave.hs&#13;
  hs-source-dirs: app&#13;
  build-depends: LPFP, base &gt;=4.7 &amp;&amp; &lt;5, gloss&#13;
  default-language: Haskell2010</pre>&#13;
<p class="listing" id="app01ex01"><em>Listing A-1: The file</em> <code>LPFP.cabal</code> <em>describing the modules we want access to and the executables we want produced</em></p>&#13;
<p class="indent">After some introductory matter appear one library stanza and two executable stanzas. The library stanza lists all of the modules from this book that we want to have access to. It says that the source code for these modules is in the subdirectory <em>src</em> and that these modules depend on several packages, such as <code>gnuplot</code> and <code>gloss</code>. The <code>base</code> module contains most of the essential libraries for the simplest data types. The version specification means “version 4.7 or newer, but the major version must be less than 5.” The “default-language” specification tells us that we’re using the 2010 version of the Haskell language specification, which is the current version. The previous version was Haskell98, which gives you a hint of how much time elapses between major revisions to the language.</p>&#13;
<p class="indent">There is one executable stanza for each stand-alone program we want Stack to build for us. Two are listed here, but you can have as many as you like. The first executable stanza describes the stand-alone program for the source code file <em>VisTwoSprings.hs</em> in the subdirectory called <em>app</em>. The executable program will be called <em>LPFP-VisTwoSprings</em> and will be available globally to run from any directory. The packages required by this stand-alone program are listed as well.</p>&#13;
<p class="indent">At the time of writing, the <code>diagrams</code> packages are not included in the curated list of packages Stack uses by default, so we must list some extra packages in a file called <em>stack.yaml</em>. <a href="#app01ex02">Listing A-2</a> shows this file.</p>&#13;
<pre id="appalist2">resolver: lts-18.21&#13;
&#13;
packages:&#13;
- .&#13;
&#13;
extra-deps:&#13;
- diagrams-cairo-1.4.1.1&#13;
- diagrams-lib-1.4.4&#13;
- active-0.2.0.15&#13;
- cairo-0.13.8.1&#13;
- diagrams-core-1.5.0&#13;
- dual-tree-0.2.3.0&#13;
- monoid-extras-0.6.1&#13;
- pango-0.13.8.1&#13;
<span epub:type="pagebreak" id="page_592"/>- statestack-0.3&#13;
- glib-0.13.8.1&#13;
- gtk2hs-buildtools-0.13.8.2</pre>&#13;
<p class="listing" id="app01ex02"><em>Listing A-2: The file stack.yaml describing the extra dependencies the modules in this book need</em></p>&#13;
<p class="indent">For each version of the compiler, Stack supports a collection of curated packages that are known to build with that compiler and to be generally compatible with each other. A compiler and package set is specified by a version number. In <a href="#app01ex02">Listing A-2</a>, <code>lts-18.21</code> in the <code>resolver</code> field means “GHC 8.10.7 and packages compatible with it.” This particular compiler/package collection has long-term support (the <code>lts-</code> prefix). This means you can count on it being around for awhile, typically a few years.</p>&#13;
<p class="indent">If you need to live on the bleeding edge to get the features you need, there are snapshot collections and, for the very latest, the nightly build.</p>&#13;
<p class="indent">The next field, <code>packages</code> refers to packages that <em>you</em> have written, typically libraries useful for your own project. In <a href="#app01ex02">Listing A-2</a>, the packages are simply files in the current directory, or “<code>.</code>” in Unix-speak.</p>&#13;
<p class="indent">The <code>extra-deps</code> are additional packages your application depends on that are not part of the curated set specified by the <code>resolver</code> field. (There is in fact not much difference between a <code>package</code> and an <code>extra-dep</code> except that it is possible to write test and benchmark targets for our own packages—very important parts of a large application—and these are not available for <code>extra-deps</code>.)</p>&#13;
<p class="indent">Your first stop for questions about the <em>stack.yaml</em> file should be <a href="https://docs.haskellstack.org/en/stable/README">https://docs.haskellstack.org/en/stable/README</a>.</p>&#13;
<p class="indent">You can see the packages <code>diagrams-core</code>, <code>diagrams-lib</code>, and <code>diagrams-cairo</code> we are interested in. The remaining packages are packages <code>diagrams</code> depends on. Specific versions of these packages are listed. By the time this book appears in print, newer versions of these packages may be available.</p>&#13;
<p class="indent">To build the executable programs, issue the following command in the main working directory (the directory in which the <em>stack.yaml</em> and <em>LPFP.cabal</em> files live):</p>&#13;
<pre>$ <span class="codestrong1">stack install</span></pre>&#13;
<p class="indent">To start a GHCi session in which all of the book modules are automatically loaded, you can issue the following command:</p>&#13;
<pre>$ <span class="codestrong1">stack ghci</span></pre>&#13;
<p class="indent">With this method, we can load any or all of the book modules into GHCi. To remove a module, you can use GHCi’s <code>:m</code> command with the module prefixed by a minus sign. To remove the <code>Newton2</code> module, type the following:</p>&#13;
<pre>ghci&gt;  <span class="codestrong1">:m -Newton2</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_593"/>Similarly, to add an additional module, use a plus sign prefix. To add the <code>Graphics.Gnuplot.Simple</code> module, type the following:</p>&#13;
<pre>ghci&gt;  <span class="codestrong1">:m +Graphics.Gnuplot.Simple</span></pre>&#13;
<p class="indent">Issuing <code>stack ghci</code> will also give you the option of loading one of the executable programs into GHCi if you wish.</p>&#13;
<h3 class="h3" id="appalev15">Summary</h3>&#13;
<p class="noindent">This appendix described how to install the Haskell compiler and a text editor, and it went over methods for installing additional library packages using Cabal and Stack. It also showed different ways to organize libraries and source code files for building projects in Haskell.<span epub:type="pagebreak" id="page_594"/></p>&#13;
</div></body></html>