- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 9 NUMERIC CONVERSION
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9 数字转换
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This chapter discusses basic conversions between various numeric formats, including
    integer to decimal string, integer to hexadecimal string, floating-point to string,
    hexadecimal string to integer, decimal string to integer, and real string to floating-point.
    It also covers error handling for string-to-numeric conversions, as well as performance
    enhancements. Finally, it introduces standard-precision conversions (for 8-, 16-,
    32-, and 64-bit integer formats) and extended-precision conversions (for example,
    128-bit integer/string conversions).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了各种数字格式之间的基本转换，包括整数到十进制字符串、整数到十六进制字符串、浮点数到字符串、十六进制字符串到整数、十进制字符串到整数以及实数字符串到浮点数。还涵盖了字符串到数字转换的错误处理以及性能优化。最后，介绍了标准精度转换（适用于8位、16位、32位和64位整数格式）和扩展精度转换（例如，128位整数/字符串转换）。
- en: In this chapter, you’ll begin to solve problems directly in assembly language,
    rather than translating a solution from an HLL as you did in previous chapters.
    Some examples here first present code that solves a problem with an HLL-based
    solution, then provide an optimized assembly language solution. This should help
    you learn to solve assembly language problems without relying on HLLs, thereby
    producing higher-quality programs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将直接在汇编语言中解决问题，而不是像前几章那样从高级语言（HLL）中翻译解决方案。这里的一些示例首先展示了一个使用HLL解决问题的代码，然后提供一个优化后的汇编语言解决方案。这应该帮助您学习在不依赖HLL的情况下解决汇编语言问题，从而生成更高质量的程序。
- en: 9.1 Converting Numeric Strings to Values
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1 将数字字符串转换为值
- en: Up to this point, this book has relied on the C stdlib to perform numeric I/O
    (writing numeric data to the display and reading numeric data from the user).
    However, the library doesn’t provide extended-precision numeric I/O facilities
    (and even 64-bit numeric I/O is questionable; this book has been using a GCC extension
    to printf() to do 64-bit numeric output). Therefore, it’s time to break down how
    to do numeric I/O in assembly language.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书一直依赖C标准库来执行数字输入/输出（将数字数据写入显示屏并从用户读取数字数据）。然而，标准库并不提供扩展精度的数字I/O功能（甚至64位数字I/O都存在问题；本书一直在使用GCC扩展的printf()来执行64位数字输出）。因此，现在是时候了解如何在汇编语言中进行数字I/O了。
- en: Because most OSes support only character or string input and output, you won’t
    actually do numeric I/O. Instead, you’ll write functions that convert between
    numeric values and strings, then do string I/O. The examples in this section work
    with 64-bit (non-extended-precision) and 128-bit values, but the algorithms are
    general and extend to any number of bits.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数操作系统只支持字符或字符串输入和输出，您实际上不会执行数字I/O。相反，您将编写函数来转换数字值和字符串之间的关系，然后进行字符串I/O。本节中的示例适用于64位（非扩展精度）和128位值，但算法是通用的，可以扩展到任何位数。
- en: 9.1.1 Numeric Values to Hexadecimal Strings
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1 数字值到十六进制字符串
- en: 'In this section, you’ll learn to convert numeric values (bytes, half words,
    words, double words, and so on) to a character string containing the equivalent
    hexadecimal characters for the value. To begin, you need a function that converts
    a 4-bit nibble into a single ASCII character in the range ''0'' to ''9'' or ''A''
    to ''F''. In an HLL such as C, you could write this as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何将数值（字节、半字、字、双字等）转换为包含等效十六进制字符的字符串。首先，您需要一个函数，将4位的半字节转换为一个单一的ASCII字符，字符范围为
    '0' 到 '9' 或 'A' 到 'F'。在类似C的高级语言（HLL）中，您可以按如下方式编写此函数：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can convert any numeric value in the range 0 to 9 to its corresponding ASCII
    character by ORing the numeric value with '0' (0x30). Unfortunately, this maps
    numeric values in the range 0xA through 0xF to 0x3A through 0x3F, so the C code
    checks to see if it produces a value greater than 0x3A and adds 7 ('A' – '9' –
    1) to produce a final character code in the range 0x41 to 0x46 ('A' through 'F').
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将数字值与 '0'（0x30）进行或运算，将任何0到9范围内的数值转换为其对应的ASCII字符。不幸的是，这会将0xA到0xF范围内的数字值映射到0x3A到0x3F，因此C代码会检查是否产生了大于0x3A的值，并加上7（'A'
    – '9' – 1），以生成最终的字符代码，范围为0x41到0x46（'A'到'F'）。
- en: With a function that converts a nibble to the appropriate ASCII character, you
    can convert bytes, half words, and so on by taking all the nibbles in the number
    and calling the function on each one to produce the corresponding output character.
    However, because ARM assembly language programs generally deal with objects no
    smaller than a byte, it’s more straightforward and efficient to write a function
    that converts a byte value to two ASCII characters. Let’s call this function btoh
    (byte to hex).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个将半字节转换为相应ASCII字符的函数，你可以通过获取数字中的所有半字节并对每一个半字节调用该函数来转换字节、半字等。然而，由于ARM汇编语言程序通常处理的对象不小于字节，因此编写一个将字节值转换为两个ASCII字符的函数会更直接、更高效。我们将这个函数称为btoh（字节到十六进制）。
- en: Listing 9-1 shows a straightforward btoh implementation. This function expects
    a single-byte value in X1 (ignoring bits 8 to 63 in X1) and returns the two characters
    in bits 0 to 15 of X1\. Listing 9-1 converts a C algorithm into assembly language
    by using the techniques described in [Chapter 7](chapter7.xhtml).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-1展示了一个直接的btoh实现。该函数期望X1中的单字节值（忽略X1中位8到63的部分），并返回X1中位0到15的两个字符。清单9-1通过使用[第7章](chapter7.xhtml)中描述的技术，将C算法转换为汇编语言。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function returns the character corresponding to the HO nibble in bits 0
    through 7 ❶ and the character corresponding to the LO nibble in bits 8 through
    15 ❷. This is because you’ll generally use this function to build up character
    strings containing the converted hexadecimal value. Character strings are inherently
    *big-endian*, with the most significant digit appearing in the lowest memory address
    (so the number will be read from left to right when you print the string). Returning
    the two characters swapped in X1 allows you to store the two characters as a half-word
    value into memory by using a single instruction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回对应于位0到7中的HO半字节❶的字符，以及对应于位8到15中的LO半字节❷的字符。这是因为你通常会使用该函数构建包含转换后的十六进制值的字符字符串。字符字符串本质上是*大端序*，最重要的数字出现在最低的内存地址（因此当你打印字符串时，数字会从左到右读取）。将两个字符交换后返回到X1，允许你通过单条指令将这两个字符作为半字存储到内存中。
- en: You may be wondering why btoh_simple passes the value to convert in X1 rather
    than X0 (the standard “first argument” location). This is in anticipation of functions
    that will output the characters to a memory buffer (string). For those string-based
    functions, X0 will contain the address of the buffer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，为什么btoh_simple将值传递给X1中的convert，而不是X0（标准的“第一个参数”位置）。这是为了预见到将来会有一些函数将字符输出到内存缓冲区（字符串）。对于这些基于字符串的函数，X0将包含缓冲区的地址。
- en: 'Because Listing 9-1 is basically hand-compiled C/C++ code, the performance
    will be about the same as (or worse than) the code produced by an optimizing C/C++
    compiler processing the C code given earlier. To write faster code in assembly
    language, you’ll first need to measure the performance of two functions to determine
    which one is faster. While you can do so with many software tools (performance
    analyzers, or *profilers*), I’ve employed a simple solution: write a main program
    that calls the function many times, then use the Unix time command line utility
    to measure the amount of time the program takes to run. Listing 9-2 shows such
    a program, for example.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于清单9-1基本上是手动编译的C/C++代码，因此性能大致与（或比）优化C/C++编译器处理之前给出的C代码要差。为了编写更快的汇编语言代码，你首先需要测量两个函数的性能，以确定哪一个更快。虽然可以使用许多软件工具（性能分析器或*分析器*）来进行此操作，但我采用了一个简单的解决方案：编写一个主程序，反复调用该函数，然后使用Unix时间命令行工具来测量程序运行所需的时间。例如，清单9-2展示了这样一个程序。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: An advanced software engineer might find several faults with this technique
    for measuring the executing time of some code. However, it is simple, is easy
    to understand and use, and doesn’t require any special software tools. While the
    measurements it produces are not perfect, it’s good enough for most purposes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一位高级软件工程师可能会发现这种测量代码执行时间的技术存在几个缺陷。然而，它简单、易于理解和使用，并且不需要任何特殊的软件工具。尽管它所产生的测量结果并不完美，但对于大多数目的来说已经足够。
- en: 'Here’s the build command and sample output (using the Unix time command to
    time the running of the program):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和示例输出（使用Unix时间命令来计时程序运行）：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On my Mac mini M1, this took about 3.5 seconds to run. (Obviously, this will
    vary by system; for example, on a Raspberry Pi 3, it took about 37 seconds.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的Mac mini M1上，这大约花费了3.5秒时间运行。（显然，这会因系统而异；例如，在Raspberry Pi 3上，它大约花费了37秒。）
- en: As noted in [Chapter 7](chapter7.xhtml), branches tend to run slower than straight-line
    code. Listing 9-2 uses branches to handle cases when the converted character is
    '0' through '9' or 'A' through 'F'. I wrote a version using the csel instruction
    to differentiate these two cases after ORing or adding '0' to the nibble value.
    The code ran in 2.5 seconds (on a Mac mini M1). However, this was achieved by
    not preserving the X1 and X2 registers. Saving X1 and X2 to memory and restoring
    them increased the execution time to 4.68 seconds.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第7章](chapter7.xhtml)所述，分支指令通常比直线代码运行得更慢。清单9-2使用了分支来处理转换后的字符是'0'到'9'或'A'到'F'的情况。我写了一个使用csel指令的版本，用于区分这两种情况，方法是在对半字值进行OR操作或加上'0'后使用它。代码运行时间为2.5秒（在Mac
    mini M1上）。然而，这是通过不保存X1和X2寄存器实现的。将X1和X2保存到内存并恢复它们使得执行时间增加到了4.68秒。
- en: 'You’ve just discovered a big time sink in ARM assembly code: accessing memory
    is very slow (and the ldp/stp instructions are much slower than the ldr/str instructions).
    This is why Arm defined nonvolatile registers, so you don’t have to preserve certain
    working registers in memory. Nevertheless, preserving volatile registers is sometimes
    worthwhile to ensure that programs are correct. Assembly language code can quickly
    become complex, and having a function stomp on registers you forgot to save in
    your calling code can lead to long debugging sessions. A fast program with defects
    is never as good as a slower program that works properly.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚发现了ARM汇编代码中的一个大时间瓶颈：访问内存非常慢（而且ldp/stp指令比ldr/str指令慢得多）。这就是为什么ARM定义了非易失性寄存器的原因，这样你就不必在内存中保存某些工作寄存器。然而，保存易失性寄存器有时是值得的，以确保程序的正确性。汇编语言代码可能很快变得复杂，而一个函数覆盖了你在调用代码中忘记保存的寄存器，可能导致长时间的调试过程。一个有缺陷的快速程序永远不如一个运行正常的较慢程序好。
- en: When writing 32-bit ARM code for a Raspberry Pi 400 (for the second volume of
    this series), I discovered that using a 256-element lookup table (with each element
    containing the two characters corresponding to the hexadecimal value) was faster
    than the standard algorithm. When I tried that approach in 64-bit ARM assembly,
    the runtime was 4.6 seconds. Once again, memory accesses (at least on the Apple
    M1 CPU) are expensive. On a different system, such as a Pi 3, 4, or 5, you will
    get different results.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Raspberry Pi 400编写32位ARM代码时（这是本系列的第二卷），我发现使用一个256元素的查找表（每个元素包含与十六进制值对应的两个字符）比标准算法更快。当我在64位ARM汇编中尝试这种方法时，运行时间为4.6秒。再一次，内存访问（至少在Apple
    M1 CPU上）是昂贵的。在其他系统上，如Pi 3、4或5，你会得到不同的结果。
- en: Once you can convert a single byte to a pair of hexadecimal characters, creating
    a string, output to the display is straightforward. We can call the btoh (byte
    to hex) function for each byte in the number and store the corresponding characters
    away in a string. With this function, you can write btoStr (byte to string), hwtoStr
    (half word to string), wtoStr (word to string), and dtoStr (double word to string)
    functions. This chapter expands several of the lower-level functions (btoStr,
    hwtoStr, and wtoStr) and uses procedure calls to the smaller functions for the
    larger-sized conversions (dtoStr). In [Chapter 13](chapter13.xhtml), I discuss
    macros that will provide another way to easily expand these functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你能够将单个字节转换为一对十六进制字符，创建字符串并输出到显示器就变得简单了。我们可以为数字中的每个字节调用btoh（字节到十六进制）函数，并将相应的字符存储在字符串中。通过这个函数，你可以编写btoStr（字节到字符串）、hwtoStr（半字到字符串）、wtoStr（字到字符串）和dtoStr（双字到字符串）函数。本章扩展了几个较低级别的函数（btoStr、hwtoStr和wtoStr），并使用过程调用来处理较大尺寸的转换（dtoStr）。在[第13章](chapter13.xhtml)中，我讨论了宏，它们将提供另一种简便的方式来扩展这些函数。
- en: The approach this book takes is to try to write fast conversion code. If you
    would prefer to save space rather than increase speed, see the following “Reducing
    Code Size” box for details.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的方法是尽量编写快速转换代码。如果你更倾向于节省空间而不是提高速度，请参见以下“减少代码大小”框中的详细信息。
- en: 'All the binary-to-hexadecimal string functions will accept two parameters:
    a value to convert in the X1 register, and a pointer to a string buffer to hold
    the string result in X0\. These functions will assume that the buffer is sufficiently
    large to hold the string result: btoStr requires a 3-character buffer, hwtoStr
    requires a 5-character buffer, wtoStr requires a 9-character buffer, and dtoStr
    requires a 17-character buffer. Each byte in the value requires two characters
    in the buffer. In addition to the character data, the buffer must also include
    1 byte for the zero-terminating byte. The caller is responsible for ensuring that
    the buffer is large enough.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的二进制到十六进制字符串函数都将接受两个参数：X1 寄存器中的待转换值，以及一个指向字符串缓冲区的指针，结果将保存在 X0 中。这些函数假设缓冲区足够大，能够容纳字符串结果：btoStr
    需要一个 3 字符的缓冲区，hwtoStr 需要一个 5 字符的缓冲区，wtoStr 需要一个 9 字符的缓冲区，dtoStr 需要一个 17 字符的缓冲区。值中的每个字节需要两个字符存放在缓冲区中。除了字符数据外，缓冲区还必须包含
    1 字节用于零终止字节。调用者需要负责确保缓冲区足够大。
- en: 'To implement these four hexadecimal-to-string functions, I’ll start by writing
    four hexadecimal-to-buffer functions. There are two differences between the *tobuf
    and *tostr functions (where the * indicates a substitution of b, hw, w, or d,
    as per regular expression syntax):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这四个十六进制到字符串的函数，我将首先编写四个十六进制到缓冲区的函数。*tobuf 和 *tostr 函数之间有两个不同之处（其中 * 表示根据正则表达式语法的替代：b、hw、w
    或 d）。
- en: The *tobuf functions do not preserve any registers. They modify the values in
    X0 and X2.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*tobuf 函数不会保留任何寄存器。它们会修改 X0 和 X2 中的值。'
- en: The *tobuf functions leave X0 pointing at the zero-terminating byte at the end
    of the string, which is often useful; the *tostr functions preserve X0’s value
    (pointing at the first character of the output buffer).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*tobuf 函数将 X0 指向字符串末尾的零终止字节，这通常是有用的；*tostr 函数则保留 X0 的值（指向输出缓冲区的第一个字符）。'
- en: 'I will also take this opportunity to introduce another assembly language feature:
    multiple entry points to a function. The btobuf, htobuf, wtobuf, and dtobuf functions
    all contain common code. Listing 9-3 merges all these functions into a single
    function (dtobuf) with separate entry points into the code sequence for the other
    three functions.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将借此机会介绍另一项汇编语言特性：函数的多个入口点。btobuf、htobuf、wtobuf 和 dtobuf 函数都包含公共代码。示例 9-3 将所有这些函数合并为一个单一的函数（dtobuf），并为其他三个函数提供单独的代码入口。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The dtobuf function begins by processing the HO nibble (nibble 15) of the dword
    ❶. For performance reasons, this code uses an unrolled loop, processing each nibble
    individually. Each nibble uses the standard algorithm for converting a binary
    value to a hexadecimal character.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: dtobuf 函数首先处理 dword ❶ 的 HO nibble（nibble 15）。为了提高性能，这段代码使用了展开的循环，逐个处理每个 nibble。每个
    nibble 使用标准算法将二进制值转换为十六进制字符。
- en: After this code processes the HO eight hex digits, you’ll notice an entry point
    for the wtobuf function ❷. Code calling wtobuf transfers control into the middle
    of the dtobuf function (literally). This works because dtobuf doesn’t push anything
    onto the stack or otherwise alter the environment that would require special work
    by wtobuf on entry. Likewise, entry points for htobuf ❸ and btobuf ❹ are at nibbles
    3 and 1, respectively. By merging these functions into a single section of code,
    you save all the code that would be used for wtobuf, htobuf, and btobuf.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码处理完 HO 八个十六进制数字后，你会注意到 wtobuf 函数 ❷ 的入口点。调用 wtobuf 的代码会将控制转移到 dtobuf 函数的中间部分（字面意义上）。之所以能这样工作，是因为
    dtobuf 不会将任何内容压入堆栈，也不会以其他方式改变环境，因此 wtobuf 进入时不需要特殊处理。类似地，htobuf ❸ 和 btobuf ❹ 的入口点分别位于
    nibble 3 和 nibble 1。通过将这些函数合并到一个代码段中，你节省了 wtobuf、htobuf 和 btobuf 函数所需的所有代码。
- en: I made several failed attempts at optimizing this code. First, I tried saving
    8 bytes in a register and wrote the data to memory a dword at a time rather than
    a byte at a time. This ran slower (on my Mac mini M1). I also tried eliminating
    branches in the code by using csel instructions. Surprisingly, that code ran slower
    too. I even tried using a ubfx instruction (see [Chapter 12](chapter12.xhtml)),
    which still ran slower than the code with branches. I timed these versions on
    a Mac mini M1 and a Raspberry Pi 400\. While the timings on the two machines varied
    greatly, the relative performance of the three algorithms remained the same (the
    branch version was always faster). Sometimes, getting clever with different algorithms
    can hurt you. That’s why you should always test the performance of your code (preferably
    on multiple architectures).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我做了几次失败的优化尝试。首先，我尝试将 8 个字节保存在一个寄存器中，并按双字（dword）而不是按字节逐个写入内存。这在我的 Mac mini M1
    上运行得更慢。我还尝试通过使用 csel 指令消除代码中的分支，结果代码反而变得更慢。甚至我还尝试使用 ubfx 指令（请参见[第12章](chapter12.xhtml)），但它的执行速度仍然比带分支的代码更慢。我在
    Mac mini M1 和 Raspberry Pi 400 上对这些版本进行了计时。尽管这两台机器的计时差异很大，但三种算法的相对性能保持不变（带分支的版本始终更快）。有时候，使用不同的算法技巧反而会适得其反。这就是为什么你应该始终测试你的代码性能（最好是在多种架构上进行测试）的原因。
- en: With the *tobuf functions out of the way, writing the *toStr functions is relatively
    easy. The *toStr functions simply call the *tobuf functions and preserve the registers
    that the *tobuf functions modify. Listing 9-4 provides the code for these functions
    (note that *Listing9-4.S*, from the online files, also includes the code for the
    dtobuf function; to avoid redundancy, I’ve removed that code from the listing).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完 *tobuf 函数后，编写 *toStr 函数相对容易。*toStr 函数仅调用 *tobuf 函数，并保留 *tobuf 函数修改的寄存器。清单
    9-4 提供了这些函数的代码（请注意，在线文件中的 *Listing9-4.S* 还包括了 dtobuf 函数的代码；为了避免冗余，我已经将该代码从清单中移除）。
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As noted, I’ve pulled the dtobuf function out of this listing; insert that code
    ❶. The btoStr function ❷ saves the X0, X2, and LR registers on the stack (the
    registers that will be modified by calls to the *tobuf functions), calls the btobuf
    function to write the two hex digits to the buffer pointed at by X0, then restores
    the registers and returns. The code does largely the same for htoStr ❸, wtoStr
    ❹, and dtoStr ❺, the only difference being the conversion function they call.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，我已将 dtobuf 函数从此清单中移除；请插入该代码 ❶。btoStr 函数 ❷ 将 X0、X2 和 LR 寄存器保存在堆栈中（这些寄存器会被
    *tobuf 函数调用修改），调用 btobuf 函数将两个十六进制数字写入 X0 所指向的缓冲区，然后恢复寄存器并返回。对于 htoStr ❸、wtoStr
    ❹ 和 dtoStr ❺，代码基本相同，唯一的区别是它们调用的转换函数不同。
- en: 'Here’s the build command and sample output for the program in Listing 9-4:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是清单 9-4 中程序的构建命令和示例输出：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the assembly code appearing in this book calls C/C++ standard library functions
    for I/O, these binary-to-hexadecimal-string functions will all produce zero-terminated
    C-compatible strings. They are easy enough to modify to produce other string formats,
    if need be. See [Chapter 14](chapter14.xhtml) for more on string functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中出现的汇编代码调用了 C/C++ 标准库函数进行 I/O 操作，因此这些二进制到十六进制字符串的函数将生成零终止的 C 兼容字符串。如果需要的话，它们足够简单，能够修改以生成其他字符串格式。更多关于字符串函数的内容，请参见[第14章](chapter14.xhtml)。
- en: 9.1.2 Extended-Precision Hexadecimal Values to Strings
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2 扩展精度的十六进制值转换为字符串
- en: 'Extended-precision hexadecimal-to-string conversion is easy: it’s simply an
    extension of the normal hexadecimal conversion routines from the previous section.
    For example, Listing 9-5 is a 128-bit hexadecimal conversion function, qtoStr,
    which expects a pointer to a 128-bit value in X2:X1 and a pointer to a buffer
    in X0\. *Listing9-5.S* is largely based on *Listing9-4.S*; to avoid redundancy,
    I’ve included just the qtoStr function here.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展精度的十六进制到字符串转换很简单：它只是上一节中正常的十六进制转换例程的扩展。例如，清单 9-5 是一个 128 位十六进制转换函数 qtoStr，它期望
    X2:X1 中的指针指向一个 128 位值，而 X0 中的指针指向一个缓冲区。*Listing9-5.S* 基本上是基于 *Listing9-4.S*；为了避免冗余，这里只包含了
    qtoStr 函数。
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The function in Listing 9-5 calls dtobuf twice to convert the 128-bit qword
    value to a string by converting first the HO dword, then the LO dword, and concatenating
    their results. To extend this conversion to any number of bytes, simply convert
    the HO bytes down to the LO bytes of the large object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-5 中的函数调用了 dtobuf 两次，通过首先转换 HO 双字（dword），然后转换 LO 双字（dword），并连接它们的结果，将 128
    位的 qword 值转换为字符串。要将此转换扩展到任意数量的字节，只需将 HO 字节转换为大对象的 LO 字节即可。
- en: 9.1.3 Unsigned Decimal Values to Strings
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3 无符号十进制值转换为字符串
- en: Decimal output is a little more complicated than hexadecimal output because,
    unlike for hexadecimal values, the HO bits of a binary number affect the LO digits
    of the decimal representation. Therefore, you must create the decimal representation
    for a binary number by extracting one decimal digit at a time from the number.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制输出比十六进制输出稍微复杂一些，因为与十六进制值不同，二进制数的高位（HO）位会影响十进制表示中的低位（LO）数字。因此，必须通过一次提取一个十进制数字的方式来创建二进制数的十进制表示。
- en: The most common solution for unsigned decimal output is to successively divide
    the value by 10 until the result becomes 0\. The remainder after the first division
    is a value in the range 0 to 9, which corresponds to the LO digit of the decimal
    number. Successive divisions by 10 (and their corresponding remainder) extract
    successive digits from the number.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号十进制输出的最常见解决方案是不断将值除以10，直到结果变为0。第一次除法后的余数是0到9之间的值，对应十进制数字的低位。不断进行除法（以及其相应的余数）会依次提取数字中的各个数字。
- en: Iterative solutions to this problem generally allocate storage for a string
    of characters large enough to hold the entire number. The code then extracts the
    decimal digits in a loop and places them in the string one by one. At the end
    of the conversion process, the routine prints the characters in the string in
    reverse order (remember, the divide algorithm extracts the LO digits first and
    the HO digits last, the opposite of the way you need to print them).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题的迭代解决方案通常会为一个足够大的字符字符串分配存储空间，以容纳整个数字。代码接着会在循环中提取十进制数字，并逐个将它们放入该字符串中。在转换过程结束时，例程会按反向顺序打印字符串中的字符（记住，除法算法首先提取低位数字，最后提取高位数字，这与打印时需要的顺序相反）。
- en: 'This section employs a *recursive solution* because it is a little more elegant.
    This solution begins by dividing the value by 10 and saving the remainder in a
    local variable. If the quotient is not 0, the routine recursively calls itself
    to output any leading digits first. On return from the recursive call (which outputs
    all the leading digits), the recursive algorithm outputs the digit associated
    with the remainder to complete the operation. For example, here’s how the operation
    works when printing the decimal value 789:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本节采用了*递归解决方案*，因为它更为优雅。该解决方案通过将值除以10并将余数保存在局部变量中开始。如果商不为0，例程将递归调用自身以首先输出所有前导数字。从递归调用返回（递归调用输出所有前导数字）后，递归算法将输出与余数相关的数字以完成操作。例如，下面是打印十进制值789时操作的执行过程：
- en: 1.  Divide 789 by 10\. The quotient is 78, and the remainder is 9.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  将789除以10，商为78，余数为9。
- en: 2.  Save the remainder (9) in a local variable and recursively call the routine
    with the quotient.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将余数（9）保存在局部变量中，并使用商递归调用该例程。
- en: '3.  Recursive entry 1: divide 78 by 10\. The quotient is 7, and the remainder
    is 8.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  递归入口1：将78除以10，商为7，余数为8。
- en: 4.  Save the remainder (8) in a local variable and recursively call the routine
    with the quotient.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  将余数（8）保存在局部变量中，并使用商递归调用该例程。
- en: '5.  Recursive entry 2: divide 7 by 10\. The quotient is 0, and the remainder
    is 7.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  递归入口2：将7除以10，商为0，余数为7。
- en: 6.  Save the remainder (7) in a local variable. Because the quotient is 0, don’t
    call the routine recursively.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  将余数（7）保存在局部变量中。由于商为0，因此不再递归调用该例程。
- en: 7.  Output the remainder value saved in the local variable (7). Return to the
    caller (recursive entry 1).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  输出保存在局部变量（7）中的余数值。返回到调用者（递归入口1）。
- en: '8.  Return to recursive entry 1: output the remainder value saved in the local
    variable in recursive entry 1 (8). Return to the caller (original invocation of
    the procedure).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  返回到递归入口1：输出在递归入口1（8）中保存在局部变量中的余数值。返回到调用者（最初调用该过程的地方）。
- en: '9.  Original invocation: output the remainder value saved in the local variable
    in the original call (9). Return to the original caller of the output routine.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  最初的调用：输出在最初调用（9）中保存在局部变量中的余数值。返回到输出例程的最初调用者。
- en: Listing 9-6 provides an implementation of this recursive algorithm for 64-bit
    unsigned integers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-6提供了64位无符号整数的递归算法实现。
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The u64toStr function ❶ is a facade that preserves the registers while calling
    the u64ToBuf procedure. The u64ToBuf function ❷ handles the special case when
    X1 contains 0 (the recursive code terminates when the result is 0). If X1 is 0
    upon entry, this code immediately writes a '0' character to the output buffer,
    increments X0, and returns. If X1 is nonzero, it transfers control to the recursive
    u64toBufRec function ❸ to process the value. For performance reasons, u64ToBufRec
    preserves only X2 (which contains the remainder value on recursive calls) and
    LR.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: u64toStr函数❶是一个外观函数，在调用u64ToBuf过程时保存寄存器。u64ToBuf函数❷处理X1包含0的特殊情况（当结果为0时，递归代码终止）。如果X1在进入时为0，代码会立即将字符'0'写入输出缓冲区，递增X0并返回。如果X1非零，则控制权转交给递归的u64toBufRec函数❸来处理该值。为了性能考虑，u64ToBufRec只保留X2（在递归调用中包含余数值）和LR寄存器。
- en: 'The recursive function computes the quotient and remainder ❹. The quotient
    is left in X3, and the remainder is in X2\. If the quotient was nonzero, there
    are still more HO digits to process: copy the quotient into X1 and make the recursive
    call to u64toBufRec ❺. On the return from the recursive call ❻ (or if the recursive
    call was skipped), all HO digits have been emitted to the buffer, so convert the
    current digit to a character and add it to the end of the buffer. Note that the
    post-increment addressing mode automatically increments X0 to point at the zero-terminated
    byte emitted by the strh instruction. The code restores the value in X2 ❼, in
    the event that this was a recursive call.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数计算商和余数❹。商保存在X3中，余数保存在X2中。如果商不为零，说明还有更多的高位数字需要处理：将商复制到X1并进行递归调用u64toBufRec❺。从递归调用返回❻（或者如果跳过了递归调用），所有的高位数字已经被输出到缓冲区，因此将当前数字转换为字符并添加到缓冲区的末尾。注意，后增量寻址模式会自动将X0递增，以指向由strh指令发出的以零结束的字节。代码恢复X2中的值❼，以防这是一次递归调用。
- en: 'Here’s the build command and sample output for Listing 9-6:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第9-6列表的构建命令和示例输出：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unlike hexadecimal output, there’s no need to provide a byte-size, hword-size,
    or word-size numeric-to-decimal-string conversion function. Simply zero-extending
    the smaller values to 64 bits is sufficient. Unlike the hexadecimal conversions,
    no leading zeros are emitted by the u64toStr function, so the output is the same
    for all sizes of variables (64 bits and smaller).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与十六进制输出不同，这里不需要提供字节大小、半字大小或字大小的数字到十进制字符串转换函数。只需将较小的值零扩展到64位即可。与十六进制转换不同，u64toStr函数不会输出前导零，因此对所有大小的变量（64位及更小）输出都是相同的。
- en: This code has several opportunities for optimization. Since decimal-to-string
    conversions are common (most program output uses this function) and the algorithm
    is not as fast as hexadecimal conversion, optimizing this code is probably worthwhile.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有几个优化的机会。由于十进制到字符串的转换很常见（大多数程序输出都使用这个函数），而且该算法的速度不如十六进制转换快，因此优化这段代码可能是值得的。
- en: It’s easy enough to get rid of the recursion and do an iterative version of
    u64toStr. This eliminates the need to preserve the registers and return address
    on multiple recursive calls (typically, one recursive call for each digit converted)
    and having to build the activation record on each call. Listing 9-7 takes this
    one step further, unraveling the loop (up to 20 iterations, one for each possible
    digit).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 去除递归并实现u64toStr的迭代版本其实很简单。这可以消除在多次递归调用中保存寄存器和返回地址的需求（通常每个数字转换会有一次递归调用），以及在每次调用时构建激活记录的需要。第9-7列表进一步改进了这一点，将循环展开（最多20次迭代，每次迭代处理一个可能的数字）。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The u64ToBuf function ❶ is a variant of u64ToStr that doesn’t preserve any registers.
    It stomps on X0 through X7, and the caller is responsible for saving any registers
    it needs preserved.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: u64ToBuf函数❶是u64ToStr的一个变体，它不会保存任何寄存器。它会覆盖X0到X7寄存器，调用者需要负责保存任何需要保留的寄存器。
- en: This function initializes X4 with the constant 10 ❷, because each digit conversion
    will divide and multiply by this constant, which must be in a register. Reserving
    X4 for this constant spares the code from having to reload the constant all the
    time. This code zeros out X5, X6, and X7, which will hold the characters of the
    converted string; this also initializes the zero-terminating byte (which can be
    in various locations in these registers, depending on the number of output digits).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将常数 10 初始化到 X4 ❷，因为每次数字转换都将除以并乘以该常数，而该常数必须存储在寄存器中。将 X4 保留为常数可以避免代码每次都重新加载该常数。此代码将
    X5、X6 和 X7 清零，这些寄存器将存储转换后的字符串字符；这也初始化了零终止字节（根据输出数字的数量，可能位于这些寄存器的不同位置）。
- en: The function converts the binary number to a string of digits by using the same
    basic “divide and remainder” algorithm as did the program in Listing 9-6 ❸. The
    function divides the value by 10; the remainder is a value in the range 0 to 9
    that the function converts to the corresponding ASCII character. The code shifts
    the converted digit into its final output position in the X5, X6, or X7 register.
    Digits 1 through 6, the HO digits, wind up in X5; digits 7 through 14 in X6; and
    digits 15 through 20 in X7\. Zero bytes fill in all the unused digit positions.
    For example, if the number has only three digits, X6 and X7 will contain 0, and
    bits 24 through 63 in X5 will all contain 0.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过使用与清单 9-6 ❸ 中程序相同的基本“除法和余数”算法，将二进制数转换为一串数字字符。函数将值除以 10，余数是一个范围在 0 到 9 之间的值，函数将其转换为相应的
    ASCII 字符。代码将转换后的数字移到 X5、X6 或 X7 寄存器的最终输出位置。1 到 6 位数字，即高位数字，最终存储在 X5 中；7 到 14 位数字存储在
    X6 中；15 到 20 位数字存储在 X7 中。零字节填充所有未使用的数字位置。例如，如果数字只有三位，X6 和 X7 将包含 0，而 X5 中的 24
    到 63 位将全部为 0。
- en: A separate sequence of divide/remainder instructions is used for each possible
    output digit in the conversion (hence the name *expanded/straight-line code*)
    ❹. The sequence is roughly the same for each digit conversion, though two variants
    alternate between the value in X1 and X2, as the quotient from the division becomes
    the value to divide in the next step. Whenever the quotient becomes 0, the conversion
    is complete, and control transfers to a different location to write the converted
    digits to the buffer. Only a single branch in the function will be taken, as these
    branches fall through to the next instruction sequence until the conversion is
    complete. Additionally, these digit conversion sequences may place the converted
    digit into a different output register based on the digit’s final position.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可能的输出数字转换使用一组单独的除法/余数指令（因此称为 *展开/直线代码*） ❹。每个数字的转换序列大致相同，尽管有两个变体在 X1 和 X2 之间交替，因为除法的商成为下一步要除的值。每当商变为
    0，转换完成，控制转移到不同的位置，将转换后的数字写入缓冲区。函数中只会采取单个分支，因为这些分支会继续执行下一条指令序列，直到转换完成。此外，这些数字转换序列可能会根据数字的最终位置将转换后的数字放入不同的输出寄存器。
- en: If the code falls all the way through to digit 20, there is no test for a 0
    result; the quotient will always be 0 at that point, so the function simply stores
    away the digits into the buffer and returns ❺.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码执行到第 20 位数字，没有对 0 结果进行测试；此时商将始终为 0，因此函数简单地将数字存储到缓冲区中并返回 ❺。
- en: If the number has six digits or fewer, the function writes the characters in
    X5 to the buffer ❻. X5 will always contain the LO digits of the number. By placing
    a maximum of six characters in X5, the HO 2 bytes of X5 will always be 0 (and
    provide the zero-terminating byte for larger strings). For numbers with fewer
    than six digits, the code must explicitly write a zero-terminating byte to the
    buffer. For values with 7 to 14 digits, the function writes out registers X6 and
    X5 (in that order) to the buffer ❼. X5 provides the zero-terminating byte, so
    the code doesn’t need to explicitly write any 0 bytes. For values with 15 or more
    digits, the code writes out the data in registers X7, X6, and X5 (X5 provides
    the zero-terminating byte) ❽.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字有六位或更少，函数将 X5 中的字符写入缓冲区 ❻。X5 将始终包含数字的低位数字。通过将最多六个字符放入 X5，X5 的高位 2 字节将始终为
    0（并为更大的字符串提供零终止字节）。对于少于六位的数字，代码必须显式地将零终止字节写入缓冲区。对于 7 到 14 位的数字，函数将寄存器 X6 和 X5（按此顺序）写入缓冲区
    ❼。X5 提供零终止字节，因此代码不需要显式地写入任何 0 字节。对于 15 位或更多位的数字，代码将寄存器 X7、X6 和 X5 中的数据写出（X5 提供零终止字节）
    ❽。
- en: The actual u64ToStr function ❾ is a short facade that preserves all the register
    values across a call to u64ToBuf. By breaking u64ToStr into these two functions,
    it is possible to call u64ToBuf directly if you want to leave X0 pointing at the
    end of the string (though you must preserve X1 through X7 if necessary). Also,
    putting the register preservation code in u64ToStr allows the u64ToBuf code to
    avoid restoring registers before all the ret instructions (or avoid yet another
    branch to code that handles restoring the registers).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的u64ToStr函数❾是一个简单的外观函数，它在调用u64ToBuf时保留所有寄存器的值。通过将u64ToStr分解为这两个函数，如果你希望X0指向字符串的末尾，可以直接调用u64ToBuf（尽管如果需要，你必须保留X1到X7）。此外，将寄存器保存代码放入u64ToStr中，允许u64ToBuf代码避免在所有ret指令之前恢复寄存器（或者避免再次跳转到处理恢复寄存器的代码）。
- en: 'Here’s the build command and sample output from Listing 9-7:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自清单9-7的构建命令和示例输出：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I modified both versions of u64toStr in order to time their execution. For
    the recursive version, I got the following timing on my Mac mini:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我修改了u64toStr的两个版本，以便对它们的执行时间进行计时。在递归版本中，我在我的Mac mini上获得了以下的计时结果：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For the straight-line code, the runtime was as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于直线代码，运行时间如下：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The latter code ran about 2.3 times faster than the recursive version, a big
    win.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 后者的代码运行速度比递归版本快了约2.3倍，这是一个很大的进步。
- en: I also created a version of u64ToStr that first counted the number of output
    digits (using a binary search), then branched to the appropriate code to convert
    exactly that many digits. Alas, the code ran slightly slower than Listing 9-7\.
    I also tried a variant that emitted the HO digits first (dividing by 1e+19, the
    successively lower values by 10). It was a little faster than the digit count
    version, and a little slower than Listing 9-7\. I’ve included the source code
    for both experiments in the online files for your perusal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我还创建了一个版本的u64ToStr，它首先计算输出数字的数量（使用二分查找），然后跳转到适当的代码以精确地转换该数量的数字。可惜的是，代码比清单9-7运行得稍慢。我还尝试了一个变体，它首先输出高位数字（通过1e+19进行除法，接下来每次除以10）。它比数字计数版本略快，比清单9-7略慢。我已将两个实验的源代码包含在在线文件中，供你参考。
- en: 9.1.4 Signed Integer Values to Strings
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.4 将带符号整数值转换为字符串
- en: To convert a signed integer value to a string, first check whether the number
    is negative. If it is, emit a hyphen (-) character and negate the value, then
    call the u64toStr function to finish the job. Listing 9-8 shows the relevant code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要将带符号的整数值转换为字符串，首先检查数字是否为负。如果是，则输出一个短横线（-）字符并取反该值，然后调用u64toStr函数完成转换。清单9-8显示了相关代码。
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 9-8 shows only the i64ToStr function (the rest of the program is taken
    from Listing 9-7). The full source code is available online.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-8仅显示了i64ToStr函数（程序的其余部分来自清单9-7）。完整的源代码可以在线获取。
- en: 9.1.5 Extended-Precision Unsigned Integers to Strings
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.5 扩展精度无符号整数转换为字符串
- en: The only operation in the entire string-conversion algorithm that requires extended-precision
    arithmetic is the divide-by-10 operation. Listing 9-9 implements a 128-bit decimal
    output routine utilizing this technique. I modified the div128 algorithm from
    [Chapter 8](chapter8.xhtml) to do an explicit divide-by-10 operation (speeding
    div128 up a little) and modified the recursive conversion routine from Listing
    9-6 to perform the conversion.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 整个字符串转换算法中唯一需要扩展精度算术的操作是除以10。清单9-9实现了一个利用该技术的128位十进制输出例程。我修改了[第8章](chapter8.xhtml)中的div128算法，使其进行显式的除以10操作（稍微加快了div128的速度），并修改了来自清单9-6的递归转换例程以执行该转换。
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code includes an optimized version of the 128-bit division function that
    divides a number by 10 ❶. This is followed by the nonrecursive entry point for
    u128toStr, which handles 0 as a special case and calls the recursive version for
    all other values ❷, and the recursive code for u128toStr ❸. As these functions
    are nearly identical to the recursive 64-bit string output functions, refer to
    that code (in Listing 9-6) for more details.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包括一个优化版的128位除法函数，它将数字除以10❶。接下来是u128toStr的非递归入口点，它将0作为特例处理，并对所有其他值调用递归版本❷，然后是u128toStr的递归代码❸。由于这些函数几乎与递归的64位字符串输出函数相同，请参考清单9-6中的代码了解更多细节。
- en: One issue with the u128toStr function is that it is much slower than the other
    numeric-to-string functions. This is all due to the performance of the div10 subroutine.
    Because the 128-bit divide-by-10 algorithm is so slow, I won’t bother improving
    the performance of the u128toStr conversion function. Unless you can come up with
    a very high-performance div10 subroutine (perhaps using multiplication by a reciprocal;
    see section 9.6, “For More Information,” on [page 603](chapter9.xhtml#pg_603)),
    trying to optimize u128toStr is probably a waste of time. Fortunately, this function
    likely won’t be called often, so its performance won’t matter much.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: u128toStr函数的一个问题是，它比其他数字到字符串的函数慢得多。这完全是因为div10子程序的性能。由于128位除以10的算法非常慢，我不会费力改进u128toStr转换函数的性能。除非你能想出一个高性能的div10子程序（或许可以使用倒数相乘；请参见第9.6节“更多信息”，[第603页](chapter9.xhtml#pg_603)），否则优化u128toStr可能是浪费时间。幸运的是，这个函数可能不会经常被调用，所以它的性能不会有太大影响。
- en: 'Here’s the build command and sample output from Listing 9-9:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自清单9-9的构建命令和示例输出：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I will leave it to you to create a 128-bit signed-integer conversion function,
    since the code is almost identical to i64toStr (see Listing 9-8); you just have
    to supply 128-bit negation and comparison operations. As a hint, for the comparison,
    just check the HO dword to see if the sign bit is set.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码几乎与i64toStr相同（见清单9-8），我会留给你来创建一个128位有符号整数转换函数；你只需提供128位取反和比较操作。作为提示，对于比较，只需检查HO字（高位字）是否设置了符号位。
- en: '#### 9.1.6 Formatted Conversions'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 9.1.6 格式化转换'
- en: The code in the previous sections converted signed and unsigned integers to
    strings by using the minimum number of necessary character positions. To create
    nicely formatted tables of values, you will need to write functions that provide
    appropriate padding in front of the string of digits before actually emitting
    the digits. Once you have the “unformatted” versions of these routines, implementing
    the formatted versions is easy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面章节中的代码通过使用最小的字符位置数将有符号和无符号整数转换为字符串。为了创建格式良好的数值表，你需要编写函数，在实际输出数字之前，先在数字字符串前添加适当的填充。等你有了这些“未格式化”版本的例程，实现格式化版本就很容易了。
- en: The first step is to write iSize and uSize routines that compute the minimum
    number of character positions needed to display the value. One algorithm to accomplish
    this is similar to the numeric string conversion routines. The only difference
    is that you initialize a counter to 0 upon entry into the routine and increment
    this counter rather than outputting a digit on each recursive call. (Don’t forget
    to increment the counter inside iSize if the number is negative; you must allow
    for the output of the minus sign.) After the calculation is complete, these routines
    should return the size of the operand in the X0 register.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是编写iSize和uSize例程，计算显示值所需的最小字符位置数。实现此功能的一种算法类似于数字字符串转换例程。唯一的区别是，在进入例程时将计数器初始化为0，并且在每次递归调用时增加该计数器，而不是输出一个数字。（如果数字为负，请不要忘记在iSize内部递增计数器；你必须考虑到负号的输出。）计算完成后，这些例程应返回操作数在X0寄存器中的大小。
- en: However, thanks to its use of recursion and division, such a conversion scheme
    is slow. A brute-force conversion using a binary search is shown in Listing 9-10.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于它使用了递归和除法，因此这种转换方案较慢。清单9-10展示了使用二分查找的暴力转换方法。
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The actual u64Size function ❶ uses a binary search algorithm to quickly scan
    through all the possible values to determine the digit count. It begins by dividing
    the search space in half, by comparing the input value (moved to X2) against a
    10-digit value ❷. In the usual binary search fashion, the two sections of code
    will test for numbers with 1 to 9 digits and 10 to 20 digits. In each of those
    ranges, the search is (roughly) broken into halves again and again until the algorithm
    zeros in on the exact number of digits. When the code gets down to 2 to 4 digits,
    it uses some straight-line code and a series of cinc instructions to rapidly handle
    the last few cases without executing a branch ❸.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的u64Size函数❶使用二分查找算法快速扫描所有可能的值，以确定数字的位数。它通过将搜索空间对半分，比较输入值（移到X2）与一个10位数字值❷来开始。在常规的二分查找方式中，代码的两部分将分别测试1到9位数字和10到20位数字。在这些范围内，搜索将（大致）反复对半分割，直到算法锁定确切的数字位数。当代码处理到2到4位数字时，它使用一些直线代码和一系列cinc指令，以快速处理最后几个案例，而无需执行分支❸。
- en: 'Here’s the build command and sample output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和示例输出：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For signed integers, add the function in Listing 9-11 to the code in Listing
    9-10 (find a full Listing 9-11 in the book’s downloadable code files at *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号整数，将清单9-11中的函数添加到清单9-10中的代码中（你可以在本书的可下载代码文件中找到完整的清单9-11，地址是*[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*）。
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For extended-precision size operations, the binary search approach quickly becomes
    unwieldy (64 bits is bad enough). The best solution is to divide your extended-precision
    value by a power of 10 (say, 1e+16). This will reduce the size of the number by
    16 digits. Repeat this process as long as the quotient is greater than 64 bits,
    keeping track of the number of times you’ve divided the number by 1e+16\. When
    the quotient fits into 64 bits (19 or 20 digits), call the 64-bit u64Size function
    and add in the number of digits you eliminated with the division operation (16
    for each division by 1e+16). I’ll leave this implementation to you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于扩展精度大小操作，二分查找方法很快会变得难以处理（64位已经足够糟糕了）。最佳解决方案是将你的扩展精度值除以一个10的幂（比如，1e+16）。这将把数字的大小减少16位数字。只要商大于64位，就重复这个过程，并跟踪你每次用1e+16进行除法操作时减少的位数。当商适合64位时（19或20位），调用64位的u64Size函数，并加上你通过除法操作减少的数字位数（每次除以1e+16减少16位）。这个实现我留给你来完成。
- en: Once you have the i64Size and u64Size routines, writing the formatted output
    routines u64toStrSize or i64toStrSize is easy. On initial entry, these routines
    call the corresponding i64Size/u64Size routine to determine the number of character
    positions for the number. If the value that the i64Size/u64Size routine returns
    is greater than or equal to the value of the minimum size parameter (passed into
    u64toStrSize or i64toStrSize), no other formatting is necessary. If the value
    of the parameter size is greater than the value i64Size/u64Size returns, the program
    must compute the difference between these two values and emit that many spaces
    (or other filler characters) to the output string before the numeric conversion
    (assuming right-justification of the value, which is what this chapter presents).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了i64Size和u64Size例程，编写格式化输出例程u64toStrSize或i64toStrSize就很简单了。初始进入时，这些例程会调用相应的i64Size/u64Size例程来确定数字所需的字符位置数。如果i64Size/u64Size例程返回的值大于或等于最小大小参数（传递给u64toStrSize或i64toStrSize的值），则无需其他格式化。如果参数size的值大于i64Size/u64Size返回的值，程序必须计算这两个值之间的差异，并在数字转换之前输出相应数量的空格（或其他填充字符）（假设是右对齐，这正是本章所介绍的）。
- en: Listing 9-12 shows the utoStrSize/itoStrSize functions (full source code appears
    online); here, I omit everything but the utoStrSize/itoStrSize functions themselves.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-12展示了utoStrSize/itoStrSize函数（完整的源代码在线上可以找到）；在这里，我省略了除了utoStrSize/itoStrSize函数本身之外的所有内容。
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The u64toStrSize function ❶ simply loads up X25 and X26 with appropriate addresses
    and branches to the generic toSizeStr function to handle the real work. The i64ToStrSize
    function ❷ does the same thing for signed integer conversions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: u64toStrSize函数❶只需加载X25和X26为适当的地址，并跳转到通用的toSizeStr函数以处理实际工作。i64ToStrSize函数❷对有符号整数转换做同样的事情。
- en: The toSizeStr function ❸ handles the real work. First, it calls the appropriate
    toSize function (whose address was passed in X25) to compute the minimum number
    of print positions the value will require ❹. It then computes the number of fill
    characters required in front of the digits to right-justify the number in the
    output field ❺. It emits the required number of filler characters ❻ before outputting
    the numeric string ❼. Probably the only thing worth noting here is that the code
    attempts to output eight spaces at a time in order to improve performance, as
    long as there are at least eight padding characters, then four, then two, and
    finally one.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: toSizeStr函数❸处理了实际工作。首先，它调用适当的toSize函数（该函数的地址通过X25传递）来计算值所需的最小打印位置数❹。然后，它计算出需要多少个填充字符才能将数字右对齐到输出字段中❺。它在输出数字字符串❼之前，先输出所需数量的填充字符❻。值得注意的唯一一点是，代码尝试每次输出八个空格以提高性能，只要至少有八个填充字符，然后是四个，再是两个，最后是一个。
- en: The printSize procedure ❽ is a little utility function that the asmMain procedure
    uses to display values, and the asmMain procedure ❾ tests the u64ToStrSize and
    i64ToStrSize procedures.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: printSize过程❽是一个小工具函数，asmMain过程用它来显示值，而asmMain过程❾测试了u64ToStrSize和i64ToStrSize过程。
- en: 'Here’s the build command and sample output for Listing 9-12 (remember that
    the actual main program appears only in the online source code):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是清单 9-12 的构建命令和示例输出（请记住，实际的主程序仅出现在在线源代码中）：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is value:size=''conversion''.  ### 9.2 Converting Floating-Point
    Values to Strings'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是值：大小 = '转换'。### 9.2 将浮点值转换为字符串
- en: Thus far, this chapter has dealt with converting integer numeric values to character
    strings (typically for output to the user). This section discusses converting
    floating-point values to a string, which is just as important.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经讨论了将整数数值转换为字符字符串（通常是输出给用户）。本节讨论了将浮点值转换为字符串，这同样非常重要。
- en: 'Converting floating-point values to strings can take one of two forms:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将浮点值转换为字符串可以有两种形式：
- en: Decimal notation conversion (such as ±xxx.yyy format)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制表示法转换（例如 ±xxx.yyy 格式）
- en: Exponential (or scientific) notation conversion (such as ±x.yyyyye±zz format)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数（或科学）表示法转换（例如 ±x.yyyyye±zz 格式）
- en: Regardless of the final output format, you’ll need two distinct operations to
    convert a value in floating-point form to a character string. First, you must
    convert the mantissa to an appropriate string of digits. Second, you convert the
    exponent to a string of digits.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 无论最终的输出格式如何，您需要进行两项不同的操作，将浮点值转换为字符字符串。首先，您必须将尾数转换为适当的数字字符串。其次，您需要将指数转换为数字字符串。
- en: However, this isn’t a simple case of converting two integer values to a decimal
    string and concatenating them (with an *e* between the mantissa and exponent).
    First of all, the mantissa is not an integer value; it is a fixed-point fractional
    binary value. Simply treating it as an *n*-bit binary value (where *n* is the
    number of mantissa bits) will almost always result in an incorrect conversion.
    Second, while the exponent is, more or less, an integer value, it represents a
    power of 2, not a power of 10\. Displaying that power of 2 as an integer value
    is not appropriate for decimal floating-point representation. These two issues
    (fractional mantissa and binary exponent) are the source of the major complications
    associated with converting a floating-point value to a string.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是将两个整数值简单地转换为十进制字符串并将它们连接在一起（在尾数和指数之间用 *e*）。首先，尾数不是一个整数值，它是一个定点分数二进制值。仅仅将它视为一个
    *n* 位二进制值（其中 *n* 是尾数位数）几乎总会导致转换错误。其次，虽然指数或多或少是一个整数值，但它表示的是 2 的幂，而不是 10 的幂。将这个
    2 的幂作为整数值表示并不适合十进制浮点表示。上述这两个问题（分数尾数和二进制指数）是将浮点值转换为字符串时的主要复杂性来源。
- en: NOTE
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The exponent is actually a biased-exponent value. However, that’s easy to
    convert to a signed binary integer.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*指数实际上是一个带偏移的指数值。然而，这很容易转换为一个带符号的二进制整数。*'
- en: Double-precision floating-point values have a 53-bit mantissa (including the
    implied bit). This is not a 53-bit integer. Instead, those 53 bits represent a
    value from 1.0 to slightly less than 2.0\. (See section 2.13, “IEEE Floating-Point
    Formats,” on [page 93](chapter2.xhtml#pg_93) for more details on the IEEE 64-bit
    floating-point format.) The double-precision format can represent numbers from
    0 to about 5 × 10^(–324) (around ±1 × 10^(±308) using normalized values).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 双精度浮点值具有 53 位尾数（包括隐含位）。这不是一个 53 位的整数，而是这 53 位表示从 1.0 到略小于 2.0 之间的值。（有关 IEEE
    64 位浮点格式的更多细节，请参见第 2.13 节“IEEE 浮点格式”，[第 93 页](chapter2.xhtml#pg_93)。）双精度格式可以表示从
    0 到大约 5 × 10^(–324) 的数字（使用标准化值时，大约为 ±1 × 10^(±308)）。
- en: To output the mantissa in decimal form with approximately 16 digits of precision,
    successively multiply or divide the floating-point value by 10 until the number
    is from 1e+15 to just less than 1e+16 (that is, 9.9999 ... e+15). Once the exponent
    is in the appropriate range, the mantissa bits form a 16-digit integer value (no
    fractional part), which can be converted to a decimal string to obtain the 16
    digits that make up the mantissa value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以大约 16 位精度输出尾数的十进制形式，依次将浮点值乘以或除以 10，直到该数字的范围从 1e+15 到略小于 1e+16（即 9.9999 …
    e+15）。一旦指数进入适当的范围，尾数位就形成一个 16 位整数值（没有小数部分），可以将其转换为十进制字符串，得到构成尾数值的 16 位数字。
- en: To convert the exponent to an appropriate decimal string, track the number of
    multiplications or divisions by 10\. For each division by 10, add 1 to the decimal
    exponent value; for each multiplication by 10, subtract 1 from the decimal exponent
    value. At the end of the process, subtract 16 from the decimal exponent value
    (as this process produces a value whose exponent is 16) and convert the decimal
    exponent value to a string.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将指数转换为适当的十进制字符串，跟踪乘以或除以10的次数。每次除以10时，十进制指数值加1；每次乘以10时，十进制指数值减1。完成该过程后，从十进制指数值中减去16（因为这个过程产生的值其指数为16），然后将十进制指数值转换为字符串。
- en: The conversions in the following sections assume that you always want to produce
    a mantissa with 16 significant digits. To produce formatted output with fewer
    significant digits, see section 9.2.4, “Double-Precision Values to Strings,” on
    the next page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节中的转换假设你始终希望生成一个具有16位有效数字的尾数。要生成格式化输出并且有效数字少，请参见第9.2.4节，“双精度值转换为字符串”，下一页。
- en: 9.2.1 Floating-Point Exponent to String of Decimal Digits
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1 将浮点指数转换为十进制数字字符串
- en: 'To convert the exponent to a string of decimal digits, use the following algorithm:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将指数转换为十进制数字字符串，使用以下算法：
- en: 1.  If the number is 0.0, directly produce the mantissa output string of "0000000000000000"
    (notice the space at the beginning of the string), set the exponent to 0, and
    you’re done. Otherwise, continue with the following steps.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  如果数字是0.0，直接生成尾数输出字符串“0000000000000000”（注意字符串开头的空格），将指数设置为0，完成。否则，继续执行以下步骤。
- en: 2.  Initialize the decimal exponent to 0.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将十进制指数初始化为0。
- en: 3.  If the exponent is negative, emit a hyphen (-) character and negate the
    value; if it is positive, emit a space character.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  如果指数为负数，输出一个连字符（-）并将值取负；如果指数为正数，输出一个空格字符。
- en: 4.  If the value of the (possibly negated) exponent is less than 1.0, skip to
    step 8.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  如果（可能是取负的）指数值小于1.0，则跳到第8步。
- en: '5.  Positive exponents: Compare the number against successively smaller powers
    of 10, starting with 10 ^(+ 256), then 10 ^(+ 128), then 10 ^(+ 64), then ...,
    then 10⁰. After each comparison, if the current value is greater than the power
    of 10, divide by that power of 10 and add the power-of-10 exponent (256, 128,
    ..., 0) to the decimal exponent value.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  正指数：将数字与逐渐较小的10的幂进行比较，从10^(+256)开始，然后是10^(+128)，然后是10^(+64)，然后……最后是10⁰。每次比较后，如果当前值大于该10的幂，则除以该10的幂，并将该10的幂指数（256、128、……、0）加到十进制指数值中。
- en: 6.  Repeat step 5 until the exponent is 0 (that is, the value is in the range
    1.0 ≤ *value* < 10.0).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  重复第5步，直到指数为0（即值的范围为1.0 ≤ *value* < 10.0）。
- en: 7.  Skip to step 10.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  跳到第10步。
- en: '8.  Negative exponents: Compare the number against successful larger powers
    of 10 starting with 10^(–256), then, 10^(–128), then 10^(–64), then ..., then
    10⁰. After each comparison, if the current value is less than the power of 10,
    divide by that power of 10 and subtract the power-of-10 exponent (256, 128, ...,
    0) from the decimal exponent value.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  负指数：将数字与从10^(–256)开始的逐渐较大的10的幂进行比较，然后是10^(–128)，然后是10^(–64)，然后……最后是10⁰。每次比较后，如果当前值小于该10的幂，则除以该10的幂，并将该10的幂指数（256、128、……、0）从十进制指数值中减去。
- en: 9.  Repeat step 8 until the exponent is 0 (that is, the value is in the range
    1.0 ≤ *value* < 10.0).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  重复第8步，直到指数为0（即值的范围为1.0 ≤ *value* < 10.0）。
- en: 10.  At this point, the exponent value is a reasonable number that can be converted
    to an integer value by using standard unsigned-to-string conversions (see section
    9.1.3, “Unsigned Decimal Values to Strings,” on [page 495](chapter9.xhtml#pg_495)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  此时，指数值是一个合理的数字，可以通过使用标准的无符号到字符串转换将其转换为整数值（参见第9.1.3节，“无符号十进制值转换为字符串”，[第495页](chapter9.xhtml#pg_495)）。
- en: 9.2.2 Floating-Point Mantissa to String of Digits
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2 将浮点尾数转换为数字字符串
- en: 'To convert the mantissa to a string of digits, you can’t simply treat the 53-bit
    mantissa produced in the previous section as an integer value, since it still
    represents an integer from 1.0 to just less than 2.0\. However, if you multiply
    that floating-point value (which has been converted to a value from 1.0 to slightly
    less than 10.0) by 10^(+15), this effectively produces an integer with the digits
    shifted to the left 15 print positions (16 digits being the number of output digits
    possible with a double-precision value). You can then convert this “integer” to
    a string. The result will consist of the 16 mantissa digits. To convert the mantissa
    to a string, do the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将尾数转换为数字字符串，不能简单地将前一节中产生的53位尾数当作整数值来处理，因为它仍然表示一个从1.0到小于2.0的整数。然而，如果将该浮点值（已转换为从1.0到略小于10.0的值）乘以10^(+15)，则实际上会生成一个整数，并且尾数的数字会向左移动15个打印位置（16位数字是双精度值能够输出的数字位数）。然后可以将这个“整数”转换为字符串。结果将包括16个尾数字符。要将尾数转换为字符串，请执行以下步骤：
- en: 1.  Multiply the value produced by the exponent calculation in the previous
    section by 1e+15\. This produces a number with the decimal digits shifted to the
    left by 15 print positions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  将前一节中指数计算得到的值乘以1e+15。这会产生一个数字，将小数位左移15个打印位置。
- en: 2.  Grab the 52-bit mantissa and OR in an implicit bit 52 equal to 1, and zero-extend
    this 53-bit value to 64 bits.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  获取52位尾数，并将一个隐式的52位比特设置为1，然后将该53位值进行零扩展到64位。
- en: 3.  Convert the resulting 64-bit value to a string by using the unsigned integer-to-string
    function given earlier in this chapter (see section 9.1.3, “Unsigned Decimal Values
    to Strings,” on [page 495](chapter9.xhtml#pg_495)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  通过使用本章早些时候介绍的无符号整数到字符串的函数，将结果64位值转换为字符串（参见第9.1.3节“无符号十进制值到字符串”，在[第495页](chapter9.xhtml#pg_495)）。
- en: 9.2.3 Strings in Decimal and Exponential Format
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3 十进制和指数格式的字符串
- en: To produce a decimal string (rather than a number in exponential form), the
    remaining task is to properly place the decimal point into the string of digits.
    If the exponent is greater than or equal to 0, you need to insert the decimal
    point in position *exponent* + 1, starting from the first mantissa digit produced
    in the previous section. For example, if the mantissa conversion produced 1234567890123456
    and the exponent is 3, then you would insert a decimal point before the character
    at index 4 (3 + 1), yielding 1234.567890123456 as the result.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个十进制字符串（而不是指数形式的数字），剩下的任务是将小数点正确地放置在数字字符串中。如果指数大于或等于0，需要将小数点插入到位置*指数* +
    1，位置从前一节中生成的第一个尾数字符开始。例如，如果尾数转换结果为1234567890123456，且指数为3，则需要在索引4的位置（3 + 1）前插入小数点，结果将是1234.567890123456。
- en: If the exponent is greater than 16, insert *exponent* – 16 zero characters at
    the end of the string (or return an error if you don’t want to allow conversions
    of values larger than 1e+16 to decimal form). If the exponent is less than 0,
    insert 0. followed by *abs*(*exp*) – 1 zero characters in front of the string
    of digits. If the exponent is less than –16 (or another arbitrary value), you
    might elect to return an error or automatically switch to exponential form.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指数大于16，则在字符串末尾插入*指数* – 16个零字符（或者如果不希望允许将大于1e+16的值转换为十进制形式，则返回错误）。如果指数小于0，则在数字字符串前插入0.，后跟*abs*（*exp*）
    – 1个零字符。如果指数小于–16（或其他任意值），你可能选择返回错误或自动切换到指数形式。
- en: Producing exponential output is slightly easier than decimal output. Always
    insert a decimal point between the first and second characters in the converted
    mantissa string and then follow the string with e±xxx, where ±xxx is the exponent
    value’s string conversion. For example, if the mantissa conversion produces 1234567890123456
    and the exponent is –3, the resulting string will be 1.234567890123456e-003 (note
    the leading 0s on the exponent digits).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 生成指数输出比生成十进制输出稍微容易一些。始终在转换后的尾数字符串中的第一个和第二个字符之间插入小数点，然后在字符串后面加上e±xxx，其中±xxx是指数值的字符串转换。例如，如果尾数转换结果为1234567890123456，且指数为–3，那么生成的字符串将是1.234567890123456e-003（注意指数数字前的0）。
- en: 9.2.4 Double-Precision Values to Strings
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4 双精度值转换为字符串
- en: This section presents the code that will convert a double-precision value to
    a string in either decimal or exponential form, with separate functions for the
    two output formats. As Listing 9-13 is rather long, I’ve broken it into pieces
    and annotated each section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了将双精度值转换为字符串的代码，可以是十进制或指数形式，分别为这两种输出格式提供了不同的函数。由于列表 9-13 比较长，我已将其拆分为多个部分，并对每个部分进行了注释。
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As is typical for sample programs in this chapter, Listing 9-13 begins with
    a read-only data section ❶ containing the program’s title string and various format
    strings used by printf() calls in the main program. The single data variable in
    this program is r64str_1 ❷, a 32-byte character string used to hold the converted
    string. The program is responsible for ensuring that all conversions will fit
    into 32 bytes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 像本章中的示例程序一样，列表 9-13 以一个只读数据部分 ❶ 开头，其中包含程序的标题字符串和主程序中 printf() 调用所使用的各种格式字符串。此程序中的唯一数据变量是
    r64str_1 ❷，它是一个 32 字节的字符字符串，用于存放转换后的字符串。程序负责确保所有转换都能适应 32 字节的空间。
- en: Listing 9-13 places several read-only constants in the .code section so the
    program can directly access these constants by using the PC-relative addressing
    mode (rather than using multiple instructions to take the address of the object
    and access it indirectly). The first such constant is tenTo15 ❸, which holds the
    value 1.0e+15\. The conversion code uses this constant to multiply a floating-point
    value in the range 1.0 to slightly less than 10.0 by 1e+15, thereby obtaining
    a value slightly less than 1e+16 when converting the mantissa to an integer value.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-13 将几个只读常量放置在 .code 部分，以便程序可以通过使用相对 PC 定址模式直接访问这些常量（而不是使用多个指令获取对象的地址并间接访问它）。第一个这样的常量是
    tenTo15 ❸，它保存值 1.0e+15\。转换代码使用这个常量将范围在 1.0 到略小于 10.0 之间的浮动点值乘以 1e+15，从而在将尾数转换为整数值时获得略小于
    1e+16 的值。
- en: The potPos, potNeg, and expTbl tables ❹ contain the positive and negative powers
    of 10 (*pot*) tables used to multiply the floating-point value by various powers
    of 10 when massaging the value into the range 1.0 to 10.0\. The expTbl contains
    the absolute value of the exponent corresponding to the same entry in the potPos
    and potNeg tables. The code adds or subtracts this value from the accumulated
    decimal exponent while converting the mantissa to the range 1.0 to 10.0.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: potPos、potNeg 和 expTbl 表 ❹ 包含用于将浮动点值乘以不同 10 的幂次的正负 10 的幂次（*pot*）表，用于将值处理到 1.0
    到 10.0 的范围内。expTbl 包含与 potPos 和 potNeg 表中的相同条目对应的指数的绝对值。代码在将尾数转换到 1.0 到 10.0 的范围时，会将此值加到或从累积的小数指数中减去。
- en: The maxDigits manifest constant ❺ specifies the number of significant digits
    supported by this conversion code (16 digits for double-precision floating-point
    numbers). Finally, this code section contains the ubiquitous getTitle function
    ❻ that returns the address of the program’s title string to the C++ shell code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: maxDigits 清单常量 ❺ 指定了该转换代码支持的有效数字的数量（对于双精度浮动点数是 16 位）。最后，这段代码包含了无处不在的 getTitle
    函数 ❻，它返回程序标题字符串的地址，供 C++ shell 代码使用。
- en: 'The following code converts a floating-point value to a string:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将浮动点值转换为字符串：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The u53ToStr function ❶ is responsible for converting a 53-bit unsigned integer
    to a string of exactly 16 digits. In theory, this code could have used the u64toSizeStr
    function from Listing 9-12 to convert the 53-bit value (zero-extended to 64 bits)
    into a string. However, the conversion of floating-point mantissa to string always
    produces a 16-character string (with leading 0s, if necessary), so the decimal
    integer-to-string conversion can be more efficient than the u64toSizeStr function,
    which could produce variable-length strings. To prioritize saving space, if you’re
    already using the u64toSizeStr function in your code, you could remove u53ToStr
    and substitute a call to u64toSizeStr (specifying '0' as the fill character).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: u53ToStr 函数 ❶ 负责将一个 53 位无符号整数转换为一个恰好包含 16 位数字的字符串。理论上，代码可以使用来自列表 9-12 的 u64toSizeStr
    函数将 53 位的值（零扩展为 64 位）转换为字符串。然而，浮动点尾数转换为字符串时总是会生成一个 16 字符的字符串（如果需要，会有前导零），因此十进制整数到字符串的转换比
    u64toSizeStr 函数更高效，后者可能会生成可变长度的字符串。为了优先节省空间，如果你的代码中已经使用了 u64toSizeStr 函数，你可以去掉
    u53ToStr，改为调用 u64toSizeStr（并指定 '0' 作为填充字符）。
- en: 'The conversion algorithm u53ToStr uses is straightforward and brute-force:
    it converts the LO eight digits to a sequence of eight characters and emits them
    ❷, then converts the HO eight digits to a sequence of eight characters and emits
    them ❸. It both cases, it uses the divide-by-10 and remainder of division-by-10
    algorithms to convert each digit to a character (see the discussion of u64ToStr
    in Listing 9-6 for more details).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: u53ToStr使用的转换算法非常直接且暴力：它将低8位数字转换为8个字符的序列并输出❷，然后将高8位数字转换为8个字符的序列并输出❸。在这两种情况下，它都使用除以10和除以10的余数算法将每个数字转换为字符（更多细节请参考Listing
    9-6中的u64ToStr讨论）。
- en: 'This function is used by FPDigits to convert the mantissa to a string of decimal
    digits:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数由FPDigits使用，将尾数转换为十进制数字字符串：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: FPDigits converts an arbitrary double-precision mantissa to a string of decimal
    digits. It assumes that the floating-point value to convert is held in the D0
    register and that X0 contains a pointer to the buffer that will hold the string
    conversion. This function also converts the binary (power-of-2) exponent to a
    decimal integer, returns the exponent value in the X1 register, and returns the
    value’s sign (a space character, indicating a nonnegative value, or -) in the
    X2 register.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: FPDigits将任意的双精度尾数转换为十进制数字字符串。它假定要转换的浮点值存储在D0寄存器中，且X0包含指向将存储字符串转换结果的缓冲区的指针。该函数还将二进制（2的幂次）指数转换为十进制整数，并将指数值返回至X1寄存器，将值的符号（空格字符表示非负值，或'-'）返回至X2寄存器。
- en: FPDigits begins by first checking for the special case of 0.0 ❶. If D0 contains
    0, this function initializes the string buffer to 0000000000000000 (sixteen 0
    characters) and returns with X0 containing 0 and X2 containing a space character.
    The code checks for the special case of -0.0 and returns X2 containing a minus
    sign if the result is -0.0 ❷. Next, FPDigits checks the sign of the floating-point
    value and sets X2 to a '-', if appropriate ❸. The code also initializes the decimal
    exponent accumulator (held in X0) to 0.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: FPDigits首先检查特殊情况0.0❶。如果D0包含0，该函数将字符串缓冲区初始化为0000000000000000（16个0字符），并返回，X0包含0，X2包含空格字符。代码会检查特殊情况-0.0，如果结果为-0.0，则返回X2包含负号❷。接下来，FPDigits检查浮点值的符号，并根据需要将X2设置为'-'❸。代码还将十进制指数累加器（保存在X0中）初始化为0。
- en: After setting the sign, the FPDigits function checks the floating-point value’s
    exponent to see if it is positive or negative ❹. The code handles values with
    positive or negative exponents independently. If the exponent is negative, the
    cmpNegExp loop searches through the potNeg table looking for the value that is
    greater than the value in D0 ❺. When the loop finds such a value, it multiplies
    D0 by that entry in potNeg and then subtracts the corresponding entry in expTbl
    from the decimal exponent value held in X1\. The cmpNegExp loop repeats this process
    until the value in D0 is greater than 1.0\. Whenever the result isn’t greater
    than 1.0, the code multiplies the value in D0 by 10.0, because the code needs
    to adjust for the multiplication by 0.1 that has taken place. If, on the other
    hand, the exponent was positive ❻, the cmpPosExp loop does the same task but divides
    by entries in the potPos table and adds the corresponding entry in expTbl to the
    decimal exponent value held in X1.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置符号后，FPDigits函数检查浮点值的指数，看看它是正数还是负数❹。代码分别处理正指数和负指数的值。如果指数为负，cmpNegExp循环会通过potNeg表查找大于D0中值的项❺。当循环找到这样的值时，它将D0乘以potNeg中的该项，然后从X1中存储的十进制指数值中减去expTbl中相应的项。cmpNegExp循环会重复这个过程，直到D0中的值大于1.0。每当结果不大于1.0时，代码会将D0中的值乘以10.0，因为代码需要调整之前发生的0.1的乘法。另一方面，如果指数为正❻，cmpPosExp循环则做同样的工作，但会除以potPos表中的项，并将expTbl中相应的项加到X1中存储的十进制指数值。
- en: Once the cmpPosExp or cmpNegExp loop gets the value into the range 1.0 to just
    less than 10.0, it multiplies the value by 10^(15) and converts it to an integer
    (in X22) ❼. Then FPDigits calls the u53toStr function to convert this integer
    to a string of exactly 16 digits. The function returns the sign character (space
    for nonnegative values, '-' for negative values) in X2 and the decimal exponent
    in X1.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦cmpPosExp或cmpNegExp循环将值调整到1.0到接近10.0的范围，它会将该值乘以10^(15)，并将其转换为整数（存储在X22中）❼。然后，FPDigits调用u53toStr函数将此整数转换为一个精确的16位数字字符串。该函数将符号字符（非负值为空格，负值为'-'）返回至X2，十进制指数返回至X1。
- en: 'Note that FPDigits converts only the mantissa to a string of digits. This is
    the base code used by the r64ToStr and e64ToStr functions that convert floating-point
    values into recognizable strings. Before presenting those functions, there is
    one utility function to explain: chkNaNINF.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，FPDigits仅将尾数转换为数字字符串。这是r64ToStr和e64ToStr函数的基础代码，用于将浮点值转换为可识别的字符串。在介绍这些函数之前，有一个实用函数需要解释：chkNaNINF。
- en: 'Certain floating-point operations produce invalid results. The IEEE 754 floating-point
    standard defines three special values to represent these invalid results: NaN
    (not a number), +INF (infinity), and -INF (negative infinity). Because the ARM
    floating-point hardware can produce these results, it is important that the conversions
    of floating-point to string handle these three special values. NaN, +INF, and
    -INF all have an exponent value containing 0x7FF (and no other valid values use
    this exponent). If the exponent is 0x7FF and the mantissa bits are all 0s, the
    value is +INF or -INF (determined by the sign bit). If the mantissa is nonzero,
    the value is NaN (and you can ignore the sign bit). The chkNaNINF function checks
    for these values and outputs the strings NaN, INF, or -INF if the number is invalid:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 某些浮点操作会产生无效结果。IEEE 754浮点标准定义了三种特殊值来表示这些无效结果：NaN（非数字）、+INF（正无穷大）和-INF（负无穷大）。由于ARM浮点硬件可能会产生这些结果，因此浮点到字符串的转换必须处理这三种特殊值。NaN、+INF和-INF的指数值都包含0x7FF（没有其他有效值使用此指数）。如果指数是0x7FF且尾数位全为0，则值为+INF或-INF（由符号位决定）。如果尾数非零，则值为NaN（符号位可以忽略）。chkNaNINF函数会检查这些值，并在数字无效时输出字符串NaN、INF或-INF：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code moves the floating-point value in D0 into X0 and then checks the exponent
    bits to see if they contain 0x7FF ❶. If the exponent does not contain this value,
    the procedure returns to the caller (using the return address in LR).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将D0中的浮点值移动到X0，然后检查指数位是否包含0x7FF ❶。如果指数位不包含此值，过程将返回给调用者（使用LR中的返回地址）。
- en: If the exponent bits are 0x7FF, the code checks the mantissa to see if it is
    0 or nonzero ❷. If it’s nonzero, the code emits the character string NaN to the
    buffer pointed at by X22 ❸. If the mantissa is nonzero, the code checks whether
    the sign bit is set ❹. If not, this code emits INF to the output buffer. If the
    sign bit is set, the code emits -INF to the output buffer ❺.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指数位是0x7FF，代码会检查尾数以判断其是0还是非零 ❷。如果是非零，代码会将字符字符串NaN输出到由X22指向的缓冲区 ❸。如果尾数非零，代码会检查符号位是否被设置
    ❹。如果没有，代码会将INF输出到输出缓冲区。如果符号位被设置，代码会将-INF输出到输出缓冲区 ❺。
- en: In all three cases (NaN, INF, or -INF), the code transfers to fillSpecial ❻,
    where it adds sufficient padding characters (the padding character is in W21,
    and the field width is in X19). Rather than return to the caller, this code transfers
    control to the address held in X25 ❼. The caller (r64ToStr or e64ToStr) loads
    the invalid value return address into X25 prior to calling chkNaNINF. I could
    have set a flag, such as the carry flag, and tested it on return. However, I wanted
    to demonstrate another way to achieve this, and this approach is slightly more
    elegant (though arguably less readable).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三种情况下（NaN、INF或-INF），代码会转移到fillSpecial ❻，在那里它添加足够的填充字符（填充字符在W21中，字段宽度在X19中）。此时，代码不会返回给调用者，而是将控制权转移到X25中保存的地址
    ❼。调用者（r64ToStr或e64ToStr）在调用chkNaNINF之前将无效值返回地址加载到X25中。我本可以设置一个标志，比如进位标志，并在返回时测试它。然而，我想展示另一种实现方法，这种方法稍显优雅（尽管可以说不那么易读）。
- en: 'With chkNaNINF out of the way, it’s time to take a look at the r64ToStr function
    that the user calls to convert floating-point values into strings:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在chkNaNINF处理完毕后，是时候看看用户调用的r64ToStr函数，它将浮点值转换为字符串：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The r64ToStr function converts the floating-point value in D0 to a string in
    standard decimal form, supporting output field widths, number of digits after
    the decimal point, and fill character for leading positions that would normally
    be blank.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: r64ToStr函数将D0中的浮点值转换为标准十进制格式的字符串，支持输出字段宽度、小数点后的数字位数以及用于填充通常为空白的前导位置的字符。
- en: After appropriate initialization, r64ToStr first checks for the values NaN (not
    a number), INF (infinity), and -INF (minus infinity) ❶; these values require special
    nonnumeric output strings, which must still be padded to fWidth characters. The
    r64ToStr calls FPDigits to convert the mantissa to a string of decimal digit characters
    (and obtain the power-of-10 exponent in integer form) ❷. The next step is to round
    the number based on the number of digits to appear after the decimal point ❸.
    This code computes the index into the string produced by FPDigits one character
    beyond the number of digits specified by the decDigits parameter. It fetches this
    character (which will be '0' through '9') and adds 5 to its ASCII code. If the
    result is greater than the ASCII code of '9', the code has to bump the previous
    digit in the string by 1\. Of course, if that character contains '9', overflow
    will occur and the carry has to ripple through to previous digit(s). If the carry
    ripples all the way to the first character of the string, the code must shift
    all the characters one position to the right and insert a '1' at the beginning
    of the string ❹.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当初始化后，r64ToStr 首先检查 NaN（非数值）、INF（无穷大）和 -INF（负无穷大） ❶；这些值需要特殊的非数值输出字符串，但仍然需要填充至
    fWidth 字符数。r64ToStr 调用 FPDigits 将尾数转换为十进制数字字符的字符串（并以整数形式获得十的幂指数） ❷。接下来的步骤是根据小数点后出现的数字位数对数字进行四舍五入
    ❸。该代码计算出由 FPDigits 生成的字符串中的索引位置，该位置在 decDigits 参数指定的数字位数之后。它获取该字符（该字符将是 '0' 到
    '9'）并将其 ASCII 码加 5。如果结果大于字符 '9' 的 ASCII 码，代码必须将字符串中的前一个数字加 1。当然，如果该字符是 '9'，则会发生溢出，进位必须向前传递到前一个字符。如果进位一直传递到字符串的第一个字符，代码必须将所有字符向右移动一位，并在字符串的开头插入
    '1' ❹。
- en: 'Next, the code emits the characters associated with the final decimal string.
    The algorithm splits into two sections ❺, with one section handling positive (and
    0) exponents and the other handling negative exponents. For negative exponents,
    the code will emit any fill characters, the sign of the number (still held in
    X2), and the decDigits digits from the mantissa string conversion ❻. If the field
    width and decDigits are sufficiently large, the code will simply output the ''0''
    character for all characters beyond the 16th significant digit. If the number
    of output digits would exceed the field width the caller passes, the widthTooBig
    code ❼ will emit # characters to indicate a formatting error (the standard HLL
    approach to format errors in floating-point conversions).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，代码输出与最终小数字符串相关的字符。算法分为两个部分 ❺，其中一部分处理正指数（包括 0），另一部分处理负指数。对于负指数，代码将输出任何填充字符、数字符号（仍保存在
    X2 中）以及从尾数字符串转换得到的 decDigits 位数字 ❻。如果字段宽度和 decDigits 足够大，代码将简单地输出 ''0'' 字符，直到超过第
    16 位有效数字。如果输出的数字位数超过调用者传递的字段宽度，widthTooBig 代码 ❼ 将输出 # 字符以指示格式错误（在浮点转换中的标准 HLL
    格式错误处理方式）。'
- en: The code handles floating-point conversions of values greater than or equal
    to 1.0 (positive exponents) ❽. This code emits necessary padding characters and
    the value’s sign, then calculates the position of the decimal point in the output
    string and rounds the last digit throughout the string, as previously described.
    It then outputs the characters returned by FPDigits up to that position. Finally,
    it outputs the decimal point, followed by the remaining fractional digits. If
    it turns out that the code cannot fit the number into the field width (and decimal
    digits) specified, it transfers control to widthTooBig to produce the error string.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码处理大于或等于 1.0 的浮点数值转换（正指数） ❽。该代码输出必要的填充字符和数值的符号，然后计算输出字符串中小数点的位置，并按照之前描述的方式四舍五入字符串中的最后一个数字。然后，它输出由
    FPDigits 返回的字符直到该位置。最后，输出小数点，后跟剩余的小数位。如果代码无法将数字适配到指定的字段宽度（以及小数位数），则会将控制转移到 widthTooBig
    来生成错误字符串。
- en: To notify the caller of possible errors, this code clears the carry flag upon
    return ❾ if the conversion was successful, or sets the carry flag on return if
    there was an error ❿. This allows the caller to easily test for success/ failure
    with a single bcs or bcc instruction after the call to r64ToStr.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通知调用者可能发生的错误，该代码在返回时会清除进位标志 ❾（如果转换成功），或者如果发生错误，则在返回时设置进位标志 ❿。这允许调用者在调用 r64ToStr
    后，通过简单的 bcs 或 bcc 指令来轻松测试成功/失败。
- en: 'The final output format handled by Listing 9-13 is exponential (scientific)
    form. Two functions handle this conversion: expToBuf and e64ToStr. The former
    handles the formatting of the exponent portion of the output string:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-13 中处理的最终输出格式为指数（科学）形式。这个转换由两个函数处理：expToBuf 和 e64ToStr。前者处理输出字符串中指数部分的格式化：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The expToBuf function produces a string of exactly one, two, or three digits
    (based on the parameters the caller passes in X0 and X1). The expToBuf function
    begins by verifying that the exponent digit count is within range ❶ and that the
    actual exponent will fit in the number of digits specified ❷. The code branches
    to three separate output conversion code sequences if the exponent output is three
    digits (the normal case ❸), one digit ❹, or two digits ❺. The code stores those
    characters into the buffer where X2 points ❻.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: expToBuf 函数生成一个恰好由一、两或三个数字组成的字符串（具体根据调用者传递的 X0 和 X1 参数决定）。expToBuf 函数首先验证指数位数是否在范围内
    ❶，并且实际的指数值是否能够适应指定的数字位数 ❷。如果指数输出为三位数（正常情况 ❸）、一位数 ❹ 或两位数 ❺，代码会跳转到三个不同的输出转换代码序列。代码将这些字符存储到
    X2 指向的缓冲区中 ❻。
- en: 'The function returns the error status in the carry flag, returning with the
    carry clear for a successful operation, or the carry set if the exponent is too
    large or the converted number will not fit in the number of character positions
    that X1 specifies. Other than this, expToBuf is basically a switch statement (implemented
    using if...then...else logic) that has three cases: one for each exponent size
    (one, two, or three characters).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过进位标志返回错误状态，若操作成功，则进位标志清除；如果指数过大或转换后的数字无法适应 X1 指定的字符位置数，则进位标志被设置。除此之外，expToBuf
    基本上是一个 switch 语句（使用 if...then...else 逻辑实现），它有三个情况：分别对应每种指数大小（一位、两位或三位）。
- en: 'The e64ToStr function handles the conversion from double-precision to string
    using exponential format:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: e64ToStr 函数处理从双精度到字符串的转换，采用指数格式：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Converting the mantissa to a string is very similar to the routine in r64ToStr,
    though exponential form is a little easier, as the format always places the decimal
    point immediately after the first mantissa digit. As with r64ToStr, e64ToStr begins
    by checking the input parameters to see if they are valid ❶ (returning with the
    carry flag set and an error code in X0 if an error occurred). After parameter
    validation, the code checks for NaN or INF ❷. It then calls FPDigits to convert
    the mantissa to a string of digits ❸ (held in a local buffer). This call also
    returns the sign of the value as well as a decimal integer exponent.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将尾数转换为字符串与 r64ToStr 中的例程非常相似，尽管指数形式稍微简单一些，因为格式总是将小数点放置在第一个尾数数字后面。与 r64ToStr
    一样，e64ToStr 通过检查输入参数是否有效来开始 ❶（如果发生错误，将返回并在 X0 中设置错误代码及进位标志）。在参数验证之后，代码检查是否为 NaN
    或 INF ❷。然后，它调用 FPDigits 将尾数转换为数字字符串 ❸（保存在本地缓冲区中）。此调用还返回值的符号以及十进制整数指数。
- en: 'After calculating the decimal exponent value, the e64ToStr function checks
    whether the converted value will fit into the space specified by the Width input
    parameter ❹. If the converted number would be too large, e64ToStr emits a string
    of # characters to denote an error.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '在计算出十进制指数值后，e64ToStr 函数会检查转换后的值是否适合由 Width 输入参数指定的空间 ❹。如果转换后的数字过大，e64ToStr
    会生成一串 # 字符以表示错误。'
- en: 'Note that this situation is not considered an error in the sense of returning
    the carry flag set. If the caller specifies an insufficient field width, the function
    still succeeds in creating a string conversion; that string just happens to be
    filled with # characters. The carry flag is set, on error, when e64ToStr cannot
    produce an output string.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，这种情况不被视为返回进位标志已设置的错误。如果调用者指定了不足的字段宽度，函数仍然能够成功生成字符串转换；不过该字符串可能会被填充为 # 字符。只有在
    e64ToStr 无法生成输出字符串时，进位标志才会被设置为错误。'
- en: After verifying that the string will fit in the specified field width, the e64ToStr
    function rounds the result to the specified number of decimal digits ❺. This algorithm
    is identical to that used by r64ToStr. Next, the code outputs the mantissa digits
    ❻. Again, this is similar to the way r64ToStr works, except that the decimal point
    is always placed after the first digit (no need to calculate its position). Finally,
    the code emits e followed by the exponent’s sign character ❼ and then calls expToBuf
    to convert the exponent to a one-, two-, or three-digit character sequence (specified
    by the expDigs parameter the caller passes in X3).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证字符串能够适应指定的字段宽度后，e64ToStr函数将结果四舍五入到指定的小数位数❺。这个算法与r64ToStr使用的算法相同。接下来，代码输出尾数位数❻。同样，这与r64ToStr的工作方式类似，只不过小数点总是放在第一个数字后（不需要计算它的位置）。最后，代码输出e后跟指数的符号字符❼，然后调用expToBuf将指数转换为一位、两位或三位的字符序列（由调用者通过X3传递的expDigs参数指定）。
- en: 'The remaining code in Listing 9-13 provides utility functions used by the main
    program to display data (r64Print and e64Print), along with the asmMain procedure
    that demonstrates floating-point output using the functions in this section:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-13中的其余代码提供了主程序用来显示数据的实用函数（r64Print和e64Print），以及演示如何使用本节中函数的asmMain过程：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that these functions preserve all the nonvolatile registers because printf()
    can modify them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些函数保留了所有非易失性寄存器，因为printf()可以修改它们。
- en: 'The asmMain function is a typical demonstration program for the floating- point
    string-conversion functions. It calls the r64ToStr and e64ToStr functions with
    various input parameters to demonstrate the use of these functions:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: asmMain函数是一个典型的浮点数字符串转换函数示范程序。它使用不同的输入参数调用r64ToStr和e64ToStr函数，演示这些函数的用法：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Listing 9-13 places the floating-point constant values in the code section rather
    than a read-only data section ❶, making it easier to modify them when looking
    at the main program.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-13将浮点常量值放在代码段中，而不是只读数据段❶，这样在查看主程序时更容易修改它们。
- en: 'The following is the build command and sample output for Listing 9-13:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列表9-13的构建命令和示例输出：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This output demonstrates double-precision floating-point output. If you want
    to convert a single-precision value to a string, first convert the single-precision
    value to double-precision and use this code to translate the resulting double-precision
    value to a string.  ### 9.3 String-to-Numeric Conversions'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '该输出演示了双精度浮点数输出。如果你想将一个单精度值转换为字符串，首先将单精度值转换为双精度值，然后使用这段代码将得到的双精度值转换为字符串。 ###
    9.3 字符串与数值的转换'
- en: The routines converting numeric values to strings, and strings to numeric values,
    have two fundamental differences. First of all, numeric-to-string conversions
    generally occur without possibility of error (assuming you have allocated a sufficiently
    large buffer so that the conversion routines don’t write data beyond the end of
    the buffer). String-to-numeric conversions, on the other hand, must handle the
    real possibility of errors like illegal characters and numeric overflow.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 数值转换为字符串和字符串转换为数值的过程有两个基本区别。首先，数值到字符串的转换通常不会出错（前提是你分配了足够大的缓冲区，以防转换函数写入缓冲区末尾之外的数据）。而字符串到数值的转换则必须处理如非法字符和数值溢出等错误的实际可能性。
- en: A typical numeric input operation consists of reading a string of characters
    from the user and then translating this string of characters into an internal
    numeric representation. For example, in C++ a statement like cin >> i32; reads
    a line of text from the user and converts a sequence of digits appearing at the
    beginning of that line of text into a 32-bit signed integer (assuming i32 is a
    32-bit int object). The cin >> i32; statement skips over certain characters, like
    leading spaces, in the string that may appear before the actual numeric characters.
    The input string may also contain additional data beyond the end of the numeric
    input (for example, it is possible to read two integer values from the same input
    line), and therefore the input conversion routine must determine where the numeric
    data ends in the input stream.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的数字输入操作包括从用户读取一个字符字符串，然后将这个字符字符串转换为内部数字表示。例如，在 C++ 中，像 `cin >> i32;` 这样的语句从用户读取一行文本，并将该行文本开头的数字序列转换为
    32 位有符号整数（假设 i32 是一个 32 位整数对象）。`cin >> i32;` 语句会跳过字符串中可能出现在实际数字字符前面的某些字符，如前导空格。输入字符串还可能包含超出数字输入末尾的额外数据（例如，可能从同一输入行读取两个整数值），因此输入转换程序必须确定数字数据在输入流中的结束位置。
- en: 'Typically, C++ achieves this by looking for a character from a set of *delimiter*
    characters. The delimiter character set could be something as simple as any character
    that is not a numeric digit; or the set could be the whitespace characters (space,
    tab, and so on) along with perhaps a few other characters such as a comma (,)
    or another punctuation character. For the sake of example, the code in this section
    assumes that any leading spaces or tab characters (ASCII code 9) may precede the
    first numeric digit and that the conversion stops on the first non-digit character
    it encounters. Possible error conditions are as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C++ 通过查找一组 *分隔符* 字符来实现这一点。分隔符字符集可以是简单的任何非数字字符；或者该集合可能包括空白字符（空格、制表符等），以及可能的一些其他字符，如逗号（,）或其他标点符号。为了举例，本节代码假设任何前导空格或制表符字符（ASCII
    代码 9）可能出现在第一个数字字符之前，并且转换会在遇到第一个非数字字符时停止。可能的错误情况如下：
- en: No numeric digits at all at the beginning of the string (following any spaces
    or tabs).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串开头完全没有数字字符（跳过任何空格或制表符后）。
- en: The string of digits is a value that would be too large for the intended numeric
    size (for example, 64 bits).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字字符串的值可能太大，无法适应预定的数字大小（例如，64 位）。
- en: It will be up to the caller to determine whether the numeric string ends with
    an invalid character upon return from the function call.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者需要确定在函数调用返回后，数字字符串是否以无效字符结尾。
- en: 9.3.1 Decimal Strings to Integers
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1 十进制字符串转整数
- en: 'The basic algorithm to convert a string containing decimal digits to a number
    is the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将包含十进制数字的字符串转换为数字的基本算法如下：
- en: 1.  Initialize an accumulator variable to 0.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  将累加器变量初始化为 0。
- en: 2.  Skip any leading spaces or tabs in the string.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  跳过字符串中的任何前导空格或制表符。
- en: 3.  Fetch the first character after the spaces/tabs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  获取空格/制表符后的第一个字符。
- en: 4.  If the character is not a numeric digit, return an error. If the character
    is a numeric digit, fall through to step 5.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  如果字符不是数字字符，返回错误。如果字符是数字字符，继续执行第 5 步。
- en: 5.  Convert the numeric character to a numeric value (using AND 0xf).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  将数字字符转换为数字值（使用 AND 0xf）。
- en: 6.  Set the accumulator = (accumulator × 10) + current numeric value.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  将累加器设置为 = (累加器 × 10) + 当前数字值。
- en: 7.  If overflow occurs, return and report an error. If no overflow occurs, fall
    through to step 8.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  如果发生溢出，返回并报告错误。如果没有发生溢出，则继续到第 8 步。
- en: 8.  Fetch the next character from the string.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  从字符串中获取下一个字符。
- en: 9.  If the character is a numeric digit, go back to step 5; otherwise, fall
    through to step 10.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  如果字符是数字字符，回到第 5 步；否则，继续执行第 10 步。
- en: 10.  Return success, with the accumulator containing the converted value.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  返回成功，累加器中包含转换后的值。
- en: 'For signed integer input, you use this same algorithm with the following modifications:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有符号整数输入，使用相同的算法，并做以下修改：
- en: If the first non-space/tab character is a hyphen (-), set a flag denoting that
    the number is negative and skip the - character. If the first character is not
    -, clear the flag.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个非空格/制表符字符是连字符（-），设置一个标志，表示数字是负数，并跳过 - 字符。如果第一个字符不是 -，则清除标志。
- en: At the end of a successful conversion, if the flag is set, negate the integer
    result before returning (you must check for overflow on the negate operation).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在成功转换结束时，如果标志被设置，在返回之前需要对整数结果进行取反（必须检查取反操作是否溢出）。
- en: Listing 9-14 implements the conversion algorithm; I’ve again broken this listing
    into several sections to better annotate it. The first section contains the usual
    format strings, along with various sample strings the main program uses to test
    the strtou and strtoi functions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-14实现了转换算法；我再次将这个列表分成几个部分，以便更好地注释它。第一部分包含通常的格式字符串，以及主程序用来测试strtou和strtoi函数的各种示例字符串。
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This program doesn’t have any static, writable data; all variable data is kept
    in registers or in local variables.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序没有任何静态、可写的数据；所有变量数据都保存在寄存器或局部变量中。
- en: 'The following code is the strtou function, which converts strings containing
    decimal digits to an unsigned integer:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是strtou函数，它将包含十进制数字的字符串转换为无符号整数：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: On entry into strtou, the X1 register points at the first character of the string
    to convert. This function begins by skipping over any whitespace characters (spaces
    and tabs) in the string, leaving X1 pointing at the first non-space/non-tab character
    ❶.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 进入strtou时，X1寄存器指向待转换字符串的第一个字符。该函数首先跳过字符串中的任何空白字符（空格和制表符），使X1指向第一个非空白/非制表符字符❶。
- en: After any whitespace characters, the first character must be a decimal digit,
    or strtou must return a conversion error. Therefore, after finding a non-whitespace
    character, the code checks to see that the character is in the range '0' to '9'
    ❷.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何空白字符之后，第一个字符必须是十进制数字，否则strtou必须返回转换错误。因此，在找到非空白字符后，代码会检查该字符是否在'0'到'9'的范围内❷。
- en: 'After verifying that the first character is a digit, the code enters the main
    conversion loop ❸. Normally, you’d just convert the character to an integer (by
    ANDing with 0xF), multiply the accumulator in X0 by 10, and add in the character’s
    value. This could be done using two instructions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证第一个字符是数字之后，代码进入主要的转换循环❸。通常，你只需将字符转换为整数（与0xF进行按位与操作），然后将X0寄存器中的累加器乘以10，并加上字符的值。这可以通过两条指令完成：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The only problem is that you cannot detect overflow by using these two instructions
    (something that the strtou function must do). To detect an overflow due to the
    multiplication by 10, the code must use the umulh instruction and check the result
    for 0 (if it is not 0, overflow occurs) ❸. If the umulh result is 0, the code
    can multiply the accumulator (X0) by 10 without fear of overflow. Of course, overflow
    can still occur when adding the character’s value to the product of X0 and 10,
    so you still cannot use madd; instead, you must multiply the accumulator by 10,
    then use the adds instruction to add in the character value and check the carry
    flag immediately thereafter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是，使用这两条指令不能检测溢出（strtou函数必须执行这一操作）。为了检测因乘以10而导致的溢出，代码必须使用umulh指令，并检查结果是否为0（如果不是0，说明发生了溢出）❸。如果umulh的结果为0，代码可以放心地将累加器（X0）乘以10而不必担心溢出。当然，在将字符的值加到X0和10的积上时，仍然可能发生溢出，因此你仍然不能使用madd指令；相反，你必须先将累加器乘以10，然后使用adds指令将字符值加进去，并立即检查进位标志。
- en: The convert loop repeats this process until either an overflow occurs or it
    encounters a nondigit character. Once it encounters a nondigit character ❹, the
    converted integer value is in the X0 register, and the function returns with the
    carry clear. Note that if the conversion is successful, the strtou function does
    not restore the X1 register; instead, it returns with X1 pointing at the first
    nondigit character ❺. It is the caller’s responsibility to check this character
    to see if it is legitimate.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 转换循环会重复这一过程，直到发生溢出或遇到非数字字符。一旦遇到非数字字符❹，转换后的整数值会保存在X0寄存器中，函数返回时，进位标志被清除。注意，如果转换成功，strtou函数不会恢复X1寄存器的值；相反，它会返回时让X1指向第一个非数字字符❺。调用者有责任检查这个字符，看看它是否合法。
- en: In the event of an overflow or an illegal starting character, the function returns
    with the carry flag set and an error code in X0 ❻.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生溢出或遇到非法的起始字符，函数会返回时设置进位标志，并在X0寄存器中放入错误代码❻。
- en: 'The following code is the strtoi procedure, which is the signed-integer version
    of the strtou procedure:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是strtoi过程，它是strtou过程的有符号整数版本：
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The strtoi function converts a string containing a signed integer to the corresponding
    value in X0\. The code begins by eliminating whitespace ❶, then checks for a '-'
    character ❷. The function maintains a “negative flag” in the X2 register (0 =
    nonnegative, 1 = negative). After skipping the optional sign character, the code
    calls the strtou function to convert the following string to an unsigned value
    ❸.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: strtoi函数将包含有符号整数的字符串转换为X0中的相应值。代码首先消除空白❶，然后检查是否存在'-'字符❷。该函数在X2寄存器中维护一个“负数标志”（0
    = 非负数，1 = 负数）。跳过可选的符号字符后，代码调用strtou函数将后续的字符串转换为无符号值❸。
- en: Upon return from strtou, the strtoi function checks the sign flag in X2 and
    negates the number if it’s supposed to be negative ❹. In both cases (negative
    or nonnegative), the code also checks for an overflow condition and returns an
    error if an overflow occurred.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从strtou返回后，strtoi函数检查X2中的符号标志，如果应该是负数，则对数字进行取反❹。无论是负数还是非负数，代码还会检查是否发生溢出，并在发生溢出时返回错误。
- en: As for strtou, the strtoi function does not restore X1 if the conversion was
    successful. However, it will restore X1 if an overflow occurred or if strtou reported
    an error.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与strtou一样，strtoi函数在转换成功时不会恢复X1。然而，如果发生溢出或strtou报告错误，它将恢复X1。
- en: When you call strtou to convert the string to an integer, strtoi will allow
    an arbitrary amount of whitespace between the minus sign and the first digit of
    a string representing a negative number. If this is a problem for you, modify
    strtou to skip whitespace and then call a subservient routine to do the conversion;
    next, have strtoi call that subservient routine (which will return an illegal
    initial character error, if appropriate) in place of strtou.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用strtou将字符串转换为整数时，strtoi允许在表示负数的字符串中的减号和第一个数字之间有任意数量的空格。如果这对你来说是个问题，可以修改strtou来跳过空格，然后调用一个从属例程进行转换；接着，让strtoi调用该从属例程（如果合适的话，它会返回非法初始字符错误），而不是直接使用strtou。
- en: 'The asmMain function demonstrates calling the strtou and strtoi functions:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: asmMain函数演示了调用strtou和strtoi函数：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The asmMain function in Listing 9-14 is a typical test program; it converts
    various strings appearing in the read-only data section to their corresponding
    integer values and displays them. It also tests a couple of overflow conditions
    to verify that the routines properly handle overflow.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-14中的asmMain函数是一个典型的测试程序；它将只读数据段中出现的各种字符串转换为相应的整数值并显示出来。它还测试了几个溢出条件，以验证例程是否正确处理溢出。
- en: 'The following is the build command and sample output for the program in Listing
    9-14:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Listing 9-14中程序的构建命令和示例输出：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For an extended-precision string-to-numeric conversion, simply modify the strtou
    function to include an extended-precision accumulator, then do an extended-precision
    multiplication by 10 (rather than a standard multiplication).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于扩展精度的字符串到数值转换，只需修改strtou函数，加入扩展精度累加器，然后进行扩展精度的乘法运算（而不是标准乘法）。
- en: 9.3.2 Hexadecimal Strings to Numeric Form
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2 十六进制字符串转换为数值形式
- en: 'As was the case for numeric output, hexadecimal input is the easiest numeric
    input routine to write. The basic algorithm for converting hexadecimal strings
    to numeric form is the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与数值输出类似，十六进制输入是最简单的数值输入例程。将十六进制字符串转换为数值形式的基本算法如下：
- en: 1.  Initialize an accumulator value to 0.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  将累加器值初始化为0。
- en: 2.  For each input character that is a valid hexadecimal digit, repeat steps
    3 through 6; skip down to step 7 when the character is not a valid hexadecimal
    digit.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个有效的十六进制数字字符，重复步骤3到步骤6；如果字符不是有效的十六进制数字，则跳到步骤7。
- en: 3.  Convert the hexadecimal character to a value in the range 0 to 15 (0h to
    0Fh).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  将十六进制字符转换为0到15的值（0h到0Fh）。
- en: 4.  If the HO 4 bits of the accumulator value are nonzero, raise an exception.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  如果累加器值的高4位不为零，则抛出异常。
- en: 5.  Multiply the current value by 16 (that is, shift left 4 bits).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  将当前值乘以16（即左移4位）。
- en: 6.  Add the converted hexadecimal digit value to the accumulator.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  将转换后的十六进制数字值添加到累加器中。
- en: 7.  Check the current input character to ensure that it is a valid delimiter.
    Raise an exception if it is not.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  检查当前输入字符，确保它是有效的分隔符。如果不是，抛出异常。
- en: Listing 9-15 implements this hexadecimal input routine for 64-bit values.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-15实现了这个针对64位值的十六进制输入例程。
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The strtoh function is similar to strtou, except that it tests for hexadecimal
    digits ❶ (rather than just decimal digits), tests the HO 4 bits to determine whether
    an overflow occurs ❷ (much easier than the decimal case), and multiplies by the
    hexadecimal radix (16) rather than by 10 ❸.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: strtoh 函数类似于 strtou，不同之处在于它测试十六进制数字❶（而不仅仅是十进制数字），测试 HO 的 4 位以确定是否发生溢出❷（比十进制情况要简单得多），并且乘以十六进制基数（16）而不是
    10❸。
- en: 'Here’s the build command and sample output for the program in Listing 9-15:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是清单 9-15 中程序的构建命令和示例输出：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For hexadecimal string conversions that handle numbers greater than 64 bits,
    you have to use an extended-precision shift left by 4 bits. Listing 9-16 demonstrates
    the necessary modifications to the strtoh function for a 128-bit conversion.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理大于 64 位的数字的十六进制字符串转换，你必须使用扩展精度的向左移 4 位。清单 9-16 演示了对 strtoh 函数进行必要的修改以进行
    128 位转换。
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code works similarly to that in Listing 9-15\. The main difference is the
    128-bit shift left by 4 bits ❶ in Listing 9-16\. The code shifts X0 to the right
    60 bits, then ORs this into X1 after shifting it to the left 4 bits, which shifts
    4 bits from X0 into X1.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的工作方式类似于清单 9-15 中的代码。主要区别在于清单 9-16 中的 128 位向左移 4 位❶。该代码将 X0 向右移 60 位，然后将其向左移
    4 位后进行 OR 操作，将 X0 的 4 位移入 X1。
- en: 'Here’s the build command and sample output for Listing 9-16:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是清单 9-16 的构建命令和示例输出：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The hexadecimal-string-to-numeric function worked as expected.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制字符串到数字的函数按预期工作。
- en: '#### 9.3.3 String to Floating-Point'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 9.3.3 字符串转浮点数'
- en: 'Converting a string of characters representing a floating-point number to the
    64-bit double format is slightly easier than the double-to-string conversion that
    appeared earlier in this chapter. Because decimal conversion (with no exponent)
    is a subset of the more general scientific notation conversion, if you can handle
    scientific notation, you get decimal conversion for free. Beyond that, the basic
    algorithm is to convert the mantissa characters to an integer form in order to
    convert to floating-point, then read the (optional) exponent and adjust the double
    exponent accordingly. The algorithm for the conversion is the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将表示浮点数的字符字符串转换为 64 位双精度格式比本章前面出现的双精度转字符串转换稍微简单一些。因为十进制转换（没有指数）是更通用的科学计数法转换的一个子集，如果你能处理科学计数法，就可以轻松处理十进制转换。除此之外，基本算法是将尾数字符转换为整数形式以进行浮点数转换，然后读取（可选的）指数并相应调整双精度指数。转换的算法如下：
- en: 1.  Begin by stripping away any leading space or tab characters (and any other
    delimiters).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  首先去除任何前导空格或制表符字符（以及其他分隔符）。
- en: 2.  Check for a leading plus (+) or minus (-) sign character. Skip it if one
    is present. Set a sign flag to true if the number is negative (false if nonnegative).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  检查是否有前导加号（+）或减号（-）字符。如果有，跳过它。如果数字是负数，则将符号标志设置为 true（非负数则设置为 false）。
- en: 3.  Initialize an exponent value to –16\. The algorithm will create an integer
    value from the mantissa digits in the string. As double-precision floats support
    a maximum of 16 significant digits, initializing the exponent to –16 accounts
    for this.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  将指数值初始化为 –16。该算法将根据字符串中的尾数数字创建一个整数值。由于双精度浮点数支持最多 16 位有效数字，因此将指数初始化为 –16
    是考虑到了这一点。
- en: 4.  Initialize a significant-digit-counter variable that counts the number of
    significant digits processed thus far to 16.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  初始化一个有效数字计数器变量，记录到目前为止已处理的有效数字数量，初始值为 16。
- en: 5.  If the number begins with any leading 0s, skip over them (do not change
    the exponent or significant digit counters for leading 0s to the left of the decimal
    point).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  如果数字以任何前导零开头，则跳过它们（不要更改小数点左侧前导零的指数或有效数字计数）。
- en: 6.  If the scan encounters a decimal point after processing any leading 0s,
    go to step 11; otherwise, fall through to step 7.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  如果扫描在处理完任何前导零后遇到小数点，则转到步骤 11；否则，继续执行步骤 7。
- en: 7.  For each nonzero digit to the left of the decimal point, if the significant
    digit counter is not 0, multiply the integer accumulator by 10 and add in the
    numeric equivalent of the digit. This is the standard integer conversion. (If
    the significant digit counter is 0, the algorithm has already processed 16 significant
    digits and will ignore any additional digits, since the double format cannot represent
    more than 16 significant digits.)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 8.  For each digit to the left of the decimal point, increment the exponent
    value (originally initialized to –16) by 1.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 9.  If the significant digit counter is not 0, decrement the significant digit
    counter (which will also provide the index into the digit string array).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 10.  If the first nondigit encountered is not a decimal point, skip to step
    14.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 11.  Skip over the decimal point character.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 12.  For each digit encountered to the right of the decimal point, continue
    adding the digits to the integer accumulator as long as the significant digit
    counter is not 0\. If the significant digit counter is greater than 0, decrement
    it. Also decrement the exponent value.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 13.  If the algorithm hasn’t encountered at least one decimal digit by this
    point, report an illegal character exception and return.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 14.  If the current character is not e or E, go to step 20\. Otherwise, skip
    over the e or E character and continue with step 15\. (Note that some string formats
    also allow d or D to denote a double-precision value. You can also choose to allow
    this, and possibly check the range of the value if the algorithm encounters e
    or E versus d or D.)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 15.  If the next character is + or -, skip over it. Set a flag to true if the
    sign character is -; set it to false otherwise (note that this exponent sign flag
    is different from the mantissa sign flag set earlier in this algorithm).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 16.  If the next character is not a decimal digit, report an error.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 17.  Convert the string of digits starting with the current decimal digit character
    to an integer.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 18.  Add the converted integer to the exponent value that was initialized to
    –16 at the start of this algorithm.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 19.  If the exponent value is outside the range –324 to +308, report an out-of-range
    exception.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 20.  Convert the mantissa, which is currently an integer, to a floating-point
    value.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 21.  Take the absolute value of the exponent, preserving the exponent’s sign.
    This value will be 9 bits or less.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 22.  If the exponent was positive, then for each set bit in the exponent, multiply
    the current mantissa value by 10 raised to the power specified by that bit’s position.
    For example, if bits 4, 2, and 1 are set, multiply the mantissa value by 10^(16),
    10⁴, and 10².
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 23.  If the exponent was negative, then for each set bit in the exponent, divide
    the current mantissa value by 10 raised to the power specified by that bit’s position.
    For example, if bits 4, 3, and 2 are set, divide the mantissa value by 10^(16),
    10⁸, and 10⁴ (starting with the larger values and working your way down).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 24.  If the mantissa is negative (the first sign flag set at the beginning of
    the algorithm), negate the floating-point number.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-17 provides an implementation of this algorithm, explained section
    by section. The first part is typical for the sample programs in this book, containing
    some constant declarations, static data, and the getTitle function.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The read-only section contains various test strings that this program will convert
    into floating-point values ❶. These test strings were carefully chosen to test
    most of the (successful) paths through the strToR64 function. To reduce the size
    of the main program, Listing 9-17 processes these strings in a loop. The array
    of pointers ❷ points at each of the test strings, with a NULL pointer (0) marking
    the end of the list. The main program will iterate through these pointers in a
    loop to test the input strings.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'The PotTbl (powers-of-10 table) array ❸ contains various powers of 10\. The
    strToR64 function uses this table to convert a decimal exponent (in integer format)
    to an appropriate power of 10:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The strToR64 function uses #define statements ❶ to create meaningful, more
    readable names for the local variables it maintains in various registers.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Although this function uses only registers X0 through X7 and D1 (which are all
    volatile in the ARM ABI), this function preserves all the registers it modifies
    ❷. In assembly language, it’s always good programming style to preserve modified
    registers. This code does not preserve X0 (assuming a successful conversion) because
    it returns X0 pointing at the end of the (successfully) converted string as a
    function result. Note that this code returns the main function result in D0.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'After function initialization, the strToR64 function begins by skipping all
    whitespace (spaces and tabs) at the beginning of the string:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code exits with ch (W6) containing the first non-whitespace character and
    X0 pointing at that character in memory.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after any whitespace characters, the string may optionally contain
    a single + or -character. This code skips either of these characters (if present)
    and sets the mantissa sign flag (sign) to 1 if a - character is present:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Immediately after a sign character (or if there isn’t an optional sign character),
    the string must contain a decimal digit character or a decimal point. This code
    tests for one of these two conditions and reports a conversion error if the condition
    fails:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This code uses a common trick to compare for a character in the range '0' through
    '9'. It subtracts the ASCII code for '0' from the character ❶. If the character
    was in the range '0' to '9', this translates its value to the range 0 to 9\. A
    single *unsigned* comparison against the value 9 tells us whether the character
    value was in the range '0' to '9'. If so, this code transfers control to the code
    that will process digits to the left of the decimal point.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the code has subtracted ''0'' from the character’s ASCII code, it cannot
    simply compare the character against a period. The cmp ch, #''.''-''0'' instruction
    correctly compares the character against a period by subtracting the character
    code for ''0'' from ''.'' ❷. If the character was a period, the code will verify
    that the following character is also a digit ❸.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the code starting at scanDigits processes the mantissa digits to the
    left of the decimal point (if present):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code skips over leading 0s by noting that if the mantissa value is 0 and
    the current character is '0', it’s a leading 0 ❶. For each mantissa digit the
    code fetches, it adjusts the mantissa value by multiplying the mantissa by 10
    and adding in the numeric equivalent of the digit ❹. However, if the loop processes
    more than 16 significant digits ❸, it does not add in the character to the mant
    accumulator (because double-precision objects support a maximum of 16 significant
    digits). If the input string exceeds 16 significant digits, the code increments
    the fpExp variable ❷ to track the eventual exponent of the number. The code undoes
    this increment ❺ if the mantissa was multiplied by 10 (in which case the exponent
    does not need to be incremented).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section of code handles the digits after a decimal point:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The code is similar to the digits to the left, except that it decrements the
    running exponent value for each digit ❷. This is because the mantissa is being
    maintained as an integer, and the code continues to insert the fractional digits
    into the mantissa by multiplying by 10 and adding in the digit’s value. Should
    the total number of significant digits exceed 16 (not including leading 0s ❶),
    this function ignores any further digits.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is processing the string’s optional exponent:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This code first checks for an e or E character denoting the start of an exponent
    ❶. If the string has an exponent, the code checks for an optional sign character
    ❷. If a - character is present, the code sets expSign to 1 (default is 0) to specify
    a negative exponent.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: After processing the exponent sign, the code expects decimal digits ❸ and converts
    these digits to an integer (held in the expAcc variable). If expSign is true (nonzero),
    the code negates the value in expAcc ❹. The exponent code then adds expAcc to
    the exponent value obtained when processing the mantissa digits to obtain the
    actual exponent value ❺.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code checks the exponent to verify it’s in the range –324 to +308
    ❻. This is the maximum dynamic range of a 64-bit double-precision floating-point
    value. If the exponent is out of this range, the code returns a value-out-of-range
    error.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the code has completely processed the string data, and the X0
    register points at the first byte in memory that is not part of the floating-point
    value. To convert the mantissa and exponent values from integers into a double-precision
    value, first convert the mantissa value (in mant) to a floating-point value by
    using the ucvtf instruction ❼.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, processing the exponent is somewhat tricky. The fpExp variable contains
    the decimal exponent, but this is an integer value representing a power of 10\.
    You must multiply the value in D0 (the mantissa) by 10*^(fpExp)*, but unfortunately,
    the ARM instruction set does not provide an instruction that computes 10 raised
    to some integer power. You’ll have to write your own code to do this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This code uses two nearly identical sections of code to handle negative ❶ and
    positive ❸ exponents. The difference between the two pieces of code is the choice
    of an fdiv instruction (for negative exponents) or an fmul instruction (for positive
    exponents). Each section contains a loop ❷ that steps through each entry of the
    PotTbl (powers-of-10) table. The exponent is a 9-bit value, as the maximum unsigned
    exponent value is 324, which fits in 9 bits or fewer.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: For each set bit in this integer, the code must multiply the floating-point
    result by the corresponding power of 10 from PotTbl. For example, if bit 9 is
    set, multiply or divide the mantissa by 10^(256) (the first entry in PotTbl);
    if bit 8 is set, multiply or divide the mantissa by 10^(128) (the second entry
    in PotTbl), ...; if bit 0 is set, multiply or divide the mantissa by 10⁰ (the
    last entry in PotTbl). The two loops in the code accomplish this by moving the
    9 bits into the HO positions of fpExp, then shifting the bits out one at a time
    and doing the multiplication (for positive exponents) or division (for negative
    exponents) if the carry flag is set, using successive entries from PotTbl.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the code negates the value if it was negative (the flag is held in the
    sign variable) and returns the floating-point value to the caller in the D0 register:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: On a successful conversion, this function returns X0 pointing at the first character
    beyond the floating-point string. This code does not restore X0 to its original
    value on a successful conversion.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the strToR64 function is the error-handling code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each error returns a special error code in X1\. So this code does not restore
    X1 upon return. Unlike the successful return, the error return code will restore
    X0 to its original value.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the asmMain function consists of a loop that processes each of the
    strings by using the pointers found in the values array. It simply steps through
    each pointer, passing it along to strToR64, until it encounters a NULL (0) value:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here’s the build command and sample output for Listing 9-17:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It would be interesting to modify the real-to-string and string-to-real programs
    to perform a “round-trip” conversion from real to string to real, to see whether
    you get roughly the same result back that you put in. (Because of rounding and
    truncation errors, you won’t always get the same exact value back, but it should
    be close.) I will leave it up to you to try this out.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Other Numeric Conversions
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter has presented the more common numeric conversion algorithms: decimal
    integer, hexadecimal integer, and floating-point. Other conversions are sometimes
    useful. For example, some applications might need octal (base-8) conversions or
    conversions in an arbitrary base. For bases 2 through 9, the algorithm is virtually
    the same as for decimal integer conversions, except that rather than dividing
    by 10 (and taking the remainder), you divide by the desired base. Indeed, it would
    be fairly simple to write a generic function to which you pass the radix (base)
    to get the appropriate conversion.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Of course, base-2 output is nearly trivial because the ARM CPU stores values
    internally in binary. All you need do is shift bits out of the number (into the
    carry flag) and output a 0 or 1 based on the state of the carry. Base-4 and base-8
    conversions are also fairly simple, working with groups of 2 or 3 bits (respectively).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Some floating-point formats do not follow the IEEE standard. To handle these
    cases, write a function that converts such formats to the IEEE form, if possible,
    then use the examples from this chapter to convert between floating-point and
    string. If you need to work with such formats directly, the algorithms in this
    chapter should prove sufficiently general and easy to modify for your use.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 9.5 Moving On
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This long chapter covered two main topics: converting numeric values to strings
    and converting strings to numeric values. For the former, this chapter covered
    numeric-to-hexadecimal conversion (bytes, hwords, words, dwords, and qwords),
    numeric-to-unsigned decimal conversion (64- and 128-bit), and numeric-to-signed
    decimal conversion (64- and 128-bit). It also discussed formatted conversion for
    controlling the output format when doing numeric-to-string conversions, and formatted
    floating-point-to-string conversions for decimal and exponential formats, as well
    as computing the number of print positions a conversion requires.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: While discussing string-to-numeric conversions, this chapter covered converting
    unsigned decimal strings to numeric forms, signed decimal strings to numeric forms,
    hexadecimal strings to numeric forms, and floating-point strings to double-precision
    numeric forms. Finally, the chapter briefly discussed other possible numeric output
    formats.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Although this book will continue to use the C printf() function for formatted
    output, you can use the procedures in this chapter to avoid relying on C when
    writing your own assembly code. These procedures also form the basis for an assembly
    language library you can use to simplify writing assembly code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 For More Information
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Donald Knuth’s *The Art of Computer Programming, Volume 2: Seminumerical Algorithms*,
    3rd edition (Addison-Wesley Professional, 1997) contains lots of useful information
    about decimal arithmetic and extended-precision arithmetic, though the text is
    generic and doesn’t describe how to do this in ARM assembly language.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on division via multiplication by a reciprocal, see the
    University of Iowa tutorial at *[http://<wbr>homepage<wbr>.cs<wbr>.uiowa<wbr>.edu<wbr>/~jones<wbr>/bcd<wbr>/divide<wbr>.html](http://homepage.cs.uiowa.edu/~jones/bcd/divide.html)*.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
