- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 9 NUMERIC CONVERSION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses basic conversions between various numeric formats, including
    integer to decimal string, integer to hexadecimal string, floating-point to string,
    hexadecimal string to integer, decimal string to integer, and real string to floating-point.
    It also covers error handling for string-to-numeric conversions, as well as performance
    enhancements. Finally, it introduces standard-precision conversions (for 8-, 16-,
    32-, and 64-bit integer formats) and extended-precision conversions (for example,
    128-bit integer/string conversions).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll begin to solve problems directly in assembly language,
    rather than translating a solution from an HLL as you did in previous chapters.
    Some examples here first present code that solves a problem with an HLL-based
    solution, then provide an optimized assembly language solution. This should help
    you learn to solve assembly language problems without relying on HLLs, thereby
    producing higher-quality programs.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Converting Numeric Strings to Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point, this book has relied on the C stdlib to perform numeric I/O
    (writing numeric data to the display and reading numeric data from the user).
    However, the library doesn’t provide extended-precision numeric I/O facilities
    (and even 64-bit numeric I/O is questionable; this book has been using a GCC extension
    to printf() to do 64-bit numeric output). Therefore, it’s time to break down how
    to do numeric I/O in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: Because most OSes support only character or string input and output, you won’t
    actually do numeric I/O. Instead, you’ll write functions that convert between
    numeric values and strings, then do string I/O. The examples in this section work
    with 64-bit (non-extended-precision) and 128-bit values, but the algorithms are
    general and extend to any number of bits.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.1 Numeric Values to Hexadecimal Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, you’ll learn to convert numeric values (bytes, half words,
    words, double words, and so on) to a character string containing the equivalent
    hexadecimal characters for the value. To begin, you need a function that converts
    a 4-bit nibble into a single ASCII character in the range ''0'' to ''9'' or ''A''
    to ''F''. In an HLL such as C, you could write this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can convert any numeric value in the range 0 to 9 to its corresponding ASCII
    character by ORing the numeric value with '0' (0x30). Unfortunately, this maps
    numeric values in the range 0xA through 0xF to 0x3A through 0x3F, so the C code
    checks to see if it produces a value greater than 0x3A and adds 7 ('A' – '9' –
    1) to produce a final character code in the range 0x41 to 0x46 ('A' through 'F').
  prefs: []
  type: TYPE_NORMAL
- en: With a function that converts a nibble to the appropriate ASCII character, you
    can convert bytes, half words, and so on by taking all the nibbles in the number
    and calling the function on each one to produce the corresponding output character.
    However, because ARM assembly language programs generally deal with objects no
    smaller than a byte, it’s more straightforward and efficient to write a function
    that converts a byte value to two ASCII characters. Let’s call this function btoh
    (byte to hex).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-1 shows a straightforward btoh implementation. This function expects
    a single-byte value in X1 (ignoring bits 8 to 63 in X1) and returns the two characters
    in bits 0 to 15 of X1\. Listing 9-1 converts a C algorithm into assembly language
    by using the techniques described in [Chapter 7](chapter7.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function returns the character corresponding to the HO nibble in bits 0
    through 7 ❶ and the character corresponding to the LO nibble in bits 8 through
    15 ❷. This is because you’ll generally use this function to build up character
    strings containing the converted hexadecimal value. Character strings are inherently
    *big-endian*, with the most significant digit appearing in the lowest memory address
    (so the number will be read from left to right when you print the string). Returning
    the two characters swapped in X1 allows you to store the two characters as a half-word
    value into memory by using a single instruction.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why btoh_simple passes the value to convert in X1 rather
    than X0 (the standard “first argument” location). This is in anticipation of functions
    that will output the characters to a memory buffer (string). For those string-based
    functions, X0 will contain the address of the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Listing 9-1 is basically hand-compiled C/C++ code, the performance
    will be about the same as (or worse than) the code produced by an optimizing C/C++
    compiler processing the C code given earlier. To write faster code in assembly
    language, you’ll first need to measure the performance of two functions to determine
    which one is faster. While you can do so with many software tools (performance
    analyzers, or *profilers*), I’ve employed a simple solution: write a main program
    that calls the function many times, then use the Unix time command line utility
    to measure the amount of time the program takes to run. Listing 9-2 shows such
    a program, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: An advanced software engineer might find several faults with this technique
    for measuring the executing time of some code. However, it is simple, is easy
    to understand and use, and doesn’t require any special software tools. While the
    measurements it produces are not perfect, it’s good enough for most purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output (using the Unix time command to
    time the running of the program):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: On my Mac mini M1, this took about 3.5 seconds to run. (Obviously, this will
    vary by system; for example, on a Raspberry Pi 3, it took about 37 seconds.)
  prefs: []
  type: TYPE_NORMAL
- en: As noted in [Chapter 7](chapter7.xhtml), branches tend to run slower than straight-line
    code. Listing 9-2 uses branches to handle cases when the converted character is
    '0' through '9' or 'A' through 'F'. I wrote a version using the csel instruction
    to differentiate these two cases after ORing or adding '0' to the nibble value.
    The code ran in 2.5 seconds (on a Mac mini M1). However, this was achieved by
    not preserving the X1 and X2 registers. Saving X1 and X2 to memory and restoring
    them increased the execution time to 4.68 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve just discovered a big time sink in ARM assembly code: accessing memory
    is very slow (and the ldp/stp instructions are much slower than the ldr/str instructions).
    This is why Arm defined nonvolatile registers, so you don’t have to preserve certain
    working registers in memory. Nevertheless, preserving volatile registers is sometimes
    worthwhile to ensure that programs are correct. Assembly language code can quickly
    become complex, and having a function stomp on registers you forgot to save in
    your calling code can lead to long debugging sessions. A fast program with defects
    is never as good as a slower program that works properly.'
  prefs: []
  type: TYPE_NORMAL
- en: When writing 32-bit ARM code for a Raspberry Pi 400 (for the second volume of
    this series), I discovered that using a 256-element lookup table (with each element
    containing the two characters corresponding to the hexadecimal value) was faster
    than the standard algorithm. When I tried that approach in 64-bit ARM assembly,
    the runtime was 4.6 seconds. Once again, memory accesses (at least on the Apple
    M1 CPU) are expensive. On a different system, such as a Pi 3, 4, or 5, you will
    get different results.
  prefs: []
  type: TYPE_NORMAL
- en: Once you can convert a single byte to a pair of hexadecimal characters, creating
    a string, output to the display is straightforward. We can call the btoh (byte
    to hex) function for each byte in the number and store the corresponding characters
    away in a string. With this function, you can write btoStr (byte to string), hwtoStr
    (half word to string), wtoStr (word to string), and dtoStr (double word to string)
    functions. This chapter expands several of the lower-level functions (btoStr,
    hwtoStr, and wtoStr) and uses procedure calls to the smaller functions for the
    larger-sized conversions (dtoStr). In [Chapter 13](chapter13.xhtml), I discuss
    macros that will provide another way to easily expand these functions.
  prefs: []
  type: TYPE_NORMAL
- en: The approach this book takes is to try to write fast conversion code. If you
    would prefer to save space rather than increase speed, see the following “Reducing
    Code Size” box for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the binary-to-hexadecimal string functions will accept two parameters:
    a value to convert in the X1 register, and a pointer to a string buffer to hold
    the string result in X0\. These functions will assume that the buffer is sufficiently
    large to hold the string result: btoStr requires a 3-character buffer, hwtoStr
    requires a 5-character buffer, wtoStr requires a 9-character buffer, and dtoStr
    requires a 17-character buffer. Each byte in the value requires two characters
    in the buffer. In addition to the character data, the buffer must also include
    1 byte for the zero-terminating byte. The caller is responsible for ensuring that
    the buffer is large enough.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement these four hexadecimal-to-string functions, I’ll start by writing
    four hexadecimal-to-buffer functions. There are two differences between the *tobuf
    and *tostr functions (where the * indicates a substitution of b, hw, w, or d,
    as per regular expression syntax):'
  prefs: []
  type: TYPE_NORMAL
- en: The *tobuf functions do not preserve any registers. They modify the values in
    X0 and X2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *tobuf functions leave X0 pointing at the zero-terminating byte at the end
    of the string, which is often useful; the *tostr functions preserve X0’s value
    (pointing at the first character of the output buffer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I will also take this opportunity to introduce another assembly language feature:
    multiple entry points to a function. The btobuf, htobuf, wtobuf, and dtobuf functions
    all contain common code. Listing 9-3 merges all these functions into a single
    function (dtobuf) with separate entry points into the code sequence for the other
    three functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The dtobuf function begins by processing the HO nibble (nibble 15) of the dword
    ❶. For performance reasons, this code uses an unrolled loop, processing each nibble
    individually. Each nibble uses the standard algorithm for converting a binary
    value to a hexadecimal character.
  prefs: []
  type: TYPE_NORMAL
- en: After this code processes the HO eight hex digits, you’ll notice an entry point
    for the wtobuf function ❷. Code calling wtobuf transfers control into the middle
    of the dtobuf function (literally). This works because dtobuf doesn’t push anything
    onto the stack or otherwise alter the environment that would require special work
    by wtobuf on entry. Likewise, entry points for htobuf ❸ and btobuf ❹ are at nibbles
    3 and 1, respectively. By merging these functions into a single section of code,
    you save all the code that would be used for wtobuf, htobuf, and btobuf.
  prefs: []
  type: TYPE_NORMAL
- en: I made several failed attempts at optimizing this code. First, I tried saving
    8 bytes in a register and wrote the data to memory a dword at a time rather than
    a byte at a time. This ran slower (on my Mac mini M1). I also tried eliminating
    branches in the code by using csel instructions. Surprisingly, that code ran slower
    too. I even tried using a ubfx instruction (see [Chapter 12](chapter12.xhtml)),
    which still ran slower than the code with branches. I timed these versions on
    a Mac mini M1 and a Raspberry Pi 400\. While the timings on the two machines varied
    greatly, the relative performance of the three algorithms remained the same (the
    branch version was always faster). Sometimes, getting clever with different algorithms
    can hurt you. That’s why you should always test the performance of your code (preferably
    on multiple architectures).
  prefs: []
  type: TYPE_NORMAL
- en: With the *tobuf functions out of the way, writing the *toStr functions is relatively
    easy. The *toStr functions simply call the *tobuf functions and preserve the registers
    that the *tobuf functions modify. Listing 9-4 provides the code for these functions
    (note that *Listing9-4.S*, from the online files, also includes the code for the
    dtobuf function; to avoid redundancy, I’ve removed that code from the listing).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As noted, I’ve pulled the dtobuf function out of this listing; insert that code
    ❶. The btoStr function ❷ saves the X0, X2, and LR registers on the stack (the
    registers that will be modified by calls to the *tobuf functions), calls the btobuf
    function to write the two hex digits to the buffer pointed at by X0, then restores
    the registers and returns. The code does largely the same for htoStr ❸, wtoStr
    ❹, and dtoStr ❺, the only difference being the conversion function they call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for the program in Listing 9-4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As the assembly code appearing in this book calls C/C++ standard library functions
    for I/O, these binary-to-hexadecimal-string functions will all produce zero-terminated
    C-compatible strings. They are easy enough to modify to produce other string formats,
    if need be. See [Chapter 14](chapter14.xhtml) for more on string functions.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.2 Extended-Precision Hexadecimal Values to Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Extended-precision hexadecimal-to-string conversion is easy: it’s simply an
    extension of the normal hexadecimal conversion routines from the previous section.
    For example, Listing 9-5 is a 128-bit hexadecimal conversion function, qtoStr,
    which expects a pointer to a 128-bit value in X2:X1 and a pointer to a buffer
    in X0\. *Listing9-5.S* is largely based on *Listing9-4.S*; to avoid redundancy,
    I’ve included just the qtoStr function here.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The function in Listing 9-5 calls dtobuf twice to convert the 128-bit qword
    value to a string by converting first the HO dword, then the LO dword, and concatenating
    their results. To extend this conversion to any number of bytes, simply convert
    the HO bytes down to the LO bytes of the large object.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.3 Unsigned Decimal Values to Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Decimal output is a little more complicated than hexadecimal output because,
    unlike for hexadecimal values, the HO bits of a binary number affect the LO digits
    of the decimal representation. Therefore, you must create the decimal representation
    for a binary number by extracting one decimal digit at a time from the number.
  prefs: []
  type: TYPE_NORMAL
- en: The most common solution for unsigned decimal output is to successively divide
    the value by 10 until the result becomes 0\. The remainder after the first division
    is a value in the range 0 to 9, which corresponds to the LO digit of the decimal
    number. Successive divisions by 10 (and their corresponding remainder) extract
    successive digits from the number.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative solutions to this problem generally allocate storage for a string
    of characters large enough to hold the entire number. The code then extracts the
    decimal digits in a loop and places them in the string one by one. At the end
    of the conversion process, the routine prints the characters in the string in
    reverse order (remember, the divide algorithm extracts the LO digits first and
    the HO digits last, the opposite of the way you need to print them).
  prefs: []
  type: TYPE_NORMAL
- en: 'This section employs a *recursive solution* because it is a little more elegant.
    This solution begins by dividing the value by 10 and saving the remainder in a
    local variable. If the quotient is not 0, the routine recursively calls itself
    to output any leading digits first. On return from the recursive call (which outputs
    all the leading digits), the recursive algorithm outputs the digit associated
    with the remainder to complete the operation. For example, here’s how the operation
    works when printing the decimal value 789:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Divide 789 by 10\. The quotient is 78, and the remainder is 9.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Save the remainder (9) in a local variable and recursively call the routine
    with the quotient.
  prefs: []
  type: TYPE_NORMAL
- en: '3.  Recursive entry 1: divide 78 by 10\. The quotient is 7, and the remainder
    is 8.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Save the remainder (8) in a local variable and recursively call the routine
    with the quotient.
  prefs: []
  type: TYPE_NORMAL
- en: '5.  Recursive entry 2: divide 7 by 10\. The quotient is 0, and the remainder
    is 7.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Save the remainder (7) in a local variable. Because the quotient is 0, don’t
    call the routine recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Output the remainder value saved in the local variable (7). Return to the
    caller (recursive entry 1).
  prefs: []
  type: TYPE_NORMAL
- en: '8.  Return to recursive entry 1: output the remainder value saved in the local
    variable in recursive entry 1 (8). Return to the caller (original invocation of
    the procedure).'
  prefs: []
  type: TYPE_NORMAL
- en: '9.  Original invocation: output the remainder value saved in the local variable
    in the original call (9). Return to the original caller of the output routine.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-6 provides an implementation of this recursive algorithm for 64-bit
    unsigned integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The u64toStr function ❶ is a facade that preserves the registers while calling
    the u64ToBuf procedure. The u64ToBuf function ❷ handles the special case when
    X1 contains 0 (the recursive code terminates when the result is 0). If X1 is 0
    upon entry, this code immediately writes a '0' character to the output buffer,
    increments X0, and returns. If X1 is nonzero, it transfers control to the recursive
    u64toBufRec function ❸ to process the value. For performance reasons, u64ToBufRec
    preserves only X2 (which contains the remainder value on recursive calls) and
    LR.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive function computes the quotient and remainder ❹. The quotient
    is left in X3, and the remainder is in X2\. If the quotient was nonzero, there
    are still more HO digits to process: copy the quotient into X1 and make the recursive
    call to u64toBufRec ❺. On the return from the recursive call ❻ (or if the recursive
    call was skipped), all HO digits have been emitted to the buffer, so convert the
    current digit to a character and add it to the end of the buffer. Note that the
    post-increment addressing mode automatically increments X0 to point at the zero-terminated
    byte emitted by the strh instruction. The code restores the value in X2 ❼, in
    the event that this was a recursive call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for Listing 9-6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Unlike hexadecimal output, there’s no need to provide a byte-size, hword-size,
    or word-size numeric-to-decimal-string conversion function. Simply zero-extending
    the smaller values to 64 bits is sufficient. Unlike the hexadecimal conversions,
    no leading zeros are emitted by the u64toStr function, so the output is the same
    for all sizes of variables (64 bits and smaller).
  prefs: []
  type: TYPE_NORMAL
- en: This code has several opportunities for optimization. Since decimal-to-string
    conversions are common (most program output uses this function) and the algorithm
    is not as fast as hexadecimal conversion, optimizing this code is probably worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy enough to get rid of the recursion and do an iterative version of
    u64toStr. This eliminates the need to preserve the registers and return address
    on multiple recursive calls (typically, one recursive call for each digit converted)
    and having to build the activation record on each call. Listing 9-7 takes this
    one step further, unraveling the loop (up to 20 iterations, one for each possible
    digit).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The u64ToBuf function ❶ is a variant of u64ToStr that doesn’t preserve any registers.
    It stomps on X0 through X7, and the caller is responsible for saving any registers
    it needs preserved.
  prefs: []
  type: TYPE_NORMAL
- en: This function initializes X4 with the constant 10 ❷, because each digit conversion
    will divide and multiply by this constant, which must be in a register. Reserving
    X4 for this constant spares the code from having to reload the constant all the
    time. This code zeros out X5, X6, and X7, which will hold the characters of the
    converted string; this also initializes the zero-terminating byte (which can be
    in various locations in these registers, depending on the number of output digits).
  prefs: []
  type: TYPE_NORMAL
- en: The function converts the binary number to a string of digits by using the same
    basic “divide and remainder” algorithm as did the program in Listing 9-6 ❸. The
    function divides the value by 10; the remainder is a value in the range 0 to 9
    that the function converts to the corresponding ASCII character. The code shifts
    the converted digit into its final output position in the X5, X6, or X7 register.
    Digits 1 through 6, the HO digits, wind up in X5; digits 7 through 14 in X6; and
    digits 15 through 20 in X7\. Zero bytes fill in all the unused digit positions.
    For example, if the number has only three digits, X6 and X7 will contain 0, and
    bits 24 through 63 in X5 will all contain 0.
  prefs: []
  type: TYPE_NORMAL
- en: A separate sequence of divide/remainder instructions is used for each possible
    output digit in the conversion (hence the name *expanded/straight-line code*)
    ❹. The sequence is roughly the same for each digit conversion, though two variants
    alternate between the value in X1 and X2, as the quotient from the division becomes
    the value to divide in the next step. Whenever the quotient becomes 0, the conversion
    is complete, and control transfers to a different location to write the converted
    digits to the buffer. Only a single branch in the function will be taken, as these
    branches fall through to the next instruction sequence until the conversion is
    complete. Additionally, these digit conversion sequences may place the converted
    digit into a different output register based on the digit’s final position.
  prefs: []
  type: TYPE_NORMAL
- en: If the code falls all the way through to digit 20, there is no test for a 0
    result; the quotient will always be 0 at that point, so the function simply stores
    away the digits into the buffer and returns ❺.
  prefs: []
  type: TYPE_NORMAL
- en: If the number has six digits or fewer, the function writes the characters in
    X5 to the buffer ❻. X5 will always contain the LO digits of the number. By placing
    a maximum of six characters in X5, the HO 2 bytes of X5 will always be 0 (and
    provide the zero-terminating byte for larger strings). For numbers with fewer
    than six digits, the code must explicitly write a zero-terminating byte to the
    buffer. For values with 7 to 14 digits, the function writes out registers X6 and
    X5 (in that order) to the buffer ❼. X5 provides the zero-terminating byte, so
    the code doesn’t need to explicitly write any 0 bytes. For values with 15 or more
    digits, the code writes out the data in registers X7, X6, and X5 (X5 provides
    the zero-terminating byte) ❽.
  prefs: []
  type: TYPE_NORMAL
- en: The actual u64ToStr function ❾ is a short facade that preserves all the register
    values across a call to u64ToBuf. By breaking u64ToStr into these two functions,
    it is possible to call u64ToBuf directly if you want to leave X0 pointing at the
    end of the string (though you must preserve X1 through X7 if necessary). Also,
    putting the register preservation code in u64ToStr allows the u64ToBuf code to
    avoid restoring registers before all the ret instructions (or avoid yet another
    branch to code that handles restoring the registers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output from Listing 9-7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I modified both versions of u64toStr in order to time their execution. For
    the recursive version, I got the following timing on my Mac mini:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For the straight-line code, the runtime was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The latter code ran about 2.3 times faster than the recursive version, a big
    win.
  prefs: []
  type: TYPE_NORMAL
- en: I also created a version of u64ToStr that first counted the number of output
    digits (using a binary search), then branched to the appropriate code to convert
    exactly that many digits. Alas, the code ran slightly slower than Listing 9-7\.
    I also tried a variant that emitted the HO digits first (dividing by 1e+19, the
    successively lower values by 10). It was a little faster than the digit count
    version, and a little slower than Listing 9-7\. I’ve included the source code
    for both experiments in the online files for your perusal.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.4 Signed Integer Values to Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To convert a signed integer value to a string, first check whether the number
    is negative. If it is, emit a hyphen (-) character and negate the value, then
    call the u64toStr function to finish the job. Listing 9-8 shows the relevant code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9-8 shows only the i64ToStr function (the rest of the program is taken
    from Listing 9-7). The full source code is available online.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.5 Extended-Precision Unsigned Integers to Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The only operation in the entire string-conversion algorithm that requires extended-precision
    arithmetic is the divide-by-10 operation. Listing 9-9 implements a 128-bit decimal
    output routine utilizing this technique. I modified the div128 algorithm from
    [Chapter 8](chapter8.xhtml) to do an explicit divide-by-10 operation (speeding
    div128 up a little) and modified the recursive conversion routine from Listing
    9-6 to perform the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code includes an optimized version of the 128-bit division function that
    divides a number by 10 ❶. This is followed by the nonrecursive entry point for
    u128toStr, which handles 0 as a special case and calls the recursive version for
    all other values ❷, and the recursive code for u128toStr ❸. As these functions
    are nearly identical to the recursive 64-bit string output functions, refer to
    that code (in Listing 9-6) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: One issue with the u128toStr function is that it is much slower than the other
    numeric-to-string functions. This is all due to the performance of the div10 subroutine.
    Because the 128-bit divide-by-10 algorithm is so slow, I won’t bother improving
    the performance of the u128toStr conversion function. Unless you can come up with
    a very high-performance div10 subroutine (perhaps using multiplication by a reciprocal;
    see section 9.6, “For More Information,” on [page 603](chapter9.xhtml#pg_603)),
    trying to optimize u128toStr is probably a waste of time. Fortunately, this function
    likely won’t be called often, so its performance won’t matter much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output from Listing 9-9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I will leave it to you to create a 128-bit signed-integer conversion function,
    since the code is almost identical to i64toStr (see Listing 9-8); you just have
    to supply 128-bit negation and comparison operations. As a hint, for the comparison,
    just check the HO dword to see if the sign bit is set.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 9.1.6 Formatted Conversions'
  prefs: []
  type: TYPE_NORMAL
- en: The code in the previous sections converted signed and unsigned integers to
    strings by using the minimum number of necessary character positions. To create
    nicely formatted tables of values, you will need to write functions that provide
    appropriate padding in front of the string of digits before actually emitting
    the digits. Once you have the “unformatted” versions of these routines, implementing
    the formatted versions is easy.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to write iSize and uSize routines that compute the minimum
    number of character positions needed to display the value. One algorithm to accomplish
    this is similar to the numeric string conversion routines. The only difference
    is that you initialize a counter to 0 upon entry into the routine and increment
    this counter rather than outputting a digit on each recursive call. (Don’t forget
    to increment the counter inside iSize if the number is negative; you must allow
    for the output of the minus sign.) After the calculation is complete, these routines
    should return the size of the operand in the X0 register.
  prefs: []
  type: TYPE_NORMAL
- en: However, thanks to its use of recursion and division, such a conversion scheme
    is slow. A brute-force conversion using a binary search is shown in Listing 9-10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The actual u64Size function ❶ uses a binary search algorithm to quickly scan
    through all the possible values to determine the digit count. It begins by dividing
    the search space in half, by comparing the input value (moved to X2) against a
    10-digit value ❷. In the usual binary search fashion, the two sections of code
    will test for numbers with 1 to 9 digits and 10 to 20 digits. In each of those
    ranges, the search is (roughly) broken into halves again and again until the algorithm
    zeros in on the exact number of digits. When the code gets down to 2 to 4 digits,
    it uses some straight-line code and a series of cinc instructions to rapidly handle
    the last few cases without executing a branch ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For signed integers, add the function in Listing 9-11 to the code in Listing
    9-10 (find a full Listing 9-11 in the book’s downloadable code files at *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For extended-precision size operations, the binary search approach quickly becomes
    unwieldy (64 bits is bad enough). The best solution is to divide your extended-precision
    value by a power of 10 (say, 1e+16). This will reduce the size of the number by
    16 digits. Repeat this process as long as the quotient is greater than 64 bits,
    keeping track of the number of times you’ve divided the number by 1e+16\. When
    the quotient fits into 64 bits (19 or 20 digits), call the 64-bit u64Size function
    and add in the number of digits you eliminated with the division operation (16
    for each division by 1e+16). I’ll leave this implementation to you.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the i64Size and u64Size routines, writing the formatted output
    routines u64toStrSize or i64toStrSize is easy. On initial entry, these routines
    call the corresponding i64Size/u64Size routine to determine the number of character
    positions for the number. If the value that the i64Size/u64Size routine returns
    is greater than or equal to the value of the minimum size parameter (passed into
    u64toStrSize or i64toStrSize), no other formatting is necessary. If the value
    of the parameter size is greater than the value i64Size/u64Size returns, the program
    must compute the difference between these two values and emit that many spaces
    (or other filler characters) to the output string before the numeric conversion
    (assuming right-justification of the value, which is what this chapter presents).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-12 shows the utoStrSize/itoStrSize functions (full source code appears
    online); here, I omit everything but the utoStrSize/itoStrSize functions themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The u64toStrSize function ❶ simply loads up X25 and X26 with appropriate addresses
    and branches to the generic toSizeStr function to handle the real work. The i64ToStrSize
    function ❷ does the same thing for signed integer conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The toSizeStr function ❸ handles the real work. First, it calls the appropriate
    toSize function (whose address was passed in X25) to compute the minimum number
    of print positions the value will require ❹. It then computes the number of fill
    characters required in front of the digits to right-justify the number in the
    output field ❺. It emits the required number of filler characters ❻ before outputting
    the numeric string ❼. Probably the only thing worth noting here is that the code
    attempts to output eight spaces at a time in order to improve performance, as
    long as there are at least eight padding characters, then four, then two, and
    finally one.
  prefs: []
  type: TYPE_NORMAL
- en: The printSize procedure ❽ is a little utility function that the asmMain procedure
    uses to display values, and the asmMain procedure ❾ tests the u64ToStrSize and
    i64ToStrSize procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for Listing 9-12 (remember that
    the actual main program appears only in the online source code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is value:size=''conversion''.  ### 9.2 Converting Floating-Point
    Values to Strings'
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, this chapter has dealt with converting integer numeric values to character
    strings (typically for output to the user). This section discusses converting
    floating-point values to a string, which is just as important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting floating-point values to strings can take one of two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Decimal notation conversion (such as ±xxx.yyy format)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exponential (or scientific) notation conversion (such as ±x.yyyyye±zz format)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regardless of the final output format, you’ll need two distinct operations to
    convert a value in floating-point form to a character string. First, you must
    convert the mantissa to an appropriate string of digits. Second, you convert the
    exponent to a string of digits.
  prefs: []
  type: TYPE_NORMAL
- en: However, this isn’t a simple case of converting two integer values to a decimal
    string and concatenating them (with an *e* between the mantissa and exponent).
    First of all, the mantissa is not an integer value; it is a fixed-point fractional
    binary value. Simply treating it as an *n*-bit binary value (where *n* is the
    number of mantissa bits) will almost always result in an incorrect conversion.
    Second, while the exponent is, more or less, an integer value, it represents a
    power of 2, not a power of 10\. Displaying that power of 2 as an integer value
    is not appropriate for decimal floating-point representation. These two issues
    (fractional mantissa and binary exponent) are the source of the major complications
    associated with converting a floating-point value to a string.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The exponent is actually a biased-exponent value. However, that’s easy to
    convert to a signed binary integer.*'
  prefs: []
  type: TYPE_NORMAL
- en: Double-precision floating-point values have a 53-bit mantissa (including the
    implied bit). This is not a 53-bit integer. Instead, those 53 bits represent a
    value from 1.0 to slightly less than 2.0\. (See section 2.13, “IEEE Floating-Point
    Formats,” on [page 93](chapter2.xhtml#pg_93) for more details on the IEEE 64-bit
    floating-point format.) The double-precision format can represent numbers from
    0 to about 5 × 10^(–324) (around ±1 × 10^(±308) using normalized values).
  prefs: []
  type: TYPE_NORMAL
- en: To output the mantissa in decimal form with approximately 16 digits of precision,
    successively multiply or divide the floating-point value by 10 until the number
    is from 1e+15 to just less than 1e+16 (that is, 9.9999 ... e+15). Once the exponent
    is in the appropriate range, the mantissa bits form a 16-digit integer value (no
    fractional part), which can be converted to a decimal string to obtain the 16
    digits that make up the mantissa value.
  prefs: []
  type: TYPE_NORMAL
- en: To convert the exponent to an appropriate decimal string, track the number of
    multiplications or divisions by 10\. For each division by 10, add 1 to the decimal
    exponent value; for each multiplication by 10, subtract 1 from the decimal exponent
    value. At the end of the process, subtract 16 from the decimal exponent value
    (as this process produces a value whose exponent is 16) and convert the decimal
    exponent value to a string.
  prefs: []
  type: TYPE_NORMAL
- en: The conversions in the following sections assume that you always want to produce
    a mantissa with 16 significant digits. To produce formatted output with fewer
    significant digits, see section 9.2.4, “Double-Precision Values to Strings,” on
    the next page.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.1 Floating-Point Exponent to String of Decimal Digits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To convert the exponent to a string of decimal digits, use the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  If the number is 0.0, directly produce the mantissa output string of "0000000000000000"
    (notice the space at the beginning of the string), set the exponent to 0, and
    you’re done. Otherwise, continue with the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Initialize the decimal exponent to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  If the exponent is negative, emit a hyphen (-) character and negate the
    value; if it is positive, emit a space character.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  If the value of the (possibly negated) exponent is less than 1.0, skip to
    step 8.
  prefs: []
  type: TYPE_NORMAL
- en: '5.  Positive exponents: Compare the number against successively smaller powers
    of 10, starting with 10 ^(+ 256), then 10 ^(+ 128), then 10 ^(+ 64), then ...,
    then 10⁰. After each comparison, if the current value is greater than the power
    of 10, divide by that power of 10 and add the power-of-10 exponent (256, 128,
    ..., 0) to the decimal exponent value.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Repeat step 5 until the exponent is 0 (that is, the value is in the range
    1.0 ≤ *value* < 10.0).
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Skip to step 10.
  prefs: []
  type: TYPE_NORMAL
- en: '8.  Negative exponents: Compare the number against successful larger powers
    of 10 starting with 10^(–256), then, 10^(–128), then 10^(–64), then ..., then
    10⁰. After each comparison, if the current value is less than the power of 10,
    divide by that power of 10 and subtract the power-of-10 exponent (256, 128, ...,
    0) from the decimal exponent value.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.  Repeat step 8 until the exponent is 0 (that is, the value is in the range
    1.0 ≤ *value* < 10.0).
  prefs: []
  type: TYPE_NORMAL
- en: 10.  At this point, the exponent value is a reasonable number that can be converted
    to an integer value by using standard unsigned-to-string conversions (see section
    9.1.3, “Unsigned Decimal Values to Strings,” on [page 495](chapter9.xhtml#pg_495)).
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2 Floating-Point Mantissa to String of Digits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To convert the mantissa to a string of digits, you can’t simply treat the 53-bit
    mantissa produced in the previous section as an integer value, since it still
    represents an integer from 1.0 to just less than 2.0\. However, if you multiply
    that floating-point value (which has been converted to a value from 1.0 to slightly
    less than 10.0) by 10^(+15), this effectively produces an integer with the digits
    shifted to the left 15 print positions (16 digits being the number of output digits
    possible with a double-precision value). You can then convert this “integer” to
    a string. The result will consist of the 16 mantissa digits. To convert the mantissa
    to a string, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Multiply the value produced by the exponent calculation in the previous
    section by 1e+15\. This produces a number with the decimal digits shifted to the
    left by 15 print positions.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Grab the 52-bit mantissa and OR in an implicit bit 52 equal to 1, and zero-extend
    this 53-bit value to 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Convert the resulting 64-bit value to a string by using the unsigned integer-to-string
    function given earlier in this chapter (see section 9.1.3, “Unsigned Decimal Values
    to Strings,” on [page 495](chapter9.xhtml#pg_495)).
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.3 Strings in Decimal and Exponential Format
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To produce a decimal string (rather than a number in exponential form), the
    remaining task is to properly place the decimal point into the string of digits.
    If the exponent is greater than or equal to 0, you need to insert the decimal
    point in position *exponent* + 1, starting from the first mantissa digit produced
    in the previous section. For example, if the mantissa conversion produced 1234567890123456
    and the exponent is 3, then you would insert a decimal point before the character
    at index 4 (3 + 1), yielding 1234.567890123456 as the result.
  prefs: []
  type: TYPE_NORMAL
- en: If the exponent is greater than 16, insert *exponent* – 16 zero characters at
    the end of the string (or return an error if you don’t want to allow conversions
    of values larger than 1e+16 to decimal form). If the exponent is less than 0,
    insert 0. followed by *abs*(*exp*) – 1 zero characters in front of the string
    of digits. If the exponent is less than –16 (or another arbitrary value), you
    might elect to return an error or automatically switch to exponential form.
  prefs: []
  type: TYPE_NORMAL
- en: Producing exponential output is slightly easier than decimal output. Always
    insert a decimal point between the first and second characters in the converted
    mantissa string and then follow the string with e±xxx, where ±xxx is the exponent
    value’s string conversion. For example, if the mantissa conversion produces 1234567890123456
    and the exponent is –3, the resulting string will be 1.234567890123456e-003 (note
    the leading 0s on the exponent digits).
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.4 Double-Precision Values to Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section presents the code that will convert a double-precision value to
    a string in either decimal or exponential form, with separate functions for the
    two output formats. As Listing 9-13 is rather long, I’ve broken it into pieces
    and annotated each section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As is typical for sample programs in this chapter, Listing 9-13 begins with
    a read-only data section ❶ containing the program’s title string and various format
    strings used by printf() calls in the main program. The single data variable in
    this program is r64str_1 ❷, a 32-byte character string used to hold the converted
    string. The program is responsible for ensuring that all conversions will fit
    into 32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-13 places several read-only constants in the .code section so the
    program can directly access these constants by using the PC-relative addressing
    mode (rather than using multiple instructions to take the address of the object
    and access it indirectly). The first such constant is tenTo15 ❸, which holds the
    value 1.0e+15\. The conversion code uses this constant to multiply a floating-point
    value in the range 1.0 to slightly less than 10.0 by 1e+15, thereby obtaining
    a value slightly less than 1e+16 when converting the mantissa to an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: The potPos, potNeg, and expTbl tables ❹ contain the positive and negative powers
    of 10 (*pot*) tables used to multiply the floating-point value by various powers
    of 10 when massaging the value into the range 1.0 to 10.0\. The expTbl contains
    the absolute value of the exponent corresponding to the same entry in the potPos
    and potNeg tables. The code adds or subtracts this value from the accumulated
    decimal exponent while converting the mantissa to the range 1.0 to 10.0.
  prefs: []
  type: TYPE_NORMAL
- en: The maxDigits manifest constant ❺ specifies the number of significant digits
    supported by this conversion code (16 digits for double-precision floating-point
    numbers). Finally, this code section contains the ubiquitous getTitle function
    ❻ that returns the address of the program’s title string to the C++ shell code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code converts a floating-point value to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The u53ToStr function ❶ is responsible for converting a 53-bit unsigned integer
    to a string of exactly 16 digits. In theory, this code could have used the u64toSizeStr
    function from Listing 9-12 to convert the 53-bit value (zero-extended to 64 bits)
    into a string. However, the conversion of floating-point mantissa to string always
    produces a 16-character string (with leading 0s, if necessary), so the decimal
    integer-to-string conversion can be more efficient than the u64toSizeStr function,
    which could produce variable-length strings. To prioritize saving space, if you’re
    already using the u64toSizeStr function in your code, you could remove u53ToStr
    and substitute a call to u64toSizeStr (specifying '0' as the fill character).
  prefs: []
  type: TYPE_NORMAL
- en: 'The conversion algorithm u53ToStr uses is straightforward and brute-force:
    it converts the LO eight digits to a sequence of eight characters and emits them
    ❷, then converts the HO eight digits to a sequence of eight characters and emits
    them ❸. It both cases, it uses the divide-by-10 and remainder of division-by-10
    algorithms to convert each digit to a character (see the discussion of u64ToStr
    in Listing 9-6 for more details).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is used by FPDigits to convert the mantissa to a string of decimal
    digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: FPDigits converts an arbitrary double-precision mantissa to a string of decimal
    digits. It assumes that the floating-point value to convert is held in the D0
    register and that X0 contains a pointer to the buffer that will hold the string
    conversion. This function also converts the binary (power-of-2) exponent to a
    decimal integer, returns the exponent value in the X1 register, and returns the
    value’s sign (a space character, indicating a nonnegative value, or -) in the
    X2 register.
  prefs: []
  type: TYPE_NORMAL
- en: FPDigits begins by first checking for the special case of 0.0 ❶. If D0 contains
    0, this function initializes the string buffer to 0000000000000000 (sixteen 0
    characters) and returns with X0 containing 0 and X2 containing a space character.
    The code checks for the special case of -0.0 and returns X2 containing a minus
    sign if the result is -0.0 ❷. Next, FPDigits checks the sign of the floating-point
    value and sets X2 to a '-', if appropriate ❸. The code also initializes the decimal
    exponent accumulator (held in X0) to 0.
  prefs: []
  type: TYPE_NORMAL
- en: After setting the sign, the FPDigits function checks the floating-point value’s
    exponent to see if it is positive or negative ❹. The code handles values with
    positive or negative exponents independently. If the exponent is negative, the
    cmpNegExp loop searches through the potNeg table looking for the value that is
    greater than the value in D0 ❺. When the loop finds such a value, it multiplies
    D0 by that entry in potNeg and then subtracts the corresponding entry in expTbl
    from the decimal exponent value held in X1\. The cmpNegExp loop repeats this process
    until the value in D0 is greater than 1.0\. Whenever the result isn’t greater
    than 1.0, the code multiplies the value in D0 by 10.0, because the code needs
    to adjust for the multiplication by 0.1 that has taken place. If, on the other
    hand, the exponent was positive ❻, the cmpPosExp loop does the same task but divides
    by entries in the potPos table and adds the corresponding entry in expTbl to the
    decimal exponent value held in X1.
  prefs: []
  type: TYPE_NORMAL
- en: Once the cmpPosExp or cmpNegExp loop gets the value into the range 1.0 to just
    less than 10.0, it multiplies the value by 10^(15) and converts it to an integer
    (in X22) ❼. Then FPDigits calls the u53toStr function to convert this integer
    to a string of exactly 16 digits. The function returns the sign character (space
    for nonnegative values, '-' for negative values) in X2 and the decimal exponent
    in X1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that FPDigits converts only the mantissa to a string of digits. This is
    the base code used by the r64ToStr and e64ToStr functions that convert floating-point
    values into recognizable strings. Before presenting those functions, there is
    one utility function to explain: chkNaNINF.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Certain floating-point operations produce invalid results. The IEEE 754 floating-point
    standard defines three special values to represent these invalid results: NaN
    (not a number), +INF (infinity), and -INF (negative infinity). Because the ARM
    floating-point hardware can produce these results, it is important that the conversions
    of floating-point to string handle these three special values. NaN, +INF, and
    -INF all have an exponent value containing 0x7FF (and no other valid values use
    this exponent). If the exponent is 0x7FF and the mantissa bits are all 0s, the
    value is +INF or -INF (determined by the sign bit). If the mantissa is nonzero,
    the value is NaN (and you can ignore the sign bit). The chkNaNINF function checks
    for these values and outputs the strings NaN, INF, or -INF if the number is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code moves the floating-point value in D0 into X0 and then checks the exponent
    bits to see if they contain 0x7FF ❶. If the exponent does not contain this value,
    the procedure returns to the caller (using the return address in LR).
  prefs: []
  type: TYPE_NORMAL
- en: If the exponent bits are 0x7FF, the code checks the mantissa to see if it is
    0 or nonzero ❷. If it’s nonzero, the code emits the character string NaN to the
    buffer pointed at by X22 ❸. If the mantissa is nonzero, the code checks whether
    the sign bit is set ❹. If not, this code emits INF to the output buffer. If the
    sign bit is set, the code emits -INF to the output buffer ❺.
  prefs: []
  type: TYPE_NORMAL
- en: In all three cases (NaN, INF, or -INF), the code transfers to fillSpecial ❻,
    where it adds sufficient padding characters (the padding character is in W21,
    and the field width is in X19). Rather than return to the caller, this code transfers
    control to the address held in X25 ❼. The caller (r64ToStr or e64ToStr) loads
    the invalid value return address into X25 prior to calling chkNaNINF. I could
    have set a flag, such as the carry flag, and tested it on return. However, I wanted
    to demonstrate another way to achieve this, and this approach is slightly more
    elegant (though arguably less readable).
  prefs: []
  type: TYPE_NORMAL
- en: 'With chkNaNINF out of the way, it’s time to take a look at the r64ToStr function
    that the user calls to convert floating-point values into strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The r64ToStr function converts the floating-point value in D0 to a string in
    standard decimal form, supporting output field widths, number of digits after
    the decimal point, and fill character for leading positions that would normally
    be blank.
  prefs: []
  type: TYPE_NORMAL
- en: After appropriate initialization, r64ToStr first checks for the values NaN (not
    a number), INF (infinity), and -INF (minus infinity) ❶; these values require special
    nonnumeric output strings, which must still be padded to fWidth characters. The
    r64ToStr calls FPDigits to convert the mantissa to a string of decimal digit characters
    (and obtain the power-of-10 exponent in integer form) ❷. The next step is to round
    the number based on the number of digits to appear after the decimal point ❸.
    This code computes the index into the string produced by FPDigits one character
    beyond the number of digits specified by the decDigits parameter. It fetches this
    character (which will be '0' through '9') and adds 5 to its ASCII code. If the
    result is greater than the ASCII code of '9', the code has to bump the previous
    digit in the string by 1\. Of course, if that character contains '9', overflow
    will occur and the carry has to ripple through to previous digit(s). If the carry
    ripples all the way to the first character of the string, the code must shift
    all the characters one position to the right and insert a '1' at the beginning
    of the string ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the code emits the characters associated with the final decimal string.
    The algorithm splits into two sections ❺, with one section handling positive (and
    0) exponents and the other handling negative exponents. For negative exponents,
    the code will emit any fill characters, the sign of the number (still held in
    X2), and the decDigits digits from the mantissa string conversion ❻. If the field
    width and decDigits are sufficiently large, the code will simply output the ''0''
    character for all characters beyond the 16th significant digit. If the number
    of output digits would exceed the field width the caller passes, the widthTooBig
    code ❼ will emit # characters to indicate a formatting error (the standard HLL
    approach to format errors in floating-point conversions).'
  prefs: []
  type: TYPE_NORMAL
- en: The code handles floating-point conversions of values greater than or equal
    to 1.0 (positive exponents) ❽. This code emits necessary padding characters and
    the value’s sign, then calculates the position of the decimal point in the output
    string and rounds the last digit throughout the string, as previously described.
    It then outputs the characters returned by FPDigits up to that position. Finally,
    it outputs the decimal point, followed by the remaining fractional digits. If
    it turns out that the code cannot fit the number into the field width (and decimal
    digits) specified, it transfers control to widthTooBig to produce the error string.
  prefs: []
  type: TYPE_NORMAL
- en: To notify the caller of possible errors, this code clears the carry flag upon
    return ❾ if the conversion was successful, or sets the carry flag on return if
    there was an error ❿. This allows the caller to easily test for success/ failure
    with a single bcs or bcc instruction after the call to r64ToStr.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final output format handled by Listing 9-13 is exponential (scientific)
    form. Two functions handle this conversion: expToBuf and e64ToStr. The former
    handles the formatting of the exponent portion of the output string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The expToBuf function produces a string of exactly one, two, or three digits
    (based on the parameters the caller passes in X0 and X1). The expToBuf function
    begins by verifying that the exponent digit count is within range ❶ and that the
    actual exponent will fit in the number of digits specified ❷. The code branches
    to three separate output conversion code sequences if the exponent output is three
    digits (the normal case ❸), one digit ❹, or two digits ❺. The code stores those
    characters into the buffer where X2 points ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function returns the error status in the carry flag, returning with the
    carry clear for a successful operation, or the carry set if the exponent is too
    large or the converted number will not fit in the number of character positions
    that X1 specifies. Other than this, expToBuf is basically a switch statement (implemented
    using if...then...else logic) that has three cases: one for each exponent size
    (one, two, or three characters).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The e64ToStr function handles the conversion from double-precision to string
    using exponential format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Converting the mantissa to a string is very similar to the routine in r64ToStr,
    though exponential form is a little easier, as the format always places the decimal
    point immediately after the first mantissa digit. As with r64ToStr, e64ToStr begins
    by checking the input parameters to see if they are valid ❶ (returning with the
    carry flag set and an error code in X0 if an error occurred). After parameter
    validation, the code checks for NaN or INF ❷. It then calls FPDigits to convert
    the mantissa to a string of digits ❸ (held in a local buffer). This call also
    returns the sign of the value as well as a decimal integer exponent.
  prefs: []
  type: TYPE_NORMAL
- en: 'After calculating the decimal exponent value, the e64ToStr function checks
    whether the converted value will fit into the space specified by the Width input
    parameter ❹. If the converted number would be too large, e64ToStr emits a string
    of # characters to denote an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this situation is not considered an error in the sense of returning
    the carry flag set. If the caller specifies an insufficient field width, the function
    still succeeds in creating a string conversion; that string just happens to be
    filled with # characters. The carry flag is set, on error, when e64ToStr cannot
    produce an output string.'
  prefs: []
  type: TYPE_NORMAL
- en: After verifying that the string will fit in the specified field width, the e64ToStr
    function rounds the result to the specified number of decimal digits ❺. This algorithm
    is identical to that used by r64ToStr. Next, the code outputs the mantissa digits
    ❻. Again, this is similar to the way r64ToStr works, except that the decimal point
    is always placed after the first digit (no need to calculate its position). Finally,
    the code emits e followed by the exponent’s sign character ❼ and then calls expToBuf
    to convert the exponent to a one-, two-, or three-digit character sequence (specified
    by the expDigs parameter the caller passes in X3).
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining code in Listing 9-13 provides utility functions used by the main
    program to display data (r64Print and e64Print), along with the asmMain procedure
    that demonstrates floating-point output using the functions in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that these functions preserve all the nonvolatile registers because printf()
    can modify them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The asmMain function is a typical demonstration program for the floating- point
    string-conversion functions. It calls the r64ToStr and e64ToStr functions with
    various input parameters to demonstrate the use of these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9-13 places the floating-point constant values in the code section rather
    than a read-only data section ❶, making it easier to modify them when looking
    at the main program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the build command and sample output for Listing 9-13:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This output demonstrates double-precision floating-point output. If you want
    to convert a single-precision value to a string, first convert the single-precision
    value to double-precision and use this code to translate the resulting double-precision
    value to a string.  ### 9.3 String-to-Numeric Conversions'
  prefs: []
  type: TYPE_NORMAL
- en: The routines converting numeric values to strings, and strings to numeric values,
    have two fundamental differences. First of all, numeric-to-string conversions
    generally occur without possibility of error (assuming you have allocated a sufficiently
    large buffer so that the conversion routines don’t write data beyond the end of
    the buffer). String-to-numeric conversions, on the other hand, must handle the
    real possibility of errors like illegal characters and numeric overflow.
  prefs: []
  type: TYPE_NORMAL
- en: A typical numeric input operation consists of reading a string of characters
    from the user and then translating this string of characters into an internal
    numeric representation. For example, in C++ a statement like cin >> i32; reads
    a line of text from the user and converts a sequence of digits appearing at the
    beginning of that line of text into a 32-bit signed integer (assuming i32 is a
    32-bit int object). The cin >> i32; statement skips over certain characters, like
    leading spaces, in the string that may appear before the actual numeric characters.
    The input string may also contain additional data beyond the end of the numeric
    input (for example, it is possible to read two integer values from the same input
    line), and therefore the input conversion routine must determine where the numeric
    data ends in the input stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, C++ achieves this by looking for a character from a set of *delimiter*
    characters. The delimiter character set could be something as simple as any character
    that is not a numeric digit; or the set could be the whitespace characters (space,
    tab, and so on) along with perhaps a few other characters such as a comma (,)
    or another punctuation character. For the sake of example, the code in this section
    assumes that any leading spaces or tab characters (ASCII code 9) may precede the
    first numeric digit and that the conversion stops on the first non-digit character
    it encounters. Possible error conditions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No numeric digits at all at the beginning of the string (following any spaces
    or tabs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string of digits is a value that would be too large for the intended numeric
    size (for example, 64 bits).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be up to the caller to determine whether the numeric string ends with
    an invalid character upon return from the function call.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1 Decimal Strings to Integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The basic algorithm to convert a string containing decimal digits to a number
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Initialize an accumulator variable to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Skip any leading spaces or tabs in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Fetch the first character after the spaces/tabs.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  If the character is not a numeric digit, return an error. If the character
    is a numeric digit, fall through to step 5.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Convert the numeric character to a numeric value (using AND 0xf).
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Set the accumulator = (accumulator × 10) + current numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  If overflow occurs, return and report an error. If no overflow occurs, fall
    through to step 8.
  prefs: []
  type: TYPE_NORMAL
- en: 8.  Fetch the next character from the string.
  prefs: []
  type: TYPE_NORMAL
- en: 9.  If the character is a numeric digit, go back to step 5; otherwise, fall
    through to step 10.
  prefs: []
  type: TYPE_NORMAL
- en: 10.  Return success, with the accumulator containing the converted value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For signed integer input, you use this same algorithm with the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: If the first non-space/tab character is a hyphen (-), set a flag denoting that
    the number is negative and skip the - character. If the first character is not
    -, clear the flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of a successful conversion, if the flag is set, negate the integer
    result before returning (you must check for overflow on the negate operation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing 9-14 implements the conversion algorithm; I’ve again broken this listing
    into several sections to better annotate it. The first section contains the usual
    format strings, along with various sample strings the main program uses to test
    the strtou and strtoi functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This program doesn’t have any static, writable data; all variable data is kept
    in registers or in local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the strtou function, which converts strings containing
    decimal digits to an unsigned integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: On entry into strtou, the X1 register points at the first character of the string
    to convert. This function begins by skipping over any whitespace characters (spaces
    and tabs) in the string, leaving X1 pointing at the first non-space/non-tab character
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: After any whitespace characters, the first character must be a decimal digit,
    or strtou must return a conversion error. Therefore, after finding a non-whitespace
    character, the code checks to see that the character is in the range '0' to '9'
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'After verifying that the first character is a digit, the code enters the main
    conversion loop ❸. Normally, you’d just convert the character to an integer (by
    ANDing with 0xF), multiply the accumulator in X0 by 10, and add in the character’s
    value. This could be done using two instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The only problem is that you cannot detect overflow by using these two instructions
    (something that the strtou function must do). To detect an overflow due to the
    multiplication by 10, the code must use the umulh instruction and check the result
    for 0 (if it is not 0, overflow occurs) ❸. If the umulh result is 0, the code
    can multiply the accumulator (X0) by 10 without fear of overflow. Of course, overflow
    can still occur when adding the character’s value to the product of X0 and 10,
    so you still cannot use madd; instead, you must multiply the accumulator by 10,
    then use the adds instruction to add in the character value and check the carry
    flag immediately thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: The convert loop repeats this process until either an overflow occurs or it
    encounters a nondigit character. Once it encounters a nondigit character ❹, the
    converted integer value is in the X0 register, and the function returns with the
    carry clear. Note that if the conversion is successful, the strtou function does
    not restore the X1 register; instead, it returns with X1 pointing at the first
    nondigit character ❺. It is the caller’s responsibility to check this character
    to see if it is legitimate.
  prefs: []
  type: TYPE_NORMAL
- en: In the event of an overflow or an illegal starting character, the function returns
    with the carry flag set and an error code in X0 ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is the strtoi procedure, which is the signed-integer version
    of the strtou procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The strtoi function converts a string containing a signed integer to the corresponding
    value in X0\. The code begins by eliminating whitespace ❶, then checks for a '-'
    character ❷. The function maintains a “negative flag” in the X2 register (0 =
    nonnegative, 1 = negative). After skipping the optional sign character, the code
    calls the strtou function to convert the following string to an unsigned value
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Upon return from strtou, the strtoi function checks the sign flag in X2 and
    negates the number if it’s supposed to be negative ❹. In both cases (negative
    or nonnegative), the code also checks for an overflow condition and returns an
    error if an overflow occurred.
  prefs: []
  type: TYPE_NORMAL
- en: As for strtou, the strtoi function does not restore X1 if the conversion was
    successful. However, it will restore X1 if an overflow occurred or if strtou reported
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: When you call strtou to convert the string to an integer, strtoi will allow
    an arbitrary amount of whitespace between the minus sign and the first digit of
    a string representing a negative number. If this is a problem for you, modify
    strtou to skip whitespace and then call a subservient routine to do the conversion;
    next, have strtoi call that subservient routine (which will return an illegal
    initial character error, if appropriate) in place of strtou.
  prefs: []
  type: TYPE_NORMAL
- en: 'The asmMain function demonstrates calling the strtou and strtoi functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The asmMain function in Listing 9-14 is a typical test program; it converts
    various strings appearing in the read-only data section to their corresponding
    integer values and displays them. It also tests a couple of overflow conditions
    to verify that the routines properly handle overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the build command and sample output for the program in Listing
    9-14:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For an extended-precision string-to-numeric conversion, simply modify the strtou
    function to include an extended-precision accumulator, then do an extended-precision
    multiplication by 10 (rather than a standard multiplication).
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.2 Hexadecimal Strings to Numeric Form
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As was the case for numeric output, hexadecimal input is the easiest numeric
    input routine to write. The basic algorithm for converting hexadecimal strings
    to numeric form is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Initialize an accumulator value to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  For each input character that is a valid hexadecimal digit, repeat steps
    3 through 6; skip down to step 7 when the character is not a valid hexadecimal
    digit.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Convert the hexadecimal character to a value in the range 0 to 15 (0h to
    0Fh).
  prefs: []
  type: TYPE_NORMAL
- en: 4.  If the HO 4 bits of the accumulator value are nonzero, raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Multiply the current value by 16 (that is, shift left 4 bits).
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Add the converted hexadecimal digit value to the accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Check the current input character to ensure that it is a valid delimiter.
    Raise an exception if it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-15 implements this hexadecimal input routine for 64-bit values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The strtoh function is similar to strtou, except that it tests for hexadecimal
    digits ❶ (rather than just decimal digits), tests the HO 4 bits to determine whether
    an overflow occurs ❷ (much easier than the decimal case), and multiplies by the
    hexadecimal radix (16) rather than by 10 ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for the program in Listing 9-15:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For hexadecimal string conversions that handle numbers greater than 64 bits,
    you have to use an extended-precision shift left by 4 bits. Listing 9-16 demonstrates
    the necessary modifications to the strtoh function for a 128-bit conversion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This code works similarly to that in Listing 9-15\. The main difference is the
    128-bit shift left by 4 bits ❶ in Listing 9-16\. The code shifts X0 to the right
    60 bits, then ORs this into X1 after shifting it to the left 4 bits, which shifts
    4 bits from X0 into X1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for Listing 9-16:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The hexadecimal-string-to-numeric function worked as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 9.3.3 String to Floating-Point'
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting a string of characters representing a floating-point number to the
    64-bit double format is slightly easier than the double-to-string conversion that
    appeared earlier in this chapter. Because decimal conversion (with no exponent)
    is a subset of the more general scientific notation conversion, if you can handle
    scientific notation, you get decimal conversion for free. Beyond that, the basic
    algorithm is to convert the mantissa characters to an integer form in order to
    convert to floating-point, then read the (optional) exponent and adjust the double
    exponent accordingly. The algorithm for the conversion is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Begin by stripping away any leading space or tab characters (and any other
    delimiters).
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Check for a leading plus (+) or minus (-) sign character. Skip it if one
    is present. Set a sign flag to true if the number is negative (false if nonnegative).
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Initialize an exponent value to –16\. The algorithm will create an integer
    value from the mantissa digits in the string. As double-precision floats support
    a maximum of 16 significant digits, initializing the exponent to –16 accounts
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Initialize a significant-digit-counter variable that counts the number of
    significant digits processed thus far to 16.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  If the number begins with any leading 0s, skip over them (do not change
    the exponent or significant digit counters for leading 0s to the left of the decimal
    point).
  prefs: []
  type: TYPE_NORMAL
- en: 6.  If the scan encounters a decimal point after processing any leading 0s,
    go to step 11; otherwise, fall through to step 7.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  For each nonzero digit to the left of the decimal point, if the significant
    digit counter is not 0, multiply the integer accumulator by 10 and add in the
    numeric equivalent of the digit. This is the standard integer conversion. (If
    the significant digit counter is 0, the algorithm has already processed 16 significant
    digits and will ignore any additional digits, since the double format cannot represent
    more than 16 significant digits.)
  prefs: []
  type: TYPE_NORMAL
- en: 8.  For each digit to the left of the decimal point, increment the exponent
    value (originally initialized to –16) by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 9.  If the significant digit counter is not 0, decrement the significant digit
    counter (which will also provide the index into the digit string array).
  prefs: []
  type: TYPE_NORMAL
- en: 10.  If the first nondigit encountered is not a decimal point, skip to step
    14.
  prefs: []
  type: TYPE_NORMAL
- en: 11.  Skip over the decimal point character.
  prefs: []
  type: TYPE_NORMAL
- en: 12.  For each digit encountered to the right of the decimal point, continue
    adding the digits to the integer accumulator as long as the significant digit
    counter is not 0\. If the significant digit counter is greater than 0, decrement
    it. Also decrement the exponent value.
  prefs: []
  type: TYPE_NORMAL
- en: 13.  If the algorithm hasn’t encountered at least one decimal digit by this
    point, report an illegal character exception and return.
  prefs: []
  type: TYPE_NORMAL
- en: 14.  If the current character is not e or E, go to step 20\. Otherwise, skip
    over the e or E character and continue with step 15\. (Note that some string formats
    also allow d or D to denote a double-precision value. You can also choose to allow
    this, and possibly check the range of the value if the algorithm encounters e
    or E versus d or D.)
  prefs: []
  type: TYPE_NORMAL
- en: 15.  If the next character is + or -, skip over it. Set a flag to true if the
    sign character is -; set it to false otherwise (note that this exponent sign flag
    is different from the mantissa sign flag set earlier in this algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: 16.  If the next character is not a decimal digit, report an error.
  prefs: []
  type: TYPE_NORMAL
- en: 17.  Convert the string of digits starting with the current decimal digit character
    to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 18.  Add the converted integer to the exponent value that was initialized to
    –16 at the start of this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 19.  If the exponent value is outside the range –324 to +308, report an out-of-range
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 20.  Convert the mantissa, which is currently an integer, to a floating-point
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 21.  Take the absolute value of the exponent, preserving the exponent’s sign.
    This value will be 9 bits or less.
  prefs: []
  type: TYPE_NORMAL
- en: 22.  If the exponent was positive, then for each set bit in the exponent, multiply
    the current mantissa value by 10 raised to the power specified by that bit’s position.
    For example, if bits 4, 2, and 1 are set, multiply the mantissa value by 10^(16),
    10⁴, and 10².
  prefs: []
  type: TYPE_NORMAL
- en: 23.  If the exponent was negative, then for each set bit in the exponent, divide
    the current mantissa value by 10 raised to the power specified by that bit’s position.
    For example, if bits 4, 3, and 2 are set, divide the mantissa value by 10^(16),
    10⁸, and 10⁴ (starting with the larger values and working your way down).
  prefs: []
  type: TYPE_NORMAL
- en: 24.  If the mantissa is negative (the first sign flag set at the beginning of
    the algorithm), negate the floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9-17 provides an implementation of this algorithm, explained section
    by section. The first part is typical for the sample programs in this book, containing
    some constant declarations, static data, and the getTitle function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The read-only section contains various test strings that this program will convert
    into floating-point values ❶. These test strings were carefully chosen to test
    most of the (successful) paths through the strToR64 function. To reduce the size
    of the main program, Listing 9-17 processes these strings in a loop. The array
    of pointers ❷ points at each of the test strings, with a NULL pointer (0) marking
    the end of the list. The main program will iterate through these pointers in a
    loop to test the input strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PotTbl (powers-of-10 table) array ❸ contains various powers of 10\. The
    strToR64 function uses this table to convert a decimal exponent (in integer format)
    to an appropriate power of 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The strToR64 function uses #define statements ❶ to create meaningful, more
    readable names for the local variables it maintains in various registers.'
  prefs: []
  type: TYPE_NORMAL
- en: Although this function uses only registers X0 through X7 and D1 (which are all
    volatile in the ARM ABI), this function preserves all the registers it modifies
    ❷. In assembly language, it’s always good programming style to preserve modified
    registers. This code does not preserve X0 (assuming a successful conversion) because
    it returns X0 pointing at the end of the (successfully) converted string as a
    function result. Note that this code returns the main function result in D0.
  prefs: []
  type: TYPE_NORMAL
- en: 'After function initialization, the strToR64 function begins by skipping all
    whitespace (spaces and tabs) at the beginning of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This code exits with ch (W6) containing the first non-whitespace character and
    X0 pointing at that character in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately after any whitespace characters, the string may optionally contain
    a single + or -character. This code skips either of these characters (if present)
    and sets the mantissa sign flag (sign) to 1 if a - character is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after a sign character (or if there isn’t an optional sign character),
    the string must contain a decimal digit character or a decimal point. This code
    tests for one of these two conditions and reports a conversion error if the condition
    fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This code uses a common trick to compare for a character in the range '0' through
    '9'. It subtracts the ASCII code for '0' from the character ❶. If the character
    was in the range '0' to '9', this translates its value to the range 0 to 9\. A
    single *unsigned* comparison against the value 9 tells us whether the character
    value was in the range '0' to '9'. If so, this code transfers control to the code
    that will process digits to the left of the decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the code has subtracted ''0'' from the character’s ASCII code, it cannot
    simply compare the character against a period. The cmp ch, #''.''-''0'' instruction
    correctly compares the character against a period by subtracting the character
    code for ''0'' from ''.'' ❷. If the character was a period, the code will verify
    that the following character is also a digit ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the code starting at scanDigits processes the mantissa digits to the
    left of the decimal point (if present):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This code skips over leading 0s by noting that if the mantissa value is 0 and
    the current character is '0', it’s a leading 0 ❶. For each mantissa digit the
    code fetches, it adjusts the mantissa value by multiplying the mantissa by 10
    and adding in the numeric equivalent of the digit ❹. However, if the loop processes
    more than 16 significant digits ❸, it does not add in the character to the mant
    accumulator (because double-precision objects support a maximum of 16 significant
    digits). If the input string exceeds 16 significant digits, the code increments
    the fpExp variable ❷ to track the eventual exponent of the number. The code undoes
    this increment ❺ if the mantissa was multiplied by 10 (in which case the exponent
    does not need to be incremented).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section of code handles the digits after a decimal point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The code is similar to the digits to the left, except that it decrements the
    running exponent value for each digit ❷. This is because the mantissa is being
    maintained as an integer, and the code continues to insert the fractional digits
    into the mantissa by multiplying by 10 and adding in the digit’s value. Should
    the total number of significant digits exceed 16 (not including leading 0s ❶),
    this function ignores any further digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is processing the string’s optional exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This code first checks for an e or E character denoting the start of an exponent
    ❶. If the string has an exponent, the code checks for an optional sign character
    ❷. If a - character is present, the code sets expSign to 1 (default is 0) to specify
    a negative exponent.
  prefs: []
  type: TYPE_NORMAL
- en: After processing the exponent sign, the code expects decimal digits ❸ and converts
    these digits to an integer (held in the expAcc variable). If expSign is true (nonzero),
    the code negates the value in expAcc ❹. The exponent code then adds expAcc to
    the exponent value obtained when processing the mantissa digits to obtain the
    actual exponent value ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code checks the exponent to verify it’s in the range –324 to +308
    ❻. This is the maximum dynamic range of a 64-bit double-precision floating-point
    value. If the exponent is out of this range, the code returns a value-out-of-range
    error.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the code has completely processed the string data, and the X0
    register points at the first byte in memory that is not part of the floating-point
    value. To convert the mantissa and exponent values from integers into a double-precision
    value, first convert the mantissa value (in mant) to a floating-point value by
    using the ucvtf instruction ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, processing the exponent is somewhat tricky. The fpExp variable contains
    the decimal exponent, but this is an integer value representing a power of 10\.
    You must multiply the value in D0 (the mantissa) by 10*^(fpExp)*, but unfortunately,
    the ARM instruction set does not provide an instruction that computes 10 raised
    to some integer power. You’ll have to write your own code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This code uses two nearly identical sections of code to handle negative ❶ and
    positive ❸ exponents. The difference between the two pieces of code is the choice
    of an fdiv instruction (for negative exponents) or an fmul instruction (for positive
    exponents). Each section contains a loop ❷ that steps through each entry of the
    PotTbl (powers-of-10) table. The exponent is a 9-bit value, as the maximum unsigned
    exponent value is 324, which fits in 9 bits or fewer.
  prefs: []
  type: TYPE_NORMAL
- en: For each set bit in this integer, the code must multiply the floating-point
    result by the corresponding power of 10 from PotTbl. For example, if bit 9 is
    set, multiply or divide the mantissa by 10^(256) (the first entry in PotTbl);
    if bit 8 is set, multiply or divide the mantissa by 10^(128) (the second entry
    in PotTbl), ...; if bit 0 is set, multiply or divide the mantissa by 10⁰ (the
    last entry in PotTbl). The two loops in the code accomplish this by moving the
    9 bits into the HO positions of fpExp, then shifting the bits out one at a time
    and doing the multiplication (for positive exponents) or division (for negative
    exponents) if the carry flag is set, using successive entries from PotTbl.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the code negates the value if it was negative (the flag is held in the
    sign variable) and returns the floating-point value to the caller in the D0 register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: On a successful conversion, this function returns X0 pointing at the first character
    beyond the floating-point string. This code does not restore X0 to its original
    value on a successful conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the strToR64 function is the error-handling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Each error returns a special error code in X1\. So this code does not restore
    X1 upon return. Unlike the successful return, the error return code will restore
    X0 to its original value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the asmMain function consists of a loop that processes each of the
    strings by using the pointers found in the values array. It simply steps through
    each pointer, passing it along to strToR64, until it encounters a NULL (0) value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the build command and sample output for Listing 9-17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: It would be interesting to modify the real-to-string and string-to-real programs
    to perform a “round-trip” conversion from real to string to real, to see whether
    you get roughly the same result back that you put in. (Because of rounding and
    truncation errors, you won’t always get the same exact value back, but it should
    be close.) I will leave it up to you to try this out.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Other Numeric Conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter has presented the more common numeric conversion algorithms: decimal
    integer, hexadecimal integer, and floating-point. Other conversions are sometimes
    useful. For example, some applications might need octal (base-8) conversions or
    conversions in an arbitrary base. For bases 2 through 9, the algorithm is virtually
    the same as for decimal integer conversions, except that rather than dividing
    by 10 (and taking the remainder), you divide by the desired base. Indeed, it would
    be fairly simple to write a generic function to which you pass the radix (base)
    to get the appropriate conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, base-2 output is nearly trivial because the ARM CPU stores values
    internally in binary. All you need do is shift bits out of the number (into the
    carry flag) and output a 0 or 1 based on the state of the carry. Base-4 and base-8
    conversions are also fairly simple, working with groups of 2 or 3 bits (respectively).
  prefs: []
  type: TYPE_NORMAL
- en: Some floating-point formats do not follow the IEEE standard. To handle these
    cases, write a function that converts such formats to the IEEE form, if possible,
    then use the examples from this chapter to convert between floating-point and
    string. If you need to work with such formats directly, the algorithms in this
    chapter should prove sufficiently general and easy to modify for your use.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5 Moving On
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This long chapter covered two main topics: converting numeric values to strings
    and converting strings to numeric values. For the former, this chapter covered
    numeric-to-hexadecimal conversion (bytes, hwords, words, dwords, and qwords),
    numeric-to-unsigned decimal conversion (64- and 128-bit), and numeric-to-signed
    decimal conversion (64- and 128-bit). It also discussed formatted conversion for
    controlling the output format when doing numeric-to-string conversions, and formatted
    floating-point-to-string conversions for decimal and exponential formats, as well
    as computing the number of print positions a conversion requires.'
  prefs: []
  type: TYPE_NORMAL
- en: While discussing string-to-numeric conversions, this chapter covered converting
    unsigned decimal strings to numeric forms, signed decimal strings to numeric forms,
    hexadecimal strings to numeric forms, and floating-point strings to double-precision
    numeric forms. Finally, the chapter briefly discussed other possible numeric output
    formats.
  prefs: []
  type: TYPE_NORMAL
- en: Although this book will continue to use the C printf() function for formatted
    output, you can use the procedures in this chapter to avoid relying on C when
    writing your own assembly code. These procedures also form the basis for an assembly
    language library you can use to simplify writing assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 For More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Donald Knuth’s *The Art of Computer Programming, Volume 2: Seminumerical Algorithms*,
    3rd edition (Addison-Wesley Professional, 1997) contains lots of useful information
    about decimal arithmetic and extended-precision arithmetic, though the text is
    generic and doesn’t describe how to do this in ARM assembly language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on division via multiplication by a reciprocal, see the
    University of Iowa tutorial at *[http://<wbr>homepage<wbr>.cs<wbr>.uiowa<wbr>.edu<wbr>/~jones<wbr>/bcd<wbr>/divide<wbr>.html](http://homepage.cs.uiowa.edu/~jones/bcd/divide.html)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
