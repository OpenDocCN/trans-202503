- en: Chapter 3. Understanding Objects
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章. 理解对象
- en: Even though there are a number of builtin reference types in JavaScript, you
    will most likely create your own objects fairly frequently. As you do so, keep
    in mind that objects in JavaScript are dynamic, meaning that they can change at
    any point during code execution. Whereas class-based languages lock down objects
    based on a class definition, JavaScript objects have no such restrictions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript中有许多内建的引用类型，但你很可能会频繁创建自己的对象。在此过程中，请记住，JavaScript中的对象是动态的，这意味着它们可以在代码执行的任何时刻发生变化。与基于类的语言根据类定义锁定对象不同，JavaScript对象没有这样的限制。
- en: A large part of JavaScript programming is managing those objects, which is why
    understanding how objects work is key to understanding JavaScript as a whole.
    This is discussed in more detail later in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript编程的一个重要部分就是管理这些对象，这也是为什么理解对象如何工作的关键是理解整个JavaScript的原因。后续章节中会更详细地讨论这一点。
- en: Defining Properties
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义属性
- en: 'Recall from [Chapter 1](ch01.html "Chapter 1. Primitive and Reference Types")
    that there are two basic ways to create your own objects: using the `Object` constructor
    and using an object literal. For example:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第1章](ch01.html "第1章. 原始类型与引用类型")，你可以通过两种基本方式来创建自己的对象：使用`Object`构造函数和使用对象字面量。例如：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Both `person1` and `person2` are objects with a `name` property. Later in the
    example, both objects are assigned an `age` property ❶. You could do this immediately
    after the definition of the object or much later. Objects you create are always
    wide open for modification unless you specify otherwise (more on that in [Preventing
    Object Modification](ch03.html#preventing_object_modification "Preventing Object
    Modification")). The last part of this example changes the value of `name` on
    each object ❷; property values can be changed at any time as well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`person1`和`person2`都是具有`name`属性的对象。在示例的后续部分，两个对象都被赋予了`age`属性 ❶。你可以在对象定义后立即这样做，也可以在更后面进行修改。除非特别指定，否则你创建的对象始终可以随时修改（有关这一点的更多内容，请参见[防止对象修改](ch03.html#preventing_object_modification
    "防止对象修改")）。这个示例的最后一部分修改了每个对象的`name`值 ❷；属性值也可以随时更改。'
- en: When a property is first added to an object, JavaScript uses an internal method
    called `[[Put]]` on the object. The `[[Put]]` method creates a spot in the object
    to store the property. You can compare this to adding a key to a hash table for
    the first time. This operation specifies not just the initial value, but also
    some attributes of the property. So, in the previous example, when the `name`
    and `age` properties are first defined on each object, the `[[Put]]` method is
    invoked for each.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个属性首次添加到对象时，JavaScript会在该对象上使用一个名为`[[Put]]`的内部方法。`[[Put]]`方法在对象中创建一个位置来存储该属性。你可以将其比作第一次向哈希表中添加一个键。此操作不仅指定了初始值，还指定了属性的一些特性。因此，在前面的示例中，当`name`和`age`属性首次在每个对象上定义时，都会调用`[[Put]]`方法。
- en: The result of calling `[[Put]]` is the creation of an *own property* on the
    object. An own property simply indicates that the specific instance of the object
    owns that property. The property is stored directly on the instance, and all operations
    on the property must be performed through that object.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`[[Put]]`的结果是在对象上创建一个*自有属性*。自有属性仅仅表示该对象的特定实例拥有该属性。属性直接存储在实例中，所有对该属性的操作都必须通过该对象进行。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Own properties are distinct from* prototype properties, *which are discussed
    in [Chapter 4](ch04.html "Chapter 4. Constructors and Prototypes").*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*自有属性不同于* 原型属性，*后者在[第4章](ch04.html "第4章. 构造函数与原型")中讨论。*'
- en: When a new value is assigned to an existing property, a separate operation called
    `[[Set]]` takes place. This operation replaces the current value of the property
    with the new one. In the previous example, setting `name` to a second value results
    in a call to `[[Set]]`. See [Figure 3-1](ch03.html#adding_and_changing_properties_of_an_obj
    "Figure 3-1. Adding and changing properties of an object") for a step-by-step
    view of what happened to `person1` behind the scenes as its `name` and `age` properties
    were changed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当新值被赋给现有属性时，会发生一个单独的操作，称为`[[Set]]`。此操作将属性的当前值替换为新值。在前面的示例中，将`name`设置为第二个值会导致调用`[[Set]]`。有关`person1`在幕后如何改变其`name`和`age`属性的详细步骤，请参见[图3-1](ch03.html#adding_and_changing_properties_of_an_obj
    "图3-1. 添加和更改对象的属性")。
- en: '![Adding and changing properties of an object](figs/web/oojs03_01.png.jpg)Figure 3-1. Adding
    and changing properties of an object'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![添加和更改对象的属性](figs/web/oojs03_01.png.jpg)图 3-1. 添加和更改对象的属性'
- en: In the first part of the diagram, an object literal is used to create the `person1`
    object. This performs an implicit `[[Put]]` for the `name` property. Assigning
    a value to `person1.age` performs a `[[Put]]` for the `age` property. However,
    setting `person1.name` to a new value (`"Greg"`) performs a `[[Set]]` operation
    on the `name` property, overwriting the existing property value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表的第一部分，使用对象字面量创建了`person1`对象。这为`name`属性执行了隐式的`[[Put]]`操作。给`person1.age`赋值时会执行`[[Put]]`操作来为`age`属性赋值。然而，将`person1.name`设置为一个新值（`"Greg"`）时会对`name`属性执行`[[Set]]`操作，覆盖现有的属性值。
- en: Detecting Properties
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测属性
- en: 'Because properties can be added at any time, it’s sometimes necessary to check
    whether a property exists in the object. New JavaScript developers often incorrectly
    use patterns like the following to detect whether a property exists:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因为属性可以随时添加，所以有时需要检查某个属性是否存在于对象中。新手 JavaScript 开发者常常错误地使用类似下面的模式来检测属性是否存在：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The problem with this pattern is how JavaScript’s type coercion affects the
    outcome. The `if` condition evaluates to `true` if the value is *truthy* (an object,
    a nonempty string, a nonzero number, or `true`) and evaluates to `false` if the
    value is *falsy* (`null`, `undefined`, `0`, `false`, `NaN`, or an empty string).
    Because an object property can contain one of these falsy values, the example
    code can yield false negatives. For instance, if `person1.age` is `0`, then the
    `if` condition will not be met even though the property exists. A more reliable
    way to test for the existence of a property is with the `in` operator.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的问题在于 JavaScript 的类型强制转换如何影响结果。如果值是*真值*（一个对象、非空字符串、非零数字或`true`），`if`条件会评估为`true`；如果值是*假值*（`null`、`undefined`、`0`、`false`、`NaN`
    或空字符串），`if`条件会评估为`false`。因为对象的属性可能包含这些假值中的一个，所以下面的代码可能会产生假阴性。例如，如果`person1.age`是`0`，那么即使该属性存在，`if`条件也不会成立。一个更可靠的检查属性是否存在的方式是使用`in`运算符。
- en: 'The `in` operator looks for a property with a given name in a specific object
    and returns `true` if it finds it. In effect, the `in` operator checks to see
    if the given key exists in the hash table. For example, here’s what happens when
    `in` is used to check for some properties in the `person1` object:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符会检查特定对象中是否存在具有给定名称的属性，如果找到该属性，则返回`true`。实际上，`in`运算符会检查给定的键是否存在于哈希表中。例如，下面是使用`in`检查`person1`对象中的某些属性时的情况：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Keep in mind that methods are just properties that reference functions, so you
    can check for the existence of a method in the same way. The following adds a
    new function, `sayName()`, to `person1` and uses `in` to confirm the function’s
    presence.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，方法只是引用函数的属性，因此你可以用相同的方式检查方法是否存在。下面的代码为`person1`添加了一个新函数`sayName()`，并使用`in`来确认该函数是否存在。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In most cases, the `in` operator is the best way to determine whether the property
    exists in an object. It has the added benefit of not evaluating the value of the
    property, which can be important if such an evaluation is likely to cause a performance
    issue or an error.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`in`运算符是判断属性是否存在于对象中的最佳方式。它的附加好处是不会评估属性的值，这在评估可能会导致性能问题或错误的情况下非常重要。
- en: 'In some cases, however, you might want to check for the existence of a property
    only if it is an own property. The `in` operator checks for both own properties
    and prototype properties, so you’ll need to take a different approach. Enter the
    `hasOwnProperty()` method, which is present on all objects and returns `true`
    only if the given property exists and is an own property. For example, the following
    code compares the results of using `in` versus `hasOwnProperty()` on different
    properties in `person1`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你可能只想检查属性是否存在且它是一个自有属性。`in`运算符会检查自有属性和原型属性，因此你需要采取不同的方法。此时使用`hasOwnProperty()`方法，它在所有对象上都有，并且只有在给定属性存在且是自有属性时，才会返回`true`。例如，下面的代码比较了在`person1`对象上使用`in`和`hasOwnProperty()`检查不同属性的结果：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, `name` is an own property of `person1`, so both the `in` operator
    and `hasOwnProperty()` return `true`. The `toString()` method, however, is a prototype
    property that is present on all objects. The `in` operator returns `true` for
    `toString()`, but `hasOwnProperty()` returns `false` ❶. This is an important distinction
    that is discussed further in [Chapter 4](ch04.html "Chapter 4. Constructors and
    Prototypes").
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`name`是`person1`的自有属性，因此`in`运算符和`hasOwnProperty()`都返回`true`。然而，`toString()`方法是所有对象上都存在的原型属性。`in`运算符对`toString()`返回`true`，但`hasOwnProperty()`返回`false`
    ❶。这是一个重要的区别，在[第四章](ch04.html "第四章. 构造函数和原型")中进一步讨论。
- en: Removing Properties
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除属性
- en: Just as properties can be added to objects at any time, they can also be removed.
    Simply setting a property to `null` doesn’t actually remove the property completely
    from the object, though. Such an operation calls `[[Set]]` with a value of `null`,
    which, as you saw earlier in the chapter, only replaces the value of the property.
    You need to use the `delete` operator to completely remove a property from an
    object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就像可以随时向对象添加属性一样，它们也可以被移除。简单地将属性设置为`null`并不会完全从对象中删除该属性。这样的操作调用`[[Set]]`并赋值为`null`，正如你在本章前面看到的，它仅仅是替换了属性的值。你需要使用`delete`运算符来完全从对象中删除一个属性。
- en: 'The `delete` operator works on a single object property and calls an internal
    operation named `[[Delete]]`. You can think of this operation as removing a key/value
    pair from a hash table. When the `delete` operator is successful, it returns `true`.
    (Some properties can’t be removed, and this is discussed in more detail later
    in the chapter.) For example, the following listing shows the `delete` operator
    at work:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`运算符作用在单个对象属性上，并调用一个名为`[[Delete]]`的内部操作。你可以把这个操作看作是从哈希表中删除一个键/值对。当`delete`运算符成功时，它返回`true`。（有些属性是不能被移除的，这会在本章后面详细讨论。）例如，下面的示例展示了`delete`运算符的工作方式：'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the `name` property is deleted from `person1`. The `in` operator
    returns `false` after the operation is complete. Also, note that attempting to
    access a property that doesn’t exist will just return `undefined` ❶. [Figure 3-2](ch03.html#when_you_delete_the_name_propertycomma_i
    "Figure 3-2. When you delete the name property, it completely disappears from
    person1.") shows how `delete` affects an object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`name`属性从`person1`中被删除。操作完成后，`in`运算符返回`false`。同时，请注意，尝试访问一个不存在的属性会返回`undefined`
    ❶。[图 3-2](ch03.html#when_you_delete_the_name_propertycomma_i "图 3-2. 当你删除名字属性时，它从person1完全消失。")展示了`delete`如何影响一个对象。
- en: '![When you delete the name property, it completely disappears from person1.](figs/web/oojs03_02.png.jpg)Figure 3-2. When
    you `delete` the name property, it completely disappears from `person1`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![当你删除名字属性时，它从person1完全消失。](figs/web/oojs03_02.png.jpg)图 3-2. 当你`delete`名字属性时，它从`person1`完全消失。'
- en: Enumeration
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'By default, all properties that you add to an object are *enumerable*, which
    means that you can iterate over them using a `for-in` loop. Enumerable properties
    have their internal `[[Enumerable]]` attributes set to `true`. The `for-in` loop
    enumerates all enumerable properties on an object, assigning the property name
    to a variable. For example, the following loop outputs the property names and
    values of an object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你向对象添加的所有属性都是*可枚举*的，这意味着你可以使用`for-in`循环对它们进行迭代。可枚举属性具有内部的`[[Enumerable]]`属性设置为`true`。`for-in`循环枚举对象上的所有可枚举属性，将属性名赋给一个变量。例如，下面的循环输出对象的属性名和值：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each time through the `for-in` loop, the `property` variable is filled with
    the next enumerable property on the object until all such properties have been
    used. At that point, the loop is finished and code execution continues. This example
    uses bracket notation to retrieve the value of the object property and output
    it to the console, which is one of the primary use cases for bracket notation
    in JavaScript.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过`for-in`循环时，`property`变量都会填充对象上的下一个可枚举属性，直到所有这些属性都被使用完为止。在那时，循环结束，代码继续执行。本例中使用方括号表示法检索对象属性的值并将其输出到控制台，这是JavaScript中方括号表示法的主要用例之一。
- en: 'If you just need a list of an object’s properties to use later in your program,
    ECMAScript 5 introduced the `Object.keys()` method to retrieve an array of enumerable
    property names, as shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要一个对象属性的列表以便稍后在程序中使用，ECMAScript 5 引入了`Object.keys()`方法来检索一个包含可枚举属性名的数组，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example uses `Object.keys()` to retrieve the enumerable properties from
    an object ❶. A `for` loop is then used to iterate over the properties and output
    the name and value. Typically, you would use `Object.keys()` in situations where
    you want to operate on an array of property names and `for-in` when you don’t
    need an array.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用`Object.keys()`来获取对象的可枚举属性❶。然后使用`for`循环遍历这些属性，并输出属性的名称和值。通常，在你想对属性名数组进行操作时，会使用`Object.keys()`，而在你不需要数组时，则使用`for-in`。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*There is a difference between the enumerable properties returned in a for-in
    loop and the ones returned by Object.keys(). The for-in loop also enumerates prototype
    properties, while Object.keys() returns only own (instance) properties. The differences
    between prototype and own properties are discussed in [Chapter 4](ch04.html "Chapter 4. Constructors
    and Prototypes").*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*在`for-in`循环中返回的可枚举属性和通过`Object.keys()`返回的属性是有区别的。`for-in`循环还会枚举原型属性，而`Object.keys()`只返回对象自身的（实例）属性。原型属性和自身属性的区别在[第4章](ch04.html
    "第4章：构造函数与原型")中有讨论。*'
- en: 'Keep in mind that not all properties are enumerable. In fact, most of the native
    methods on objects have their `[[Enumerable]]` attribute set to `false`. You can
    check whether a property is enumerable by using the `propertyIsEnumerable()` method,
    which is present on every object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，并非所有的属性都是可枚举的。实际上，大多数对象上的原生方法的`[[Enumerable]]`属性都被设置为`false`。你可以使用`propertyIsEnumerable()`方法来检查一个属性是否可枚举，该方法存在于每个对象上：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the property `name` is enumerable, as it is a custom property defined
    on `person1` ❶. The `length` property for the `properties` array, on the other
    hand, is not enumerable ❷ because it’s a built-in property on `Array.prototype`.
    You’ll find that many native properties are not enumerable by default.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name`属性是可枚举的，因为它是定义在`person1`上的自定义属性❶。另一方面，`properties`数组的`length`属性不可枚举❷，因为它是`Array.prototype`上的内置属性。你会发现许多原生属性默认是不可枚举的。
- en: Types of Properties
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性的类型
- en: 'There are two different types of properties: data properties and accessor properties.
    *Data properties* contain a value, like the `name` property from earlier examples
    in this chapter. The default behavior of the `[[Put]]` method is to create a data
    property, and every example up to this point in the chapter has used data properties.
    *Accessor properties* don’t contain a value but instead define a function to call
    when the property is read (called a *getter*), and a function to call when the
    property is written to (called a *setter*). Accessor properties only require either
    a getter or a setter, though they can have both.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 属性有两种不同的类型：数据属性和访问器属性。*数据属性*包含一个值，就像本章前面示例中的`name`属性一样。`[[Put]]`方法的默认行为是创建一个数据属性，本章到目前为止的每个示例都使用了数据属性。*访问器属性*不包含值，而是定义了一个在读取属性时调用的函数（称为*getter*），以及一个在写入属性时调用的函数（称为*setter*）。访问器属性只需要一个getter或一个setter，但也可以同时拥有两者。
- en: 'There is a special syntax to define an accessor property using an object literal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象字面量定义访问器属性有一种特殊的语法：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example defines an accessor property called `name`. There is a data property
    called `_name` that contains the actual value for the property ❶. (The leading
    underscore is a common convention to indicate that the property is considered
    to be private, though in reality it is still public.) The syntax used to define
    the getter ❷ and setter ❸ for `name` looks a lot like a function but without the
    `function` keyword. The special keywords `get` and `set` are used before the accessor
    property name, followed by parentheses and a function body. Getters are expected
    to return a value, while setters receive the value being assigned to the property
    as an argument.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例定义了一个名为`name`的访问器属性。还有一个数据属性`_name`，它包含该属性的实际值❶。（前导的下划线是常见的约定，表示该属性被视为私有，尽管实际上它仍然是公共的。）定义`name`的getter❷和setter❸的语法看起来像函数，但没有使用`function`关键字。在访问器属性名之前使用了特殊关键字`get`和`set`，后面跟着括号和函数体。getter预计返回一个值，而setter接收被分配给属性的值作为参数。
- en: Even though this example uses `_name` to store the property data, you could
    just as easily store the data in a variable or even in another object. This example
    simply adds logging to the behavior of the property; there’s usually no reason
    to use accessor properties if you are only storing the data in another property—just
    use the property itself. Accessor properties are most useful when you want the
    assignment of a value to trigger some sort of behavior, or when reading a value
    requires the calculation of the desired return value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个示例使用`_name`来存储属性数据，你完全可以将数据存储在一个变量中，甚至存储在另一个对象中。这个示例只是为属性的行为添加了日志记录；如果你只是将数据存储在另一个属性中，通常没有必要使用访问器属性——直接使用该属性即可。当你希望赋值操作触发某种行为，或者当读取一个值时需要计算所需的返回值时，访问器属性最为有用。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You don’t need to define both a getter and a setter; you can choose one or
    both. If you define only a getter, then the property becomes read-only, and attempts
    to write to it will fail silently in nonstrict mode and throw an error in strict
    mode. If you define only a setter, then the property becomes write-only, and attempts
    to read the value will fail silently in both strict and nonstrict modes.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*你不需要同时定义 getter 和 setter；你可以选择其中一个或两个。如果你只定义了 getter，那么该属性就变为只读，尝试写入该属性会在非严格模式下默默失败，在严格模式下抛出错误。如果你只定义了
    setter，那么该属性就变为只写，尝试读取其值在严格模式和非严格模式下都会默默失败。*'
- en: Property Attributes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性属性
- en: Prior to ECMAScript 5, there was no way to specify whether a property should
    be enumerable. In fact, there was no way to access the internal attributes of
    a property at all. ECMAScript 5 changed this by introducing several ways of interacting
    with property attributes directly, as well as introducing new attributes to support
    additional functionality. It’s now possible to create properties that behave the
    same way as builtin JavaScript properties. This section covers in detail the attributes
    of both data and accessor properties, starting with the ones they have in common.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 5 之前，无法指定一个属性是否应该是可枚举的。实际上，根本无法访问属性的内部属性。ECMAScript 5 通过引入多种直接与属性属性交互的方法，并引入新属性以支持更多功能，改变了这一点。现在可以创建表现得像内建
    JavaScript 属性一样的属性。本节将详细介绍数据属性和访问器属性的属性，从它们的共同属性开始。
- en: Common Attributes
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见属性
- en: There are two property attributes shared between data and accessor properties.
    One is `[[Enumerable]]`, which determines whether you can iterate over the property.
    The other is `[[Configurable]]`, which determines whether the property can be
    changed. You can remove a configurable property using `delete` and can change
    its attributes at any time. (This also means configurable properties can be changed
    from data to accessor properties and vice versa.) By default, all properties you
    declare on an object are both enumerable and configurable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数据属性和访问器属性之间有两个共享的属性。一个是`[[Enumerable]]`，决定是否可以遍历该属性。另一个是`[[Configurable]]`，决定该属性是否可以更改。你可以使用`delete`删除一个可配置的属性，并且可以随时更改其属性。（这也意味着可配置属性可以从数据属性更改为访问器属性，反之亦然。）默认情况下，你在对象上声明的所有属性都是可枚举且可配置的。
- en: 'If you want to change property attributes, you can use the `Object.defineProperty()`
    method. This method accepts three arguments: the object that owns the property,
    the property name, and a *property descriptor* object containing the attributes
    to set. The descriptor has properties with the same name as the internal attributes
    but without the square brackets. So you use `enumerable` to set `[[Enumerable]]`,
    and `configurable` to set `[[Configurable]]`. For example, suppose you want to
    make an object property nonenumerable and nonconfigurable:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更改属性的属性，可以使用`Object.defineProperty()`方法。该方法接受三个参数：拥有该属性的对象、属性名和一个包含要设置的属性的*属性描述符*对象。描述符的属性名称与内部属性相同，但没有方括号。因此，你可以使用`enumerable`来设置`[[Enumerable]]`，使用`configurable`来设置`[[Configurable]]`。例如，假设你想将一个对象属性设置为不可枚举且不可配置：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `name` property is defined as usual ❶, but it’s then modified to set its
    `[[Enumerable]]` attribute to `false` ❷. The `propertyIsEnumerable()` method now
    returns `false` ❸ because it references the new value of `[[Enumerable]]`. After
    that, `name` is changed to be nonconfigurable ❹. From now on, attempts to delete
    `name` fail because the property can’t be changed, so `name` is still present
    on `person1` ❺. Calling `Object.defineProperty()` on `name` again would also result
    in no further changes to the property. Effectively, `name` is locked down as a
    property on `person1`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`属性如常规定义 ❶，但随后被修改，将其`[[Enumerable]]`特性设置为`false` ❷。现在，`propertyIsEnumerable()`方法返回`false`
    ❸，因为它引用了`[[Enumerable]]`的新值。之后，`name`被修改为不可配置 ❹。从此以后，删除`name`的尝试会失败，因为该属性无法更改，所以`name`仍然存在于`person1`上
    ❺。再次调用`Object.defineProperty()`在`name`上也不会进一步更改该属性。实际上，`name`已被锁定为`person1`上的一个属性。'
- en: The last piece of the code tries to redefine `name` to be configurable once
    again ❻. However, this throws an error because you can’t make a nonconfigurable
    property configurable again. Attempting to change a data property into an accessor
    property or vice versa should also throw an error in this case.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一部分尝试重新定义`name`为可配置属性 ❻。然而，这会抛出一个错误，因为你不能将一个不可配置的属性重新配置为可配置的。在这种情况下，尝试将数据属性转换为访问器属性，或反之亦然，也应该抛出一个错误。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*When JavaScript is running in strict mode, attempting to delete a nonconfigurable
    property results in an error. In nonstrict mode, the operation silently fails.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*当JavaScript在严格模式下运行时，尝试删除一个不可配置的属性会导致错误。在非严格模式下，该操作会悄悄失败。*'
- en: Data Property Attributes
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据属性特性
- en: Data properties possess two additional attributes that accessors do not. The
    first is `[[Value]]`, which holds the property value. This attribute is filled
    in automatically when you create a property on an object. All property values
    are stored in `[[Value]]`, even if the value is a function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 数据属性具有访问器没有的两个附加特性。第一个是`[[Value]]`，它存储属性的值。创建对象上的属性时，这个特性会自动填充。所有属性值都存储在`[[Value]]`中，即使这个值是一个函数。
- en: The second attribute is `[[Writable]]`, which is a Boolean value indicating
    whether the property can be written to. By default, all properties are writable
    unless you specify otherwise.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个特性是`[[Writable]]`，它是一个布尔值，表示该属性是否可以被写入。默认情况下，所有属性都是可写的，除非你特别指定为不可写。
- en: 'With these two additional attributes, you can fully define a data property
    using `Object.defineProperty()` even if the property doesn’t already exist. Consider
    this code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个附加特性，你可以完全定义一个数据属性，即使该属性尚不存在。考虑以下代码：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You’ve seen this snippet throughout this chapter; it adds the `name` property
    to `person1` and sets its value. You can achieve the same result using the following
    (more verbose) code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中多次看到了这一段代码；它将`name`属性添加到`person1`上，并设置了它的值。你可以使用以下（更加冗长的）代码实现相同的结果：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When `Object.defineProperty()` is called, it first checks to see if the property
    exists. If the property doesn’t exist, a new one is added with the attributes
    specified in the descriptor. In this case, `name` isn’t already a property of
    `person1`, so it is created.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`Object.defineProperty()`时，它首先检查属性是否存在。如果属性不存在，则会按照描述符中指定的特性添加一个新的属性。在这种情况下，`name`并不是`person1`的一个属性，所以它会被创建。
- en: When you are defining a new property with `Object.defineProperty()`, it’s important
    to specify all of the attributes because Boolean attributes automatically default
    to `false` otherwise. For example, the following code creates a `name` property
    that is nonenumerable, nonconfigurable, and nonwritable because it doesn’t explicitly
    make any of those attributes `true` in the call to `Object.defineProperty()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`Object.defineProperty()`定义新属性时，重要的是要指定所有特性，因为布尔特性默认会自动设为`false`。例如，以下代码创建了一个`name`属性，该属性是不可枚举的、不可配置的和不可写的，因为在调用`Object.defineProperty()`时没有显式地将这些特性设置为`true`。
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code, you can’t do anything with the `name` property except read the
    value; every other operation is locked down. If you’re changing an existing property,
    keep in mind that only the attributes you specify will change.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，除了读取值外，你不能对`name`属性进行任何其他操作；所有其他操作都被锁定。如果你正在更改一个已有属性，请记住，只有你指定的特性会发生变化。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Nonwritable properties throw an error in strict mode when you try to change
    the value. In nonstrict mode, the operation silently fails.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可写属性在严格模式下尝试修改值时会抛出错误。在非严格模式下，该操作会悄悄失败。*'
- en: Accessor Property Attributes
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问器属性特性
- en: Accessor properties also have two additional attributes. Because there is no
    value stored for accessor properties, there is no need for `[[Value]]` or `[[Writable]]`.
    Instead, accessors have `[[Get]]` and `[[Set]]`, which contain the getter and
    setter functions, respectively. As with the object literal form of getters and
    setters, you need only define one of these attributes to create the property.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器属性还有两个额外的属性。因为访问器属性没有存储值，所以不需要`[[Value]]`或`[[Writable]]`。相反，访问器属性有`[[Get]]`和`[[Set]]`，它们分别包含getter和setter函数。与对象字面量形式的getter和setter类似，你只需要定义其中一个属性即可创建该属性。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you try to create a property with both data and accessor attributes, you
    will get an error.*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你尝试创建一个同时具有数据属性和访问器属性的属性，会导致错误。*'
- en: The advantage of using accessor property attributes instead of object literal
    notation to define accessor properties is that you can also define those properties
    on existing objects. If you want to use object literal notation, you have to define
    accessor properties when you create the object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用访问器属性属性而不是对象字面量符号来定义访问器属性的优点是，你还可以在现有对象上定义这些属性。如果你想使用对象字面量符号，必须在创建对象时就定义访问器属性。
- en: 'As with data properties, you can also specify whether accessor properties are
    configurable or enumerable. Consider this example from earlier:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据属性类似，你也可以指定访问器属性是否是可配置的或可枚举的。考虑下面这个之前的例子：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code can also be written as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也可以写成如下：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the `get` and `set` keys on the object passed in to `Object.defineProperty()`
    are data properties that contain a function. You can’t use object literal accessor
    format here.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，传递给`Object.defineProperty()`的对象中的`get`和`set`键是包含函数的数据属性。在这里，你不能使用对象字面量访问器格式。
- en: 'Setting the other attributes (`[[Enumerable]]` and `[[Configurable]]`) allows
    you to change how the accessor property works. For example, you can create a nonconfigurable,
    nonenumerable, nonwritable property like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 设置其他属性（`[[Enumerable]]`和`[[Configurable]]`）可以改变访问器属性的行为。例如，你可以像这样创建一个不可配置、不可枚举、不可写的属性：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code, the `name` property is an accessor property with only a getter
    ❶. There is no setter or any other attributes to explicitly set to `true`, so
    the value can be read but not changed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`name`属性是一个只有getter的访问器属性❶。没有setter或任何其他属性被显式设置为`true`，因此值可以读取但不能修改。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*As with accessor properties defined via object literal notation, an accessor
    property without a setter throws an error in strict mode when you try to change
    the value. In nonstrict mode, the operation silently fails. Attempting to read
    an accessor property that has only a setter defined always returns undefined.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*与通过对象字面量符号定义的访问器属性一样，如果访问器属性没有setter，在严格模式下尝试更改值时会抛出错误。在非严格模式下，操作会悄悄失败。尝试读取仅定义了setter的访问器属性时，始终返回`undefined`。*'
- en: Defining Multiple Properties
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义多个属性
- en: 'It’s also possible to define multiple properties on an object simultaneously
    if you use `Object.defineProperties()` instead of `Object.defineProperty()`. This
    method accepts two arguments: the object to work on and an object containing all
    of the property information. The keys of that second argument are property names,
    and the values are descriptor objects defining the attributes for those properties.
    For example, the following code defines two properties:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`Object.defineProperties()`而不是`Object.defineProperty()`，也可以同时在一个对象上定义多个属性。这个方法接受两个参数：要操作的对象和一个包含所有属性信息的对象。第二个参数的键是属性名，值是描述符对象，定义这些属性的属性。例如，以下代码定义了两个属性：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example defines `_name` as a data property to contain information ❶ and
    `name` as an accessor property ❷. You can define any number of properties using
    `Object.defineProperties()`; you can even change existing properties and create
    new ones at the same time. The effect is the same as calling `Object.defineProperty()`
    multiple times.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将`_name`定义为数据属性来存储信息❶，而将`name`定义为访问器属性❷。你可以使用`Object.defineProperties()`定义任意数量的属性；你甚至可以在同一时间修改现有属性或创建新属性。其效果与多次调用`Object.defineProperty()`相同。
- en: Retrieving Property Attributes
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取属性属性
- en: 'If you need to fetch property attributes, you can do so in JavaScript by using
    `Object.getOwnPropertyDescriptor()`. As the name suggests, this method works only
    on own properties. This method accepts two arguments: the object to work on and
    the property name to retrieve. If the property exists, you should receive a descriptor
    object with four properties: `configurable`, `enumerable`, and the two others
    appropriate for the type of property. Even if you didn’t specifically set an attribute,
    you will still receive an object containing the appropriate value for that attribute.
    For example, this code creates a property and checks its attributes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要获取属性的特性，可以通过JavaScript中的`Object.getOwnPropertyDescriptor()`来实现。顾名思义，这个方法仅适用于对象的自有属性。此方法接受两个参数：要操作的对象和要获取的属性名。如果属性存在，你将收到一个描述符对象，其中包含四个属性：`configurable`、`enumerable`和两个适用于该属性类型的其他属性。即使你没有特别设置某个属性，仍然会收到一个包含该属性适当值的对象。例如，这段代码创建了一个属性并检查了它的特性：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, a property called `name` is defined as part of an object literal. The
    call to `Object.getOwnPropertyDescriptor()` returns an object with `enumerable`,
    `configurable`, `writable`, and `value`, even though these weren’t explicitly
    defined via `Object.defineProperty()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个名为`name`的属性被定义为对象字面量的一部分。对`Object.getOwnPropertyDescriptor()`的调用返回一个包含`enumerable`、`configurable`、`writable`和`value`的对象，即使这些属性没有通过`Object.defineProperty()`显式定义。
- en: Preventing Object Modification
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止对象修改
- en: Objects, just like properties, have internal attributes that govern their behavior.
    One of these attributes is `[[Extensible]]`, which is a Boolean value indicating
    if the object itself can be modified. All objects you create are *extensible*
    by default, meaning new properties can be added to the object at any time. You’ve
    seen this several times in this chapter. By setting `[[Extensible]]` to `false`,
    you can prevent new properties from being added to an object. There are three
    different ways to accomplish this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对象就像属性一样，具有内部属性来控制它们的行为。其中一个属性是`[[Extensible]]`，它是一个布尔值，表示对象是否可以修改。你创建的所有对象默认都是*可扩展*的，这意味着可以随时向对象添加新属性。在本章中你已经看到过这种情况。通过将`[[Extensible]]`设置为`false`，你可以防止向对象添加新属性。有三种不同的方法可以实现这一点。
- en: Preventing Extensions
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止扩展
- en: One way to create a nonextensible object is with `Object.preventExtensions()`.
    This method accepts a single argument, which is the object you want to make nonextensible.
    Once you use this method on an object, you’ll never be able to add any new properties
    to it again. You can check the value of `[[Extensible]]` by using `Object.isExtensible()`.
    The following code shows examples of both methods at work.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建不可扩展对象的一种方法是使用`Object.preventExtensions()`。此方法接受一个参数，即你希望设置为不可扩展的对象。一旦你在一个对象上使用了这个方法，就无法再向它添加任何新属性。你可以通过`Object.isExtensible()`来检查`[[Extensible]]`的值。以下代码展示了两种方法的实际操作。
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After creating `person1`, this example checks the object’s `[[Extensible]]`
    attribute ❶ before making it unchangeable ❷. Now that `person1` is nonextensible,
    the `sayName()` method ❸ is never added to it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`person1`后，本示例首先检查对象的`[[Extensible]]`属性❶，然后将其设置为不可变❷。现在，`person1`是不可扩展的，`sayName()`方法❸将不会被添加到它上面。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Attempting to add a property to a nonextensible object will throw an error
    in strict mode. In nonstrict mode, the operation fails silently. You should always
    use strict mode with nonextensible objects so that you are aware when a nonextensible
    object is being used incorrectly.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*在严格模式下，尝试向一个不可扩展的对象添加属性会抛出错误。在非严格模式下，操作会悄无声息地失败。你应该始终在不可扩展的对象上使用严格模式，以便在不小心使用不可扩展对象时能及时察觉。*'
- en: Sealing Objects
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密封对象
- en: The second way to create a nonextensible object is to *seal* the object. A sealed
    object is nonextensible, and all of its properties are nonconfigurable. That means
    not only can you not add new properties to the object, but you also can’t remove
    properties or change their type (from data to accessor or vice versa). If an object
    is sealed, you can only read from and write to its properties.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建不可扩展对象的第二种方法是对对象进行*密封*。一个密封的对象是不可扩展的，并且它的所有属性都是不可配置的。这意味着不仅不能向对象添加新属性，还不能删除属性或更改其类型（从数据类型到访问器类型，或反之）。如果一个对象被密封，你只能读写其属性。
- en: 'You can use the `Object.seal()` method on an object to seal it. When that happens,
    the `[[Extensible]]` attribute is set to `false`, and all properties have their
    `[[Configurable]]` attribute set to `false`. You can check to see whether an object
    is sealed using `Object.isSealed()` as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Object.seal()`方法来密封一个对象。当对象被密封时，`[[Extensible]]`属性会被设置为`false`，所有属性的`[[Configurable]]`属性也会被设置为`false`。你可以通过`Object.isSealed()`来检查一个对象是否已密封，如下所示：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code seals `person1` ❶ so you can’t add or remove properties. Since all
    sealed objects are nonextensible, `Object.isExtensible()` returns `false` ❷ when
    used on `person1`, and the attempt to add a method called `sayName()` ❸ fails
    silently. Also, though `person1.name` is successfully changed to a new value ❹,
    the attempt to delete it ❺ fails.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码密封了`person1` ❶，因此你无法添加或删除属性。由于所有密封对象都是不可扩展的，`Object.isExtensible()`在`person1`上使用时返回`false`
    ❷，而尝试添加一个名为`sayName()`的方法 ❸会静默失败。此外，尽管`person1.name`成功更改为一个新值 ❹，但是删除它的尝试 ❺会失败。
- en: If you’re familiar with Java or C++, sealed objects should also be familiar.
    When you create a new object instance based on a class in one of those languages,
    you can’t add any new properties to that object. However, if a property contains
    an object, you can modify that object. In effect, sealed objects are JavaScript’s
    way of giving you the same measure of control without using classes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Java 或 C++，那么密封对象应该也比较熟悉。当你基于这些语言中的类创建一个新的对象实例时，你无法向该对象添加任何新属性。然而，如果某个属性包含一个对象，你可以修改这个对象。实际上，密封对象是
    JavaScript 提供的一种控制机制，它无需使用类便能实现类似的功能。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Be sure to use strict mode with sealed objects so you’ll get an error when
    someone tries to use the object incorrectly.*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*确保在使用密封对象时启用严格模式，这样当有人错误地使用该对象时，您会收到错误提示。*'
- en: Freezing Objects
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冻结对象
- en: 'The last way to create a nonextensible object is to *freeze* it. If an object
    is frozen, you can’t add or remove properties, you can’t change properties’ types,
    and you can’t write to any data properties. In essence, a frozen object is a sealed
    object where data properties are also read-only. Frozen objects can’t become unfrozen,
    so they remain in the state they were in when they became frozen. You can freeze
    an object by using `Object.freeze()` and determine if an object is frozen by using
    `Object.isFrozen()`. For example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建不可扩展对象的最后一种方法是*冻结*它。如果一个对象被冻结，你无法添加或删除属性，无法更改属性类型，也不能向任何数据属性写入数据。实质上，冻结对象是一个密封对象，其中的数据属性也是只读的。冻结对象无法解除冻结，因此它们将保持在被冻结时的状态。你可以通过使用`Object.freeze()`来冻结一个对象，并通过`Object.isFrozen()`来检查对象是否被冻结。例如：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, `person1` is frozen ❶. Frozen objects are also considered nonextensible
    and sealed, so `Object.isExtensible()` returns `false` ❷ and `Object.isSealed()`
    returns `true` ❸. The `name` property can’t be changed, so even though it is assigned
    to `"Greg"`, the operation fails ❹, and subsequent checks of `name` will still
    return `"Nicholas"`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`person1`被冻结 ❶。冻结对象也被认为是不可扩展和密封的，因此`Object.isExtensible()`返回`false` ❷，而`Object.isSealed()`返回`true`
    ❸。`name`属性不能更改，所以即使它被赋值为`"Greg"`，操作也会失败 ❹，后续检查`name`时仍然会返回`"Nicholas"`。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Frozen objects are simply snapshots of an object at a particular point in
    time. They are of limited use and should be used rarely. As with all nonextensible
    objects, you should use strict mode with frozen objects.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*冻结对象仅仅是在某一时刻对对象的快照。它们的用途有限，应当尽量少用。和所有不可扩展的对象一样，使用冻结对象时，应该启用严格模式。*'
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: It helps to think of JavaScript objects as hash maps where properties are just
    key/value pairs. You access object properties using either dot notation or bracket
    notation with a string identifier. You can add a property at any time by assigning
    a value to it, and you can remove a property at any time with the `delete` operator.
    You can always check whether a property exists by using the `in` operator on a
    property name and object. If the property in question is an own property, you
    could also use `hasOwnProperty()`, which exists on every object. All object properties
    are enumerable by default, which means that they will appear in a `for-in` loop
    or be retrieved by `Object.keys()`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 把 JavaScript 对象想象成哈希映射，其中属性就是键/值对，这样有助于理解。你可以通过点表示法或使用带有字符串标识符的括号表示法来访问对象属性。你可以随时通过给属性赋值来添加属性，也可以随时使用`delete`操作符删除属性。你可以通过在属性名和对象上使用`in`操作符来检查一个属性是否存在。如果该属性是自身属性，你还可以使用`hasOwnProperty()`，该方法在每个对象上都可以使用。所有对象属性默认都是可枚举的，这意味着它们会出现在`for-in`循环中，或者通过`Object.keys()`来获取。
- en: 'There are two types of properties: data properties and accessor properties.
    Data properties are placeholders for values, and you can read from and write to
    them. When a data property holds a function value, the property is considered
    a method of the object. Unlike data properties, accessor properties don’t store
    values on their own; they use a combination of getters and setters to perform
    specific actions. You can create both data properties and accessor properties
    directly using object literal notation.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的属性：数据属性和访问器属性。数据属性是值的占位符，你可以从中读取并写入数据。当数据属性持有一个函数值时，该属性被视为对象的方法。与数据属性不同，访问器属性本身不存储值；它们使用
    getter 和 setter 的组合来执行特定操作。你可以直接使用对象字面量表示法来创建数据属性和访问器属性。
- en: All properties have several associated attributes. These attributes define how
    the properties work. Both data and accessor properties have `[[Enumerable]]` and
    `[[Configurable]]` attributes. Data properties also have `[[Writable]]` and `[[Value]]`
    attributes, while accessor properties have `[[Get]]` and `[[Set]]` attributes.
    By default, `[[Enumerable]]` and `[[Configurable]]` are set to `true` for all
    properties, and `[[Writable]]` is set to `true` for data properties. You can change
    these attributes by using `Object. defineProperty()` or `Object.defineProperties()`.
    It’s also possible to retrieve these attributes by using `Object.getOwnPropertyDescriptor()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属性都有几个相关的属性，这些属性定义了属性的行为。数据属性和访问器属性都有 `[[Enumerable]]` 和 `[[Configurable]]`
    属性。数据属性还具有 `[[Writable]]` 和 `[[Value]]` 属性，而访问器属性则具有 `[[Get]]` 和 `[[Set]]` 属性。默认情况下，所有属性的
    `[[Enumerable]]` 和 `[[Configurable]]` 都被设置为 `true`，数据属性的 `[[Writable]]` 默认设置为
    `true`。你可以通过使用 `Object.defineProperty()` 或 `Object.defineProperties()` 来更改这些属性。也可以使用
    `Object.getOwnPropertyDescriptor()` 来获取这些属性。
- en: When you want to lock down an object’s properties in some way, there are three
    different ways to do so. If you use `Object.preventExtensions()`, objects will
    no longer allow properties to be added. You could also create a sealed object
    with the `Object.seal()` method, which makes that object nonextensible and makes
    its properties nonconfigurable. The `Object.freeze()` method creates a frozen
    object, which is a sealed object with nonwritable data properties. Be careful
    with nonextensible objects, and always use strict mode so that attempts to access
    the objects incorrectly will throw an error.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要以某种方式锁定对象的属性时，有三种不同的方式可以做到这一点。如果你使用 `Object.preventExtensions()`，对象将不再允许添加新的属性。你还可以使用
    `Object.seal()` 方法创建一个密封对象，这会使对象不可扩展，并使其属性不可配置。`Object.freeze()` 方法创建一个冻结对象，这是一个密封对象，且其数据属性不可写。对于不可扩展的对象要小心，并且始终使用严格模式，以确保尝试不正确访问对象时会抛出错误。
