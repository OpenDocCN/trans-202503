["```\n// The following compute *`destreg`* = *`destreg`* * *`constant`*\n\n          intmul( *`constant, destreg16`* );\n          intmul( *`constant, destreg32`* );\n\n          // The following compute *`dest`* = *`src`* * *`constant`*\n\n          intmul( *`constant`*, *`srcreg16`*, *`destreg16`* );\n          intmul( *`constant`*, *`srcmem16`*, *`destreg16`* );\n\n          intmul( *`constant`*, *`srcreg32`*, *`destreg32`* );\n          intmul( *`constant`*, *`srcmem32`*, *`destreg32`* );\n\n          // The following compute *`dest`* = *`src`* * *`constant`*\n\n          intmul( *`srcreg16`*, *`destreg16`* );\n          intmul( *`srcmem16`*, *`destreg16`* );\n          intmul( *`srcreg32`*, *`destreg32`* );\n          intmul( *`srcmem32`*, *`destreg32`* );\n```", "```\nbound( *`reg16`*, *`LBconstant`*, *`UBconstant`* );\nbound( *`reg32`*, *`LBconstant`*, *`UBconstant`* );\n\nbound( *`reg16`*, *`Mem16`*[2] );\nbound( *`reg32`*, *`Mem32`*[2] );\n```", "```\n*`lower_bound`* <= *`register`* <= *`upper_bound`*\n```", "```\n*`Mem16`*[0] <= *`register16`* <= *`Mem16`*[2]\n*`Mem32`*[0] <= *`register32`* <= *`Mem32`*[4]\n```", "```\nprogram BoundDemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n    InputValue:int32;\n    GoodInput:boolean;\n\nbegin BoundDemo;\n\n    // Repeat until the user enters a good value:\n\n    repeat\n\n        // Assume the user enters a bad value.\n\n        mov( false, GoodInput );\n\n        // Catch bad numeric input via the try..endtry statement.\n\n        try\n\n            stdout.put( \"Enter an integer between 1 and 10: \" );\n            stdin.flushInput();\n            stdin.geti32();\n\n            mov( eax, InputValue );\n\n            // Use the BOUND instruction to verify that the\n            // value is in the range 1..10.\n\n            bound( eax, 1, 10 );\n\n            // If we get to this point, the value was in the\n            // range 1..10, so set the boolean GoodInput\n            // flag to true so we can exit the loop.\n\n            mov( true, GoodInput );\n\n            // Handle inputs that are not legal integers.\n\n          exception( ex.ConversionError )\n\n            stdout.put( \"Illegal numeric format, re-enter\", nl );\n\n            // Handle integer inputs that don't fit into an int32.\n\n          exception( ex.ValueOutOfRange )\n\n            stdout.put( \"Value is *way* too big, re-enter\", nl );\n\n            // Handle values outside the range 1..10 (BOUND instruction).\n\n          exception( ex.BoundInstr )\n\n            stdout.put\n            (\n                \"Value was \",\n                InputValue,\n                \", it must be between 1 and 10, re-enter\",\n                nl\n            );\n\n        endtry;\n\n    until( GoodInput );\n    stdout.put( \"The value you entered, \", InputValue, \" is valid.\", nl );\n\nend BoundDemo;\n```", "```\nprogram INTOdemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n    LOperand:int8;\n    ResultOp:int8;\n\nbegin INTOdemo;\n\n    // The following try..endtry checks for bad numeric\n    // input and handles the integer overflow check:\n\n    try\n\n        // Get the first of two operands:\n\n        stdout.put( \"Enter a small integer value (-128..+127):\" );\n        stdin.geti8();\n        mov( al, LOperand );\n\n        // Get the second operand:\n\n        stdout.put( \"Enter a second small integer value (-128..+127):\" );\n        stdin.geti8();\n\n        // Produce their sum and check for overflow:\n\n        add( LOperand, al );\n        into();\n\n        // Display the sum:\n\n        stdout.put( \"The eight-bit sum is \", (type int8 al), nl );\n\n        // Handle bad input here:\n\n      exception( ex.ConversionError )\n\n        stdout.put( \"You entered illegal characters in the number\", nl );\n\n        // Handle values that don't fit in a byte here:\n\n      exception( ex.ValueOutOfRange )\n\n        stdout.put( \"The value must be in the range −128..+127\", nl );\n\n        // Handle integer overflow here:\n\n      exception( ex.IntoInstr )\n\n        stdout.put\n        (\n            \"The sum of the two values is outside the range −128..+127\",\n            nl\n        );\n\n    endtry;\n\nend INTOdemo;\n```", "```\nconst\n     pi:                   real32  := 3.14159;\n     MaxIndex:             uns32   := 15;\n     Delimiter:            char    := '/';\n     BitMask:              byte    := $F0;\n     DebugActive:          boolean := true;\n```", "```\nconst\n     pi               := 3.14159;     // Default type is real80.\n     MaxIndex         := 15;          // Default type is uns32.\n     Delimiter        := '/';         // Default type is char.\n     DebugActive      := true;        // Default type is boolean.\n```", "```\nprogram ConstDemo;\n#include( \"stdlib.hhf\" );\n\nconst\n    MemToAllocate   := 4_000_000;\n    NumDWords       := MemToAllocate div 4;\n    MisalignBy      := 62;\n\n    MainRepetitions := 10000;\n    DataRepetitions := 999_900;\n\n    CacheLineSize   := 16;\n\nbegin ConstDemo;\n\n    //console.cls();\n    stdout.put\n    (\n        \"Memory Alignment Exercise\",nl,\n        nl,\n        \"Using a watch (preferably a stopwatch), time the execution of\", nl\n        \"the following code to determine how many seconds it takes to\", nl\n        \"execute.\", nl\n        nl\n        \"Press Enter to begin timing the code:\"\n    );\n\n    // Allocate enough dynamic memory to ensure that it does not\n    // all fit inside the cache. Note: The machine had better have\n    // at least 4 megabytes mem.free or virtual memory will kick in\n    // and invalidate the timing.\n\n    mem.alloc( MemToAllocate );\n\n    // Zero out the memory (this loop really exists just to\n    // ensure that all memory is mapped in by the OS).\n\n    mov( NumDWords, ecx );\n    repeat\n\n        dec( ecx );\n        mov( 0, (type dword [eax+ecx*4]));\n\n    until( !ecx );  // Repeat until ecx = 0.\n\n    // Okay, wait for the user to press the Enter key.\n\n    stdin.readLn();\n\n    // Note: As processors get faster and faster, you may\n    // want to increase the size of the following constant.\n    // Execution time for this loop should be approximately\n    // 10-30 seconds.\n\n    mov( MainRepetitions, edx );\n    add( MisalignBy, eax );     // Force misalignment of data.\n\n    repeat\n\n        mov( DataRepetitions, ecx );\n        align( CacheLineSize );\n        repeat\n\n            sub( 4, ecx );\n            mov( [eax+ecx*4], ebx );\n            mov( [eax+ecx*4], ebx );\n            mov( [eax+ecx*4], ebx );\n            mov( [eax+ecx*4], ebx );\n\n        until( !ecx );\n        dec( edx );\n\n    until( !edx ); // Repeat until eax is zero.\n\n    stdout.put( stdio.bell, \"Stop timing and record time spent\", nl, nl );\n\n    // Okay, time the aligned access.\n\n    stdout.put\n    (\n        \"Press Enter again to begin timing access to aligned variable:\"\n    );\n    stdin.readLn();\n\n    // Note: If you change the constant above, be sure to change\n    // this one, too!\n\n    mov( MainRepetitions, edx );\n    sub( MisalignBy, eax );     // Realign the data.\n    repeat\n\n        mov( DataRepetitions, ecx );\n        align( CacheLineSize );\n        repeat\n\n            sub( 4, ecx );\n            mov( [eax+ecx*4], ebx );\n            mov( [eax+ecx*4], ebx );\n            mov( [eax+ecx*4], ebx );\n            mov( [eax+ecx*4], ebx );\n\n        until( !ecx );\n        dec( edx );\n\n    until( !edx ); // Repeat until eax is zero.\n\n    stdout.put( stdio.bell, \"Stop timing and record time spent\", nl, nl );\n    mem.free( eax );\n\nend ConstDemo;\n```", "```\n\"This is a string\"          // String with 16 characters.\n     \"\"                          // Zero length string.\n     \"a\"                         // String with a single character.\n     \"123\"                       // String of length 3.\n```", "```\n'2'               // Character constant equivalent to ASCII code $32.\n     'a'               // Character constant for lowercase 'A'.\n```", "```\n\"First part of string, \"    \"second part of string\"\n```", "```\n\"First part of string, second part of string\"\n```", "```\n\"He wrote a \"\" Hello World\"\" program as an example.\"\n```", "```\nHe wrote a \"Hello World\" program as an example.\n```", "```\n''''\n```", "```\n'1'  '2'  '3'                // Equivalent to \"123\"\n          \"He wrote a \"  '\"' \"Hello World\"  '\"' \" program as an example.\"\n```", "```\n#integer_constant\n```", "```\n#13          #$d          #%1101    // All three are the same\n                                              // character, a carriage return.\n```", "```\n\"Hello World\" #13 #10       // #13 #10 is the Windows newline sequence\n                                 // (carriage return followed by line feed).\n\n     \"Error: Bad Value\" #7       // #7 is the bell character.\n     \"He wrote a \" #$22 \"Hello World\" #$22 \" program as an example.\"\n```", "```\nconst\n     AStringConst:     string := \"123\";\n     ATextConst:       text   := \"123\";\n```", "```\nmov( ATextConst, al );            // Equivalent to mov( 123, al );\n```", "```\nmov( AStringConst, al );          // Equivalent to mov( \"123\", al );\n```", "```\nconst\n     nl: text := \"#$d #$a\";    // Windows version.\n\nconst\n    nl:  text := \" \"\"\"\" #$a\";  // Linux, FreeBSD, and Mac OS X version.\n```", "```\nstdout.put( \"Hello World\", nl );\n          stdout.put( \"Hello World\"  nl );\n```", "```\nstdout.put( \"Hello World\" #$d #$a );\n```", "```\nconst\n     AStrConst := \"String Constant\";\n     ATextConst: text := \"mov( 0, eax );\";\n```", "```\n*`Identifier`* : *`typeName`* := *`constant_expression`* ;\n          *`Identifier`* := *`constant_expression`* ;\n```", "```\n// Constant expression, computed while HLA is compiling your program:\n\nconst\n          x          := 5;\n          y          := 6;\n          Sum        := x + y;\n\n// Runtime calculation, computed while your program is running, long after\n// HLA has compiled it:\n\n     mov( x, al );\n     add( y, al );\n```", "```\nconst\n     TapeDAT               :=     0;\n     Tape8mm               :=     TapeDAT + 1;\n     TapeQIC80             :=     Tape8mm + 1;\n     TapeTravan            :=     TapeQIC80 + 1;\n     TapeDLT               :=     TapeTravan + 1;\n```", "```\nconst          TapeDAT               :=     0;\nconst          Tape8mm               :=     TapeDAT + 1;\nconst          TapeQIC80             :=     Tape8mm + 1;\nconst          TapeTravan            :=     TapeQIC80 + 1;\nconst          TapeDLT               :=     TapeTravan + 1;\n```", "```\nval       InitialValue     := 0;\nconst     SomeVal          := InitialValue + 1;        // = 1\nconst     AnotherVal       := InitialValue + 2;        // = 2\n\nval       InitialValue     := 100;\nconst     ALargerVal       := InitialValue;            // = 100\nconst     LargeValTwo      := InitialValue*2;          // = 200\n```", "```\n? *`ValIdentifier`* := *`constant_expression`*;\n```", "```\nprogram VALdemo;\n#include( \"stdlib.hhf\" )\n\nval\n    NotSoConstant := 0;\n\nbegin VALdemo;\n\n    mov( NotSoConstant, eax );\n    stdout.put( \"EAX = \", (type uns32 eax ), nl );\n\n    ?NotSoConstant := 10;\n    mov( NotSoConstant, eax );\n    stdout.put( \"EAX = \", (type uns32 eax ), nl );\n\n    ?NotSoConstant := 20;\n    mov( NotSoConstant, eax );\n    stdout.put( \"EAX = \", (type uns32 eax ), nl );\n\n    ?NotSoConstant := 30;\n    mov( NotSoConstant, eax );\n    stdout.put( \"EAX = \", (type uns32 eax ), nl );\n\nend VALdemo;\n```", "```\ntype\n     integer:             int32;\n     float:               real32;\n     double:              real64;\n     colors:              byte;\n```", "```\nstatic\n     i:                    integer;\n     x:                    float;\n     HouseColor:           colors;\n```", "```\nconst          TapeDAT          :=     0;\nconst          Tape8mm          :=     TapeDAT + 1;\nconst          TapeQIC80        :=     Tape8mm + 1;\nconst          TapeTravan       :=     TapeQIC80 + 1;\nconst          TapeDLT          :=     TapeTravan + 1;\n```", "```\ntype\n     *`enumTypeID`*:          enum { *`comma_separated_list_of_names`* };\n```", "```\ntype\n     TapeDrives: enum{ TapeDAT, Tape8mm, TapeQIC80, TapeTravan, TapeDLT};\n\nstatic\n     BackupUnit:        TapeDrives := TapeDAT;\n\n     .\n     .\n     .\n\n     mov( BackupUnit, al );\n     if( al = Tape8mm ) then\n\n          ...\n\n     endif;\n\n     // etc.\n```", "```\nM: array [0..1023] of integer;\n```", "```\ni := 0; (* Assume \"i\" is an integer variable. *)\n          M [i] := 100;\n```", "```\ni := 5;               (* Assume all variables are integers.*)\n          j := 10;\n          k := 50;\n          m [i*j-k] := 100;\n```", "```\nM [1] := 0;\n          M [ M [1] ] := 100;\n```", "```\nmov( p, ebx );            // Load ebx with the value of pointer p.\n          mov( [ebx], eax );        // Fetch the data that p points at.\n```", "```\nmov( &i, p );        // Assume all variables are STATIC variables.\n               .\n               .\n               .\n          if( *`some_expression`* ) then\n\n             mov( &j, p );      // Assume the code above skips this instruction\n               .                // and you get to the next instruction by\n               .                // jumping to this point from somewhere else.\n               .\n\n          endif;\n          mov( p, ebx );        // Assume both of the above code paths wind up\n          mov( [ebx], eax );    // down here.\n```", "```\nstatic\n     b:          byte;\n     d:          dword;\n     pByteVar:   pointer to byte := &b;\n     pDWordVar:  pointer to dword := &d;\n```", "```\ntype\n     ptrChar:     pointer to char;\n\nstatic\n     cString:     ptrChar;\n```", "```\n&*`StaticVarName`* [ *`PureConstantExpression`* ]\n          &*`StaticVarName`* + *`PureConstantExpression`*\n          &*`StaticVarName`* - *`PureConstantExpression`*\n```", "```\nprogram PtrConstDemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n    b:  byte := 0;\n        byte    1, 2, 3, 4, 5, 6, 7;\n\nconst\n    pb := &b + 1;\n\nbegin PtrConstDemo;\n\n    mov( pb, ebx );\n    mov( [ebx], al );\n    stdout.put( \"Value at address pb = $\", al, nl );\n\nend PtrConstDemo;\n```", "```\ntype\n     bytePtr:     pointer to byte;\n\nvar\n     bPtr: bytePtr;\n          .\n          .\n          .\n     mem.alloc( 1024 );    // Allocate a block of 1,024 bytes.\n     mov( eax, bPtr );     // Store address of block in bPtr.\n          .\n          .\n          .\n     mem.free( bPtr );     // Free the allocated block when done using it.\n          .\n          .\n          .\n```", "```\n// Program to demonstrate use of\n// an uninitialized pointer. Note\n// that this program should terminate\n// with a Memory Access Violation exception.\n\nprogram UninitPtrDemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n\n    // Note: By default, variables in the\n    // static section are initialized with\n    // zero (NULL) hence the following\n    // is actually initialized with NULL,\n    // but that will still cause our program\n    // to fail because we haven't initialized\n    // the pointer with a valid memory address.\n\n    Uninitialized: pointer to byte;\n\nbegin UninitPtrDemo;\n\n    mov( Uninitialized, ebx );\n    mov( [ebx], al );\n    stdout.put( \"Value at address Uninitialized: = $\", al, nl );\n\nend UninitPtrDemo;\n```", "```\nmem.alloc( 256 );   // Allocate some storage.\n          mov( eax, ptr );    // Save address away in a pointer variable.\n               .\n               .              // Code that uses the pointer variable ptr.\n               .\n          mem.free( ptr );    // Free the storage associated with ptr.\n               .\n               .              // Code that does not change the value in ptr.\n               .\n          mov( ptr, ebx );\n          mov( al, [ebx] );\n```", "```\nmem.alloc( 256 );\n          mov( eax, ptr );\n               .              // Code that uses the data where ptr is pointing.\n               .              // This code does not free up the storage\n               .              // associated with ptr.\n          mem.alloc( 512 );\n          mov( eax, ptr );\n\n          // At this point, there is no way to reference the original\n          // block of 256 bytes pointed at by ptr.\n```", "```\n// Program to demonstrate use of\n// lack of type checking in pointer\n// accesses.\n\nprogram BadTypePtrDemo;\n#include(\"stdlib.hhf\" );\n\nstatic\n    ptr:    pointer to char;\n    cnt:    uns32;\n\nbegin BadTypePtrDemo;\n\n    // Allocate sufficient characters\n    // to hold a line of text input\n    // by the user:\n\n    mem.alloc( 256 );\n    mov( eax, ptr );\n\n    // Okay, read the text a character\n    // at a time by the user:\n\n    stdout.put( \"Enter a line of text: \" );\n    stdin.flushInput();\n    mov( 0, cnt );\n    mov( ptr, ebx );\n    repeat\n\n        stdin.getc();       // Read a character from the user.\n        mov( al, [ebx] );   // Store the character away.\n        inc( cnt );         // Bump up count of characters.\n        inc( ebx );         // Point at next position in memory.\n\n    until( stdin.eoln());\n\n    // Okay, we've read a line of text from the user,\n    // now display the data:\n\n    mov( ptr, ebx );\n    for( mov( cnt, ecx ); ecx > 0; dec( ecx )) do\n\n        mov( [ebx], eax );\n        stdout.put( \"Current value is $\", eax, nl );\n        inc( ebx );\n\n    endfor;\n    mem.free( ptr );\n\nend BadTypePtrDemo;\n```", "```\nstatic\n     zeroTerminatedString:     char; @nostorage;\n                               byte \"This is the zero-terminated string\", 0;\n```", "```\nstatic\n     zeroTerminatedString:     char; @nostorage;\n                               byte \"This is the zero-terminated string\", 0;\n     zstrVar:                  zstring := &zeroTerminatedString;\n```", "```\nmov( &zeroTerminatedString, ebx );\n          mov( 0, eax );\n          while( (type byte [ebx+eax]) <> 0 ) do\n\n               inc( eax );\n\n          endwhile;\n\n          // String length is now in eax.\n```", "```\nstatic\n     lengthPrefixedString:char; @nostorage;\n                          byte 3, \"abc\";\n```", "```\nstatic\n          align(4);\n          dword 11;\n          dword 11;\n     TheString: char; @nostorage;\n          byte \"Hello there\";\n          byte 0;\n```", "```\nstdout.put( \"This gets converted to a four-component string by HLA\" );\n```", "```\nstatic\n          StrVariable:     string;\n```", "```\nstatic\n     InitializedString: string := \"This is my string\";\n```", "```\n// Program to demonstrate accessing Length and Maxlength fields of a string.\n\nprogram StrDemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n    theString:string := \"String of length 19\";\n\nbegin StrDemo;\n\n    mov( theString, ebx );  // Get pointer to the string.\n\n    mov( [ebx-4], eax );    // Get current length.\n    mov( [ebx-8], ecx );    // Get maximum length.\n\n    stdout.put\n    (\n        \"theString = '\", theString, \"'\", nl,\n        \"length( theString )= \", (type uns32 eax ), nl,\n        \"maxLength( theString )= \", (type uns32 ecx ), nl\n    );\n\nend StrDemo;\n```", "```\n// Program to demonstrate accessing length and maxlen fields of a string\n\nprogram LenMaxlenDemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n    theString:string := \"String of length 19\";\n\nbegin LenMaxlenDemo;\n\n    mov( theString, ebx );  // Get pointer to the string.\n\n    mov( (type str.strRec [ebx]).length, eax );  // Get current length.\n    mov( (type str.strRec [ebx]).maxlen, ecx );  // Get maximum length.\n\n    stdout.put\n    (\n        \"theString = \", theString, \"'\", nl,\n        \"length( theString )= \", (type uns32 eax ), nl,\n        \"maxLength( theString )= \", (type uns32 ecx ), nl\n    );\n\nend LenMaxlenDemo;\n```", "```\n// Program to demonstrate str.alloc and stdin.gets\n\nprogram strallocDemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n    theString:string;\n\nbegin strallocDemo;\n\n    str.alloc( 16 );         // Allocate storage for the string and store\n    mov( eax, theString );   // the pointer into the string variable.\n\n    // Prompt the user and read the string from the user:\n\n    stdout.put( \"Enter a line of text (16 chars, max): \" );\n    stdin.flushInput();\n    stdin.gets( theString );\n\n    // Echo the string back to the user:\n\n    stdout.put( \"The string you entered was: \", theString, nl );\n\nend strallocDemo;\n```", "```\n// Program to demonstrate str.alloc, str.free, and stdin.gets\n\nprogram strfreeDemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n    theString:string;\n\nbegin strfreeDemo;\n\n    str.alloc( 16 );         // Allocate storage for the string and store\n    mov( eax, theString );   // the pointer into the string variable.\n\n    // Prompt the user and read the string from the user:\n\n    stdout.put( \"Enter a line of text (16 chars, max): \" );\n    stdin.flushInput();\n    stdin.gets( theString );\n\n    // Echo the string back to the user:\n\n    stdout.put( \"The string you entered was: \", theString, nl );\n\n    // Free up the storage allocated by str.alloc:\n\n    str.free( theString );\n\nend strfreeDemo;\n```", "```\n// Program to demonstrate str.free and stdin.a_gets\n\nprogram strfreeDemo2;\n#include( \"stdlib.hhf\" );\n\nstatic\n    theString:string;\n\nbegin strfreeDemo2;\n\n    // Prompt the user and read the string from the user:\n\n    stdout.put( \"Enter a line of text: \" );\n    stdin.flushInput();\n    stdin.a_gets();\n    mov( eax, theString );\n\n    // Echo the string back to the user:\n\n    stdout.put( \"The string you entered was: \", theString, nl );\n\n    // Free up the storage allocated by stdin.a_gets:\n\n    str.free( theString );\n\nend strfreeDemo2;\n```", "```\nmov( s, ebx );          // Get pointer to string data into ebx.\n          mov( [ebx+3], al );     // Fetch the fourth character of the string.\n```", "```\nmov( s, ebx );          // Get address of string data into ebx.\n          mov( index, ecx );      // Get desired offset into string.\n          mov( [ebx+ecx], al );   // Get the desired character into al.\n```", "```\nmov( s, ebx );\n          mov( index, ecx );\n          if( ecx < (type str.strRec [ebx]).length ) then\n\n               mov( [ebx+ecx], al );\n\n          else\n\n               << Code that handles out-of-bounds string index >>\n\n          endif;\n```", "```\nraise( *`integer_constant`* );\nraise( *`reg32`* );\n```", "```\nmov( s, ebx );\n          mov( index, ecx );\n          if( ecx < (type str.strRec [ebx]).length ) then\n\n               mov( [ebx+ecx], al );\n\n          else\n\n               raise( ex.StringIndexError );\n\n          endif;\n```", "```\nstatic\n          string1:               string  := \"Some String Data\";\n          string2:               string;\n               .\n               .\n               .\n          mov( string1, eax );\n          mov( eax, string2 );\n               .\n               .\n               .\n```", "```\n// Program to demonstrate the problem with string assignment by reference\n\nprogram strRefAssignDemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n    string1:    string;\n    string2:    string;\n\nbegin strRefAssignDemo;\n\n    // Get a value into string1.\n\n    forever\n\n        stdout.put( \"Enter a string with at least three characters: \" );\n        stdin.a_gets();\n        mov( eax, string1 );\n\n        breakif( (type str.strRec [eax]).length >= 3 );\n\n        stdout.put( \"Please enter a string with at least three chars:\" nl );\n\n    endfor;\n\n    stdout.put( \"You entered: '\", string1, \"'\" nl );\n\n    // Do the string assignment by copying the pointer.\n\n    mov( string1, ebx );\n    mov( ebx, string2 );\n\n    stdout.put( \"String1= '\", string1, \"'\" nl );\n    stdout.put( \"\"String2= '\", string2, \"'\" nl );\n\n    // Okay, modify the data in string1 by overwriting\n    // the first three characters of the string (note that\n    // a string pointer always points at the first character\n    // position in the string and we know we've got at least\n    // three characters here).\n\n    mov( 'a', (type char [ebx]) );\n    mov( 'b', (type char [ebx+1]) );\n    mov( 'c', (type char [ebx+2]) );\n\n    // Okay, demonstrate the problem with assignment via\n    // pointer copy.\n\n    stdout.put\n    (\n        \"After assigning 'abc' to the first three characters in string1:\"\n        nl\n        nl\n    );\n    stdout.put( \"String1= '\", string1, \"'\" nl );\n    stdout.put( \"String2= '\", string2, \"'\" nl );\n\n    str.free( string1 );     // Don't free string2 as well!\n\nend strRefAssignDemo;\n```", "```\nstr.cpy( *`source_string`*, *`destination_string`* );\n```", "```\n// Program to demonstrate string assignment using str.cpy\n\nprogram strcpyDemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n    string1:    string;\n    string2:    string;\n\nbegin strcpyDemo;\n\n    // Allocate storage for string2:\n\n    str.alloc( 64 );\n    mov( eax, string2 );\n\n    // Get a value into string1.\n\n    forever\n\n        stdout.put( \"Enter a string with at least three characters: \" );\n        stdin.a_gets();\n        mov( eax, string1 );\n\n        breakif( (type str.strRec [eax]).length >= 3 );\n\n        stdout.put( \"Please enter a string with at least three chars:\" nl );\n\n    endfor;\n\n    // Do the string assignment via str.cpy.\n\n    str.cpy( string1, string2 );\n\n    stdout.put( \"String1= '\", string1, \"'\" nl );\n    stdout.put( \"String2= '\", string2, \"'\" nl );\n\n    // Okay, modify the data in string1 by overwriting\n    // the first three characters of the string (note that\n    // a string pointer always points at the first character\n    // position in the string and we know we've got at least\n    // three characters here).\n\n    mov( string1, ebx );\n    mov( 'a', (type char [ebx]) );\n    mov( 'b', (type char [ebx+1]) );\n    mov( 'c', (type char [ebx+2]) );\n\n    // Okay, demonstrate that we have two different strings\n    // because we used str.cpy to copy the data:\n\n    stdout.put\n    (\n        \"After assigning 'abc' to the first three characters in string1:\"\n        nl\n        nl\n    );\n    stdout.put( \"String1= '\", string1, \"'\" nl );\n    stdout.put( \"String2= '\", string2, \"'\" nl );\n\n    // Note that we have to free the data associated with both\n    // strings because they are not aliases of one another.\n\n    str.free( string1 );\n    str.free( string2 );\n\nend strcpyDemo;\n```", "```\nstr.a_cpy( *`source_string`* );\n```", "```\n// Program to demonstrate string assignment using str.a_cpy\n\nprogram stra_cpyDemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n    string1:    string;\n    string2:    string;\n\nbegin stra_cpyDemo;\n\n    // Get a value into string1.\n\n    forever\n\n        stdout.put( \"Enter a string with at least three characters: \" );\n        stdin.a_gets();\n        mov( eax, string1 );\n\n        breakif( (type str.strRec [eax]).length >= 3 );\n\n        stdout.put( \"Please enter a string with at least three chars:\" nl );\n\n    endfor;\n\n    // Do the string assignment via str.a_cpy.\n\n    str.a_cpy( string1 );\n    mov( eax, string2 );\n\n    stdout.put( \"String1= '\", string1, \"'\" nl );\n    stdout.put( \"String2= '\", string2, \"'\" nl );\n\n    // Okay, modify the data in string1 by overwriting\n    // the first three characters of the string (note that\n    // a string pointer always points at the first character\n    // position in the string and we know we've got at least\n    // three characters here).\n\n    mov( string1, ebx );\n    mov( 'a', (type char [ebx]) );\n    mov( 'b', (type char [ebx+1]) );\n    mov( 'c', (type char [ebx+2]) );\n\n    // Okay, demonstrate that we have two different strings\n    // because we used str.cpy to copy the data:\n\n    stdout.put\n    (\n        \"After assigning 'abc' to the first three characters in string1:\"\n        nl\n        nl\n    );\n    stdout.put( \"String1= '\", string1, \"'\" nl );\n    stdout.put( \"String2= '\", string2, \"'\" nl );\n\n    // Note that we have to free the data associated with both\n    // strings because they are not aliases of one another.\n\n    str.free( string1 );\n    str.free( string2 );\n\nend stra_cpyDemo;\n```", "```\nstr.length( *`Reg32`* );\nstr.length( *`string_variable`* );\n```", "```\nstr.cat( *`srcRStr`*, *`destLStr`* );\nstr.a_cat( *`srcLStr`*, *`srcRStr`* );\n```", "```\n// Program to demonstrate str.cat and str.a_cat\n\nprogram strcatDemo;\n#include( \"stdlib.hhf\" );\n\nstatic\n    UserName:   string;\n    Hello:      string;\n    a_Hello:    string;\n\nbegin strcatDemo;\n\n    // Allocate storage for the concatenated result:\n\n    str.alloc( 1024 );\n    mov( eax, Hello );\n\n    // Get some user input to use in this example:\n\n    stdout.put( \"Enter your name: \" );\n    stdin.flushInput();\n    stdin.a_gets();\n    mov( eax, UserName );\n\n    // Use str.cat to combine the two strings:\n\n    str.cpy( \"Hello \", Hello );\n    str.cat( UserName, Hello );\n\n    // Use str.a_cat to combine the string strings:\n\n    str.a_cat( \"Hello \", UserName );\n    mov( eax, a_Hello );\n\n    stdout.put( \"Concatenated string #1 is '\", Hello, \"'\" nl );\n    stdout.put( \"Concatenated string #2 is '\", a_Hello, \"'\" nl );\n\n    str.free( UserName );\n    str.free( a_Hello );\n    str.free( Hello );\n\nend strcatDemo;\n```", "```\nstr.insert( *`src`*, *`dest`*, *`index`* );\n                    str.a_insert( *`src`*, *`dest`*, *`index`* );\n```", "```\nstr.delete( *`strng`*, *`StartIndex`*, *`Length`* );\nstr.a_delete( *`strng`*, *`StartIndex`*, *`Length`* );\n```", "```\nstr.substr( *`src`*, *`dest`*, *`StartIndex`*, *`Length`* );\nstr.a_substr( *`src`*, *`StartIndex`*, *`Length`* );\n```", "```\nmov( s1, eax );\n     if( eax = s2 ) then\n\n          << Code to execute if the strings are equal >>\n\n     else\n\n          << Code to execute if the strings are not equal >>\n\n     endif;\n```", "```\nstr.eq( *`src1`*, *`src2`* );\nstr.ne( *`src1`*, *`src2`* );\nstr.lt( *`src1`*, *`src2`* );\nstr.le( *`src1`*, *`src2`* );\nstr.gt( *`src1`*, *`src2`* );\nstr.ge( *`src1`*, *`src2`* );\n```", "```\nstdout.put( \"Enter a single word: \" );\n          stdin.a_gets();\n          if( str.eq( eax, \"Hello\" )) then\n\n               stdout.put( \"You entered 'Hello'\", nl );\n\n          endif;\n          str.free( eax );\n```", "```\nstr.ieq( *`src1`*, *`src2`* );\nstr.ine( *`src1`*, *`src2`* );\nstr.ilt( *`src1`*, *`src2`* );\nstr.ile( *`src1`*, *`src2`* );\nstr.igt( *`src1`*, *`src2`* );\nstr.ige( *`src1`*, *`src2`* );\n```", "```\nstr.index( *`StrToSearch`*, *`SubstrToSearchFor`* );\n```", "```\nstr.put( *`destString`*, *`values_to_convert`* );\n```", "```\nstr.put( *`destString`*, \"I =\", i:4, \" J= \", j, \" s=\", s );\n```", "```\nstatic\n     s: string;\n          .\n          .\n          .\n     str.alloc( 256 );\n     mov( eax, s );\n          .\n          .\n          .\n     str.put( s, \"R: \", r:16:4, \" strval: '\", strval:-10, \"'\" );\n```", "```\nstatic\n     *`CharSetVar`*: cset;\n```", "```\nbt( *`BitNumber`*, *`BitsToTest`* );\n\nbt( *`reg16`*, *`reg16`* );\nbt( *`reg32`*, *`reg32`* );\nbt( *`constant`*, *`reg16`* );\nbt( *`constant`*, *`reg32`* );\n\nbt( *`reg16`*, *`mem16`* );\nbt( *`reg32`*, *`mem32`* );     // HLA treats cset objects as dwords within bt.\nbt( *`constant`*, *`mem16`* );\nbt( *`constant`*, *`mem32`* );  // HLA treats cset objects as dwords within bt.\n```", "```\nbt( 7, ax );          // Copies bit 7 of ax into the carry flag (CF).\n     mov( 20, eax );\n     bt( eax, ebx );       // Copies bit 20 of ebx into CF.\n\n     // Copies bit 0 of the byte at CharSetVar+3 into CF.\n\n     bt( 24, CharSetVar );\n\n     // Copies bit 4 of the byte at DWmem+2 into CF.\n\n     bt( eax, DWmem);\n```", "```\nbt( 'A', CharSetVar );\n          if( @c ) then\n\n               << Do something if 'A' is a member of the set. >>\n\n          endif;\n```", "```\n{ *`Comma_separated_list_of_characters_and_character_ranges`* }\n```", "```\n{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }\n```", "```\n{ '0'..'9' }\n```", "```\n{ '0'..'9', 'a'..'z', 'A'..'Z' }\n```", "```\nconst\n     AlphaNumeric: cset := {'0'..'9', 'a'..'z', 'A'..'Z' };\n```", "```\nstatic\n     Alphabetic: cset := { 'a'..'z', 'A'..'Z' };\n```", "```\ncs.empty( *`CSvar`* );\n```", "```\ncs.cpy( *`srcCsetValue`*, *`destCsetVar`* );\n```", "```\ncs.unionChar( *`CharVar`*, *`CSvar`* );\n```", "```\ncs.charToCset( *`CharValue`*, *`CSvar`* );\n```", "```\ncs.removeChar( *`CharValue`*, *`CSvar`* );\n```", "```\ncs.rangeChar( *`LowerBoundChar`*, *`UpperBoundChar`*, *`CSVar`* );\n```", "```\ncs.strToCset( *`StringValue`*, *`CSVar`* );\n```", "```\ncs.unionStr( *`StringValue`*, *`CSVar`* );\n```", "```\ncs.setunion( *`srcCset`*, *`destCset`* );\ncs.intersection( *`srcCset`*, *`destCset`* );\ncs.difference( *`srcCset`*, *`destCset`* );\n```", "```\ncs.IsEmpty( *`CSetValue`* );\n```", "```\ncs.member( *`CharValue`*, *`CsetValue`* );\n```", "```\ncs.subset( *`CsetValue1`*, *`CsetValue2`* );\ncs.psubset( *`CsetValue1`*, *`CsetValue2`* );\ncs.superset( *`CsetValue1`*, *`CsetValue2`* );\ncs.psuperset( *`CsetValue1`*, *`CsetValue2`* );\n```", "```\ncs.eq( *`CsetValue1`*, *`CsetValue2`* );\ncs.ne( *`CsetValue1`*, *`CsetValue2`* );\n```", "```\ncs.extract( *`CsetVar`* );\n```", "```\nstatic\n     answer: char;\n          .\n          .\n          .\n     repeat\n               .\n               .\n               .\n          stdout.put( \"Would you like to play again? \" );\n          stdin.FlushInput();\n          stdin.get( answer );\n\n     until( answer = 'n' );\n```", "```\nrepeat\n               .\n               .\n               .\n          repeat\n\n               stdout.put( \"Would you like to play again? \" );\n               stdin.FlushInput();\n               stdin.get( answer );\n\n          until( cs.member( answer, { 'n', 'N', 'Y', 'y' } );\n          if( answer = 'N' ) then\n\n               mov( 'n', answer );\n\n          endif;\n\n     until( answer = 'n' );\n```", "```\n*`Element_Address`* = *`Base_Address`* + ((*`Index`* - *`Initial_Index`*) * *`Element_Size`*)\n```", "```\n*`ArrayName`*: *`basetype`*[n];\n```", "```\nstatic\n\n     CharArray: char[128];    // Character array with elements 0..127.\n     ByteArray: byte[10];     // Array of bytes with elements 0..9.\n     PtrArray:  dword[4];     // Array of double words with elements 0..3.\n```", "```\nRealArray: real32[8] := [ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 ];\nIntegerAry: int32[8] := [ 1, 1, 1, 1, 1, 1, 1, 1 ];\n```", "```\nRealArray: real32[8] := [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 ];\nIntegerAry: int32[8] := [ 1, 2, 3, 4, 5, 6, 7, 8 ];\n```", "```\n[ 1, 2, 3, 4 ]\n[ 2.0, 3.14159, 1.0, 0.5 ]\n[ 'a', 'b', 'c', 'd' ]\n[ \"Hello\", \"world\", \"of\", \"assembly\" ]\n```", "```\nBigArray: uns32[ 1000 ] := 1000 dup [ 1 ];\n```", "```\nSixteenInts: int32[16] := 4 dup [1,2,3,4];\n```", "```\n*`Element_Address`* = *`Base_Address`* + *`index`* * Element_Size\n```", "```\n*`Element_Address`* = *`SixteenInts`* + *`index`**4\n```", "```\nmov( index, ebx );\n               shl( 2, ebx );          // Sneaky way to compute 4*ebx\n               mov( SixteenInts[ ebx ], eax );\n```", "```\nlea( eax, SixteenInts );\n               mov( index, ebx );\n               shl( 2, ebx );            // Sneaky way to compute 4*ebx\n               add( eax, ebx );          // Compute base address plus index*4\n               mov( [ebx], eax );\n```", "```\nmov( index, ebx );\n               mov( SixteenInts[ ebx*4 ], eax );\n```", "```\nconst\n    NumElements := 16;\n\nstatic\n    DataToSort: uns32[ NumElements ] :=\n                    [\n                        1, 2, 16, 14,\n                        3, 9, 4,  10,\n                        5, 7, 15, 12,\n                        8, 6, 11, 13\n                    ];\n\n    NoSwap: boolean;\n\n          .\n          .\n          .\n\n    // Bubble sort for the DataToSort array:\n\n    repeat\n\n        mov( true, NoSwap );\n        for( mov( 0, ebx ); ebx <= NumElements-2; inc( ebx )) do\n\n            mov( DataToSort[ ebx*4], eax );\n            if( eax > DataToSort[ ebx*4 + 4] ) then\n\n                mov( DataToSort[ ebx*4 + 4 ], ecx );\n                mov( ecx, DataToSort[ ebx*4 ] );\n                mov( eax, DataToSort[ ebx*4 + 4 ] ); // Note: eax contains\n                mov( false, NoSwap );                // DataToSort[ ebx*4 ]\n\n            endif;\n\n        endfor;\n\n    until( NoSwap );\n```", "```\n*`Element_Address`* = *`Base_Address`* + (*`colindex`* * *`row_size`* + *`rowindex`*) *\n *`Element_Size`*\n```", "```\nColumn          Row             Offset\n     Index           Index           into Array\n     0               0               0\n     0               1               1\n     0               2               2\n     0               3               3\n     1               0               4\n     1               1               5\n     1               2               6\n     1               3               7\n     2               0               8\n     2               1               9\n     2               2               10\n     2               3               11\n     3               0               12\n     3               1               13\n     3               2               14\n     3               3               15\n```", "```\n*`Address`* = *`Base`* + ((*`depthindex`***`col_size`*+*`colindex`*) * *`row_size`* + *`rowindex`*)\n * *`Element_Size`*\n```", "```\n*`Address`* =\n*`Base`* + (((*`LeftIndex`***`depth_size`*+*`depthindex`*)**`col_size`*+*`colindex`*) * *`row_size`*\n + *`rowindex`*) * *`Element_Size`*\n```", "```\nA: array [0..3] of *`sometype`*;\n```", "```\n*`Element_Address`* = *`Base`* + *`Index`* * *`Element_Size`*\n```", "```\ntype\n          OneD: char[4];\n          TwoD: OneD[4];\n          ThreeD: TwoD[4];\n          FourD: ThreeD [4];\nvar\n          A : FourD [4];\n```", "```\nFor a two-dimension column-major array:\n*`Element_Address`* = *`Base_Address`* + (*`rowindex`* * *`col_size`* + *`colindex`*) *\n                  *`Element_Size`*\n\nFor a three-dimension column-major array:\n*`Address`* = *`Base`* + ((*`rowindex`* * *`col_size`*+*`colindex`*) * *`depth_size`* +\n *`depthindex`*) *\n          *`Element_Size`*\n\nFor a four-dimension column-major array:\n*`Address`* =\n     *`Base`* + (((*`rowindex`* * *`col_size`* + *`colindex`*)**`depth_size`* + *`depthindex`*) *\n          *`Left_size`* + *`Leftindex`*) * *`Element_Size`*\n```", "```\n*`ArrayName`*: *`elementType`* [ *`comma_separated_list_of_dimension_bounds`* ];\n```", "```\nGameGrid: char[ 4, 4 ];\n```", "```\nNameItems: string[ 2, 3, 3 ];\n```", "```\nGameGrid: char[ 4, 4 ] :=\n          [\n               'a', 'b', 'c', 'd',\n               'e', 'f', 'g', 'h',\n               'i', 'j', 'k', 'l',\n               'm', 'n', 'o', 'p'\n          ];\n```", "```\nGameGrid: char[ 4,4 ] :=\n          [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p' ];\n```", "```\nStateValue: byte[ 256, 64 ] := 256*64 dup [$ff];\n```", "```\n[ [0, 1, 2], [3, 4], [10, 11, 12, 13] ]\n```", "```\n[ 0, 1, 2, 3, 4, 10, 11, 12, 13 ]\n```", "```\nGameGrid: char[ 4, 4 ] :=\n          [\n               [ 'a', 'b', 'c', 'd' ],\n               [ 'e', 'f', 'g', 'h' ],\n               [ 'i', 'j', 'k', 'l' ],\n               [ 'm', 'n', 'o', 'p' ]\n          ];\n```", "```\nstatic\n     i:          int32;\n     j:          int32;\n     TwoD:       int32[ 4, 8 ];\n\n           .\n           .\n           .\n\n// To perform the operation TwoD[i,j] := 5; you'd use code like the following.\n// Note that the array index computation is (i*8 + j)*4.\n\n          mov( i, ebx );\n          shl( 3, ebx );    // Multiply by 8 (shl by 3 is a multiply by 8).\n          add( j, ebx );\n          mov( 5, TwoD[ ebx*4 ] );\n```", "```\nstatic\n     i:               int32;\n     j:               int32;\n     k:               int32;\n     ThreeD:          int32[ 3, 4, 5 ];\n          .\n          .\n          .\n\n// To perform the operation ThreeD[i,j,k] := esi; you'd use the following code\n// that computes ((i*4 + j)*5 + k )*4 as the address of ThreeD[i,j,k].\n\n          mov( i, ebx );\n          shl( 2, ebx );                     // Four elements per column.\n          add( j, ebx );\n          intmul( 5, ebx );                  // Five elements per row.\n          add( k, ebx );\n          mov( esi, ThreeD[ ebx*4 ] );\n```", "```\nstudent =\n     record\n          Name:     string[64];\n          Major:    integer;\n          SSN:      string[11];\n          Midterm1: integer;\n          Midterm2: integer;\n          Final:    integer;\n          Homework: integer;\n          Projects: integer;\n     end;\n```", "```\ntype\n     student:     record\n          Name:     char[65];\n          Major:    int16;\n          SSN:      char[12];\n          Midterm1: int16;\n          Midterm2: int16;\n          Final:    int16;\n          Homework: int16;\n          Projects: int16;\n     endrecord;\n```", "```\nvar\n     John: Student;\n```", "```\nmov( ax, (type word John[65]) );\n```", "```\nstorage\n     OriginPoint:  record\n          x: uns8;\n          y: uns8;\n          z: uns8;\n     endrecord;\n```", "```\n*`RecordTypeName`*:[ *`List_of_comma_separated_constants`* ]\n```", "```\ntype\n     point:     record\n          x:int32;\n          y:int32;\n          z:int32;\n     endrecord;\n\nstatic\n     Vector: point := point:[ 1, −2, 3 ];\n```", "```\ntype\n     point:     record\n          x:int32;\n          y:int32;\n          z:int32;\n     endrecord;\n\nconst\n     PointInSpace: point := point:[ 1, 2, 3 ];\n\nstatic\n     Vector: point := PointInSpace;\n     XCoord: int32 := PointInSpace.x;\n          .\n          .\n          .\n     stdout.put( \"Y Coordinate is \", PointInSpace.y, nl );\n          .\n          .\n          .\n```", "```\ntype\n     *`recElement`*:\n          record\n               << Fields for this record >>\n          endrecord;\n          .\n          .\n          .\nstatic\n     *`recArray`*: *`recElement`*[4];\n```", "```\n// Access element i of *`recArray`*:\n\n     intmul( @size( *`recElement`* ), i, ebx );  // ebx := i*@size( *`recElement`* )\n     mov( *`recArray`*.*`someField`*[ebx], eax );\n```", "```\nstatic\n     rec2D: recElement[ 4, 6 ];\n          .\n          .\n          .\n     // Access element [i,j] of rec2D and load *`someField`* into eax:\n\n     intmul( 6, i, ebx );\n     add( j, ebx );\n     intmul( @size( *`recElement`* ), ebx );\n     mov( rec2D.*`someField`*[ ebx ], eax );\n```", "```\ntype\n     Pixel:\n          record\n               Pt:        point;\n               color:     dword;\n          endrecord;\n```", "```\nstatic\n     ThisPt: Pixel := Pixel:[ 5, 10 ];   // Syntactically incorrect!\n```", "```\nstatic\n     ThisPt: Pixel := Pixel:[ point:[ 1, 2, 3 ], 10 ];\n     ThatPt: Pixel := Pixel:[ point:[ 0, 0, 0 ], 5 ];\n```", "```\nstdout.put( \"ThisPt.Pt.x = \", ThisPt.Pt.x, nl );\n          stdout.put( \"ThisPt.Pt.y = \", ThisPt.Pt.y, nl );\n          stdout.put( \"ThisPt.Pt.z = \", ThisPt.Pt.z, nl );\n           .\n           .\n           .\n     mov( eax, ThisPt.Color );\n```", "```\ntype\n     Object8:\n          record\n               Pts:       point[8];\n               Color:     dword;\n          endrecord;\n```", "```\n// Cube.Pts[i].x := 0;\n\n          mov( i, ebx );\n          intmul( 12, ebx );\n          mov( 0, Cube.Pts.x[ebx] );\n```", "```\n// Cube.Pts[i].x := 0;\n\n          mov( i, ebx );\n          intmul( @size( point ), ebx );\n          mov( 0, Cube.Pts.x[ebx] );\n```", "```\ntype\n     RecW2DArray:\n          record\n               intField: int32;\n               aField:   int32[4,5];\n                    .\n                    .\n                    .\n          endrecord;\n\nstatic\n     recVar: RecW2DArray;\n          .\n          .\n          .\n     // Access element [i,j] of the aField field using row-major ordering:\n\n     mov( i, ebx );\n     intmul( 5, ebx );\n     add( j, ebx );\n     mov( recVar.aField[ ebx*4 ], eax );\n          .\n          .\n          .\n```", "```\ntype\n     NestedRecs:\n          record\n               iField: int32;\n               sField: string;\n               rField:\n                    record\n                         i:int32;\n                         u:uns32;\n                    endrecord;\n               cField:char;\n          endrecord;\n```", "```\ntype\n     recType:\n          record\n               arrayField: dword[4,5];\n               << Other fields >>\n          endrecord;\n\nstatic\n     aryOfRecs: recType[3,3];\n          .\n          .\n          .\n     // Access aryOfRecs[i,j].arrayField[k,l]:\n\n     intmul( 5, i, ebx );               // Computes index into aryOfRecs\n     add( j, ebx );                     // as (i*5 +j)*@size( recType ).\n     intmul( @size( recType ), ebx );\n\n     intmul( 3, k, eax );               // Computes index into aryOfRecs\n     add( l, eax );                     // as (k*3 + j) (*4 handled later).\n\n     mov( aryOfRecs.arrayField[ ebx + eax*4 ], eax );\n```", "```\ntype\n     PaddedRecord:\n          record\n               c:  char;\n               align(4);\n               d:  dword;\n               b:  boolean;\n               align(2);\n               w:  word;\n          endrecord;\n```", "```\nstatic\n          .\n          .\n          .\n     align(4);\n     PRvar: PaddedRecord;\n```", "```\ntype\n     PaddedRec:\n          record\n               << Some field declarations >>\n\n               align(4);\n          endrecord;\n```", "```\nstatic\n     Cube:          Object8;\n     CubePtr:       pointer to Object8 := &Cube;\n```", "```\nmov( CubePtr, ebx );\n          mov( [ebx].Color, eax );      // This does not work!\n```", "```\nmov( CubePtr, ebx );\nmov( (type Cube [ebx]).Color, eax );\n```", "```\nmov( CubePtr, ebx );\nintmul( @size( point ), i, esi );   // Compute index into point array.\nmov( (type Object8 [ebx]).Pts.x[ esi*4 ], eax );\n```", "```\nconst\n     O8ptr: text := \"(type Object8 [ebx])\";\n```", "```\nmov( CubePtr, ebx );\nintmul( @size( point ), i, esi );   // Compute index into point array.\nmov( O8Ptr.Pts.x[ esi*4 ], eax );\n```", "```\ntype\n     *`unionType`*:\n          union\n               << Fields (syntactically identical to record declarations) >>\n          endunion;\n```", "```\ntype\n     numeric:\n          union\n               i: int32;\n               u: uns32;\n               r: real64;\n          endunion;\n               .\n               .\n               .\nstatic\n     number: numeric;\n               .\n               .\n               .\n     mov( 55, number.u );\n               .\n               .\n               .\n     mov( −5, number.i );\n               .\n               .\n               .\n     stdout.put( \"Real value = \", number.r, nl );\n```", "```\ntype\n     numericRec:\n          record\n               i: int32;\n               u: uns32;\n               r: real64;\n          endrecord;\n```", "```\ntype\n     CharOrUns:\n          union\n               c:char;\n               u:uns32;\n          endrecord;\n\nstatic\n     v:CharOrUns;\n```", "```\nmov( eax, v.u );\n     stdout.put( \"v, as a character, is '\", v.c, \"'\" nl );\n```", "```\ntype\n     HasAnonUnion:\n          record\n               r:real64;\n               union\n                    u:uns32;\n                    i:int32;\n               endunion;\n               s:string;\n          endrecord;\n\nstatic\n     v: HasAnonUnion;\n```", "```\nv.r           0\n     v.u           8\n     v.i           8\n     v.s          12\n```", "```\ntype\n     VariantType:\n          record\n               tag:uns32;  // 0-uns32, 1-int32, 2-real64\n               union\n                    u:uns32;\n                    i:int32;\n                    r:real64;\n               endunion;\n          endrecord;\n\nstatic\n     v:VariantType;\n```", "```\nnamespace *`name`*;\n\n     << declarations >>\n\nend *`name`*;\n```", "```\nnamespace myNames;\n\n     type\n          integer: int32;\n\n     static\n          i:integer;\n          j:uns32;\n\n     const\n          pi:real64 := 3.14159;\n\nend myNames;\n```", "```\nmyNames.integer       A type declaration equivalent to int32\nmyNames.i             An integer variable (int32)\nmyNames.j             An uns32 variable\nmyNames.pi            A real64 constant\n```", "```\ntype\n     integer: int32;\n\nnamespace myNames;\n\n     static\n          i:integer;\n          j:uns32;\n\n     const\n          pi:real64 := 3.14159;\n\nend myNames;\n```", "```\ntype\n     integer: int32;\n\nnamespace myNames;\n\n     static\n          i:@global:integer;\n          j:uns32;\n\n     const\n          pi:real64 := 3.14159;\n\nend myNames;\n```", "```\nnamespace ns;\n\n     << Declaration group #1 >>\n\nend ns;\n     .\n     .\n     .\nnamespace ns;\n\n     << Declaration group #2 >>\n\nend ns;\n```", "```\nstatic\n     ArySize:                    uns32;\n     BaseAdrs:                   pointer to uns32;\n          .\n          .\n          .\n     stdout.put( \"How many elements do you want in your array? \" );\n     stdin.getu32();\n     mov( eax, ArySize );  // Save away the upper bounds on this array.\n     shl( 2, eax );        // Multiply eax by 4 to compute the number of bytes.\n     mem.alloc( eax );     // Allocate storage for the array.\n     mov( eax, BaseAdrs ); // Save away the base address of the new array.\n          .\n          .\n          .\n\n     // Zero out each element of the array:\n\n     mov( BaseAdrs, ebx );\n     mov( 0, eax );\n     for( mov(0, esi); esi < ArySize; inc( esi )) do\n\n          mov( eax, [ebx + esi*4 ]);\n\n     endfor;\n```", "```\nvar\n    ArrayPtr:   pointer to uns32;\n    ArrayDims:  uns32[2];  // The dope vector\n          .\n          .\n          .\n    // Get the array bounds from the user:\n\n    stdout.put( \"Enter the bounds for dimension #1: \" );\n    stdin.get( ArrayDims[0] );\n\n    stdout.put( \"Enter the bounds for dimension #2: \" );\n    stdin.get( ArrayDims[1*4] );\n\n    // Allocate storage for the array:\n\n    mov( ArrayDims[0], eax );\n    intmul( ArrayDims[1*4], eax );\n    shl( 2, eax );        // Multiply by 4 because each element is 4 bytes.\n    mem.alloc( eax );     // Allocate storage for the array and\n    mov( eax, ArrayPtr ); // save away the pointer to the array.\n\n    // Initialize the array:\n\n    mov( 0, edx );\n    mov( ArrayPtr, edi );\n    for( mov( 0, ebx ); ebx < ArrayDims[0]; inc( ebx )) do\n\n        for( mov( 0, ecx ); ecx < ArrayDims[1*4]; inc( ecx )) do\n\n            // Compute the index into the array\n            // as esi := ( ebx * ArrayDims[1*4] + ecx ) * 4\n            // (Note that the final multiplication by 4 is\n            //  handled by the scaled indexed addressing mode below.)\n\n            mov( ebx, esi );\n            intmul( ArrayDims[1*4], esi );\n            add( ecx, esi );\n\n            // Initialize the current array element with edx.\n\n            mov( edx, [edi+esi*4] );\n            inc( edx );\n\n        endfor;\n\n    endfor;\n```"]