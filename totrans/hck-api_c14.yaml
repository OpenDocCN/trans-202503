- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Attacking GraphQL
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击GraphQL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter will guide you through the process of attacking the Damn Vulnerable
    GraphQL Application (DVGA) using the API hacking techniques we’ve covered so far.
    We’ll begin with active reconnaissance, transition to API analysis, and conclude
    by attempting various attacks against the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将指导你通过使用我们迄今为止介绍的API黑客技术，攻击Damn Vulnerable GraphQL Application（DVGA）。我们将从主动侦察开始，过渡到API分析，并最终尝试对该应用进行各种攻击。
- en: As you’ll see, there are some major differences between the RESTful APIs we’ve
    been working with throughout this book and GraphQL APIs. I will guide you through
    these differences and demonstrate how we can leverage the same hacking techniques
    by adapting them to GraphQL. In the process, you’ll get a sense of how you might
    apply your new skills to emerging web API formats.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在本书中一直使用的RESTful API与GraphQL API之间存在一些主要区别。我将引导你了解这些区别，并演示如何通过将现有的黑客技巧调整为GraphQL，从而充分利用它们。在这个过程中，你将会感受到如何将你的新技能应用于新兴的Web
    API格式。
- en: You should treat this chapter as a hands-on lab. If you would like to follow
    along, make sure your hacking lab includes DVGA. For more information regarding
    setting up DVGA, return to Chapter 5.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将本章视为一个动手实验。如果你想跟着一起操作，确保你的黑客实验室包含DVGA。有关设置DVGA的更多信息，请回到第5章。
- en: GraphQL Requests and IDEs
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL请求与集成开发环境（IDE）
- en: In Chapter 2, we covered some of the basics of how GraphQL works. In this section,
    we’ll discuss how to use and attack GraphQL. As you proceed, remember that GraphQL
    more closely resembles SQL than REST APIs. Because GraphQL is a query language,
    using it is really just querying a database with more steps. Let’s look the request
    in [Listing 14-1](#listing14-1) and its response in [Listing 14-2](#listing14-2).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们介绍了GraphQL的一些基本概念。在本节中，我们将讨论如何使用和攻击GraphQL。在你继续操作时，请记住，GraphQL更像SQL而不是REST
    API。由于GraphQL是一种查询语言，因此使用它实际上就是对数据库进行查询，只是步骤更多一些。让我们看看[清单14-1](#listing14-1)中的请求及其在[清单14-2](#listing14-2)中的响应。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 14-1: A GraphQL request'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-1：一个GraphQL请求
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 14-2: A GraphQL response'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-2：一个GraphQL响应
- en: Unlike REST APIs, GraphQL APIs don’t use a variety of endpoints to represent
    where resources are located. Instead, all requests use POST and get sent to a
    single endpoint. The request body will contain the query and mutation, along with
    the requested types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与REST API不同，GraphQL API不使用多个端点来表示资源的位置。相反，所有请求都使用POST，并发送到一个单一的端点。请求体将包含查询和变更操作，以及请求的类型。
- en: Remember from Chapter 2 that the GraphQL *schema* is the shape in which the
    data is organized. The schema consists of types and fields. The *types* (`query`,
    `mutation`, and`subscription`) are the basic methods consumers can use to interact
    with GraphQL. While REST APIs use the HTTP request methods GET, POST, PUT, and
    DELETE to implement CRUD (create, read, update, delete) functionality, GraphQL
    instead uses `query` (to read) and `mutation` (to create, update, and delete).
    We won’t be using `subscription` in this chapter, but it is essentially a connection
    made to the GraphQL server that allows the consumer to receive real-time updates.
    You can actually build out a GraphQL request that performs both a query and mutation,
    allowing you to read and write in a single request.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得在第2章中提到，GraphQL的*模式*是数据组织的形式。模式由类型和字段组成。*类型*（`query`、`mutation`和`subscription`）是消费者与GraphQL交互的基本方法。尽管REST
    API使用HTTP请求方法GET、POST、PUT和DELETE来实现CRUD（创建、读取、更新、删除）功能，GraphQL则使用`query`（用于读取）和`mutation`（用于创建、更新和删除）。我们在本章中不会使用`subscription`，但它本质上是与GraphQL服务器建立的连接，允许消费者接收实时更新。实际上，你可以构建一个GraphQL请求，同时执行查询和变更操作，在单个请求中同时进行读写。
- en: '*Queries* begin with an object type. In our example, the object type is `products`.
    Object types contain one or more fields providing data about the object, such
    as `name` and `price` in our example. GraphQL queries can also contain arguments
    within parentheses, which help narrow down the fields you’re looking for. For
    instance, the argument in our sample request specifies that the consumer only
    wants products that have the price `"10.00"`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询*以对象类型开始。在我们的例子中，对象类型是`products`。对象类型包含一个或多个字段，提供有关该对象的数据，如我们例子中的`name`和`price`。GraphQL查询还可以包含括号中的参数，帮助缩小你查找的字段范围。例如，我们示例请求中的参数指定消费者只想要价格为`"10.00"`的产品。'
- en: As you can see, GraphQL responded to the successful query with the exact information
    requested. Many GraphQL APIs will respond to all requests with an HTTP 200 response,
    regardless of whether the query was successful. Whereas you would receive a variety
    of error response codes with a REST API, GraphQL will often send a 200 response
    and include the error within the response body.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，GraphQL对成功的查询做出了回应，并提供了请求的精确信息。许多GraphQL API都会对所有请求返回HTTP 200响应，不论查询是否成功。而使用REST
    API时，你会收到各种错误响应代码，而GraphQL通常会发送200响应，并在响应体中包含错误信息。
- en: Another major difference between REST and GraphQL is that it is fairly common
    for GraphQL providers to make an integrated development environment (IDE) available
    over their web application. A GraphQL IDE is a graphical interface that can be
    used to interact with the API. Some of the most common GraphQL IDEs are GraphiQL,
    GraphQL Playground, and the Altair Client. These GraphQL IDEs consist of a window
    to craft queries, a window to submit requests, a window for responses, and a way
    to reference the GraphQL documentation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: REST和GraphQL之间的另一个主要区别是，GraphQL提供商通常会在其Web应用程序中提供集成开发环境（IDE）。GraphQL IDE是一个图形界面，可用于与API进行交互。一些最常见的GraphQL
    IDE包括GraphiQL、GraphQL Playground和Altair Client。这些GraphQL IDE包含用于编写查询的窗口、提交请求的窗口、响应窗口以及用于引用GraphQL文档的方式。
- en: Later in this chapter, we will cover enumerating GraphQL with queries and mutations.
    For more information about GraphQL, check out the GraphQL guide at [https://graphql.org/learn](https://graphql.org/learn)
    and the additional resources provided by Dolev Farhi in the DVGA GitHub Repo.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将讨论如何通过查询和变更操作枚举GraphQL。有关GraphQL的更多信息，请查看[https://graphql.org/learn](https://graphql.org/learn)的GraphQL指南以及Dolev
    Farhi在DVGA GitHub Repo中提供的额外资源。
- en: Active Reconnaissance
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主动侦察
- en: Let’s begin by actively scanning DVGA for any information we can gather about
    it. If you were trying to uncover an organization’s attack surface rather than
    attacking a deliberately vulnerable application, you might begin with passive
    reconnaissance instead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先主动扫描DVGA，收集我们能找到的任何信息。如果你是想揭示某个组织的攻击面而不是攻击一个故意存在漏洞的应用程序，你可以先从被动侦察开始。
- en: Scanning
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扫描
- en: 'Use an Nmap scan to learn about the target host. From the following scan, we
    can see that port 5000 is open, has HTTP running on it, and uses a web application
    library called Werkzeug version 1.0.1:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Nmap扫描了解目标主机。从以下扫描结果可以看到，5000端口是开放的，并且在该端口上运行HTTP，使用的是版本为1.0.1的Werkzeug Web应用程序库：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The most important piece of information here is found in the `http-title`, which
    gives us a hint that we’re working with a GraphQL application. You won’t typically
    find indications like this in the wild, so we will ignore it for now. You might
    follow this scan with an all-ports scan to search for additional information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的信息出现在`http-title`中，它给我们一个提示，表明我们正在处理一个GraphQL应用程序。在实际环境中你通常找不到这样的提示，所以我们暂时忽略它。你可以在之后进行一次全端口扫描，以便寻找更多的信息。
- en: 'Now it’s time to perform more targeted scans. Let’s run a quick web application
    vulnerability scan using Nikto, making sure to specify that the web application
    is operating over port 5000:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是进行更有针对性的扫描的时候了。让我们使用Nikto进行快速的Web应用程序漏洞扫描，确保指定Web应用程序在5000端口上运行：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Nikto tells us that the application may have some security misconfigurations,
    such as the missing `X-Frame-Options` and undefined `X-XSS-Protection` headers.
    In addition, we’ve found that the OPTIONS, HEAD, and GET methods are allowed.
    Since Nikto did not pick up any interesting directories, we should check out the
    web application in a browser and see what we can find as an end user. Once we
    have thoroughly explored the web app, we can perform a directory brute-force attack
    to see if we can find any other directories.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Nikto告诉我们，应用程序可能存在一些安全配置错误，例如缺少`X-Frame-Options`和未定义的`X-XSS-Protection`头。此外，我们发现允许使用OPTIONS、HEAD和GET方法。由于Nikto没有发现任何有趣的目录，我们应该在浏览器中查看该Web应用程序，看看作为终端用户能发现什么。一旦我们彻底浏览了Web应用程序，就可以执行目录暴力攻击，看看是否能找到其他目录。
- en: Viewing DVGA in a Browser
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在浏览器中查看DVGA
- en: As you can see in [Figure 14-1](#figure14-1), the DVGA web page describes a
    deliberately vulnerable GraphQL application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图14-1](#figure14-1)中看到的，DVGA网页描述了一个故意存在漏洞的GraphQL应用程序。
- en: Make sure to use the site as any other user would by clicking the links located
    on the web page. Explore the Private Pastes, Public Pastes, Create Paste, Import
    Paste, and Upload Paste links. In the process, you should begin to see a few interesting
    items, such as usernames, forum posts that include IP addresses and `user-agent`
    info, a link for uploading files, and a link for creating forum posts. Already
    we have a bundle of information that could prove useful in our upcoming attacks.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 确保像其他用户一样使用该站点，点击网页上的链接。探索“私人粘贴”、“公开粘贴”、“创建粘贴”、“导入粘贴”和“上传粘贴”链接。在这个过程中，你应该开始看到一些有趣的信息，如用户名、包含IP地址和`user-agent`信息的论坛帖子、上传文件的链接，以及创建论坛帖子的链接。我们已经收集了一些可能在接下来的攻击中非常有用的信息。
- en: '![Screenshot of the Damn Vulnerable GraphQL Application homepage. Shows welcome
    and getting started messages. A sidebar shows tabs for Home, Private Pastes, and
    Public Pastes.](image_fi/502444c14/F14001.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Damn Vulnerable GraphQL Application首页的截图。显示欢迎信息和入门指南。侧边栏展示了“主页”、“私人粘贴”和“公开粘贴”标签。](image_fi/502444c14/F14001.png)'
- en: 'Figure 14-1: The DVGA landing page'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-1：DVGA登录页面
- en: Using DevTools
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用开发者工具
- en: Now that we’ve explored the site as an average user, let’s take a peek under
    the hood of the web application using DevTools. To see the different resources
    involved in this web application, navigate to the DVGA home page and open the
    Network module in DevTools. Refresh the Network module by pressing ctrl-R. You
    should see something like the interface shown in [Figure 14-2](#figure14-2).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经作为普通用户浏览了这个网站，让我们通过开发者工具（DevTools）来窥探一下这个Web应用程序的内部。要查看此Web应用程序涉及的不同资源，请导航到DVGA主页，并打开DevTools中的网络模块。通过按ctrl-R刷新网络模块。你应该会看到类似[图14-2](#figure14-2)的界面。
- en: '![Screenshot of the DevTools Network tab with a list of the headers sent in
    a request to the DVGA home page. The header “Set-Cookie: env=graphiql:disable;
    Path=/” is highlighted.](image_fi/502444c14/F14002.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![DevTools网络标签的截图，展示了请求DVGA主页时发送的头部信息列表。突出显示了“Set-Cookie: env=graphiql:disable;
    Path=/”头部。](image_fi/502444c14/F14002.png)'
- en: 'Figure 14-2: The DVGA home page’s network source file'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-2：DVGA主页的网络源文件
- en: 'Look through the response headers of the primary resource. You should see the
    header `Set-Cookie: env=graphiql:disable`, another indication that we’re interacting
    with a target that uses GraphQL. Later, we may be able to manipulate a cookie
    like this one to enable a GraphQL IDE called GraphiQL.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '查看主资源的响应头。你应该能看到`Set-Cookie: env=graphiql:disable`，这是另一个迹象，表明我们正在与一个使用GraphQL的目标进行交互。稍后，我们可能能够操控像这样的cookie，以启用一个名为GraphiQL的GraphQL集成开发环境。'
- en: Back in your browser, navigate to the Public Pastes page, open up the DevTools
    Network module, and refresh again (see [Figure 14-3](#figure14-3)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回到浏览器中，导航到公共粘贴页面，打开DevTools网络模块，并再次刷新（见[图14-3](#figure14-3)）。
- en: '![Screenshot of the DevTools Network tab set to the Preview menu. Shows the
    source code for the DVGA Public Pastes page.](image_fi/502444c14/F14003.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![DevTools网络标签在预览菜单下的截图。展示了DVGA公共粘贴页面的源代码。](image_fi/502444c14/F14003.png)'
- en: 'Figure 14-3: DVGA *public_pastes* source'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-3：DVGA *public_pastes*源
- en: There is a new source file called *graphql*. Select this source and choose the
    Preview tab. Now you will see a preview of the response for this resource. GraphQL,
    like REST, uses JSON as the syntax for transferring data. At this point, you may
    have guessed that this is a response generated using GraphQL.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个新的源文件叫做*graphql*。选择这个源并点击预览标签。现在你将看到这个资源响应的预览。GraphQL和REST一样，使用JSON作为数据传输的语法。这时，你可能已经猜到这是一个使用GraphQL生成的响应。
- en: Reverse Engineering the GraphQL API
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆向工程GraphQL API
- en: Now that we know the target app uses GraphQL, let’s try to determine the API’s
    endpoint and requests. Unlike REST APIs, whose resources are available at various
    endpoints, a host that uses GraphQL relies on only a single endpoint for its API.
    In order to interact with the GraphQL API, we must first find this endpoint and
    then figure out what we can query for.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道目标应用程序使用GraphQL，接下来让我们尝试确定API的端点和请求。与REST API不同，REST API的资源可以通过不同的端点访问，而使用GraphQL的主机仅依赖单一端点来提供其API。为了与GraphQL
    API交互，我们必须首先找到这个端点，然后弄清楚我们可以查询哪些内容。
- en: Directory Brute-Forcing for the GraphQL Endpoint
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对GraphQL端点的目录暴力破解
- en: 'A directory brute-force scan using Gobuster or Kiterunner can tell us if there
    are any GraphQL-related directories. Let’s use Kiterunner to find these. If you
    were searching for GraphQL directories manually, you could add keywords like the
    following in the requested path:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gobuster 或 Kiterunner 进行目录暴力破解扫描，可以帮助我们找出是否存在与 GraphQL 相关的目录。让我们使用 Kiterunner
    来查找这些目录。如果你手动搜索 GraphQL 目录，可以在请求路径中加入以下关键字：
- en: '*/graphql*'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/graphql*'
- en: '*/v1/graphql*'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/v1/graphql*'
- en: '*/api/graphql*'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/api/graphql*'
- en: '*/v1/api/graphql*'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/v1/api/graphql*'
- en: '*/graph*'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/graph*'
- en: '*/v1/graph*'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/v1/graph*'
- en: '*/graphiql*'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/graphiql*'
- en: '*/v1/graphiql*'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/v1/graphiql*'
- en: '*/console*'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/console*'
- en: '*/query*'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/query*'
- en: '*/graphql/console*'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/graphql/console*'
- en: '*/altair*'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/altair*'
- en: '*/playground*'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/playground*'
- en: Of course, you should also try replacing the version numbers in any of these
    paths with */v2*, */v3*, */test*, */internal*, */mobile*, */legacy*, or any variation
    of these paths. For example, both Altair and Playground are alternative IDEs to
    GraphiQL that you could search for with various versioning in the path.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也应该尝试将这些路径中的版本号替换为 */v2*、*/v3*、*/test*、*/internal*、*/mobile*、*/legacy*，或者这些路径的任何变体。例如，Altair
    和 Playground 都是 GraphiQL 的替代 IDE，你可以通过路径中的不同版本来搜索它们。
- en: 'SecLists can also help us automate this directory search:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: SecLists 还可以帮助我们自动化这个目录搜索：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We receive two relevant results from this scan; however, both currently respond
    with an HTTP 400 Bad Request status code. Let’s check them in the web browser.
    The */graphql* path resolves to a JSON response page with the message `"Must provide
    query string."` (see [Figure 14-4](#figure14-4)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这次扫描中得到两个相关的结果；不过，目前它们都回应了一个 HTTP 400 错误请求状态码。让我们在 Web 浏览器中查看它们。*/graphql*
    路径解析为一个 JSON 响应页面，页面中显示 `"Must provide query string."` 消息（见 [图 14-4](#figure14-4)）。
- en: '![Screenshot of the /graphql path of the DVGA app. Shows the JSON message “Must
    provide query string.”](image_fi/502444c14/F14004.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![DVGA 应用程序的 /graphql 路径截图，显示 JSON 消息 “Must provide query string.”](image_fi/502444c14/F14004.png)'
- en: 'Figure 14-4: The DVGA */graphql* path'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-4：DVGA */graphql* 路径
- en: This doesn’t give us much to work with, so let’s check out the */graphiql* endpoint.
    As you can see in [Figure 14-5](#figure14-5), the */graphiql* path leads us to
    the web IDE often used for GraphQL, GraphiQL.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有给我们提供太多信息，所以让我们检查一下 */graphiql* 端点。正如你在 [图 14-5](#figure14-5) 中看到的，*/graphiql*
    路径将我们引导到一个常用于 GraphQL 的 Web IDE，GraphiQL。
- en: '![Screenshot of the /graphiql page of the DVGA app. Shows a GraphiQL IDE.](image_fi/502444c14/F14005.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![DVGA 应用程序的 /graphiql 页面截图，显示 GraphiQL IDE。](image_fi/502444c14/F14005.png)'
- en: 'Figure 14-5: The DVGA GraphiQL web IDE'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-5：DVGA GraphiQL Web IDE
- en: 'However, we are met with the message `"400 Bad Request: GraphiQL Access Rejected"`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，我们遇到了 `"400 Bad Request: GraphiQL Access Rejected"` 的消息。'
- en: In the GraphiQL web IDE, the API documentation is normally located on the top
    right of the page, under a button called Docs. If you click the Docs button, you
    should see the Documentation Explorer window, shown on the right side of [Figure
    14-5](#figure14-5). This information could be helpful for crafting requests. Unfortunately,
    due to our bad request, we do not see any documentation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphiQL Web IDE 中，API 文档通常位于页面右上方，按钮名为 Docs。如果你点击 Docs 按钮，你应该会看到右侧的文档资源管理器窗口，如
    [图 14-5](#figure14-5) 所示。这些信息可能有助于构建请求。不幸的是，由于我们的请求错误，我们看不到任何文档。
- en: There is a chance we’re not authorized to access the documentation due to the
    cookies included in our request. Let’s see if we can alter the `env=graphiql:disable`
    cookie we spotted back at the bottom of [Figure 14-2](#figure14-2).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有可能因为请求中的 cookies 而没有授权访问文档。让我们看看是否可以更改我们在 [图 14-2](#figure14-2) 底部看到的 `env=graphiql:disable`
    cookie。
- en: Cookie Tampering to Enable the GraphiQL IDE
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用 Cookie 篡改来启用 GraphiQL IDE
- en: 'Let’s capture a request to */graphiql* using the Burp Suite Proxy to see what
    we’re working with. As usual, you can proxy the request to be intercepted through
    Burp Suite. Make sure Foxy Proxy is on and then refresh the */graphiql* page in
    your browser. Here is the request you should intercept:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Burp Suite Proxy 捕获一个请求到 */graphiql*，看看我们在处理什么内容。像往常一样，你可以通过 Burp Suite
    将请求代理进行拦截。确保 Foxy Proxy 已开启，然后刷新浏览器中的 */graphiql* 页面。以下是你应该拦截的请求：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In reviewing the request, one thing you should notice is that the `env` variable
    is base64 encoded. Paste the value into Burp Suite’s Decoder and then decode the
    value as base64\. You should see the decoded value as `graphiql:disable`. This
    is the same value we noticed when viewing DVGA in DevTools.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查请求时，你应该注意到 `env` 变量是 base64 编码的。将该值粘贴到 Burp Suite 的解码器中，然后将其解码为 base64。你应该会看到解码后的值为
    `graphiql:disable`。这与我们在 DevTools 查看 DVGA 时注意到的值相同。
- en: Let’s take this value and try altering it to `graphiql:enable`. Since the original
    value was base64 encoded, let’s encode the new value back to base64 (see [Figure
    14-6](#figure14-6)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿这个值并尝试将其改为`graphiql:enable`。由于原始值是base64编码的，让我们将新的值重新编码为base64（见[图14-6](#figure14-6)）。
- en: '![Screenshot of Burp Suite’s Decoder with a string decoded to “graphiql:enable”](image_fi/502444c14/F14006.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite的解码器截图，解码后的字符串为“graphiql:enable”](image_fi/502444c14/F14006.png)'
- en: 'Figure 14-6: Burp Suite’s Decoder'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-6：Burp Suite的解码器
- en: You can test out this updated cookie in Repeater to see what sort of response
    you receive. To be able to use GraphiQL in the browser, you’ll need to update
    the cookie saved in your browser. Open the DevTools Storage panel to edit the
    cookie (see [Figure 14-7](#figure14-7)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Repeater中测试更新后的cookie，看看你会收到什么响应。为了在浏览器中使用GraphiQL，你需要更新浏览器中保存的cookie。打开开发者工具存储面板以编辑cookie（见[图14-7](#figure14-7)）。
- en: '![Screenshot of the DevTools storage panel showing a list of cookies and their
    values](image_fi/502444c14/F14007.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![开发者工具存储面板截图，显示一列cookie及其值](image_fi/502444c14/F14007.png)'
- en: 'Figure 14-7: Cookies in DevTools'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-7：开发者工具中的Cookies
- en: Once you’ve located the `env` cookie, double-click the value and replace it
    with the new one. Now return to the GraphiQL IDE and refresh the page. You should
    now be able to use the GraphiQL interface and Documentation Explorer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了`env` cookie，双击其值并用新的值替换它。现在返回到GraphiQL IDE并刷新页面。你应该能够使用GraphiQL界面和文档浏览器。
- en: Reverse Engineering the GraphQL Requests
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向工程GraphQL请求
- en: Although we know the endpoints we want to target, we still don’t know the structure
    of the API’s requests. One major difference between REST and GraphQL APIs is that
    GraphQL operates using POST requests only.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们知道我们想要访问的端点，但我们仍然不知道API请求的结构。REST和GraphQL API之间的一个主要区别是，GraphQL仅使用POST请求。
- en: Let’s intercept these requests in Postman so we can better manipulate them.
    First, set your browser’s proxy to forward traffic to Postman. If you followed
    the setup instructions back in Chapter 4, you should be able to set FoxyProxy
    to “Postman.” [Figure 14-8](#figure14-8) shows Postman’s Capture requests and
    cookies screen.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们在Postman中拦截这些请求，以便更好地操作它们。首先，将浏览器的代理设置为转发流量到Postman。如果你按照第4章中的设置说明操作，你应该能够将FoxyProxy设置为“Postman”。[图14-8](#figure14-8)展示了Postman的捕获请求和cookie页面。 '
- en: '![Screenshot of the Postman “Capture requests and cookies” page with “Capture
    requests” set to On](image_fi/502444c14/F14008.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Postman“捕获请求和cookie”页面截图，其中“捕获请求”设置为开启](image_fi/502444c14/F14008.png)'
- en: 'Figure 14-8: Postman’s Capture requests and cookies screen'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-8：Postman的捕获请求和cookie页面
- en: Now let’s reverse engineer this web application by manually navigating to every
    link and using every feature we’ve discovered. Click around and submit some data.
    Once you’ve thoroughly used the web app, open Postman to see what your collection
    looks like. You’ve likely collected requests that do not interact with the target
    API. Make sure to delete any that do not include either */graphiql* or */graphql*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过手动访问每个链接并使用我们已发现的每个功能来反向工程这个Web应用。点击四周并提交一些数据。使用完这个Web应用后，打开Postman查看你的集合是什么样子的。你可能已经收集了一些不与目标API交互的请求。确保删除所有不包含*/graphiql*或*/graphql*的请求。
- en: However, as you can see in [Figure 14-9](#figure14-9), even if you delete all
    requests that don’t involve */graphql*, their purposes aren’t so clear. In fact,
    many of them look identical. Because GraphQL requests function solely using the
    data in the body of the POST request rather than the request’s endpoint, we’ll
    have to review the body of the request to get an idea of what these requests do.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你在[图14-9](#figure14-9)中看到的，即使你删除了所有不涉及*/graphql*的请求，它们的目的仍然不太清晰。事实上，许多请求看起来一模一样。因为GraphQL请求完全通过POST请求的主体数据来操作，而不是通过请求的端点，因此我们必须检查请求的主体内容，才能了解这些请求的作用。
- en: '![Screenshot of identical-looking POST requests saved in Postman](image_fi/502444c14/F14009.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Postman中看起来相同的POST请求截图](image_fi/502444c14/F14009.png)'
- en: 'Figure 14-9: An unclear GraphQL Postman collection'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-9：不明确的GraphQL Postman集合
- en: 'Take the time to go through the body of each of these requests and then rename
    each request so you can see what it does. Some of the request bodies may seem
    intimidating; if so, extract a few key details from them and give them a temporary
    name until you understand them better. For instance, take the following request:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间仔细查看每个请求的主体，然后重新命名每个请求，以便你能理解它的作用。某些请求体可能看起来很复杂；如果是这样，从中提取一些关键信息并给它们一个临时名称，直到你更好地理解它们。例如，考虑以下请求：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*There is a lot of information here, but we can pick out a few details from
    the beginning of the request body and give it a name (for example, Graphiql Query
    Introspection SubscriptionType). The next request looks very similar, but instead
    of `subscriptionType`, the request includes only `types`, so let’s name it based
    on that difference, as shown in [Figure 14-10](#figure14-10).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里有很多信息，但我们可以从请求体的开头提取一些细节，并给它命名（例如，Graphiql 查询反射类型）。下一个请求看起来非常相似，但它包含的不是`subscriptionType`，而是只有`types`，因此我们可以根据这个差异给它命名，如[图
    14-10](#figure14-10)所示。*'
- en: '![Screenshot of a list of POST requests renamed descriptively in Postman](image_fi/502444c14/F14010.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 中一系列被描述性重命名的 POST 请求截图](image_fi/502444c14/F14010.png)'
- en: 'Figure 14-10: A cleaned-up DVGA collection'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-10：已清理的 DVGA 集合
- en: Now you have a basic collection with which to conduct testing. As you learn
    more about the API, you will further build your collection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有了一个基本的集合可以进行测试。随着你对 API 了解得更多，你将进一步构建你的集合。
- en: 'Before we continue, we’ll cover another method of reverse engineering GraphQL
    requests: obtaining the schema using introspection.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将介绍另一种逆向工程 GraphQL 请求的方法：通过反射获取模式。
- en: Reverse Engineering a GraphQL Collection Using Introspection
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用反射进行 GraphQL 集合的逆向工程
- en: Introspection is a feature of GraphQL that reveals the API’s entire schema to
    the consumer, making it a gold mine when it comes to information disclosure. For
    this reason, you’ll often find introspection disabled and will have to work a
    lot harder to attack the API. If, however, you can query the schema, you’ll be
    able to operate as though you’ve found a collection or specification file for
    a REST API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是 GraphQL 的一个特性，它向消费者揭示了整个 API 的模式，使其在信息泄露方面成为一座宝矿。因此，你常常会发现反射被禁用，这意味着你需要付出更多的努力来攻击
    API。不过，如果你可以查询到模式，就能像找到了 REST API 的集合或规范文件一样操作。
- en: Testing for introspection is as simple as sending an introspection query. If
    you’re authorized to use the DVGA GraphiQL interface, you can capture the introspection
    query by intercepting the requests made when loading */graphiql*, because the
    GraphiQL interface sends an introspection query when populating the Documentation
    Explorer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 测试反射是否可用非常简单，只需发送一个反射查询。如果你有权限使用 DVGA GraphiQL 界面，可以通过拦截加载*/graphiql*时发出的请求来捕获反射查询，因为
    GraphiQL 界面在填充文档浏览器时会发送反射查询。
- en: The full introspection query is quite large, so I’ve only included a portion
    here; however, you can see it in its entirety by intercepting the request yourself
    or checking it out on the Hacking APIs GitHub repo at [https://github.com/hAPI-hacker/Hacking-APIs](https://github.com/hAPI-hacker/Hacking-APIs).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的反射查询相当大，因此我这里只包含了一部分；不过，你可以通过自己拦截请求或在 Hacking APIs GitHub 仓库中查看完整查询，网址为[https://github.com/hAPI-hacker/Hacking-APIs](https://github.com/hAPI-hacker/Hacking-APIs)。
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A successful GraphQL introspection query will provide you with all the types
    and fields contained within the schema. You can use the schema to build a Postman
    collection. If you’re using GraphiQL, the query will populate the GraphiQL Documentation
    Explorer. As you’ll see in the next sections, the GraphiQL Documentation Explorer
    is a tool for seeing the types, fields, and arguments available in the GraphQL
    documentation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的 GraphQL 反射查询会向你提供模式中包含的所有类型和字段。你可以使用该模式来构建 Postman 集合。如果你使用的是 GraphiQL，查询将填充
    GraphiQL 文档浏览器。正如你在接下来的章节中会看到的，GraphiQL 文档浏览器是一个用于查看 GraphQL 文档中可用的类型、字段和参数的工具。
- en: GraphQL API Analysis
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL API 分析
- en: At this point, we know that we can make requests to a GraphQL endpoint and the
    GraphiQL interface. We’ve also reverse engineered several GraphQL requests and
    gained access to the GraphQL schema through the use of a successful introspection
    query. Let’s use the Documentation Explorer to see if there is any information
    we might leverage for exploitation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道可以向 GraphQL 端点和 GraphiQL 界面发送请求。我们还反向工程了几个 GraphQL 请求，并通过成功的自省查询获得了
    GraphQL 架构的访问权限。让我们使用文档浏览器查看是否有任何我们可以利用的资料进行利用。
- en: Crafting Requests Using the GraphiQL Documentation Explorer
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 GraphiQL 文档浏览器构建请求
- en: Take one of the requests we reverse engineered from Postman, such as the request
    for Public Pastes used to generate the *public_pastes* web page, and test it out
    using the GraphiQL IDE. Use the Documentation Explorer to help you build your
    query. Under **Root Types**, select **Query**. You should see the same options
    displayed in [Figure 14-11](#figure14-11).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 拿出我们从 Postman 反向工程的请求之一，例如用于生成 *public_pastes* 网页的公共粘贴请求，并使用 GraphiQL IDE 进行测试。使用文档浏览器帮助您构建查询。在
    **Root Types** 下选择 **Query**。您应该看到与 [图 14-11](#figure14-11) 中显示的选项相同。
- en: '![Screenshot of the GraphiQL IDE with a search bar open and information about
    query formats visible](image_fi/502444c14/F14011.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![GraphiQL IDE 截图，搜索框已打开，查询格式的信息可见](image_fi/502444c14/F14011.png)'
- en: 'Figure 14-11: The GraphiQL Documentation Explorer'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-11：GraphiQL 文档浏览器
- en: 'Using the GraphiQL query panel, enter `query` followed by curly brackets to
    initiate the GraphQL request. Now query for the public pastes field by adding
    `pastes` under `query` and using parentheses for the argument `public: true`.
    Since we’ll want to know more about the public pastes object, we’ll need to add
    fields to the query. Each field we add to the request will tell us more about
    the object. To do this, select **PasteObject** in the Documentation Explorer to
    view these fields. Finally, add the fields that you would like to include in your
    request body, separated by new lines. The fields you include represent the different
    data objects you should receive back from the provider. In my request I’ll add
    `title`, `content`, `public`, `ipAddr`, and `pId`, but feel free to experiment
    with your own fields. Your completed request body should look like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 GraphiQL 查询面板，输入 `query` 后跟花括号以启动 GraphQL 请求。现在通过在 `query` 下添加 `pastes`
    并使用括号作为参数 `public: true` 来查询公共粘贴字段。由于我们想了解更多关于公共粘贴对象的信息，我们需要在查询中添加字段。我们向请求中添加的每个字段都会告诉我们更多关于该对象的信息。为此，在文档浏览器中选择
    **PasteObject** 查看这些字段。最后，添加您希望包含在请求正文中的字段，并以新行分隔。您包含的字段代表您应该从提供者那里接收到的不同数据对象。在我的请求中，我将添加
    `title`、`content`、`public`、`ipAddr` 和 `pId`，但也可以尝试添加您自己的字段。完成的请求正文应该如下所示：'
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Send the request by using the **Execute Query** button or the shortcut ctrl-enter.
    If you’ve followed along, you should receive a response like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Execute Query** 按钮或快捷键 ctrl-enter 发送请求。如果您跟随操作，应该会收到如下响应：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that you have an idea of how to request data using GraphQL, let’s transition
    to Burp Suite and use a great extension to help us flesh out what can be done
    with DVGA.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何使用 GraphQL 请求数据，让我们转到 Burp Suite，并使用一个很棒的扩展来帮助我们完善在 DVGA 中可以做的事情。
- en: Using the InQL Burp Extension
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 InQL Burp 扩展
- en: Sometimes, you won’t find any GraphiQL IDE to work with on your target. Luckily
    for us, an amazing Burp Suite extension can help. InQL acts as an interface to
    GraphQL within Burp Suite. To install it, as you did for the IP Rotate extension
    in the previous chapter, you’ll need to select Jython in the Extender options.
    Refer to Chapter 13 for the Jython installation steps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能找不到适用于目标的 GraphiQL IDE。幸运的是，有一个很棒的 Burp Suite 扩展可以帮助我们。InQL 作为 Burp Suite
    中的 GraphQL 接口。要安装它，像在上一章中为 IP Rotate 扩展所做的那样，您需要在 Extender 选项中选择 Jython。有关 Jython
    安装步骤，请参见第 13 章。
- en: Once you’ve installed InQL, select the InQL Scanner and add the URL of the GraphQL
    API you’re targeting (see [Figure 14-12](#figure14-12)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 InQL 后，选择 InQL 扫描器并添加您要针对的 GraphQL API 的 URL（参见 [图 14-12](#figure14-12)）。
- en: The scanner will automatically find various queries and mutations and save them
    into a file structure. You can then select these saved requests and send them
    to Repeater for additional testing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描器将自动查找各种查询和变更并将它们保存到文件结构中。然后，您可以选择这些保存的请求并将它们发送到 Repeater 进行进一步测试。
- en: '![Screenshot of the InQL screenshot in Burp with the paste.query GraphQL query
    visible](image_fi/502444c14/F14012.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Burp 中的 InQL 截图，显示可见的 paste.query GraphQL 查询](image_fi/502444c14/F14012.png)'
- en: 'Figure 14-12: The InQL Scanner module in Burp Suite'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-12：Burp Suite 中的 InQL 扫描模块
- en: Let’s practice testing different requests. The `paste.query` is a query used
    to find pastes by their paste ID (pID) code. If you posted any public pastes in
    the web application, you can see your pID values. What if we used an authorization
    attack against the pID field by requesting pIDs that were meant to be private?
    This would constitute a BOLA attack. Since these paste IDs appear to be sequential,
    we’ll want to test for any authorization restrictions preventing us from accessing
    the private posts of other users.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习测试不同的请求。`paste.query` 是一个查询，用于根据粘贴 ID（pID）代码查找粘贴。如果你在 Web 应用程序中发布了任何公共粘贴，你可以看到你的
    pID 值。如果我们通过请求本应私密的 pID 字段进行授权攻击，会发生什么呢？这将构成 BOLA 攻击。由于这些粘贴 ID 似乎是连续的，我们需要测试是否存在任何授权限制，防止我们访问其他用户的私密粘贴。
- en: 'Right-click `paste.query` and send it to Repeater. Edit the `code*` value by
    replacing it with a pID that should work. I’ll use the pID 166, which I received
    earlier. Send the request with Repeater. You should receive a response like the
    following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `paste.query` 并将其发送到 Repeater。通过将 `code*` 值替换为应有效的 pID 来编辑它。我将使用之前收到的 pID
    166。使用 Repeater 发送请求。你应该会收到如下响应：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Sure enough, the application responds with the public paste I had previously
    submitted.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，应用程序回应了我之前提交的公共粘贴。
- en: If we’re able to request pastes by pID, maybe we can brute-force the other pIDs
    to see if there are authorization requirements that prevent us from requesting
    private pastes. Send the paste request in [Figure 14-12](#figure14-12) to Intruder
    and then set the pID value to be the payload position. Change the payload to a
    number value starting at 0 and going to 166 and then start the attack.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够通过 pID 请求粘贴，也许我们可以暴力破解其他 pID 来看看是否有授权要求，阻止我们请求私密粘贴。将图 [14-12](#figure14-12)
    中的粘贴请求发送到 Intruder，然后将 pID 值设置为有效负载位置。将有效负载更改为从 0 开始到 166 的数字值，然后启动攻击。
- en: 'Reviewing the results reveals that we’ve discovered a BOLA vulnerability. We
    can see that we’ve received private data, as indicated by the `"public": false`
    field:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '审查结果显示我们已经发现了 BOLA 漏洞。我们可以看到我们已收到私密数据，如 `"public": false` 字段所示：'
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’re able to retrieve every private paste by requesting different pIDs. Congratulations,
    this is a great find! Let’s see what else we can discover.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够通过请求不同的 pID 来检索每一个私密粘贴。恭喜，这是一个很棒的发现！让我们看看还能发现些什么。
- en: Fuzzing for Command Injection
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令注入的模糊测试
- en: Now that we’ve analyzed the API, let’s fuzz it for vulnerabilities to see if
    we can conduct an attack. Fuzzing GraphQL can pose an additional challenge, as
    most requests result in a 200 status code, even if they were formatted incorrectly.
    Therefore, we’ll need to look for other indicators of success.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分析了 API，接下来让我们进行模糊测试，看看是否能发现漏洞进行攻击。模糊测试 GraphQL 可能会增加额外的挑战，因为大多数请求即使格式不正确，也会返回
    200 状态码。因此，我们需要寻找其他成功的指示符。
- en: You’ll find any errors in the response body, and you’ll need to build a baseline
    for what these look like by reviewing the responses. Check whether errors all
    generate the same response length, for example, or if there are other significant
    differences between a successful response and a failed one. Of course, you should
    also review error responses for information disclosures that can aid your attack.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在响应体中发现任何错误，需要通过查看响应来构建这些错误的基准。检查错误是否都生成相同的响应长度，例如，或者是否在成功响应和失败响应之间有其他显著差异。当然，你还应该查看错误响应，查找可能有助于攻击的信息泄露。
- en: Since the query type is essentially read-only, we’ll attack the mutation request
    types. First, let’s take one of the mutation requests, such as the `Mutation ImportPaste`
    request, in our DVGA collection and intercept it with Burp Suite. You should see
    an interface similar to [Figure 14-13](#figure14-13).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于查询类型本质上是只读的，我们将攻击变更请求类型。首先，让我们拿一个变更请求，比如我们 DVGA 集合中的 `Mutation ImportPaste`
    请求，并使用 Burp Suite 对其进行拦截。你应该看到一个类似于[图 14-13](#figure14-13)的界面。
- en: '![Screenshot of a POST request in Burp Suite with a GraphQL query in the request
    body](image_fi/502444c14/F14013.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite 中的 POST 请求截图，带有请求体中的 GraphQL 查询](image_fi/502444c14/F14013.png)'
- en: 'Figure 14-13: An intercepted GraphQL mutation request'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-13：一个拦截的 GraphQL 变更请求
- en: 'Send this request to Repeater to see the sort of response we should expect
    to see. You should receive a response like the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将此请求发送到 Repeater，以查看我们应该期望看到的响应类型。你应该会收到如下所示的响应：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I happen to have tested the request by using [http://www.google.com/](http://www.google.com/)
    as my URL for importing pastes; you might have a different URL in the request.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我恰好使用 [http://www.google.com/](http://www.google.com/) 作为我导入粘贴内容的 URL 来测试请求；你可能在请求中使用了不同的
    URL。
- en: 'Now that we have an idea of how GraphQL will respond, let’s forward this request
    to Intruder. Take a closer look at the body of the request:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们大致了解了 GraphQL 的响应方式，让我们将此请求转发给 Intruder。仔细查看请求的主体：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice that this request contains variables, each of which is preceded by `$`
    and followed by `!`. The corresponding keys and values are at the bottom of the
    request, following `"variables"`. We’ll place our payload positions here, because
    these values contain user input that could be passed to backend processes, making
    them an ideal target for fuzzing. If any of these variables lack good input validation
    controls, we’ll be able to detect a vulnerability and potentially exploit the
    weakness. We’ll place our payload positions within this variables section:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此请求包含变量，每个变量前面都有 `$`，后面跟着 `!`。相应的键和值位于请求的底部，跟随 `"variables"`。我们将在这里放置有效载荷位置，因为这些值包含可能传递给后台进程的用户输入，使它们成为模糊测试的理想目标。如果这些变量缺乏良好的输入验证控制，我们就能检测到漏洞并可能利用这个弱点。我们将在这些变量部分放置我们的有效载荷位置：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, configure your two payload sets. For the first payload, let’s take a
    sample of metacharacters from Chapter 12:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，配置你的两组有效载荷。对于第一组有效载荷，我们从第 12 章中取一个元字符示例：
- en: '`|`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`|`'
- en: '`||`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`||`'
- en: '`&`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`'
- en: '`&&`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`'
- en: '`''`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`''`'
- en: '`"`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`"`'
- en: '`;`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`;`'
- en: '`''"`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`''"`'
- en: 'For the second payload set, let’s use a sample of potential injection payloads,
    also from Chapter 12:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二组有效载荷，我们使用来自第 12 章的潜在注入有效载荷示例：
- en: '`whoami`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`whoami`'
- en: '`{"$where": "sleep(1000) "}`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`{"$where": "sleep(1000) "}`'
- en: '`;%00`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`;%00`'
- en: '`-- -`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`-- -`'
- en: Finally, make sure payload encoding is disabled.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保禁用有效载荷编码。
- en: Now let’s run our attack against the host variable. As you can see in [Figure
    14-14](#figure14-14), the results are uniform, and there were no anomalies. All
    the status codes and response lengths were identical.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对主机变量进行攻击。如你在[图 14-14](#figure14-14)中看到的，结果是一致的，没有出现异常。所有的状态代码和响应长度都相同。
- en: You can review the responses to see what they consisted of, but from this initial
    scan, there doesn’t appear to be anything interesting.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看响应以了解它们的内容，但从这次初步扫描来看，似乎没有什么有趣的东西。
- en: 'Now let’s target the `"path"` variable:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们瞄准 `"path"` 变量：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![Screenshot of fuzzing results in Burp Suite showing 200 response codes only](image_fi/502444c14/F14014.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite 中模糊测试结果的截图，显示只有 200 响应代码](image_fi/502444c14/F14014.png)'
- en: 'Figure 14-14: Intruder results for an attack on the host variable'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-14：对主机变量攻击的入侵者结果
- en: We’ll use the same payloads as the first attack. As you can see in [Figure 14-15](#figure14-15),
    not only do we receive a variety of response codes and lengths, but we also receive
    indicators of successful code execution.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与第一次攻击相同的有效载荷。正如你在[图 14-15](#figure14-15)中看到的，我们不仅收到了各种响应代码和长度，还收到了成功执行代码的指示。
- en: '![Screenshot of fuzzing results in Burp Suite showing a response body containing
    data returned from a GraphQL query](image_fi/502444c14/F14015.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite 中模糊测试结果的截图，显示包含来自 GraphQL 查询返回的数据的响应体](image_fi/502444c14/F14015.png)'
- en: 'Figure 14-15: Intruder results for an attack on the `"path"` variable'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-15：对 `"path"` 变量攻击的入侵者结果
- en: Digging through the responses, you can see that several of them were susceptible
    to the `whoami` command. This suggests that the `"path"` variable is vulnerable
    to operating system injection. In addition, the user that the command revealed
    is the privileged user, `root`, an indication that the app is running on a Linux
    host. You can update your second set of payloads to include the Linux commands
    `uname -a` and `ver` to see which operating system you are interacting with.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看响应，你可以发现其中有几个响应容易受到 `whoami` 命令的影响。这表明 `"path"` 变量容易受到操作系统注入的攻击。此外，命令返回的用户是特权用户
    `root`，这表明该应用程序正在运行在 Linux 主机上。你可以更新你的第二组有效载荷，包含 Linux 命令 `uname -a` 和 `ver` 来查看你正在与哪个操作系统进行交互。
- en: Once you’ve discovered the operating system, you can perform more targeted attacks
    to obtain sensitive information from the system. For example, in the request shown
    in [Listing 14-3](#listing14-3), I’ve replaced the `"path"` variable with `/;
    cat /etc/passwd`, which will attempt to make the operating system return the */etc/passwd*
    file containing a list of the accounts on the host system, shown in [Listing 14-4](#listing14-4).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你发现了操作系统，你就可以进行更有针对性的攻击，以获取系统中的敏感信息。例如，在[列表14-3](#listing14-3)中显示的请求中，我将`"path"`变量替换为`/;
    cat /etc/passwd`，这将尝试让操作系统返回包含主机系统账户列表的*/etc/passwd*文件，如[列表14-4](#listing14-4)所示。
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 14-3: The request'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-3：请求
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 14-4: The response'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-4：响应
- en: You now have the ability to execute all commands as the root user within the
    Linux operating system. Just like that, we’re able to inject system commands using
    a GraphQL API. From here, we could continue to enumerate information using this
    command injection vulnerability or else use commands to obtain a shell to the
    system. Either way, this is a very significant finding. Good job exploiting a
    GraphQL API!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经能够在Linux操作系统中以root用户身份执行所有命令。就这样，我们能够通过GraphQL API注入系统命令。从这里开始，我们可以继续利用这个命令注入漏洞枚举信息，或者使用命令获取系统的shell。无论哪种方式，这都是一个非常重要的发现。干得好，成功利用了GraphQL
    API！
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we walked through an attack of a GraphQL API using some of
    the techniques covered in this book. GraphQL operates differently than the REST
    APIs we’ve worked with up to this point. However, once we adapted a few things
    to GraphQL, we were able to apply many of the same techniques to perform some
    awesome exploits. Don’t be intimidated by new API types you might encounter; instead,
    embrace the tech, learn how it operates, and then experiment with the API attacks
    you’ve already learned.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们通过一些本书中讲解的技术，演示了如何攻击一个GraphQL API。GraphQL的工作方式与我们之前接触过的REST API不同。然而，一旦我们对GraphQL做了一些调整，我们就能够应用许多相同的技术，进行一些非常酷的攻击。不要被你可能遇到的新API类型吓倒；相反，拥抱这项技术，了解它的运作方式，然后尝试你已经学到的API攻击。
- en: DVGA has several more vulnerabilities we didn’t cover in this chapter. I recommend
    that you return to your lab and exploit them. In the final chapter, I’ll present
    real-world breaches and bounties involving APIs.*
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: DVGA还有几个漏洞我们在这一章没有覆盖。我建议你返回实验室，利用这些漏洞。在最后一章，我将展示一些涉及API的真实世界泄露和赏金案例。
