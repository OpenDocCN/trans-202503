- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attacking GraphQL
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter will guide you through the process of attacking the Damn Vulnerable
    GraphQL Application (DVGA) using the API hacking techniques we’ve covered so far.
    We’ll begin with active reconnaissance, transition to API analysis, and conclude
    by attempting various attacks against the application.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see, there are some major differences between the RESTful APIs we’ve
    been working with throughout this book and GraphQL APIs. I will guide you through
    these differences and demonstrate how we can leverage the same hacking techniques
    by adapting them to GraphQL. In the process, you’ll get a sense of how you might
    apply your new skills to emerging web API formats.
  prefs: []
  type: TYPE_NORMAL
- en: You should treat this chapter as a hands-on lab. If you would like to follow
    along, make sure your hacking lab includes DVGA. For more information regarding
    setting up DVGA, return to Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL Requests and IDEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 2, we covered some of the basics of how GraphQL works. In this section,
    we’ll discuss how to use and attack GraphQL. As you proceed, remember that GraphQL
    more closely resembles SQL than REST APIs. Because GraphQL is a query language,
    using it is really just querying a database with more steps. Let’s look the request
    in [Listing 14-1](#listing14-1) and its response in [Listing 14-2](#listing14-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-1: A GraphQL request'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-2: A GraphQL response'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike REST APIs, GraphQL APIs don’t use a variety of endpoints to represent
    where resources are located. Instead, all requests use POST and get sent to a
    single endpoint. The request body will contain the query and mutation, along with
    the requested types.
  prefs: []
  type: TYPE_NORMAL
- en: Remember from Chapter 2 that the GraphQL *schema* is the shape in which the
    data is organized. The schema consists of types and fields. The *types* (`query`,
    `mutation`, and`subscription`) are the basic methods consumers can use to interact
    with GraphQL. While REST APIs use the HTTP request methods GET, POST, PUT, and
    DELETE to implement CRUD (create, read, update, delete) functionality, GraphQL
    instead uses `query` (to read) and `mutation` (to create, update, and delete).
    We won’t be using `subscription` in this chapter, but it is essentially a connection
    made to the GraphQL server that allows the consumer to receive real-time updates.
    You can actually build out a GraphQL request that performs both a query and mutation,
    allowing you to read and write in a single request.
  prefs: []
  type: TYPE_NORMAL
- en: '*Queries* begin with an object type. In our example, the object type is `products`.
    Object types contain one or more fields providing data about the object, such
    as `name` and `price` in our example. GraphQL queries can also contain arguments
    within parentheses, which help narrow down the fields you’re looking for. For
    instance, the argument in our sample request specifies that the consumer only
    wants products that have the price `"10.00"`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, GraphQL responded to the successful query with the exact information
    requested. Many GraphQL APIs will respond to all requests with an HTTP 200 response,
    regardless of whether the query was successful. Whereas you would receive a variety
    of error response codes with a REST API, GraphQL will often send a 200 response
    and include the error within the response body.
  prefs: []
  type: TYPE_NORMAL
- en: Another major difference between REST and GraphQL is that it is fairly common
    for GraphQL providers to make an integrated development environment (IDE) available
    over their web application. A GraphQL IDE is a graphical interface that can be
    used to interact with the API. Some of the most common GraphQL IDEs are GraphiQL,
    GraphQL Playground, and the Altair Client. These GraphQL IDEs consist of a window
    to craft queries, a window to submit requests, a window for responses, and a way
    to reference the GraphQL documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will cover enumerating GraphQL with queries and mutations.
    For more information about GraphQL, check out the GraphQL guide at [https://graphql.org/learn](https://graphql.org/learn)
    and the additional resources provided by Dolev Farhi in the DVGA GitHub Repo.
  prefs: []
  type: TYPE_NORMAL
- en: Active Reconnaissance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin by actively scanning DVGA for any information we can gather about
    it. If you were trying to uncover an organization’s attack surface rather than
    attacking a deliberately vulnerable application, you might begin with passive
    reconnaissance instead.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use an Nmap scan to learn about the target host. From the following scan, we
    can see that port 5000 is open, has HTTP running on it, and uses a web application
    library called Werkzeug version 1.0.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The most important piece of information here is found in the `http-title`, which
    gives us a hint that we’re working with a GraphQL application. You won’t typically
    find indications like this in the wild, so we will ignore it for now. You might
    follow this scan with an all-ports scan to search for additional information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to perform more targeted scans. Let’s run a quick web application
    vulnerability scan using Nikto, making sure to specify that the web application
    is operating over port 5000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Nikto tells us that the application may have some security misconfigurations,
    such as the missing `X-Frame-Options` and undefined `X-XSS-Protection` headers.
    In addition, we’ve found that the OPTIONS, HEAD, and GET methods are allowed.
    Since Nikto did not pick up any interesting directories, we should check out the
    web application in a browser and see what we can find as an end user. Once we
    have thoroughly explored the web app, we can perform a directory brute-force attack
    to see if we can find any other directories.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing DVGA in a Browser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see in [Figure 14-1](#figure14-1), the DVGA web page describes a
    deliberately vulnerable GraphQL application.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to use the site as any other user would by clicking the links located
    on the web page. Explore the Private Pastes, Public Pastes, Create Paste, Import
    Paste, and Upload Paste links. In the process, you should begin to see a few interesting
    items, such as usernames, forum posts that include IP addresses and `user-agent`
    info, a link for uploading files, and a link for creating forum posts. Already
    we have a bundle of information that could prove useful in our upcoming attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Damn Vulnerable GraphQL Application homepage. Shows welcome
    and getting started messages. A sidebar shows tabs for Home, Private Pastes, and
    Public Pastes.](image_fi/502444c14/F14001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-1: The DVGA landing page'
  prefs: []
  type: TYPE_NORMAL
- en: Using DevTools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve explored the site as an average user, let’s take a peek under
    the hood of the web application using DevTools. To see the different resources
    involved in this web application, navigate to the DVGA home page and open the
    Network module in DevTools. Refresh the Network module by pressing ctrl-R. You
    should see something like the interface shown in [Figure 14-2](#figure14-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the DevTools Network tab with a list of the headers sent in
    a request to the DVGA home page. The header “Set-Cookie: env=graphiql:disable;
    Path=/” is highlighted.](image_fi/502444c14/F14002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-2: The DVGA home page’s network source file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look through the response headers of the primary resource. You should see the
    header `Set-Cookie: env=graphiql:disable`, another indication that we’re interacting
    with a target that uses GraphQL. Later, we may be able to manipulate a cookie
    like this one to enable a GraphQL IDE called GraphiQL.'
  prefs: []
  type: TYPE_NORMAL
- en: Back in your browser, navigate to the Public Pastes page, open up the DevTools
    Network module, and refresh again (see [Figure 14-3](#figure14-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the DevTools Network tab set to the Preview menu. Shows the
    source code for the DVGA Public Pastes page.](image_fi/502444c14/F14003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-3: DVGA *public_pastes* source'
  prefs: []
  type: TYPE_NORMAL
- en: There is a new source file called *graphql*. Select this source and choose the
    Preview tab. Now you will see a preview of the response for this resource. GraphQL,
    like REST, uses JSON as the syntax for transferring data. At this point, you may
    have guessed that this is a response generated using GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse Engineering the GraphQL API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know the target app uses GraphQL, let’s try to determine the API’s
    endpoint and requests. Unlike REST APIs, whose resources are available at various
    endpoints, a host that uses GraphQL relies on only a single endpoint for its API.
    In order to interact with the GraphQL API, we must first find this endpoint and
    then figure out what we can query for.
  prefs: []
  type: TYPE_NORMAL
- en: Directory Brute-Forcing for the GraphQL Endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A directory brute-force scan using Gobuster or Kiterunner can tell us if there
    are any GraphQL-related directories. Let’s use Kiterunner to find these. If you
    were searching for GraphQL directories manually, you could add keywords like the
    following in the requested path:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/graphql*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/v1/graphql*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/api/graphql*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/v1/api/graphql*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/graph*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/v1/graph*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/graphiql*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/v1/graphiql*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/console*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/query*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/graphql/console*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/altair*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*/playground*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, you should also try replacing the version numbers in any of these
    paths with */v2*, */v3*, */test*, */internal*, */mobile*, */legacy*, or any variation
    of these paths. For example, both Altair and Playground are alternative IDEs to
    GraphiQL that you could search for with various versioning in the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'SecLists can also help us automate this directory search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We receive two relevant results from this scan; however, both currently respond
    with an HTTP 400 Bad Request status code. Let’s check them in the web browser.
    The */graphql* path resolves to a JSON response page with the message `"Must provide
    query string."` (see [Figure 14-4](#figure14-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the /graphql path of the DVGA app. Shows the JSON message “Must
    provide query string.”](image_fi/502444c14/F14004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-4: The DVGA */graphql* path'
  prefs: []
  type: TYPE_NORMAL
- en: This doesn’t give us much to work with, so let’s check out the */graphiql* endpoint.
    As you can see in [Figure 14-5](#figure14-5), the */graphiql* path leads us to
    the web IDE often used for GraphQL, GraphiQL.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the /graphiql page of the DVGA app. Shows a GraphiQL IDE.](image_fi/502444c14/F14005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-5: The DVGA GraphiQL web IDE'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we are met with the message `"400 Bad Request: GraphiQL Access Rejected"`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the GraphiQL web IDE, the API documentation is normally located on the top
    right of the page, under a button called Docs. If you click the Docs button, you
    should see the Documentation Explorer window, shown on the right side of [Figure
    14-5](#figure14-5). This information could be helpful for crafting requests. Unfortunately,
    due to our bad request, we do not see any documentation.
  prefs: []
  type: TYPE_NORMAL
- en: There is a chance we’re not authorized to access the documentation due to the
    cookies included in our request. Let’s see if we can alter the `env=graphiql:disable`
    cookie we spotted back at the bottom of [Figure 14-2](#figure14-2).
  prefs: []
  type: TYPE_NORMAL
- en: Cookie Tampering to Enable the GraphiQL IDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s capture a request to */graphiql* using the Burp Suite Proxy to see what
    we’re working with. As usual, you can proxy the request to be intercepted through
    Burp Suite. Make sure Foxy Proxy is on and then refresh the */graphiql* page in
    your browser. Here is the request you should intercept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In reviewing the request, one thing you should notice is that the `env` variable
    is base64 encoded. Paste the value into Burp Suite’s Decoder and then decode the
    value as base64\. You should see the decoded value as `graphiql:disable`. This
    is the same value we noticed when viewing DVGA in DevTools.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take this value and try altering it to `graphiql:enable`. Since the original
    value was base64 encoded, let’s encode the new value back to base64 (see [Figure
    14-6](#figure14-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of Burp Suite’s Decoder with a string decoded to “graphiql:enable”](image_fi/502444c14/F14006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-6: Burp Suite’s Decoder'
  prefs: []
  type: TYPE_NORMAL
- en: You can test out this updated cookie in Repeater to see what sort of response
    you receive. To be able to use GraphiQL in the browser, you’ll need to update
    the cookie saved in your browser. Open the DevTools Storage panel to edit the
    cookie (see [Figure 14-7](#figure14-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the DevTools storage panel showing a list of cookies and their
    values](image_fi/502444c14/F14007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-7: Cookies in DevTools'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve located the `env` cookie, double-click the value and replace it
    with the new one. Now return to the GraphiQL IDE and refresh the page. You should
    now be able to use the GraphiQL interface and Documentation Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse Engineering the GraphQL Requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we know the endpoints we want to target, we still don’t know the structure
    of the API’s requests. One major difference between REST and GraphQL APIs is that
    GraphQL operates using POST requests only.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s intercept these requests in Postman so we can better manipulate them.
    First, set your browser’s proxy to forward traffic to Postman. If you followed
    the setup instructions back in Chapter 4, you should be able to set FoxyProxy
    to “Postman.” [Figure 14-8](#figure14-8) shows Postman’s Capture requests and
    cookies screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman “Capture requests and cookies” page with “Capture
    requests” set to On](image_fi/502444c14/F14008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-8: Postman’s Capture requests and cookies screen'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s reverse engineer this web application by manually navigating to every
    link and using every feature we’ve discovered. Click around and submit some data.
    Once you’ve thoroughly used the web app, open Postman to see what your collection
    looks like. You’ve likely collected requests that do not interact with the target
    API. Make sure to delete any that do not include either */graphiql* or */graphql*.
  prefs: []
  type: TYPE_NORMAL
- en: However, as you can see in [Figure 14-9](#figure14-9), even if you delete all
    requests that don’t involve */graphql*, their purposes aren’t so clear. In fact,
    many of them look identical. Because GraphQL requests function solely using the
    data in the body of the POST request rather than the request’s endpoint, we’ll
    have to review the body of the request to get an idea of what these requests do.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of identical-looking POST requests saved in Postman](image_fi/502444c14/F14009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-9: An unclear GraphQL Postman collection'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the time to go through the body of each of these requests and then rename
    each request so you can see what it does. Some of the request bodies may seem
    intimidating; if so, extract a few key details from them and give them a temporary
    name until you understand them better. For instance, take the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*There is a lot of information here, but we can pick out a few details from
    the beginning of the request body and give it a name (for example, Graphiql Query
    Introspection SubscriptionType). The next request looks very similar, but instead
    of `subscriptionType`, the request includes only `types`, so let’s name it based
    on that difference, as shown in [Figure 14-10](#figure14-10).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a list of POST requests renamed descriptively in Postman](image_fi/502444c14/F14010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-10: A cleaned-up DVGA collection'
  prefs: []
  type: TYPE_NORMAL
- en: Now you have a basic collection with which to conduct testing. As you learn
    more about the API, you will further build your collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, we’ll cover another method of reverse engineering GraphQL
    requests: obtaining the schema using introspection.'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse Engineering a GraphQL Collection Using Introspection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Introspection is a feature of GraphQL that reveals the API’s entire schema to
    the consumer, making it a gold mine when it comes to information disclosure. For
    this reason, you’ll often find introspection disabled and will have to work a
    lot harder to attack the API. If, however, you can query the schema, you’ll be
    able to operate as though you’ve found a collection or specification file for
    a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for introspection is as simple as sending an introspection query. If
    you’re authorized to use the DVGA GraphiQL interface, you can capture the introspection
    query by intercepting the requests made when loading */graphiql*, because the
    GraphiQL interface sends an introspection query when populating the Documentation
    Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: The full introspection query is quite large, so I’ve only included a portion
    here; however, you can see it in its entirety by intercepting the request yourself
    or checking it out on the Hacking APIs GitHub repo at [https://github.com/hAPI-hacker/Hacking-APIs](https://github.com/hAPI-hacker/Hacking-APIs).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A successful GraphQL introspection query will provide you with all the types
    and fields contained within the schema. You can use the schema to build a Postman
    collection. If you’re using GraphiQL, the query will populate the GraphiQL Documentation
    Explorer. As you’ll see in the next sections, the GraphiQL Documentation Explorer
    is a tool for seeing the types, fields, and arguments available in the GraphQL
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL API Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we know that we can make requests to a GraphQL endpoint and the
    GraphiQL interface. We’ve also reverse engineered several GraphQL requests and
    gained access to the GraphQL schema through the use of a successful introspection
    query. Let’s use the Documentation Explorer to see if there is any information
    we might leverage for exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting Requests Using the GraphiQL Documentation Explorer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take one of the requests we reverse engineered from Postman, such as the request
    for Public Pastes used to generate the *public_pastes* web page, and test it out
    using the GraphiQL IDE. Use the Documentation Explorer to help you build your
    query. Under **Root Types**, select **Query**. You should see the same options
    displayed in [Figure 14-11](#figure14-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the GraphiQL IDE with a search bar open and information about
    query formats visible](image_fi/502444c14/F14011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-11: The GraphiQL Documentation Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the GraphiQL query panel, enter `query` followed by curly brackets to
    initiate the GraphQL request. Now query for the public pastes field by adding
    `pastes` under `query` and using parentheses for the argument `public: true`.
    Since we’ll want to know more about the public pastes object, we’ll need to add
    fields to the query. Each field we add to the request will tell us more about
    the object. To do this, select **PasteObject** in the Documentation Explorer to
    view these fields. Finally, add the fields that you would like to include in your
    request body, separated by new lines. The fields you include represent the different
    data objects you should receive back from the provider. In my request I’ll add
    `title`, `content`, `public`, `ipAddr`, and `pId`, but feel free to experiment
    with your own fields. Your completed request body should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the request by using the **Execute Query** button or the shortcut ctrl-enter.
    If you’ve followed along, you should receive a response like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have an idea of how to request data using GraphQL, let’s transition
    to Burp Suite and use a great extension to help us flesh out what can be done
    with DVGA.
  prefs: []
  type: TYPE_NORMAL
- en: Using the InQL Burp Extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you won’t find any GraphiQL IDE to work with on your target. Luckily
    for us, an amazing Burp Suite extension can help. InQL acts as an interface to
    GraphQL within Burp Suite. To install it, as you did for the IP Rotate extension
    in the previous chapter, you’ll need to select Jython in the Extender options.
    Refer to Chapter 13 for the Jython installation steps.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve installed InQL, select the InQL Scanner and add the URL of the GraphQL
    API you’re targeting (see [Figure 14-12](#figure14-12)).
  prefs: []
  type: TYPE_NORMAL
- en: The scanner will automatically find various queries and mutations and save them
    into a file structure. You can then select these saved requests and send them
    to Repeater for additional testing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the InQL screenshot in Burp with the paste.query GraphQL query
    visible](image_fi/502444c14/F14012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-12: The InQL Scanner module in Burp Suite'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s practice testing different requests. The `paste.query` is a query used
    to find pastes by their paste ID (pID) code. If you posted any public pastes in
    the web application, you can see your pID values. What if we used an authorization
    attack against the pID field by requesting pIDs that were meant to be private?
    This would constitute a BOLA attack. Since these paste IDs appear to be sequential,
    we’ll want to test for any authorization restrictions preventing us from accessing
    the private posts of other users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click `paste.query` and send it to Repeater. Edit the `code*` value by
    replacing it with a pID that should work. I’ll use the pID 166, which I received
    earlier. Send the request with Repeater. You should receive a response like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, the application responds with the public paste I had previously
    submitted.
  prefs: []
  type: TYPE_NORMAL
- en: If we’re able to request pastes by pID, maybe we can brute-force the other pIDs
    to see if there are authorization requirements that prevent us from requesting
    private pastes. Send the paste request in [Figure 14-12](#figure14-12) to Intruder
    and then set the pID value to be the payload position. Change the payload to a
    number value starting at 0 and going to 166 and then start the attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reviewing the results reveals that we’ve discovered a BOLA vulnerability. We
    can see that we’ve received private data, as indicated by the `"public": false`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’re able to retrieve every private paste by requesting different pIDs. Congratulations,
    this is a great find! Let’s see what else we can discover.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing for Command Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve analyzed the API, let’s fuzz it for vulnerabilities to see if
    we can conduct an attack. Fuzzing GraphQL can pose an additional challenge, as
    most requests result in a 200 status code, even if they were formatted incorrectly.
    Therefore, we’ll need to look for other indicators of success.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find any errors in the response body, and you’ll need to build a baseline
    for what these look like by reviewing the responses. Check whether errors all
    generate the same response length, for example, or if there are other significant
    differences between a successful response and a failed one. Of course, you should
    also review error responses for information disclosures that can aid your attack.
  prefs: []
  type: TYPE_NORMAL
- en: Since the query type is essentially read-only, we’ll attack the mutation request
    types. First, let’s take one of the mutation requests, such as the `Mutation ImportPaste`
    request, in our DVGA collection and intercept it with Burp Suite. You should see
    an interface similar to [Figure 14-13](#figure14-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a POST request in Burp Suite with a GraphQL query in the request
    body](image_fi/502444c14/F14013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-13: An intercepted GraphQL mutation request'
  prefs: []
  type: TYPE_NORMAL
- en: 'Send this request to Repeater to see the sort of response we should expect
    to see. You should receive a response like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I happen to have tested the request by using [http://www.google.com/](http://www.google.com/)
    as my URL for importing pastes; you might have a different URL in the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an idea of how GraphQL will respond, let’s forward this request
    to Intruder. Take a closer look at the body of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this request contains variables, each of which is preceded by `$`
    and followed by `!`. The corresponding keys and values are at the bottom of the
    request, following `"variables"`. We’ll place our payload positions here, because
    these values contain user input that could be passed to backend processes, making
    them an ideal target for fuzzing. If any of these variables lack good input validation
    controls, we’ll be able to detect a vulnerability and potentially exploit the
    weakness. We’ll place our payload positions within this variables section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, configure your two payload sets. For the first payload, let’s take a
    sample of metacharacters from Chapter 12:'
  prefs: []
  type: TYPE_NORMAL
- en: '`|`'
  prefs: []
  type: TYPE_NORMAL
- en: '`||`'
  prefs: []
  type: TYPE_NORMAL
- en: '`&`'
  prefs: []
  type: TYPE_NORMAL
- en: '`&&`'
  prefs: []
  type: TYPE_NORMAL
- en: '`''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`''"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second payload set, let’s use a sample of potential injection payloads,
    also from Chapter 12:'
  prefs: []
  type: TYPE_NORMAL
- en: '`whoami`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{"$where": "sleep(1000) "}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`;%00`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-- -`'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, make sure payload encoding is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s run our attack against the host variable. As you can see in [Figure
    14-14](#figure14-14), the results are uniform, and there were no anomalies. All
    the status codes and response lengths were identical.
  prefs: []
  type: TYPE_NORMAL
- en: You can review the responses to see what they consisted of, but from this initial
    scan, there doesn’t appear to be anything interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s target the `"path"` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Screenshot of fuzzing results in Burp Suite showing 200 response codes only](image_fi/502444c14/F14014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-14: Intruder results for an attack on the host variable'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the same payloads as the first attack. As you can see in [Figure 14-15](#figure14-15),
    not only do we receive a variety of response codes and lengths, but we also receive
    indicators of successful code execution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of fuzzing results in Burp Suite showing a response body containing
    data returned from a GraphQL query](image_fi/502444c14/F14015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-15: Intruder results for an attack on the `"path"` variable'
  prefs: []
  type: TYPE_NORMAL
- en: Digging through the responses, you can see that several of them were susceptible
    to the `whoami` command. This suggests that the `"path"` variable is vulnerable
    to operating system injection. In addition, the user that the command revealed
    is the privileged user, `root`, an indication that the app is running on a Linux
    host. You can update your second set of payloads to include the Linux commands
    `uname -a` and `ver` to see which operating system you are interacting with.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve discovered the operating system, you can perform more targeted attacks
    to obtain sensitive information from the system. For example, in the request shown
    in [Listing 14-3](#listing14-3), I’ve replaced the `"path"` variable with `/;
    cat /etc/passwd`, which will attempt to make the operating system return the */etc/passwd*
    file containing a list of the accounts on the host system, shown in [Listing 14-4](#listing14-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-3: The request'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-4: The response'
  prefs: []
  type: TYPE_NORMAL
- en: You now have the ability to execute all commands as the root user within the
    Linux operating system. Just like that, we’re able to inject system commands using
    a GraphQL API. From here, we could continue to enumerate information using this
    command injection vulnerability or else use commands to obtain a shell to the
    system. Either way, this is a very significant finding. Good job exploiting a
    GraphQL API!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we walked through an attack of a GraphQL API using some of
    the techniques covered in this book. GraphQL operates differently than the REST
    APIs we’ve worked with up to this point. However, once we adapted a few things
    to GraphQL, we were able to apply many of the same techniques to perform some
    awesome exploits. Don’t be intimidated by new API types you might encounter; instead,
    embrace the tech, learn how it operates, and then experiment with the API attacks
    you’ve already learned.
  prefs: []
  type: TYPE_NORMAL
- en: DVGA has several more vulnerabilities we didn’t cover in this chapter. I recommend
    that you return to your lab and exploit them. In the final chapter, I’ll present
    real-world breaches and bounties involving APIs.*
  prefs: []
  type: TYPE_NORMAL
