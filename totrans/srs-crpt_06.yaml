- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: STREAM CIPHERS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Symmetric ciphers can be either block ciphers or stream ciphers. Recall from
    [Chapter 4](ch04.xhtml#ch4) that block ciphers mix chunks of plaintext bits together
    with key bits to produce chunks of ciphertext of the same size, usually 64 or
    128 bits. Stream ciphers, on the other hand, don’t mix plaintext and key bits;
    instead, they generate pseudorandom bits from the key and encrypt the plaintext
    by XORing it with the pseudorandom bits, in the same fashion as the one-time pad
    explained in [Chapter 1](ch01.xhtml#ch1).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密码可以是块密码或流密码。回想一下[第 4 章](ch04.xhtml#ch4)，块密码通过将明文比特与密钥比特混合在一起，产生相同大小的密文块，通常为
    64 或 128 位。而流密码则不同，它们不会将明文和密钥比特混合在一起；相反，它们通过密钥生成伪随机比特，并通过与伪随机比特进行异或（XOR）操作来加密明文，就像[第
    1 章](ch01.xhtml#ch1)中解释的一次性密钥一样。
- en: Stream ciphers are sometimes shunned because historically they’ve been more
    fragile than block ciphers and are more often broken—both the experimental ones
    designed by amateurs and the ciphers deployed in systems used by millions, including
    mobile phones, Wi-Fi, and public transport smart cards. But that’s all history.
    Fortunately, although it has taken 20 years, we now know how to design secure
    stream ciphers, and we trust them to protect things like Bluetooth connections,
    mobile 4G communications, TLS connections, and more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码有时会被排斥，因为历史上它们比块密码更脆弱，而且更容易被破解——无论是业余爱好者设计的实验性密码，还是在包括移动电话、Wi-Fi 和公共交通智能卡在内的系统中使用的密码。但这些都已经是历史了。幸运的是，虽然花费了
    20 年时间，我们现在知道如何设计安全的流密码，并且相信它们能够保护像蓝牙连接、移动 4G 通信、TLS 连接等内容。
- en: 'This chapter first presents how stream ciphers work and discusses the two main
    classes of stream ciphers: stateful and counter-based ciphers. We’ll then study
    hardware- and software-oriented stream ciphers and look at some insecure ciphers
    (such as A5/1 in GSM mobile communications and RC4 in TLS) and some secure, state-of-the-art
    ones (such as Grain-128a for hardware and Salsa20 for software).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先介绍流密码的工作原理，并讨论流密码的两大主要类别：有状态密码和基于计数器的密码。然后，我们将研究硬件和软件导向的流密码，并查看一些不安全的密码（例如
    GSM 移动通信中的 A5/1 和 TLS 中的 RC4）以及一些安全的、最先进的密码（如硬件使用的 Grain-128a 和软件使用的 Salsa20）。
- en: How Stream Ciphers Work
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流密码的工作原理
- en: Stream ciphers are more akin to deterministic random bit generators (DRBGs)
    than they are to full-fledged pseudorandom number generators (PRNGs) because,
    like DRBGs, stream ciphers are deterministic. Stream ciphers’ determinism allows
    you to decrypt by regenerating the pseudorandom bits used to encrypt. With a PRNG,
    you could encrypt but never decrypt—which is secure, but useless.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码更像是确定性随机比特生成器（DRBGs），而不是完整的伪随机数生成器（PRNGs），因为像 DRBGs 一样，流密码是确定性的。流密码的确定性使得你可以通过重新生成用于加密的伪随机比特来解密。使用
    PRNG，你可以加密但无法解密——这虽然安全，但毫无用处。
- en: 'What sets stream ciphers apart from DRBGs is that DRBGs take a single input
    value whereas stream ciphers take two values: a key and a nonce. The key should
    be secret and is usually 128 or 256 bits. The nonce doesn’t have to be secret,
    but it should be unique for each key and is usually between 64 and 128 bits.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 区分流密码与 DRBGs 的关键在于，DRBGs 只接受一个输入值，而流密码接受两个值：一个密钥和一个随机数。密钥应该是保密的，通常为 128 位或 256
    位。随机数不需要保密，但它应该对于每个密钥都是唯一的，通常为 64 到 128 位之间。
- en: '![image](../images/f05-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-01.jpg)'
- en: '*Figure 5-1: How stream ciphers encrypt, taking a secret key*, K, *and a public
    nonce*, N'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：流密码如何加密，采用一个秘密密钥*，K，*和一个公共的随机数*，N'
- en: Stream ciphers produce a pseudorandom stream of bits called the *keystream*.
    The keystream is XORed to a plaintext to encrypt it and then XORed again to the
    ciphertext to decrypt it. [Figure 5-1](ch05.xhtml#ch5fig1) shows the basic stream
    cipher encryption operation, where **SC** is the stream cipher algorithm, *KS*
    the keystream, *P* the plaintext, and *C* the ciphertext.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码生成一个称为 *密钥流* 的伪随机比特流。密钥流与明文进行异或操作来加密明文，然后再次与密文进行异或操作来解密密文。[图 5-1](ch05.xhtml#ch5fig1)展示了基本的流密码加密操作，其中
    **SC** 是流密码算法，*KS* 是密钥流，*P* 是明文，*C* 是密文。
- en: A stream cipher computes *KS* = **SC**(*K*, *N*), encrypts as *C* = *P* ⊕ *KS*,
    and decrypts as *P* = *C* ⊕ *KS*. The encryption and decryption functions are
    the same because both do the same thing—namely, XOR bits with the keystream. That’s
    why, for example, certain cryptographic libraries provide a single `encrypt` function
    that’s used for both encryption and decryption.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码计算 *KS* = **SC**(*K*, *N*)，加密为 *C* = *P* ⊕ *KS*，解密为 *P* = *C* ⊕ *KS*。加密和解密函数是相同的，因为两者执行的操作相同——即用密钥流进行异或运算。这就是为什么某些加密库提供一个单独的
    `encrypt` 函数，用于加密和解密的原因。
- en: Stream ciphers allow you to encrypt a message with key *K*[1] and nonce *N*[1]
    and then encrypt another message with key *K*[1] and nonce *N*[2] that is different
    from *N*[1], or with key *K*[2], which is different from *K*[1] and nonce *N*[1].
    However, you should never again encrypt with *K*[1] and *N*[1], because you would
    then use twice the same keystream *KS*. You would then have a first ciphertext
    *C*[1] = *P*[1] ⊕ *KS*, a second ciphertext *C*[2] = *P*[2] ⊕ *KS*, and if you
    know *P*[1], then you could determine *P*[2] = *C*[1] ⊕ *C*[2] ⊕ *P*[1].
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码允许你使用密钥 *K*[1] 和 nonce *N*[1] 加密一条消息，然后使用密钥 *K*[1] 和与 *N*[1] 不同的 nonce *N*[2]
    或使用与 *K*[1] 不同的密钥 *K*[2] 和 nonce *N*[1] 再加密另一条消息。然而，你永远不应该再次使用 *K*[1] 和 *N*[1]
    进行加密，因为那样你就会使用两次相同的密钥流 *KS*。这时你会有第一个密文 *C*[1] = *P*[1] ⊕ *KS*，第二个密文 *C*[2] = *P*[2]
    ⊕ *KS*，如果你知道 *P*[1]，那么你可以通过 *C*[1] ⊕ *C*[2] ⊕ *P*[1] 计算出 *P*[2]。
- en: '**NOTE**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The name* nonce *is actually short for* number used only once. *In the context
    of stream ciphers, it’s sometimes called the IV, for* initial value.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*名称* nonce *实际上是* number used only once（仅使用一次的数字）的缩写。*在流密码的上下文中，它有时被称为 IV，即*
    initial value（初始值）。'
- en: '*Stateful and Counter-Based Stream Ciphers*'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*有状态与基于计数器的流密码*'
- en: 'From a high-level perspective, there are two types of stream ciphers: stateful
    and counter based. *Stateful stream ciphers* have a secret internal state that
    evolves throughout keystream generation. The cipher initializes the state from
    the key and the nonce and then calls an update function to update the state value
    and produce one or more keystream bits from the state, as shown in [Figure 5-2](ch05.xhtml#ch5fig2).
    For example, the famous RC4 is a stateful cipher.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次的角度来看，流密码有两种类型：有状态和基于计数器的。*有状态流密码* 具有一个在生成密钥流的过程中不断变化的秘密内部状态。密码从密钥和 nonce
    初始化状态，然后调用更新函数来更新状态值，并从状态中生成一个或多个密钥流位，如[图 5-2](ch05.xhtml#ch5fig2)所示。例如，著名的 RC4
    就是一个有状态密码。
- en: '![image](../images/f05-02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-02.jpg)'
- en: '*Figure 5-2: The stateful stream cipher*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：有状态流密码*'
- en: '*Counter-based stream ciphers* produce chunks of keystream from a key, a nonce,
    and a counter value, as shown in [Figure 5-3](ch05.xhtml#ch5fig3). Unlike stateful
    stream ciphers, such as Salsa20, no secret state is memorized during keystream
    generation.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于计数器的流密码* 从密钥、nonce 和计数器值生成密钥流块，如[图 5-3](ch05.xhtml#ch5fig3)所示。与有状态流密码（例如
    Salsa20）不同，基于计数器的流密码在生成密钥流时不会记住任何秘密状态。'
- en: '![image](../images/f05-03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-03.jpg)'
- en: '*Figure 5-3: The counter-based stream cipher*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：基于计数器的流密码*'
- en: 'These two approaches define the high-level architecture of the stream cipher,
    regardless of how the core algorithms work. The internals of the stream cipher
    also fall into two categories, depending on the target platform of the cipher:
    hardware oriented and software oriented.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法定义了流密码的高层架构，无论核心算法如何工作。流密码的内部实现也分为两类，取决于密码的目标平台：硬件导向和软件导向。
- en: Hardware-Oriented Stream Ciphers
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬件导向的流密码
- en: When cryptographers talk about hardware, they mean application-specific integrated
    circuits (ASICs), programmable logic devices (PLDs), and field-programmable gate
    arrays (FPGAs). A cipher’s hardware implementation is an electronic circuit that
    implements the cryptographic algorithm at the bit level and that can’t be used
    for anything else; in other words, the circuit is *dedicated hardware*. On the
    other hand, software implementations of cryptographic algorithms simply tell a
    microprocessor what instructions to execute in order to run the algorithm. These
    instructions operate on bytes or words and then call pieces of electronic circuit
    that implement general-purpose operations such as addition and multiplication.
    Software deals with bytes or words of 32 or 64 bits, whereas hardware deals with
    bits. The first stream ciphers worked with bits in order to save complex word-wise
    operations and thus be more efficient in hardware, their target platform at the
    time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当密码学家谈到硬件时，他们指的是应用特定集成电路（ASICs）、可编程逻辑设备（PLDs）和现场可编程门阵列（FPGAs）。密码算法的硬件实现是一个电子电路，按位实现加密算法，且不能用于其他任何用途；换句话说，这个电路是*专用硬件*。另一方面，密码算法的软件实现仅仅是告诉微处理器执行什么指令来运行算法。这些指令处理字节或字，并调用实现一般操作（如加法和乘法）的电子电路。软件处理32位或64位的字节或字，而硬件处理的是比特。最早的流密码按比特工作，以避免复杂的字操作，从而在当时的硬件平台上更加高效。
- en: The main reason why stream ciphers were commonly used for hardware implementations
    is that they were cheaper than block ciphers. Stream ciphers needed less memory
    and fewer logical gates than block ciphers, and therefore occupied a smaller area
    on an integrated circuit, which reduced fabrication costs. For example, counting
    in gate-equivalents, the standard area metric for integrated circuits, you could
    find stream ciphers taking less than 1000 gate-equivalents; by contrast, typical
    software-oriented block ciphers needed at least 10000 gate-equivalents, making
    crypto an order of magnitude more expensive than with stream ciphers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码在硬件实现中被广泛使用的主要原因是它们比分组密码更便宜。流密码需要的内存和逻辑门比分组密码少，因此占用集成电路的面积更小，从而降低了制造成本。例如，以门等效（gate-equivalents）为计量标准，流密码的面积通常小于1000个门等效；相比之下，典型的软件导向分组密码至少需要10000个门等效，这使得加密在成本上比流密码贵了一个数量级。
- en: Today, however, block ciphers are no longer more expensive than stream ciphers—first,
    because there are now hardware-friendly block ciphers about as small as stream
    ciphers, and second, because the cost of hardware has plunged. Yet stream ciphers
    are often associated with hardware because they used to be the best option.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，今天，分组密码不再比流密码更昂贵——首先，因为现在有一些硬件友好的分组密码，它们的体积与流密码相差无几，其次，因为硬件的成本已经大幅下降。尽管如此，流密码仍然常与硬件相关联，因为它们曾经是最佳选择。
- en: In the next section, I’ll explain the basic mechanism behind hardware stream
    ciphers, called *feedback shift registers* *(FSRs)*. Almost all hardware stream
    ciphers rely on FSRs in some way, whether that’s the A5/1 cipher used in 2G mobile
    phones or the more recent cipher Grain-128a.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将解释硬件流密码的基本机制，这种机制叫做*反馈移位寄存器*（*FSRs*）。几乎所有的硬件流密码都以某种方式依赖于FSR，无论是2G手机中使用的A5/1密码，还是较新的密码Grain-128a。
- en: '**NOTE**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The first standard block cipher, the Data Encryption Standard (DES), was optimized
    for hardware rather than for software. When the US government standardized DES
    in the 1970s, most target applications were hardware implementations. It’s therefore
    no surprise that the S-boxes in DES are small and fast to compute when implemented
    as a logical circuit in hardware but inefficient in software. Unlike DES, the
    current Advanced Encryption Standard (AES) deals with bytes and is therefore more
    efficient in software than DES.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一个标准分组密码数据加密标准（DES）是为了硬件优化的，而不是为了软件优化。当美国政府在1970年代将DES标准化时，大多数目标应用是硬件实现。因此，DES中的S盒在硬件中作为逻辑电路实现时既小又快速计算，但在软件中则效率低下。与DES不同，目前的高级加密标准（AES）处理字节，因此在软件中比DES更高效。*'
- en: '*Feedback Shift Registers*'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*反馈移位寄存器*'
- en: Countless stream ciphers have used FSRs because they’re simple and well understood.
    An FSR is simply an array of bits equipped with an update *feedback function*,
    which I’ll denote as **f**. The FSR’s state is stored in the array, or register,
    and each *update* of the FSR uses the feedback function to change the state’s
    value and to produce one output bit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 无数的流密码都使用了FSR，因为它们简单且易于理解。FSR只是一个配备有更新*反馈函数*的比特数组，我将其表示为**f**。FSR的状态存储在数组或寄存器中，每次*更新*FSR时，使用反馈函数来改变状态的值并生成一个输出位。
- en: 'In practice, an FSR works like this: if *R*[0] is the initial value of the
    FSR, the next state, *R*[1], is defined as *R*[0] left-shifted by 1 bit, where
    the bit leaving the register is returned as output, and where the empty position
    is filled with **f**(*R*[0]).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，FSR的工作方式是这样的：如果 *R*[0] 是FSR的初始值，下一状态 *R*[1] 定义为 *R*[0] 左移1位，离开寄存器的位作为输出，并且空位由**f**(*R*[0])填充。
- en: 'The same rule is repeated to compute the subsequent state values *R*[2], *R*[3],
    and so on. That is, given *R*[*t*], the FSR’s state at time *t*, the next state,
    *R*[*t* + 1], is the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的规则重复用于计算随后的状态值 *R*[2]、*R*[3]，依此类推。也就是说，给定 *R*[*t*]，FSR在时刻*t*的状态，下一个状态 *R*[*t*
    + 1] 如下：
- en: '*R*[*i* + 1] = (*R*[*t*] << 1)|**f**(*R*[*t*])'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*R*[*i* + 1] = (*R*[*t*] << 1)|**f**(*R*[*t*])'
- en: 'In this equation, `|` is the logical OR operator and << is the shift operator,
    as used in the C language. For example, given the 8-bit string 00001111, we have
    this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，`|`是逻辑或运算符，<<是位移运算符，像在C语言中一样使用。例如，给定8位字符串00001111，我们得到：
- en: '![image](../images/f0081-01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0081-01.jpg)'
- en: The bit shift moves the bits to the left, losing the leftmost bit in order to
    retain the state’s bit length, and zeroing the rightmost bit. The update operation
    of an FSR is identical, except that instead of being set to 0, the rightmost bit
    is set to **f**(*R*[*t*]).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 位移操作将位向左移动，丢失最左侧的位，以保持状态的位长，并将最右侧的位置为0。FSR的更新操作是相同的，不同之处在于，最右侧的位不是置为0，而是设置为**f**(*R*[*t*])。
- en: 'Consider, for example, a 4-bit FSR whose feedback function **f** XORs all 4
    bits together. Initialize the state to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个4位的FSR，其反馈函数**f**将所有4个比特进行异或操作。将状态初始化为：
- en: 1 1 0 0
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1 0 0
- en: 'Now shift the bits to the left, where 1 is output and the rightmost bit is
    set to the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将位向左移，其中输出1，最右侧的位设置为以下内容：
- en: '**f**(1100) = 1 ⊕ 1 ⊕ 0 ⊕ 0 = 0'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**f**(1100) = 1 ⊕ 1 ⊕ 0 ⊕ 0 = 0'
- en: 'Now the state becomes this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在状态变为：
- en: 1 0 0 0
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 1 0 0 0
- en: 'The next update outputs 1, left-shifts the state, and sets the rightmost bit
    to the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次更新输出1，左移状态，并将最右侧的位设置为：
- en: '**f**(1000) = 1 ⊕ 0 ⊕ 0 ⊕0 = 1'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**f**(1000) = 1 ⊕ 0 ⊕ 0 ⊕ 0 = 1'
- en: 'Now the state is this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在状态是：
- en: 0 0 0 1
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 0 1
- en: 'The next three updates return three 0 bits and give the following state values:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三次更新输出三个0位，并给出以下状态值：
- en: '![image](../images/f0081-02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0081-02.jpg)'
- en: We thus return to our initial state of 1100 after five iterations, and we can
    see that updating the state five times from any of the values observed throughout
    this cycle will return us to this initial value. We say that 5 is the *period*
    of the FSR given any one of the values 1100, 1000, 0001, 0011, or 0110\. Because
    the period of this FSR is 5, clocking the register 10 times will yield twice the
    same 5-bit sequence. Likewise, if you clock the register 20 times, starting from
    1100, the output bits will be 11000110001100011000, or four times the same 5-bit
    sequence of 11000\. Intuitively, such repeating patterns should be avoided, and
    a longer period is better for security.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在五次迭代后，我们回到最初的状态1100，我们可以看到，从该周期中观察到的任一值更新状态五次都会使我们回到初始值。我们称5是FSR的*周期*，对于任何一个值1100、1000、0001、0011或0110来说都适用。由于这个FSR的周期是5，时钟信号让寄存器时钟跳动10次时将输出两次相同的5位序列。同理，如果你让寄存器跳动20次，从1100开始，输出位将是11000110001100011000，或者四次相同的5位序列11000。直观上，应该避免这样的重复模式，更长的周期对安全性更有利。
- en: '**NOTE**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you plan to use an FSR in a stream cipher, avoid using one with short periods,
    which make the output more predictable. Some types of FSRs make it easy to figure
    out their period, but it’s almost impossible to do so with others.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你计划在流密码中使用FSR，避免使用周期较短的FSR，因为它们的输出更容易预测。有些类型的FSR使得推算其周期变得容易，但有些则几乎不可能做到这一点。*'
- en: '[Figure 5-4](ch05.xhtml#ch5fig4) shows the structure of this cycle, along with
    the other cycles of that FSR, with each cycle shown as a circle whose dots represent
    a state of the register.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-4](ch05.xhtml#ch5fig4) 展示了这个周期的结构，以及该 FSR 的其他周期，每个周期以一个圆圈显示，圆圈中的点代表寄存器的一个状态。'
- en: '![image](../images/f05-04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-04.jpg)'
- en: '*Figure 5-4: Cycles of the FSR whose feedback function XORs the 4 bits together*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：FSR 的周期，其反馈函数将 4 位进行异或*'
- en: Indeed, this particular FSR has two other period-5 cycles—namely, {0100, 1001,
    0010, 0101, 1010} and {1111, 1110, 1101, 1011, 0111}. Note that any given state
    can belong to only one cycle of states. Here, we have three cycles of five states
    each, covering 15 of all the 2⁴ = 16 possible values of our 4-bit register. The
    16th possible value is 0000, which, as [Figure 5-4](ch05.xhtml#ch5fig4) shows,
    is a period-1 cycle because the FSR will transform 0000 to 0000.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，这个特定的 FSR 还有两个其他的周期为 5 的循环——即 {0100, 1001, 0010, 0101, 1010} 和 {1111, 1110,
    1101, 1011, 0111}。请注意，任何给定的状态只能属于一个状态循环。在这里，我们有三个周期，每个周期包含五个状态，涵盖了我们 4 位寄存器的 2⁴
    = 16 个可能值中的 15 个。第 16 个可能值是 0000，正如 [图 5-4](ch05.xhtml#ch5fig4) 所示，它是一个周期为 1 的循环，因为
    FSR 会将 0000 转换为 0000。
- en: You’ve seen that an FSR is essentially a register of bits, where each update
    of the register outputs a bit (the leftmost bit of the register) and where a function
    computes the new rightmost bit of the register. (All other bits are left-shifted.)
    The period of an FSR, from some initial state, is the number of updates needed
    until the FSR enters the same state again. If it takes *N* updates to do so, the
    FSR will produce the same *N* bits again and again.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，FSR 本质上是一个位寄存器，其中每次更新寄存器都会输出一个位（寄存器的最左边位），而函数计算出寄存器的新最右边位。（其他位都会左移。）FSR
    的周期是从某个初始状态开始，直到 FSR 再次进入相同状态所需的更新次数。如果需要 *N* 次更新才能达到这一点，那么 FSR 会一次又一次地生成相同的 *N*
    位。
- en: Linear Feedback Shift Registers
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 线性反馈移位寄存器
- en: Linear feedback shift registers (LFSRs) are FSRs with a *linear* feedback function—namely,
    a function that’s the XOR of some bits of the state, such as the example of a
    4-bit FSR in the previous section and its feedback function returning the XOR
    of the register’s 4 bits. Recall that in cryptography, linearity is synonymous
    with predictability and suggestive of a simple underlying mathematical structure.
    And, as you might expect, thanks to this linearity, LFSRs can be analyzed using
    notions like linear complexity, finite fields, and primitive polynomials—but I’ll
    skip the math details and just give you the essential facts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 线性反馈移位寄存器（LFSR）是具有 *线性* 反馈函数的 FSR——即一个函数，它是某些状态位的异或（XOR），就像上一节中 4 位 FSR 的示例及其反馈函数返回寄存器
    4 位的异或结果一样。回想一下，在密码学中，线性性意味着可预测性，并暗示着一个简单的基础数学结构。正如你可能预期的那样，得益于这种线性性，LFSR 可以通过线性复杂度、有限域和原始多项式等概念进行分析——但我会跳过数学细节，直接给你核心要点。
- en: 'The choice of which bits are XORed together is crucial for the period of the
    LFSR and thus for its cryptographic value. The good news is that we know how to
    select the position of the bits in order to guarantee a maximal period, of 2^(*n*)
    – 1\. Specifically, we take the indices of the bits, from 1 for the rightmost
    to *n* for the leftmost, and write the polynomial expression 1 + *X* + *X*² +
    … + *X*^(*n*), where the term *X*^(*i*) is only included if the *i*th bit is one
    of the bits XORed in the feedback function. The period is maximal *if and only
    if* that polynomial is *primitive*. To be primitive, the polynomial must have
    the following qualities:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些位被异或在一起对于 LFSR 的周期及其密码学价值至关重要。好消息是，我们知道如何选择位的位置，以确保最大周期，即 2^(*n*) – 1。具体来说，我们取位的索引，从最右边的
    1 到最左边的 *n*，并写出多项式表达式 1 + *X* + *X*² + … + *X*^(*n*)，其中只有当第 *i* 位是反馈函数中异或的位之一时，才会包含
    *X*^(*i*) 这一项。只有当该多项式是 *原始* 时，周期才是最大周期。为了是原始的，该多项式必须具备以下特性：
- en: 'The polynomial must be irreducible, meaning that it can’t be factorized; that
    is, written as a product of smaller polynomials. For example, *X* + *X*³ is not
    irreducible because it’s equal to (1 + *X*)(*X* + *X*²):'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式必须是不可约的，这意味着它不能被因式分解；也就是说，不能写成更小多项式的积。例如，*X* + *X*³ 不是不可约的，因为它等于 (1 + *X*)(*X*
    + *X*²)：
- en: (1 + *X*)(*X* + *X*²) = *X* + *X*² + *X*² + *X*³ = *X* + *X*³
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (1 + *X*)(*X* + *X*²) = *X* + *X*² + *X*² + *X*³ = *X* + *X*³
- en: The polynomial must satisfy certain other mathematical properties that cannot
    be easily explained without nontrivial mathematical notions but are easy to test.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式必须满足一些其他的数学性质，这些性质不能用简单的数学概念来解释，但可以通过测试轻松验证。
- en: '**NOTE**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The maximal period of an n-bit LFSR is 2*^n – *1, not 2*^n, *because the all-zero
    state always loops on itself infinitely. Because the XOR of any number of zeros
    is zero, new bits entering the state from the feedback functions will always be
    zero; hence, the all-zero state is doomed to stay all zeros.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个n位LFSR的最大周期是2*^n - *1，而不是2*^n，*因为全零状态总是无限循环在自己上。由于任何数量零的异或结果是零，从反馈函数进入状态的新位将始终为零；因此，全零状态注定会一直保持为全零。*'
- en: For example, [Figure 5-5](ch05.xhtml#ch5fig5) shows a 4-bit LFSR with the feedback
    polynomial 1 + *X* + *X*³ + *X*⁴ in which the bits at positions 1, 3, and 4 are
    XORed together to compute the new bit set to *L*[1]. However, this polynomial
    isn’t primitive because it can be factorized into (1 + *X*³)(1 + *X*).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图 5-5](ch05.xhtml#ch5fig5)展示了一个具有反馈多项式1 + *X* + *X*³ + *X*⁴的4位LFSR，其中位置1、3和4的位进行异或运算以计算新位，设置为*L*[1]。然而，这个多项式不是原始的，因为它可以分解为(1
    + *X*³)(1 + *X*)。
- en: '![image](../images/f05-05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-05.jpg)'
- en: '*Figure 5-5: An LFSR with the feedback polynomial 1 + X + X³ + X⁴*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：具有反馈多项式1 + X + X³ + X⁴的LFSR*'
- en: Indeed, the period of the LFSR shown in [Figure 5-5](ch05.xhtml#ch5fig5) isn’t
    maximal. To prove that, start from the state 0001.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，[图 5-5](ch05.xhtml#ch5fig5)所示的LFSR的周期并不是最大值。为了证明这一点，从状态0001开始。
- en: 0 0 0 1
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 0 1
- en: 'Now left-shift by 1 bit and set the new bit to 0 + 0 + 1 = 1:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在左移1位，并将新位设置为0 + 0 + 1 = 1：
- en: 0 0 1 1
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 0 0 1 1
- en: 'Repeating the operation four times gives the following state values:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重复该操作四次后，得到以下状态值：
- en: '![image](../images/f0084-01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0084-01.jpg)'
- en: And as you can see, the state after five updates is the same as the initial
    one, demonstrating that we’re in a period-5 cycle and proving that the LFSR’s
    period isn’t the maximal value of 15.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，经过五次更新后的状态与初始状态相同，这证明我们处于一个周期为5的循环中，并且证明了LFSR的周期不是最大值15。
- en: Now, by way of contrast, consider the LFSR shown in [Figure 5-6](ch05.xhtml#ch5fig6).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相比之下，考虑[图 5-6](ch05.xhtml#ch5fig6)所示的LFSR。
- en: '![image](../images/f05-06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-06.jpg)'
- en: '*Figure 5-6: An LFSR with the feedback polynomial 1 + X*³ + *X*⁴, *a primitive
    polynomial, ensuring a maximal period*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：具有反馈多项式1 + X³ + X⁴的LFSR，*一个原始多项式，确保最大周期*'
- en: 'This feedback polynomial is a primitive polynomial described by 1 + *X*³ +
    *X*⁴, and you can verify that its period is indeed maximal (namely 15). Specifically,
    from an initial value, the state evolves as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个反馈多项式是由1 + *X*³ + *X*⁴描述的原始多项式，你可以验证它的周期确实是最大值（即15）。具体来说，从初始值开始，状态按如下方式演变：
- en: '![image](../images/f0084-02.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0084-02.jpg)'
- en: The state spans all possible values except 0000 with no repetition until it
    eventually loops. This demonstrates that the period is maximal and proves that
    the feedback polynomial is primitive.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该状态涵盖了所有可能的值，除了0000，并且没有重复，直到最终进入循环。这证明了周期是最大的，并且证明了反馈多项式是原始的。
- en: Alas, using an LFSR as a stream cipher is insecure. If *n* is the LFSR’s bit
    length, an attacker needs only *n* output bits to recover the LFSR’s initial state,
    allowing them to determine all previous bits and predict all future bits. This
    attack is possible because the Berlekamp–Massey algorithm can be used to solve
    the equations defined by the LFSR’s mathematical structure to find not only the
    LFSR’s initial state but also its feedback polynomial. In fact, you don’t even
    need to know the exact length of the LFSR to succeed; you can repeat the Berlekamp–Massey
    algorithm for all possible values of *n* until you hit the right one.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，使用LFSR作为流密码是不安全的。如果*n*是LFSR的位长度，攻击者只需要*n*个输出位就能恢复LFSR的初始状态，从而确定所有先前的位并预测所有未来的位。之所以可能进行此攻击，是因为Berlekamp–Massey算法可以用来解LFSR数学结构定义的方程，不仅能找到LFSR的初始状态，还能找到它的反馈多项式。事实上，你甚至不需要知道LFSR的确切长度就能成功；你可以对所有可能的*n*值重复使用Berlekamp–Massey算法，直到找到正确的值。
- en: The upshot is that LFSRs are cryptographically weak because they’re linear.
    Output bits and initial state bits are related by simple and short equations that
    can be easily solved with high-school linear algebra techniques.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是LFSR在加密上较弱，因为它们是线性的。输出位和初始状态位通过简单且短小的方程式相互关联，这些方程可以通过高中线性代数技巧轻松解决。
- en: To strengthen LFSRs, let’s thus add a pinch of nonlinearity.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强LFSR，我们因此需要加入一些非线性。
- en: Filtered LFSRs
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 过滤后的LFSR
- en: '![image](../images/f05-07.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-07.jpg)'
- en: '*Figure 5-7: A filtered LFSR*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：经过滤波的LFSR*'
- en: To mitigate the insecurity of LFSRs, you can hide their linearity by passing
    their output bits through a nonlinear function before returning them to produce
    what is called a *filtered LFSR* (see [Figure 5-7](ch05.xhtml#ch5fig7)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻LFSRs的不安全性，可以通过将其输出位通过非线性函数处理，再返回以生成所谓的*过滤LFSR*（见[图5-7](ch05.xhtml#ch5fig7)）。
- en: The **g** function in [Figure 5-7](ch05.xhtml#ch5fig7) must be a *nonlinear*
    function—one that both XORs bits together and combines them with logical AND or
    OR operations. For example, *L*[1]*L*[2] + *L*[3]*L*[4] is a nonlinear function
    (I’ve omitted the multiply sign, so *L*[1]*L*[2] means *L*[1] × *L*[2], or *L*[1]
    & *L*[2] using C syntax).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-7](ch05.xhtml#ch5fig7)中的**g**函数必须是一个*非线性*函数—既能对比特进行异或操作，又能结合逻辑与或或操作。例如，*L*[1]*L*[2]
    + *L*[3]*L*[4]是一个非线性函数（我省略了乘号，因此*L*[1]*L*[2]表示*L*[1] × *L*[2]，或在C语言中表示为*L*[1]
    & *L*[2]）。'
- en: '**NOTE**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can write feedback functions either directly in terms of an FSR’s bits,
    like* L[1]L[2] + L[3]L[4], *or using the equivalent polynomial notation* 1 + XX²
    + X³X⁴. *The direct notation is easier to grasp, but the polynomial notation better
    serves the mathematical analysis of an FSR’s properties. We’ll now stick to the
    direct notation unless we care about the mathematical properties.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以直接通过FSR的位来编写反馈函数，例如* L[1]L[2] + L[3]L[4]，*或者使用等效的多项式表示法* 1 + XX² + X³X⁴。*直接表示法更易于理解，但多项式表示法更适合FSR性质的数学分析。除非我们关心数学性质，否则我们将坚持使用直接表示法。*'
- en: 'Filtered LFSRs are stronger than plain LFSRs because their nonlinear function
    thwarts straightforward attacks. Still, more complex attacks such as the following
    will break the system:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 滤波LFSRs比普通LFSRs更强，因为它们的非线性函数能抵挡简单的攻击。然而，更复杂的攻击如以下几种将破坏系统：
- en: '*Algebraic attacks* will solve the nonlinear equation systems deduced from
    the output bits, where unknowns in the equations are bits from the LFSR state.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代数攻击*将解出从输出位推导出的非线性方程组，其中方程中的未知数是LFSR状态中的比特。'
- en: '*Cube attacks* will compute derivatives of the nonlinear equations in order
    to reduce the degree of the system down to one and then solve it efficiently like
    a linear system.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*立方体攻击*将计算非线性方程的导数，以将系统的阶数降到一，然后像线性系统一样高效地求解。'
- en: '*Fast correlation attacks* will exploit filtering functions that, despite their
    nonlinearity, tend to behave like linear functions.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快速相关攻击*将利用过滤函数，尽管其具有非线性，仍然倾向于像线性函数一样表现。'
- en: The lesson here, as we’ve seen in previous examples, is that Band-Aids don’t
    fix bullet holes. Patching a broken algorithm with a slightly stronger layer won’t
    make the whole thing secure. The problem has to be fixed at the core.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训，如我们在之前的例子中看到的，是创可贴无法修复枪伤。用稍微强一点的层修补破损的算法并不会使整个系统安全。问题必须从根本上解决。
- en: Nonlinear FSRs
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 非线性反馈移位寄存器（NFSRs）
- en: Nonlinear FSRs (NFSRs) are like LFSRs but with a nonlinear feedback function
    instead of a linear one. That is, instead of just bitwise XORs, the feedback function
    can include bitwise AND and OR operations—a feature with both pros and cons.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 非线性反馈移位寄存器（NFSRs）类似于LFSRs，但它们采用非线性反馈函数，而不是线性反馈函数。也就是说，反馈函数不仅仅是逐位异或，可能还包括逐位与（AND）和或（OR）操作—这一特性既有优点也有缺点。
- en: 'One benefit of the addition of nonlinear feedback functions is that they make
    NFSRs cryptographically stronger than LFSRs because the output bits depend on
    the initial secret state in a complex fashion, according to equations of exponential
    size. The LFSRs’ linear function keeps the relations simple, with at most *n*
    terms (*N*[1], *N*[2], … , *N*[*n*], if the *N*[*i*]s are the NFSR’s state bits).
    For example, a 4-bit NFSR with an initial secret state (*N*[1], *N*[2], *N*[3],
    *N*[4]) and a feedback function (*N*[1] + *N*[2] + *N*[1]*N*[2] + *N*[3]*N*[4])
    will produce a first output bit equal to the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 添加非线性反馈函数的一个好处是，它们使NFSRs在密码学上比LFSRs更强，因为输出位依赖于初始秘密状态，以一种复杂的方式，符合指数大小的方程。LFSRs的线性函数保持关系简单，最多有*n*项（*N*[1]、*N*[2]、……、*N*[*n*]，如果*N*[*i*]是NFSR的状态位）。例如，一个4位的NFSR，其初始秘密状态为(*N*[1]、*N*[2]、*N*[3]、*N*[4])，反馈函数为(*N*[1]
    + *N*[2] + *N*[1]*N*[2] + *N*[3]*N*[4])，将生成第一个输出位，公式如下：
- en: '*N*[1] + *N*[2] + *N*[1]*N*[2] + *N*[3]*N*[4]'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*N*[1] + *N*[2] + *N*[1]*N*[2] + *N*[3]*N*[4]'
- en: 'The second iteration replaces the *N*[1] value with that new bit. Expressing
    the second output bit in terms of the initial state, we get the following equation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次迭代将用新的比特替换*N*[1]的值。将第二个输出位表示为初始状态的形式，我们得到以下方程：
- en: '![image](../images/f0086-01.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0086-01.jpg)'
- en: This new equation has algebraic degree 3 (the highest number of bits multiplied
    together, here in *N*[1]*N*[3]*N*[4]) rather than degree 2 of the feedback function,
    and it has six terms instead of four. As a result, iterating the nonlinear function
    quickly yields unmanageable equations because the size of the output grows exponentially.
    Although you’ll never compute those equations when running the NFSR, an attacker
    would have to solve them in order to break the system.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新方程具有代数度3（即最多有几个比特相乘，这里是*N*[1]*N*[3]*N*[4]），而不是反馈函数的代数度2，它有六个项而不是四个。因此，迭代非线性函数很快就会产生无法管理的方程，因为输出的大小呈指数增长。尽管在运行NFSR时你永远不会计算这些方程，但攻击者必须解决这些方程才能破解系统。
- en: One downside to NFSRs is that there’s no efficient way to determine an NFSR’s
    period, or simply to know whether its period is maximal. For an NFSR of *n* bits,
    you’d need to run close to 2^(*n*) trials to verify that its period is maximal.
    This calculation is impossible for large NFSRs of 80 bits or more.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: NFSR的一个缺点是，没有有效的方法来确定NFSR的周期，或者简单地说，无法知道它的周期是否是最大周期。对于一个*n*比特的NFSR，你需要进行接近2^(*n*)次的试验来验证其周期是否为最大周期。对于80比特或更大的NFSR，这个计算几乎是不可能的。
- en: 'Fortunately, there’s a trick to using an NFSR without worrying about short
    periods: you can combine LFSRs and NFSRs to get both a guaranteed maximal period
    and the cryptographic strength—and that’s exactly how Grain-128a works.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个技巧可以在不担心短周期的情况下使用NFSR：你可以将LFSR和NFSR结合起来，从而获得一个保证的最大周期以及密码学强度——这正是Grain-128a的工作原理。
- en: '*Grain-128a*'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Grain-128a*'
- en: Remember the AES competition discussed in [Chapter 4](ch04.xhtml#ch4), in the
    context of the AES block cipher? The stream cipher Grain is the offspring of a
    similar project called the eSTREAM competition. This competition closed in 2008
    with a shortlist of recommended stream ciphers, which included four hardware-oriented
    ciphers and four software-oriented ones. Grain is one of these hardware ciphers,
    and Grain-128a is an upgraded version from the original authors of Grain. [Figure
    5-8](ch05.xhtml#ch5fig8) shows the action mechanism of Grain-128a.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第4章](ch04.xhtml#ch4)中讨论的AES竞赛吗？它与AES分组密码有关。流密码Grain是一个类似项目的产物，名为eSTREAM竞赛。该竞赛于2008年结束，并公布了一份推荐的流密码候选名单，包含了四个面向硬件的密码和四个面向软件的密码。Grain是这些硬件密码之一，Grain-128a是Grain原作者提出的升级版。[图5-8](ch05.xhtml#ch5fig8)展示了Grain-128a的工作机制。
- en: '![image](../images/f05-08.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-08.jpg)'
- en: '*Figure 5-8: The mechanism of Grain-128a, with a 128-bit NFSR and a 128-bit
    LFSR*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-8：Grain-128a的机制，包含一个128比特的NFSR和一个128比特的LFSR*'
- en: As you can see in [Figure 5-8](ch05.xhtml#ch5fig8), Grain-128a is about as simple
    as a stream cipher can be, combining a 128-bit LFSR, a 128-bit NFSR, and a filter
    function, **h**. The LFSR has a maximal period of 2^(128) – 1, which ensures that
    the period of the whole system is at least 2^(128) – 1 to protect against potential
    short cycles in the NFSR. At the same time, the NFSR and the nonlinear filter
    function **h** add cryptographic strength.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图5-8](ch05.xhtml#ch5fig8)所示，Grain-128a可以说是尽可能简单的流密码，它结合了一个128比特的LFSR，一个128比特的NFSR，以及一个滤波函数**h**。LFSR具有2^(128)
    – 1的最大周期，这确保了整个系统的周期至少为2^(128) – 1，从而防止了NFSR中可能出现的短周期。同时，NFSR和非线性滤波函数**h**增强了密码学强度。
- en: Grain-128a takes a 128-bit key and a 96-bit nonce. It copies the 128 key bits
    into the NFSR’s 128 bits and copies the 96 nonce bits into the first 96 LFSR bits,
    filling the 32 bits left with ones and a single zero bit at the end. The initialization
    phase updates the whole system 256 times before returning the first keystream
    bit. During initialization, the bit returned by the **h** function is thus not
    output as a keystream, but instead goes into the LFSR to ensure that its subsequent
    state depends on both the key and the nonce.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Grain-128a采用128比特的密钥和96比特的随机数（nonce）。它将128比特的密钥位复制到NFSR的128比特中，并将96比特的随机数位复制到LFSR的前96个比特中，剩下的32个比特用1填充，并在末尾加一个零比特。初始化阶段更新整个系统256次，然后才返回第一个密钥流比特。在初始化过程中，**h**函数返回的比特不会作为密钥流输出，而是进入LFSR，确保其后续状态同时依赖于密钥和随机数。
- en: Grain-128a’s LFSR feedback function is
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Grain-128a的LFSR反馈函数为
- en: '**f**(*L*) = *L*[32] + *L*[47] + *L*[58] + *L*[90] + *L*[121] + *L*[128]'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**f**(*L*) = *L*[32] + *L*[47] + *L*[58] + *L*[90] + *L*[121] + *L*[128]'
- en: where *L*[1], *L*[2], … , *L*[128] are the bits of the LFSR. This feedback function
    takes only 6 bits from the 128-bit LFSR, but that’s enough to get a primitive
    polynomial that guarantees a maximal period. The small number of bits minimizes
    the cost of a hardware implementation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*L*[1]、*L*[2]、…、*L*[128]是LFSR的位。这种反馈函数仅取自128位LFSR中的6个位，但这些足以得到一个原始多项式，保证最大周期。较少的位数最小化了硬件实现的成本。
- en: 'Here is the feedback polynomial of Grain-128a’s NFSR (*N*[1], … , *N*[128]):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Grain-128a的NFSR反馈多项式（*N*[1]、…、*N*[128]）：
- en: '![image](../images/f0087-01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0087-01.jpg)'
- en: This function was carefully chosen to maximize its cryptographic strength while
    minimizing its implementation cost. It has an algebraic degree of 4 because its
    term with the most variables has four variables (namely, *N*[33]*N*[35]*N*[36]*N*[40]).
    Moreover, **g** can’t be approximated by a linear function because it is highly
    nonlinear. Also, in addition to **g**, Grain-128a XORs the bit coming out from
    the LFSRs to feed the result back as the NFSR’s new, rightmost bit.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数经过精心选择，以最大化其密码学强度，同时最小化实现成本。它的代数阶为4，因为其包含最多变量的项有四个变量（即，*N*[33]*N*[35]*N*[36]*N*[40]）。此外，**g**无法通过线性函数近似，因为它是高度非线性的。此外，除了**g**，Grain-128a还将来自LFSRs的位进行XOR运算，将结果反馈作为NFSR的新最右边的位。
- en: The filter function **h** is another nonlinear function; it takes 9 bits from
    the NFSR and 7 bits from the LFSR and combines them in a way that ensures good
    cryptographic properties.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤函数**h**是另一个非线性函数；它从NFSR中取9个位，从LFSR中取7个位，并以确保良好的密码学属性的方式将它们结合在一起。
- en: As I write this, there is no known attack on Grain-128a, and I’m confident that
    it will remain secure. Grain-128a is used in some low-end embedded systems that
    need a compact and fast stream cipher—typically industrial proprietary systems—which
    is why Grain-128a is little known in the open-source software community.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写这段话的时候，Grain-128a没有已知的攻击方法，我相信它将保持安全。Grain-128a被用于一些低端嵌入式系统，这些系统需要紧凑且快速的流加密算法——通常是工业专有系统——这也是Grain-128a在开源软件社区中不为人知的原因。
- en: '*A5/1*'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*A5/1*'
- en: A5/1 is a stream cipher that was used to encrypt voice communications in the
    2G mobile standard. The A5/1 standard was created in 1987 but only published in
    the late 1990s after it was reverse engineered. Attacks appeared in the early
    2000s, and A5/1 was eventually broken in a way that allows actual (rather than
    theoretical) decryption of encrypted communications. Let’s see why and how.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: A5/1是一种流加密算法，曾用于2G移动标准中的语音通信加密。A5/1标准创建于1987年，但直到1990年代末期才发布，因为它是通过逆向工程得出的。2000年代初出现了攻击方法，最终A5/1被破解，能够对加密通信进行实际（而非理论上的）解密。让我们来看看为什么以及如何发生的。
- en: A5/1’s Mechanism
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: A5/1的机制
- en: A5/1 relies on three LFSRs and uses a trick that looks clever at first glance
    but actually fails to be secure (see [Figure 5-9](ch05.xhtml#ch5fig9)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: A5/1依赖于三个LFSR，并使用一个乍一看很巧妙但实际上无法提供安全性的技巧（参见[图5-9](ch05.xhtml#ch5fig9)）。
- en: '![image](../images/f05-09.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-09.jpg)'
- en: '*Figure 5-9: The A5/1 cipher*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-9：A5/1密码*'
- en: 'As you can see in [Figure 5-9](ch05.xhtml#ch5fig9), A5/1 uses LFSRs of 19,
    22, and 23 bits, with the polynomials for each as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图5-9](ch05.xhtml#ch5fig9)中看到的，A5/1使用了19、22和23位的LFSR，每个LFSR的多项式如下：
- en: '![image](../images/f0089-01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0089-01.jpg)'
- en: 'How could this be seen as secure with only LFSRs and no NFSR? The trick lies
    in A5/1’s update mechanism. Instead of updating all three LFSRs at each clock
    cycle, the designers of A5/1 added a clocking rule that does the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如何仅通过LFSRs而没有NFSR来认为这能被视为安全？其中的技巧在于A5/1的更新机制。A5/1的设计者没有在每个时钟周期更新所有三个LFSR，而是添加了一个时钟规则，执行以下操作：
- en: Checks the value of the ninth bit of LFSR 1, the 11th bit of LFSR 2, and the
    11th bit of LFSR 3, called the *clocking bits*. Of those three bits, either all
    have the same value (1 or 0) or exactly two have the same value.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查LFSR 1的第九位、LFSR 2的第十一位和LFSR 3的第十一位，这些被称为*时钟位*。在这三个位中，要么它们的值都相同（1或0），要么恰好有两个值相同。
- en: Clocks the registers whose clocking bits are equal to the majority value, 0
    or 1\. Either two or three LFSRs are clocked at each update.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 时钟对那些时钟位与大多数值相同的寄存器进行时钟操作，0或1。每次更新时，可能会时钟两个或三个LFSR。
- en: Without this simple rule, A5/1 would provide no security whatsoever, and bypassing
    this rule is enough to break the cipher. However, that is easier said than done,
    as you’ll see.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个简单的规则，A5/1根本不会提供任何安全性，绕过这个规则就足以破解密码。然而，正如你将看到的那样，这并不容易实现。
- en: '**NOTE**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In A5/1’s irregular clocking rule, each register is clocked with a probability
    of 3/4 at any update. Namely, the probability that at least one other register
    has the same bit value is 1 – (1/2)², where (1/2)² is the chance that both of
    the other two registers have a different bit value.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*在A5/1的不规则时钟规则中，每个寄存器在每次更新时有3/4的概率被时钟驱动。也就是说，至少有一个其他寄存器具有相同位值的概率是1 – (1/2)²，其中(1/2)²是另外两个寄存器具有不同位值的机会。*'
- en: 2G communications use A5/1 with a key of 64 bits and a 22-bit nonce, which is
    changed for every new data frame. Attacks on A5/1 recover the 64-bit initial state
    of the system (the 19 + 22 + 23 LFSR initial value), thus in turn revealing the
    nonce (if it was not already known) and the key, by unwinding the initialization
    mechanism. The attacks are referred to as *known-plaintext attacks (KPAs)* because
    part of the encrypted data is known, which allows attackers to determine the corresponding
    keystream parts by XORing the ciphertext with the known plaintext chunks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 2G通信使用具有64位密钥和22位随机数的A5/1，每个数据帧都会更改该随机数。对A5/1的攻击可以恢复系统的64位初始状态（19 + 22 + 23的LFSR初始值），进而揭示随机数（如果它尚未被知道）和密钥，通过解开初始化机制。这些攻击被称为*已知明文攻击（KPA）*，因为部分加密数据是已知的，这使得攻击者能够通过将密文与已知的明文片段进行异或运算来确定相应的密钥流部分。
- en: 'There are two main types of attacks on A5/1:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对A5/1的攻击有两种主要类型：
- en: '**Subtle attacks** Exploit the internal linearity of A5/1 and its simple irregular
    clocking system'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**微妙攻击** 利用A5/1的内部线性性及其简单的不规则时钟系统'
- en: '**Brutal attacks** Only exploit the short key of A5/1 and the invertibility
    of the frame number injection'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**暴力攻击** 仅利用A5/1的短密钥和帧号注入的可逆性'
- en: Let’s see how these attacks work.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些攻击是如何工作的。
- en: Subtle Attacks
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 微妙攻击
- en: 'In a subtle attack called a *guess-and-determine* attack, an attacker guesses
    certain secret values of the state in order to determine others. In cryptanalysis,
    “guessing” means brute-forcing: for each possible value of LFSRs 1 and 2, and
    all possible values of LFSR 3’s clocking bit during the first 11 clocks, the attack
    reconstructs LFSR 3’s bits by solving equations that depend on the bits guessed.
    When the guess is correct, the attacker gets the right value for LFSR 3.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在一种叫做*猜测与确定*的微妙攻击中，攻击者猜测状态中的某些秘密值，以确定其他值。在密码分析中，“猜测”意味着暴力破解：对于LFSR 1和LFSR 2的每一个可能值，以及LFSR
    3在前11次时钟期间的所有可能时钟位值，攻击者通过求解依赖于猜测位的方程式来重构LFSR 3的位。当猜测正确时，攻击者得到LFSR 3的正确值。
- en: 'The attack’s pseudocode looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击的伪代码如下：
- en: '[PRE0]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How efficient is this attack compared to the 2^(64)-trial brute-force search
    discussed in [Chapter 3](ch03.xhtml#ch3)? This attack makes at most 2^(19) × 2^(22)
    × 2^(11) = 2^(52) operations in the worst case, when the algorithm only succeeds
    at the very last test. That’s 2^(12) (or about 4000) times faster than in the
    brute-force search, assuming that the last two operations in the above pseudocode
    require about as much computation as testing a 64-bit key in a brute-force search.
    But is this assumption correct?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 相较于在[第3章](ch03.xhtml#ch3)中讨论的2^(64)次暴力搜索，这种攻击的效率如何？在最坏情况下，当算法仅在最后一次测试时成功时，这种攻击最多进行2^(19)
    × 2^(22) × 2^(11) = 2^(52)次操作。假设上述伪代码中的最后两次操作所需的计算量与在暴力搜索中测试64位密钥相当，那么它比暴力搜索快2^(12)（即大约4000）倍。但这个假设是否正确？
- en: 'Recall our discussion of the full attack cost in [Chapter 3](ch03.xhtml#ch3).
    When evaluating the cost of an attack, we need to consider not only the amount
    of computation required to perform the attack but also parallelism and memory
    consumption. Neither are issues here: as with any brute-force attack, the guess-and-determine
    attack is embarrassingly parallel (or *N* times faster when run on *N* cores)
    and doesn’t need more memory than just running the cipher itself.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 回想我们在[第3章](ch03.xhtml#ch3)中对完整攻击成本的讨论。在评估攻击成本时，我们不仅需要考虑执行攻击所需的计算量，还需要考虑并行性和内存消耗。在这里，这两个问题都不是问题：与任何暴力攻击一样，猜测与确定攻击具有显著的并行性（或在*N*个核心上运行时速度是*N*倍），并且不需要比运行密码本身更多的内存。
- en: Our 2^(52) attack cost estimate is inaccurate for another reason. In fact, each
    of the 2^(52) operations (testing a key candidate) takes about four times as many
    clock cycles as does testing a key in a brute-force attack. The upshot is that
    the real cost of this particular attack is closer to 4 × 2^(52) = 2^(54) operations,
    when compared to a brute-force attack.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对2^(52)攻击成本的估计不准确，原因还有一个。实际上，2^(52)次操作（测试一个密钥候选）所需的时钟周期约为暴力破解攻击时的四倍。结果是，与暴力破解攻击相比，这种特定攻击的实际成本更接近4
    × 2^(52) = 2^(54)次操作。
- en: The guess-and-determine attack on A5/1 can decrypt encrypted mobile communications,
    but it takes a couple of hours to recover the key when run on a cluster of dedicated
    hardware devices. In other words, it’s nowhere near real-time decryption. For
    that, we have another type of attack.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对A5/1的猜测-确定攻击可以解密加密的移动通信，但在专用硬件设备集群上运行时，恢复密钥需要几个小时。换句话说，它远不能实现实时解密。要实现这一点，我们还有另一种攻击方式。
- en: Brutal Attacks
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 残酷攻击
- en: The time-memory trade-off (TMTO) attack is the brutal attack on A5/1\. This
    attack doesn’t care about A5/1’s internals; it cares only that its state is 64
    bits long. The TMTO attack sees A5/1 as a black box that takes in a 64-bit value
    (the state) and spits out a 64-bit value (the first 64 keystream bits).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 时间-内存权衡（TMTO）攻击就是对A5/1的残酷攻击。这种攻击不关心A5/1的内部实现；它只关心其状态是64位长的。TMTO攻击将A5/1视为一个黑盒，输入64位值（状态），然后输出64位值（前64位密钥流）。
- en: 'The idea behind the attack is to reduce the cost of a brute-force search in
    exchange for using lots of memory. The simplest type of TMTO is the codebook attack.
    In a codebook attack, you precompute a table of 2^(64) elements containing a combination
    of key and value pairs (key`:`value), and store the output value for each of the
    2^(64) possible keys. To use this precomputed table for the attack, you simply
    collect the output of an A5/1 instance and then look up in the table which key
    corresponds to that output. The attack itself is fast—taking only the amount of
    time necessary to look up a value in memory—but the creation of the table takes
    2^(64) computations of A5/1\. Worse, codebook attacks require an insane amount
    of memory: 2^(64) × (64 + 64) bits, which is 2^(68) bytes or 256 exabytes. That’s
    dozens of data centers, so we can forget about it.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击的思想是，通过使用大量内存来降低暴力搜索的成本。最简单的TMTO类型是代码本攻击。在代码本攻击中，你预计算一个包含2^(64)个元素的表格，表格中包含密钥和值对（key`:`value），并存储每个2^(64)个可能密钥的输出值。要使用这个预计算的表格进行攻击，你只需收集一个A5/1实例的输出，然后在表格中查找哪个密钥对应该输出。攻击本身很快—只需要查找内存中的一个值的时间—但表格的创建需要进行2^(64)次A5/1计算。更糟糕的是，代码本攻击需要大量的内存：2^(64)
    × (64 + 64)位，即2^(68)字节，或者256 exabytes。这相当于数十个数据中心，所以我们可以忘掉这个方法。
- en: TMTO attacks reduce the memory required by a codebook attack at the price of
    increased computation during the online phase of the attack; the smaller the table,
    the more computations required to crack a key. Regardless, it will still cost
    about 2^(64) operations to prepare the table, but that needs to be done only once.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: TMTO攻击通过增加攻击在线阶段的计算量，减少了代码本攻击所需的内存；表格越小，破解一个密钥所需的计算就越多。无论如何，准备表格仍需要大约2^(64)次操作，但这只需要做一次。
- en: In 2010, researchers took about two months to generate two terabytes’ worth
    of tables, using graphics processing units (GPUs) and running 100000 instances
    of A5/1 in parallel. With the help of such large tables, calls encrypted with
    A5/1 could be decrypted almost in real time. Telecommunication operators have
    implemented workarounds to mitigate the attack, but a real solution came with
    the later 3G and 4G mobile telephony standards, which ditched A5/1 altogether.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，研究人员花费约两个月时间，使用图形处理单元（GPU）并行运行100000个A5/1实例，生成了两个TB大小的表格。在这些大型表格的帮助下，使用A5/1加密的通话几乎可以实时解密。电信运营商已实施解决方法来减轻这种攻击，但真正的解决方案出现在后来的3G和4G移动通信标准中，这些标准彻底放弃了A5/1。
- en: Software-Oriented Stream Ciphers
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向软件的流密码
- en: Software stream ciphers work with bytes or 32- or 64-bit words instead of individual
    bits, which proves to be more efficient on modern CPUs where instructions can
    perform arithmetic operations on a word in the same amount of time as on a bit.
    Software stream ciphers are therefore better suited than hardware ciphers for
    servers or browsers running on personal computers, where powerful general-purpose
    processors run the cipher as native software.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 软件流密码使用字节或32位或64位字（而不是单独的比特）进行操作，这在现代CPU上更为高效，因为指令在相同的时间内可以对字进行算术运算，和对比特操作是一样的。因此，软件流密码比硬件密码更适用于运行在个人计算机上的服务器或浏览器，在这些设备上，强大的通用处理器将密码作为原生软件运行。
- en: Today, there is considerable interest in software stream ciphers for a few reasons.
    First, because many devices embed powerful CPUs and hardware has become cheaper,
    there’s less of a need for small bit-oriented ciphers. For example, the two stream
    ciphers in the mobile communications standard 4G (the European SNOW3G and the
    Chinese ZUC) work with 32-bit words and not bits, unlike the older A5/1.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，由于以下几个原因，软件流密码引起了相当大的兴趣。首先，由于许多设备嵌入了强大的CPU，且硬件变得更便宜，因此对小型比特定向密码的需求减少了。例如，移动通信标准4G中的两个流密码（欧洲的SNOW3G和中国的ZUC）使用32位字而不是比特，这与较旧的A5/1不同。
- en: 'Second, stream ciphers have gained popularity in software at the expense of
    block ciphers, notably following the fiasco of the padding oracle attack against
    block ciphers in CBC mode. In addition, stream ciphers are easier to specify and
    to implement than block ciphers: instead of mixing message and key bits together,
    stream ciphers just ingest key bits as a secret. In fact, one of the most popular
    stream ciphers is actually a block cipher in disguise: AES in counter mode (CTR).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，流密码在软件中的流行度超过了块密码，特别是在对块密码的CBC模式填充oracle攻击事件之后。此外，流密码比块密码更容易指定和实现：流密码只是将密钥比特作为机密输入，而不是将消息和密钥比特混合在一起。事实上，最流行的流密码之一实际上是伪装成块密码的：以计数器模式（CTR）使用的AES。
- en: One software stream cipher design, used by SNOW3G and ZUC, copies hardware ciphers
    and their FSRs, replacing bits with bytes or words. But these aren’t the most
    interesting designs for a cryptographer. As of this writing, the two designs of
    most interest are RC4 and Salsa20, which are used in numerous systems, despite
    the fact that one is completely broken.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一种软件流密码设计，SNOW3G和ZUC使用的设计，模仿硬件密码及其线性反馈移位寄存器（FSRs），将比特替换为字节或字。但这些设计对密码学家来说并不是最有趣的设计。截至本文写作时，最受关注的两种设计是RC4和Salsa20，它们被应用于许多系统，尽管其中一种已经完全被攻破。
- en: '*RC4*'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*RC4*'
- en: Designed in 1987 by Ron Rivest of RSA Security, then reverse engineered and
    leaked in 1994, RC4 has long been the most widely used stream cipher. RC4 has
    been used in countless applications, most famously in the first Wi-Fi encryption
    standard Wireless Equivalent Privacy (WEP) and in the Transport Layer Security
    (TLS) protocol used to establish HTTPS connections. Unfortunately, RC4 isn’t secure
    enough for most applications, including WEP and TLS. To understand why, let’s
    see how RC4 works.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: RC4由RSA安全公司（RSA Security）的Ron Rivest于1987年设计，随后在1994年被逆向工程并泄露。RC4长期以来是最广泛使用的流密码。RC4已被应用于无数应用程序中，最著名的包括第一个Wi-Fi加密标准无线等效隐私（WEP）和用于建立HTTPS连接的传输层安全（TLS）协议。不幸的是，RC4对大多数应用程序来说并不够安全，包括WEP和TLS。为了理解原因，让我们看看RC4是如何工作的。
- en: How RC4 Works
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: RC4的工作原理
- en: RC4 is among the simplest ciphers ever created. It doesn’t perform any crypto-like
    operations, and it has no XORs, no multiplications, no S-boxes … nada. It simply
    swaps bytes. RC4’s internal state is an array, *S*, of 256 bytes, first set to
    *S*[0] = 0, *S*[1] = 1, *S*[2] = 2, … , *S*[255] = 255, and then initialized from
    an *n*-byte *K* using its *key scheduling algorithm* *(KSA)*, which works as shown
    in the Python code in [Listing 5-1](ch05.xhtml#ch5list1).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: RC4是迄今为止最简单的密码之一。它不执行任何类似密码学的操作，也没有异或、没有乘法、没有S盒……什么都没有。它只是交换字节。RC4的内部状态是一个256字节的数组*S*，最初设置为*S*[0]
    = 0, *S*[1] = 1, *S*[2] = 2, … , *S*[255] = 255，然后通过*n*字节的*K*使用其*密钥调度算法*（*KSA*）初始化，具体工作方式如[列表5-1](ch05.xhtml#ch5list1)中的Python代码所示。
- en: '[PRE1]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-1: The key scheduling algorithm of RC4*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-1：RC4的密钥调度算法*'
- en: 'Once this algorithm completes, array *S* still contains all the byte values
    from 0 to 255, but now in a random-looking order. For example, with the all-zero
    128-bit key, the state *S* (from *S*[0] to *S*[255]) becomes this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个算法完成，数组*S*仍然包含从0到255的所有字节值，但现在它们的顺序是随机的。例如，对于全零128位密钥，状态*S*（从*S*[0]到*S*[255]）变成了这样：
- en: 0, 35, 3, 43, 9, 11, 65, 229, (…), 233, 169, 117, 184, 31, 39
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 0, 35, 3, 43, 9, 11, 65, 229, (…), 233, 169, 117, 184, 31, 39
- en: 'However, if I flip the first key bit and run the KSA again, I get a totally
    different, apparently random state:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我翻转第一个密钥位并重新运行KSA，我会得到一个完全不同的、看似随机的状态：
- en: 32, 116, 131, 134, 138, 143, 149, (…), 152, 235, 111, 48, 80, 12
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 32, 116, 131, 134, 138, 143, 149, (…), 152, 235, 111, 48, 80, 12
- en: 'Given the initial state *S*, RC4 generates a keystream, *KS*, of the same length
    as the plaintext, *P*, in order to compute a ciphertext: *C* = *P* ⊕ *KS*. The
    bytes of the keystream *KS* are computed from *S* according to the Python code
    in [Listing 5-2](ch05.xhtml#ch5list2), if *P* is *m* bytes long.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 给定初始状态*S*，RC4生成一个与明文*P*长度相同的密钥流*KS*，用于计算密文：*C* = *P* ⊕ *KS*。密钥流*KS*的字节是根据[S5-2](ch05.xhtml#ch5list2)中的Python代码，从*S*计算得出的，如果*P*是*m*字节长。
- en: '[PRE2]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-2: The keystream generation of RC4, where* S *is the state initialized
    in [Listing 5-1](ch05.xhtml#ch5list1)*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-2: RC4的密钥流生成，其中*S*是[Listing 5-1](ch05.xhtml#ch5list1)中初始化的状态*'
- en: 'In [Listing 5-2](ch05.xhtml#ch5list2), each iteration of the `for` loop modifies
    up to 2 bytes of RC4’s internal state *S*: the *S*[*i*] and *S*[*j*] whose values
    are swapped. That is, if *i* = 0 and *j* = 4, and if *S*[0] = 56 and *S*[4] =
    78, then the swap operation sets *S*[0] to 78 and *S*[4] to 56\. If *j* equals
    *i*, then S[*i*] isn’t modified.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在[S5-2](ch05.xhtml#ch5list2)中，每次`for`循环迭代会修改RC4的内部状态*S*中的最多2个字节：*S*[*i*]和*S*[*j*]，它们的值会被交换。也就是说，如果*i*
    = 0且*j* = 4，并且如果*S*[0] = 56且*S*[4] = 78，那么交换操作会将*S*[0]设为78，将*S*[4]设为56。如果*j*等于*i*，则*S*[*i*]不被修改。
- en: This looks too simple to be secure, yet it took 20 years for cryptanalysts to
    find exploitable flaws. Before the flaws were revealed, we only knew RC4’s weaknesses
    in specific implementations, as in the first Wi-Fi encryption standard, WEP.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来过于简单，不足以保证安全，然而，密码学家花了20年才发现可被利用的漏洞。在这些漏洞被揭露之前，我们只知道RC4在特定实现中的弱点，正如在第一个Wi-Fi加密标准WEP中那样。
- en: RC4 in WEP
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: WEP中的RC4
- en: WEP, the first generation Wi-Fi security protocol, is now completely broken
    due to weaknesses in the protocol’s design and in RC4.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: WEP，第一代Wi-Fi安全协议，由于协议设计和RC4的弱点，现在已经完全被攻破。
- en: In its WEP implementation, RC4 encrypts payload data of 802.11 frames, the datagrams
    (or packets) that transport data over the wireless network. All payloads delivered
    in the same session use the same secret key of 40 or 104 bits but have what is
    a supposedly unique 3-byte nonce encoded in the frame header (the part of the
    frame that encodes metadata and comes before the actual payload). See the problem?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在其WEP实现中，RC4加密802.11帧的有效载荷数据，这些数据报（或数据包）在无线网络上传输数据。所有在同一会话中传输的有效载荷使用相同的40位或104位密钥，但帧头中编码了一个所谓的唯一的3字节nonce（这是帧的部分，包含元数据，位于实际有效载荷之前）。看到问题了吗？
- en: 'The problem is that RC4 doesn’t support a nonce, at least not in its official
    specification, and a stream cipher can’t be used without a nonce. The WEP designers
    addressed this limitation with a workaround: they included a 24-bit nonce in the
    wireless frame’s header and prepended it to the WEP key to be used as RC4’s secret
    key. That is, if the nonce is the bytes *N*[0], *N*[1], *N*[2] and the WEP key
    is *K*[0], *K*[1], *K*[2], *K*[3], *K*[4], the actual RC4 key is *N*[0], *N*[1],
    *N*[2], *K*[0], *K*[1], *K*[2], *K*[3], *K*[4]. The net effect is to have 40-bit
    secret keys yield 64-bit effective keys, and 104-bit keys yield 128-bit effective
    keys. The result? The advertised 128-bit WEP protocol actually offers only 104-bit
    security, at best.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，RC4不支持nonce，至少在其官方规格中不支持，并且流加密算法在没有nonce的情况下无法使用。WEP设计者通过一种变通方法解决了这个限制：他们在无线帧的头部加入了一个24位的nonce，并将其添加到WEP密钥中，作为RC4的密钥。也就是说，如果nonce是字节*N*[0]、*N*[1]、*N*[2]，WEP密钥是*K*[0]、*K*[1]、*K*[2]、*K*[3]、*K*[4]，那么实际的RC4密钥就是*N*[0]、*N*[1]、*N*[2]、*K*[0]、*K*[1]、*K*[2]、*K*[3]、*K*[4]。其结果是，40位的密钥变成了64位有效密钥，104位的密钥变成了128位有效密钥。结果呢？广告中所说的128位WEP协议实际上最多只能提供104位的安全性。
- en: 'But here are the real problems with WEP’s nonce trick:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，WEP的随机数（nonce）技巧存在真正的问题：
- en: '**The nonces are too small at only 24 bits**. This means that if a nonce is
    chosen randomly for each new message, you’ll have to wait about 2^(24/2) = 2^(12)
    packets, or a few megabytes’ worth of traffic, until you can find two packets
    encrypted with the same nonce, and thus the same keystream. Even if the nonce
    is a counter running from 0 to 2^(24) – 1, it will take a few gigabytes’ worth
    of data until a rollover, when the repeated nonce can allow the attacker to decrypt
    packets. But there’s a bigger problem.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nonce太小，只有24位**。这意味着，如果每个新消息都随机选择一个nonce，你需要等待大约2^(24/2) = 2^(12)个数据包，或者几兆字节的流量，才能找到两个使用相同nonce加密的数据包，从而得到相同的密钥流。即便nonce是一个从0到2^(24)-1的计数器，直到发生溢出，攻击者也需要几GB的数据才能找到重复的nonce，从而使得攻击者能够解密数据包。但更大的问题是：'
- en: '**Combining the nonce and key in this fashion helps recover the key**. WEP’s
    three non-secret nonce bytes let an attacker determine the value of *S* after
    three iterations of the key scheduling algorithm. Because of this, cryptanalysts
    found that the first keystream byte strongly depends on the first secret key byte—the
    fourth byte ingested by the KSA—and that this bias can be exploited to recover
    the secret key.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以这种方式将nonce和密钥结合有助于恢复密钥**。WEP的三个非机密的nonce字节使得攻击者可以在经过三次密钥调度算法迭代后确定*S*的值。因此，密码分析师发现，第一个密钥流字节强烈依赖于第一个机密密钥字节——即KSA处理的第四个字节——而且这种偏差可以被利用来恢复机密密钥。'
- en: 'Exploiting those weaknesses requires access to both ciphertexts and the keystream;
    that is, known or chosen plaintexts. But that’s easy enough: known plaintexts
    occur when the Wi-Fi frames encapsulate data with a known header, and chosen plaintexts
    occur when the attacker injects known plaintext encrypted with the target key.
    The upshot is that the attacks work in practice, not just on paper.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些弱点需要访问到密文和密钥流；也就是说，已知明文或选择明文。但这很容易做到：已知明文出现在Wi-Fi帧中，当这些帧封装了已知的头部数据时，选择明文则发生在攻击者注入已知明文并使用目标密钥加密的情况下。结果是，这些攻击在实际中有效，而不仅仅是纸面上有效。
- en: Following the appearance of the first attacks on WEP in 2001, researchers found
    faster attacks that required fewer ciphertexts. Today, you can even find tools
    such as aircrack-ng that implement the entire attack, from network sniffing to
    cryptanalysis.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在2001年首次出现WEP攻击后，研究人员发现了更快的攻击方法，只需要更少的密文。今天，你甚至可以找到像aircrack-ng这样的工具，来实现从网络嗅探到密码分析的整个攻击过程。
- en: WEP’s insecurity is due to both weaknesses in RC4, which takes a single one-use
    key instead of a key and nonce (as in any decent stream cipher), and weaknesses
    in the WEP design itself.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: WEP的不安全性既来源于RC4的缺陷，RC4使用的是单一的一次性密钥，而不是像任何合适的流密码那样使用密钥和nonce的组合，也来源于WEP设计本身的缺陷。
- en: Now let’s look at the second biggest failure of RC4.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看RC4的第二大失败。
- en: RC4 in TLS
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: TLS中的RC4
- en: TLS is the single most important security protocol used on the internet. It
    is best known for underlying HTTPS connections, but it’s also used to protect
    some virtual private network (VPN) connections, as well as email servers, mobile
    applications, and many others. And sadly, TLS has long supported RC4.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: TLS是互联网上使用的最重要的安全协议。它最著名的是作为HTTPS连接的基础，但它也用于保护一些虚拟专用网络（VPN）连接、电子邮件服务器、移动应用程序等。可悲的是，TLS长期以来一直支持RC4。
- en: Unlike WEP, the TLS implementation doesn’t make the same blatant mistake of
    tweaking the RC4 specs in order to use a public nonce. Instead, TLS just feeds
    RC4 a unique 128-bit session key, which means it’s a bit less broken than WEP.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与WEP不同，TLS的实现并没有犯同样的明显错误，即为了使用公共nonce而修改RC4规格。相反，TLS只是为RC4提供了一个唯一的128位会话密钥，这意味着它比WEP稍微安全一些。
- en: 'The weakness in TLS is due only to RC4 and its inexcusable flaws: statistical
    biases, or non-randomness, which we know is a total deal breaker for a stream
    cipher. For example, the second keystream byte produced by RC4 is zero, with a
    probability of 1/128, whereas it should be 1/256 ideally. (Recall that a byte
    can take 256 values from 0 to 255; hence, a truly random byte is zero with a chance
    of 1/256.) Crazier still is the fact that most experts continued to trust RC4
    as late as 2013, even though its statistical biases have been known since 2001.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: TLS的弱点仅仅是由于RC4及其不可原谅的缺陷：统计偏差或非随机性，而我们知道这是流密码的致命缺陷。例如，RC4产生的第二个密钥流字节为零的概率为1/128，而理想情况下应该是1/256。（回想一下，一个字节可以取0到255之间的256个值；因此，一个真正随机的字节出现零的概率应该是1/256。）更疯狂的是，尽管自2001年起就已经知道RC4的统计偏差，大多数专家直到2013年仍然继续信任RC4。
- en: RC4’s known statistical biases should have been enough to ditch the cipher altogether,
    even if we didn’t know how to exploit the biases to compromise actual applications.
    In TLS, RC4’s flaws weren’t publicly exploited until 2011, but the NSA allegedly
    managed to exploit RC4’s weaknesses to compromise TLS’s RC4 connections well before
    then.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: RC4 的已知统计偏差本应足以让我们完全放弃这种加密算法，即使我们不知道如何利用这些偏差来破坏实际应用。在 TLS 中，RC4 的缺陷直到 2011 年才被公开利用，但据称，NSA
    在那之前就已经利用 RC4 的弱点来破解 TLS 的 RC4 连接。
- en: As it turned out, not only was RC4’s second keystream byte biased, but all of
    the first 256 bytes were biased as well. In 2011, researchers found that the probability
    that one of those bytes comes to zero equals 1/256 + *c*/256², for some constant,
    *c*, taking values between 0.24 and 1.34\. It’s not just for the byte zero but
    for other byte values as well. The amazing thing about RC4 is that it fails where
    even many noncryptographic PRNGs succeed—namely, at producing uniformly distributed
    pseudorandom bytes (that is, where each of the 256 bytes has a chance of 1/256
    of showing up).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，RC4 的第二个密钥流字节有偏差，而前 256 个字节也都有偏差。2011 年，研究人员发现，这些字节中某个字节为零的概率等于 1/256 +
    *c*/256²，其中 *c* 是一个常数，取值范围在 0.24 到 1.34 之间。这不仅仅是针对字节零，其他字节值也存在这种偏差。RC4 的惊人之处在于，它在许多非加密的伪随机数生成器（PRNG）成功的地方失败——即生成均匀分布的伪随机字节（也就是说，每个
    256 个字节中，每个字节出现的概率为 1/256）。
- en: 'Even the weakest attack model can be used to exploit RC4’s flawed TLS implementation:
    basically, you collect ciphertexts and look for the plaintext, not the key. But
    there’s a caveat: you’ll need many ciphertexts, encrypting *the same plaintext*
    several times using different secret keys. This attack model is sometimes called
    the *broadcast model*, because it’s akin to broadcasting the same message to multiple
    recipients.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最弱的攻击模型也可以用来利用 RC4 在 TLS 实现中的缺陷：基本上，你收集密文并寻找明文，而不是密钥。但有一个警告：你需要多条密文，使用不同的密钥多次加密
    *相同的明文*。这种攻击模型有时被称为 *广播模型*，因为它类似于将相同的消息广播给多个接收者。
- en: 'For example, say you want to decrypt the plaintext byte *P*[1] given many ciphertext
    bytes obtained by intercepting the different ciphertexts of the same message.
    The first four ciphertext bytes will therefore look like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想要解密明文字节 *P*[1]，而你已经截获了多条相同消息的不同密文字节。那样，前四个密文字节将看起来像这样：
- en: '![image](../images/f0095-01.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0095-01.jpg)'
- en: Because of RC4’s bias, keystream bytes *KS*[1]^(*i*) are more likely to be zero
    than any other byte value. Therefore, *C*[1]^(*i*) bytes are more likely to be
    equal to *P*[1] than to any other value. In order to determine *P*[1] given the
    *C*[1]^(*i*) bytes, you simply count the number of occurrences of each byte value
    and return the most frequent one as *P*[1]. However, because the statistical bias
    is very small, you’ll need millions of values to get it right with any certainty.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RC4 的偏差，密钥流字节 *KS*[1]^(*i*) 更有可能为零，而不是其他字节值。因此，*C*[1]^(*i*) 字节更有可能等于 *P*[1]，而不是任何其他值。为了根据
    *C*[1]^(*i*) 字节确定 *P*[1]，你只需计算每个字节值的出现次数，并返回出现频率最高的字节作为 *P*[1]。然而，由于统计偏差非常小，你需要数百万个字节值才能有足够的把握得到正确答案。
- en: The attack generalizes to recover more than one plaintext byte and to exploit
    more than one biased value (zero here). The algorithm just becomes a bit more
    complicated. However, this attack is hard to put into practice because it needs
    to collect many ciphertexts encrypting the same plaintext but using different
    keys. For example, the attack can’t break all TLS-protected connections that use
    RC4 because you need to trick the server into encrypting the same plaintext to
    many different recipients, or many times to the same recipient with different
    keys.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个攻击可以推广到恢复多个明文字节，并利用多个偏差值（这里是零）。算法只会变得稍微复杂一些。然而，这个攻击难以付诸实践，因为它需要收集多条加密相同明文但使用不同密钥的密文。例如，这种攻击无法破解所有使用
    RC4 的 TLS 保护连接，因为你需要欺骗服务器加密相同的明文并发送给多个接收者，或者用不同的密钥多次加密同一个接收者。
- en: '*Salsa20*'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Salsa20*'
- en: Salsa20 is a simple, software-oriented cipher optimized for modern CPUs that
    has been implemented in numerous protocols and libraries, along with its variant,
    ChaCha. Its designer, respected cryptographer Daniel J. Bernstein, submitted Salsa20
    to the eSTREAM competition in 2005 and won a place in eSTREAM’s software portfolio.
    Salsa20’s simplicity and speed have made it popular among developers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20是一种简单的软件导向密码，针对现代CPU进行了优化，并已在众多协议和库中实现，以及它的变种ChaCha。其设计者、备受尊敬的密码学家丹尼尔·J·伯恩斯坦（Daniel
    J. Bernstein）在2005年将Salsa20提交到eSTREAM竞赛，并成功获得eSTREAM软件组合中的一席之地。Salsa20的简单性和速度使它在开发者中广受欢迎。
- en: '![image](../images/f05-10.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-10.jpg)'
- en: '*Figure 5-10: Salsa20’s encryption scheme for a 512-bit plaintext block*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-10：Salsa20对512位明文块的加密方案*'
- en: Salsa20 is a counter-based stream cipher—it generates its keystream by repeatedly
    processing a counter incremented for each block. As you can see in [Figure 5-10](ch05.xhtml#ch5fig10),
    the *Salsa20 core* algorithm transforms a 512-bit block using a key (*K*), a nonce
    (*N*), and a counter value (*Ctr*). Salsa20 then adds the result to the original
    value of the block to produce a *keystream block*. (If the algorithm were to return
    the core’s permutation directly as an output, Salsa20 would be totally insecure,
    because it could be inverted. The final addition of the initial secret state *K*
    || *N* || *Ctr* makes the transform key-to-keystream-block non-invertible.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20是一种基于计数器的流密码——它通过不断处理递增的计数器生成密钥流。正如在[图5-10](ch05.xhtml#ch5fig10)中所示，*Salsa20核心*算法使用一个密钥（*K*）、一个随机数（*N*）和一个计数器值（*Ctr*）来转换一个512位的块。然后，Salsa20将结果加到该块的原始值上，生成一个*密钥流块*。（如果算法直接返回核心的置换结果作为输出，Salsa20将完全不安全，因为它可以被反转。最终将初始秘密状态*K*
    || *N* || *Ctr* 加入，使得转换从密钥到密钥流块不可逆。）
- en: The Quarter-Round Function
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 四分之一轮函数
- en: 'Salsa20’s core permutation uses a function called *quarter-round* (**QR**)
    to transform four 32-bit words (*a*, *b*, *c*, and *d*), as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20的核心置换使用一个叫做*四分之一轮*（**QR**）的函数来转换四个32位字（*a*，*b*，*c*，和*d*），如图所示：
- en: '![image](../images/f0096-01.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0096-01.jpg)'
- en: These four lines are computed from top to bottom, meaning that the new value
    of *b* depends on *a* and *d*, the new value of *c* depends on *a* and on the
    new value of *b* (and thus *d* as well), and so on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这四行是从上到下计算的，这意味着*b*的新值依赖于*a*和*d*，*c*的新值依赖于*a*和*b*的新值（因此也依赖于*d*），以此类推。
- en: 'The operation <<< is wordwise left-rotation by the specified number of bits,
    which can be any value between 1 and 31 (for 32-bit words). For example, <<< 8
    rotates a word’s bits of eight positions toward the left, as shown in these examples:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 操作<<<是按字进行的左旋转，旋转的位数可以是1到31之间的任意值（对于32位字）。例如，<<< 8表示将一个字的位向左旋转八个位，如以下示例所示：
- en: '![image](../images/f0096-02.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0096-02.jpg)'
- en: Transforming Salsa20’s 512-bit State
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转换Salsa20的512位状态
- en: Salsa20’s core permutation transforms a 512-bit internal state viewed as a 4
    × 4 array of 32-bit words. [Figure 5-11](ch05.xhtml#ch5fig11) shows the initial
    state, using a key of eight words (256 bits), a nonce of two words (64 bits),
    a counter of two words (64 bits), and four fixed constant words (128 bits) that
    are identical for each encryption/decryption and all blocks.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20的核心置换将一个512位的内部状态视为一个4 × 4的32位字数组进行转换。[图5-11](ch05.xhtml#ch5fig11)显示了初始状态，使用了一个包含八个字（256位）的密钥、两个字（64位）的随机数、两个字（64位）的计数器和四个固定的常数字（128位），这些常数对于每次加密/解密以及所有块都是相同的。
- en: To transform the initial 512-bit state, Salsa20 first applies the **QR** transform
    to all four columns independently (known as the *column-round*) and then to all
    four rows independently (the *row-round*), as shown in [Figure 5-12](ch05.xhtml#ch5fig12).
    The sequence column-round/row-round is called a *double-round*. Salsa20 repeats
    10 double-rounds, for 20 rounds in total, thus the *20* in *Salsa20*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了转换初始的512位状态，Salsa20首先将**QR**变换独立应用于所有四列（称为*列轮*），然后应用于所有四行（*行轮*），如[图5-12](ch05.xhtml#ch5fig12)所示。列轮/行轮的序列称为*双轮*。Salsa20重复进行10个双轮，总共进行20轮，因此得名*Salsa20*。
- en: '![image](../images/f05-11.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-11.jpg)'
- en: '*Figure 5-11: The initialization of Salsa20’s state*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-11：Salsa20状态的初始化*'
- en: '![image](../images/f05-12.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-12.jpg)'
- en: '*Figure 5-12: Columns and rows transformed by Salsa20’s quarter-round (**QR**)
    function*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-12：Salsa20的四分之一轮（**QR**）函数转化的列和行*'
- en: 'The **column-round** transforms the four columns like so:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**列轮**将四列如图所示转换：'
- en: '![image](../images/f0097-01.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0097-01.jpg)'
- en: 'The **row-round** transforms the rows by doing the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**行轮**通过以下方式转换行：'
- en: '![image](../images/f0097-02.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0097-02.jpg)'
- en: Notice that in a column-round, each **QR** takes *x*[*i*] arguments ordered
    from the top to the bottom line, whereas a row-round’s **QR** takes as a first
    argument the words on the diagonal (as shown in the array on the right in [Figure
    5-12](ch05.xhtml#ch5fig12)) rather than words from the first column.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在列轮（column-round）中，每个**QR**都会按照从上到下的顺序接受 *x*[*i*] 参数，而行轮（row-round）的**QR**则将对角线上的单词作为第一个参数（如[图
    5-12](ch05.xhtml#ch5fig12)右侧的数组所示），而不是来自第一列的单词。
- en: Evaluating Salsa20
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 评估Salsa20
- en: '[Listing 5-3](ch05.xhtml#ch5list3) shows Salsa20’s initial states for the first
    and second blocks when initialized with an all-zero key (`00` bytes) and an all-one
    nonce (`ff` bytes). These two states differ in only one bit, in the counter, as
    shown in bold: specifically, 0 for the first block and 1 for the second.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-3](ch05.xhtml#ch5list3) 显示了Salsa20在使用全零密钥（`00` 字节）和全一 nonce（`ff` 字节）初始化时，第一个和第二个块的初始状态。这两个状态仅在计数器中有一位差异，如粗体所示：具体来说，第一个块为0，第二个块为1。'
- en: '[PRE3]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-3: Salsa20’s initial states for the first two blocks with an all-zero
    key and an all-one nonce*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：使用全零密钥和全一nonce初始化的前两个块的Salsa20初始状态*'
- en: Yet, despite only a one-bit difference, the respective internal states after
    10 double-rounds are totally different from each other, as [Listing 5-4](ch05.xhtml#ch5list4)
    shows.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管只有一位差异，但在经过10次双轮之后，各自的内部状态彼此之间完全不同，如[清单 5-4](ch05.xhtml#ch5list4)所示。
- en: '[PRE4]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-4: The states from [Listing 5-3](ch05.xhtml#ch5list3) after 10 Salsa20
    double-rounds*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4：经过10次Salsa20双轮后的[清单 5-3](ch05.xhtml#ch5list3)状态*'
- en: But remember, even though word values in the keystream block may look random,
    we’ve seen that it’s far from a guarantee of security. RC4’s output looks random,
    but it has blatant biases. Fortunately, Salsa20 is much more secure than RC4 and
    doesn’t have statistical biases.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请记住，尽管密钥流块中的单词值看起来是随机的，但我们已经看到，这远不能保证安全性。RC4的输出看起来是随机的，但它有明显的偏差。幸运的是，Salsa20比RC4安全得多，并且没有统计偏差。
- en: Differential Cryptanalysis
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 差分密码分析
- en: 'To demonstrate why Salsa20 is more secure than RC4, let’s have a look at the
    basics of *differential cryptanalysis*, the study of the differences between states
    rather than their actual values. For example, the two initial states in [Figure
    5-13](ch05.xhtml#ch5fig13) differ by one bit in the counter, or by the word *x*[8]
    in the Salsa20 state array. The bitwise difference between these two states is
    thus shown in this array:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明Salsa20比RC4更安全，我们来看看*差分密码分析*的基础，即研究状态之间的差异，而不是它们的实际值。例如，[图 5-13](ch05.xhtml#ch5fig13)中的两个初始状态在计数器中有一位差异，或者在Salsa20的状态数组中由单词
    *x*[8] 表示。这两个状态之间的逐位差异在这个数组中展示如下：
- en: '![image](../images/f0098-01.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0098-01.jpg)'
- en: The difference between the two states is actually the XOR of these states. The
    1 bit shown in bold corresponds to a 1-bit difference between the two states.
    In the XOR of the two states, any nonzero bits indicate differences.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个状态之间的差异实际上是这两个状态的异或（XOR）。粗体显示的1位对应于这两个状态之间的1位差异。在两个状态的XOR中，任何非零的位都表示存在差异。
- en: 'To see how fast changes propagate in the initial state as a result of Salsa20’s
    core algorithm, let’s look at the difference between two states throughout the
    rounds iteration. After one round, the difference propagates across the first
    column to two of the three other words in that column:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看Salsa20的核心算法如何快速传播变化，我们来看一下初始状态在整个轮次迭代中的差异。经过一轮之后，差异传播到第一列的三个单词中的两个：
- en: '![image](../images/f0098-02.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0098-02.jpg)'
- en: 'After two rounds, differences further propagate across the rows that already
    include a difference, which is all but the second row. At this point the differences
    between the states are rather sparse; not many bits have changed within a word
    as shown here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 经过两轮后，差异进一步传播到已经包含差异的行中，除了第二行。此时，状态之间的差异相当稀疏；如图所示，单词内部的变化位数不多：
- en: '![image](../images/f0099-01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0099-01.jpg)'
- en: 'After three rounds, the differences between the states become more dense, though
    the many zero nibbles indicate that many bit positions are still not affected
    by the initial difference:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 三轮之后，状态之间的差异变得更加密集，尽管许多零位表明许多比特位置仍然未受到初始差异的影响：
- en: '![image](../images/f0099-02.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0099-02.jpg)'
- en: 'After four rounds, differences look random to a human observer, and they are
    also almost random statistically as well, as shown here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 四轮之后，差异对于人类观察者看起来是随机的，从统计学角度来看，它们也几乎是随机的，如下所示：
- en: '![image](../images/f0099-03.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0099-03.jpg)'
- en: So after only four rounds, a single difference propagates to most of the bits
    in the 512-bit state. In cryptography, this is called *full diffusion*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，仅经过四轮，一个单一的差异就会传播到512位状态的大部分位。在密码学中，这称为*完全扩散*。
- en: We’ve seen that differences propagate quickly throughout Salsa20 rounds. But
    not only do differences propagate across all states, they also do so according
    to complex equations that make future differences hard to predict because highly
    *nonlinear* relations drive the state’s evolution, thanks to the mix of XOR, addition,
    and rotation. If only XORs were used, we’d still have many differences propagating,
    but the process would be linear and therefore insecure.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到差异在Salsa20的轮次中迅速传播。但不仅差异会跨越所有状态传播，它们还会按照复杂的方程传播，这使得未来的差异难以预测，因为高度的*非线性*关系推动了状态的演变，这要归功于XOR、加法和旋转的混合。如果仅使用XOR，差异仍然会传播，但过程将是线性的，因此不安全。
- en: Attacking Salsa20/8
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 攻击Salsa20/8
- en: Salsa20 makes 20 rounds by default, but it’s sometimes used with only 12 rounds,
    in a version called Salsa20/12, to make it faster. Although Salsa20/12 uses eight
    fewer rounds than Salsa20, it’s still significantly stronger than the weaker Salsa20/8,
    another version with eight rounds, which is more rarely used.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20默认进行20轮，但有时仅使用12轮，这个版本被称为Salsa20/12，目的是使其运行更快。尽管Salsa20/12比Salsa20少了八轮，但它仍然比更弱的Salsa20/8强得多，后者只有八轮，且较少使用。
- en: Breaking Salsa20 should ideally take 2^(256) operations, thanks to its use of
    a 256-bit key. If the key can be recovered by performing any fewer than 2^(256)
    operations, the cipher is in theory broken. That’s exactly the case with Salsa20/8.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 破解Salsa20理想情况下需要进行2^(256)次操作，因为它使用的是256位密钥。如果通过进行少于2^(256)次操作就能恢复密钥，那么该密码算法在理论上就被攻破了。这正是Salsa20/8的情况。
- en: 'The attack on Salsa20/8 (published in the 2008 paper *New Features of Latin
    Dances: Analysis of Salsa, ChaCha, and Rumba*, of which I’m a co-author, and for
    which we won a cryptanalysis prize from Daniel J. Bernstein) exploits a statistical
    bias in Salsa’s core algorithm after four rounds to recover the key of eight-round
    Salsa20\. In reality, this is mostly a theoretical attack: we estimate its complexity
    at 2^(251) operations of the core function—impossible, but less so than breaking
    the expected 2^(256) complexity.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对Salsa20/8的攻击（在2008年发表的论文《拉丁舞蹈的新特征：Salsa、ChaCha和Rumba的分析》中发布，我是该论文的共同作者，并因此获得了丹尼尔·J·伯恩斯坦颁发的密码分析奖）利用了Salsa核心算法在四轮之后的统计偏差来恢复八轮Salsa20的密钥。实际上，这主要是一个理论攻击：我们估计其复杂度为2^(251)次核心函数操作——虽然不可能，但比破解预计的2^(256)复杂度要容易一些。
- en: 'The attack exploits not only a bias over the first four rounds of Salsa20/8,
    but also a property of the last four rounds: knowing the nonce, *N*, and the counter,
    *Ctr* (refer back to [Figure 5-10](ch05.xhtml#ch5fig10)), the only value needed
    to invert the computation from the keystream back to the initial state is the
    key, *K*. But as shown in [Figure 5-13](ch05.xhtml#ch5fig13), if you only know
    some part of *K*, you can partially invert the computation up until the fourth
    round and observe some bits of that intermediate state—including the biased bit!
    You’ll only observe the bias if you have the correct guess of the partial key;
    hence, the bias serves as an indicator that you’ve got the correct key.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击不仅利用了Salsa20/8前四轮的偏差，还利用了最后四轮的一个特性：知道nonce，*N*，和计数器，*Ctr*（请参考[图5-10](ch05.xhtml#ch5fig10)），从密钥流反向计算回初始状态所需的唯一值是密钥，*K*。但如[图5-13](ch05.xhtml#ch5fig13)所示，如果你只知道*K*的某一部分，你可以在第四轮之前部分反转计算，并观察该中间状态的一些位——包括偏差位！只有当你正确猜测部分密钥时，才能观察到偏差；因此，偏差作为一个指示器，表明你得到了正确的密钥。
- en: '![image](../images/f05-13.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f05-13.jpg)'
- en: '*Figure 5-13: The principle of the attack on Salsa20/8*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-13：Salsa20/8攻击的原理*'
- en: In the actual attack on Salsa20/8, in order to determine the correct guess,
    we need to guess 220 bits of the key, and we need 2^(31) pairs of keystream blocks,
    all with the same specific difference in the nonce. Once we’ve singled out the
    correct 220 bits, we simply need to brute-force 36 bits. The brute-forcing takes
    2^(36) operations, a computation that dwarfs the unrealistic 2^(220) × 2^(31)
    = 2^(251) trials needed to find the 220 bits to complete the first part of the
    attack.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在对Salsa20/8的实际攻击中，为了确定正确的猜测，我们需要猜测**220位**的密钥，并且需要2^(31)对密钥流块，它们在nonce的差异上是相同的。一旦我们找到了正确的220位，我们只需暴力破解36位。暴力破解需要2^(36)次操作，这一计算远远超过了找到这220位所需的2^(220)
    × 2^(31) = 2^(251)次试验，这是攻击的第一部分所需的试验次数。
- en: How Things Can Go Wrong
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误的地方
- en: Alas, many things can go wrong with stream ciphers, from brittle, insecure designs
    to strong algorithms incorrectly implemented. I’ll explore each category of potential
    problems in the following sections.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 唉，流密码有许多可能出错的地方，从脆弱、不安全的设计到错误实现的强算法。我将在接下来的章节中探讨每类潜在问题。
- en: '*Nonce Reuse*'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Nonce 重用*'
- en: 'The most common failure seen with stream ciphers is an amateur mistake: it
    occurs when a nonce is reused more than once with the same key. This produces
    identical keystreams, allowing you to break the encryption by XORing two ciphertexts
    together. The keystream then vanishes, and you’re left with the XOR of the two
    plaintexts.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 流密码中最常见的失败是一个业余错误：当一个**nonce**与相同的密钥被多次重用时，就会发生这种错误。这会产生相同的密钥流，使你可以通过将两个密文进行异或操作来破解加密。这样，密钥流就会消失，剩下的就是两个明文的异或结果。
- en: For example, older versions of Microsoft Word and Excel used a unique nonce
    for each document, but the nonce wasn’t changed once the document was modified.
    As a result, the clear and encrypted text of an older version of a document could
    be used to decrypt later encrypted versions. If even Microsoft made this kind
    of blunder, you can imagine how large the problem might be.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Microsoft Word和Excel的旧版本为每个文档使用了唯一的nonce，但一旦文档被修改，nonce就不会再改变。因此，旧版本文档的明文和加密文本可以用于解密后续加密版本。如果连Microsoft都犯下了这样的错误，你可以想象这个问题可能有多大。
- en: Certain stream ciphers designed in the 2010s tried to mitigate the risk of nonce
    reuse by building “misuse-resistant” constructions, or ciphers that remain secure
    even if a nonce is used twice. However, achieving this level of security comes
    with a performance penalty, as we’ll see in [Chapter 8](ch08.xhtml#ch8) with the
    SIV mode.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在2010年代设计的流密码通过构建“抗滥用”结构（或即使nonce被重用也能保持安全的密码）来试图降低nonce重用的风险。然而，达到这种安全水平是有性能代价的，正如我们在[第8章](ch08.xhtml#ch8)中看到的SIV模式一样。
- en: '*Broken RC4 Implementation*'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*RC4的错误实现*'
- en: Though it’s already weak, RC4 can become even weaker if you blindly optimize
    its implementation. For example, consider the following entry in the 2007 Underhanded
    C Contest, an informal competition where programmers write benign-looking code
    that actually includes a malicious function.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管RC4已经很弱，但如果你盲目优化它的实现，它可能会变得更弱。例如，考虑2007年Underhanded C Contest中的一个例子，这是一个非正式的竞赛，程序员编写看似无害的代码，实际上包含恶意功能。
- en: 'Here’s how it works. The naive way to implement the line `swap(S[i], S[j])`
    in RC4’s algorithm is to do the following, as expressed in this Python code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的工作原理。在RC4算法中，实施`swap(S[i], S[j])`的最直接方式是按照下面的Python代码来操作：
- en: '[PRE5]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This way of swapping two variables obviously works, but you need to create
    a new variable, `buf`. To avoid this, programmers often use the *XOR-swap* trick,
    shown here, to swap the values of the variables `x` and `y`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 交换两个变量的这种方法显然有效，但你需要创建一个新的变量，`buf`。为了避免这种情况，程序员通常使用*XOR交换*技巧，如下所示，用来交换变量`x`和`y`的值：
- en: '[PRE6]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This trick works because the second line sets `y` to `x` ⊕ `y` ⊕ `y = x`, and
    the third line sets `x` to `x` ⊕ `y` ⊕ `x` ⊕ `y` ⊕ `y = y`. Using this trick to
    implement RC4 gives the implementation shown in [Listing 5-5](ch05.xhtml#ch5list5)
    (adapted from Wagner and Biondi’s program submitted to the Underhanded C Contest,
    and online at *[http://www.underhanded-c.org/_page_id_16.html](http://www.underhanded-c.org/_page_id_16.html)*).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧之所以有效，是因为第二行将`y`设置为`x ⊕ y`，然后第三行将`x`设置为`x ⊕ y ⊕ x ⊕ y ⊕ y = y`。使用这个技巧来实现RC4的结果，如[清单5-5](ch05.xhtml#ch5list5)所示（改编自Wagner和Biondi提交的程序，参与了Underhanded
    C Contest，并在线发布于*[http://www.underhanded-c.org/_page_id_16.html](http://www.underhanded-c.org/_page_id_16.html)*）。
- en: '[PRE7]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-5: Incorrect C implementation of RC4, due to its use of an XOR swap*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单5-5：由于使用了XOR交换，RC4的C语言实现错误*'
- en: Now stop reading, and try to spot the problem with the XOR swap in [Listing
    5-5](ch05.xhtml#ch5list5).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在停止阅读，尝试找出 [Listing 5-5](ch05.xhtml#ch5list5) 中 XOR 交换的问题。
- en: 'Things will go south when `i = j`. Instead of leaving the state unchanged,
    the XOR swap will set `S[i]` to `S[i]` ⊕ `S[i] = 0`. In effect, a byte of the
    state will be set to zero each time `i` equals `j` in the key schedule or during
    encryption, ultimately leading to an all-zero state and thus to an all-zero keystream.
    For example, after 68KB of data have been processed, most of the bytes in the
    256-byte state are zero, and the output keystream looks like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `i = j` 时，事情就会出问题。与其让状态保持不变，XOR 交换会将 `S[i]` 设置为 `S[i]` ⊕ `S[i] = 0`。实际上，每当密钥调度或加密过程中
    `i` 等于 `j` 时，状态中的一个字节会被设置为零，最终导致全零状态，从而生成全零的密钥流。例如，当处理了 68KB 的数据后，256 字节状态中的大部分字节都变成了零，输出的密钥流看起来如下：
- en: 00 00 00 00 00 00 00 53 53 00 00 00 00 00 00 00 00 00 00 00 13 13 00 5c 00 a5
    00 00 …
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 00 00 00 00 00 00 00 53 53 00 00 00 00 00 00 00 00 00 00 00 13 13 00 5c 00 a5
    00 00 …
- en: The lesson here is to refrain from over-optimizing your crypto implementations.
    Clarity and confidence always trump performance in cryptography.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，避免过度优化你的加密实现。在加密学中，清晰和自信总是优于性能。
- en: '*Weak Ciphers Baked Into Hardware*'
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*弱加密算法嵌入硬件中*'
- en: When a cryptosystem fails to be secure, some systems can quickly respond by
    silently updating the affected software remotely (as with some pay-TV systems)
    or by releasing a new version and prompting the users to upgrade (as with mobile
    applications). Some other systems are not so lucky and need to stick to the compromised
    cryptosystem for a while before upgrading to a secure version, as is the case
    with certain satellite phones.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个加密系统不再安全时，一些系统可以通过远程静默更新受影响的软件来迅速响应（例如某些付费电视系统），或通过发布新版本并提示用户升级（例如移动应用）。然而，其他一些系统就不那么幸运了，它们在升级到安全版本之前，必须坚持使用被攻破的加密系统，就像某些卫星电话那样。
- en: In the early 2000s, US and European telecommunication standardization institutes
    (TIA and ETSI) jointly developed two standards for satellite phone (satphone)
    communications. Satphones are like mobile phones, except that their signal goes
    through satellites rather than terrestrial stations. The advantage is that you
    can use them pretty much everywhere in the world. Their downsides are the price,
    quality, latency, and, as it turns out, security.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2000 年代初期，美国和欧洲的电信标准化机构（TIA 和 ETSI）共同开发了两项卫星电话（satphone）通信标准。卫星电话类似于移动电话，只不过它们的信号通过卫星而不是地面站传输。其优势在于几乎可以在全球任何地方使用。它们的缺点是价格、质量、延迟以及，结果证明，安全性。
- en: GMR-1 and GMR-2 are the two satphone standards adopted by most commercial vendors,
    such as Thuraya and Inmarsat. Both include stream ciphers to encrypt voice communications.
    GMR-1’s cipher is hardware oriented, with a combination of four LFSRs, similar
    to A5/2, the deliberately insecure cipher in the 2G mobile standard aimed at non-Western
    countries. GMR-2’s cipher is software oriented, with an 8-byte state and the use
    of S-boxes. Both stream ciphers are insecure, and will only protect users against
    amateurs, not against state agencies.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: GMR-1 和 GMR-2 是大多数商业厂商（如 Thuraya 和 Inmarsat）采用的两种卫星电话标准。两者都包含流密码用于加密语音通信。GMR-1
    的加密算法以硬件为导向，结合了四个线性反馈移位寄存器（LFSRs），类似于 A5/2，这是 2G 移动通信标准中故意不安全的加密算法，目的是为了服务于非西方国家。GMR-2
    的加密算法以软件为导向，使用 8 字节状态和 S 盒。两种流密码都不安全，只能保护用户免受业余攻击，而无法防御国家级的机构。
- en: This story should remind us that stream ciphers used to be easier to break than
    block ciphers and that they’re easier to sabotage. Why? Well, if you design a
    weak stream cipher on purpose, when the flaw is found, you can still blame it
    on the weakness of stream ciphers and deny any malicious intent.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事应该提醒我们，流密码曾经比块密码更容易破解，而且它们更容易被破坏。为什么？嗯，如果你故意设计一个弱的流密码，当漏洞被发现时，你仍然可以把责任归咎于流密码的弱点，并否认任何恶意意图。
- en: Further Reading
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about stream ciphers, begin with the archives of the eSTREAM competition
    at *[http://www.ecrypt.eu.org/stream/project.html](http://www.ecrypt.eu.org/stream/project.html)*,
    where you’ll find hundreds of papers on stream ciphers, including details of more
    than 30 candidates and many attacks. Some of the most interesting attacks are
    the correlation attacks, algebraic attacks, and cube attacks. See in particular
    the work of Courtois and Meier for the first two attack types and that of Dinur
    and Shamir for cube attacks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于流密码的信息，可以从*[[http://www.ecrypt.eu.org/stream/project.html](http://www.ecrypt.eu.org/stream/project.html)]*的eSTREAM竞赛档案开始，在那里你将找到关于流密码的数百篇论文，包括30多个候选算法的细节以及许多攻击方法。其中一些最有趣的攻击方法包括相关攻击、代数攻击和立方攻击。特别可以参考Courtois和Meier的工作，了解前两种攻击类型，Dinur和Shamir的工作则涉及立方攻击。
- en: For more information on RC4, see the work of Paterson and his team at *[http://www.isg.rhul.ac.uk/tls/](http://www.isg.rhul.ac.uk/tls/)*
    on the security of RC4 as used in TLS and WPA. Also see Spritz, the RC4-like cipher
    created in 2014 by Rivest, who designed RC4 in the 1980s.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 关于RC4的更多信息，可以参考Paterson及其团队的工作，*[[http://www.isg.rhul.ac.uk/tls/](http://www.isg.rhul.ac.uk/tls/)]*，这项工作研究了RC4在TLS和WPA中的安全性。同时也可以了解Spritz，这是一种类似RC4的密码，由Rivest于2014年设计，他在1980年代设计了RC4。
- en: Salsa20’s legacy deserves your attention, too. The stream cipher ChaCha is similar
    to Salsa20, but with a slightly different core permutation that was later used
    in the hash function BLAKE, as you’ll see in [Chapter 6](ch06.xhtml#ch6). These
    algorithms all leverage Salsa20’s software implementation techniques using parallelized
    instructions, as discussed at *[https://cr.yp.to/snuffle.html](https://cr.yp.to/snuffle.html)*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Salsa20的遗产也值得关注。流密码ChaCha与Salsa20相似，但核心置换稍有不同，后来这种置换被用于哈希函数BLAKE，如你将在[第6章](ch06.xhtml#ch6)中看到的那样。这些算法都利用了Salsa20的软件实现技术，使用并行化指令，如在*[[https://cr.yp.to/snuffle.html](https://cr.yp.to/snuffle.html)]*中所讨论的。
