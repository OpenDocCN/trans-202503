- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Preexisting Images
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 13: Loading and Displaying an Image'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Images are everywhere in cyberspace, and even people without explicit computer
    skills know the names of the image formats, or at least the file suffixes: GIF,
    JPEG, BMP, PNG, and so on. Each of these sequences of letters is symbolic of a
    different way of storing images in computer form, and each has specific pros and
    cons for different purposes. GIF images were developed for use on the early internet,
    and they can have transparent color as well as the ability to store animations.
    The JPEG (or JPG) format is used by almost all digital cameras, and it compresses
    pictures into relatively few bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: You should recognize the importance of images and how complex a task it is to
    read data from one of these file formats. A program to read most GIF files would
    require more than a thousand lines of code. The fact that Processing provides
    an easy-to-use facility to read, display, and write images is one of its many
    advantages over other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Processing has a type that represents an image, much as an integer is represented
    by the `int` type, and the system can read an image file into a variable with
    one call to a function. The type is `PImage` (short for *Processing Image*), and
    the function is `loadImage()`. For the image to load, it should be saved in the
    same folder as the sketch file, or in a subfolder called *data*.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s assume that an image file named *image.jpg* exists and that we want to
    read this image and display it in the sketch window. The first thing to do is
    declare a `PImage` variable, `im`, into which we’ll place the image 1. Inside
    of `setup()`, we will create a sketch window (using `size()`) and read the image.
    The following statement reads the image and assigns it to the variable `im`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now the image data is stored in some internal form in the variable `im`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Displaying the image is done from the `draw()` function, although it could
    be done in this instance from `setup()` as well. The Processing system gives us
    a function named `image()` that will draw a `PImage` into the sketch window at
    a particular (*x*, *y*) location (specifying the location of the upper-left corner
    of the image). The following call draws the image so that its upper-left corner
    corresponds to the window’s upper-left corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This program is the same as Example A, but it draws the image at location `(150,
    30)` 1. Now the image is more neatly displayed in the available space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 14: Images—Theory and Practice'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Images are used often in the visual arts, and Processing was designed for artists,
    so it’s no surprise that images are pretty easy to use in the program. There are
    some basic things you need to know, though.
  prefs: []
  type: TYPE_NORMAL
- en: One is that for an image to be used on a computer, it must be digitized; that
    is, it must be turned into numbers. If an image was not created by a computer
    in the first place, then it has to be scanned or photographed, and each location
    on the original image must be given a number indicating the color seen there.
    The result is a two-dimensional array of numbers, each of which represents the
    color at a specific location. Each small area of an image is considered to be
    uniform in color, even if it’s not, so the most prominent color is selected to
    represent the entire area. This color is stored at the corresponding (*x*, *y*)
    location in the internal representation, and it’s called a picture element, or
    pixel for short. The complete collection of these pixels is an approximation of
    the original image. Drawing an image on screen means setting the pixels on a portion
    of the computer screen to match those in the image. This is what the `image()`
    function does in Processing.
  prefs: []
  type: TYPE_NORMAL
- en: Images are most often thought of as being *N*×*M* pixels in size, where *N*
    is the number of rows and *M* is the number of columns. The total number of pixels
    in such an image is *N*×*M*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PImage` data type offers programmers a variety of ways to access the pixels
    in an image and manipulate them. Properties of an image can be accessed using
    “.” (dot) notation. For a `PImage` variable named `myImage`, for example, we have
    the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We often wish to create a graphics area that is the same size as a particular
    image, but the `size()` function in `setup()` can only use constants to set the
    window size. To get around this, we can add `surface.setResizable(true)` to `setup()`.
    It lets us resize the graphics area while the sketch is running with a call to
    `surface.setSize()`, which can use non-constants like `myImage.width`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual pixel values can be accessed using functions that return or set
    colors based on (*x, y*) coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we simply call `get()` or `set()` with no image specified, Processing assumes
    that the image being referenced is whatever is being displayed in the sketch window.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This sketch reads an image file and checks to see if it was read in successfully
    1; if not, the program is ended by calling the function named `exit()`. The `loadImage()`
    function returns a special value named `null` if the image could not be read,
    so that can be used as an indicator that the image file, for example, was not
    found. If the image is okay, the program sets the size of the sketch window to
    be the same size as that image, using the image’s `width` and `height` properties
    2. When the `setup()` function displays the image, it will fill the entire window.
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second sketch does not call `exit()` if the image file can’t be opened.
    Instead, it displays an error message in the graphics window 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 15: Manipulating Images I—Aspect Ratio'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous sketch we used the size of an image to define the size of the
    sketch window. It’s also possible to change the size of an image so that it fits
    into an existing space. The `resize()` function, part of the `PImage` data type,
    can be used to specify a new size for an image. It does not make a copy but resizes
    the `PImage` itself. Here’s an example call to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This call will cause the image stored in the `img` variable to be expanded or
    contracted to be `w` pixels wide by `h` pixels high.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the first example, we scale the image to be the size of the window, which
    is 240×480\. Note that the image has been distorted, squashed from the sides and
    made taller. Also note that all of the work is done in `setup()`, and `draw()`
    has no code.
  prefs: []
  type: TYPE_NORMAL
- en: Any image has an aspect ratio, which is the relationship between the width and
    height of the image. It is often expressed as *w*:*h*. For example, 16:9 would
    be the aspect ratio of an image that had 16 pixels in the x-direction (width)
    for every 9 pixels in the y-direction (height). The aspect ratio is sometimes
    expressed as a fraction, dividing the height into the width, so the ratio of 16:9
    would be written as 1.8 in this way. The reason that the image in Example A looks
    odd is that the aspect ratio has been changed by forcing the image to fit into
    an arbitrary rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This sketch draws an image into a window, scaling it so that the aspect ratio
    remains intact. The first thing to be done is to compute the aspect ratio of the
    original image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `float` variables here because the aspect ratio will be a fraction.
    When we place an image into a fixed space, its largest dimension (height or width)
    determines the overall size of the image within the window. We’ll adjust the largest
    side of the image to exactly fit the corresponding side of the window 2, whether
    that means making the image larger or smaller. The other dimension of the image
    is kept proportional to this new scaled value. So if the image is taller than
    it is wide, we will map the height of the image to the height of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'and the width will be in proportion to the original aspect ratio (converted
    to an integer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the image can be resized for display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Sketch 16: Manipulating Images II—Cropping'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cropping an image refers to the removal of some outer parts. You could think
    of it more generally as the selection of an arbitrary rectangular sub-image. We
    crop images to make a more appealing image or to remove extraneous material. In
    Paint or Photoshop we use the mouse, clicking first on the desired upper-left
    corner of the cropped image, then dragging the mouse to the desired new lower-right
    corner, and releasing the button. All parts of the image outside of the selected
    rectangle will be discarded. This sketch will crop an image and optionally expand
    the cropped region to fill the entire image window.
  prefs: []
  type: TYPE_NORMAL
- en: 'First the image is read in and the sketch window is resized to fit the image.
    The `draw()` function displays the image (named `img`) centered in the window
    using the following code 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the image has not been cropped, `width-img.width` will be 0, and the call
    will be `image(img, 0, 0)`. Otherwise the image will be smaller than the window,
    and (`width-img.width)/2` will be the number of pixels needed on the left to center
    the cropped image. The same is done for height, which places the image in the
    center of the window.
  prefs: []
  type: TYPE_NORMAL
- en: When the mouse button is pressed (`mousePressed()`), the cropping process starts,
    using the point where the cursor is, which is saved as `x0` and `y0`. Then a rectangle
    is drawn from this location to the current mouse coordinates, implementing a rubber
    band rectangle 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the mouse button is released, the mouse coordinates are evaluated to ensure
    that the current `mouseX` and `mouseY` represent the lower-right corner of the
    crop box; in other words, make sure that `mouseX` is bigger than it was when the
    mouse button was pressed, and the same for `mouseY`. If not, the values of `x0`
    and `y0` are swapped with the values of `mouseX` and `mouseY`. Then we create
    a cropped image with the `get()` function, using the upper-left and lower-right
    coordinates 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `get()` function returns a rectangular region of an image specified by a
    coordinate pair, a width, and a height. In the preceding call (`x0`, `y0`) are
    the upper-left coordinates, the width is the distance between the `mouseX` value
    and the upper-left *x* value, and the height is the distance between `mouseY`
    and the upper-left *y* value. In this case, `get()` is using the image displayed
    in the sketch window as the original.
  prefs: []
  type: TYPE_NORMAL
- en: The sub-image returned by the `get()` function becomes the current image to
    be displayed in `draw()` (the variable `img`) centered in the window 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new idea in this sketch is the test to see which mouse button was pressed.
    In the `mouseReleased()` function, this statement tests for the right mouse button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If that was the one released, the sub-image is rescaled to fit the window.
  prefs: []
  type: TYPE_NORMAL
- en: At 1 we resize the graphics window to be the size of the image, as we’ve done
    before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 17: Manipulating Images III—Magnifier'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some computers have a “magnifying glass” object that is controlled by the mouse
    and displays a close-up (magnified) view of a part of the screen. It allows people
    with a minor visual impairment to see things more clearly, and it allows everyone
    to get a better look at menus and other screen-based objects.
  prefs: []
  type: TYPE_NORMAL
- en: Magnification is done by increasing the size of each pixel in the original image.
    If each pixel in the original becomes four pixels (in a square) in the new image,
    then the size of the new image will be double that of the original, giving the
    appearance of a magnified version, as shown in [Figure 17-1](#figure17-1). The
    image will contain no more detail than the original; it will just be easier to
    see.
  prefs: []
  type: TYPE_NORMAL
- en: '![f17001](Images/f17001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-1: Magnifying an image'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a magnifying glass is a simple matter using the functions that
    Processing provides. First we display the target image and use the techniques
    discussed in previous sketches to select a rectangular region in the sketch window
    to be magnified. By pressing the mouse button, the user selects a square beginning
    at the mouse coordinates with a size of 50×50 1. The Processing functions `mousePressed()`
    and `mouseReleased()` are called when the button is pressed and released 3, and
    we use these functions to set a flag variable named `mag`. If `mag` is set, we
    copy the selected part of the original image into another `PImage` named `sub`
    using the `get()` function. The copied image is then resized to be 100×100 pixels
    using the `resize()` function 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Taking a 50×50 image and making it 100×100 effectively doubles its size. Now
    the resized image is drawn on the screen at the location from which it was copied,
    more or less. The new image is larger than the extracted one, so the new position
    is approximate, and some pixels from the original will be hidden behind the new,
    larger copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 18: Rotation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When rotating something, we always need to specify an axis of rotation, which
    in two dimensions is a *point* and an angle. A rotation is specified using a call
    to the function `rotate()`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: where `angle` is specified in radians. A circle contains 2π radians and also
    360 degrees, so to convert from degrees to radians means multiplying the degrees
    by 3.14159/180.0, or by using the Processing function `radians(x)`. The point
    (axis) about which the rotation will take place is the origin of the window’s
    coordinate system, (0, 0), by default. It is the upper-left corner of the window,
    and the rotation will be *clockwise* about this point.
  prefs: []
  type: TYPE_NORMAL
- en: When a rotation is specified, all things drawn from that point on will be rotated.
    Calling `rotate()` again rotates by a further angle. Turning off the rotation
    is not possible as such, but a call to `rotate (-angle)` will undo the call to
    `rotate(angle)`.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first example draws a figure illustrating rotations. A horizontal line is
    drawn and labeled 1, followed by a line that is rotated by 10 degrees 2 and then
    by one rotated by 20 degrees 3. To avoid having the text rotated, the rotation
    is “undone” (rotated by the negative angle) before drawing the text labels.
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A line is drawn from the origin. It has a small ball on the end. This line is
    rotated from 0 to 90 degrees in small steps, with each step displayed within `draw()`
    because the line and ball are drawn there. When the line is rotating clockwise,
    the angle is incremented by 0.01 radians each time `draw()` is called 1. When
    the line becomes vertical and further rotation would take it out of the field
    of view, the change in angle for each frame (variable `d`) is changed to `-d`
    2. Now the line rotates back to its original position, and at that point (0 degrees)
    the value of `d` is changed to become positive again. The object, which looks
    like a pendulum, bounces between 90 degrees and 0 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: The rotation angle is reset to 0 each time `draw()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 19: Rotating About Any Point—Translation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to rotate objects is essential, but only being able to rotate about
    the upper-left corner of the screen is inconvenient. Rotation about an object’s
    center is what we usually want, but it requires knowledge of the object. Objects
    can be complex things in graphics; an object might be just a circle or square,
    or it might be a building or a car. Processing cannot be expected to know what
    an object is or where the center might be. However, Processing makes it possible
    to move the center of rotation to any coordinate we choose, using the `translate()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '`translate()` takes an x- and a y-coordinate and changes the origin to that
    location for all future drawing. The following example moves the origin to the
    location (100, 200) in the window, which now becomes the coordinate (0, 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The word translate means, in mathematical terms, to *reposition*, so a translation
    involves changing the position of an object. If we translate the origin to (50,
    50) and then draw a circle at (0, 0), the circle will appear at window coordinates
    (50, 50) on the screen. Further circles will be drawn relative to window coordinates
    (50, 50).
  prefs: []
  type: TYPE_NORMAL
- en: Because rotations always use (0, 0) as the axis, this means we can set the axis
    to any coordinates we like and rotate an object about any point.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a basic example, we’ll draw a circle at (0, 0) using the `ellipse()` function
    1 and then call `translate()` to change the origin to (50, 50). A second call
    to `ellipse()` that is exactly the same as the first draws the circle at screen
    coordinates (50, 50). A further `ellipse()` call drawing a circle at (30, 40)
    draws the circle at screen coordinates (80, 90); that is, (30, 40) relative to
    the new origin at (50, 50).
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this sketch we rotate a line about its center. The process is to `translate()`
    to the center of the line, in this case (150, 100) 1; rotate by the current angle
    2; and then draw the line. The coordinates of the line must reflect the fact that
    the origin is the line’s center, not one end. Because the center of the line is
    at (150, 100), the line should be drawn from −50 to +50 in the x-direction so
    as to be 100 pixels long. The translated coordinates of the start would be (150
    − 50, 200 − 100 − 0), or (100, 100). The coordinates of the endpoint will simply
    be 100 pixels further in x, or (200, 100). A small circle is drawn at the midpoint
    (origin) so that it can be seen.
  prefs: []
  type: TYPE_NORMAL
- en: The rotation angle increases each time `draw()` is called 3. Since the line
    is drawn each time `draw()` is called, the image shows a slowly rotating line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 20: Rotating an Image'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rotation and translation can be applied to complex objects as well as simple
    lines and circles. In particular, we can rotate images about arbitrary points
    by any angle.
  prefs: []
  type: TYPE_NORMAL
- en: There can be a problem in determining how to place the image so that it lies
    entirely on the screen. Images are rectangular, and rotating them increases their
    width or height. If we don’t place the image properly within the window, one or
    more corners could rotate out of the window’s boundaries, as shown in [Figure
    20-1](#figure20-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![g20001a](Images/g20001a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20-1: Rotating an image out of the window’s boundaries'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top pair of images shows the result of rotating an image that was displayed
    in the upper-left corner of the window. Rotating by 45 degrees moves half of the
    image off of the screen. The bottom pair of images shows what can happen when
    an image is rotated about its center without a large enough window: the corners
    of the image are cut off.'
  prefs: []
  type: TYPE_NORMAL
- en: This sketch displays a continuously rotating image. The image is read in, and
    the window size is set to *double* the image size in each dimension 1. The `draw()`
    function translates the origin to the center of the image and then rotates the
    image by `angle` and displays it, thus rotating the image about its own center
    2. The value of `angle` is then increased by a tiny amount for the next time `draw()`
    is called 3. The image appears in the center of the window and appears to rotate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 21: Getting the Value of a Pixel'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While developing Sketch 14, we discussed how to get a pixel value from a `PImage`
    using the `get()` function. We can get the color value of the pixel at (`x`, `y`)
    in a `PImage` named `im` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The picture currently being displayed in the sketch window has a privileged
    position because it can be accessed without using a variable. A pixel value on
    the screen can be obtained by simply calling `get()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can therefore get the color of the pixel at the current mouse position with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This sketch loads an image and allows the user to click any pixel to see its
    color, which will be displayed on the right side of the screen as a colored bar
    and as RGB values in text form. First the sketch loads an image and sizes the
    window to fit it, with an extra region on the right side. In `draw()` it displays
    the image with a background color of (200, 200, 200) 1; when the mouse button
    is pressed, it assigns the pixel value (color) at the `mouseX`, `mouseY` coordinates
    to the color variable `c` 3; then it displays the color on the right side of the
    image and the RGB values as text at the upper-right corner of the screen 2. Whenever
    the mouse button is clicked, the color value displayed will change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 22: Setting and Changing the Values of Pixels'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pixel values in an image, including the drawing area, can be changed using the
    `set()` function. We specify a pixel location using coordinates and identify the
    color to draw at that point. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This sets the pixel in the graphics area at location (`i`,`j`) to yellow, or
    RGB (255, 255, 0). If the coordinates lie outside of the window, the pixel will
    be drawn but will not be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set a color for *all* pixels in the window using the `background()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This call fills the sketch window with orange.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting all pixels in the window without using the `background()` function
    requires a loop*—*two nested loops, in fact. The first loop examines all pixels
    in the horizontal direction; that is, all pixels in a specified row. The second
    loop looks at all possible values of `i`, which is to say all rows. The first
    loop is nested within the second so that all pixels in all rows are modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This sets all pixels in the sketch window to orange.
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pixel values of an image can be modified before the image is displayed in
    the sketch window. Not only can the color be replaced, but a pixel value can be
    changed more subtly to a variation of what is already there. This example first
    loads and displays an image. When the program detects a button press with `mousePressed()`,
    it sets the flag `grey` 2, which indicates that the image on the screen is to
    be modified, pixel by pixel, in a loop like that of the previous example. In this
    case, we replace the RGB value of each pixel on the screen with its brightness
    value 1, and the result is a grey image showing no color. When the mouse button
    is released (`mouseReleased()`), the program clears the flag (sets it to `false`),
    and the image is displayed in color again 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 23: Changing the Values of Pixels—Thresholding'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The act of thresholding an image changes the color value of each pixel to either
    black or white, depending on the original color or brightness. Thresholding creates
    a binary image: each pixel can be thought of as being either *on* or *off*. Why
    do this? Some images have content that is fundamentally binary: a scan of a page
    of text has black characters on a white background. In other cases, it is a way
    to simplify an image so that we can perform other operations, such as detecting
    edges or faces. Thresholding an image of red blood cells might facilitate counting
    them, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: Thresholding an image is a two-step process. First we determine a threshold
    value—one that retains the required features of the image. We usually do this
    by examining all of the pixels in the image and computing a value using some statistical
    formula. A threshold value is a number between 0 and 255; all pixel brightness
    values smaller than the threshold will be set to black (0), and those greater
    will be set to white (255). The second step is looking at all of the pixels and
    actually applying the threshold.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address the second step first, applying the threshold is a simple matter
    of looking at each pixel and deciding whether it is less than or greater than
    `threshold`. Weassign the pixel value to the variable `g`, extract the brightness,
    and then test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The value `black` is the color (0, 0, 0), and `white` is (255, 255, 255).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sketch, we will determine the threshold manually, using the mouse position.
    This is the horizontal position of the mouse as a percentage of the total window
    width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If we multiply this fraction by 255, we get a value between 0 and 255 1 that
    is in proportion to how far to the right the mouse is. We’ll use this value as
    a threshold. When the mouse is on the left side of the window, the threshold will
    be small and most of the image will be white; when the mouse is on the right,
    the threshold will be large and the image will be largely black.
  prefs: []
  type: TYPE_NORMAL
- en: If the `draw()` function calculates and applies the threshold, it will be dynamic,
    and we can watch the image change as the mouse moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 24: User-Defined Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up to this point, we have been using drawing functions provided by the Processing
    system: `ellipse()`, `line()`, `mousePressed()`, and so on. We have not analyzed
    the concept of functions much, partly because it appears fairly obvious what is
    going on. However, if we wish to create our own functions, there are some things
    we need to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: A function is a name given to a collection of code. When the name of the function
    is used in a statement, that function is said to be invoked or called, and the
    code within the function is executed. This means that functions can be executed
    from many different places without repeating the code itself, merely by calling
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can return a value: we’ve used such functions before. For example,
    `color()` and `get()` return colors and pixel values. Functions that do not return
    a value are said to return `void`, and that’s the reason for the word `void` in
    front of `setup()` and `draw()`. They are functions that do not return a value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new function, we must follow the same syntax as `setup()` and `draw()`:
    we write the return type, the function name, parentheses, and then the function
    body in curly brackets. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, `newFunctionA()` does not return a value, and it is called or invoked
    using the function call `newFunctionA();`. `newFunctionB()` returns an integer
    value and must have a `return` statement indicating the value to be returned.
    This type of function is called as if it were part of an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There can be more than one `return` statement in a function, but only one will
    be executed, because once a function returns, no other code in the function can
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions may have parameters or arguments, values that are given to the function
    when it is called. When calling the function `color()`, we list three values in
    the parentheses: red, green, and blue. These variables are specifically passed
    for use by the function, and their values are available to do calculations within
    the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a function that calculates the distance between two points, (x0,
    y0) and (x1, y1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments to the function are named `x0`, `y0`, `x1`, and `y1`, and they
    have types, in this case integer (`int`). The arguments are used to calculate
    the distance between the points (x0, y0) and (x1, y1) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![C02eq001](Images/C02eq001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This sketch uses two mouse clicks to determine the points: (x0, y0) 2 and (x1,
    y1) 3. It draws a marker at each point and displays the distance between them
    as a text message at the bottom of the window 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 25: Elements of Programming Style'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Style in a program refers to aspects of the code that don’t usually impact the
    execution but that do have an effect on how other people read, modify, or repair
    it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there is a way to place human-readable text within a program for
    other programmers to read. Any text that follows a pair of slashes is called a
    comment, and it is ignored by Processing, as is any text in between the symbols
    `/*` and `*/`, which delineate comments that can span many lines. Programs should
    have relevant comments embedded within the code to explain what is going on to
    any human beings looking at it. Comments should be clear, offer an explanation,
    and never simply repeat the code itself. The nature of the comments in a program
    is one aspect of what we call programming style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect of style is the use of indentation to convey structure. There
    is no single correct way to indent, but the standard shown in the sketches in
    this book has certain consistent features. For example, the “{” and “}” characters
    used to enclose blocks of code always line up with each other vertically so that
    the blocks are easy to identify. The only exception is when they are on the same
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In other books, you might see another style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The location of brackets doesn’t matter to the programming language’s compiler,
    but a programmer should be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Variables should have meaningful names. The variables `x0` and `y0` above represent
    x- and y-coordinates, so the names make sense. A variable named `pixelCount` should
    contain a count of pixels. It is pretty easy to give variables good names, and
    doing so does not impact how fast the code is or how much memory it requires in
    order to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Numeric constants should be named like variables so that the purpose of the
    constant can be inferred from the name. A perfect example is `PI` instead of 3.1415\.
    A program should contain very few if any numerical constants, and names should
    be used instead. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The number 0.01745 is meaningless to most people. Now consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is better. Two times PI/360 is the conversion between radians and degrees.
    Best would be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: where `degrees_to_radians` equals `0.01745`. Now anyone reading the code can
    easily see what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this sketch does the same thing as the previous sketch, but it shows
    better style. Note, though, that it takes more space on the screen—this is typical,
    and it’s why these rules are not followed all of the time, even in this book (where
    it’s important for the text to fit on a single page).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 26: Duplicating Images—More Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this sketch is to give you some ideas about how to organize code
    into functions properly. This program will read an image, make a copy, and increase
    the brightness of the copy. The brighter version will be displayed when a mouse
    button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function is named `brighten()`. It is passed an image (named `img`)
    and an integer value (named `val`) as parameters. Its purpose is to increase the
    brightness value in an image by a specified amount. It does this by extracting
    the HSB value from each pixel in turn in a nested loop 2, adding the amount `val`
    to the brightness portion, and saving the pixel back in the image. This is the
    essential code 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We will use a new feature in `draw()`. Processing provides us with a variable
    named `mousePressed` 1 that is `true` if a mouse button is depressed and `false`
    otherwise, and this can be used in place of the `mousePressed()` callback function
    in very simple cases. In this instance, we display the brightness-enhanced image
    when the mouse button is pressed, and the original otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function in this sketch makes a copy of the original image. We define
    the duplicate function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the definition of this function, the function takes an image as
    an argument and returns an image. In fact, it returns a new image that is a copy
    of the one passed in. The Processing-supplied function that creates a new image
    is named `createImage()` 4, and it has this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The width and height should be self-explanatory; the constant `RGB` specifies
    the form of the image, which in this case is RGB color. The image returned by
    `CreateImage` is uninitialized, having pixels with unknown values, so after creating
    an image the same size as the one passed in, our `duplicate()` function sets each
    pixel in the new image to the value of the corresponding pixel in the original,
    with a standard nested loop.
  prefs: []
  type: TYPE_NORMAL
