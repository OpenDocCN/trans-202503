- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">WRITING</samp>
    <samp class="SANS_Dogma_OT_Bold_B_11">A</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SONG</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You’ve now learned enough about the basics of Tone.js and sound synthesis to
    write a simple song. Our song is going to be made up of a few instruments: the
    drums we developed in the previous chapter, the trumpet sampler, two different
    synth bass parts, and some chords played on another synth.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Getting Organized</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our song will reuse a lot of the code from the previous chapter, but we’ll
    reorganize it to make it easier to follow how the song is built. The *index.html*
    file will be exactly the same as in [Chapter 12](chapter12.xhtml), but we’ll start
    from scratch with a new *script.js* file, which we’ll organize into four logical
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instruments**    For instantiating and setting up the instruments'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequencing**    For creating the looping sequences of notes to be played'
  prefs: []
  type: TYPE_NORMAL
- en: '**Song**    For scheduling the start and end of each sequence'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event Handling**    The code that handles the click event that starts playing
    the song'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll set off each of these four sections with a multiline comment to make the
    *script.js* file easier to navigate. [Listing 13-1](#Lis13-1) shows what these
    comments look like. You can add them to the file now, in this order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: The comments
    delineating the main sections of</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapter, as we build up the song, I’ll tell you to add each new
    piece of code to the end of a particular section. These comments will enable you
    to quickly find exactly where the new code should go.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Event Handling</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by writing the Event Handling section of *script.js*. This code
    is almost identical to the code we wrote at the beginning of the previous chapter:
    it creates a click event listener that toggles the style of the Play button and
    “Playing” paragraph when the user clicks the button, and makes the Tone.js calls
    necessary to start playing the song. Enter the contents of [Listing 13-2](#Lis13-2)
    in the Event Handling section of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: The event handling
    code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: One important difference in this code compared to [Listing 12-2](chapter12.xhtml#Lis12-2)
    is that we use Tone.Transport.position to set the starting position of the transport
    before we call Tone.Transport.start ❶. Here we’ve set the starting position to
    "0:0:0", which is the default, so this call isn’t strictly necessary. However,
    including this line of code makes it easy to modify the starting position if you
    don’t want to have to listen to the whole song every time you add a new element
    to it. For example, if you wanted to skip the first 20 bars, you could change
    the value of Tone.Transport.position to "20:0:0".
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in the previous chapter, all the code to create the instruments and sequences
    will live outside of the event handler. That code can all be executed before the
    user presses Play. Only the Tone.start call has to be inside the handler for the
    song to work correctly. We could even move the Tone.Transport lines outside of
    the handler if we wanted, but it feels more natural to have those come after Tone.start.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Making the Drumbeat</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s create the drumbeat to underlay the song. We’ll use the same hi-hat,
    snare, and kick sounds we created in the last chapter. First we’ll declare those
    instruments, as shown in [Listing 13-3](#Lis13-3). Add this code to the Instruments
    section of *script.js*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-3: Declaring the
    drums</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is identical to the code we wrote in the previous chapter, but to
    keep it a little more organized I’ve moved all of the drum setup code, including
    the reverb effect, into a single function called mkDrums (for “make drums”) ❶.
    This function returns an object with the three drums ❷. We’re using a new form
    of syntax for creating this object called *object literal shorthand syntax*. With
    this shorthand syntax, instead of typing out {hiHat: hiHat, snare: snare, kick:
    kick}, we just type {hiHat, snare, kick}. This works only if the property names
    are the same as the variable names.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve declared the drums, we’ll create the actual drumbeat pattern.
    We’ll use the same one-bar pattern that we developed in the previous chapter,
    with hi-hats on every eighth note and kick and snare sounds alternating every
    quarter note. Add [Listing 13-4](#Lis13-4) to the Sequencing section of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-4: The drumbeat
    sequences</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Again, this is identical to code we wrote in [Chapter 12](chapter12.xhtml).
    We start with a helper function, mkSequence ❶, that takes in a pattern of x’s
    and dots and turns it into note information that Tone.Sequence can use. Then we
    store the patterns we want in a drumPattern object ❷ and generate the sequences
    for each instrument with Tone.Sequence.
  prefs: []
  type: TYPE_NORMAL
- en: All that’s left to do to create the drumbeat is to schedule the sequences to
    play on loop for most of the duration of the song, as shown in [Listing 13-5](#Lis13-5).
    Add this code to the Song section of the *script.js* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-5: Scheduling the
    drumbeat sequences</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here we tell the drums to start at the beginning of the song and keep playing
    for 44 bars. Load the page and click **Play,** and you should hear the same drums
    as before, but for much longer. When you get tired of listening, reload the page
    to stop the drums playing.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding the Bass Lines</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next we’re going to add a couple of bass synths and have them play two separate
    bass lines. First we’ll create the synths, by adding the code in [Listing 13-6](#Lis13-6)
    to the end of the Instruments section (just before the Sequencing section).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-6: Creating the
    bass instruments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here we declare two bass instruments called lowBass and highBass. Both use a
    synth we haven’t seen yet, called an FMSynth. *FM* is short for *frequency modulation*,
    and *FM synthesis* involves using one oscillator to modulate, or modify, the frequency
    of another oscillator. This kind of synthesis yields a richer sound than a plain
    oscillator, and it makes a good bass synth. There are a lot of parameters that
    can be modified in Tone.FMSynth (for example, the amount of modulation applied,
    the relationship between the frequencies of the two oscillators, the waveforms
    of the two oscillators, and so on), but we’ll mostly stick to the default values.
    All we’ll do is set the oscillator type ("triangle" for "lowBass" ❶ and "square"
    for highBass ❷), as well as the envelope and volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'For generating the bass sequences, we’re going to use a slightly different
    technique from our current mkSequence helper function. That helper is great for
    things like drums, where you need only a single character to determine whether
    a note is played or not, but it doesn’t work for a bass line where we want to
    provide note names, which have at least two characters (like C3 or F#4). One notation
    we might choose for writing out a sequence could be something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The vertical pipe characters are used as divisions, and between each pair of
    pipes is either a note we want to play or a blank space, which represents a silence.
    (The sequence written out here is the start of the bass line for Ben E. King’s
    “Stand by Me.”)
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-7](#Lis13-7) gives the definition of mkPipeSequence, which we’ll
    use for sequencing our bass lines. It takes a string like the one for “Stand by
    Me” and converts it into an array of note names and nulls. Insert this function
    into the Sequencing section of *script.js*, just after the definition of mkSequence.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-7: The mkPipeSequence
    function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This function uses split("|") to split the string by the pipe character. Using
    the “Stand by Me” example, this would give the array ["C3", " ", " ", "C3", "
    ", " ", "G2", "B2"]. We then map over each of these values. The trim method ❶
    removes any whitespace from the start or end of a string, so " ".trim() results
    in " ", an empty string. We replace any empty strings with nulls in the returned
    array and pass the note names through unchanged, resulting in a return value of
    ["C3", null, null, "C3", null, null, "G2", "B2"].
  prefs: []
  type: TYPE_NORMAL
- en: Next we want to create the actual sequences for the two bass lines (we won’t
    be borrowing from “Stand by Me” here). Add the code in [Listing 13-8](#Lis13-8)
    to the end of the Sequencing section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-8: The bass sequences</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two bass parts here: the low one just plays three eighth notes per
    bar, while the high one plays eighth notes continuously.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to schedule these sequences against the transport, as shown
    in [Listing 13-9](#Lis13-9). This code should be added to the end of the Song
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-9: Scheduling the
    bass sequences</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The low sequence starts at the beginning, and the high sequence starts after
    four bars. Both continue looping until partway through the 48th bar. This way,
    the bass parts will continue for a few bars after the drums stop.
  prefs: []
  type: TYPE_NORMAL
- en: If you now refresh the page and hit Play, you’ll hear the beginnings of a song!
    Not only do we have drums and bass, but we have some very basic structure, with
    the second bass line coming in after four bars and the drums ending before the
    bass. That bass solo at the end is by far the most dramatic part of the song as
    it currently stands. To hear just that part, you can modify the value of Tone.Transport.Position
    in the Event Handling section of the code. If you set it to "40:0:0" and reload,
    you’ll skip to the last eight bars of the song.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding Chords</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next we’ll fill out the song with some chords. This song will have two separate
    chord sequences, which we’ll schedule for different times in the song to give
    it some more structure and variety.
  prefs: []
  type: TYPE_NORMAL
- en: First we need to create the instrument that will play the chords. The code for
    this is in [Listing 13-10](#Lis13-10); insert this at the end of the Instruments
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-10: The chord synth</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We need a PolySynth because the instrument will be playing more than one note
    at a time (that’s what a chord is). The PolySynth is based on a regular Synth,
    using the default amplitude envelope and a triangle wave oscillator.
  prefs: []
  type: TYPE_NORMAL
- en: Next we’ll create the sequencing code for the chords. Rather than writing a
    chord out manually each time we want to play it in a sequence, we’ll create some
    named chords, and then create sequences using those chord names. Insert the code
    in [Listing 13-11](#Lis13-11) at the end of the Sequencing section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-11: Sequencing the
    chords</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is create an object called chords with the four chords
    that we’ll be sequencing ❶. We could call them anything, but for simplicity I’m
    using the numbers 1, 2, 3, and 4 to refer to the chords (though note that because
    these are object keys, the numbers are interpreted as strings). Each chord number
    corresponds to an array of note names, which is the format our PolySynth requires.
    The two chord sequences will just be various orderings of these four chords.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes a helper function for playing the chords ❷. This playChord function
    takes the time to play the chord and the name of the chord as a string (one of
    the numbers 1 through 4). Then it looks in the chords object and retrieves the
    array of notes keyed by the given chord name ❸. The function ends by calling triggerAttackRelease
    on the chordSynth, passing the array of note names. Because it’s a PolySynth,
    our chordSynth instrument is able to play all the notes in the chord at once.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we make the two sequences, called chordSequence1 ❹ and chordSequence2
    ❺. The callback for both of these sequences is our playChord function. We’re also
    using the same mkSequence helper we used for sequencing the drums earlier, but
    in this case the values in the string are either dots (silence) or chord names.
    Unlike with our bass lines, mkSequence works here because each chord name is a
    single character, and we have our playChord function to reinterpret the chord
    names as pitches. As with the drums, we’re passing "8n" as the last argument to
    Tone.Sequence, meaning that each dot or chord name is an eighth note. The first
    sequence is 32 eighth notes long, or 4 bars. The second sequence is 16 eighth
    notes long, or 2 bars.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll actually schedule the sequences against the transport. Add the code
    in [Listing 13-12](#Lis13-12) to the end of the Song section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-12: Scheduling the
    chord sequences</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first sequence starts playing after 8 bars and repeats through the end of
    bar 24, which is 16 bars, or four complete loops of the first sequence. Then the
    second sequence takes over and runs through bar 32; this is 8 bars, or four complete
    loops of the second sequence. Finally, the first sequence returns, playing through
    bar 40; this is also 8 bars, or two complete loops of the first sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Try refreshing your browser and listening to the song again. Make sure to set
    Tone.Transport.position to "0:0:0" in the event handler to play from the beginning.
    If you don’t want to wait eight bars for the chords to come in, set it to "8:0:0"
    to start playing where the chords start.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Playing a Tune</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have drums, bass, and chords, the only thing our song is missing
    is a tune. We’re going to use the trumpet sampler we created in the last chapter,
    and we’ll sequence the notes using Tone.Part, which lets us easily schedule the
    timing of each note in the tune separately.
  prefs: []
  type: TYPE_NORMAL
- en: First we’ll create the sampler, like we did in [Chapter 12](chapter12.xhtml).
    Add the code in [Listing 13-13](#Lis13-13) to the end of the Instruments section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-13: Declaring the
    trumpet sampler</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here we’re creating a Tone.Sampler instrument with the same three samples as
    in the previous chapter. Note, however, that we’re no longer using the sampler’s
    onload property to tell it what to do once the samples have been downloaded. This
    is a bit of a cheat, but I know that the trumpets aren’t going to play at the
    beginning of the song, and I’m banking on the fact that by the time they come
    in, the samples will have downloaded. The proper thing to do would be to hide
    the Play button until the samples have finished downloading, but that would add
    extra complexity to this project.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-14](#Lis13-14) shows the code for sequencing the notes of the tune.
    Add this code to the end of the Sequencing section.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-14: Sequencing the
    tune</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, the Tone.Part constructor takes two arguments: a callback to
    play for each time/note pair, and a list of time/note pairs. Here, the callback
    plays a long note ("1n", or a whole bar) on the trumpet sampler for every time/note
    pair. The first note is played at "0:0:0" and the second is played two beats later,
    at "0:2:0". Because the notes are about four beats long, they will overlap—I did
    this intentionally to add some interest to the tune.'
  prefs: []
  type: TYPE_NORMAL
- en: The tune won’t play yet because we haven’t said *when* to play it. Even though
    each note has a time, these times are relative to when the part is scheduled to
    begin. To schedule the part, we just have to add some code to the end of the Song
    section, as shown in [Listing 13-15](#Lis13-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-15: Scheduling the
    trumpet part</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the sequences we scheduled so far, the part doesn’t loop, so it doesn’t
    need a stop time. We’re telling Tone.js to start the trumpet part after 16 bars,
    which means that all the times given in the part are relative to "16:0:0". We
    can add the two times together to get the actual time when each note is scheduled
    (for example, "4:2:0" + "16:0:0" is "20:2:0").
  prefs: []
  type: TYPE_NORMAL
- en: Now you can listen to the complete song! Don’t forget to reset Tone .Transport.position
    to "0:0:0" before you refresh the page.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Complete Code</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve been adding code all over the file, so just in case you got something
    mixed up, or if you just want to see how it should all look, [Listing 13-16](#Lis13-16)
    gives the entire contents of *script.js*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-16: The complete
    code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you coded a song in JavaScript! Now that you’re used to working
    with Tone.js, you can use it to make your own song. Another fun thing to try is
    algorithmic music, where instead of writing out a fixed song, you write code that
    semirandomly produces new music each time it runs. One simple way to try this
    out is to come up with a list of nice-sounding chords, and then randomly choose
    which one to play on any given beat (you could use Tone.Loop to accomplish this,
    as we did in [Listing 12-12](chapter12.xhtml#Lis12-12) in the previous chapter).
  prefs: []
  type: TYPE_NORMAL
