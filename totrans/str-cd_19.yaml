- en: '15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: USING FIREFLY
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Chapter 14](ch14.xhtml#ch14) introduced us to Firefly. Now let’s see what
    we can make it do. First, we’ll walk through the environment for building and
    testing Firefly programs. Then, we’ll look at five examples that put Firefly to
    the test. For the first test, we’ll make the firefly count (“Fly Time”). After
    that, we’ll simulate a 1960s sci-fi computer display (“Space Trek”). Then, we’ll
    go high-brow and play some classical music (“Beethoven in Lights”). We’ll even
    experiment with animation effects (“Dance Dance”) and end with something useful,
    a tea timer (“Tea Time”). We’ll conclude the chapter with a discussion of Firefly
    as a programming language.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Process**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two versions of the Firefly interpreter: one for the console and
    one for the micro:bit. [Chapter 14](ch14.xhtml#ch14) presented the micro:bit version.
    In this section, we’ll walk through developing Firefly programs, testing with
    the console interpreter, debugging via execution tracing, and deploying code on
    the micro:bit. The last step is optional for all the examples in the chapter,
    should you not have a micro:bit handy. However, you won’t hear the firefly sing.'
  prefs: []
  type: TYPE_NORMAL
- en: The process involves the sequence of steps listed next. Steps 4, 5, and 6 are
    specific to the micro:bit, so console-only users should stop after Step 3.
  prefs: []
  type: TYPE_NORMAL
- en: Write Firefly code, including comments and whitespace, in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code with the console interpreter, *firefly.py*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally debug the code with execution tracing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package the debugged program using *fly_dump.py*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a micro:bit runtime to bundle the compacted Firefly code with the micro:bit
    interpreter, *firefly_micro.py*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transfer the bundled runtime to the micro:bit using the *[microbit.org](http://microbit.org)*
    Python editor, [https://python.microbit.org/v/2/](https://python.microbit.org/v/2/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you plan on using a micro:bit, we’ll be using the online Python editor at
    *[https://python.microbit.org/v/2](https://python.microbit.org/v/2)*. It works
    best with Windows. I used the Microsoft Edge browser and had no trouble at all.
  prefs: []
  type: TYPE_NORMAL
- en: To work with the micro:bit on Linux, I had some success with the Mu editor when
    using a version 1 micro:bit and the 1.0.2 version of Mu. With later versions of
    the editor and a version 2 micro:bit, I was only able to get stable functionality
    from Ubuntu 18.04 when running the editor directly from the GitHub repo at *[https://github.com/mu-editor/mu/](https://github.com/mu-editor/mu/)*.
    Your mileage may vary.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-1](ch15.xhtml#ch015fig1) shows the Python editor running on Windows
    in the Microsoft Edge browser.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/15fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: The Python editor for micro:bit*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the book’s GitHub site contains short videos showing the code running
    on a micro:bit. Please take a look, especially if you do not intend to use the
    micro:bit yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing Firefly Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our first example is the Firefly equivalent of “Hello, world!” The program draws
    the letters `HI` on the screen. The source code is in *hi.fly* in the *firefly/
    console/examples* directory (see [Listing 15-1](ch15.xhtml#ch015list1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-1: “Hello, world!” in Firefly*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of *hi.fly* ensures move mode (no trail) and moves the firefly
    from its initial (2,2) position to the upper-left corner, (0,0). The mode is then
    set to intensity 5.
  prefs: []
  type: TYPE_NORMAL
- en: The next line moves south three spaces to draw the left side of the H. At this
    point, the firefly is at position (3,0), so switching to move mode and going north
    twice puts the firefly at (1,0). Setting the mode to 5 and moving east three times
    draws the crossbar of the H. The next two lines finish the H and `MEEN` moves
    to (2,4). From (2,4), setting the mode to 5 and moving north three times draws
    the I, ending with the firefly at position (4,4). The `L` instruction loops forever
    to preserve the “HI” display on the micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the Console Interpreter***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To execute [Listing 15-1](ch15.xhtml#ch015list1), we need the console interpreter.
    Run the code with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: to produce
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The 5×5 display is indented four spaces and one space is printed between each
    digit. By default, *firefly.py* shows 0 intensity as a space. Adding the `-z`
    command line option shows 0 intensity as 0s
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: where we now see the full 5×5 grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, step through *hi.fly* by adding the `-t` (trace) command line option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In trace mode, an instruction is executed and the display is updated; then,
    before execution of the next instruction, the interpreter shows a status line
    and waits for the user to press ENTER or Q to quit the program. For example, running
    *hi.fly* in trace mode presents us with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'which tells us that the last instruction executed was `M` (set move mode).
    This is the `INST` part of the status line. The rest of the status line is described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `I=(2,2)(12)` | The firefly is at (2,2) (index 12) |'
  prefs: []
  type: TYPE_TB
- en: '| `SHOW=A` | Grid A is currently visible |'
  prefs: []
  type: TYPE_TB
- en: '| `DRAW=A` | Grid A is currently drawn to |'
  prefs: []
  type: TYPE_TB
- en: '| `M=M` | Move mode is “M” |'
  prefs: []
  type: TYPE_TB
- en: The index is into the `bytearray` of the currently active memory grid.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing ENTER moves us to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: which informs us that the firefly is now at position (1, 2) (index 7) because
    a “move north” instruction was executed.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing to press ENTER traces through the entire program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We continue to the `L` instruction, which throws us into an infinite loop. Use
    CTRL-C to exit the loop.
  prefs: []
  type: TYPE_NORMAL
- en: We have a working program. Let’s now bundle it to run on the micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: '***Packing a Bundle***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can’t use *hi.fly* as-is with the micro:bit version of Firefly because we
    first need to strip the comments and whitespace. We could do this manually, but
    why bother when we already have a utility to do it for us? In the same `console`
    directory as *firefly.py* is *fly_dump.py*. Let’s run it to get a single-string
    version of *hi.fly*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the console version of the code with comments and whitespace.
    The second is the output, which in this case is sent to the *examples* directory
    of the micro:bit version in *micro*. The output generated is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This version of the code still runs in the console interpreter. Give it a try
    and see for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the micro:bit bundle, we’ll need to complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy *firefly_micro.py* to *hi.py*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit *hi.py* and update *PRG* to be the text in *micro/examples/hi.fly*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Python editor and load *hi.py*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the micro:bit via USB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Program the micro:bit from the online Python editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 1 and 2 mean that bundles are copies of the micro:bit version of the interpreter
    edited to contain the compacted Firefly code. The default *firefly_micro.py* file
    begins with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: which becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This embeds the code in *hi.py*. The remainder of *hi.py* is the same as the
    interpreter code of [Chapter 15](ch15.xhtml#ch15).
  prefs: []
  type: TYPE_NORMAL
- en: To program the micro:bit, first run the editor in Microsoft Edge by opening
    *[https://python.microbit.org/v/2/](https://python.microbit.org/v/2/)*. Then,
    connect the micro:bit’s Micro-USB port to the computer’s USB port. The micro:bit
    will likely automount. If so, just close any Explorer window that opens.
  prefs: []
  type: TYPE_NORMAL
- en: Next, connect to the micro:bit by clicking **Connect** and selecting the micro:bit
    from the resulting dialog. The micro:bit is present and working if you see a string
    similar to “‘BBC micro:bit CMSIS-DAP’ – Paired.” Select the micro:bit and click
    **Connect**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, open *hi.py* by clicking **Load/Save** followed by **Download** to program
    the micro:bit. Programming takes a few seconds. When complete, the program starts
    immediately producing [Figure 15-2](ch15.xhtml#ch015fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/15fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: “Hello, world!” micro:bit style*'
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice something when the program ran? Rerun it by pressing the reset
    button beneath the micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a version 1 micro:bit, you’ll see the message draw on the screen
    from left to right. The *hi.fly* program moves the firefly on grid A while showing
    grid A, so we see each instruction’s effect. Later in the chapter, we’ll adjust
    *hi.fly* to use double buffering (see “Space Trek” below).
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of this chapter walks through each example’s code, running it
    on the console when applicable and then running the code on the micro:bit. In
    each case, program the micro:bit as we did here: use *fly_dump.py* to strip comments
    and whitespace, paste the compacted Firefly program text into a suitably renamed
    copy of *firefly_micro.py*, and load the copy onto the micro:bit via the Python
    editor. Don’t forget to take a look at the micro:bit videos on the book’s GitHub
    site as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put our firefly to work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fly Time**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `P` instruction pauses the program for 0.1 seconds. Therefore, `PPPPPPPPPP`
    pauses the program for one second. Let’s use this as the basis for a counter/
    timer. Our goal is a Firefly program that counts seconds, up to 1,000, before
    rolling over and starting again. Firefly lacks any looping mechanism other than
    starting a program from the beginning after it ends; therefore, we need to design
    our program so that looping from the beginning starts the counter again from 0.
  prefs: []
  type: TYPE_NORMAL
- en: If 10 `P` instructions give a one-second pause, then `PPPPPPPPPPT` pauses for
    one second before “moving” the firefly by remaining in place. If the mode is `I`
    (increment), the net effect is a one-second pause before incrementing the current
    firefly position. Repeat the one-second pause 10 times with `T` after each pause,
    and we have a 10-second timer.
  prefs: []
  type: TYPE_NORMAL
- en: To count, we increment the ones digit until it rolls over back to 0 and then
    increment the tens digit by 1\. We can use this approach with the one-second timer
    to build a two-digit timer by moving from the current firefly position, the ones
    position, over to the left and incrementing, and then moving back and repeating
    for another 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: This thought suggests a set of repeated instructions. The program begins with
    the firefly at position (2,2). Let’s use position (0,4) for the ones and position
    (0,3) for the tens. Consider the sequence of instructions shown in [Listing 15-2](ch15.xhtml#ch015list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-2: A 10-second timer*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line moves the firefly from (2,2) to (0,4), which is the ones position.
    The second line sets the mode to increment. Next comes a one-second delay followed
    by a “tick” to increment the ones position. Nine more one-second delays finish
    the 10-second delay, and the ones position has moved from 0 up through 9 and back
    to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line `MWIT` moves one position to the left, to (0,3), and increments the
    tens position by 1\. Let’s break the steps down: `M` sets move mode (no trail),
    `W` moves left one position, `I` sets increment mode, and `T` increments position
    (0,3). The block of steps ends with `MEI` to move back to (0,4), the ones position,
    which is currently 0 because it rolled over, followed by `I` to reassert increment
    mode.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-2](ch15.xhtml#ch015list2) counts for 10 seconds. If [Listing 15-2](ch15.xhtml#ch015list2)
    is repeated nine more times, except for the top two lines, `NNEE` and `I`, which
    set up the initial firefly position and mode, we’ll have a 100-second timer.'
  prefs: []
  type: TYPE_NORMAL
- en: The file *fly_time.fly* in *console/examples* contains the code we need. Most
    of the code is repeated blocks like [Listing 15-2](ch15.xhtml#ch015list2). However,
    the 10th block ends with [Listing 15-3](ch15.xhtml#ch015list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-3: End of the 10th timer block*'
  prefs: []
  type: TYPE_NORMAL
- en: The last one-second pause and an increment happens, followed by `MWIT` to move
    from (0,4) to (0,3) and increment the tens value. As this is the 10th block, the
    tens value has rolled over from 9 back to 0\. So a second `MWIT` moves from (0,3)
    to (0,2), the hundreds position, and increments it.
  prefs: []
  type: TYPE_NORMAL
- en: This last step completes a counter from 0 to 100\. If the firefly moves back
    to (0,4) and the program loops by starting over, the display will still read `1
    0 0`. The final line is `MEEI` to move back to (0,4) and set increment mode. As
    there is no `H` or `L` instruction, the program begins again.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when the program loops, the display memory is preserved, but the firefly
    is warped back to its initial position of (2,2). However, this is what we want.
    The first instructions in *fly_time.fly* tell the firefly to move to (0,4), which
    is just where we need it to be to count another 100 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The hundreds position, (0,2), is incremented again after another 100 seconds,
    leaving the display at `2 0 0`. Another 100 seconds later, the display is `3 0
    0`. This continues to 1,000 seconds, after which the display rolls over to all
    0s. We don’t increment the thousands position, but the program continues to loop
    until we hit CTRL-C, so the 1,000-second counter begins again, over and over.
  prefs: []
  type: TYPE_NORMAL
- en: Run *fly_time.fly* with the console interpreter using `-z` to show 0 memory
    as 0s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The program counts until you hit CTRL-C. By starting the program at the beginning
    of an interval, and using CTRL-C to stop the program at the end of an interval,
    we have a primitive stopwatch—geeky to be sure, but functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example makes use of the only looping available to Firefly: restarting
    the program. It is naturally designed for the console so we can read the time
    directly as a number, but nothing stops you from running this code on the micro:bit.
    If you do, you’ll see sequences of increasingly bright LEDs. If you are like me,
    you’ll see the LEDs change and understand that the program is counting up, but
    not be able to reliably tell the difference between an LED that is at, say, brightness
    3 versus one at brightness 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, *fly_time.fly* is counting in base-10; however, there is no reason
    why other bases couldn’t be used. If we used binary, then the micro:bit would
    work nicely. Or perhaps we could use base-3, with LED intensities of 0, 5, and
    9 to make the distinction between digits clear. Changing the base changes the
    repeated code block used, but the general idea remains the same. Instead of ones
    (10⁰), tens (10¹), and hundreds positions (10²), we would use ones (3⁰), threes
    (3¹), nines (3²), and possibly twenty-sevens positions (3³).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll implement a different sort of timer later in the chapter, but for now,
    let’s learn how to use Firefly’s double buffering for animations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Space Trek**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve mentioned Firefly’s double buffering several times now. Let’s see it in
    action. The examples in this section work best on the micro:bit. Depending on
    your machine’s speed, you might see some effect when using the console interpreter;
    however, it’s most noticeable on the micro:bit.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the chapter, we played around with *hi.fly* and commented that since
    we are showing grid A while drawing on grid A, we see the letters as they’re drawn.
    A simple modification uses double buffering to present the letters to us only
    after being drawn. The code we need is in *hi2.fly* under *console/examples*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-4](ch15.xhtml#ch015list4) presents the updated code. The only difference
    between [Listing 15-4](ch15.xhtml#ch015list4) and [Listing 15-1](ch15.xhtml#ch015list1)
    is the first line, `Y`, and the second-to-last line, `X`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-4: “HI” with double buffering*'
  prefs: []
  type: TYPE_NORMAL
- en: We show grid A and draw to it. Executing `Y` shows grid B, which is empty, while
    still drawing to grid A. The letters are drawn as before, but the user does not
    see it because grid B is shown. When the letters are finished, `X` shows grid
    A again, and `L` enters the loop to preserve the micro:bit display.
  prefs: []
  type: TYPE_NORMAL
- en: Bundle *hi2.fly* and load it on the micro:bit. When it runs, instead of watching
    the letters draw, you’ll see nothing until the complete word `HI` suddenly appears.
    If you run *hi2.fly* in the console using the `-t` option, you’ll notice `HI`
    suddenly appear as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-4](ch15.xhtml#ch015list4) is a bare-minimum example of double buffering.
    The core concept of double buffering is to show grid B while updating grid A and
    then switch and show grid A while updating grid B. We repeat this as necessary
    so that the user never views a grid as it is being drawn.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see a slightly more interesting example where we simulate the random “computer”
    displays often seen in the background of 1960s sci-fi shows. First, we’ll generate
    the display live, without double buffering. Then we’ll change the code to use
    double buffering. The difference between the two is visibly clear; however, to
    be honest, both approaches are pretty cool to watch.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-5](ch15.xhtml#ch015list5) generates random displays without double
    buffering.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-5: Random computer lights*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line moves to (0,0), the upper-left corner of the display. Recall
    that not only does the firefly start at position (2,2), it also starts in “move”
    mode (`M`) so there is no trail. The second line sets the mode to “random” (`R`).
  prefs: []
  type: TYPE_NORMAL
- en: The third line moves east from (0,0) four times. Each move sets the previous
    position to a random intensity. After the last move east, the firefly is at position
    (0,4), so a move south sets position (0,4) to a random intensity and puts the
    firefly at position (1,4).
  prefs: []
  type: TYPE_NORMAL
- en: To fill in the second row of the display, we’ll need four moves to the west
    followed by a move south to end up at the beginning of the third row. This zig-zag
    continues through the remaining rows until the final `S` moves the firefly to
    (0,4). A final move then sets the last LED at (4,4).
  prefs: []
  type: TYPE_NORMAL
- en: There is no halt instruction, so the program loops after filling the display.
    The firefly is reset to (2,2), immediately moved to (0,0), and the grid is drawn
    again from top to bottom. Therefore, the display is overwritten continuously,
    row by row, with the previous set of random intensities still present.
  prefs: []
  type: TYPE_NORMAL
- en: The console interpreter is too fast to see the overwriting effect, but running
    *random.fly* on the micro:bit makes it visible, though just barely. Even on the
    micro:bit, the code is almost too fast. The effect is mesmerizing. Unfortunately,
    there is no way to capture the effect in a still image in a book. To see the effect,
    do view the videos on the GitHub site.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of overwriting the display one row at a time, we can introduce double
    buffering and display a full grid of random intensities while generating the next
    grid, then flip and display that grid, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-6](ch15.xhtml#ch015list6) shows us *random2.fly*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-6: Random computer lights with double buffering*'
  prefs: []
  type: TYPE_NORMAL
- en: The code is in two distinct blocks. The first block is nearly identical to [Listing
    15-5](ch15.xhtml#ch015list5) except for the addition of a leading `B` instruction
    to tell the firefly to make trails on grid B even though grid A is being shown.
    At the bottom of the first block, after the entirety of grid B is updated, come
    `M` and `NNNN` to set move mode and then move back to (0,0).
  prefs: []
  type: TYPE_NORMAL
- en: The second block of code now takes over. First, `YA` shows grid B, the grid
    the first block of code just filled with random intensities, and switches to drawing
    trails on grid A. The next six lines fill grid A and the final instruction is
    `X` to show grid A.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the program loops and begins again, filling grid B. The final
    `X` has us looking at grid A, just as we do when a Firefly program begins, so
    the sequence repeats: show A, draw on B, show B, draw on A, and repeat forever.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike [Listing 15-5](ch15.xhtml#ch015list5), which constantly overwrites the
    one grid shown, [Listing 15-6](ch15.xhtml#ch015list6) ping-pongs between the two
    grids, so the user only sees the grid that was most recently filled and never
    the grid actively being drawn to. The effect is perhaps even more like the old
    sci-fi movies. There is no flow from top to bottom and the intensities change
    seemingly at once.
  prefs: []
  type: TYPE_NORMAL
- en: '**Beethoven in Lights**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I claimed in [Chapter 14](ch14.xhtml#ch14) that our firefly knows how to sing.
    Let’s prove it now by writing some music in Firefly. Of course, without an actual
    micro:bit, console-only runs of the examples in this section will be disappointing.
    Have no fear! You can always listen to the song via the videos included on the
    book’s GitHub site.
  prefs: []
  type: TYPE_NORMAL
- en: Firefly supports playing notes in the key of C. Middle C (the default) is octave
    4, and middle C itself is note 1\. Therefore, the simplest way to play a note
    in Firefly is to execute `1TF`, which sets the intensity to 1, “ticks” to update
    the default firefly position of (2,2), and plays with the default duration of
    a quarter note. The code loops, of course, and after a brief pause for reset,
    the note plays again. The result is a dim LED in the middle of the grid followed
    by buzzing at the pitch of middle C, over and over and over until you cut the
    power. Still, it’s impressive to get sound from a three-character program.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly longer program does sound fun and a bit outer space-ish: `1TJRTF`.
    First, it sets the note duration to 1, which is one-quarter of a quarter note
    (a sixteenth note). Then it sets the note itself to a random note and plays it.
    Visually, the higher the pitch, the brighter the LED. The `R` instruction sets
    positions to a random value in the range [1,9]. However, you’ll notice pauses
    while the random melody plays. If the random value is 8, it acts as note 0, which
    is a rest. For fun, experiment with two slightly different versions: `RTJRTF`
    and `0TJRTF`. The first makes the note duration random as well, and the second
    sets the duration to 0, causing a staccato effect.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll get to Beethoven in time, but before we do, [Listing 15-7](ch15.xhtml#ch015list7)
    shows us how to play an actual scale.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-7: A simple C-major scale*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line sets the duration to 1, as we did with the random melody. Next,
    we set the note to 0 and the mode to increment. Then, `TF` increments to 1 and
    plays the note (middle C). The next `TF` increments to 2 and plays D. This repeats
    for notes E through B.
  prefs: []
  type: TYPE_NORMAL
- en: To play the C one octave above middle C, we need to update the octave with `5TG`,
    remembering that middle C is octave 4\. Lastly, `8TG` sets the duration to a half
    note (8) and plays the first note of octave 5 before halting.
  prefs: []
  type: TYPE_NORMAL
- en: The scale plays quickly, but there is a distinct pause before the final note
    plays. In this case, it adds a bit of dramatic effect, but in reality, the pause
    is an artifact of how slowly the micro:bit interprets Firefly instructions. There
    are eight instructions between playing the second-to-last note, B, and the last
    note, C. Interpreting these eight instructions causes the pause you hear.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get classical. We want code to make the firefly “sing” Beethoven’s *Ode
    to Joy* (see [Figure 15-3](ch15.xhtml#ch015fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/15fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: Beethoven’s* Ode to Joy'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of simply playing the notes in one place, wouldn’t it be nice if the
    firefly displayed the notes as it played them? S- along with singing, we want
    the firefly to show us the notes in lights on the display.
  prefs: []
  type: TYPE_NORMAL
- en: There are 30 notes in [Figure 15-3](ch15.xhtml#ch015fig3), split into two musical
    phrases of 15 notes each. There are five LEDs per row on the micro:bit display.
    How convenient for us. We’ll show the notes, one per position, using the first
    three rows of LEDs to cover a 15-note phrase. Then, we’ll clear the screen and
    repeat the process for the remaining 15 notes. The code we need is in *ode.fly*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the code by musical phrase. The first phrase is in [Listing
    15-8](ch15.xhtml#ch015list8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-8: Ode to Joy, first phrase*'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the octave is that of middle C, and the duration matches a quarter
    note, so we need not change the duration or octave. We want the notes displayed
    as they play, row by row, so we first move the firefly to position (0,0). The
    next line sets up a pattern we’ll repeat for each note. For example, `3TFE` sets
    the current position to 3 (`3T`) and plays the note (`F`) before moving one position
    to the east (`E`). This pattern of instructions is used for every note of the
    piece.
  prefs: []
  type: TYPE_NORMAL
- en: The next four notes, E-F-G-G, finish the first row and leave the firefly back
    at position (0,0). To get to the next row, we use `MS` to move south to (1,0)
    without changing the current value of (0,0). The notes of the second row play
    next, F-E-D-C-C, before moving to the third row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first four notes of row 3 play: D-E-E-D. Then, we change the duration from
    quarter notes to half notes. If we make the change directly, we’ll upset the display,
    as we need to set a position to 8 for the `J` instruction. So we tell the firefly
    to draw on grid B, which is not displayed, and set the duration that way before
    switching back to drawing on grid A and playing the note: `A2TF`. The first phrase
    is now complete.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-9](ch15.xhtml#ch015list9) plays the second phrase.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-9: Ode to Joy, second phrase*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-9](ch15.xhtml#ch015list9) is much the same as [Listing 15-8](ch15.xhtml#ch015list8)
    except for the first line. That line clears the display, grid A, switches to grid
    B to reset the duration to 4, and then goes back to drawing on grid A. The next
    line moves the firefly to (0,0), and the second phrase plays just as the first
    did. After the final note, the program executes `H` to end.'
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, we must run this program on the micro:bit, but you can play the associated
    video to see how it goes if you don’t have one. It would be straightforward to
    copy this technique to play other melodies, though we were fortunate that *Ode
    to Joy* consists of two distinct musical phrases of exactly 15 notes and thus
    fits perfectly on the 5×5 display.
  prefs: []
  type: TYPE_NORMAL
- en: If you watch the melody play, you’ll see how the LED intensity is related to
    the pitch of the note; higher notes are brighter, at least within the same octave.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dance Dance**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s use Firefly’s double-buffering abilities to do a bit of animation
    with music. We’ll begin with the animation and add the music later.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to make a simple figure “dance.” With a 5×5 display, the emphasis
    is definitely on the word *simple*. Each stance of the figure is a display. To
    make the animation, we’ll use double buffering and a collection of independent
    stances. We’ll proceed by defining the stances in code, putting them together
    in an animation, and adding the dance music. Our firefly will be quite the busy
    flier for this example.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Stances***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll make the firefly trace the figure for each stance beginning and ending
    at position (2,2). This allows us to string the stances together in any order
    that we wish and be in the proper position when the program loops and begins again.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin with Stance 1\. As the figure dances, each move returns to Stance
    1 before moving on to the next. [Listing 15-10](ch15.xhtml#ch015list10) shows
    the code for Stance 1 along with the stance itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-10: Stance 1*'
  prefs: []
  type: TYPE_NORMAL
- en: With a bit of imagination, you’ll see a figure with outstretched arms. To make
    the figure dance, we’ll move the arms and legs in sequence. We can move both arms
    up or down, or move one up and the other down. Similarly, we can move the right
    leg out or the left leg out for a total of six possible stances. [Table 15-1](ch15.xhtml#ch015tab1)
    gives us the code and the appearance of each stance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** The Remaining Stances'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0406-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While developing this example, it was extremely helpful to use the console interpreter
    in trace mode. I first generated the code for each stance independently of the
    others. We’ll see below how this helps create the desired animation sequence by
    literally copying and pasting code in the right place.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Dance***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To animate the figure, we start with Stance 1, and after each move go back to
    Stance 1\. The sequence is
  prefs: []
  type: TYPE_NORMAL
- en: 1 → 2 → 1 → 3 → 1 → 4 → 1 → 5 → 1 → 6 → 1 → 7
  prefs: []
  type: TYPE_NORMAL
- en: where we end with Stance 7 and allow the program to loop to begin again with
    Stance 1.
  prefs: []
  type: TYPE_NORMAL
- en: Look carefully at the sequence of stances and think of Firefly’s double buffers.
    When the program starts, we’re looking at grid A and the firefly is drawing to
    grid A. We’ll draw Stance 1 in grid A, but doing that will let the user see the
    firefly draw, so we’ll show grid B while drawing Stance 1\. Likewise, when the
    firefly has drawn Stance 1 in grid A, we’ll show grid A and tell the firefly to
    draw in grid B. Then, we’ll render Stance 2 in grid B.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we might be tempted to draw Stance 1 in grid A; however, Stance
    1 is already in grid A, so we don’t need to draw it again. This is why the figure
    always returns to Stance 1 before moving to another stance—we can leave Stance
    1 in grid A and only draw it once. When we need to draw a new stance, we’ll do
    it in grid B while showing Stance 1 in grid A.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to animate, we need the following sequence, formatted as (*shown*,
    *drawn*):'
  prefs: []
  type: TYPE_NORMAL
- en: (*B*, *A*) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*) →
  prefs: []
  type: TYPE_NORMAL
- en: (*B*, ∗) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*) → (*B*, ∗) → (*A*, *B*)
  prefs: []
  type: TYPE_NORMAL
- en: Here, ∗ means we don’t change the grid drawn to as we’re showing Stance 1, which
    never needs to be redrawn. At each step in the sequence, save the first, the grid
    shown reveals the most recently drawn stance (or Stance 1).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-11](ch15.xhtml#ch015list11) presents the animation code in skeleton
    form to show the sequence of stances drawn and how the different grids are displayed
    and drawn to. To generate the actual code, replace instances of “draw Stance 1”
    and so on with the proper code block from [Table 15-1](ch15.xhtml#ch015tab1) or
    [Listing 15-10](ch15.xhtml#ch015list10).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-11: Animation sequence code skeleton*'
  prefs: []
  type: TYPE_NORMAL
- en: The `PPPPP` blocks delay for 0.5 seconds to control the speed of the animation.
    These are also the locations where we’ll later add music. To watch the animation
    without music, execute *dance.fly*.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Music***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s add some music. The melody we’ll use was kindly written for us by film
    and television composer Paul Kneusel (see [Figure 15-4](ch15.xhtml#ch015fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/15fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: “Dance dance” by Paul Kneusel (*[https://www.paulkneusel.com/](https://www.paulkneusel.com/)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: Translating the score into Firefly code leads to [Listing 15-12](ch15.xhtml#ch015list12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-12: “Dance dance” in Firefly*'
  prefs: []
  type: TYPE_NORMAL
- en: You can hear the melody by loading *dance_loop.fly* onto the micro:bit or by
    watching the video on the GitHub site. The music plays in place, so the center
    LED on the micro:bit fluctuates in brightness as the melody plays.
  prefs: []
  type: TYPE_NORMAL
- en: To complete this section, we’ll merge the melody with the animation code. [Listing
    15-11](ch15.xhtml#ch015list11) has pauses between screens, `PPPPP`. For the musical
    version, we’ll replace the pauses with successive measures from the melody, so
    the first instance of `PPPPP` in [Listing 15-11](ch15.xhtml#ch015list11) is replaced
    by the first measure of [Listing 15-12](ch15.xhtml#ch015list12) and so on. The
    result is *dance_music.fly*. We won’t show the code here, but do read through
    it.
  prefs: []
  type: TYPE_NORMAL
- en: If you run *dance_music.fly*, you’ll hear the first measure as a sort of intro
    before the animation. There are noticeable pauses while successive screens are
    rendered in the buffer not shown, but the tune and animation still work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tea Time**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no general agreement as to how long one should steep a cup of tea,
    but a rule of thumb I often use is about three and a half minutes for a cup of
    black tea. In this section, we’ll use Firefly to write a tea timer that runs for
    about three and a half minutes. Once you see the pattern, you’ll be able to adjust
    the delay to suit your tastes.
  prefs: []
  type: TYPE_NORMAL
- en: The timer counts down a display of LEDs. When the countdown is complete, the
    program animates the display while playing an alarm sound to let us know our tea
    is ready. This example is practical enough to make it worth dedicating an entire
    micro:bit to the task. Just put your teabag in the hot water, start the micro:bit,
    and wait for the visual and audio alarm to sound—your tea is now ready.
  prefs: []
  type: TYPE_NORMAL
- en: The source code is in *tea_timer.fly*. The program fills the first four rows
    of the display with maximum intensity. Then, starting with position (0,0), the
    program dims the LEDs by 1 after a one-second delay. When the LED at the current
    position is 0, the program moves to the next position and repeats. LED after LED
    is dimmed to 0 this way until all four rows are 0\. After the display is completely
    0, a brief animation of star patterns plays along with a rapid scale as the audio
    alarm.
  prefs: []
  type: TYPE_NORMAL
- en: Filling four rows of the display means we have 20 LEDs to dim. Each LED takes
    10 seconds to go from maximum intensity to 0; therefore, dimming the display takes
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0409-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The animation and alarm add a few more seconds to give us an approximate three-and-a-half
    minute timer.
  prefs: []
  type: TYPE_NORMAL
- en: The timer starts by filling the first four rows of grid A with 9s (see [Listing
    15-13](ch15.xhtml#ch015list13)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-13: Filling the display*'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid watching the display draw, grid B is shown until the first four rows
    of grid A are full, and then grid A is shown again after moving the firefly to
    position (0,0).
  prefs: []
  type: TYPE_NORMAL
- en: The countdown now begins. Here’s where the simplicity of Firefly pains us a
    bit. The pattern we need to implement is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, `M` is the micro:bit display, grid A. It would be nice to have some sort
    of looping construct, but Firefly is too primitive to support looping, so we need
    to unroll the loops and manually decrement each position to 0 before moving to
    the next position and then repeat, row by row.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, once we have a pattern in place for the current position, we have
    what we need for virtually all the positions in a row. Once we have all we need
    for a row, we have what we need for all four rows. So unrolling the loops isn’t
    too bad and is relatively straightforward with the help of some copy-and-paste
    magic.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to process the first column of the first row, meaning position
    (0,0), we need
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first line pauses for one second, then uses `T` to decrement the current
    position without moving. This changes intensity 9 to intensity 8\. Repeating this
    process eight more times results in intensity 0 at (0,0). We need to wait one
    more second for the 0 intensity before moving to the next column with `MED`. We
    are now at position (0,1) and ready to repeat this code block. We do the same
    for positions (0,2), (0,3), and (0,4).
  prefs: []
  type: TYPE_NORMAL
- en: At the end of position (0,4), we need to move to the next row. So instead of
    executing `MED`, we execute `MESD` to arrive at (1,0). The entire process repeats
    for row 1, row 2, and row 3\. However, at the end of row 3, the timer portion
    is complete and all of grid A is empty. We conclude by moving to (2,2) via `MWWN`
    so we are in position to begin the animation and alarm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The animation is straightforward: two star patterns, with one stored on each
    grid. We’ll toggle between them while playing the alarm. [Listing 15-14](ch15.xhtml#ch015list14)
    shows the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-14: Animation and alarm code*'
  prefs: []
  type: TYPE_NORMAL
- en: There are three code blocks. The first generates an X shape on grid A and the
    second displays a + shape on grid B. The last block toggles between grids A and
    B while playing a scale over and over. Note that the firefly is at position (2,2),
    so the center pixel on both grids changes as the animation happens. When complete,
    the program exits, and our tea is ready.
  prefs: []
  type: TYPE_NORMAL
- en: The tea timer concludes our Firefly examples. There is one more, using genetic
    programming to evolve Firefly programs, but its complexity requires moving it
    to Appendix 16\. Do take a look. The examples of this chapter are fun and whimsical.
    The example in Appendix 16 demonstrates a more sophisticated way to use even the
    tiniest of esolangs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Firefly is most definitely *not* Turing complete. We learned in [Chapter 3](ch03.xhtml#ch03)
    that a Turing complete imperative programming language requires some form of conditional
    branching and arbitrary memory. Firefly has no branching, conditional or otherwise,
    and minimal memory; therefore, Firefly is not Turing complete and not able to
    implement, even in theory, arbitrary algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as the examples of this chapter demonstrate, Firefly does support
    useful programs. We created a counter suitable for timing things in the real world.
    We also created a timer for steeping tea and programs to play music. Even the
    random sci-fi backgrounds are useful, if desired: imagine a wall of micro:bits
    each running *random.fly* or *random2.fly* and built into a prop.'
  prefs: []
  type: TYPE_NORMAL
- en: Is Firefly all it could be? Definitely not. The micro:bit has two pushbuttons
    for user input, but Firefly ignores them. And this says nothing about all the
    many other advanced features the micro:bit supports. One reason for making Firefly
    primitive was the limited memory of the version 1 micro:bit. Another was the need
    for simplicity in the presentation via a physical book. Firefly is screaming for
    enhancement. I genuinely hope a reader or two accepts the challenge and enhances
    the language. If you do, please share it with us. Part of the fun of esoteric
    programming languages is how they build upon each other—just witness the many
    variants of BF. One language’s ideas prompt new thoughts about languages and lead
    to “what if” ideas, which lead to new esolangs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we presented many examples of Firefly programs. Some were trivial,
    like *hi.fly*, and others were visually appealing, like *random.fly*, or musical,
    like *ode.fly*. Some were cute, like *dance.fly*, and some were perhaps even a
    bit useful, like *fly_time.fly* and *tea_timer.fly*. Regardless, all were (hopefully)
    fun. Many more fun Firefly programs doubtless exist, waiting to be extracted from
    the ether and written down. For example, its display and its compact size makes
    the thought of embedding the micro:bit in a craft or holiday decoration something
    to consider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firefly also concludes our exploration of esolangs and programming languages
    in general. Only one chapter remains: where to go from here.'
  prefs: []
  type: TYPE_NORMAL
