- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BOOLEAN
    ALGEBRA AND THE LOOK-UP TABLE</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: Boolean algebra is a field of mathematics and logic essential to understanding
    how to work with devices like FPGAs. In Boolean algebra, the input and output
    values are all true or false, which we can equate with 1s and 0s, or high and
    low voltages. Instead of operations like multiplication and division, Boolean
    algebra has operations such as AND, OR, and NOT. Each of these operations takes
    in some number of 0s and 1s as input, evaluates them, and produces a 0 or 1 as
    an output. Algebra class would have been much simpler if it had been about Boolean
    algebra!
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have encountered Boolean operations in other programming languages,
    such as C or Python. For example, you might want your program to write to a file
    only if the user chooses to do so *and* the filename is valid. Similarly, inside
    an FPGA, you’ll often want to check multiple inputs to determine the state of
    an output. Let’s say you want to turn on an LED when either of two switches is
    pressed. An FPGA can make this happen using an OR operation: if either one switch
    *or* the other (or both) provides a 1 as an input, the FPGA provides a 1 as an
    output to the LED, and the LED lights up.'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean algebra makes tasks like this possible. But more importantly, Boolean
    algebra describes *all* the underlying operations on data in your FPGA. String
    together enough Boolean operations and you can do math, store data, and more.
    You can do a surprising amount by manipulating 1s and 0s.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore how to represent simple Boolean operations with
    logic gates, and we’ll see how these gates can be combined into more complicated
    Boolean equations. Then we’ll explore how FPGAs actually perform logic operations
    by combining the functionality of different logic gates into a single device called
    a look-up table. As you’ll see, look-up tables are one of the most important components
    in an FPGA.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Logic Gates and Their Truth Tables</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing FPGAs, we represent simple Boolean operations with *logic gates*,
    devices that take in electrical signals as inputs, perform a Boolean operation
    on them, and produce the appropriate electrical signal as an output. There are
    different logic gates corresponding to all the different Boolean operations, such
    as AND, OR, NOT, XOR, and NAND. Each of these logic gates can be described with
    a *truth table*, a table that lists all the possible input combinations for a
    Boolean algebra equation and shows the corresponding outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll discuss some common logic gates and examine their truth tables next.
    But first, it’s important to understand what the 1s and 0s in the truth tables
    we’ll be looking at actually mean. Inside an FPGA, digital data is represented
    by voltages: 0 volts for a 0, and some higher-than-zero voltage, called the *core
    voltage*, for a 1\. The core voltage depends on the specific FPGA, but often is
    around 0.8 to 1.2 volts. When we talk about a signal being *high*, we mean that
    the signal is at the core voltage and represents a data value of 1\. Likewise,
    a *low* signal is at 0 volts and represents a data value of 0\. With this in mind,
    let’s look at some logic gates.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AND Gates</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *AND gate* is a logic gate whose output is high when all its inputs are high.
    We’ll use the example of a two-input AND gate, but AND gates can have any number
    of inputs. For a two-input AND gate, the output is high when input A *and* input
    B are both high, hence the name AND gate. [Table 3-1](#tab3-1) shows the truth
    table for this AND gate. Notice that the output is a 1 only when both inputs are
    a 1.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for a Two-Input AND Gate</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: In a truth table, the rows are usually arranged in increasing decimal order,
    based on the inputs. In the case of the AND truth table, the first row shows when
    input A = 0 and input B = 0, which is represented as <samp class="SANS_TheSansMonoCd_W5Regular_11">b00</samp>,
    which means <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> in binary,
    or 0 in decimal. Next comes <samp class="SANS_TheSansMonoCd_W5Regular_11">b01</samp>
    (decimal 1), then <samp class="SANS_TheSansMonoCd_W5Regular_11">b10</samp> (decimal
    2), then <samp class="SANS_TheSansMonoCd_W5Regular_11">b11</samp> (decimal 3).
    If the AND gate had additional inputs, then there would be more rows in our truth
    table that we would have to fill out. In the case of a three-input AND gate, for
    example, there would be eight rows, going from <samp class="SANS_TheSansMonoCd_W5Regular_11">b000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b111</samp>, or 0 to 7 in decimal.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*The output of a logic gate is denoted with a Q. This convention comes from
    the English mathematician Alan Turing, who used the letter Q to denote states
    in his famous Turing machines. The Q stood for* quanta*, which is a discrete state
    (such as 0 or 1), rather than something that can have a continuous range of values.*'
  prefs: []
  type: TYPE_NORMAL
- en: Each logic gate has a distinctive symbol for use in schematics. A two-input
    AND gate is drawn as shown in [Figure 3-1](#fig3-1). The symbol depicts the inputs
    A and B going into the gate on the left, and the output Q emerging on the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: The AND gate symbol</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As we continue our exploration of logic gates, most of the gates we’ll look
    at will have two inputs and one output. As with AND gates, it’s possible that
    these other types of gates could have additional inputs, but for simplicity we’ll
    stick to the two-input versions. (The exception is the NOT gate, which can only
    have one input and one output.) For brevity, I’ll omit the words *two-input* from
    this point forward when referring to a given logic gate.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">OR Gates</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *OR gate* ([Figure 3-2](#fig3-2)) is a logic gate whose output is high when
    either of the inputs is high; that is, when either input A *or* input B is high.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The OR gate symbol</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-2](#tab3-2) shows the truth table for an OR gate.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for an OR Gate</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: Notice that when both inputs are high, the OR gate’s output is high as well.
    All that matters to an OR gate is that at least one of the inputs is high, which
    is also the case when both inputs are high.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NOT Gates</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *NOT gate* ([Figure 3-3](#fig3-3)) has a single input and a single output.
    This kind of gate simply inverts the input (the output is *not* the input), so
    it’s also known as an inverter.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: The NOT gate symbol</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the bubble at the tip of the triangle in the NOT gate symbol, which indicates
    inversion. It also appears in the NAND gate, which we’ll look at later, and can
    even appear on some inputs. The truth table for a NOT gate is shown in [Table
    3-3](#tab3-3).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for a NOT Gate</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output
    Q</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: As the truth table indicates, whatever the input value to the gate is, the output
    is the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">XOR Gates</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The output of an *XOR gate* (pronounced “ex-or,” short for *exclusive or*) is
    high when either of the inputs is high, but not both. In other words, the gate
    checks for exclusively one or the other input being high. The symbol for an XOR
    gate is shown in [Figure 3-4](#fig3-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: The XOR gate symbol</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The symbol looks like that of an OR gate, but the extra line on the left side
    of the gate sets it apart. [Table 3-4](#tab3-4) shows the XOR gate’s truth table.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for an XOR Gate</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: Though this type of gate might not seem particularly useful at first blush,
    it comes up more often than you might expect. For example, XOR gates are used
    for generating a *cyclic redundancy check (CRC)*, a way to validate data to verify
    the integrity of transmitted information.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NAND Gates</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *NAND gate* (short for *not and*) has the opposite output of an AND gate.
    You can infer this from the NAND gate’s schematic symbol, shown in [Figure 3-5](#fig3-5):
    it looks exactly like an AND gate, except with a bubble on the output to indicate
    an inversion.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: The NAND gate symbol</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The output of the NAND gate is thus the same as an AND gate, but inverted. If
    both input A and input B are high, output Q will be low. In all other cases, output
    Q will be high. This is shown in the truth table in [Table 3-5](#tab3-5).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for a NAND Gate</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: NAND gates are commonly used in USB flash drives, solid state drives (SSDs),
    and other types of data storage devices. They also inspired the name of my website,
    [*https://<wbr>nandland<wbr>.com*](https://nandland.com).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Other Gates</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve explored the most common types of logic gates here to give you an idea
    of how they work, but this isn’t an exhaustive list. There are other types as
    well, such as NOR (short for *not or*) and XNOR (*exclusive not or*) gates. Additionally,
    as mentioned previously, though we focused on the two-input versions here, all
    of these gates (with the exception of NOT) can have more than two inputs. This
    section was just intended to get you comfortable with the standard logic operations
    from Boolean algebra. Next, we’ll explore how these operations can be combined
    to make more complicated expressions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Combining Gates with Boolean Algebra</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve seen how individual logic gates work. However, often you’ll want to write
    code that’s more complex than just a single logic operation. The good news is
    that you can chain together multiple logic gates to represent more elaborate Boolean
    equations, and use Boolean algebra to determine the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: In Boolean algebra, each logic operation has its own symbol. One common set
    of symbols is shown in [Table 3-6](#tab3-6). For example, * represents an AND
    operation, and + represents an OR operation. These symbols make it easier to write
    more elaborate Boolean algebraic equations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-6:</samp> <samp class="SANS_Futura_Std_Book_11">Boolean
    Algebra Symbols</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Symbol</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Meaning</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">AND</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| + | <samp class="SANS_Futura_Std_Book_11">OR</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">′</samp> | <samp class="SANS_Futura_Std_Book_11">NOT</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">^</samp> | <samp class="SANS_Futura_Std_Book_11">XOR</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Boolean algebra also has its own *order of operations*. To solve a Boolean equation,
    first you evaluate NOTs, then ANDs, and finally ORs. As in conventional algebra,
    you can use parentheses to bypass the order of operations; anything in parentheses
    will be evaluated first.
  prefs: []
  type: TYPE_NORMAL
- en: You now know everything you need to write and evaluate Boolean equations with
    more than one logic operation, such as Q = A * B + A<samp class="SANS_Futura_Std_Book_11">′</samp>.
    In plain language, you’d read this as “The output Q equals A *and* B *or not*
    A.” [Table 3-7](#tab3-7) shows the truth table for this equation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-7:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for A * B</samp> + <samp class="SANS_Futura_Std_Book_11">A′</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output Q</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[Figure 3-6](#fig3-6) shows the circuit equivalent of this equation, created
    by combining logic gates.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: The circuit diagram
    for A * B</samp> + <samp class="SANS_Futura_Std_Book_Oblique_I_11">A</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">′</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we still have only two inputs, but because those inputs go through
    three different logic operations, the possible outputs of our truth table are
    more interesting than they were for individual logic gates. Let’s consider what
    happens with this equation when both inputs are 0, the first row of our truth
    table. The equation has no parentheses, so first we look at NOT A, which evaluates
    to 1\. Then we perform the AND operation of A and B, which evaluates to 0\. Finally,
    we OR the results of both of those expressions, giving us an output of 1\. Considering
    the other possible inputs, you should see that any time A is 0, or any time A
    and B are both 1, the output Q will be 1\. Otherwise, the output will be 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this example featured two inputs, it’s possible to have Boolean equations
    with any number of inputs. Each input increases the number of rows in the truth
    table by a factor of 2: for one input there are two truth table rows, for two
    inputs there are four rows, for three inputs there are eight rows, and so on.
    In mathematical terms, for *n* inputs, there are 2*^n* truth table rows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, let’s consider an example equation with three inputs: Q = A
    + (C * B′). Note that the parentheses indicate that the operation C AND NOT B
    occurs prior to the OR operation. In fact, that follows the regular Boolean algebra
    order of operations, but the parentheses make the equation a little easier to
    read. The truth table with three inputs is shown in [Table 3-8](#tab3-8).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-8:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for A</samp> + <samp class="SANS_Futura_Std_Book_11">(C * B′)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input
    B</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Input C</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Output
    Q</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: The corresponding circuit is shown in [Figure 3-7](#fig3-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: The circuit diagram
    for A</samp> + <samp class="SANS_Futura_Std_Book_Oblique_I_11">(C * B</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">′</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To generate this truth table, first we should perform the operation inside the
    parentheses. This is C AND NOT B. Within the parentheses, the highest precedence
    is the inversion applied to B, which is then ANDed with C. In all, the part of
    the equation in parentheses evaluates to high when C is high and B is low, and
    since the remainder of the equation is an OR operation, we also know that the
    overall output will be high when C is high and B is low. This case occurs on the
    second line of the truth table. It also occurs on the fifth line of the truth
    table, so we can fill those in with a 1\. Finally, consider the A on the other
    side of the OR operation. When it’s high, as in the last four lines of the truth
    table, the output will be high. We can fill in the remaining lines with a 0 to
    complete the truth table.
  prefs: []
  type: TYPE_NORMAL
- en: Combining logic operations to perform more complicated functionality is common
    throughout programming. In FPGAs, this same capability is possible by chaining
    together simple logic gate functions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Look-Up Table</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we’ve been learning about individual logic gates, but it might surprise
    you to find out that these logic gates don’t physically exist inside an FPGA.
    There isn’t a bank of AND gates and OR gates that you can just pull from and wire
    together to create your Boolean algebra logic. Instead, there’s something much
    better: *look-up tables (LUTs)*. These are devices that can be programmed to perform
    any Boolean algebra equation you can think of, regardless of the specific logic
    gate(s) involved. If you need an AND gate, a LUT can do it. If you need an XOR
    gate, a LUT can do that too. A single LUT can also evaluate an equation involving
    multiple logic gates, like the ones we considered in the previous section. Any
    truth table you can think of, a LUT can produce. This is the power of the look-up
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '*Early programmable logic devices like Programmable Array Logic (PAL) did actually
    have banks of AND and OR gates. With FPGAs, these have been superseded by the
    more capable LUTs.*'
  prefs: []
  type: TYPE_NORMAL
- en: LUTs are classified by the number of inputs they can accept. For example, there
    are two-, three-, four-, five-, and even six-input LUTs on the newest FPGAs. Most
    LUTs produce a single output. [Figure 3-8](#fig3-8) shows what a three-input LUT
    (often referred to as LUT-3) looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-8: A three-input LUT</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This LUT is a blank slate that can be programmed to perform any Boolean algebra
    operation with three inputs and one output. For example, look back at the circuit
    drawn in [Figure 3-7](#fig3-7) to represent the Boolean equation Q = A + (C *
    B′). Drawing the circuit for that equation required three logic gates—a NOT gate,
    an AND gate, and an OR gate—but we can replace those three gates with our single
    three-input LUT. The same LUT could also be programmed to represent the equation
    Q = (A + B + C)′, or Q = (A + B)′ * C.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we have a Boolean algebra equation with more than three inputs?
    That’s just fine, as LUTs can be chained together to perform very long sequences
    of logic. In fact, the typical FPGA contains hundreds or even thousands of LUTs,
    all ready to be programmed to carry out whatever logic operations you need. This
    is why look-up tables are one of the two most important components to understand
    inside of an FPGA: they perform the logical operations of your code. The other
    key component is the flip-flop, which we’ll talk about in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we’ve been drawing truth tables and logic gate diagrams here, in the
    real world you’ll rarely define FPGA operations this way. Instead, you’ll write
    code. Often, the code you write is at a higher level than individual logic gates:
    you might write code to compare two numbers, or increment a counter, or check
    if a condition is true, and the synthesis tools then break down that code into
    the necessary Boolean logic operations and assign those operations to LUTs. However,
    the purpose of this book is to teach you how FPGAs work so you understand them,
    and at a fundamental level, FPGAs work by performing Boolean algebra. Once you
    know how FPGAs work, you’ll be able to use Verilog or VHDL with a deeper understanding
    of what you’re creating with your code. This will help you create efficient and
    reliable FPGA designs.'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #2: Lighting an LED with Logic
    Gates</samp>'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re now ready to combine everything you’ve learned about Boolean logic and
    look-up tables in a real-world example on your FPGA development board. This project
    should illuminate an LED, but only when two switches are pushed at the same time.
    In other words, you’re using your first LUT by implementing an AND gate. [Figure
    3-9](#fig3-9) shows the block diagram for this project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-9: The Project #2
    block diagram</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project turns the entire FPGA into one single AND gate. This might be overkill
    for a very capable FPGA, but it’s an excellent way to visualize how a LUT works
    in the real world. [Table 3-9](#tab3-9) shows the truth table corresponding to
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_11">Table 3-9:</samp> <samp class="SANS_Futura_Std_Book_11">Truth
    Table for Project #2</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">SW1</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">SW2</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">D1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">0</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  prefs: []
  type: TYPE_TB
- en: This truth table looks exactly like the one we created for the AND gate, but
    the column labels have been replaced to represent two switches and an LED on your
    development board. As expected, the output D1 is only high when inputs SW1 and
    SW2 are both high.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Implementing an AND gate uses very few resources: three connections (two input
    and one output) and a single LUT. Let’s look at the Verilog and VHDL to get that
    LED to light up:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We begin by defining our inputs as <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>, and our output
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>. Then we continuously
    assign the output with the AND of the two inputs ❶. In Verilog the symbol for
    an AND operation is <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, whereas
    in VHDL <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> is a reserved
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building and Programming
    the FPGA</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’re now ready to run your Verilog or VHDL through the build process discussed
    in [Chapter 2](chapter2.xhtml). The synthesis tool will generate a report outlining
    the resource utilization on your FPGA. Here’s the most interesting part of the
    report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This report tells us that three I/O ports (input/output ports, or pins, meaning
    connections to the outside world) on the FPGA have been used to implement our
    circuit design ❶ and, most importantly, that we’ve used a single LUT ❷. That <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0%)</samp> on the last line is indicating
    the resource utilization on the FPGA. On this particular FPGA there are over 1,000
    LUTs available for usage, and we’re only making use of 1 of them. Since the synthesis
    report is showing one LUT with 0 percent resource utilization, the tool must be
    doing some rounding down here (1 / 1,000 = 0.1).
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and program your development board, and notice that the LED only illuminates
    when the two switches are held down together. The LUT is working!
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to change the code around to implement a different Boolean operation
    than AND. For example, you could create an OR gate or an XOR gate using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">|</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>
    symbols in Verilog, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> keywords in VHDL.
    You could also try stringing together several operations to make the LED light
    up based on whatever crazy Boolean algebra equation you can think of, or try adding
    in more switch inputs or more LED outputs to implement more complicated truth
    tables. You can check that the synthesis tools are really generating the correct
    LUTs based on your code by writing out your own truth table using the switches
    as inputs and the LED as the output, then testing all possible switch combinations
    to see if they work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter you’ve learned about one of the two most important components
    of an FPGA: the look-up table. You’ve seen how a LUT can implement any Boolean
    algebra equation with a given number of inputs, from simple logic gates like AND,
    OR, NOT, XOR, and NAND to more complex equations that combine these gates. In
    the next chapter, we’ll focus on the other crucial FPGA component: the flip-flop.'
  prefs: []
  type: TYPE_NORMAL
