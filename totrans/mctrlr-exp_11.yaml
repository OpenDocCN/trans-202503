- en: '**11  STM32F1 Interrupt Jigsaw**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RDP Level 1 of the STM32 series, in which JTAG debugging is allowed but immediately
    disconnects flash memory, is an appealing target for memory extraction exploits.
    The STM32F1 series does not seem to be vulnerable to Obermaier’s STM32F0 exploit
    from [Chapter 10](ch10.xhtml#ch10) or the DFU bootloader exploit from [Chapter
    2](ch02.xhtml#ch02), but in this chapter we will cover a different vulnerability,
    first described in Schink and Obermaier (2020) for the STM32F1 and shortly after
    in Obermaier, Schink, and Moczek (2020) for two of its clones, the APM32F103 and
    CKS32F103\. As a bonus, the STM32F1 series does not support RDP Level 2, so it’s
    possible that all parts in the series are vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: When protections are enabled, flash memory is disconnected from the main memory
    bus when a debugger is attached. You can’t fetch it as data, and you can’t even
    fetch it as code for execution. The trick here is that while flash memory is disconnected
    from the main memory bus for code and data fetches, interrupts can still be fired.
    The interrupt addresses are accurately fetched from the interrupt vector table
    (IVT) despite the disconnect! This table is also movable, and by stepping the
    table slowly across memory, we can move most words of memory into the programmer
    counter for the debugger to catch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0110-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: STM32F103'
  prefs: []
  type: TYPE_NORMAL
- en: '**The First Two Words**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![Image](../images/f0111-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Schink’s paper begins with this gloriously simple example, in which he first
    attaches a Segger J-Link adapter through SWD and then calls `reset halt` in OpenOCD’s
    telnet session to reveal that `0x08000268` are the upper 31 bits of the reset
    vector, the second word in flash memory. `0x20005000` is the initial stack pointer,
    the very first word.
  prefs: []
  type: TYPE_NORMAL
- en: The low bit of the program counter is set (1) for all real handler addresses
    on this chip, indicating Thumb2 mode, but it might be clear (0), so we’ll need
    to recover that bit for a real exploit. This is because unlike the real interrupt
    table, the fake interrupt tables are mostly composed of instructions or data that
    are not interrupt handler addresses. Schink does this by first reading the program
    counter (whose low bit is forced clear) and then grabbing the Thumb2 mode from
    `ESPR` to restore the missing bit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0111-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This gives us the first two words of flash memory, but in reading the code,
    you’ll see that these are a special case because triggering the reset also moves
    the interrupt table back to the beginning of flash memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0112-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**The Rest of Memory**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all other addresses, the entire interrupt table must be slowly stepped across
    flash memory, then individual interrupts must be triggered artificially to move
    table entries into the program counter.
  prefs: []
  type: TYPE_NORMAL
- en: The first complication to this is that seven entries in the list are unusable.
    We’ve already discussed that 0 (MSP) and 1 (reset) can’t be relocated, so except
    at the very beginning, those are forbidden. Exceptions 7, 8, 9, 10, and 13 are
    reserved, and we are unable to trigger them. Exceptions 16 and higher are external
    interrupts, and we can trigger them, but the count differs by chip model.
  prefs: []
  type: TYPE_NORMAL
- en: A second complication is that we are relocating the table with the vector table
    offset register (VTOR). This register is commonly used by custom bootloaders,
    such as the one in [Chapter 3](ch03.xhtml#ch03), so that the chip can boot with
    one interrupt table and later switch over to the application’s table.
  prefs: []
  type: TYPE_NORMAL
- en: If we could slide the interrupt table one word at a time, we could reuse a single
    interrupt to dump all words of memory, but as you can see in [Figure 11.2](ch11.xhtml#ch11fig2),
    we have a 128-word alignment restriction that gets in the way. We’ll need to step
    the table in chunks, then trigger individual interrupts to extract words from
    the table.
  prefs: []
  type: TYPE_NORMAL
- en: This alignment rule means that while we can slide the VTOR, we’ll have gaps
    for our forbidden exceptions, with seven words missing from every table! Schink
    found that while you do need to be aligned to the table size for proper operation,
    the table sort of wraps around if the table is aligned to half of its size and
    you trigger an interrupt that is after the end.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0113-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: VTOR from STMicro (2005)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0113-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Relocation of the IVT'
  prefs: []
  type: TYPE_NORMAL
- en: 'So in an STM32F103 with 64 entries in its IVT, the table begins at `0x08000000`
    and we can officially use the VTOR to relocate it to aligned addresses: `0x08000100`,
    `0x08000200`, `0x0800-0300`, and so on. At these offsets, we are unable to read
    the seven words at offsets `0x00`, `0x04`, `0x1C`, `0x20`, `0x24`, `0x28`, and
    `0x34` because those interrupts are forbidden or impossible to trigger. But by
    setting the table to 32-word alignment at `0x08000080`, `0x08000180`, `0x08000280`,
    and so on, we can use the table wraparound to fill in the blanks, triggering interrupt
    32 instead of 0 to dump offset `0x00`, or interrupt 39 instead of 7 to dump offset
    `0x1C`. [Figure 11.3](ch11.xhtml#ch11fig3) demonstrates this.'
  prefs: []
  type: TYPE_NORMAL
- en: Using this illegal-offset trick, we still miss seven words from each even 32-word
    block, but we collect all words from the odd 32-word blocks, giving us 89% coverage
    of the firmware on the STM32F103\. Because we only miss words on the even blocks,
    our coverage is better in chips with larger interrupt tables.
  prefs: []
  type: TYPE_NORMAL
- en: '**Triggering Interrupts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve covered the theory of Schink’s exploit, let’s cover some of the
    practical details behind triggering specific interrupts. After connecting to the
    OpenOCD server, his script begins by halting the target and disabling exception
    masking.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0114-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It then writes four half-word instructions to the beginning of SRAM at `0x20000000`,
    for triggering exceptions when they can’t be triggered directly. One is `svc #0`
    to trigger a supervisor call, the second is a `nop`, the third is a load instruction
    used to trigger a bus fault, and the fourth is `0xFFFF`, an illegal instruction.
    Many of these interrupts are disabled by default, so the code must first enable
    the feature and then perform the illegal action.'
  prefs: []
  type: TYPE_NORMAL
- en: Each interrupt is triggered by first sending `reset halt` to OpenOCD, writing
    the VTOR address, and then triggering the individual interrupt by its own unique
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the standard interrupts: Exception 2 is an NMI, triggered by setting
    bit 31 of `ICSR`. Exception 3 is a HardFault, triggered by executing `0xFFFF`
    from SRAM. Exception 4 is a MemFault, triggered by setting a bit of the `SHCSR`
    register and branching to unexecutable I/O memory at `0xe0000000`. Exception 5
    is a BusFault, triggered by setting a different bit of `SHCSR` and branching to
    the `ldr` instruction in SRAM. Exception 6 is a UsageFault, triggered by jumping
    to the illegal instruction in RAM after setting the appropriate bit of `SHCSR`.
    Exception 11 is a Supervisor Call, triggered by executing `svc #0` from SRAM.
    Exception 12 is a DebugMonitor exception, triggered by setting bit 17 of `DEMCR`.
    Exception 14 is a PendSV interrupt, triggered by setting bit 28 of `ICSR`. Exception
    15 is a SysTick interrupt, triggered by setting bit 26 of `ICSR`.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Exception 16 and continuing to the end of the table, we have external
    interrupts. Each of these has an exception number, beginning with 0 for Exception
    16, and each can be triggered by setting the appropriate bit of both `NVIC_ISER0`
    and `NVIC_ISPR0`.
  prefs: []
  type: TYPE_NORMAL
- en: Except where a specific instruction is specified, you’ll probably want to execute
    a `nop` when triggering these interrupts to avoid any unpredictable errors in
    the extraction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Counting the External Interrupts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only one thing is left before the exploit is ready to roll. We desperately need
    to know the size of the interrupt table, in order to know both when to slide it
    to a new position and when we can use the wraparound trick for half-aligned table
    positions.
  prefs: []
  type: TYPE_NORMAL
- en: It would work perfectly well for a demo to simply hard-code the values for a
    few known model numbers, but for the sake of portability, Schink’s exploit instead
    counts the external interrupts by triggering them sequentially until the Program
    Status Register (PSR) fails to indicate the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Counting the interrupts also revealed that for some model numbers, the documentation
    erroneously listed some of these external interrupts as reserved, when in fact
    they functioned just like all the others.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Schink’s paper concludes with a table of STM32F1 chips, along with their external
    interrupt counts, extraction time, and coverage when extracting 128kB of flash
    memory. ([Figures 11.4](ch11.xhtml#ch11fig4) and [11.5](ch11.xhtml#ch11fig5).)
  prefs: []
  type: TYPE_NORMAL
- en: Extraction coverage is strictly limited by the number of interrupts, because
    of those pesky seven that can’t be triggered in an aligned interrupt table.
  prefs: []
  type: TYPE_NORMAL
- en: If it becomes too frustrating to reverse engineer the firmware given only the
    majority of the instructions, it might help to dump multiple versions of your
    target’s firmware. Gaps should appear in different places, allowing the missing
    part of one version to be filled in from another version. (There will of course
    be errors with this technique attributed to differences in source code and object
    size, but quite a few of the words should be correctly extracted.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0117-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Code Coverage from Schink and Obermaier (2020)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0117-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Counting Interrupt Handlers'
  prefs: []
  type: TYPE_NORMAL
- en: Schink used a Segger J-Link debugger at 3,500 kHz, and extraction time might
    be improved by reducing round-trips or increasing the clock rate. This won’t matter
    much for dumping a single device, of course, but it could be critical if you need
    to dump many different chips in order to fill in the coverage gaps with bytes
    from different versions of a product’s firmware.
  prefs: []
  type: TYPE_NORMAL
