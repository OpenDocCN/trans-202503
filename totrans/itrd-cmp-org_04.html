<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_53"/><strong><span class="big">4</span><br/>BOOLEAN ALGEBRA</strong></h2>&#13;
<div class="image1"><img src="../images/pg23_Image_2.jpg" alt="Image" width="191" height="190"/></div>&#13;
<p class="noindentz"><em>Boolean algebra</em> was developed in the 19th century by an English mathematician, George Boole, who was working on ways to use mathematical rigor to solve logic problems. He formalized a mathematical system for manipulating logical values in which the only possible values for the variables are <em>true</em> and <em>false</em>, usually designated <span class="literal">1</span> and <span class="literal">0</span>, respectively.</p>&#13;
<p class="indent">The basic operations in Boolean algebra are <em>conjunction</em> (AND), <em>disjunction</em> (OR), and <em>negation</em> (NOT). This distinguishes it from elementary algebra, which includes the infinite set of real numbers and uses the arithmetic operations addition, subtraction, multiplication, and division. (Exponentiation is a simplified notation for repeated multiplication.)</p>&#13;
<p class="indent">While mathematicians and logicians were expanding the field of Boolean algebra in increasingly complex and abstract ways, engineers were learning to harness electrical flows using switches in circuits to perform logic operations. The two fields developed in parallel until the mid-1930s, when a graduate student named Claude Shannon proved that electrical switches could be used to implement the full range of Boolean algebraic expressions. (When used to describe switching circuits, Boolean algebra is sometimes called <em>switching algebra</em>.) With Shannon’s discovery, a world of possibilities <span epub:type="pagebreak" id="page_54"/>was opened and Boolean algebra became the mathematical foundation of the computer.</p>&#13;
<p class="indent">In this chapter, I’ll start with descriptions of the basic Boolean operators. Then, you’ll learn about their logical rules, which form the basis of Boolean algebra. Next, I’ll explain ways to combine Boolean variables and operators into algebraic expressions to form Boolean logic functions. Finally, I’ll discuss techniques for simplifying Boolean functions. In subsequent chapters, you’ll learn how electronic on/off switches can be used to implement logic functions that can be connected together in logic circuits to perform the primary functions of a computer: arithmetic, logic operations, and memory storage.</p>&#13;
<h3 class="h3" id="ch04lev1sec1"><strong>Basic Boolean Operators</strong></h3>&#13;
<p class="noindent">A Boolean operator acts on a value or pair of values called the <em>operand(s)</em>. There are several symbols used to denote each Boolean operator, which I’ll include in the description of each of the operators. In this book, I’ll present the symbols used by logicians.</p>&#13;
<p class="indent">I’ll use truth tables to show the results of each operation. A <em>truth table</em> shows the results for all possible combinations of the operands. For example, consider the addition of two bits, <em>x</em> and <em>y</em>. There are four possible combinations of the values, one of which is addition, which will give a sum and a possible carry. <a href="ch04.xhtml#ch4tab1">Table 4-1</a> shows how to express this in a truth table.</p>&#13;
<p class="tabcap" id="ch4tab1"><strong>Table 4-1:</strong> A Truth Table for Addition of Two Bits</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><em><strong>x</strong></em></th>&#13;
<th class="tab_th"><em><strong>y</strong></em></th>&#13;
<th class="tab_th"><em><strong>Carry</strong></em></th>&#13;
<th class="tab_th"><em><strong>Sum</strong></em></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">0</td>&#13;
<td class="bg1">0</td>&#13;
<td class="bg1">0</td>&#13;
<td class="bg1">0</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">0</td>&#13;
<td class="bg">1</td>&#13;
<td class="bg">0</td>&#13;
<td class="bg">1</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">1</td>&#13;
<td class="bg1">0</td>&#13;
<td class="bg1">0</td>&#13;
<td class="bg1">1</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">1</td>&#13;
<td class="bg">1</td>&#13;
<td class="bg">1</td>&#13;
<td class="bg">0</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">I’ll also provide the electronic circuit representations for <em>gates</em>, which are the electronic devices that implement the Boolean operators. You’ll learn more about these devices in <a href="ch05.xhtml">Chapters 5</a> through <a href="ch08.xhtml">8</a>, where you’ll also see that the real-world behavior of the physical devices varies slightly from the ideal mathematical behavior shown in the truth tables.</p>&#13;
<p class="indent">As with elementary algebra, you can combine these basic operators to define secondary operators. You’ll see an example of this when I define the XOR operator near the end of this chapter. For now, let’s take a look at the basic operators:</p>&#13;
<p class="noindenta"><strong>AND</strong></p>&#13;
<p class="noindentin">AND is a <em>binary operator</em>, meaning it acts on two operands. The result of AND is <span class="literal">1</span> if and only if <em>both</em> operands are <span class="literal">1</span>; otherwise, the result is <span class="literal">0</span>. In logic, this operation is known as <em>conjunction</em>. I’ll use ∧ to designate the AND operation. It’s also common to use the <em>·</em> symbol or simply AND.<span epub:type="pagebreak" id="page_55"/></p>&#13;
<p class="noindentin"><a href="ch04.xhtml#ch4fig1">Figure 4-1</a> shows the circuit symbol for an AND gate and a truth table defining the output, with operands <em>x</em> and <em>y</em>.</p>&#13;
<div class="image"><img id="ch4fig1" src="../images/pg83_Image_51.jpg" alt="Image" width="392" height="127"/></div>&#13;
<p class="figcap"><em>Figure 4-1: An AND gate acting on two variables,</em> x <em>and</em> y</p>&#13;
<p class="indent1">As you can see in the truth table, the AND operator has properties similar to multiplication in elementary algebra, which is why some use the <em>·</em> symbol to represent it.</p>&#13;
<p class="noindenta"><strong>OR</strong></p>&#13;
<p class="noindentin">OR is also a binary operator. The result of OR is <span class="literal">1</span> if at least one of the operands is <span class="literal">1</span>; otherwise, the result is <span class="literal">0</span>. In logic, this operation is known as <em>disjunction</em>. I’ll use ∨ to designate the OR operation. It’s also common to use the + symbol or simply OR. <a href="ch04.xhtml#ch4fig2">Figure 4-2</a> shows the circuit symbol for an OR gate and a truth table defining the output, with operands <em>x</em> and <em>y</em>.</p>&#13;
<div class="image"><img id="ch4fig2" src="../images/pg83_Image_52.jpg" alt="Image" width="387" height="127"/></div>&#13;
<p class="figcap"><em>Figure 4-2: An OR gate acting on two variables,</em> x <em>and</em> y</p>&#13;
<p class="indent1">The truth table shows that the OR operator follows rules somewhat similar to addition in elementary algebra, which is why some use the + symbol to represent it.</p>&#13;
<p class="noindenta"><strong>NOT</strong></p>&#13;
<p class="noindentin">NOT is a <em>unary operator</em>, which acts on only one operand. The result of NOT is <span class="literal">1</span> if the operand is <span class="literal">0</span> and <span class="literal">0</span> if the operand is <span class="literal">1</span>. Other names for the NOT operation are <em>complement</em> and <em>invert</em>. I’ll use ¬ to designate the NOT operation. It’s also common to use the <span class="literal">'</span> symbol, an overscore above the variable, or simply NOT. <a href="ch04.xhtml#ch4fig3">Figure 4-3</a> shows the circuit symbol for a NOT gate and a truth table defining the output, with the operand <em>x</em>.</p>&#13;
<div class="image"><img id="ch4fig3" src="../images/pg83_Image_53.jpg" alt="Image" width="343" height="69"/></div>&#13;
<p class="figcap"><em>Figure 4-3: A NOT gate acting on one variable,</em> x</p>&#13;
<p class="indent1">As you’ll see, NOT has some properties of the arithmetic negation used in elementary algebra, but there are some significant differences.<span epub:type="pagebreak" id="page_56"/></p>&#13;
<p class="indent1">It’s no accident that AND is multiplicative and OR is additive. George Boole developed his algebra to apply mathematical rigor to logic and use addition and multiplication to manipulate logical statements. He developed the rules based on using AND for multiplication and OR for addition. In the next section, you’ll learn how to use these operators, together with NOT, to represent logical statements.</p>&#13;
<h3 class="h3" id="ch04lev1sec2"><strong>Boolean Expressions</strong></h3>&#13;
<p class="noindent">Just as you can use elementary algebra operators to combine variables into expressions such as (<em>x</em> + <em>y</em>), you can use Boolean operators to combine variables into expressions.</p>&#13;
<p class="indent">There is a significant difference, though. A Boolean expression is created from values (<span class="literal">0</span> and <span class="literal">1</span>) and literals. In Boolean algebra, a <em>literal</em> is a single instance of a variable or its complement that’s being used in an expression. In the expression</p>&#13;
<div class="image1"><img src="../images/pg84_Image_54.jpg" alt="Image" width="254" height="18"/></div>&#13;
<p class="noindent">there are three variables (<em>x</em>, <em>y</em>, and <em>z</em>) and seven literals. In a Boolean expression, you have a variable in both its complemented form and its uncomplemented form, because each form is a separate literal.</p>&#13;
<p class="indent">We can combine literals using either the ∧ or the ∨ operator. Like in elementary algebra, Boolean algebra expressions are made up of <em>terms</em>—groups of literals that are acted upon by operators, such as (<em>x</em> ∨ <em>y</em>) or (<em>a</em> ∧ <em>b</em>)—and <em>operation precedence</em> (or <em>order of operations</em>) specifies how these operators are applied when evaluating an expression. <a href="ch04.xhtml#ch4tab2">Table 4-2</a> lists the precedence rules for the Boolean operators. As with elementary algebra, expressions in parentheses are evaluated first.</p>&#13;
<p class="tabcap" id="ch4tab2"><strong>Table 4-2:</strong> Precedence Rules for Boolean Algebra Operators</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Operation</strong></th>&#13;
<th class="tab_th"><strong>Notation</strong></th>&#13;
<th class="tab_th"><strong>Precedence</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">NOT</td>&#13;
<td class="bg1">¬<em>x</em></td>&#13;
<td class="bg1">Highest</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">AND</td>&#13;
<td class="bg"><em>x</em> ∧ <em>y</em></td>&#13;
<td class="bg">Middle</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">OR</td>&#13;
<td class="bg1"><em>x</em> ∨ <em>y</em></td>&#13;
<td class="bg1">Lowest</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Now that you know how the three fundamental Boolean operators work, we’ll look at some of the rules they obey when used in algebraic expressions. As you’ll see later in the chapter, we can use the rules to simplify Boolean expressions, which will allow us to simplify the way we implement those expressions in the hardware.</p>&#13;
<p class="indent">Knowing how to simplify Boolean expressions is an important tool for both those making hardware and those writing software. A computer is just a physical manifestation of Boolean logic. Even if your only interest is in programming, every programming statement you write is ultimately carried out <span epub:type="pagebreak" id="page_57"/>by hardware that is completely described by the system of Boolean algebra. Our programming languages tend to hide much of this through abstraction, but they still use Boolean expressions to implement programming logic.</p>&#13;
<h3 class="h3" id="ch04lev1sec3"><strong>Boolean Algebra Rules</strong></h3>&#13;
<p class="noindent">When comparing AND and OR in Boolean algebra to multiplication and addition in elementary algebra, you’ll find that some of the rules of Boolean algebra are familiar but others are significantly different.</p>&#13;
<h4 class="h4" id="ch04lev2sec1"><em><strong>Rules That Are the Same as Elementary Algebra</strong></em></h4>&#13;
<p class="noindent">Let’s start with the rules that are the same; in the next section, we’ll look at the ones that differ. These rules are as follows:</p>&#13;
<p class="noindenta"><strong>AND and OR are associative</strong></p>&#13;
<p class="noindentin">We say that an operator is <em>associative</em> if we can change the order of applying two or more occurrences of the operator in an expression without changing the value of the expression. Mathematically:</p>&#13;
<div class="image1"><img src="../images/pg85_Image_55.jpg" alt="Image" width="193" height="52"/></div>&#13;
<p class="indent1">To prove the associative rule for AND and OR, let’s use exhaustive truth tables, as shown in <a href="ch04.xhtml#ch4tab3">Tables 4-3</a> and <a href="ch04.xhtml#ch4tab4">4-4</a>. <a href="ch04.xhtml#ch4tab3">Table 4-3</a> lists all possible values of the variables <em>x</em>, <em>y</em>, and <em>z</em>, as well as the intermediate computations of the terms (<em>y</em> ∧ <em>z</em>) and (<em>x</em> ∧ <em>y</em>). In the last two columns, I compute the values of each expression on both sides of the previous equations, which shows that the two equalities hold.</p>&#13;
<p class="tabcap" id="ch4tab3"><strong>Table 4-3:</strong> The Associativity of the AND Operation</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:16%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><em><strong>x</strong></em></th>&#13;
<th class="tab_th"><em><strong>y</strong></em></th>&#13;
<th class="tab_th"><em><strong>z</strong></em></th>&#13;
<th class="tab_th">(<strong><em>y</em></strong> ∧ <strong><em>z</em></strong>)</th>&#13;
<th class="tab_th">(<strong><em>x</em></strong> ∧ <strong><em>y</em></strong>)</th>&#13;
<th class="tab_th"> <em><strong>x</strong></em> ∧ (<strong><em>y</em></strong> ∧ <em><strong>z</strong></em>)</th>&#13;
<th class="tab_th">(<strong><em>x</em></strong> ∧ <em><strong>y</strong></em>) ∧ <em><strong>z</strong></em></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch04.xhtml#ch4tab4">Table 4-4</a> lists all possible values of the variables <em>x</em>, <em>y</em>, and <em>z</em>, as well as the intermediate computations of the terms (<em>y</em> ∨ <em>z</em>) and (<em>x</em> ∨ <em>y</em>). In the last two columns, I compute the values of each expression on both <span epub:type="pagebreak" id="page_58"/>sides of the previous equations, which again shows that the two equalities hold.</p>&#13;
<p class="tabcap" id="ch4tab4"><strong>Table 4-4:</strong> The Associativity of the OR Operation</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:8%"/>&#13;
<col style="width:16%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:15%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong><em>x</em></strong></th>&#13;
<th class="tab_th"><strong><em>y</em></strong></th>&#13;
<th class="tab_th"><strong><em>z</em></strong></th>&#13;
<th class="tab_th">(<strong><em>y</em></strong> ∨ <em><strong>z</strong></em>)</th>&#13;
<th class="tab_th">(<strong><em>x</em></strong> ∨ <em><strong>y</strong></em>)</th>&#13;
<th class="tab_th"> <em><strong>x</strong></em> ∨ (<strong><em>y</em></strong> ∨ <em><strong>z</strong></em>)</th>&#13;
<th class="tab_th">(<strong><em>x</em></strong> ∨ <em><strong>y</strong></em>) ∨ <em><strong>z</strong></em></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">This strategy works for each of the rules shown in this section, but I’ll only go through the truth table for the associative rule here. You’ll get to do this for the other rules in “Your Turn” <a href="ch04.xhtml#ch4exe1">exercise 4.1</a> on <a href="ch04.xhtml#ch4you1">page 61</a>.</p>&#13;
<p class="noindenta"><strong>AND and OR have identity values</strong></p>&#13;
<p class="noindentin">An <em>identity value</em> is a value specific to an operation, such that using that operation on a quantity with the identity value yields the value of the original quantity. For AND and OR, the identity values are <span class="literal">1</span> and <span class="literal">0</span>, respectively:</p>&#13;
<div class="image1"><img src="../images/pg86_Image_56.jpg" alt="Image" width="75" height="47"/></div>&#13;
<p class="noindenta"><strong>AND and OR are commutative</strong></p>&#13;
<p class="noindentin">We can say that an operator is <em>commutative</em> if we can reverse the order of its operands without changing the result of the operation:</p>&#13;
<div class="image1"><img src="../images/pg86_Image_57.jpg" alt="Image" width="107" height="53"/></div>&#13;
<p class="noindenta"><strong>AND is distributive over OR</strong></p>&#13;
<p class="noindentin">The AND operator applied to quantities OR-ed together can be <em>distributed</em> to apply to each of the OR-ed quantities:</p>&#13;
<div class="image1"><img src="../images/pg86_Image_58.jpg" alt="Image" width="239" height="21"/></div>&#13;
<p class="indent1">Unlike in elementary algebra, the additive OR <em>is</em> distributive over the multiplicative AND. You’ll see this in the next section.</p>&#13;
<p class="noindenta"><strong>AND has an annulment (also called annihilation) value</strong></p>&#13;
<p class="noindentin">An <em>annulment value</em> is a value such that operating on a quantity with the annulment value yields the annulment value. The annulment value for AND is <span class="literal">0</span>:</p>&#13;
<div class="image1"><img src="../images/pg86_Image_59.jpg" alt="Image" width="77" height="15"/></div>&#13;
<span epub:type="pagebreak" id="page_59"/>&#13;
<p class="indent1">We’re used to 0 being the annulment value for multiplication in elementary algebra, but addition has no concept of annulment. You’ll learn about the annulment value for OR in the next section.</p>&#13;
<p class="noindenta"><strong>NOT shows involution</strong></p>&#13;
<p class="noindentin">An operator shows <em>involution</em> if applying it to a quantity twice yields the original quantity:</p>&#13;
<div class="image1"><img src="../images/pg87_Image_60.jpg" alt="Image" width="82" height="20"/></div>&#13;
<p class="indent1">Involution is simply the application of a double complement: NOT(NOT true) = true. This is similar to double negation in elementary algebra.</p>&#13;
<h4 class="h4" id="ch04lev2sec2"><em><strong>Rules That Differ from Elementary Algebra</strong></em></h4>&#13;
<p class="noindent">Although AND is multiplicative and OR is additive, there are significant differences between these logical operations and the arithmetic ones. The differences stem from the fact that Boolean algebra deals with logic expressions that evaluate to either true or false, while elementary algebra deals with the infinite set of real numbers. In this section, you’ll see expressions that might remind you of elementary algebra, but the Boolean algebra rules are different. Those rules are:</p>&#13;
<p class="noindenta"><strong>OR is distributive over AND</strong></p>&#13;
<p class="noindentin">The OR operator applied to quantities AND-ed together can be distributed to apply to each of the AND-ed quantities:</p>&#13;
<div class="image1"><img src="../images/pg87_Image_61.jpg" alt="Image" width="239" height="49"/></div>&#13;
<p class="indent1">Because addition is not distributive over multiplication in elementary algebra, you might overlook this way of manipulating Boolean expressions.</p>&#13;
<p class="indent1">First, let’s look at elementary algebra. Using addition for OR and multiplication for AND in the previous equation, we have:</p>&#13;
<div class="image1"><img src="../images/pg87_Image_62.jpg" alt="Image" width="211" height="21"/></div>&#13;
<p class="noindentin">When we plug in the numbers <em>x</em> = 1, <em>y</em> = 2, and <em>z</em> = 3, the left-hand side gives</p>&#13;
<p class="center">1 + (2 · 3) = 7</p>&#13;
<p class="noindentin">and the right-hand side gives:</p>&#13;
<p class="center">(1 + 2) · (1 + 3) = 12</p>&#13;
<p class="indent1">Thus, addition is <em>not</em> distributive over multiplication in elementary algebra.</p>&#13;
<span epub:type="pagebreak" id="page_60"/>&#13;
<p class="indent">The best way to show that OR is distributive over AND in Boolean algebra is to use a truth table, as shown in <a href="ch04.xhtml#ch4tab5">Table 4-5</a>.</p>&#13;
<p class="tabcap" id="ch4tab5"><strong>Table 4-5:</strong> OR Distributes over AND</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong><em>x</em></strong></th>&#13;
<th class="tab_th"><strong><em>y</em></strong></th>&#13;
<th class="tab_th"><strong><em>z</em></strong></th>&#13;
<th class="tab_th"><em><strong>x</strong></em> ∨ (<strong><em>y</em></strong> ∧ <em><strong>z</strong></em>)</th>&#13;
<th class="tab_th">(<strong><em>x</em></strong> ∨ <em><strong>y</strong></em>) ∧ (<strong><em>x</em></strong> ∨ <em><strong>z</strong></em>)</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Comparing the two right-hand columns, you can tell that OR-ing the variable, <em>x</em>, with each of the two AND-ed variables, <em>y</em> and <em>z</em>, gives the same result as OR-ing it with each of the variables and AND-ing the two OR-ed terms. Thus, the distributive property holds.</p>&#13;
<p class="noindenta"><strong>OR has an annulment (also called annihilation) value</strong></p>&#13;
<p class="noindentina">There is no annulment value for addition in elementary algebra, but in Boolean algebra, the annulment value for OR is <span class="literal">1</span>:</p>&#13;
<div class="image1"><img src="../images/pg88_Image_63.jpg" alt="Image" width="75" height="16"/></div>&#13;
<p class="noindenta"><strong>AND and OR both have a complement value</strong></p>&#13;
<p class="noindentina">The <em>complement value</em> is the diminished radix complement of the variable. You learned in <a href="ch03.xhtml">Chapter 3</a> that the sum of a quantity and that quantity’s diminished radix complement is equal to (<em>radix</em> – 1). Since the radix in Boolean algebra is 2, the complement of <span class="literal">0</span> is <span class="literal">1</span> and the complement of <span class="literal">1</span> is <span class="literal">0</span>. So, the complement of a Boolean quantity is simply the NOT of that quantity, which gives:</p>&#13;
<div class="image1"><img src="../images/pg88_Image_64.jpg" alt="Image" width="91" height="48"/></div>&#13;
<p class="indent1">The complement value illustrates one of the differences between the AND and OR logical operations and the multiplication and addition arithmetic operations. In elementary algebra:</p>&#13;
<div class="image1"><img src="../images/pg88_Image_65.jpg" alt="Image" width="113" height="55"/></div>&#13;
<p class="indent1">Even if we restrict <em>x</em> to be 0 or 1, in elementary algebra 1 · (–1) = –1 and 1 + (–1) = 0.</p>&#13;
<span epub:type="pagebreak" id="page_61"/>&#13;
<p class="noindenta"><strong>AND and OR are idempotent</strong></p>&#13;
<p class="noindentina">If an operator is <em>idempotent</em>, applying it to two of the same operands results in that operand. In other words:</p>&#13;
<div class="image1"><img src="../images/pg89_Image_66.jpg" alt="Image" width="73" height="46"/></div>&#13;
<p class="indent1">This looks different than in elementary algebra, where repeatedly multiplying a number by itself is exponentiation and repeatedly adding a number to itself is equivalent to multiplication.</p>&#13;
<p class="noindenta"><strong>De Morgan’s law applies</strong></p>&#13;
<p class="noindentina">In Boolean algebra, the special relationship between the AND and OR operations is captured by <em>De Morgan’s law</em>, which states:</p>&#13;
<div class="image1"><img src="../images/pg89_Image_67.jpg" alt="Image" width="157" height="52"/></div>&#13;
<p class="indent1">The first equation states that the NOT of the AND of two Boolean quantities is equal to the OR of the NOT of the two quantities. The second equation states that the NOT of the OR of two Boolean quantities is equal to the AND of the NOT of the two quantities.</p>&#13;
<p class="indent1">This relationship is an example of the <em>principle of duality</em>, which in Boolean algebra states that if you replace every <span class="literal">0</span> with a <span class="literal">1</span>, every <span class="literal">1</span> with a <span class="literal">0</span>, every AND with an OR, and every OR with an AND, the equation is still true. Look back over the rules just given and you’ll see that all of them except involution have dual operations. De Morgan’s law is one of the best examples of duality; you’ll see this principle in play when you complete “Your Turn” <a href="ch04.xhtml#ch4exe2">exercise 4.2</a>.</p>&#13;
<div class="box">&#13;
<p class="box-title" id="ch4you1"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch4exe1">4.1     Use truth tables to prove the Boolean algebra rules given in this section.</p>&#13;
<p class="box-list" id="ch4exe2">4.2     Prove De Morgan’s law.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev1sec4"><strong>Boolean Functions</strong></h3>&#13;
<p class="noindent">The functionality of a computer is based on Boolean logic, which means the various operations of a computer are specified by Boolean functions. A Boolean function looks somewhat like a function in elementary algebra, but the variables can appear in either uncomplemented or complemented form. The variables and constants are connected by Boolean operators. A Boolean function evaluates to either <span class="literal">1</span> or <span class="literal">0</span> (true or false).</p>&#13;
<p class="indent">When we discussed addition in the binary number system on <a href="ch03.xhtml#page_41">page 41</a> in <a href="ch03.xhtml">Chapter 3</a>, you saw that when adding two bits, <em>x</em> and <em>y</em>, we have to include <span epub:type="pagebreak" id="page_62"/>a possible carry into their bit position in the computation. The conditions that cause the carry out from the bit position to be <span class="literal">1</span> are:</p>&#13;
<p class="indent1a">there’s no carry into the current bit position, <em>x</em> = <span class="literal">1</span>, and <em>y</em> = <span class="literal">1</span>, or</p>&#13;
<p class="indent1">there’s a carry into the current bit position, <em>x</em> = <span class="literal">0</span>, and <em>y</em> = <span class="literal">1</span>, or</p>&#13;
<p class="indent1">there’s a carry into the current bit position, <em>x</em> = <span class="literal">1</span>, and <em>y</em> = <span class="literal">0</span>, or</p>&#13;
<p class="indent1">there’s a carry into the current bit position, <em>x</em> = <span class="literal">1</span>, and <em>y</em> = <span class="literal">1</span>.</p>&#13;
<p class="indent1">We can express this more concisely with the Boolean function</p>&#13;
<div class="image1"><img src="../images/pg90_Image_68.jpg" alt="Image" width="642" height="21"/></div>&#13;
<p class="noindent">where <em>x</em> is one bit, <em>y</em> is the other bit, <em>c<sub>in</sub></em> is the carry in from the next lower-order bit position, and <em>C<sub>out</sub></em>(<em>c<sub>in</sub></em>, <em>x</em>, <em>y</em>) is the carry resulting from the addition in the current bit position. We’ll use this equation throughout this section, but first, let’s think a bit about the differences between Boolean and elementary functions.</p>&#13;
<p class="indent">Like an elementary algebra function, a Boolean algebra function can be manipulated mathematically, but the mathematical operations are different. Operations in elementary algebra are performed on the infinite set of real numbers, but Boolean functions work on only two possible values, <span class="literal">0</span> or <span class="literal">1</span>. Elementary algebra functions can evaluate to any real number, but Boolean functions can evaluate only to <span class="literal">0</span> or <span class="literal">1</span>.</p>&#13;
<p class="indent">This difference means we have to think differently about Boolean functions. For example, look at this elementary algebra function:</p>&#13;
<div class="image1"><img src="../images/pg90_Image_69.jpg" alt="Image" width="138" height="26"/></div>&#13;
<p class="noindent">You probably read it as “if I multiply the value of <em>x</em> by the negative of the value of <em>y</em>, I’ll get the value of <em>F</em>(<em>x</em>, <em>y</em>).” However, with the Boolean function</p>&#13;
<div class="image1"><img src="../images/pg90_Image_70.jpg" alt="Image" width="143" height="21"/></div>&#13;
<p class="noindent">there are only four possibilities. If <em>x</em> = 1 and <em>y</em> = 0, then <em>F</em>(<em>x</em>, <em>y</em>) = <span class="literal">1</span>; for the other three possibilities, <em>F</em>(<em>x</em>, <em>y</em>) = <span class="literal">0</span>. Whereas you can plug any numbers into an elementary algebra function, a Boolean algebra function shows you what the values of the variables are that cause the function to evaluate to <span class="literal">1</span>. I think of elementary algebra functions as <em>asking</em> me to plug in values for the variables for evaluation, while Boolean algebra functions <em>tell</em> me what values of the variables cause the function to evaluate to <span class="literal">1</span>.</p>&#13;
<p class="indent">There are simpler ways to express the conditions for carry, and those simplifications lead to being able to implement a Boolean function for carry with fewer logic gates, thus lowering the cost and power usage. In this and the following sections, you’ll learn how the mathematical nature of Boolean algebra makes function simplification easier and more concise.</p>&#13;
<h4 class="h4" id="ch04lev2sec3"><em><strong>Canonical Sum or Sum of Minterms</strong></em></h4>&#13;
<p class="noindent">A <em>canonical form</em> of a Boolean function explicitly shows whether each variable in the problem is complemented or not in each term that defines the <span epub:type="pagebreak" id="page_63"/>function, just as we did with our plain-language statement of the conditions that produce a carry of <span class="literal">1</span> earlier. This ensures that you have taken all possible combinations into account in the function definition.</p>&#13;
<p class="indent">We’ll use the equation for carry on <a href="ch04.xhtml#page_62">page 62</a> to illustrate these concepts. Although the parentheses in the equation are not required, I’ve added them to help you see the form of the equation. The parentheses show four <em>product terms</em>, which are terms where all the literals are operated on only by AND. The four product terms are then OR-ed together. Since the OR operation is like addition, the right-hand side is called a <em>sum of products</em>. It’s also said to be in <em>disjunctive normal form</em>.</p>&#13;
<p class="indent">Let’s look more closely at the product terms. Each of them includes all the variables in this equation in the form of a literal (uncomplemented or complemented). An equation that has <em>n</em> variables has 2<em><sup>n</sup></em> permutations of the values for the variables; a <em>minterm</em> is a product term that specifies exactly one of the permutations. Since there are four combinations of values for <em>c<sub>in</sub></em>, <em>x</em>, and <em>y</em> that produce a carry of <span class="literal">1</span>, the previous equation has four of the possible eight minterms. A Boolean function that is defined by summing (ORing) all the minterms that evaluate to <span class="literal">1</span> is said to be a <em>canonical sum</em>, a <em>sum of minterms</em>, or in <em>full disjunctive normal form</em>. A function defined by a sum of minterms evaluates to <span class="literal">1</span> when at least one of the minterms evaluates to <span class="literal">1</span>.</p>&#13;
<p class="indent">For every minterm, exactly one set of values for the variables makes the minterm evaluate to <span class="literal">1</span>. For example, the minterm (<em>c<sub>in</sub></em> ∧ <em>x</em> ∧ ¬<em>y</em>) in the previous equation evaluates to <span class="literal">1</span> only when <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">1</span>, <em>y</em> = <span class="literal">0</span>. A product term that does not contain all the variables in the problem, in either uncomplemented or complemented form, will always evaluate to <span class="literal">1</span> for more sets of values for the variables than a minterm. For example, (<em>c<sub>in</sub></em> ∧ <em>x</em>) evaluates to <span class="literal">1</span> for <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">1</span>, <em>y</em> = <span class="literal">0</span> and for <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">1</span>, <em>y</em> = <span class="literal">1</span>. (We call them <em>min</em>terms because they minimize the number of cases that evaluate to <span class="literal">1</span>.)</p>&#13;
<p class="indent">Rather than write out all the literals in a function, logic designers commonly use the notation <em>m<sub>i</sub></em> to specify the <em>i</em>th minterm, where <em>i</em> is the integer represented by the values of the literals in the problem if the values are placed in order and treated as binary numbers. For example, <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">1</span>, <em>y</em> = <span class="literal">0</span> gives <span class="literal">110</span>, which is the (base 10) number 6; thus, that minterm is <em>m</em><sub>6</sub>.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4tab6">Table 4-6</a> shows all eight possible minterms for the three-variable function that specifies carry.</p>&#13;
<p class="tabcap" id="ch4tab6"><strong>Table 4-6:</strong> The Conditions That Cause Carry to Be <span class="literal">1</span></p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong><em>c</em></strong><em><strong><sub>in</sub></strong></em></th>&#13;
<th class="tab_th"><strong><em>x</em></strong></th>&#13;
<th class="tab_th"><strong><em>y</em></strong></th>&#13;
<th class="tab_th">Minterm</th>&#13;
<th class="tab_th"><em><strong>C</strong><strong><sub>out</sub></strong></em>(<strong><em>c</em></strong><em><strong><sub>in</sub></strong></em><strong><em>, x, y</em></strong>)</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>m</em><sub>0</sub>     (¬<em>c<sub>in</sub></em> ∧ ¬<em>x</em> ∧ ¬<em>y</em>)</td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>m</em><sub>1</sub>     (¬<em>c<sub>in</sub></em> ∧ ¬<em>x</em> ∧ <em>y</em>)</td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>m</em><sub>2</sub>     (¬<em>c<sub>in</sub></em> ∧ <em>x</em> ∧ ¬<em>y</em>)</td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>m</em><sub>3</sub>     (¬<em>c<sub>in</sub></em> ∧ <em>x</em> ∧ <em>y</em>)</td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>m</em><sub>4</sub>     (<em>c<sub>in</sub></em> ∧ ¬<em>x</em> ∧ ¬<em>y</em>)</td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>m</em><sub>5</sub>     (<em>c<sub>in</sub></em> ∧ ¬<em>x</em> ∧ <em>y</em>)</td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>m</em><sub>6</sub>     (<em>c<sub>in</sub></em> ∧ <em>x</em> ∧ ¬<em>y</em>)</td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>m</em><sub>7</sub>     (<em>c<sub>in</sub></em> ∧ <em>x</em> ∧ y)</td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<span epub:type="pagebreak" id="page_64"/>&#13;
<p class="indent">The <em>C<sub>out</sub></em>(<em>c<sub>in</sub></em>, <em>x</em>, <em>y</em>) column shows which minterms in our equation cause it to evaluate to <span class="literal">1</span>.</p>&#13;
<p class="indent">Using this notation to write a Boolean equation as a canonical sum and using the ∑ symbol to denote summation, we can restate the function for carry as:</p>&#13;
<div class="image1"><img src="../images/pg92_Image_71.jpg" alt="Image" width="667" height="99"/></div>&#13;
<p class="indent">We are looking at a simple example here. For more complicated functions, writing out all the minterms is error-prone. The simplified notation is easier to work with and helps avoid making errors.</p>&#13;
<h4 class="h4" id="ch04lev2sec4"><em><strong>Canonical Product or Product of Maxterms</strong></em></h4>&#13;
<p class="noindent">Depending on factors like available components and personal choice, a designer may prefer to work with the cases where a function evaluates to <span class="literal">0</span> instead of <span class="literal">1</span>. In our example, that means a design that specifies when the complement of carry is <span class="literal">0</span>. To see how this works, let’s take the complement of both sides of the equation for specifying carry, using De Morgan’s law:</p>&#13;
<div class="image1"><img src="../images/pg92_Image_72.jpg" alt="Image" width="693" height="21"/></div>&#13;
<p class="indent">Because we complemented both sides of the equation, we now have the Boolean equation for ¬<em>C<sub>out</sub></em>, the complement of carry. Thus, we are looking for conditions that cause ¬<em>C<sub>out</sub></em> to evaluate to <span class="literal">0</span>, not <span class="literal">1</span>. In this equation, the parentheses are required due to the precedence rules of Boolean operators. The parentheses show four <em>sum terms</em>, which are terms where all the literals are operated on only by OR. The four sum terms are then AND-ed together. Since the AND operation is like multiplication, the right-hand side is called a <em>product of sums</em>. It’s also said to be in <em>conjunctive normal form</em>.</p>&#13;
<p class="indent">Each of the sum terms includes all the variables in this equation in the form of literals (uncomplemented or complemented). Whereas a minterm was a <em>product</em> term that specified a single permutation of the 2<em><sup>n</sup></em> permutations of possible values for the variables, a <em>maxterm</em> is a <em>sum</em> term specifying exactly one of those permutations. A Boolean function that is defined by multiplying (AND-ing) all the maxterms that evaluate to <span class="literal">0</span> is said to be a <em>canonical product</em>, a <em>product of maxterms</em>, or in <em>full conjunctive normal form</em>.</p>&#13;
<p class="indent">Each maxterm identifies exactly one set of values for the variables in a function that cause the term to evaluate to <span class="literal">0</span> when OR-ed together. For example, the maxterm (¬<em>c<sub>in</sub></em> ∨ ¬<em>x</em> ∨ <em>y</em>) in the previous equation evaluates to <span class="literal">0</span> only when <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">1</span>, <em>y</em> = <span class="literal">0</span>. But a sum term that does not contain all the variables in the problem, in either uncomplemented or complemented form, will always evaluate to <span class="literal">0</span> for more than one set of values. For example, the sum term (¬<em>c<sub>in</sub></em> ∨ ¬<em>x</em>) evaluates to <span class="literal">0</span> for two sets of values for the three variables in this example, <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">1</span>, <em>y</em> = <span class="literal">0</span> and <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">1</span>, and <em>y</em> = <span class="literal">1</span>. (We call them <em>max</em>terms because they minimize the number of cases that evaluate to <span class="literal">0</span> and thus <em>maximize</em> the number of cases that evaluate to <span class="literal">1</span>.)</p>&#13;
<span epub:type="pagebreak" id="page_65"/>&#13;
<p class="indent">Rather than write out all the literals in a function, logic designers commonly use the notation <em>M<sub>i</sub></em> to specify the <em>i</em>th maxterm, where <em>i</em> is the integer value of the base 2 number created by concatenating the values of the literals in the problem. For example, stringing together <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">1</span>, <em>y</em> = <span class="literal">0</span> gives <span class="literal">110</span>, which is the maxterm <em>M</em><sub>6</sub>. The truth table in <a href="ch04.xhtml#ch4tab7">Table 4-7</a> shows the maxterms that cause the carry to be <span class="literal">0</span>. Notice that maxterm <em>M</em><sub>6</sub> = (¬<em>c<sub>in</sub></em> ∨ ¬<em>x</em> ∨ <em>y</em>) evaluates to <span class="literal">0</span> when <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">1</span>, and <em>y</em> = <span class="literal">0</span>.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4tab7">Table 4-7</a> shows all eight possible maxterms for the three-variable function that specifies the complement of carry.</p>&#13;
<p class="tabcap" id="ch4tab7"><strong>Table 4-7:</strong> The Conditions That Cause the Complement of Carry to Be <span class="literal">0</span></p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong><em>c</em></strong><em><strong><sub>in</sub></strong></em></th>&#13;
<th class="tab_th"><strong><em>x</em></strong></th>&#13;
<th class="tab_th"><strong><em>y</em></strong></th>&#13;
<th class="tab_th">Maxterm</th>&#13;
<th class="tab_th"><strong>¬</strong><strong><em>C</em></strong><em><strong><sub>out</sub></strong></em>(<strong><em>c</em></strong><em><strong><sub>in</sub></strong></em><strong><em>, x, y</em></strong>)</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>M</em><sub>0</sub>     (<em>c<sub>in</sub></em> ∨ <em>x</em> ∨ <em>y</em>)</td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>M</em><sub>1</sub>     (<em>c<sub>in</sub></em> ∨ <em>x</em> ∨ ¬<em>y</em>)</td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>M</em><sub>2</sub>     (<em>c<sub>in</sub></em> ∨ ¬<em>x</em> ∨ <em>y</em>)</td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>M</em><sub>3</sub>     (<em>c<sub>in</sub></em> ∨ ¬<em>x</em> ∨ ¬<em>y</em>)</td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>M</em><sub>4</sub>     (¬<em>c<sub>in</sub></em> ∨ <em>x</em> ∨ <em>y</em>)</td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>M</em><sub>5</sub>     (¬<em>c<sub>in</sub></em> ∨ <em>x</em> ∨ ¬<em>y</em>)</td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>M</em><sub>6</sub>     (¬<em>c<sub>in</sub></em> ∨ ¬<em>x</em> ∨ <em>y</em>)</td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>M</em><sub>7</sub>     (¬<em>c<sub>in</sub></em> ∨ ¬<em>x</em> ∨ ¬<em>y</em>)</td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The ¬<em>C<sub>out</sub></em>(<em>c<sub>in</sub></em>, <em>x</em>, <em>y</em>) column shows which maxterms in our equation cause it to evaluate to <span class="literal">0</span>.</p>&#13;
<p class="indent">Using this notation to write a Boolean equation as a canonical product and using the ∏ symbol to denote multiplication, we can restate the function for the complement of carry as:</p>&#13;
<div class="image1"><img src="../images/pg93_Image_73.jpg" alt="Image" width="738" height="93"/></div>&#13;
<p class="indent">In <a href="ch04.xhtml#ch4tab7">Table 4-7</a>, you’ll see that these are the conditions that cause the complement of carry to be <span class="literal">0</span> and hence the carry to be <span class="literal">1</span>. This shows that using either minterms or maxterms is equivalent.</p>&#13;
<h4 class="h4" id="ch04lev2sec5"><em><strong>Comparison of Canonical Boolean Forms</strong></em></h4>&#13;
<p class="noindent"><a href="ch04.xhtml#ch4tab8">Table 4-8</a> shows all the minterms and maxterms for a three-variable problem. Comparing the corresponding minterms and maxterms reveals the duality of minterms and maxterms: one can be formed from the other using De Morgan’s law by complementing each variable and interchanging OR and AND.</p>&#13;
<span epub:type="pagebreak" id="page_66"/>&#13;
<p class="tabcap" id="ch4tab8"><strong>Table 4-8:</strong> The Canonical Terms for a Three-Variable Problem</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Minterm = <span class="codestrong">1</span></strong></th>&#13;
<th class="tab_th"><strong><em>x</em></strong></th>&#13;
<th class="tab_th"><strong><em>y</em></strong></th>&#13;
<th class="tab_th"><strong><em>z</em></strong></th>&#13;
<th class="tab_th"><strong>Maxterm = <span class="codestrong">0</span></strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><em>m</em><sub>0</sub>     ¬<em>x</em> ∧ ¬<em>y</em> ∧ ¬<em>z</em></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>M</em><sub>0</sub>     <em>x</em> ∨ <em>y</em> ∨ <em>z</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><em>m</em><sub>1</sub>     ¬<em>x</em> ∧ ¬<em>y</em> ∧ <em>z</em></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>M</em><sub>1</sub>     <em>x</em> ∨ <em>y</em> ∨ ¬<em>z</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><em>m</em><sub>2</sub>     ¬<em>x</em> ∧ <em>y</em> ∧ ¬<em>z</em></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>M</em><sub>2</sub>     <em>x</em> ∨ ¬<em>y</em> ∨<em>z</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><em>m</em><sub>3</sub>     ¬<em>x</em> ∧ <em>y</em> ∧ <em>z</em></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>M</em><sub>3</sub>     <em>x</em> ∨ ¬<em>y</em> ∨ ¬<em>z</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><em>m<sub>4</sub></em>     <em>x</em> ∧ ¬<em>y</em> ∧ ¬<em>z</em></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>M</em><sub>4</sub>     ¬<em>x</em> ∨ <em>y</em> ∨ <em>z</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><em>m</em><sub>5</sub>     <em>x</em> ∧ ¬<em>y</em> ∧ <em>z</em></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>M</em><sub>5</sub>     ¬<em>x</em> ∨ <em>y</em> ∨ ¬<em>z</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><em>m</em><sub>6</sub>     <em>x</em> ∧ <em>y</em> ∧ ¬<em>z</em></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><em>M</em><sub>6</sub>     ¬<em>x</em> ∨ ¬<em>y</em> ∨ <em>z</em></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><em>m</em><sub>7</sub>     <em>x</em> ∧ <em>y</em> ∧ <em>z</em></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><em>M</em><sub>7</sub>     ¬<em>x</em> ∨ ¬<em>y</em> ∨ ¬<em>z</em></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The Venn diagrams in <a href="ch04.xhtml#ch4fig4">Figure 4-4</a> provide a pictorial view of the reason we use the terms minterm and maxterm.</p>&#13;
<div class="image"><img id="ch4fig4" src="../images/pg94_Image_74.jpg" alt="Image" width="562" height="217"/></div>&#13;
<p class="figcap"><em>Figure 4-4: The relationships between three variables for a minterm and a maxterm</em></p>&#13;
<p class="indent">The canonical forms give us a complete and unique statement of the function because they take all possible combinations of the variables’ values into account. However, there often are simpler solutions to the problem. The remainder of this chapter will be devoted to methods of simplifying Boolean functions.</p>&#13;
<h3 class="h3" id="ch04lev1sec5"><strong>Boolean Expression Minimization</strong></h3>&#13;
<p class="noindent">When implementing a Boolean function in hardware, each ∧ operator specifies an AND gate, each ∨ operator specifies an OR gate, and each ¬ operator specifies a NOT gate. In general, the complexity of the hardware is related to the number of AND and OR gates used (NOT gates are simple and tend not to contribute significantly to the complexity). Simpler hardware uses fewer components, thus saving cost and space, and uses less power. These savings are especially important with handheld and wearable devices. In this section, you’ll learn how you can manipulate Boolean expressions to reduce the number of AND and OR gates, thus simplifying their hardware implementation.</p>&#13;
<span epub:type="pagebreak" id="page_67"/>&#13;
<h4 class="h4" id="ch04lev2sec6"><em><strong>Minimal Expressions</strong></em></h4>&#13;
<p class="noindent">When simplifying a function, start with one of the canonical forms to ensure you have taken all possible cases into account. To translate a problem into a canonical form, create a truth table that lists all possible combinations of the variables in the problem. From the truth table, it will be easy to list the minterms or maxterms that define the function.</p>&#13;
<p class="indent">Armed with a canonical statement, the next step is to look for a functionally equivalent <em>minimal expression</em>, which is an expression that does the same thing as the canonical one using a minimum number of literals and Boolean operators. To minimize an expression, we apply the rules of Boolean algebra to reduce the number of terms and the number of literals in each term, without changing the logical meaning of the expression.</p>&#13;
<p class="indent">There are two types of minimal expressions, depending on whether you use minterms or maxterms:</p>&#13;
<p class="noindenta"><strong>Minimal sum of products</strong></p>&#13;
<p class="noindentina">When starting with a minterms description of the problem, the minimal expression, known as a <em>minimal sum of products</em>, is a sum of products expression where all other mathematically equivalent sum of products expressions have at least as many product terms and those with the same number of product terms have at least as many literals. As an example of a minimal sum of products, consider these equations:</p>&#13;
<div class="image1"><img src="../images/pg95_Image_75.jpg" alt="Image" width="485" height="115"/></div>&#13;
<p class="indent1"><em>S</em> is in canonical form as each of the product terms explicitly shows the contribution of all three variables. The other three functions are simplifications of <em>S</em>. Although all three have the same number of product terms, <em>S3</em> is a minimal sum of products for <em>S</em> because it has fewer literals in its product terms than <em>S1</em> and <em>S2</em>.</p>&#13;
<p class="noindenta"><strong>Minimal product of sums</strong></p>&#13;
<p class="noindentina">When starting with a maxterms description of the problem, the minimal expression, known as a <em>minimal product of sums</em>, is a product of sums expression where all other mathematically equivalent product of sums expressions have at least as many sum terms and those with the same number of sum terms have at least as many literals. For an example of a minimal product of sums, consider these equations:</p>&#13;
<div class="image1"><img src="../images/pg95_Image_76.jpg" alt="Image" width="461" height="115"/></div>&#13;
<span epub:type="pagebreak" id="page_68"/>&#13;
<p class="indent1"><em>P</em> is in canonical form, and the other three functions are simplifications of <em>P</em>. Although all three have the same number of sum terms as <em>P</em>, <em>P3</em> is a minimal product of sums for <em>P</em> because it has fewer literals in its product terms than <em>P1</em> and <em>P2</em>.</p>&#13;
<p class="indenta">A problem may have more than one minimal solution. Good hardware design typically involves finding several minimal solutions and assessing each one within the context of the available hardware. This means more than using fewer gates; for example, as you’ll learn when we discuss hardware implementation, adding judiciously placed NOT gates can reduce hardware complexity.</p>&#13;
<p class="indent">In the following two sections, you’ll learn two ways to find minimal expressions.</p>&#13;
<h4 class="h4" id="ch04lev2sec7"><em><strong>Minimization Using Algebraic Manipulations</strong></em></h4>&#13;
<p class="noindent">To illustrate the importance of reducing the complexity of a Boolean function, let’s return to the function for carry:</p>&#13;
<div class="image1"><img src="../images/pg96_Image_77.jpg" alt="Image" width="642" height="21"/></div>&#13;
<p class="indent">The expression on the right-hand side of the equation is a sum of minterms. <a href="ch04.xhtml#ch4fig5">Figure 4-5</a> shows the circuit to implement this function. It requires four AND gates and one OR gate. The small circles at the inputs to the AND gates indicate a NOT gate at that input.</p>&#13;
<div class="image"><img id="ch4fig5" src="../images/pg96_Image_78.jpg" alt="Image" width="504" height="232"/></div>&#13;
<p class="figcap"><em>Figure 4-5: A hardware implementation of a function to generate the value of carry when adding two numbers</em></p>&#13;
<p class="indent">Let’s try to simplify the Boolean expression implemented in <a href="ch04.xhtml#ch4fig5">Figure 4-5</a> to see whether we can reduce the hardware requirements. Note that there may not be a single path to a solution, and there may be more than one correct solution. I will present only one way here.</p>&#13;
<p class="indent">First, we’ll do something that might look strange. We’ll use the idempotency rule to duplicate the fourth term twice:</p>&#13;
<div class="image1"><img src="../images/pg96_Image_79.jpg" alt="Image" width="614" height="52"/></div>&#13;
<span epub:type="pagebreak" id="page_69"/>&#13;
<p class="indent">Next, we’ll rearrange the product terms a bit to OR each of the three original terms with (<em>c<sub>in</sub></em> ∧ <em>x</em> ∧ <em>y</em>):</p>&#13;
<div class="image1"><img src="../images/pg97_Image_80.jpg" alt="Image" width="656" height="52"/></div>&#13;
<p class="indent">Now, we can use the rule for distribution of AND over OR to factor out terms that OR to <span class="literal">1</span>:</p>&#13;
<div class="image1"><img src="../images/pg97_Image_81.jpg" alt="Image" width="670" height="83"/></div>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig6">Figure 4-6</a> shows the circuit for this function. Not only have we eliminated an AND gate, but each of the AND gates and the OR gate has one fewer input.</p>&#13;
<div class="image"><img id="ch4fig6" src="../images/pg97_Image_82.jpg" alt="Image" width="505" height="169"/></div>&#13;
<p class="figcap"><em>Figure 4-6: A simplified hardware implementation to generate the value of carry when adding two numbers</em></p>&#13;
<p class="indent">Comparing the circuits in <a href="ch04.xhtml#ch4fig5">Figures 4-5</a> and <a href="ch04.xhtml#ch4fig6">4-6</a>, we can see that Boolean algebra has helped us simplify the hardware implementation. This simplification results from stating the conditions that result in a carry of <span class="literal">1</span> in plain language. The original, canonical form of the equation stated that a carry, <em>C<sub>out</sub></em>(<em>c<sub>in</sub></em>, <em>x</em>, <em>y</em>), will be <span class="literal">1</span> in any of these four cases:</p>&#13;
<p class="indent1a">If <em>c<sub>in</sub></em> = <span class="literal">0</span>, <em>x</em> = <span class="literal">1</span>, and <em>y</em> = <span class="literal">1</span></p>&#13;
<p class="indent1">If <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">0</span>, and <em>y</em> = <span class="literal">1</span></p>&#13;
<p class="indent1">If <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">1</span>, and <em>y</em> = <span class="literal">0</span></p>&#13;
<p class="indent1">If <em>c<sub>in</sub></em> = <span class="literal">1</span>, <em>x</em> = <span class="literal">1</span>, and <em>y</em> = <span class="literal">1</span></p>&#13;
<p class="indenta">The minimization can be stated much more simply: carry is <span class="literal">1</span> if at least two of <em>c<sub>in</sub></em>, <em>x</em>, and <em>y</em> are <span class="literal">1</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>These examples of specifying a logic circuit for carry from addition, and the algorithm for subtraction in <a href="ch03.xhtml">Chapter 3</a>, illustrate one of the more common sources of programming errors. Specifying an activity that seems very simple to us humans in simple logical steps that a computer can execute can be a very tedious, error-prone process.</em></p>&#13;
</div>&#13;
<p class="indent">We arrived at the solution in <a href="ch04.xhtml#ch4fig6">Figure 4-6</a> by starting with the sum of minterms; in other words, we were working with the values of <em>c<sub>in</sub></em>, <em>x</em>, and <em>y</em> that <span epub:type="pagebreak" id="page_70"/>generate a <span class="literal">1</span> for carry. As you saw in the section “Canonical Product or Product of Maxterms” on <a href="ch04.xhtml#ch04lev2sec4">page 64</a>, since carry must be either <span class="literal">1</span> or <span class="literal">0</span>, it’s equally as valid to start with the values of <em>c<sub>in</sub></em>, <em>x</em>, and <em>y</em> that generate a <span class="literal">0</span> for the complement of carry and to write the equation as a product of maxterms:</p>&#13;
<div class="image1"><img src="../images/pg98_Image_83.jpg" alt="Image" width="693" height="21"/></div>&#13;
<p class="indent">To simplify this equation, we’ll take the same approach we took with the sum of minterms and start by duplicating the last term twice to give:</p>&#13;
<div class="image1"><img src="../images/pg98_Image_84.jpg" alt="Image" width="766" height="52"/></div>&#13;
<p class="indent">Adding some parentheses helps to clarify the simplification process:</p>&#13;
<div class="image1"><img src="../images/pg98_Image_85.jpg" alt="Image" width="781" height="52"/></div>&#13;
<p class="indent">Next, we’ll use the distribution of OR over AND. Because this is tricky, I’ll go over the steps to simplify the first grouping of product terms in this equation; the steps for the other two groupings are similar to this one. Distribution of OR over AND has this generic form:</p>&#13;
<div class="image1"><img src="../images/pg98_Image_86.jpg" alt="Image" width="266" height="27"/></div>&#13;
<p class="indent">The sum terms in our first grouping share a (¬<em>x</em> ∨ ¬<em>y</em>), so we’ll make the following substitutions into the generic form:</p>&#13;
<div class="image1"><img src="../images/pg98_Image_87.jpg" alt="Image" width="118" height="81"/></div>&#13;
<p class="indent">Making the substitutions and using the complement rule for AND, we get:</p>&#13;
<div class="image1"><img src="../images/pg98_Image_88.jpg" alt="Image" width="587" height="58"/></div>&#13;
<p class="indent">And applying these same manipulations to the other two groupings, we get:</p>&#13;
<div class="image1"><img src="../images/pg98_Image_89.jpg" alt="Image" width="464" height="21"/></div>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig7">Figure 4-7</a> shows the circuit implementation of this function. This circuit produces the complement of carry. We would need to complement the output, ¬<em>C<sub>out</sub></em>(<em>c<sub>in</sub></em>, <em>x</em>, <em>y</em>), to get the value of carry.</p>&#13;
<span epub:type="pagebreak" id="page_71"/>&#13;
<div class="image"><img id="ch4fig7" src="../images/pg99_Image_90.jpg" alt="Image" width="519" height="168"/></div>&#13;
<p class="figcap"><em>Figure 4-7: A simplified hardware implementation to generate the complement of carry when adding two numbers</em></p>&#13;
<p class="indent">If you compare <a href="ch04.xhtml#ch4fig7">Figures 4-7</a> and <a href="ch04.xhtml#ch4fig6">4-6</a>, you can graphically see De Morgan’s law, where the ORs have become ANDs with complemented values as inputs. The circuit in <a href="ch04.xhtml#ch4fig6">Figure 4-6</a> might look simpler to you because the circuit in <a href="ch04.xhtml#ch4fig7">Figure 4-7</a> requires NOT gates at the six inputs to the OR gates. But as you will learn in the next chapter, this may not be the case because of the inherent electronic properties of the devices used to construct logic gates.</p>&#13;
<p class="indent">The important point to understand here is that there is more than one way to solve the problem. One of the jobs of the hardware engineer is to decide which solution is best, based on elements such as cost, component availability, and so on.</p>&#13;
<h4 class="h4" id="ch04lev2sec8"><em><strong>Minimization Using Karnaugh Maps</strong></em></h4>&#13;
<p class="noindent">The algebraic manipulations used to minimize Boolean functions may not always be obvious. You may find it easier to work with a graphic representation of the logical statements.</p>&#13;
<p class="indent">A commonly used graphic tool for working with Boolean functions is the <em>Karnaugh map</em>, also called a <em>K-map</em>. The Karnaugh map, invented in 1953 by Maurice Karnaugh, a telecommunications engineer at Bell Labs, gives a way to visually find the same simplifications you can find algebraically. It can be used either with a sum of products, using minterms, or with a product of sums, using maxterms. Here, I illustrate how they work, starting with minterms.</p>&#13;
<h5 class="h5" id="ch04lev3sec1"><strong>Simplifying Sums of Products Using Karnaugh Maps</strong></h5>&#13;
<p class="noindent">The Karnaugh map is a rectangular grid with a cell for each minterm. There are 2<em><sup>n</sup></em> cells for <em>n</em> variables. <a href="ch04.xhtml#ch4fig8">Figure 4-8</a> is a Karnaugh map showing all four possible minterms for two variables, <em>x</em> and <em>y</em>. The vertical axis is used to plot <em>x</em> and the horizontal axis is used for <em>y</em>. The value of <em>x</em> for each row is shown by the number (<span class="literal">0</span> or <span class="literal">1</span>) immediately to the left of the row, and the value of <em>y</em> for each column appears at the top of the column.</p>&#13;
<span epub:type="pagebreak" id="page_72"/>&#13;
<div class="image"><img id="ch4fig8" src="../images/pg100_Image_91.jpg" alt="Image" width="191" height="139"/></div>&#13;
<p class="figcap"><em>Figure 4-8: The mapping of two-variable minterms on a Karnaugh map</em></p>&#13;
<p class="indent">To illustrate how to use a Karnaugh map, let’s look at an arbitrary function of two variables:</p>&#13;
<div class="image1"><img src="../images/pg100_Image_92.jpg" alt="Image" width="312" height="21"/></div>&#13;
<p class="indent">Start by placing a <span class="literal">1</span> in each cell corresponding to a minterm that appears in the equation, as shown in <a href="ch04.xhtml#ch4fig9">Figure 4-9</a>.</p>&#13;
<div class="image"><img id="ch4fig9" src="../images/pg100_Image_93.jpg" alt="Image" width="154" height="133"/></div>&#13;
<p class="figcap"><em>Figure 4-9: A Karnaugh map of the arbitrary function</em> F<em>(</em>x, y<em>)</em></p>&#13;
<p class="indent">Placing a <span class="literal">1</span> in the cell corresponding to each minterm that evaluates to <span class="literal">1</span> shows graphically when the equation evaluates to <span class="literal">1</span>. The two cells on the right-hand side correspond to the minterms <em>m</em><sub>1</sub> and <em>m</em><sub>3</sub>, (¬<em>x</em> ∧ <em>y</em>) and (<em>x</em> ∧ <em>y</em>). Since these terms are OR-ed together, <em>F</em>(<em>x</em>, <em>y</em>) evaluates to <span class="literal">1</span> if either of these minterms evaluates to <span class="literal">1</span>. Using the distributive and complement rules, we get the result:</p>&#13;
<div class="image1"><img src="../images/pg100_Image_94.jpg" alt="Image" width="268" height="52"/></div>&#13;
<p class="indent">This shows algebraically that <em>F</em>(<em>x</em>, <em>y</em>) evaluates to <span class="literal">1</span> whenever <em>y</em> is <span class="literal">1</span>, which you’ll see next by simplifying this Karnaugh map.</p>&#13;
<p class="indent">The only difference between the two minterms, (¬<em>x</em> ∧ <em>y</em>) and (<em>x</em> ∧ <em>y</em>), is the change from <em>x</em> to ¬<em>x</em>. Karnaugh maps are arranged such that only one variable changes between two cells that share an edge, a requirement called the <em>adjacency rule</em>.</p>&#13;
<p class="indent">To use a Karnaugh map to perform simplification, you group two adjacent cells in a sum of products Karnaugh map that have <span class="literal">1</span>s in them. Then you eliminate the variable that differs between them and coalesce the two product terms. Repeating this process allows you to simplify the equation. Each grouping eliminates a product term in the final sum of products. This can be extended to equations with more than two variables, but the number of cells that are grouped together must be a multiple of 2, and you can <span epub:type="pagebreak" id="page_73"/>group only adjacent cells. The adjacency wraps around from side to side and from top to bottom. You’ll see an example in <a href="ch04.xhtml#ch4fig18">Figure 4-18</a> on <a href="ch04.xhtml#page_79">page 79</a>.</p>&#13;
<p class="indent">To see how all this works, consider the grouping in the Karnaugh map in <a href="ch04.xhtml#ch4fig10">Figure 4-10</a>.</p>&#13;
<div class="image"><img id="ch4fig10" src="../images/pg101_Image_95.jpg" alt="Image" width="154" height="133"/></div>&#13;
<p class="figcap"><em>Figure 4-10: Two of the minterms in</em> F<em>(</em>x, y<em>) grouped</em></p>&#13;
<p class="indent">This grouping is a graphical representation of the algebraic manipulation we did earlier, where <em>F</em>(<em>x</em>, <em>y</em>) evaluates to <span class="literal">1</span> whenever <em>y</em> = <span class="literal">1</span>, regardless of the value of <em>x</em>. Thus, the grouping coalesces two minterms into one product term by eliminating <em>x</em>.</p>&#13;
<p class="indent">From the last grouping, we know our final simplified function will have a <em>y</em> term. Let’s do another grouping to find the next term. First, we’ll simplify the equation algebraically. Returning to the original equation for <em>F</em>(<em>x</em>, <em>y</em>), we can use idempotency to duplicate one of the minterms:</p>&#13;
<div class="image1"><img src="../images/pg101_Image_96.jpg" alt="Image" width="396" height="24"/></div>&#13;
<p class="indent">Now, we’ll do some algebraic manipulation on the first product term and the one we just added:</p>&#13;
<div class="image1"><img src="../images/pg101_Image_97.jpg" alt="Image" width="272" height="48"/></div>&#13;
<p class="indent">Instead of using algebraic manipulations, we can do this directly on our Karnaugh map, as shown in <a href="ch04.xhtml#ch4fig11">Figure 4-11</a>. This map shows that separate groups can include the same cell (minterm).</p>&#13;
<div class="image"><img id="ch4fig11" src="../images/pg101_Image_98.jpg" alt="Image" width="154" height="133"/></div>&#13;
<p class="figcap"><em>Figure 4-11: A Karnaugh map grouping showing that (</em>x ∧ ¬y<em>)</em> ∨ (¬x ∧ y<em>)</em> ∨ <em>(</em>x ∧ y<em>) =</em> x ∨ y</p>&#13;
<p class="indent">The group in the bottom row represents the product term <em>x</em> and the one in the right-hand column represents <em>y</em>, giving us the following minimization:</p>&#13;
<div class="image1"><img src="../images/pg101_Image_99.jpg" alt="Image" width="115" height="21"/></div>&#13;
<span epub:type="pagebreak" id="page_74"/>&#13;
<p class="indent">Note that the cell that is included in both groupings, (<em>x</em> ∧ <em>y</em>), is the term that we duplicated using the idempotent rule in our algebraic solution previously. You can think of including a cell in more than one group as adding a duplicate copy of the cell, as we did in our algebraic manipulation earlier, and then coalescing it with the other cell(s) in the group, thus removing it.</p>&#13;
<p class="indent">The adjacency rule is automatically satisfied when there are only two variables in the function. When we add another variable, we need to think about how to order the cells of a Karnaugh map such that we can use the adjacency rule to simplify Boolean expressions.</p>&#13;
<h5 class="h5" id="ch04lev3sec2"><strong>Ordering Cells in a Karnaugh Map</strong></h5>&#13;
<p class="noindent">One of the problems with both the binary and binary coded decimal (BCD) codes is that the difference between two adjacent values often involves more than one bit being changed. In 1943, Frank Gray introduced a code, the <em>Gray code</em>, in which adjacent values differ by only one bit. Although encoding values in the Gray code complicates arithmetic operations on the values, it simplifies showing when the values are adjacent to one another, which shows us how to order the cells in a Karnaugh map.</p>&#13;
<p class="indent">Constructing the Gray code is quite easy. Start with one bit:</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Decimal</strong></th>&#13;
<th class="tab_th"><strong>Gray code</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">To add a bit, first write the mirror image of the existing pattern:</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Gray code</strong></th></tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Then, add a <span class="literal">0</span> to the beginning of each of the original bit patterns and add a <span class="literal">1</span> to the beginning of each of the mirror-image set to give the Gray code for two bits, as shown in <a href="ch04.xhtml#ch4tab9">Table 4-9</a>.</p>&#13;
<p class="tabcap" id="ch4tab9"><strong>Table 4-9:</strong> The Gray Code for Two Bits</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Decimal</strong></th>&#13;
<th class="tab_th"><strong>Gray code</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">0</td>&#13;
<td class="bg1"><span class="literal">00</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">1</td>&#13;
<td class="bg"><span class="literal">01</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">2</td>&#13;
<td class="bg1"><span class="literal">11</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">3</td>&#13;
<td class="bg"><span class="literal">10</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<span epub:type="pagebreak" id="page_75"/>&#13;
<p class="indent">This is the reason the Gray code is sometimes called <em>reflected binary code (RBC)</em>. <a href="ch04.xhtml#ch4tab10">Table 4-10</a> shows the Gray code for four bits.</p>&#13;
<p class="tabcap" id="ch4tab10"><strong>Table 4-10:</strong> The Gray Code for Four Bits</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Decimal</strong></th>&#13;
<th class="tab_th"><strong>Gray code</strong></th>&#13;
<th class="tab_th"><strong>Binary</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1">  0</td>&#13;
<td class="bg1"><span class="literal">0000</span></td>&#13;
<td class="bg1"><span class="literal">0000</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">  1</td>&#13;
<td class="bg"><span class="literal">0001</span></td>&#13;
<td class="bg"><span class="literal">0001</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">  2</td>&#13;
<td class="bg1"><span class="literal">0011</span></td>&#13;
<td class="bg1"><span class="literal">0010</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">  3</td>&#13;
<td class="bg"><span class="literal">0010</span></td>&#13;
<td class="bg"><span class="literal">0011</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">  4</td>&#13;
<td class="bg1"><span class="literal">0110</span></td>&#13;
<td class="bg1"><span class="literal">0100</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">  5</td>&#13;
<td class="bg"><span class="literal">0111</span></td>&#13;
<td class="bg"><span class="literal">0101</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">  6</td>&#13;
<td class="bg1"><span class="literal">0101</span></td>&#13;
<td class="bg1"><span class="literal">0110</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">  7</td>&#13;
<td class="bg"><span class="literal">0100</span></td>&#13;
<td class="bg"><span class="literal">0111</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">  8</td>&#13;
<td class="bg1"><span class="literal">1100</span></td>&#13;
<td class="bg1"><span class="literal">1000</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">  9</td>&#13;
<td class="bg"><span class="literal">1101</span></td>&#13;
<td class="bg"><span class="literal">1001</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">10</td>&#13;
<td class="bg1"><span class="literal">1111</span></td>&#13;
<td class="bg1"><span class="literal">1010</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">11</td>&#13;
<td class="bg"><span class="literal">1110</span></td>&#13;
<td class="bg"><span class="literal">1011</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">12</td>&#13;
<td class="bg1"><span class="literal">1010</span></td>&#13;
<td class="bg1"><span class="literal">1100</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">13</td>&#13;
<td class="bg"><span class="literal">1011</span></td>&#13;
<td class="bg"><span class="literal">1101</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1">14</td>&#13;
<td class="bg1"><span class="literal">1001</span></td>&#13;
<td class="bg1"><span class="literal">1110</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg">15</td>&#13;
<td class="bg"><span class="literal">1000</span></td>&#13;
<td class="bg"><span class="literal">1111</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let’s compare the binary codes with the Gray codes for the decimal values 7 and 8 in <a href="ch04.xhtml#ch4tab10">Table 4-10</a>. The binary codes for 7 and 8 are <span class="literal">0111</span> and <span class="literal">1000</span>, respectively; all four bits change when stepping only 1 in decimal value. But the Gray codes for 7 and 8 are <span class="literal">0100</span> and <span class="literal">1100</span>, respectively; only one bit changes, thus satisfying the adjacency rule for a Karnaugh map.</p>&#13;
<p class="indent">Notice that the pattern of changing only one bit between adjacent values also holds when the bit pattern wraps around. That is, when going from the highest value (15 for four bits) to the lowest (0), only one bit is changed.</p>&#13;
<h5 class="h5" id="ch04lev3sec3"><strong>Using a Karnaugh Map for Three Variables</strong></h5>&#13;
<p class="noindent">To see how the adjacency property is important, let’s consider a more complicated function. We’ll use a Karnaugh map to simplify our function for carry, which has three variables. Adding another variable means we need to double the number of cells to hold the minterms. To keep the map two-dimensional, we add the new variable to an existing variable on one side of the map. We need a total of eight cells (2<sup>3</sup>), so we’ll draw it four cells wide and two cells high. We’ll add <em>z</em> to the y-axis and draw our Karnaugh map with <em>y</em> and <em>z</em> on the horizontal axis and <em>x</em> on the vertical axis, as shown in <a href="ch04.xhtml#ch4fig12">Figure 4-12</a>.</p>&#13;
<span epub:type="pagebreak" id="page_76"/>&#13;
<div class="image"><img id="ch4fig12" src="../images/pg104_Image_100.jpg" alt="Image" width="255" height="129"/></div>&#13;
<p class="figcap"><em>Figure 4-12: The mapping of three-variable minterms on a Karnaugh map</em></p>&#13;
<p class="indent">The order of the bit patterns along the top of the three-variable Karnaugh map is <span class="literal">00</span>, <span class="literal">01</span>, <span class="literal">11</span>, <span class="literal">10</span>, as opposed to <span class="literal">00</span>, <span class="literal">01</span>, <span class="literal">10</span>, <span class="literal">11</span>, which is the Gray code order in <a href="ch04.xhtml#ch4tab9">Table 4-9</a>. The adjacency rule also holds when wrapping around the edges of the Karnaugh map—that is, going from <em>m</em><sub>2</sub> to <em>m</em><sub>0</sub> or from <em>m</em><sub>6</sub> to <em>m</em><sub>4</sub>—which means that groups can wrap around the edges of the map. (Other axis labeling schemes will also work, as you’ll see at the end of this section.)</p>&#13;
<p class="indent">You saw earlier in this chapter that carry can be expressed as the sum of four minterms:</p>&#13;
<div class="image1"><img src="../images/pg104_Image_101.jpg" alt="Image" width="642" height="93"/></div>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig13">Figure 4-13</a> shows these four minterms on a Karnaugh map.</p>&#13;
<div class="image"><img id="ch4fig13" src="../images/pg104_Image_102.jpg" alt="Image" width="287" height="150"/></div>&#13;
<p class="figcap"><em>Figure 4-13: A Karnaugh map of the function for carry</em></p>&#13;
<p class="indent">We look for adjacent cells that can be grouped together to eliminate one variable from the product term. As noted, the groups can overlap, giving the three groups shown in <a href="ch04.xhtml#ch4fig14">Figure 4-14</a>.</p>&#13;
<div class="image"><img id="ch4fig14" src="../images/pg104_Image_103.jpg" alt="Image" width="281" height="130"/></div>&#13;
<p class="figcap"><em>Figure 4-14: A minimum sum of products of the function for carry =</em> <span class="codeitalic">1</span></p>&#13;
<p class="indent">Using the three groups in the Karnaugh map in <a href="ch04.xhtml#ch4fig14">Figure 4-14</a>, we end up with the same equation we got through algebraic manipulations:</p>&#13;
<div class="image1"><img src="../images/pg104_Image_104.jpg" alt="Image" width="367" height="21"/></div>&#13;
<span epub:type="pagebreak" id="page_77"/>&#13;
<h5 class="h5" id="ch04lev3sec4"><strong>Simplifying Products of Sums Using Karnaugh Maps</strong></h5>&#13;
<p class="noindent">It’s equally valid to work with a function that shows when the complement of carry is <span class="literal">0</span>. We did that using maxterms:</p>&#13;
<div class="image1"><img src="../images/pg105_Image_105.jpg" alt="Image" width="744" height="94"/></div>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig15">Figure 4-15</a> shows the arrangement of maxterms on a three-variable Karnaugh map.</p>&#13;
<div class="image"><img id="ch4fig15" src="../images/pg105_Image_106.jpg" alt="Image" width="323" height="141"/></div>&#13;
<p class="figcap"><em>Figure 4-15: The mapping of three-variable maxterms on a Karnaugh map</em></p>&#13;
<p class="indent">When working with a maxterm statement of the solution, you mark the cells that evaluate to <span class="literal">0</span>. The minimization process is the same as when working with minterms, except that you group the cells with <span class="literal">0</span>s in them.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig16">Figure 4-16</a> shows a minimization of ¬<em>C<sub>out</sub></em>(<em>c<sub>in</sub></em>, <em>x</em>, <em>y</em>), the complement of carry.</p>&#13;
<div class="image"><img id="ch4fig16" src="../images/pg105_Image_107.jpg" alt="Image" width="273" height="126"/></div>&#13;
<p class="figcap"><em>Figure 4-16: A minimum product of sums of the function for NOT carry =</em> <span class="codeitalic">0</span></p>&#13;
<p class="indent">The Karnaugh map in <a href="ch04.xhtml#ch4fig16">Figure 4-16</a> leads to the same product of sums we got algebraically for the complement of carry = <span class="literal">0</span>:</p>&#13;
<div class="image1"><img src="../images/pg105_Image_108.jpg" alt="Image" width="464" height="21"/></div>&#13;
<p class="indent">Comparing <a href="ch04.xhtml#ch4fig14">Figures 4-14</a> and <a href="ch04.xhtml#ch4fig16">4-16</a> gives a graphic view of De Morgan’s law. When making this comparison, keep in mind that <a href="ch04.xhtml#ch4fig14">Figure 4-14</a> shows the product terms that get added and <a href="ch04.xhtml#ch4fig16">Figure 4-16</a> shows the sum terms that get multiplied, and the result is complemented. Thus, we exchange <span class="literal">0</span> and <span class="literal">1</span> and exchange AND and OR to go from one Karnaugh map to the other.</p>&#13;
<p class="indent">To further emphasize the duality of minterms and maxterms, compare <a href="ch04.xhtml#ch4fig17">Figures 4-17(a)</a> and <a href="ch04.xhtml#ch4fig17">(b)</a>.</p>&#13;
<span epub:type="pagebreak" id="page_78"/>&#13;
<div class="image"><img id="ch4fig17" src="../images/pg106_Image_109.jpg" alt="Image" width="556" height="162"/></div>&#13;
<p class="figcap"><em>Figure 4-17: A comparison of (a) one minterm and (b) one maxterm</em></p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig17">Figure 4-17</a>(a) shows the function:</p>&#13;
<div class="image1"><img src="../images/pg106_Image_110.jpg" alt="Image" width="205" height="21"/></div>&#13;
<p class="noindent">Although it’s not necessary and usually not done, we have placed a <span class="literal">0</span> in each of the cells representing minterms not included in this function.</p>&#13;
<p class="indent">Similarly, in <a href="ch04.xhtml#ch4fig17">Figure 4-17</a>(b), we have placed a <span class="literal">1</span> in each of the cells representing the maxterms that are not included in the function:</p>&#13;
<div class="image1"><img src="../images/pg106_Image_111.jpg" alt="Image" width="175" height="21"/></div>&#13;
<p class="noindent">This comparison shows graphically how a minterm specifies the minimum number of <span class="literal">1</span>s in a Karnaugh map and a maxterm specifies the maximum number of <span class="literal">1</span>s.</p>&#13;
<h5 class="h5" id="ch04lev3sec5"><strong>Exploring Larger Groupings on a Karnaugh Map</strong></h5>&#13;
<p class="noindent">Thus far, we have grouped only two cells together on our Karnaugh maps. Here, I’ll show you an example of larger groups. Consider a function that outputs <span class="literal">1</span> when a 3-bit number is even. <a href="ch04.xhtml#ch4tab11">Table 4-11</a> shows the truth table. It uses <span class="literal">1</span> to indicate that the number is even and uses <span class="literal">0</span> to indicate odd.</p>&#13;
<p class="tabcap" id="ch4tab11"><strong>Table 4-11:</strong> The Even Values of a 3-Bit Number</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:10%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>Minterm</strong></th>&#13;
<th class="tab_th"><em><strong>x</strong></em></th>&#13;
<th class="tab_th"><em><strong>y</strong></em></th>&#13;
<th class="tab_th"><em><strong>z</strong></em></th>&#13;
<th class="tab_th"><strong>Number</strong></th>&#13;
<th class="tab_th"><em><strong>Even</strong></em>(<strong><em>x, y, z</em></strong>)</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><em>m</em><sub>0</sub></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1">0</td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><em>m</em><sub>1</sub></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg">1</td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><em>m</em><sub>2</sub></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1">2</td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><em>m</em><sub>3</sub></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg">3</td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><em>m</em><sub>4</sub></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1">4</td>&#13;
<td class="bg1"><span class="literal">1</span></td></tr>&#13;
<tr>&#13;
<td class="bg"><em>m</em><sub>5</sub></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg">5</td>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><em>m</em><sub>6</sub></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1">6</td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><em>m</em><sub>7</sub></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg">7</td>&#13;
<td class="bg"><span class="literal">0</span>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The canonical sum of products for this function is:</p>&#13;
<div class="image1"><img src="../images/pg106_Image_112.jpg" alt="Image" width="237" height="30"/></div>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig18">Figure 4-18</a> shows these minterms on a Karnaugh map with the four terms grouped together. We can group all four together because they all have adjacent edges.</p>&#13;
<span epub:type="pagebreak" id="page_79"/>&#13;
<div class="image"><img id="ch4fig18" src="../images/pg107_Image_113.jpg" alt="Image" width="284" height="137"/></div>&#13;
<p class="figcap"><em>Figure 4-18: A Karnaugh map showing even values of a 3-bit number</em></p>&#13;
<p class="indent">From the Karnaugh map in <a href="ch04.xhtml#ch4fig18">Figure 4-18</a>, we can write the equation for when a 3-bit number is even:</p>&#13;
<div class="image1"><img src="../images/pg107_Image_114.jpg" alt="Image" width="143" height="21"/></div>&#13;
<p class="indent">The Karnaugh map shows that it does not matter what the values of <em>x</em> and <em>y</em> are, only that <em>z</em> = <span class="literal">0</span>.</p>&#13;
<h5 class="h5" id="ch04lev3sec6"><strong>Adding More Variables to a Karnaugh Map</strong></h5>&#13;
<p class="noindent">Each time you add another variable to a Karnaugh map, you will need to double the number of cells. The only requirement for the Karnaugh map to work is that you arrange the minterms (or maxterms) according to the adjacency rule. <a href="ch04.xhtml#ch4fig19">Figure 4-19</a> shows a four-variable Karnaugh map for minterms. The <em>y</em> and <em>z</em> variables are on the horizontal axis, and <em>w</em> and <em>x</em> are on the vertical axis.</p>&#13;
<div class="image"><img id="ch4fig19" src="../images/pg107_Image_115.jpg" alt="Image" width="279" height="211"/></div>&#13;
<p class="figcap"><em>Figure 4-19: The mapping of four-variable minterms on a Karnaugh map</em></p>&#13;
<p class="indent">So far we have assumed that every minterm (or maxterm) is accounted for in our functions. But design does not take place in a vacuum. We might have knowledge about other components of the overall design telling us that some combinations of variable values can never occur. Next, I’ll show you how to take this knowledge into account in your function simplification process. The Karnaugh map provides an especially clear way to visualize the situation.</p>&#13;
<h5 class="h5" id="ch04lev3sec7"><strong>Using “Don’t Care” Cells</strong></h5>&#13;
<p class="noindent">Sometimes, you have information about the values that the variables can have. If you know which combinations of values will never occur, then the minterms (or maxterms) that represent those combinations are irrelevant. <span epub:type="pagebreak" id="page_80"/>For example, you may want a function that indicates whether one of two possible events has occurred or not, but you know that the two events cannot occur simultaneously. Let’s name the events <em>x</em> and <em>y</em> and let <span class="literal">0</span> indicate that the event has not occurred and <span class="literal">1</span> indicate that it has. <a href="ch04.xhtml#ch4tab12">Table 4-12</a> shows the truth table for our function, <em>F</em>(<em>x</em>, <em>y</em>).</p>&#13;
<p class="tabcap" id="ch4tab12"><strong>Table 4-12:</strong> A Truth Table for <em>x</em> or <em>y</em> Occurring, but Not Both</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong><em>x</em></strong></th>&#13;
<th class="tab_th"><strong><em>y</em></strong></th>&#13;
<th class="tab_th"><strong><em>F</em></strong>(<strong><em>x, y</em></strong>)</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">0</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">1</span></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="codeitalic">×</span></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">We can show that both events cannot occur simultaneously by placing an <em>×</em> in that row. We can draw a Karnaugh map with an <em>×</em> for the minterm that can’t exist in the system, as shown in <a href="ch04.xhtml#ch4fig20">Figure 4-20</a>. The <em>×</em> represents a <em>don’t care</em> cell; grouping this cell with other cells doesn’t affect the evaluation of the function.</p>&#13;
<div class="image"><img id="ch4fig20" src="../images/pg108_Image_116.jpg" alt="Image" width="194" height="137"/></div>&#13;
<p class="figcap"><em>Figure 4-20: A Karnaugh map for</em> F<em>(</em>x, y<em>), showing a “don’t care” cell</em></p>&#13;
<p class="indent">Since the cell that represents the minterm (<em>x</em> ∧ <em>y</em>) is a “don’t care” cell, we can include it, or not, in our minimization groupings, leading to the two groupings shown. The Karnaugh map in <a href="ch04.xhtml#ch4fig20">Figure 4-20</a> leads us to the solution</p>&#13;
<div class="image1"><img src="../images/pg108_Image_117.jpg" alt="Image" width="115" height="21"/></div>&#13;
<p class="noindent">which is a simple OR gate. You probably guessed this solution without having to use a Karnaugh map. You’ll see a more interesting use of “don’t care” cells when you learn about the design of two digital logic circuits at the end of <a href="ch07.xhtml">Chapter 7</a>.</p>&#13;
<p class="indent">Karnaugh maps can be used to minimize only two levels of logic: groups of AND gates feeding an OR gate, or groups of OR gates feeding an AND gate. As you’ll see in the next several chapters, most logic designs involve more than two levels. Karnaugh maps can provide some useful guidelines, but you need to think carefully about the overall design. You will see an <span epub:type="pagebreak" id="page_81"/>example of using Karnaugh maps to design an adder circuit with three levels of logic in <a href="ch06.xhtml">Chapter 6</a>.</p>&#13;
<h3 class="h3" id="ch04lev1sec6"><strong>Combining Basic Boolean Operators</strong></h3>&#13;
<p class="noindent">As mentioned earlier in this chapter, we can combine basic Boolean operators to implement more complex Boolean operators. Now that you know how to work with Boolean functions, we’ll design one of the more common operators, the <em>exclusive or</em>, often called <em>XOR</em>, using the three basic operators, AND, OR, and NOT. It’s so commonly used that it has its own circuit symbol. Let’s take a look:</p>&#13;
<p class="noindenta"><strong>XOR</strong></p>&#13;
<p class="noindentin">XOR is a binary operator. The result is <span class="literal">1</span> if one, and only one, of the two operands is <span class="literal">1</span>; otherwise, the result is <span class="literal">0</span>. I’ll use ⊻ to designate the XOR operation. It’s also common to use the ⊕ symbol. <a href="ch04.xhtml#ch4fig21">Figure 4-21</a> shows XOR gate operation with inputs <em>x</em> and <em>y</em>.</p>&#13;
<div class="image"><img id="ch4fig21" src="../images/pg109_Image_118.jpg" alt="Image" width="326" height="129"/></div>&#13;
<p class="figcap"><em>Figure 4-21: An XOR gate acting on two variables,</em> x <em>and</em> y</p>&#13;
<p class="indent1">The minterm implementation of this operation is:</p>&#13;
<div class="image1"><img src="../images/pg109_Image_119.jpg" alt="Image" width="221" height="21"/></div>&#13;
<p class="indent">The XOR operator can be implemented with two AND gates, two NOT gates, and one OR gate, as shown in <a href="ch04.xhtml#ch4fig22">Figure 4-22</a>.</p>&#13;
<div class="image"><img id="ch4fig22" src="../images/pg109_Image_120.jpg" alt="Image" width="405" height="116"/></div>&#13;
<p class="figcap"><em>Figure 4-22: An XOR gate made from AND, OR, and NOT gates</em></p>&#13;
<p class="indent">We can, of course, design many more Boolean operators, but we’ll move on in the next few chapters to learn how these operators can be implemented in hardware using simple on/off switches. As you’ll discover, the idealized minimal solutions you’ve learned about in this chapter may not always be the best solutions, due to factors such as the inherent electrical characteristics of the switches, multiple levels of logic, availability of hardware components, and so forth.</p>&#13;
<span epub:type="pagebreak" id="page_82"/>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch4exe3">4.3     Design a function that will detect all the 4-bit integers that are even.</p>&#13;
<p class="box-list" id="ch4exe4">4.4     Find a minimal sum of products expression for this function:</p>&#13;
<div class="image1"><img src="../images/pg110_Image_121.jpg" alt="Image" width="495" height="46"/></div>&#13;
<p class="box-list" id="ch4exe5">4.5     Find a minimal product of sums expression for this function:</p>&#13;
<div class="image1"><img src="../images/pg110_Image_122.jpg" alt="Image" width="464" height="54"/></div>&#13;
<p class="box-list" id="ch4exe6">4.6     The arrangement of the variables for a Karnaugh map is arbitrary, but the minterms (or maxterms) need to be consistent with the labeling. Show where each minterm is located with this Karnaugh map axis labeling using the notation of <a href="ch04.xhtml#ch4fig12">Figure 4-12</a>:</p>&#13;
<div class="indent1a"><img src="../images/pg110_Image_123.jpg" alt="Image" width="253" height="132"/></div>&#13;
<p class="box-list" id="ch4exe7">4.7     The arrangement of the variables for a Karnaugh map is arbitrary, but the minterms (or maxterms) need to be consistent with the labeling. Show where each minterm is located with this Karnaugh map axis labeling using the notation of <a href="ch04.xhtml#ch4fig12">Figure 4-12</a>:</p>&#13;
<div class="indent1a"><img src="../images/pg110_Image_124.jpg" alt="Image" width="253" height="133"/></div>&#13;
<p class="box-list" id="ch4exe8">4.8     Create a Karnaugh map for five variables. You’ll probably need to review the Gray code in <a href="ch04.xhtml#ch4tab10">Table 4-10</a> and increase it to five bits.</p>&#13;
<p class="box-list" id="ch4exe9">4.9     Design a logic function that detects the single-digit prime numbers. Assume that the numbers are coded in 4-bit BCD (see <a href="ch02.xhtml#ch2tab7">Table 2-7</a>). The function is <span class="literal">1</span> for each prime number.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev1sec7"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Boolean operators</strong>   The three basic Boolean operators are AND, OR, and NOT.</p>&#13;
<p class="noindentin"><strong>Rules of Boolean algebra</strong>   Boolean algebra provides a mathematical way to work with the rules of logic. AND works like multiplication, and OR is similar to addition in elementary algebra.</p>&#13;
<span epub:type="pagebreak" id="page_83"/>&#13;
<p class="noindentin"><strong>Simplifying Boolean algebra expressions</strong>   Boolean functions specify the functionality of a computer. Simplifying these functions leads to a simpler hardware implementation.</p>&#13;
<p class="noindentin"><strong>Karnaugh maps</strong>   These provide a graphical way to simplify Boolean expressions.</p>&#13;
<p class="noindentin"><strong>Gray code</strong>   This shows how to order the cells in a Karnaugh map.</p>&#13;
<p class="noindentin"><strong>Combining basic Boolean operators</strong>   XOR can be created from AND, OR, and NOT operators.</p>&#13;
<p class="indenta">The next chapter starts with an introduction to basic electronics that will provide a basis for understanding how transistors can be used to implement switches. From there, we’ll look at how transistor switches are used to implement logic gates.<span epub:type="pagebreak" id="page_84"/></p>&#13;
</div>
</div>
</body></html>