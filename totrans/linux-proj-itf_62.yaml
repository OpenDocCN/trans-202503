- en: Chapter 62. Terminals
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 62 章 终端
- en: Historically, users accessed a UNIX system using a terminal connected via a
    serial line (an RS-232 connection). Terminals were cathode ray tubes (CRTs) capable
    of displaying characters and, in some cases, primitive graphics. Typically, CRTs
    provided a monochrome display of 24 lines by 80 columns. By today’s standards,
    these CRTs were small and expensive. In even earlier times, terminals were sometimes
    hard-copy teletype devices. Serial lines were also used to connect other devices,
    such as printers and modems, to a computer or to connect one computer to another.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，用户通过串行线（RS-232 连接）连接终端来访问 UNIX 系统。终端是能够显示字符的阴极射线管（CRT），在某些情况下也能显示原始图形。通常，CRT
    提供的是单色显示，分为 24 行、80 列。按今天的标准，这些 CRT 既小又贵。早期的终端有时是硬拷贝电传打字机设备。串行线还用于将其他设备（如打印机和调制解调器）连接到计算机，或将一台计算机连接到另一台计算机。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On early UNIX systems, the terminal lines connected to the system were represented
    by character devices with names of the form `/dev/tty`*n*. (On Linux, the /`dev/tty`*n*
    devices are the virtual consoles on the system.) It is common to see the abbreviation
    *tty* (derived from teletype) as a shorthand for *terminal*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 UNIX 系统中，连接到系统的终端线路表示为以 `/dev/tty`*n* 形式命名的字符设备。（在 Linux 上，/`dev/tty`*n*
    设备是系统中的虚拟控制台。）常见的缩写 *tty*（源自电传打字机）常被用作 *terminal*（终端）的简写。
- en: Especially during the early years of UNIX, terminal devices were not standardized,
    which meant that different character sequences were required to perform operations
    such as moving the cursor to the beginning of the line or the top of the screen.
    (Eventually, some vendor implementations of such *escape sequences*—for example,
    Digital’s VT-100—became de facto and, ultimately, ANSI standards, but a wide variety
    of terminal types continued to exist.) This lack of standardization meant that
    it was difficult to write portable programs that used terminal features. The *vi*
    editor was an early example of a program with such requirements. The *termcap*
    and *terminfo* databases (described in [Strang et al., 1988]), which tabulate
    how to perform various screen-control operations for a wide variety of terminal
    types, and the *curses* library ([Strang, 1986]) were developed in response to
    this lack of standardization.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在 UNIX 的早期阶段，终端设备并未标准化，这意味着执行操作（例如将光标移到行首或屏幕顶部）需要不同的字符序列。（最终，某些厂商实现的 *escape
    sequences*（转义序列）——例如 Digital 的 VT-100——成为事实上的标准，并最终成为 ANSI 标准，但各种终端类型仍然存在。）这种缺乏标准化导致编写使用终端功能的可移植程序变得困难。*vi*
    编辑器就是一个具有此类要求的早期示例。为应对这种标准化的缺失，开发了 *termcap* 和 *terminfo* 数据库（参见 [Strang 等, 1988]），它们列出了如何为各种终端类型执行不同的屏幕控制操作，以及
    *curses* 库（[Strang, 1986]）。
- en: It is no longer common to see a conventional terminal. The usual interface to
    modern UNIX systems is an X Window System window manager on a high-performance
    bit-mapped graphical monitor. (An old-style terminal provided functionality roughly
    equivalent to a single terminal window—an *xterm* or similar—in an X Window System.
    The fact that the user of such a terminal had only a single “window” to the system
    was the driving force behind the development of the job-control facilities described
    in Section 34.7.) Similarly, many devices (e.g., printers) that were once connected
    directly to a computer are now often intelligent devices connected via a network.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 传统终端已经不常见。现代 UNIX 系统的常见接口是高性能位图图形显示器上的 X 窗口系统窗口管理器。（老式终端提供的功能大致相当于 X 窗口系统中的单个终端窗口——例如
    *xterm* 或类似的终端。使用这种终端的用户仅能看到系统的单个“窗口”，这也是驱动第 34.7 节中描述的作业控制功能发展的原因。）类似地，许多曾经直接连接到计算机的设备（如打印机）现在通常是通过网络连接的智能设备。
- en: All of the above is a preamble to saying that the need to program terminal devices
    is less frequent than it used to be. Therefore, this chapter focuses on the aspects
    of terminal programming that are particularly relevant to software terminal emulators
    (i.e., *xterm* and similar). It gives only brief coverage to serial lines; references
    for further information about serial programming are provided at the end of this
    chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容作为引言，目的是说明编程终端设备的需求不再像以前那样频繁。因此，本章将重点介绍与软件终端模拟器（即 *xterm* 和类似的）特别相关的终端编程方面。对于串行线的内容，本章仅做简要介绍；关于串行编程的进一步参考资料将在本章末尾提供。
- en: Overview
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Both a conventional terminal and a terminal emulator have an associated terminal
    driver that handles input and output on the device. (In the case of a terminal
    emulator, the device is a pseudoterminal. We describe pseudoterminals in [Chapter 64](ch64.html
    "Chapter 64. Pseudoterminals").) Various aspects of the operation of the terminal
    driver can be controlled using the functions described in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 常规终端和终端仿真器都有一个相关的终端驱动程序，负责处理设备的输入和输出。（对于终端仿真器，设备是伪终端。我们在[第64章](ch64.html "第64章.
    伪终端")中描述了伪终端。）终端驱动程序的各种操作方面可以使用本章中描述的函数进行控制。
- en: 'When performing input, the driver is capable of operating in either of the
    following modes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行输入时，驱动程序能够以以下模式之一进行操作：
- en: '*Canonical mode*: In this mode, terminal input is processed line by line, and
    line editing is enabled. Lines are terminated by a newline character, generated
    when the user presses the *Enter* key. A *read()* from the terminal returns only
    when a complete line of input is available, and returns at most one line. (If
    the *read()* requests fewer bytes than are available in the current line, then
    the remaining bytes are available for the next *read()*.) This is the default
    input mode.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*规范模式*：在这种模式下，终端输入按行处理，并启用了行编辑。每行以换行符结束，当用户按下*Enter*键时生成换行符。*read()* 从终端读取数据仅在完整的一行输入可用时才返回，并且最多返回一行。（如果*read()*请求的字节数少于当前行中的可用字节，则剩余的字节将在下次*read()*中可用。）这是默认的输入模式。'
- en: '*Noncanonical mode*: Terminal input is not gathered into lines. Programs such
    as *vi*, *more*, and *less* place the terminal in noncanonical mode so that they
    can read single characters without the user needing to press the *Enter* key.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非规范模式*：终端输入不按行收集。像*vi*、*more*和*less*这样的程序将终端置于非规范模式，以便它们能够读取单个字符，而无需用户按下*Enter*键。'
- en: The terminal driver also interprets a range of special characters, such as the
    *interrupt* character (normally *Control-C*) and the *end-of-file* character (normally
    *Control-D*). Such interpretation may result in a signal being generated for the
    foreground process group or some type of input condition occurring for a program
    reading from the terminal. Programs that place the terminal in noncanonical mode
    typically also disable processing of some or all of these special characters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 终端驱动程序还会解释一系列特殊字符，如*中断*字符（通常是*Control-C*）和*文件结束*字符（通常是*Control-D*）。这种解释可能会导致为前台进程组生成信号，或者在程序从终端读取时发生某种输入条件。将终端置于非规范模式的程序通常还会禁用对某些或所有这些特殊字符的处理。
- en: 'A terminal driver operates two queues ([Figure 62-1](ch62.html#input_and_output_queues_for_a_terminal_d
    "Figure 62-1. Input and output queues for a terminal device")): one for input
    characters transmitted from the terminal device to the reading process(es) and
    the other for output characters transmitted from processes to the terminal. If
    terminal echoing is enabled, then the terminal driver automatically appends a
    copy of any input character to the end of the output queue, so that input characters
    are also output on the terminal.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 终端驱动程序操作两个队列（[图62-1](ch62.html#input_and_output_queues_for_a_terminal_d "图62-1.
    终端设备的输入输出队列")）：一个用于将从终端设备传输到读取进程的输入字符，另一个用于将从进程传输到终端的输出字符。如果启用了终端回显，终端驱动程序会自动将任何输入字符的副本附加到输出队列的末尾，从而使输入字符也在终端上输出。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 specifies the limit `MAX_INPUT`, which an implementation can use to indicate
    the maximum length of the terminal’s input queue. A related limit, `MAX_CANON`,
    defines the maximum number of bytes in a line of input in canonical mode. On Linux,
    *sysconf(_SC_MAX_INPUT)* and *sysconf(_SC_MAX_CANON)* both return the value 255.
    However, neither of these limits is actually employed by the kernel, which simply
    imposes a limit of 4096 bytes on the input queue. A corresponding limit on the
    size of the output queue also exists. However, applications don’t need to be concerned
    with this, since, if a process produces output faster than the terminal driver
    can handle it, the kernel suspends execution of the writing process until space
    is once more available in the output queue.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定了限制 `MAX_INPUT`，该限制可以被实现用来表示终端输入队列的最大长度。相关的限制 `MAX_CANON` 定义了规范模式下输入行的最大字节数。在
    Linux 上，*sysconf(_SC_MAX_INPUT)* 和 *sysconf(_SC_MAX_CANON)* 都返回值 255。然而，内核实际上并没有使用这些限制，而是直接对输入队列施加了
    4096 字节的限制。同时，输出队列的大小也有相应的限制。不过，应用程序无需关心这一点，因为如果进程产生的输出速度超过终端驱动程序处理的速度，内核会暂停写入进程的执行，直到输出队列中再次有足够空间。
- en: On Linux, we can call *ioctl(fd, FIONREAD, &cnt)* to obtain the number of unread
    bytes in the input queue of the terminal referred to by the file descriptor *fd*.
    This feature is not specified in SUSv3.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，我们可以调用 *ioctl(fd, FIONREAD, &cnt)* 来获取由文件描述符 *fd* 引用的终端输入队列中未读字节的数量。此功能在
    SUSv3 中没有规定。
- en: '![Input and output queues for a terminal device](figs/web/62-1_TERM-IO-queues-scale90.png.jpg)Figure 62-1. Input
    and output queues for a terminal device'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![终端设备的输入输出队列](figs/web/62-1_TERM-IO-queues-scale90.png.jpg)图62-1. 终端设备的输入输出队列'
- en: Retrieving and Modifying Terminal Attributes
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和修改终端属性
- en: The *tcgetattr()* and *tcsetattr()* functions retrieve and modify the attributes
    of a terminal.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcgetattr()* 和 *tcsetattr()* 函数用于检索和修改终端的属性。'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1。
- en: The *fd* argument is a file descriptor that refers to a terminal. (If *fd* doesn’t
    refer to a terminal, these functions fail with the error `ENOTTY`.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*fd* 参数是指向终端的文件描述符。（如果 *fd* 不指向终端，这些函数将因错误 `ENOTTY` 而失败。）'
- en: 'The *termios_p* argument is a pointer to a *termios* structure, which records
    terminal attributes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*termios_p* 参数是指向 *termios* 结构的指针，该结构记录终端属性：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first four fields of the *termios* structure are bit masks (the *tcflag_t*
    data type is an integer type of suitable size) containing flags that control various
    aspects of the terminal driver’s operation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*termios* 结构的前四个字段是位掩码（*tcflag_t* 数据类型是适当大小的整数类型），包含控制终端驱动程序操作的各种标志：'
- en: '*c_iflag* contains flags controlling terminal input;'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*c_iflag* 包含控制终端输入的标志；'
- en: '*c_oflag* contains flags controlling terminal output;'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*c_oflag* 包含控制终端输出的标志；'
- en: '*c_cflag* contains flags relating to hardware control of the terminal line;
    and'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*c_cflag* 包含与终端线路硬件控制相关的标志；'
- en: '*c_lflag* contains flags controlling the user interface for terminal input.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*c_lflag* 包含控制终端输入用户界面的标志。'
- en: All of the flags used in the above fields are listed in [Table 62-2](ch62.html#terminal_flags-id1
    "Table 62-2. Terminal flags") (in [Terminal Flags](ch62.html#terminal_flags "Terminal
    Flags")).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述字段中使用的所有标志列出了[表62-2](ch62.html#terminal_flags-id1 "表62-2. 终端标志")（在[终端标志](ch62.html#terminal_flags
    "Terminal Flags")中）。
- en: The *c_line* field specifies the line discipline for this terminal. For the
    purposes of programming terminal emulators, the line discipline will always be
    set to `N_TTY`, the so-called *new* discipline, a component of the kernel terminal-handling
    code that implements canonical mode I/O processing. Setting the line discipline
    can be relevant when programming serial lines.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*c_line* 字段指定了该终端的行规程。对于终端仿真器的编程，行规程将始终设置为 `N_TTY`，即所谓的 *新* 规程，这是内核终端处理代码的一个组成部分，用于实现规范模式的
    I/O 处理。在编写串口程序时，设置行规程可能是相关的。'
- en: The *c_cc* array contains the terminal special characters (*interrupt*, *suspend*,
    and so on) as well as fields controlling the operation of noncanonical mode input.
    The *cc_t* data type is an unsigned integer type suitable for holding these values,
    and the `NCCS` constant specifies the number of elements in this array. We describe
    the terminal special characters in Section 62.4.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*c_cc* 数组包含终端特殊字符（*中断*、*挂起*等），以及控制非规范模式输入操作的字段。*cc_t* 数据类型是一个无符号整数类型，适合存储这些值，`NCCS`
    常量指定该数组中的元素数量。我们将在第62.4节描述终端特殊字符。'
- en: The *c_ispeed* and *c_ospeed* fields are unused on Linux (and are not specified
    in SUSv3). We explain how Linux stores terminal line speeds in Section 62.7.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，*c_ispeed* 和 *c_ospeed* 字段未使用（且在 SUSv3 中未指定）。我们将在第 62.7 节中解释 Linux
    如何存储终端行速。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Seventh Edition and early BSD terminal driver (known as the *tty* driver)
    had grown over time so that it used no less than four different data structures
    to represent the information equivalent to the *termios* structure. System V replaced
    this baroque arrangement with a single structure called *termio*. The initial
    POSIX committee selected the System V API almost as is, in the process renaming
    it to *termios*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第七版和早期的 BSD 终端驱动程序（称为 *tty* 驱动程序）随着时间的推移，发展到使用不止四个不同的数据结构来表示等同于 *termios* 结构的信息。System
    V 用一个名为 *termio* 的单一结构取代了这种复杂的安排。最初的 POSIX 委员会几乎按照原样选择了 System V API，并在此过程中将其重命名为
    *termios*。
- en: 'When changing terminal attributes with *tcsetattr()*, the *optional_actions*
    argument determines when the change takes effect. This argument is specified as
    one of the following values:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 *tcsetattr()* 更改终端属性时，*optional_actions* 参数决定了更改何时生效。此参数可以指定以下值之一：
- en: '`TCSANOW`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCSANOW`'
- en: The change is carried out immediately.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更改会立即生效。
- en: '`TCSADRAIN`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCSADRAIN`'
- en: The change takes effect after all currently queued output has been transmitted
    to the terminal. Normally, this flag should be specified when making changes that
    affect terminal output, so that we don’t affect output that has already been queued
    but not yet displayed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更改在所有当前排队的输出已传输到终端后生效。通常，在进行影响终端输出的更改时，应该指定此标志，以避免影响已排队但尚未显示的输出。
- en: '`TCSAFLUSH`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCSAFLUSH`'
- en: The change takes effect as for `TCSADRAIN`, but, in addition, any input that
    is still pending at the time the change takes effect is discarded. This is useful,
    for example, when reading a password, where we wish to disable terminal echoing
    and prevent user type-ahead.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 更改生效方式与 `TCSADRAIN` 相同，但此外，任何在更改生效时仍待处理的输入将被丢弃。例如，当读取密码时，我们希望禁用终端回显并防止用户提前输入。
- en: 'The usual (and recommended) way to change terminal attributes is to use *tcgetattr()*
    to retrieve a *termios* structure containing a copy of the current settings, change
    the desired attributes, and then use *tcsetattr()* to push the updated structure
    back to the driver. (This approach ensures that we pass a fully initialized structure
    to *tcsetattr()*.) For example, we can use the following sequence to turn terminal
    echoing off:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 更改终端属性的常用（且推荐）方法是使用 *tcgetattr()* 来获取一个包含当前设置副本的 *termios* 结构，修改所需的属性，然后使用 *tcsetattr()*
    将更新后的结构推送回驱动程序。（这种方法确保我们向 *tcsetattr()* 传递一个完全初始化的结构。）例如，我们可以使用以下序列来关闭终端回显：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The *tcsetattr()* function returns successfully if *any* of the requested changes
    to terminal attributes could be performed; it fails only if *none* of the requested
    changes could be made. This means that, when making multiple attribute changes,
    it may sometimes be necessary to make a further call to *tcgetattr()* to retrieve
    the new terminal attributes and compare them against the requested changes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以执行请求的任何终端属性更改，则 *tcsetattr()* 函数将成功返回；只有在无法进行任何请求的更改时才会失败。这意味着，在进行多个属性更改时，有时可能需要再次调用
    *tcgetattr()* 来获取新的终端属性，并将其与请求的更改进行比较。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Implementing Job Control](ch34.html#implementing_job_control "Implementing
    Job Control"), we noted that if *tcsetattr()* is called from a process in a background
    process group, then the terminal driver suspends the process group by delivering
    a `SIGTTOU` signal, and that, if called from an orphaned process group, *tcsetattr()*
    fails with the error EIO. The same statements apply for various other functions
    described in this chapter, including *tcflush()*, *tcflow()*, *tcsendbreak()*,
    and *tcdrain()*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[实现作业控制](ch34.html#implementing_job_control "Implementing Job Control")中，我们指出，如果从后台进程组中的进程调用
    *tcsetattr()*，则终端驱动程序会通过发送 `SIGTTOU` 信号来暂停该进程组；如果从孤立的进程组调用，则 *tcsetattr()* 会因错误
    EIO 而失败。对于本章中描述的其他各种函数，如 *tcflush()*、*tcflow()*、*tcsendbreak()* 和 *tcdrain()*，同样适用这些说明。
- en: In earlier UNIX implementations, terminal attributes were accessed using *ioctl()*
    calls. Like several other functions described in this chapter, the *tcgetattr()*
    and *tcsetattr()* functions are POSIX inventions designed to address the problem
    that type checking of the third argument of *ioctl()* isn’t possible. On Linux,
    as in many other UNIX implementations, these are library functions layered on
    top of *ioctl()*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 UNIX 实现中，终端属性是通过*ioctl()*调用访问的。与本章中描述的其他几个函数一样，*tcgetattr()*和*tcsetattr()*函数是
    POSIX 发明的，旨在解决*ioctl()*的第三个参数类型检查无法进行的问题。在 Linux 以及许多其他 UNIX 实现中，这些是基于*ioctl()*的库函数。
- en: The *stty* Command
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*stty* 命令'
- en: The *stty* command is the command-line analog of the *tcgetattr()* and *tcsetattr()*
    functions, allowing us to view and change terminal attributes from the shell.
    This is useful when trying to monitor, debug, or undo the effects of programs
    that modify terminal attributes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*stty* 命令是*tcgetattr()*和*tcsetattr()*函数的命令行类比，允许我们从 shell 中查看和更改终端属性。这在尝试监控、调试或撤销修改终端属性的程序的效果时非常有用。'
- en: 'We can view the current settings of all terminal attributes using the following
    command (here carried out on a virtual console):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令查看所有终端属性的当前设置（此命令在虚拟控制台上执行）：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line of the above output shows the terminal line speed (bits per second),
    the terminal window size, and the line discipline in numeric form (0 corresponds
    to `N_TTY`, the new line discipline).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出的第一行显示了终端的行速（每秒比特数）、终端窗口大小和行规程的数字表示形式（0代表`N_TTY`，即新的行规程）。
- en: The next three lines show the settings of the various terminal special characters.
    The notation `^C` denotes *Control-C*, and so on. The string `<undef>` means that
    the corresponding terminal special character is not currently defined. The *min*
    and *time* values relate to noncanonical mode input, and are described in [Noncanonical
    Mode](ch62.html#noncanonical_mode "Noncanonical Mode").
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三行显示了各种终端特殊字符的设置。符号`^C`表示*Control-C*，依此类推。字符串`<undef>`表示相应的终端特殊字符当前未定义。*min*和*time*值与非规范模式输入相关，详情请参见[非规范模式](ch62.html#noncanonical_mode
    "Noncanonical Mode")。
- en: The remaining lines show the settings of the various flags from (in order) the
    *c_cflag*, *c_iflag*, *c_oflag*, and *c_lflag* fields of the *termios* structure.
    Where a flag name is preceded by a hyphen (`-`), the flag is currently disabled;
    otherwise, it is currently enabled.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的几行展示了来自*termios*结构的各个标志的设置（按顺序为：*c_cflag*、*c_iflag*、*c_oflag*和*c_lflag*字段）。如果某个标志前有一个短横线（`-`），则表示该标志当前被禁用；否则，它是启用状态。
- en: When entered without command-line arguments, *stty* shows just the terminal
    line speed, the line discipline, and any of the other settings that deviate from
    sane values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有命令行参数的情况下输入*stty*，它将只显示终端的行速、行规程以及任何偏离合理值的其他设置。
- en: 'We can change the settings of terminal special characters using commands such
    as the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用如下命令更改终端特殊字符的设置：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When specifying a control character as the final argument, we can do so in
    a variety of ways:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定控制字符作为最终参数时，我们可以采用多种方式：
- en: as a 2-character sequence consisting of a caret (`^`) followed by the corresponding
    character (as shown above);
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为由插入符号（`^`）后跟相应字符组成的两个字符序列（如上所示）；
- en: 'as an octal or hexadecimal number (thus: `014` or `0xC`); or'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为八进制或十六进制数字（例如：`014`或`0xC`）；或者
- en: by typing the actual character itself.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过输入实际字符本身。
- en: 'If we employ the final option, and the character in question is one interpreted
    specially by the shell or the terminal driver, then we must precede it with the
    *literal next* character (usually *Control-V*):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用最后一个选项，并且该字符是 shell 或终端驱动程序特别解释的字符，则必须在它前面加上*字面下一个*字符（通常是*Control-V*）：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: (Although, for readability, a space is shown between the *Control-V* and the
    *Control-L* in the above example, no white-space characters should be typed between
    the *Control-V* and the desired character.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: （尽管为了可读性，以上示例中*Control-V*和*Control-L*之间显示了一个空格，但在实际输入时，*Control-V*和目标字符之间不应输入任何空白字符。）
- en: 'It is possible, though unusual, to define terminal special characters to be
    something other than control characters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不常见，但可以将终端特殊字符定义为非控制字符：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, when we do this, we can no longer use the *q* key for its usual purpose
    (i.e., generating the letter *q*).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们这么做时，我们就无法再使用*q*键来执行其常规功能（即生成字母*q*）。
- en: 'To change terminal flags, such as the `TOSTOP` flag, we can use commands such
    as the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改终端标志，例如 `TOSTOP` 标志，我们可以使用以下命令：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sometimes, when developing programs that modify terminal attributes, a program
    may crash, leaving the terminal in a state that renders it all but unusable. On
    a terminal emulator, we have the luxury of simply closing the terminal window
    and starting another. Alternatively, we can type in the following character sequence
    to restore the terminal flags and special characters to a reasonable state:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在开发修改终端属性的程序时，程序可能会崩溃，导致终端进入一个几乎无法使用的状态。在终端仿真器上，我们可以轻松关闭终端窗口并启动另一个。或者，我们可以键入以下字符序列来恢复终端标志和特殊字符到一个合理的状态：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The *Control-J* character is the real newline character (ASCII 10 decimal).
    We use this character because, in some modes, the terminal driver may no longer
    map the *Enter* key (ASCII 13 decimal) into a newline character. We type an initial
    *Control-J* to ensure that we have a fresh command line with no preceding characters.
    This may not be easy to verify if, for example, terminal echoing has been disabled.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*Control-J* 字符是真正的换行字符（ASCII 10 十进制）。我们使用这个字符，因为在某些模式下，终端驱动程序可能不再将 *Enter*
    键（ASCII 13 十进制）映射为换行字符。我们输入一个初始的 *Control-J* 来确保我们有一个没有前导字符的新命令行。如果终端回显被禁用，这一点可能不容易验证。'
- en: 'The *stty* command operates on the terminal referred to by standard input.
    Using the *-F* option, we can (subject to permission checks) monitor and set the
    attributes of a terminal other than the one on which the *stty* command is run:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*stty* 命令作用于标准输入指定的终端。使用 *-F* 选项，我们可以（在权限检查通过的情况下）监控和设置除了运行 *stty* 命令的终端以外的其他终端的属性：'
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The *-F* option is a Linux-specific extension to the *stty* command. On many
    other UNIX implementations, *stty* always acts on the terminal referred to by
    standard input, and we must use the following alternative form (which can also
    be used on Linux):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*-F* 选项是 Linux 特有的扩展，用于 *stty* 命令。在许多其他 UNIX 实现中，*stty* 总是作用于标准输入指定的终端，我们必须使用以下替代形式（在
    Linux 上也可使用）：'
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Terminal Special Characters
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端特殊字符
- en: '[Table 62-1](ch62.html#terminal_special_characters-id1 "Table 62-1. Terminal
    special characters") lists the special characters recognized by the Linux terminal
    driver. The first two columns show the name of the character and the corresponding
    constant that can be used as a subscript in the *c_cc* array. (As can be seen,
    these constants simply prefix the letter *V* in front of the character name.)
    The CR and NL characters don’t have corresponding *c_cc* subscripts, because the
    values of these characters can’t be changed.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 62-1](ch62.html#terminal_special_characters-id1 "表格 62-1. 终端特殊字符")列出了 Linux
    终端驱动程序识别的特殊字符。前两列显示了字符的名称和对应的常量，可以作为 *c_cc* 数组的下标使用。（如所见，这些常量只是将字母 *V* 前缀加在字符名称前面。）CR
    和 NL 字符没有对应的 *c_cc* 下标，因为这些字符的值无法更改。'
- en: The *Default setting* column of the table shows the usual default value for
    the special character. As well as being able to set a terminal special character
    to a specific value, it is also possible to disable the character by setting it
    to the value returned by the call *fpathconf(fd, _PC_VDISABLE)*, where *fd* is
    a file descriptor referring to a terminal. (On most UNIX implementations, this
    call returns the value 0.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的 *默认设置* 列显示了特殊字符的通常默认值。除了能够将终端特殊字符设置为特定值外，还可以通过将字符设置为调用 *fpathconf(fd, _PC_VDISABLE)*
    返回的值来禁用该字符，其中 *fd* 是指向终端的文件描述符。（在大多数 UNIX 实现中，这个调用返回值为 0。）
- en: The operation of each of the special characters is subject to the setting of
    various flags in the *termios* bit-mask fields (described in [Terminal Flags](ch62.html#terminal_flags
    "Terminal Flags")), as shown in the penultimate column of the table.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特殊字符的操作受到 *termios* 位掩码字段中各种标志设置的影响（详细描述见[终端标志](ch62.html#terminal_flags "终端标志")），如表格倒数第二列所示。
- en: The final column indicates which of these characters are specified by SUSv3.
    Regardless of the SUSv3 specification, most of these characters are supported
    on all UNIX implementations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一列指示哪些字符是由 SUSv3 指定的。无论 SUSv3 规范如何，大多数这些字符在所有 UNIX 实现中都受支持。
- en: Table 62-1. Terminal special characters
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 62-1. 终端特殊字符
- en: '| Character | *c_cc* subscript | Description | Default setting | Relevant bit-mask
    flags | SUSv3 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | *c_cc* 下标 | 描述 | 默认设置 | 相关位掩码标志 | SUSv3 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| CR | (none) | Carriage return | `^M` | `ICANON`, `IGNCR`, `ICRNL`, `OPOST`,
    `OCRNL`, `ONOCR` | • |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| CR | (无) | 回车 | `^M` | `ICANON`, `IGNCR`, `ICRNL`, `OPOST`, `OCRNL`, `ONOCR`
    | • |'
- en: '| DISCARD | `VDISCARD` | Discard output | `^O` | (not implemented) |   |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| DISCARD | `VDISCARD` | 丢弃输出 | `^O` | （未实现） |   |'
- en: '| EOF | `VEOF` | End-of-file | `^D` | `ICANON` | • |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| EOF | `VEOF` | 文件结束 | `^D` | `ICANON` | • |'
- en: '| EOL | `VEOL` | End-of-line |   | `ICANON` | • |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| EOL | `VEOL` | 行尾 |   | `ICANON` | • |'
- en: '| EOL2 | `VEOL2` | Alternate end-of-line |   | `ICANON`, `IEXTEN` |   |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| EOL2 | `VEOL2` | 备用行尾 |   | `ICANON`, `IEXTEN` |   |'
- en: '| ERASE | `VERASE` | Erase character | `^?` | `ICANON` | • |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| ERASE | `VERASE` | 擦除字符 | `^?` | `ICANON` | • |'
- en: '| INTR | `VINTR` | Interrupt (`SIGINT`) | `^C` | `ISIG` | • |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| INTR | `VINTR` | 中断（`SIGINT`） | `^C` | `ISIG` | • |'
- en: '| KILL | `VKILL` | Erase line | `^U` | `ICANON` | • |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| KILL | `VKILL` | 擦除行 | `^U` | `ICANON` | • |'
- en: '| LNEXT | `VLNEXT` | Literal next | `^V` | `ICANON`, `IEXTEN` |   |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| LNEXT | `VLNEXT` | 字面量下一个 | `^V` | `ICANON`, `IEXTEN` |   |'
- en: '| NL | (none) | Newline | `^J` | `ICANON`, `INLCR`, `ECHONL`, `OPOST`, `ONLCR`,
    `ONLRET` | • |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| NL | (无) | 换行 | `^J` | `ICANON`, `INLCR`, `ECHONL`, `OPOST`, `ONLCR`, `ONLRET`
    | • |'
- en: '| QUIT | `VQUIT` | Quit (`SIGQUIT`) | `^\` | `ISIG` | • |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| QUIT | `VQUIT` | 退出（`SIGQUIT`） | `^\` | `ISIG` | • |'
- en: '| REPRINT | `VREPRINT` | Reprint input line | `^R` | `ICANON`, `IEXTEN`, `ECHO`
    |   |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| REPRINT | `VREPRINT` | 重新打印输入行 | `^R` | `ICANON`, `IEXTEN`, `ECHO` |   |'
- en: '| START | `VSTART` | Start output | `^Q` | `IXON`, `IXOFF` | • |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| START | `VSTART` | 启动输出 | `^Q` | `IXON`, `IXOFF` | • |'
- en: '| STOP | `VSTOP` | Stop output | `^S` | `IXON`, `IXOFF` | • |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| STOP | `VSTOP` | 停止输出 | `^S` | `IXON`, `IXOFF` | • |'
- en: '| SUSP | `VSUSP` | Suspend (`SIGTSTP`) | `^Z` | `ISIG` | • |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| SUSP | `VSUSP` | 挂起（`SIGTSTP`） | `^Z` | `ISIG` | • |'
- en: '| WERASE | `VWERASE` | Erase word | `^W` | `ICANON`, `IEXTEN` |   |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| WERASE | `VWERASE` | 擦除单词 | `^W` | `ICANON`, `IEXTEN` |   |'
- en: The following paragraphs provide more detailed explanations of the terminal
    special characters. Note that if the terminal driver performs its special input
    interpretation on one of these characters, then—with the exception of CR, EOL,
    EOL2, and NL—the character is discarded (i.e., it is not passed to any reading
    process).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下段落将提供有关终端特殊字符的更详细解释。请注意，如果终端驱动程序对这些字符执行了特殊的输入解释，那么——除了 CR、EOL、EOL2 和 NL——该字符会被丢弃（即，不会传递给任何读取进程）。
- en: CR
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CR
- en: CR is the *carriage return* character. This character is passed to the reading
    process. In canonical mode (`ICANON` flag set) with the `ICRNL` (*map CR to NL
    on input*) flag set (the default), this character is first converted to a newline
    (ASCII 10 decimal, `^J`) before being passed to the reading process. If the `IGNCR`
    (*ignore CR*) flag is set, then this character is ignored on input (in which case
    the true newline character must be used to terminate a line of input). An output
    CR character causes the terminal to move the cursor to the beginning of the line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CR 是 *回车* 字符。这个字符会传递给读取进程。在规范模式下（`ICANON` 标志被设置），并且设置了 `ICRNL`（*将 CR 映射到 NL
    进行输入*）标志（默认情况下），这个字符会首先转换为换行符（ASCII 10 十进制，`^J`），然后才会传递给读取进程。如果设置了 `IGNCR`（*忽略
    CR*）标志，那么该字符在输入时会被忽略（在这种情况下，必须使用真正的换行符来终止一行输入）。输出的 CR 字符会使终端将光标移动到行首。
- en: DISCARD
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DISCARD
- en: DISCARD is the *discard output* character. Although this character is defined
    within the *c_cc* array, it has no effect on Linux. On some other UNIX implementations,
    typing this character once causes program output to be discarded. This character
    is a toggle—typing it once more reenables the display of output. This is useful
    when a program is generating a large amount of output and we want to skip some
    of it. (This was much more useful on traditional terminals, where line speeds
    were slower and other “terminal windows” were unavailable.) This character is
    not passed to the reading process.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: DISCARD 是 *丢弃输出* 字符。尽管该字符在 *c_cc* 数组中有定义，但在 Linux 上没有作用。在某些其他 UNIX 实现中，输入这个字符一次会导致程序输出被丢弃。这个字符是一个开关——再次输入它会重新启用输出显示。这在程序生成大量输出时很有用，可以跳过部分输出。（这在传统终端上更为有用，因为当时行速较慢，且没有其他“终端窗口”可用。）该字符不会传递给读取进程。
- en: EOF
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: EOF
- en: EOF is the canonical mode *end-of-file* character (usually *Control-D*). Entering
    this character at the beginning of a line causes an end-of-file condition to be
    detected by a process reading from the terminal (i.e., *read()* returns 0). If
    typed anywhere other than the initial character of a line, then this character
    simply causes *read()* to complete immediately, returning the characters so far
    input in the line. In both cases, the EOF character itself is not passed to the
    reading process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: EOF是规范模式下的*文件结束*字符（通常是*Control-D*）。在行的开头输入此字符会导致读取进程检测到文件结束条件（即，*read()*返回0）。如果在行的其他位置输入此字符，则该字符会立即导致*read()*完成，返回到目前为止输入的字符。在这两种情况下，EOF字符本身不会传递给读取进程。
- en: EOL and EOL2
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: EOL和EOL2
- en: EOL and EOL2 are *additional line-delimiter* characters that operate like the
    standard newline (NL) character for canonical mode input, terminating a line of
    input and making it available to the reading process. By default, these characters
    are undefined. If they are defined, they are passed to the reading process. The
    EOL2 character is operational only if the `IEXTEN` (*extended input processing*)
    flag is set (the default).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: EOL和EOL2是*附加行分隔符*字符，类似于规范模式输入中的标准换行（NL）字符，用于终止一行输入并将其提供给读取进程。默认情况下，这些字符未定义。如果定义了这些字符，它们将传递给读取进程。EOL2字符仅在设置了`IEXTEN`（*扩展输入处理*）标志时才有效（默认情况下是如此）。
- en: These characters are rarely used. One application that does use them is *telnet*.
    By setting EOL or EOL2 to be the *telnet* escape character (usually *Control-]*,
    or, alternatively, the tilde character, ~, if operating in *rlogin* mode), *telnet*
    is able to immediately catch that character, even while reading input in canonical
    mode.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符很少使用。有一个应用程序使用它们，那就是*telnet*。通过将EOL或EOL2设置为*telnet*的转义字符（通常是*Control-]*，或者在*rlogin*模式下，使用波浪号字符~），*telnet*能够立即捕捉到该字符，即使在规范模式下读取输入时也是如此。
- en: ERASE
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ERASE
- en: In canonical mode, typing the ERASE character erases the previously input character
    on the current line. The erased character and the ERASE character itself are not
    passed to the reading process.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范模式下，输入ERASE字符会删除当前行上先前输入的字符。被删除的字符和ERASE字符本身不会传递给读取进程。
- en: INTR
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: INTR
- en: INTR is the *interrupt* character. If the `ISIG` (*enable signals*) flag is
    set (the default), typing this character causes an *interrupt* signal (`SIGINT`)
    to be sent to the terminal’s foreground process group ([Process Groups](ch34.html#process_groups
    "Process Groups")). The INTR character itself is not passed to the reading process.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: INTR是*中断*字符。如果设置了`ISIG`（*启用信号*）标志（默认情况下），输入此字符会向终端的前台进程组发送一个*中断*信号（`SIGINT`）（参见[进程组](ch34.html#process_groups
    "进程组")）。INTR字符本身不会传递给读取进程。
- en: KILL
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: KILL
- en: KILL is the *erase line* (also known as *kill line*) character. In canonical
    mode, typing this character causes the current line of input to be discarded (i.e.,
    the characters typed so far, as well as the KILL character itself, are not passed
    to the reading process).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: KILL是*清除行*（也叫*杀死行*）字符。在规范模式下，输入此字符会导致当前输入行被丢弃（即，已经输入的字符以及KILL字符本身不会传递给读取进程）。
- en: LNEXT
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LNEXT
- en: LNEXT is the *literal next* character. In some circumstances, we may wish to
    treat one of the terminal special characters as though it were a normal character
    for input to a reading process. Typing the literal next character (usually *Control-V*)
    causes the next character to be treated literally, voiding any special interpretation
    of the character that the terminal driver would normally perform. Thus, we could
    enter the 2-character sequence *Control-V Control-C* to supply a real *Control-C*
    character (ASCII 3) as input to the reading process. The LNEXT character itself
    is not passed to the reading process. This character is interpreted only in canonical
    mode with the `IEXTEN` (*extended input processing*) flag set (which is the default).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: LNEXT是*字面上的下一个*字符。在某些情况下，我们可能希望将某些终端特殊字符视为普通字符来输入到读取进程中。输入字面下一个字符（通常是*Control-V*）会导致下一个字符被字面处理，忽略终端驱动程序通常对该字符的任何特殊解释。因此，我们可以输入两个字符序列*Control-V
    Control-C*，将真正的*Control-C*字符（ASCII 3）作为输入提供给读取进程。LNEXT字符本身不会传递给读取进程。该字符仅在规范模式下并且设置了`IEXTEN`（*扩展输入处理*）标志时被解释（默认情况下就是如此）。
- en: NL
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NL
- en: NL is the *newline* character. In canonical mode, this character terminates
    an input line. The NL character itself is included in the line returned to the
    reading process. (The CR character is normally converted to NL in canonical mode.)
    An output NL character causes the terminal to move the cursor down one line. If
    the `OPOST` and `ONLCR` (*map NL to CR-NL*) flags are set (the default), then,
    on output, a newline character is mapped to the 2-character sequence CR plus NL.
    (The combination of the `ICRNL` and `ONLCR` flags means that an input CR is converted
    to a NL, and then echoed as CR plus NL.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: NL是*换行*字符。在规范模式下，该字符用于终止输入行。NL字符本身包含在返回给读取进程的行中。（在规范模式下，CR字符通常会转换为NL。）输出的NL字符会使终端光标下移一行。如果设置了`OPOST`和`ONLCR`（*将NL映射为CR-NL*）标志（默认设置），则在输出时，换行字符会被映射为两个字符的序列CR加NL。（`ICRNL`和`ONLCR`标志的组合意味着输入的CR会被转换为NL，然后作为CR加NL回显。）
- en: QUIT
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: QUIT
- en: If the `ISIG` flag is set (the default), typing the QUIT character causes a
    *quit* signal (`SIGQUIT`) to be sent to the terminal’s foreground process group
    ([Process Groups](ch34.html#process_groups "Process Groups")). The QUIT character
    itself is not passed to the reading process.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`ISIG`标志（默认设置），输入QUIT字符会向终端的前台进程组发送一个*退出*信号（`SIGQUIT`）（[进程组](ch34.html#process_groups
    "进程组")）。QUIT字符本身不会传递给读取进程。
- en: REPRINT
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: REPRINT
- en: REPRINT is the *reprint input* character. In canonical mode with the `IEXTEN`
    flag set (the default), typing this character causes the current (as yet incomplete)
    line of input to be redisplayed on the terminal. This is useful if some other
    program (e.g., *wall(1)* or *write(1)*) has written output that has messed up
    the terminal display. The REPRINT character itself is not passed to the reading
    process.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: REPRINT是*重新打印输入*字符。在设置了`IEXTEN`标志（默认设置）的规范模式下，输入该字符会在终端上重新显示当前（尚未完成的）输入行。如果其他程序（例如，*wall(1)*或*write(1)*)输出内容导致终端显示混乱，这个功能会很有用。REPRINT字符本身不会传递给读取进程。
- en: START and STOP
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: START和STOP
- en: START and STOP are the *start output* and *stop output* characters, which operate
    if the `IXON` (*enable start/stop output control*) flag is enabled (the default).
    (The START and STOP characters are not honored by some terminal emulators.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: START和STOP是*开始输出*和*停止输出*字符，当`IXON`（*启用开始/停止输出控制*）标志启用时会生效（默认设置）。(某些终端模拟器不支持START和STOP字符。)
- en: Typing the STOP character suspends terminal output. The STOP character itself
    is not passed to the reading process. If the `IXOFF` flag is set and the terminal
    input queue is full, then the terminal driver automatically sends a STOP character
    to throttle the input.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输入STOP字符会暂停终端输出。STOP字符本身不会传递给读取进程。如果设置了`IXOFF`标志且终端输入队列已满，则终端驱动程序会自动发送STOP字符以限制输入。
- en: Typing the START character causes terminal output to resume after previously
    being stopped by the STOP character. The START character itself is not passed
    to the reading process. If the `IXOFF` (*enable start/stop input control*) flag
    is set (this flag is disabled by default) and the terminal driver had previously
    sent a STOP character because the input queue was full, the terminal driver automatically
    generates a START character when space once more becomes available in the input
    queue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输入START字符会在之前被STOP字符暂停的终端输出后恢复。START字符本身不会传递给读取进程。如果设置了`IXOFF`（*启用开始/停止输入控制*）标志（该标志默认禁用），且终端驱动程序之前由于输入队列已满而发送了STOP字符，当输入队列中再次有空间时，终端驱动程序会自动生成一个START字符。
- en: If the `IXANY` flag is set, then any character, not just `START`, may be typed
    in order to restart output (and that character is similarly not passed to the
    reading process).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`IXANY`标志，那么任何字符，而不仅仅是`START`，都可以用来重新启动输出（且该字符同样不会传递给读取进程）。
- en: The START and STOP characters are used for software flow control in either direction
    between the computer and the terminal device. One function of these characters
    is to allow users to stop and start terminal output. This is output flow control,
    as enabled by `IXON`. However, flow control in the other direction (i.e., control
    of input flow from the device to the computer, as enabled by `IXOFF`) is also
    important when, for example, the device in question is a modem or another computer.
    Input flow control makes sure that no data is lost if the application is slow
    to handle input and the kernel buffers fill up.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: START 和 STOP 字符用于在计算机和终端设备之间进行软件流控制，方向是双向的。这些字符的一个功能是允许用户停止和启动终端输出。这是输出流控制，由
    `IXON` 启用。然而，另一方向的流控制（即从设备到计算机的输入流控制，由 `IXOFF` 启用）也很重要，特别是当设备是调制解调器或另一台计算机时。输入流控制确保在应用程序处理输入缓慢并且内核缓冲区已满时，不会丢失数据。
- en: With the higher line speeds that are nowadays typical, software flow control
    has been superseded by hardware (RTS/CTS) flow control, whereby data flow is enabled
    and disabled using signals sent via separate wires on the serial port. (RTS stands
    for *Request To Send*, and CTS stands for *Clear To Send*.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随着如今典型的更高线路速度，软件流控制已被硬件（RTS/CTS）流控制取代，数据流通过串口上单独的线路发送信号来启用和禁用。（RTS 代表*请求发送*，CTS
    代表*清除发送*。）
- en: SUSP
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SUSP
- en: SUSP is the *suspend* character. If the `ISIG` flag is set (the default), typing
    this character causes a *terminal suspend* signal (`SIGTSTP`) to be sent to the
    terminal’s foreground process group ([Process Groups](ch34.html#process_groups
    "Process Groups")). The SUSP character itself is not passed to the reading process.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SUSP 是*暂停*字符。如果设置了 `ISIG` 标志（默认情况），输入此字符会向终端的前台进程组发送一个*终端暂停*信号（`SIGTSTP`）([进程组](ch34.html#process_groups
    "进程组")）。SUSP 字符本身不会传递给正在读取的进程。
- en: WERASE
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WERASE
- en: WERASE is the *word erase* character. In canonical mode, with the `IEXTEN` flag
    set (the default), typing this character erases all characters back to the beginning
    of the previous word. A word is considered to be a sequence of letters, digits,
    and the underscore character. (On some UNIX implementations, a word is considered
    to be delimited by white space.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: WERASE 是*删除词*字符。在规范模式下，当设置了 `IEXTEN` 标志（默认情况），输入此字符会删除从当前光标位置到前一个单词的所有字符。一个单词被认为是由字母、数字和下划线字符组成的序列。（在某些
    UNIX 实现中，一个单词被认为是由空格分隔的。）
- en: Other terminal special characters
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他终端特殊字符
- en: Other UNIX implementations provide terminal special characters in addition to
    those listed in [Table 62-1](ch62.html#terminal_special_characters-id1 "Table 62-1. Terminal
    special characters").
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 UNIX 实现除了 [表 62-1](ch62.html#terminal_special_characters-id1 "表 62-1. 终端特殊字符")
    中列出的字符外，还提供了其他终端特殊字符。
- en: BSD provides the DSUSP and STATUS characters. The DSUSP character (typically
    *Control-Y*) operates in a fashion similar to the SUSP character, but suspends
    the foreground process group only when it attempts to read the character (i.e.,
    after all preceding input has been read). Several non-BSD-derived implementations
    also provide the DSUSP character.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: BSD 提供了 DSUSP 和 STATUS 字符。DSUSP 字符（通常是*Control-Y*）的作用与 SUSP 字符相似，但仅当前台进程组尝试读取字符时才会暂停（即在读取完所有前面的输入之后）。一些非
    BSD 衍生的实现也提供了 DSUSP 字符。
- en: The STATUS character (typically *Control-T*) causes the kernel to display status
    information on the terminal (including the state of the foreground process and
    how much CPU time it has consumed), and sends a `SIGINFO` signal to the foreground
    process group. If desired, processes can catch this signal and display further
    status information. (Linux provides a vaguely similar feature in the form of the
    magic SysRq *key*; see the kernel source file `Documentation/sysrq.txt` for details.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: STATUS 字符（通常是*Control-T*）使内核在终端显示状态信息（包括前台进程的状态以及它消耗的 CPU 时间），并向前台进程组发送一个`SIGINFO`信号。如果需要，进程可以捕获这个信号并显示更多的状态信息。（Linux
    提供了一个相似的功能，称为魔术 SysRq *键*；详情请参见内核源文件 `Documentation/sysrq.txt`。）
- en: System V derivatives provide the SWTCH character. This character is used to
    switch shells under *shell layers*, a System V predecessor to job control.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: System V 衍生版本提供了 SWTCH 字符。这个字符用于在*shell 层*之间切换，这是 System V 的前身，用于作业控制。
- en: Example program
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 62-1](ch62.html#changing_the_terminal_interrupt_characte "Example 62-1. Changing
    the terminal interrupt character") shows the use of *tcgetattr()* and *tcsetattr()*
    to change the terminal *interrupt* character. This program sets the *interrupt*
    character to be the character whose numeric value is supplied as the program’s
    command-line argument, or disables the *interrupt* character if no command-line
    argument is supplied.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例62-1](ch62.html#changing_the_terminal_interrupt_characte "示例62-1. 更改终端中断字符")展示了使用*tcgetattr()*和*tcsetattr()*来更改终端*中断*字符。这个程序将*中断*字符设置为命令行参数中提供的数字值对应的字符，或者如果没有提供命令行参数，则禁用*中断*字符。'
- en: 'The following shell session demonstrates the use of this program. We begin
    by setting the *interrupt* character to *Control-L* (ASCII 12), and then verify
    the change with *stty*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell会话演示了此程序的使用。我们首先将*中断*字符设置为*Control-L*（ASCII 12），然后使用*stty*验证更改：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We then start a process running *sleep(1)*. We find that typing *Control-C*
    no longer has its usual effect of terminating a process, but typing *Control-L*
    does terminate the process.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们启动一个执行*sleep(1)*的进程。我们发现，按下*Control-C*不再像通常那样终止进程，但按下*Control-L*确实会终止该进程。
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We now display the value of the shell $? variable, which shows the termination
    status of the last command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在显示shell的$?变量值，该值显示最后一条命令的终止状态：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We see that the termination status of the process was 130\. This indicates that
    the process was killed by signal 130 - 128 = 2; signal number 2 is `SIGINT`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到进程的终止状态为130。这表示进程被信号130 - 128 = 2杀死；信号2是`SIGINT`。
- en: Next, we use our program to disable the *interrupt* character.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用我们的程序禁用*中断*字符。
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we find that neither *Control-C* nor *Control-L* generates a `SIGINT` signal,
    and we must instead use *Control-\* to terminate a program:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们发现*Control-C*和*Control-L*都不会产生`SIGINT`信号，我们必须改用*Control-\*来终止程序：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Example 62-1. Changing the terminal *interrupt* character
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 示例62-1. 更改终端*中断*字符
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Terminal Flags
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端标志
- en: '[Table 62-2](ch62.html#terminal_flags-id1 "Table 62-2. Terminal flags") lists
    the settings controlled by each of the four flag fields of the *termios* structure.
    The constants listed in this table correspond to single bits, except those specifying
    the term *mask*, which are values spanning several bits; these may contain one
    of a range of values, shown in parentheses. The column labeled *SUSv3* indicates
    whether the flag is specified in SUSv3\. The *Default* column shows the default
    settings for a virtual console login.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[表62-2](ch62.html#terminal_flags-id1 "表62-2. 终端标志")列出了由*termios*结构的四个标志字段控制的设置。此表中列出的常量对应单个位，除非是指定*掩码*的项，它们是跨越多个比特的值；这些值可能包含一个范围内的值，括号内列出了这些范围。标有*SUSv3*的列指示该标志是否在SUSv3中指定。*默认*列显示虚拟控制台登录的默认设置。'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Many shells that provide command-line editing facilities perform their own manipulations
    of the flags listed in [Table 62-2](ch62.html#terminal_flags-id1 "Table 62-2. Terminal
    flags"). This means that if we try using *stty(1)* to experiment with these settings,
    then the changes may not be effective when entering shell commands. To circumvent
    this behavior, we must disable command-line editing in the shell. For example,
    command-line editing can be disabled by specifying the command-line option —*noediting*
    when invoking *bash*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 许多提供命令行编辑功能的shell会对[表62-2](ch62.html#terminal_flags-id1 "表62-2. 终端标志")中列出的标志进行自己的处理。这意味着，如果我们尝试使用*stty(1)*来实验这些设置，那么在输入shell命令时，修改可能不起作用。为了避免这种行为，我们必须禁用shell中的命令行编辑。例如，可以通过在调用*bash*时指定命令行选项—*noediting*来禁用命令行编辑。
- en: Table 62-2. Terminal flags
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表62-2. 终端标志
- en: '| Field/Flag | Description | Default | SUSv3 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 字段/标志 | 描述 | 默认 | SUSv3 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| *c_iflag* |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| *c_iflag* |'
- en: '| `BRKINT` | Signal interrupt (`SIGINT`) on BREAK condition | on | • |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `BRKINT` | 在BREAK条件下发送中断信号（`SIGINT`） | on | • |'
- en: '| `ICRNL` | Map CR to NL on input | on | • |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `ICRNL` | 将CR映射为NL输入 | on | • |'
- en: '| `IGNBRK` | Ignore BREAK condition | off | • |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `IGNBRK` | 忽略BREAK条件 | off | • |'
- en: '| `IGNCR` | Ignore CR on input | off | • |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `IGNCR` | 忽略输入中的CR | off | • |'
- en: '| `IGNPAR` | Ignore characters with parity errors | off | • |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `IGNPAR` | 忽略具有奇偶校验错误的字符 | off | • |'
- en: '| `IMAXBEL` | Ring bell when terminal input queue is full (unused) | (on) |
      |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `IMAXBEL` | 当终端输入队列满时响铃（未使用） | (on) |   |'
- en: '| `INLCR` | Map NL to CR on input | off | • |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `INLCR` | 将NL映射为CR输入 | off | • |'
- en: '| `INPCK` | Enable input parity checking | off | • |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `INPCK` | 启用输入奇偶校验检查 | off | • |'
- en: '| `ISTRIP` | Strip high bit (bit 8) from input characters | off | • |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `ISTRIP` | 从输入字符中去除高位（第 8 位） | 关 | • |'
- en: '| `IUTF8` | Input is UTF-8 (since Linux 2.6.4) | off |   |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `IUTF8` | 输入为 UTF-8（自 Linux 2.6.4 起） | 关 |   |'
- en: '| `IUCLC` | Map uppercase to lowercase on input (if `IEXTEN` also set) | off
    |   |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `IUCLC` | 在输入时将大写字母映射为小写字母（如果同时设置了 `IEXTEN`） | 关 |   |'
- en: '| `IXANY` | Allow any character to restart stopped output | off | • |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `IXANY` | 允许任何字符重新启动停止的输出 | 关 | • |'
- en: '| `IXOFF` | Enable start/stop input flow control | off | • |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `IXOFF` | 启用输入流控制的开始/停止 | 关 | • |'
- en: '| `IXON` | Enable start/stop output flow control | on | • |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `IXON` | 启用开始/停止输出流控制 | 开 | • |'
- en: '| `PARMRK` | Mark parity errors (with 2 prefix bytes: 0377 + 0) | off | • |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `PARMRK` | 标记奇偶校验错误（前缀字节：0377 + 0） | 关 | • |'
- en: '| *c_oflag* |   |   |   |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| *c_oflag* |   |   |   |'
- en: '| `BSDLY` | Backspace delay mask (`BS0`, `BS1`) | `BS0` | • |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `BSDLY` | 退格延迟掩码（`BS0`，`BS1`） | `BS0` | • |'
- en: '| `CRDLY` | CR delay mask (`CR0`, `CR1`, `CR2`, `CR3`) | `CR0` | • |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `CRDLY` | CR 延迟掩码（`CR0`，`CR1`，`CR2`，`CR3`） | `CR0` | • |'
- en: '| `FFDLY` | Form-feed delay mask (`FF0`, `FF1`) | `FF0` | • |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `FFDLY` | 换页延迟掩码（`FF0`，`FF1`） | `FF0` | • |'
- en: '| `NLDLY` | Newline delay mask (`NL0`, `NL1`) | `NL0` | • |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `NLDLY` | 换行延迟掩码（`NL0`，`NL1`） | `NL0` | • |'
- en: '| `OCRNL` | Map CR to NL on output (see also `ONOCR`) | off | • |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `OCRNL` | 将 CR 映射为 NL 输出（参见 `ONOCR`） | 关 | • |'
- en: '| `OFDEL` | Use DEL (0177) as fill character; otherwise NUL (0) | off | • |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `OFDEL` | 使用 DEL（0177）作为填充字符；否则使用 NUL（0） | 关 | • |'
- en: '| `OFILL` | Use fill characters for delay (rather than timed delay) | off |
    • |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `OFILL` | 使用填充字符进行延迟（而不是定时延迟） | 关 | • |'
- en: '| `OLCUC` | Map lowercase to uppercase on output | off |   |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `OLCUC` | 在输出时将小写字母映射为大写字母 | 关 |   |'
- en: '| `ONLCR` | Map NL to CR-NL on output | on | • |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `ONLCR` | 在输出时将 NL 映射为 CR-NL | 开 | • |'
- en: '| `ONLRET` | Assume NL performs CR function (move to start of line) | off |
    • |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `ONLRET` | 假定 NL 执行 CR 功能（移动到行首） | 关 | • |'
- en: '| `ONOCR` | Don’t output CR if already at column 0 (start of line) | off |
    • |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `ONOCR` | 如果已经在第 0 列（行首），则不输出 CR | 关 | • |'
- en: '| `OPOST` | Perform output postprocessing | on | • |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `OPOST` | 执行输出后处理 | 开 | • |'
- en: '| `TABDLY` | Horizontal-tab delay mask (`TAB0`, `TAB1`, `TAB2`, `TAB3`) | `TAB0`
    | • |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `TABDLY` | 水平制表符延迟掩码（`TAB0`，`TAB1`，`TAB2`，`TAB3`） | `TAB0` | • |'
- en: '| `VTDLY` | Vertical-tab delay mask (`VT0`, `VT1`) | `VT0` | • |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `VTDLY` | 垂直制表符延迟掩码（`VT0`，`VT1`） | `VT0` | • |'
- en: '| *c_cflag* |   |   |   |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| *c_cflag* |   |   |   |'
- en: '| `CBAUD` | Baud (bit rate) mask (`B0`, `B2400`, `B9600`, and so on) | `B38400`
    |   |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `CBAUD` | 波特率掩码（`B0`，`B2400`，`B9600` 等） | `B38400` |   |'
- en: '| `CBAUDEX` | Extended baud (bit rate) mask (for rates > 38,400) | off |  
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `CBAUDEX` | 扩展波特率（大于 38,400 的速率）掩码 | 关 |   |'
- en: '| `CIBAUD` | Input baud (bit rate), if different from output (unused) | (off)
    |   |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `CIBAUD` | 输入波特率（如果与输出不同）（未使用） | （关） |   |'
- en: '| `CLOCAL` | Ignore modem status lines (don’t check carrier signal) | off |
    • |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `CLOCAL` | 忽略调制解调器状态行（不检查载波信号） | 关 | • |'
- en: '| `CMSPAR` | Use “stick” (mark/space) parity | off |   |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `CMSPAR` | 使用“标记” (mark/space) 奇偶校验 | 关 |   |'
- en: '| `CREAD` | Allow input to be received | on | • |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `CREAD` | 允许接收输入 | 开 | • |'
- en: '| `CRTSCTS` | Enable RTS/CTS (hardware) flow control | off |   |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `CRTSCTS` | 启用 RTS/CTS（硬件）流控制 | 关 |   |'
- en: '| `CSIZE` | Character-size mask (5 to 8 bits: `CS5`, `CS6`, `CS7`, `CS8`) |
    `CS8` | • |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `CSIZE` | 字符大小掩码（5 到 8 位：`CS5`，`CS6`，`CS7`，`CS8`） | `CS8` | • |'
- en: '| `CSTOPB` | Use 2 stop bits per character; otherwise 1 | off | • |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `CSTOPB` | 每个字符使用 2 个停止位；否则使用 1 个 | 关 | • |'
- en: '| `HUPCL` | Hang up (drop modem connection) on last close | on | • |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `HUPCL` | 在最后一次关闭时挂断（断开调制解调器连接） | 开 | • |'
- en: '| `PARENB` | Parity enable | off | • |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `PARENB` | 启用奇偶校验 | 关 | • |'
- en: '| `PARODD` | Use odd parity; otherwise even | off | • |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `PARODD` | 使用奇校验；否则使用偶校验 | 关 | • |'
- en: '| *c_lflag* |   |   |   |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| *c_lflag* |   |   |   |'
- en: '| `ECHO` | Echo input characters | on | • |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `ECHO` | 回显输入字符 | 开 | • |'
- en: '| `ECHOCTL` | Echo control characters visually (e.g., `^L`) | on |   |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `ECHOCTL` | 以可视方式回显控制字符（例如，`^L`） | 开 |   |'
- en: '| `ECHOE` | Perform ERASE visually | on | • |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `ECHOE` | 执行可视化擦除 | 开 | • |'
- en: '| `ECHOK` | Echo KILL visually | on | • |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `ECHOK` | 回显 KILL 字符 | 开 | • |'
- en: '| `ECHOKE` | Don’t output a newline after echoed KILL | on |   |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `ECHOKE` | 回显 KILL 后不输出换行符 | 开 |   |'
- en: '| `ECHONL` | Echo NL (in canonical mode) even if echoing is disabled | off
    | • |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `ECHONL` | 在规范模式下，即使回显被禁用，也回显 NL | 关 | • |'
- en: '| `ECHOPRT` | Echo deleted characters backward (between `\` and `/`) | off
    |   |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `ECHOPRT` | 回显删除字符（在 `\` 和 `/` 之间） | 关 |   |'
- en: '| `FLUSHO` | Output is being flushed (unused) | - |   |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `FLUSHO` | 输出正在刷新（未使用） | - |   |'
- en: '| `ICANON` | Canonical mode (line-by-line) input | on | • |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `ICANON` | 规范模式（逐行）输入 | 开 | • |'
- en: '| `IEXTEN` | Enable extended processing of input characters | on | • |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `IEXTEN` | 启用输入字符的扩展处理 | 开 | • |'
- en: '| `ISIG` | Enable signal-generating characters (INTR, QUIT, SUSP) | on | •
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `ISIG` | 启用生成信号的字符（INTR、QUIT、SUSP） | 开 | • |'
- en: '| `NOFLSH` | Disable flushing on INTR, QUIT, and SUSP | off | • |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `NOFLSH` | 禁用在 INTR、QUIT 和 SUSP 信号下的刷新操作 | 关 | • |'
- en: '| `PENDIN` | Redisplay pending input at next read (not implemented) | (off)
    |   |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `PENDIN` | 在下一次读取时重新显示待处理输入（未实现） | （关） |   |'
- en: '| `TOSTOP` | Generate `SIGTTOU` for background output ([Using Job Control Within
    the Shell](ch34.html#using_job_control_within_the_shell "Using Job Control Within
    the Shell")) | off | • |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `TOSTOP` | 为后台输出生成 `SIGTTOU` 信号 ([在 Shell 中使用作业控制](ch34.html#using_job_control_within_the_shell
    "在 Shell 中使用作业控制")) | 关 | • |'
- en: '| `XCASE` | Canonical upper/lowercase presentation (unimplemented) | (off)
    |   |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `XCASE` | 规范的大写/小写显示（未实现） | （关） |   |'
- en: 'Several of the flags listed in [Table 62-2](ch62.html#terminal_flags-id1 "Table 62-2. Terminal
    flags") were provided for historical terminals with limited capabilities, and
    these flags have little use on modern systems. For example, the `IUCLC`, `OLCUC`,
    and `XCASE` flags were used with terminals that were capable of displaying only
    uppercase letters. On many older UNIX systems, if a user tried logging in with
    an uppercase username, the *login* program assumed that the user was sitting at
    such a terminal and would set these flags, and then the following password prompt
    would appear:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 62-2](ch62.html#terminal_flags-id1 "表 62-2. 终端标志")中列出的一些标志是为历史上具有有限功能的终端提供的，这些标志在现代系统中几乎没有用处。例如，`IUCLC`、`OLCUC`
    和 `XCASE` 标志曾用于只能显示大写字母的终端。在许多较老的 UNIX 系统上，如果用户尝试使用大写用户名登录，*login* 程序会假设用户正坐在此类终端上，并设置这些标志，接着会出现如下密码提示：'
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From this point on, all lowercase characters were output in uppercase, and real
    uppercase characters were preceded by a backslash (\). Similarly, for input, a
    real uppercase character could be specified by a preceding backslash. The `ECHOPRT`
    flag was also designed for limited-capability terminals.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，所有的小写字母都将以大写字母形式输出，真正的大写字母会前面加上反斜杠（\）。类似地，对于输入，真正的大写字母也可以通过前面加上反斜杠来指定。`ECHOPRT`
    标志也是为有限功能的终端设计的。
- en: The various delay masks are also historical, allowing for terminals and printers
    that took longer to echo characters such as carriage return and form feed. The
    related `OFILL` and `OFDEL` flags specified how such a delay was to be performed.
    Most of these flags are unused on Linux. One exception is the `TAB3` setting for
    the `TABDLY` mask, which causes tab characters to be output as (up to eight) spaces.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 各种延迟掩码也是历史遗留的，用于支持那些回显字符较慢的终端和打印机，例如回车符和换页符。相关的 `OFILL` 和 `OFDEL` 标志指定了如何执行这种延迟。大多数这些标志在
    Linux 上未使用。一个例外是 `TAB3` 设置，它属于 `TABDLY` 掩码，会将制表符输出为（最多八个）空格。
- en: The following paragraphs provide more details about some of the *termios* flags.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下段落提供了一些 *termios* 标志的更多细节。
- en: BRKINT
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BRKINT
- en: If the `BRKINT` flag is set and the `IGNBRK` flag is not set, then a `SIGINT`
    signal is sent to the foreground process group when a BREAK condition occurs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `BRKINT` 标志，并且没有设置 `IGNBRK` 标志，则当发生 BREAK 条件时，会向前台进程组发送 `SIGINT` 信号。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most conventional dumb terminals provided a *BREAK* key. Pressing this key doesn’t
    actually generate a character, but instead causes a *BREAK condition*, whereby
    a series of 0 bits is sent to the terminal driver for a specified length of time,
    typically 0.25 or 0.5 seconds (i.e., longer than the time required to transmit
    a single byte). (Unless the `IGNBRK` flag has been set, the terminal driver consequently
    delivers a single 0 byte to the reading process.) On many UNIX systems, the BREAK
    condition acted as a signal to a remote host to change its line speed (baud) to
    something suitable for the terminal. Thus, the user would press the *BREAK* key
    until a valid login prompt appeared, indicating that the line speed was now suitable
    for this terminal.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传统的傻瓜终端提供了一个*BREAK*键。按下该键实际上不会生成字符，而是触发一个*BREAK条件*，即向终端驱动程序发送一系列 0 位，持续指定时间，通常为
    0.25 或 0.5 秒（即，比传输一个字节的时间要长）。(除非设置了 `IGNBRK` 标志，否则终端驱动程序会向读取进程传送一个 0 字节。）在许多 UNIX
    系统上，BREAK 条件充当信号，通知远程主机将线路速度（波特率）调整为适合终端的速度。因此，用户会按下 *BREAK* 键，直到出现有效的登录提示，表明线路速度现在适合该终端。
- en: On a virtual console, we can generate a BREAK condition by pressing *Control-Break*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟控制台上，我们可以通过按 *Control-Break* 来生成 BREAK 条件。
- en: ECHO
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ECHO
- en: Setting the `ECHO` flag enables echoing of input characters. Disabling echoing
    is useful when reading passwords. Echoing is also disabled within the command
    mode of *vi*, where keyboard characters are interpreted as editing commands rather
    than text input. The `ECHO` flag is effective in both canonical and noncanonical
    modes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`ECHO`标志启用输入字符的回显。禁用回显在读取密码时很有用。在*vi*的命令模式下，回显也会被禁用，因为键盘字符会被解释为编辑命令，而不是文本输入。`ECHO`标志在规范模式和非规范模式下都有效。
- en: ECHOCTL
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ECHOCTL
- en: If `ECHO` is set, then enabling the `ECHOCTL` flag causes control characters
    other than tab, newline, START, and STOP to be echoed in the form `^A` (for *Control-A*),
    and so on. If `ECHOCTL` is disabled, control characters are not echoed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`ECHO`，则启用`ECHOCTL`标志会导致除制表符、换行符、START和STOP外的控制字符以`^A`（例如*Control-A*）的形式回显。如果禁用`ECHOCTL`，则不会回显控制字符。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The control characters are those with ASCII codes less than 32, plus the DEL
    character (127 decimal). A control character, x, is echoed using a caret (`^`)
    followed by the character resulting from the expression (*x ^ 64*). For all characters
    except DEL, the effect of the XOR (`^`) operator in this expression is to add
    64 to the value of the character. Thus, *Control-A* (ASCII 1) is echoed as caret
    plus `A` (ASCII 65). For DEL, the expression has the effect of subtracting 64
    from 127, yielding the value 63, the ASCII code for ?, so that DEL is echoed as
    `^`?.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 控制字符是那些ASCII码小于32的字符，加上DEL字符（十进制127）。控制字符x使用插入符号（`^`）和通过表达式（*x ^ 64*）得出的字符回显。例如，*Control-A*（ASCII
    1）会回显为插入符号加`A`（ASCII 65）。对于DEL，表达式的效果是从127中减去64，得到63，这是问号的ASCII码，因此DEL会回显为`^?`。
- en: ECHOE
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ECHOE
- en: In canonical mode, setting the `ECHOE` flag causes ERASE to be performed visually,
    by outputting the sequence backspace-space-backspace to the terminal. If `ECHOE`
    is disabled, then the ERASE character is instead echoed (e.g., as `^?`), but still
    performs its function of deleting a character.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范模式下，设置`ECHOE`标志会通过输出退格符-空格-退格符的序列，将删除操作可视化地执行。如果禁用`ECHOE`，则删除字符会被回显（例如，显示为`^?`），但仍然执行其删除字符的功能。
- en: '`ECHOK` and `ECHOKE`'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`ECHOK`和`ECHOKE`'
- en: The `ECHOK` and `ECHOKE` flags control the visual display when using the KILL
    (erase line) character in canonical mode. In the default case (both flags enabled),
    a line is erased visually (see `ECHOE`). If either of these flags is disabled,
    then a visual erase is not performed (but the input line is still discarded),
    and the KILL character is echoed (e.g., as `^U`). If `ECHOK` is set, but not `ECHOKE`,
    then a newline character is also output.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`ECHOK`和`ECHOKE`标志控制在规范模式下使用KILL（删除整行）字符时的可视显示。在默认情况下（两个标志都启用），一行会被可视化删除（参见`ECHOE`）。如果这两个标志中的任何一个被禁用，那么就不会执行可视删除（但输入行仍会被丢弃），KILL字符会被回显（例如，显示为`^U`）。如果设置了`ECHOK`，但没有设置`ECHOKE`，则还会输出换行符。'
- en: ICANON
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ICANON
- en: Setting the `ICANON` flag enables canonical mode input. Input is gathered into
    lines, and special interpretation of the EOF, EOL, EOL2, ERASE, LNEXT, KILL, REPRINT,
    and WERASE characters is enabled (but note the effect of the `IEXTEN` flag described
    below).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`ICANON`标志启用规范模式输入。输入会按行收集，并启用对EOF、EOL、EOL2、ERASE、LNEXT、KILL、REPRINT和WERASE字符的特殊解释（但请注意，下面描述的`IEXTEN`标志的效果）。
- en: IEXTEN
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IEXTEN
- en: 'Setting the `IEXTEN` flag enables extended processing of input characters.
    This flag (as well as `ICANON`) must be set in order for the following characters
    to be interpreted: EOL2, LNEXT, REPRINT, and WERASE. The `IEXTEN` flag must also
    be set for the `IUCLC` flag to be effective. SUSv3 merely says that the `IEXTEN`
    flag enables extended (implementation-defined) functions; details may vary on
    other UNIX implementations.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`IEXTEN`标志启用对输入字符的扩展处理。必须同时设置此标志（以及`ICANON`），才能解释以下字符：EOL2、LNEXT、REPRINT和WERASE。`IEXTEN`标志还必须设置，`IUCLC`标志才会生效。SUSv3仅表示`IEXTEN`标志启用扩展的（实现定义的）功能；其他UNIX实现的具体细节可能有所不同。
- en: IMAXBEL
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IMAXBEL
- en: On Linux, the setting of the `IMAXBEL` flag is ignored. On a console login,
    the bell is always rung when the input queue is full.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，`IMAXBEL`标志的设置会被忽略。在控制台登录时，当输入队列已满时，铃声始终会响起。
- en: IUTF8
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IUTF8
- en: Setting the `IUTF8` flag enables cooked mode ([Cooked, Cbreak, and Raw Modes](ch62.html#cooked_comma_cbreak_comma_and_raw_modes
    "Cooked, Cbreak, and Raw Modes")) to correctly handle UTF-8 input when performing
    line editing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`IUTF8`标志启用已处理模式（[Cooked, Cbreak, and Raw Modes](ch62.html#cooked_comma_cbreak_comma_and_raw_modes
    "Cooked, Cbreak, and Raw Modes")）以正确处理UTF-8输入，尤其是在执行行编辑时。
- en: NOFLSH
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NOFLSH
- en: By default, when a signal is generated by typing the INTR, QUIT, or SUSP character,
    any outstanding data in the terminal input and output queues is flushed (discarded).
    Setting the `NOFLSH` flag disables such flushing.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当通过输入 INTR、QUIT 或 SUSP 字符生成信号时，终端输入和输出队列中任何待处理的数据都会被清除（丢弃）。设置 `NOFLSH`
    标志会禁用这种清除。
- en: OPOST
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OPOST
- en: Setting the `OPOST` flag enables output postprocessing. This flag must be set
    in order for any of the flags in the *c_oflag* field of the *termios* structure
    to be effective. (Put conversely, disabling the `OPOST` flag prevents all output
    postprocessing.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `OPOST` 标志启用输出后处理。必须设置此标志才能使 *termios* 结构中的 *c_oflag* 字段中的任何标志生效。（换句话说，禁用
    `OPOST` 标志会阻止所有输出后处理。）
- en: PARENB, IGNPAR, INPCK, PARMRK, and PARODD
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PARENB、IGNPAR、INPCK、PARMRK 和 PARODD
- en: The `PARENB`, `IGNPAR`, `INPCK`, `PARMRK`, and `PARODD` flags are concerned
    with parity generation and checking.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`PARENB`、`IGNPAR`、`INPCK`、`PARMRK` 和 `PARODD` 标志涉及到奇偶校验的生成和检查。'
- en: The `PARENB` flag enables generation of parity check bits for output characters
    and parity checking for input characters. If we want to perform only output parity
    generation, then we can disable input parity checking by turning `INPCK` off.
    If the `PARODD` flag is set, then odd parity is used in both cases; otherwise,
    even parity is used.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`PARENB` 标志启用输出字符的奇偶校验位生成和输入字符的奇偶校验检查。如果只需要执行输出奇偶校验生成，可以通过关闭 `INPCK` 来禁用输入奇偶校验检查。如果设置了
    `PARODD` 标志，则在两种情况下都使用奇数奇偶校验；否则，使用偶数奇偶校验。'
- en: The remaining flags specify how an input character with parity errors should
    be handled. If the `IGNPAR` flag is set, the character is discarded (not passed
    to the reading process). Otherwise, if the `PARMRK` flag is set, then the character
    is passed to the reading process, but is preceded by the 2-byte sequence 0377
    + 0\. (If the `PARMRK` flag is set and `ISTRIP` is clear, then a real 0377 character
    is doubled to become 0377 + 0377.) If `PARMRK` is not set, but `INPCK` is set,
    then the character is discarded, and a 0 byte is passed to the reading process
    instead. If none of `IGNPAR`, `PARMRK`, or `INPCK` is set, then the character
    is passed as is to the reading process.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的标志指定了如何处理带有奇偶校验错误的输入字符。如果设置了 `IGNPAR` 标志，则丢弃该字符（不传递给读取进程）。否则，如果设置了 `PARMRK`
    标志，则将该字符传递给读取进程，但前面会加上 2 字节的序列 0377 + 0。 （如果设置了 `PARMRK` 标志且 `ISTRIP` 未设置，则会将实际的
    0377 字符加倍，变为 0377 + 0377。）如果未设置 `PARMRK`，但设置了 `INPCK`，则丢弃该字符，并传递一个 0 字节给读取进程。如果
    `IGNPAR`、`PARMRK` 或 `INPCK` 均未设置，则直接将该字符传递给读取进程。
- en: Example program
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 62-2](ch62.html#disabling_terminal_echoing "Example 62-2. Disabling
    terminal echoing") demonstrates the use of *tcgetattr()* and *tcsetattr()* to
    turn off the `ECHO` flag, so that input characters are not echoed. Here is an
    example of what we see when running this program:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 62-2](ch62.html#disabling_terminal_echoing "示例 62-2：禁用终端回显") 演示了如何使用 *tcgetattr()*
    和 *tcsetattr()* 关闭 `ECHO` 标志，从而使输入字符不被回显。以下是运行此程序时的示例输出：'
- en: '[PRE18]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Example 62-2. Disabling terminal echoing
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 62-2：禁用终端回显
- en: '[PRE19]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Terminal I/O Modes
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端 I/O 模式
- en: We have already noted that the terminal driver is capable of handling input
    in either canonical or noncanonical mode, depending on the setting of the `ICANON`
    flag. We now describe these two modes in detail. We then describe three useful
    terminal modes—cooked, cbreak, and raw—that were available in Seventh Edition
    UNIX, and show how these modes are emulated on modern UNIX systems by setting
    appropriate values in the *termios* structure.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过，终端驱动程序能够根据 `ICANON` 标志的设置，处理规范模式或非规范模式的输入。接下来我们将详细描述这两种模式。然后，我们会介绍三种在第七版
    UNIX 中可用的有用终端模式——cooked、cbreak 和 raw，并展示如何通过在 *termios* 结构中设置适当的值，在现代 UNIX 系统中模拟这些模式。
- en: Canonical Mode
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范模式
- en: 'Canonical mode input is enabled by setting the `ICANON` flag. Terminal input
    in canonical mode is distinguished by the following features:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置 `ICANON` 标志启用规范模式输入。规范模式下的终端输入具有以下特点：
- en: 'Input is gathered into lines, terminated by one of the line-delimiter characters:
    NL, EOL, EOL2 (if the `IEXTEN` flag is set), EOF (at anything other than the initial
    position in the line), or CR (if the `ICRNL` flag is enabled). Except in the case
    of EOF, the line delimiter is passed back to the reading process (as the last
    character in the line).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入会被收集成行，并以以下行分隔符字符之一结束：NL、EOL、EOL2（如果设置了 `IEXTEN` 标志）、EOF（在行中的非初始位置处）、或 CR（如果启用了
    `ICRNL` 标志）。除非是 EOF，否则行分隔符会作为行中的最后一个字符返回给读取进程。
- en: 'Line editing is enabled, so that the current line of input can be modified.
    Thus, the following characters are enabled: ERASE, KILL, and, if the `IEXTEN`
    flag is set, WERASE.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用行编辑，因此可以修改当前的输入行。因此，以下字符将启用：ERASE、KILL，如果设置了 `IEXTEN` 标志，则启用 WERASE。
- en: If the `IEXTEN` flag is set, the REPRINT and LNEXT characters are also enabled.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设置了 `IEXTEN` 标志，则 REPRINT 和 LNEXT 字符也会启用。
- en: In canonical mode, a terminal *read()* returns when a complete line of input
    is available. (The *read()* itself may fetch only part of that line if it requested
    fewer bytes; remaining bytes will be fetched by subsequent calls to *read()*.)
    A *read()* may also terminate if interrupted by a signal handler and restarting
    of system calls is not enabled for this signal ([Interruption and Restarting of
    System Calls](ch21.html#interruption_and_restarting_of_system_ca "Interruption
    and Restarting of System Calls")).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范模式下，当一行完整的输入数据可用时，终端 *read()* 会返回。（如果请求的字节数较少，*read()* 可能只获取该行的一部分；剩余字节将在后续的
    *read()* 调用中获取。）如果在信号处理程序中被中断且未启用该信号的系统调用重启功能，*read()* 也可能终止（[信号的中断与系统调用的重启](ch21.html#interruption_and_restarting_of_system_ca
    "Interruption and Restarting of System Calls")）。
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While describing the `NOFLSH` flag in [Terminal Flags](ch62.html#terminal_flags
    "Terminal Flags"), we noted that the characters that generate signals also cause
    the terminal driver to flush the terminal input queue. This flushing occurs regardless
    of whether the signal is caught or ignored by an application. We can prevent such
    flushing by enabling the `NOFLSH` flag.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述 [终端标志](ch62.html#terminal_flags "Terminal Flags")中的 `NOFLSH` 标志时，我们提到会生成信号的字符还会导致终端驱动程序刷新终端输入队列。这种刷新发生时，不管应用程序是否捕获或忽略了信号。我们可以通过启用
    `NOFLSH` 标志来防止这种刷新。
- en: Noncanonical Mode
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非规范模式
- en: Some applications (e.g., *vi* and *less*) need to read characters from the terminal
    without the user supplying a line delimiter. Noncanonical mode is provided for
    this purpose. In noncanonical mode (`ICANON` unset), no special input processing
    is performed. In particular, input is no longer gathered into lines, but is instead
    available immediately.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序（例如 *vi* 和 *less*）需要从终端读取字符，而不要求用户提供行定界符。为此提供了非规范模式。在非规范模式下（`ICANON` 未设置），不会执行特殊的输入处理。特别地，输入不再被聚集为行，而是可以立即获取。
- en: 'In what circumstances does a noncanonical *read()* complete? We can specify
    that a noncanonical *read()* terminates after a certain time, after a certain
    number of bytes have been read, or both in combination. Two elements of the *termios
    c_cc* array determine the behavior: TIME and MIN. The TIME element (indexed using
    the constant `VTIME`) specifies a timeout value in tenths of a second. The MIN
    element (indexed using `VMIN`) specifies the minimum number of bytes to be read.
    (The MIN and TIME settings have no effect on canonical-mode terminal I/O.)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么情况下，非规范的 *read()* 会完成？我们可以指定非规范 *read()* 在一定时间后完成，或者在读取一定数量的字节后完成，或者两者结合使用。*termios
    c_cc* 数组的两个元素决定了行为：TIME 和 MIN。TIME 元素（使用常量 `VTIME` 索引）指定以十分之一秒为单位的超时值。MIN 元素（使用
    `VMIN` 索引）指定要读取的最小字节数。（MIN 和 TIME 设置对规范模式终端 I/O 没有影响。）
- en: The precise operation and interaction of the MIN and TIME parameters depends
    on whether they each have nonzero values. The four possible cases are described
    below. Note that in all cases, if, at the time of a *read()*, sufficient bytes
    are already available to satisfy the requirements specified by MIN, *read()* returns
    immediately with the lesser of the number of bytes available and the number of
    bytes requested.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: MIN 和 TIME 参数的精确操作和相互作用取决于它们是否具有非零值。下面描述了四种可能的情况。请注意，在所有情况下，如果在进行 *read()* 时，已经有足够的字节可用以满足
    MIN 指定的要求，*read()* 会立即返回可用字节数和请求字节数中的较小值。
- en: MIN == 0, TIME == 0 (polling read)
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MIN == 0，TIME == 0（轮询读取）
- en: If data is available at the time of the call, then *read()* returns immediately
    with the lesser of the number of bytes available or the number of bytes requested.
    If no bytes are available, *read()* completes immediately, returning 0.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用时数据可用，*read()* 会立即返回可用字节数和请求字节数中的较小值。如果没有可用字节，*read()* 会立即完成并返回 0。
- en: This case serves the usual requirements of polling, allowing the application
    to check if input is available without blocking if it is not. This mode is somewhat
    similar to setting the `O_NONBLOCK` flag for the terminal ([Nonblocking I/O](ch05.html#nonblocking_i_solidus_o
    "Nonblocking I/O")). However, with `O_NONBLOCK`, if no bytes are available for
    reading, then *read()* returns -1 with the error `EAGAIN`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况满足了轮询的常见需求，允许应用程序在没有阻塞的情况下检查输入是否可用。如果不可用，则不会阻塞。这种模式与设置终端的 `O_NONBLOCK` 标志有些相似（[非阻塞I/O](ch05.html#nonblocking_i_solidus_o
    "非阻塞I/O")）。然而，使用 `O_NONBLOCK` 时，如果没有可读取的字节，则 *read()* 返回 -1，并且会出现 `EAGAIN` 错误。
- en: MIN > 0, TIME == 0 (blocking read)
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MIN > 0，TIME == 0（阻塞读取）
- en: The *read()* blocks (possibly indefinitely) until the lesser of the number of
    bytes requested or MIN bytes are available, and returns the lesser of the two
    values.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*read()* 会阻塞（可能会无限期阻塞），直到请求的字节数或 MIN 字节的较小值可用，并返回这两个值中的较小者。'
- en: Programs such as *less* typically set MIN to 1 and TIME to 0\. This allows the
    program to wait for single key presses without needing to waste CPU time by polling
    in a busy loop.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 像 *less* 这样的程序通常将 MIN 设置为 1，TIME 设置为 0。这样，程序就可以等待单个按键输入，而无需通过忙循环轮询来浪费 CPU 时间。
- en: If a terminal is placed in noncanonical mode with MIN set to 1 and TIME set
    to 0, then the techniques described in [Chapter 63](ch63.html "Chapter 63. Alternative
    I/O Models") can be used to check whether a single character (rather than a complete
    line) has been typed at the terminal.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果终端处于非规范模式，并将 MIN 设置为 1，TIME 设置为 0，则可以使用 [第63章](ch63.html "第63章. 替代I/O模型")
    中描述的技术检查终端上是否输入了单个字符（而不是完整的一行）。
- en: MIN == 0, TIME > 0 (read with timeout)
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MIN == 0，TIME > 0（带超时读取）
- en: A timer is started when *read()* is called. The call returns as soon as at least
    1 byte is available, or when TIME tenths of a second have elapsed. In the latter
    case, *read()* returns 0.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 *read()* 时，计时器开始计时。只要至少 1 个字节可用，或者 TIME 十分之一秒已经过去，调用就会返回。在后一种情况下，*read()*
    返回 0。
- en: This case is useful for programs talking to a serial device (e.g., a modem).
    The program can send data to the device and then wait for a response, using a
    timeout to avoid hanging forever in case the device doesn’t respond.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况对于与串行设备（例如调制解调器）通信的程序很有用。程序可以向设备发送数据，然后等待响应，使用超时来避免设备没有响应时程序永远挂起。
- en: MIN > 0, TIME > 0 (read with interbyte timeout)
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MIN > 0，TIME > 0（带字节间超时读取）
- en: After the initial byte of input becomes available, a timer is restarted as each
    further byte is received. The *read()* returns when either the lesser of MIN bytes
    or the number of bytes requested have been read, or when the time between receiving
    successive bytes exceeds TIME tenths of a second. Since the timer is started only
    after the initial byte becomes available, at least 1 byte is returned. (A *read()*
    can block indefinitely for this case.)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入的初始字节可用后，每当接收到更多字节时，计时器都会重新启动。当读取到 MIN 字节或者请求的字节数时，*read()* 返回，或者当接收到连续字节之间的时间超过
    TIME 十分之一秒时返回。由于计时器仅在初始字节可用后启动，因此至少会返回 1 个字节。（对于这种情况，*read()* 可能会无限期阻塞。）
- en: This case is useful for handling terminal keys that generate escape sequences.
    For example, on many terminals, the left-arrow key generates the 3-character sequence
    consisting of *Escape* followed by `OD`. These characters are transmitted in quick
    succession. Applications handling such sequences need to distinguish the pressing
    of such a key from the situation where the user slowly types each of the characters
    individually. This can be done by performing a *read()* with a small interbyte
    timeout, say 0.2 seconds. Such a technique is used in the command mode of some
    versions of *vi*. (Depending on the length of the timeout, in such applications,
    we may be able to simulate a left-arrow key press by quickly typing the aforementioned
    3-character sequence.)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况对于处理生成转义序列的终端键非常有用。例如，在许多终端上，左箭头键会生成由 *Escape* 后跟 `OD` 组成的 3 字符序列。这些字符是迅速连续传输的。处理此类序列的应用程序需要区分按下此类键与用户缓慢逐个输入字符的情况。这可以通过执行带有小字节间超时的
    *read()* 来完成，例如 0.2 秒。某些版本的 *vi* 编辑器的命令模式中使用了这种技术。（根据超时的长度，在此类应用程序中，我们可能能够通过快速输入上述的
    3 字符序列来模拟左箭头键的按下。）
- en: Portably modifying and restoring MIN and TIME
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可移植地修改和恢复 MIN 和 TIME
- en: For historical compatibility with some UNIX implementations, SUSv3 allows the
    values of the `VMIN` and `VTIME` constants to be the same as `VEOF` and `VEOL`,
    respectively, which means that these elements of the *termios c_cc* array may
    coincide. (On Linux, the values of these constants are distinct.) This is possible
    because `VEOF` and `VEOL` are unused in noncanonical mode. The fact that `VMIN`
    and `VEOF` may have the same value means that caution is needed in a program that
    enters noncanonical mode, sets MIN (typically to 1), and then later returns to
    canonical mode. On return to canonical mode, EOF will no longer have its usual
    value of ASCII 4 (*Control-D*). The portable way to deal with this problem is
    to save a copy of the *termios* settings prior to changing to noncanonical mode,
    and then use this saved structure to return to canonical mode.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与某些 UNIX 实现的历史兼容性，SUSv3 允许`VMIN`和`VTIME`常量的值与`VEOF`和`VEOL`分别相同，这意味着*termios
    c_cc*数组中的这些元素可能会重合。（在 Linux 上，这些常量的值是不同的。）这是可能的，因为`VEOF`和`VEOL`在非标准模式下未被使用。`VMIN`和`VEOF`可能具有相同的值，这意味着在进入非标准模式、设置
    MIN（通常为 1）后再返回标准模式时需要小心。在返回标准模式时，EOF 将不再具有通常的 ASCII 4（*Control-D*）值。处理这个问题的可移植方法是，在切换到非标准模式之前保存*termios*设置的副本，然后使用保存的结构返回标准模式。
- en: Cooked, Cbreak, and Raw Modes
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 烹饪模式、半烹饪模式和原始模式
- en: 'The terminal driver in Seventh Edition UNIX (as well as in early versions of
    BSD) was capable of handling input in three modes: *cooked*, *cbreak*, and *raw*.
    The differences between the three modes are summarized in [Table 62-3](ch62.html#differences_between_cooked_comma_cbreak
    "Table 62-3. Differences between cooked, cbreak, and raw terminal modes").'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 第七版 UNIX（以及早期的 BSD 版本）中的终端驱动程序能够处理三种模式下的输入：*烹饪模式*、*半烹饪模式*和*原始模式*。这三种模式的区别总结在[表
    62-3](ch62.html#differences_between_cooked_comma_cbreak "表 62-3. 烹饪模式、半烹饪模式和原始终端模式的区别")中。
- en: Table 62-3. Differences between cooked, cbreak, and raw terminal modes
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 表 62-3. 烹饪模式、半烹饪模式和原始终端模式的区别
- en: '| Feature | Mode |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 模式 |'
- en: '| --- | --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Cooked | Cbreak | Raw |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 烹饪模式 | 半烹饪模式 | 原始模式 |'
- en: '| --- | --- | --- |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Input available | line by line | char. by char. | char. by char. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 输入可用 | 按行 | 按字符 | 按字符 |'
- en: '| Line-editing? | yes | no | no |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 行编辑？ | 是 | 否 | 否 |'
- en: '| Signal-generating characters interpreted? | yes | yes | no |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 是否解释生成信号的字符？ | 是 | 是 | 否 |'
- en: '| START/STOP interpreted? | yes | yes | no |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 是否解释开始/停止？ | 是 | 是 | 否 |'
- en: '| Other special characters interpreted? | yes | no | no |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 是否解释其他特殊字符？ | 是 | 否 | 否 |'
- en: '| Other input processing performed? | yes | yes | no |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 是否进行其他输入处理？ | 是 | 是 | 否 |'
- en: '| Other output processing performed? | yes | yes | no |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 是否进行其他输出处理？ | 是 | 是 | 否 |'
- en: '| Input echoed? | yes | maybe | no |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 输入回显？ | 是 | 可能 | 否 |'
- en: Cooked mode was essentially canonical mode with all of the default special character
    processing enabled (i.e., interpretation of `CR`, `NL`, and `EOF`; enabling of
    line editing; handling of signal-generating characters; `ICRNL`; `OCRNL`; and
    so on).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 烹饪模式本质上是标准模式，只不过启用了所有默认的特殊字符处理（即：解释`CR`、`NL`和`EOF`；启用行编辑；处理生成信号的字符；`ICRNL`；`OCRNL`；等等）。
- en: 'Raw mode was the converse: noncanonical mode, with all input and output processing,
    as well as echoing, switched off. (An application that needed to ensure that the
    terminal driver makes absolutely no changes to the data transferred across a serial
    line would use this mode.)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 原始模式则相反：它是非标准模式，所有输入输出处理以及回显都被关闭。（一个需要确保终端驱动程序完全不对通过串行线路传输的数据进行任何更改的应用程序会使用这种模式。）
- en: Cbreak mode was intermediate between cooked and raw modes. Input was noncanonical,
    but signal-generating characters were interpreted, and the various input and output
    transformations could still occur (depending on individual flag settings). Cbreak
    mode did not disable echoing, but applications employing this mode would usually
    disable echoing as well. Cbreak mode was useful in screen-handling applications
    (such as *less*) that permitted character-by-character input, but still needed
    to allow interpretation of characters such as INTR, QUIT, and SUSP.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 半烹饪模式介于烹饪模式和原始模式之间。输入是非标准的，但信号生成字符会被解释，并且各种输入输出转换仍然会发生（具体取决于各个标志设置）。半烹饪模式不会禁用回显，但采用这种模式的应用通常会禁用回显。半烹饪模式在处理屏幕的应用程序中很有用（例如*less*），它允许逐字符输入，但仍然需要允许解释像
    INTR、QUIT 和 SUSP 这样的字符。
- en: 'Example: setting raw and cbreak mode'
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例：设置原始模式和半烹饪模式
- en: In the Seventh Edition and the original BSD terminal drivers, it was possible
    to switch to raw or cbreak mode by tweaking single bits (called `RAW` and `CBREAK`)
    in the terminal driver data structures. With the transition to the POSIX *termios*
    interface (now supported on all UNIX implementations), single bits for selecting
    raw and cbreak mode are no longer available, and applications emulating these
    modes must explicitly change the required fields of the *termios* structure. [Example 62-3](ch62.html#switching_a_terminal_to_cbreak_and_raw_m
    "Example 62-3. Switching a terminal to cbreak and raw modes") provides two functions,
    *ttySetCbreak()* and *ttySetRaw()*, that implement the equivalents of these terminal
    modes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在第七版和原始的BSD终端驱动程序中，可以通过调整终端驱动程序数据结构中的单个位（称为`RAW`和`CBREAK`）来切换到原始模式或cbreak模式。随着过渡到POSIX
    *termios*接口（现在所有UNIX实现都支持），用于选择原始模式和cbreak模式的单个位不再可用，模拟这些模式的应用程序必须显式地更改*termios*结构中的相关字段。[示例62-3](ch62.html#switching_a_terminal_to_cbreak_and_raw_m
    "示例62-3. 切换终端到cbreak和原始模式")提供了两个函数，*ttySetCbreak()*和*ttySetRaw()*，它们实现了这些终端模式的等效功能。
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Applications that use the *ncurses* library can call the functions *cbreak()*
    and *raw()*, which perform similar tasks to our functions in [Example 62-3](ch62.html#switching_a_terminal_to_cbreak_and_raw_m
    "Example 62-3. Switching a terminal to cbreak and raw modes").
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*ncurses*库的应用程序可以调用*cbreak()*和*raw()*函数，这些函数执行与[示例62-3](ch62.html#switching_a_terminal_to_cbreak_and_raw_m
    "示例62-3. 切换终端到cbreak和原始模式")中的函数类似的任务。
- en: Example 62-3. Switching a terminal to cbreak and raw modes
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 示例62-3. 切换终端到cbreak和原始模式
- en: '[PRE20]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A program that places the terminal in raw or cbreak mode must be careful to
    return the terminal to a usable mode when it terminates. Among other tasks, this
    entails handling all of the signals that are likely to be sent to the program,
    so that the program is not prematurely terminated. (Job-control signals can still
    be generated from the keyboard in cbreak mode.)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 将终端置于原始模式或cbreak模式的程序必须小心，在终止时将终端恢复到可用模式。除其他任务外，这需要处理所有可能发送到程序的信号，以避免程序被提前终止。（在cbreak模式下，仍然可以从键盘生成作业控制信号。）
- en: 'An example of how to do this is provided in [Example 62-4](ch62.html#demonstrating_cbreak_and_raw_modes
    "Example 62-4. Demonstrating cbreak and raw modes"). This program performs the
    following steps:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现这一点的示例请参见[示例62-4](ch62.html#demonstrating_cbreak_and_raw_modes "示例62-4.
    演示cbreak和原始模式")。该程序执行以下步骤：
- en: Set the terminal to either cbreak mode ![](figs/web/U009.png) or raw mode ![](figs/web/U012.png),
    depending on whether a command-line argument (any string) is supplied ![](figs/web/U008.png).
    The previous terminal settings are saved in the global variable *userTermios*
    ![](figs/web/U001.png).
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据是否提供命令行参数（任何字符串），将终端设置为cbreak模式！[](figs/web/U009.png)或原始模式！[](figs/web/U012.png)。之前的终端设置保存在全局变量*userTermios*中！[](figs/web/U001.png)。
- en: If the terminal was placed in cbreak mode, then signals can be generated from
    the terminal. These signals need to be handled so that terminating or suspending
    the program leaves the terminal in a state that the user expects. The program
    installs the same handler for `SIGQUIT` and `SIGINT` ![](figs/web/U010.png). The
    `SIGTSTP` signal requires special treatment, so a different handler is installed
    for that signal ![](figs/web/U011.png).
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果终端处于cbreak模式，则可以从终端生成信号。这些信号需要被处理，以便终止或挂起程序时，终端保持在用户期望的状态。程序为`SIGQUIT`和`SIGINT`安装相同的处理程序！[](figs/web/U010.png)。`SIGTSTP`信号需要特殊处理，因此为该信号安装了不同的处理程序！[](figs/web/U011.png)。
- en: Install a handler for the `SIGTERM` signal, in order to catch the default signal
    sent by the *kill* command ![](figs/web/U013.png).
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装一个`SIGTERM`信号的处理程序，以捕获*kill*命令发送的默认信号！[](figs/web/U013.png)。
- en: 'Execute a loop that reads characters one at a time from *stdin* and echoes
    them on standard output ![](figs/web/U014.png). The program treats various input
    characters specially before outputting them ![](figs/web/U015.png):'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个循环，从*stdin*中逐个读取字符，并在标准输出上回显它们！[](figs/web/U014.png)。程序在输出之前会特殊处理各种输入字符！[](figs/web/U015.png)：
- en: All letters are converted to lowercase before being output.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有字母在输出之前都会被转换为小写字母。
- en: The newline (`\n`) and carriage return (`\r`) characters are echoed without
    change.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 换行符（`\n`）和回车符（`\r`）字符会被原样回显。
- en: 'Control characters other than the newline and carriage return are echoed as
    a 2-character sequence: caret (`^`) plus the corresponding uppercase letter (e.g.,
    *Control-A* echoes as `^A`).'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了换行符和回车符之外，控制字符会被回显为2个字符的序列：插入符号（`^`）加上相应的大写字母（例如，*Control-A*回显为`^A`）。
- en: All other characters are echoed as asterisks (`*`).
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他字符都会被回显为星号（`*`）。
- en: The letter *q* causes the loop to terminate ![](figs/web/U016.png).
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母*q*会导致循环终止 ![](figs/web/U016.png)。
- en: On exit from the loop, restore the terminal to its state as last set by the
    user, and then terminate ![](figs/web/U017.png).
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环退出时，将终端恢复到用户上次设置的状态，然后终止程序 ![](figs/web/U017.png)。
- en: The program installs the same handler for `SIGQUIT`, `SIGINT`, and `SIGTERM`.
    This handler restores the terminal to its state as last set by the user and terminates
    the program ![](figs/web/U002.png).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 程序为`SIGQUIT`、`SIGINT`和`SIGTERM`安装了相同的处理程序。该处理程序将终端恢复到用户上次设置的状态并终止程序 ![](figs/web/U002.png)。
- en: 'The handler for the `SIGTSTP` signal ![](figs/web/U003.png) deals with the
    signal in the manner described in [Handling Job-Control Signals](ch34.html#handling_job-control_signals
    "Handling Job-Control Signals"). Note the following additional details of the
    operation of this signal handler:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGTSTP`信号的处理程序 ![](figs/web/U003.png)按照[处理作业控制信号](ch34.html#handling_job-control_signals
    "处理作业控制信号")中描述的方式处理信号。请注意以下信号处理程序的其他操作细节：'
- en: Upon entry, the handler saves the current terminal settings (in *ourTermios*)
    ![](figs/web/U004.png), and then resets the terminal to the settings that were
    in effect (saved in *userTermios*) when the program was started ![](figs/web/U005.png),
    before once more raising `SIGTSTP` to actually stop the process.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入时，处理程序保存当前终端设置（在*ourTermios*中）![](figs/web/U004.png)，然后将终端重置为程序启动时生效的设置（保存在*userTermios*中）![](figs/web/U005.png)，然后再次引发`SIGTSTP`信号以实际停止进程。
- en: Upon resumption of execution after receipt of `SIGCONT`, the handler once more
    saves the current terminal settings in *userTermios* ![](figs/web/U006.png), since
    the user may have changed the settings while the program was stopped (using the
    *stty* command, for example). The handler then returns the terminal to the state
    (*ourTermios*) required by the program ![](figs/web/U007.png).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在收到`SIGCONT`信号后恢复执行时，处理程序再次将当前终端设置保存在*userTermios*中 ![](figs/web/U006.png)，因为用户在程序停止期间可能已更改设置（例如使用*stty*命令）。然后，处理程序将终端恢复到程序所需的状态（*ourTermios*）![](figs/web/U007.png)。
- en: Example 62-4. Demonstrating cbreak and raw modes
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 示例62-4：演示cbreak和原始模式
- en: '[PRE21]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is an example of what we see when we ask the program in [Example 62-4](ch62.html#demonstrating_cbreak_and_raw_modes
    "Example 62-4. Demonstrating cbreak and raw modes") to use raw mode:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在请求程序使用原始模式时看到的示例，参考[示例62-4](ch62.html#demonstrating_cbreak_and_raw_modes
    "示例62-4：演示cbreak和原始模式")：
- en: '[PRE22]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the last line of the preceding shell session, we see that the shell printed
    its prompt on the same line as the *q* character that caused the program to terminate.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述Shell会话的最后一行，我们看到Shell在与程序终止的*q*字符同一行打印了提示符。
- en: 'The following shows an example run using cbreak mode:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用cbreak模式的示例运行：
- en: '[PRE23]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Terminal Line Speed (Bit Rate)
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端线路速度（比特率）
- en: Different terminals (and serial lines) are capable of transmitting and receiving
    at different speeds (bits per second). The *cfgetispeed()* and *cfsetispeed()*
    functions retrieve and modify the input line speed. The *cfgetospeed()* and *cfsetospeed()*
    functions retrieve and modify the output line speed.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的终端（和串行线路）能够以不同的速度（比特每秒）进行传输和接收。*cfgetispeed()*和*cfsetispeed()*函数用于检索和修改输入线路速度。*cfgetospeed()*和*cfsetospeed()*函数用于检索和修改输出线路速度。
- en: Note
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term *baud* is commonly used as a synonym for the terminal line speed (in
    bits per second), although this usage is not technically correct. Precisely, baud
    is the per-second rate at which signal changes can occur on the line, which is
    not necessarily the same as the number of bits transmitted per second, since the
    latter depends on how bits are encoded into signals. Nevertheless, the term *baud*
    continues to be used synonymously with *bit rate* (bits per second). (The term
    *baud rate* is often also used synonymously with *baud*, but this is redundant;
    the baud is by definition a rate.) To avoid confusion, we’ll generally use terms
    like *line speed* or *bit rate*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '*baud*一词通常用作终端行速（每秒比特数）的同义词，尽管这种用法在技术上不完全正确。严格来说，baud是信号变化可以在每秒发生的速率，这不一定等同于每秒传输的比特数，因为后者取决于如何将比特编码为信号。然而，*baud*一词仍然与*比特率*（每秒比特数）同义使用。（*baud
    rate*一词也常常与*baud*同义使用，但这是冗余的；因为根据定义，baud本身就是一种速率。）为了避免混淆，我们通常使用*行速*或*比特率*等术语。'
- en: '[PRE24]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return a line speed from given *termios* structure
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 两者从给定的*termios*结构返回行速
- en: '[PRE25]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 两者成功时返回0，失败时返回-1
- en: Each of these functions works on a *termios* structure that must be previously
    initialized by a call to *tcgetattr()*.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些函数都作用于一个*termios*结构，必须通过调用*tcgetattr()*来初始化。
- en: 'For example, to find out the current terminal output line speed, we would do
    the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查找当前终端输出行速，我们可以执行如下操作：
- en: '[PRE26]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we then wanted to change this line speed, we would continue as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要改变这个行速，我们将继续如下操作：
- en: '[PRE27]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The *speed_t* data type is used to store a line speed. Rather than directly
    assigning numeric values for line speeds, a set of symbolic constants (defined
    in `<termios.h>`) is used. These constants define a series of discrete values.
    Some examples of such constants are `B300`, `B2400`, `B9600`, and `B38400`, corresponding,
    respectively, to the line speeds 300, 2400, 9600, and 38,400 bits per second.
    The use of a set of discrete values reflects the fact that terminals are normally
    designed to work with a limited set of different (standardized) line speeds, derived
    from the division of some base rate (e.g., 115,200 is typical on PCs) by integral
    values (e.g., 115,200 / 12 = 9600).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*speed_t*数据类型用于存储行速。为了避免直接为行速分配数值，使用了一组符号常量（在`<termios.h>`中定义）。这些常量定义了一系列离散的值。一些常见常量示例包括`B300`、`B2400`、`B9600`和`B38400`，分别对应于300、2400、9600和38,400比特每秒的行速。使用离散值集反映了终端通常设计为与一组有限的（标准化的）行速工作，这些行速是通过将某些基准速率（例如，115,200在PC上很常见）除以整数值（例如，115,200
    / 12 = 9600）得出的。'
- en: SUSv3 specifies that the terminal line speeds are stored in the *termios* structure,
    but (deliberately) does not specify where. Many implementations, including Linux,
    maintain these values in the *c_cflag* field, using the `CBAUD` mask and the `CBAUDEX`
    flag. (In [Retrieving and Modifying Terminal Attributes](ch62.html#retrieving_and_modifying_terminal_attrib
    "Retrieving and Modifying Terminal Attributes"), we noted that the nonstandard
    *c_ispeed* and *c_ospeed* fields of the Linux *termios* structure are unused.)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，终端行速存储在*termios*结构中，但（故意）没有指定存储位置。许多实现，包括Linux，维护这些值在*c_cflag*字段中，使用`CBAUD`掩码和`CBAUDEX`标志。（在[检索和修改终端属性](ch62.html#retrieving_and_modifying_terminal_attrib
    "Retrieving and Modifying Terminal Attributes")中，我们提到Linux的*termios*结构中的非标准*c_ispeed*和*c_ospeed*字段未使用。）
- en: Although the *cfsetispeed()* and *cfsetospeed()* functions allow separate input
    and output line speeds to be specified, on many terminals, these two speeds must
    be the same. Furthermore, Linux uses only a single field to store the line speed
    (i.e., the two rates are assumed to be always the same), which means that all
    of the input and output line-speed functions access the same *termios* field.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*cfsetispeed()*和*cfsetospeed()*函数允许分别指定输入和输出行速，但在许多终端上，这两个速率必须相同。此外，Linux只使用一个字段来存储行速（即假定这两个速率始终相同），这意味着所有的输入和输出行速函数都访问相同的*termios*字段。
- en: Note
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Specifying *speed* as 0 in a call to *cfsetispeed()* means “set the input speed
    to whatever the output speed is when *tcsetattr()* is later called.” This is useful
    on systems where the two line speeds are maintained as separate values.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用*cfsetispeed()*时，指定*speed*为0意味着“设置输入速率为稍后调用*tcsetattr()*时的输出速率。”这在输入和输出行速分别作为独立值的系统中非常有用。
- en: Terminal Line Control
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端行控制
- en: The *tcsendbreak()*, *tcdrain()*, *tcflush()*, and *tcflow()* functions perform
    tasks that are usually collectively grouped under the term *line control*. (These
    functions are POSIX inventions designed to replace various *ioctl()* operations.)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcsendbreak()*、*tcdrain()*、*tcflush()* 和 *tcflow()* 函数执行的任务通常被统称为 *行控制*。（这些函数是
    POSIX 发明的，旨在替代各种 *ioctl()* 操作。）'
- en: '[PRE28]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All return 0 on success, or -1 on error
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数成功时返回 0，失败时返回 -1
- en: In each function, *fd* is a file descriptor that refers to a terminal or other
    remote device on a serial line.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个函数中，*fd* 是一个文件描述符，表示指向终端或其他串行线远程设备的描述符。
- en: The *tcsendbreak()* function generates a BREAK condition, by transmitting a
    continuous stream of 0 bits. The *duration* argument specifies the length of the
    transmission. If *duration* is 0, 0 bits are transmitted for 0.25 seconds. (SUSv3
    specifies at least 0.25 and not more than 0.5 seconds.) If *duration* is greater
    than 0, 0 bits are transmitted for *duration* milliseconds. SUSv3 leaves this
    case unspecified; the handling of a nonzero *duration* varies widely on other
    UNIX implementations (the details described here are for *glibc*).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcsendbreak()* 函数通过传输连续的0比特流来生成一个BREAK条件。*duration* 参数指定传输的持续时间。如果 *duration*
    为 0，则在 0.25 秒内传输 0 比特。（SUSv3 规定至少为 0.25 秒，且不超过 0.5 秒。）如果 *duration* 大于 0，则会在 *duration*
    毫秒内传输 0 比特。SUSv3 对此情况没有做具体规定；在其他 UNIX 实现中，非零 *duration* 的处理方式差异较大（此处描述的细节适用于 *glibc*）。'
- en: The *tcdrain()* function blocks until all output has been transmitted (i.e.,
    until the terminal output queue has been emptied).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcdrain()* 函数会阻塞，直到所有输出都已传输完成（即直到终端输出队列被清空）。'
- en: The *tcflush()* function flushes (discards) the data in the terminal input queue,
    the terminal output queue, or both queues (see [Figure 62-1](ch62.html#input_and_output_queues_for_a_terminal_d
    "Figure 62-1. Input and output queues for a terminal device")). Flushing the input
    queue discards data that has been received by the terminal driver but not yet
    read by any process. For example, an application can use *tcflush()* to discard
    terminal type-ahead before prompting for a password. Flushing the output queue
    discards data that has been written (passed to the terminal driver) but not yet
    transmitted to the device. The *queue_selector* argument specifies one of the
    values shown in [Table 62-4](ch62.html#values_for_the_tcflush_open_parenthesis
    "Table 62-4. Values for the tcflush() queue_selector argument").
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcflush()* 函数刷新（丢弃）终端输入队列、终端输出队列或两者的队列中的数据（参见 [图 62-1](ch62.html#input_and_output_queues_for_a_terminal_d
    "图 62-1. 终端设备的输入和输出队列")）。刷新输入队列会丢弃终端驱动程序已接收但尚未被任何进程读取的数据。例如，应用程序可以在提示输入密码前使用 *tcflush()*
    来丢弃终端的预输入缓存。刷新输出队列会丢弃已写入（传递给终端驱动程序）但尚未传输到设备的数据。*queue_selector* 参数指定 [表 62-4](ch62.html#values_for_the_tcflush_open_parenthesis
    "表 62-4. tcflush() 的 queue_selector 参数值") 中列出的其中一个值。'
- en: Note
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the term *flush* is used in a different sense with *tcflush()* than
    when talking about file I/O. For file I/O, *flushing* means forcing the output
    to be transferred either user-space memory to the buffer cache in the case of
    the *stdio fflush()*, or from the buffer cache to the disk, in the case of *fsync()*,
    *fdatasync()*, and *sync()*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，术语 *flush* 在 *tcflush()* 中的使用与文件 I/O 中有所不同。在文件 I/O 中，*flushing* 意味着强制将输出数据传输：在
    *stdio fflush()* 的情况下，从用户空间内存到缓冲区缓存，或在 *fsync()*、*fdatasync()* 和 *sync()* 的情况下，从缓冲区缓存到磁盘。
- en: Table 62-4. Values for the *tcflush() queue_selector* argument
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 表 62-4. *tcflush()* 函数中 *queue_selector* 参数的值
- en: '| Value | Description |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `TCIFLUSH` | Flush the input queue |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `TCIFLUSH` | 刷新输入队列 |'
- en: '| `TCOFLUSH` | Flush the output queue |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `TCOFLUSH` | 刷新输出队列 |'
- en: '| `TCIOFLUSH` | Flush both the input and the output queues |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `TCIOFLUSH` | 刷新输入和输出队列 |'
- en: The *tcflow()* function controls the flow of data in either direction between
    the computer and the terminal (or other remote device). The *action* argument
    is one of the values shown in [Table 62-5](ch62.html#values_for_the_tcflush_open_parenthe
    "Table 62-5. Values for the tcflush() action argument"). The `TCIOFF` and `TCION`
    values are effective only if the terminal is capable of interpreting STOP and
    START characters, in which case these operations respectively cause the terminal
    to suspend and resume sending data to the computer, respectively.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcflow()*函数控制计算机和终端（或其他远程设备）之间的双向数据流。*action*参数是[表62-5](ch62.html#values_for_the_tcflush_open_parenthe
    "表62-5。*tcflush()*操作参数的值")中显示的值之一。`TCIOFF`和`TCION`值仅在终端能够解释STOP和START字符的情况下有效，在这种情况下，这些操作分别会使终端暂停和恢复向计算机发送数据。'
- en: Table 62-5. Values for the *tcflush() action* argument
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 表62-5。*tcflush()*操作参数的值
- en: '| Value | Description |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `TCOOFF` | Suspend output to the terminal |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `TCOOFF` | 暂停输出到终端 |'
- en: '| `TCOON` | Resume output to the terminal |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `TCOON` | 恢复输出到终端 |'
- en: '| `TCIOFF` | Transmit a STOP character to the terminal |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `TCIOFF` | 向终端传输STOP字符 |'
- en: '| `TCION` | Transmit a START character to the terminal |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `TCION` | 向终端传输START字符 |'
- en: Terminal Window Size
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端窗口大小
- en: 'In a windowing environment, a screen-handling application needs to be able
    to monitor the size of a terminal window, so that the screen can be redrawn appropriately
    if the user modifies the window size. The kernel provides two pieces of support
    to allow this to happen:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个窗口环境中，屏幕处理应用程序需要能够监控终端窗口的大小，以便在用户修改窗口大小时，屏幕可以适当重新绘制。内核提供了两项支持来实现这一点：
- en: A `SIGWINCH` signal is sent to the foreground process group after a change in
    the terminal window size. By default, this signal is ignored.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端窗口大小发生变化后，`SIGWINCH`信号会发送到前台进程组。默认情况下，这个信号会被忽略。
- en: At any time—usually following the receipt of a `SIGWINCH` signal—a process can
    use the *ioctl()* `TIOCGWINSZ` operation to find out the current size of the terminal
    window.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何时候—通常是在接收到`SIGWINCH`信号后—一个进程可以使用*ioctl()* `TIOCGWINSZ`操作来查找当前终端窗口的大小。
- en: 'The *ioctl()* `TIOCGWINSZ` operation is used as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*ioctl()* `TIOCGWINSZ`操作的使用方式如下：'
- en: '[PRE29]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The *fd* argument is a file descriptor referring to a terminal window. The
    final argument to *ioctl()* is a pointer to a *winsize* structure (defined in
    `<sys/ioctl.h>`), used to return the terminal window size:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '*fd*参数是指向终端窗口的文件描述符。*ioctl()*的最终参数是指向*winsize*结构的指针（在`<sys/ioctl.h>`中定义），用于返回终端窗口的大小：'
- en: '[PRE30]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Like many other implementations, Linux doesn’t use the pixel-size fields of
    the *winsize* structure.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多其他实现一样，Linux不使用*winsize*结构的像素大小字段。
- en: '[Example 62-5](ch62.html#monitoring_changes_in_the_terminal_windo "Example 62-5. Monitoring
    changes in the terminal window size") demonstrates the use of the `SIGWINCH` signal
    and the *ioctl()* `TIOCGWINSZ` operation. The following shows an example of the
    output produced when this program is run under a window manager and the terminal
    window size is changed three times:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例62-5](ch62.html#monitoring_changes_in_the_terminal_windo "示例62-5。监控终端窗口大小的变化")演示了`SIGWINCH`信号和*ioctl()*
    `TIOCGWINSZ`操作的使用。下面展示了在窗口管理器下运行该程序并且终端窗口大小变化三次时产生的输出示例：'
- en: '[PRE31]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Example 62-5. Monitoring changes in the terminal window size
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 示例62-5。监控终端窗口大小的变化
- en: '[PRE32]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It is also possible to change the terminal driver’s notion of the window size
    by passing an initialized *winsize* structure in an *ioctl()* `TIOCSWINSZ` operation:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过在*ioctl()* `TIOCSWINSZ`操作中传递一个初始化过的*winsize*结构来改变终端驱动程序对窗口大小的认知：
- en: '[PRE33]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the new values in the *winsize* structure differ from the terminal driver’s
    current notion of the terminal window size, two things happen:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*winsize*结构中的新值与终端驱动程序当前的终端窗口大小不一致，会发生两件事：
- en: The terminal driver data structures are updated using the values supplied in
    the *ws* argument.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在*ws*参数中提供的值更新终端驱动程序的数据结构。
- en: A `SIGWINCH` signal is sent to the foreground process group of the terminal.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGWINCH`信号会发送到终端的前台进程组。'
- en: Note, however, that these events on their own are insufficient to change the
    actual dimensions of the displayed window, which are controlled by software outside
    the kernel (such as a window manager or a terminal emulator program).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然而需要注意的是，这些事件本身不足以改变显示窗口的实际尺寸，因为这些尺寸是由内核之外的软件（如窗口管理器或终端仿真程序）控制的。
- en: Although not standardized in SUSv3, most UNIX implementations provide access
    to the terminal window size using the *ioctl()* operations described in this section.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 SUSv3 中没有标准化，大多数 UNIX 实现提供了通过本节描述的 *ioctl()* 操作来访问终端窗口大小的功能。
- en: Terminal Identification
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端标识
- en: In [Controlling Terminals and Controlling Processes](ch34.html#controlling_terminals_and_controlling_pr
    "Controlling Terminals and Controlling Processes"), we described the *ctermid()*
    function, which returns the name of the controlling terminal for a process (usually
    `/dev/tty` on UNIX systems). The functions described in this section are also
    useful for identifying a terminal.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在[控制终端和控制进程](ch34.html#controlling_terminals_and_controlling_pr "Controlling
    Terminals and Controlling Processes")中，我们描述了 *ctermid()* 函数，它返回进程的控制终端名称（通常是 UNIX
    系统上的 `/dev/tty`）。本节描述的函数对于标识终端也很有用。
- en: The *isatty()* function enables us to determine whether a file descriptor, *fd*,
    is associated with a terminal (as opposed to some other file type).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '*isatty()* 函数使我们能够判断一个文件描述符 *fd* 是否与终端相关联（而不是与其他文件类型相关联）。'
- en: '[PRE34]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns true (1) if *fd* is associated with a terminal, otherwise false (0)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *fd* 与终端相关联，则返回真（1），否则返回假（0）
- en: The *isatty()* function is useful in editors and other screen-handling programs
    that need to determine whether their standard input and output are directed to
    a terminal.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*isatty()* 函数在编辑器和其他需要判断标准输入输出是否指向终端的屏幕处理程序中非常有用。'
- en: Given a file descriptor, the *ttyname()* function returns the name of the associated
    terminal device.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个文件描述符，*ttyname()* 函数返回与之关联的终端设备名称。
- en: '[PRE35]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to (statically allocated) string containing terminal name, or
    `NULL` on error
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向（静态分配的）包含终端名称的字符串的指针，若出错则返回 `NULL`
- en: 'To find the name of the terminal, *ttyname()* uses the *opendir()* and *readdir()*
    functions described in [Reading Directories: *opendir()* and *readdir()*](ch18.html#reading_directories_colon_opendir_open_p
    "Reading Directories: opendir() and readdir()") to walk through the directories
    holding terminal device names, looking at each directory entry until it finds
    one whose device ID (the *st_rdev* field of the *stat* structure) matches that
    of the device referred to by the file descriptor *fd*. Terminal device entries
    normally reside in two directories: `/dev` and `/dev/pts`. The `/dev` directory
    contains entries for virtual consoles (e.g., `/dev/tty1`) and BSD pseudoterminals.
    The `/dev/pts` directory contains entries for (System V-style) pseudoterminal
    slave devices. (We describe pseudoterminals in [Chapter 64](ch64.html "Chapter 64. Pseudoterminals").)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '为了查找终端的名称，*ttyname()* 使用 [读取目录：*opendir()* 和 *readdir()*](ch18.html#reading_directories_colon_opendir_open_p
    "Reading Directories: opendir() and readdir()") 中描述的 *opendir()* 和 *readdir()*
    函数，遍历包含终端设备名称的目录，查看每个目录条目，直到找到一个其设备 ID（即 *stat* 结构的 *st_rdev* 字段）与文件描述符 *fd* 所引用的设备相匹配的条目。终端设备条目通常位于两个目录中：`/dev`
    和 `/dev/pts`。`/dev` 目录包含虚拟控制台（例如，`/dev/tty1`）和 BSD 伪终端的条目。`/dev/pts` 目录包含（System
    V 风格的）伪终端从设备条目。（我们在[第64章](ch64.html "第64章. 伪终端")中描述了伪终端。）'
- en: Note
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A reentrant version of *ttyname()* exists in the form of *ttyname_r()*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 存在 *ttyname()* 的可重入版本，名为 *ttyname_r()*。
- en: The *tty(1)* command, which displays the name of the terminal referred to by
    its standard input, is the command-line analog of *ttyname()*.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '*tty(1)* 命令显示其标准输入所引用的终端名称，是 *ttyname()* 的命令行等效命令。'
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: On early UNIX systems, terminals were real hardware devices connected to a computer
    via serial lines. Early terminals were not standardized, meaning that different
    escape sequences were required to program the terminals produced by different
    vendors. On modern workstations, such terminals have been superseded by bit-mapped
    monitors running the X Window System. However, the ability to program terminals
    is still required when dealing with virtual devices, such as virtual consoles
    and terminal emulators (which employ pseudoterminals), and real devices connected
    via serial lines.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 UNIX 系统中，终端是通过串行线路连接到计算机的实际硬件设备。早期的终端没有标准化，这意味着不同厂商生产的终端需要使用不同的转义序列进行编程。在现代工作站中，这些终端已被运行
    X Window 系统的位图显示器所取代。然而，在处理虚拟设备（如虚拟控制台和终端仿真器，它们使用伪终端）以及通过串行线路连接的实际设备时，编程终端的能力仍然是必要的。
- en: Terminal settings (with the exception of the terminal window size) are maintained
    in a structure of type *termios*, which contains four bit-mask fields that control
    various terminal settings and an array that defines the various special characters
    interpreted by the terminal driver. The *tcgetattr()* and *tcsetattr()* functions
    allow a program to retrieve and modify the terminal settings.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 终端设置（终端窗口大小除外）保存在类型为 *termios* 的结构体中，该结构体包含四个位掩码字段，用于控制各种终端设置，并包含一个数组，定义终端驱动程序解析的各种特殊字符。*tcgetattr()*
    和 *tcsetattr()* 函数允许程序检索和修改终端设置。
- en: When performing input, the terminal driver can operate in two different modes.
    In canonical mode, input is gathered into lines (terminated by one of the line-delimiter
    characters) and line editing is enabled. By contrast, noncanonical mode allows
    an application to read terminal input a character at a time, without needing to
    wait for the user to type a line-delimiter character. Line editing is disabled
    in noncanonical mode. Completion of a noncanonical mode read is controlled by
    the MIN and TIME fields of the *termios* structure, which determine the minimum
    number of characters to be read and a timeout to be applied to the read operation.
    We described four distinct cases for the operation of noncanonical reads.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行输入时，终端驱动程序可以在两种不同模式下工作。在规范模式下，输入被聚集成行（由其中一个行分隔符字符终止），并启用了行编辑。相比之下，非规范模式允许应用程序一次读取一个字符的终端输入，而无需等待用户输入行分隔符字符。在非规范模式下，禁用行编辑。非规范模式读取的完成由
    *termios* 结构体中的 MIN 和 TIME 字段控制，分别决定要读取的最小字符数和应用于读取操作的超时。我们描述了非规范读取操作的四种不同情况。
- en: Historically, the Seventh Edition and BSD terminal drivers provided three input
    modes—cooked, cbreak, and raw—which performed varying degrees of processing of
    terminal input and output. Cbreak and raw modes can be emulated by changing various
    fields within the *termios* structure.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，第七版和BSD终端驱动程序提供了三种输入模式——已处理模式、cbreak模式和原始模式——它们对终端输入输出进行了不同程度的处理。通过修改 *termios*
    结构体中的不同字段，可以模拟cbreak和原始模式。
- en: A range of functions perform various other terminal operations. These include
    changing the terminal line speed and performing line-control operations (generating
    a break condition, pausing until output has been transmitted, flushing terminal
    input and output queues, and suspending or resuming transmission of data in either
    direction between the terminal and the computer). Other functions allow us to
    check if a given file descriptor refers to a terminal and to obtain the name of
    that terminal. The *ioctl()* system call can be used to retrieve and modify the
    terminal window size recorded by the kernel, and to perform a range of other terminal-related
    operations.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列函数执行各种其他终端操作。这些操作包括更改终端的行速率以及执行行控制操作（生成中断条件，暂停直到输出传输完毕，刷新终端输入输出队列，暂停或恢复终端和计算机之间的数据传输）。其他函数允许我们检查给定的文件描述符是否指向终端，并获取该终端的名称。*ioctl()*
    系统调用可以用来检索和修改由内核记录的终端窗口大小，并执行一系列其他与终端相关的操作。
- en: Further information
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: '[Stevens, 1992] also describes terminal programming and goes into much more
    detail on programming serial ports. Several good online resources discuss terminal
    programming. Hosted at the LDP web site ([http://www.tldp.org](http://www.tldp.org))
    are the *Serial HOWTO* and the *Text-terminal HOWTO*, both by David S. Lawyer.
    Another useful source of information is the *Serial Programming Guide for POSIX
    Operating Systems* by Michael R. Sweet, available online at [http://www.easysw.com/~mike/serial/](http://www.easysw.com/~mike/serial/).'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[Stevens, 1992] 也描述了终端编程，并对串口编程进行了更详细的讨论。几个优秀的在线资源讨论了终端编程。LDP网站上（[http://www.tldp.org](http://www.tldp.org)）托管着由David
    S. Lawyer编写的《*串口 HOWTO*》和《*文本终端 HOWTO*》。另一个有用的信息来源是 Michael R. Sweet 编写的《*POSIX
    操作系统的串口编程指南*》，可以在线访问：[http://www.easysw.com/~mike/serial/](http://www.easysw.com/~mike/serial/)。'
- en: Exercises
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Implement *isatty()*. (You may find it useful to read the description of *tcgetattr()*
    in Section 62.2.)
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 *isatty()*。 （你可能会发现阅读第62.2节中 *tcgetattr()* 的描述很有用。）
- en: Implement *ttyname()*.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 *ttyname()*。
- en: Implement the *getpass()* function described in Section 8.5\. (The *getpass()*
    function can obtain a file descriptor for the controlling terminal by opening
    `/dev/tty`.)
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现第8.5节中描述的 *getpass()* 函数。(*getpass()* 函数可以通过打开 `/dev/tty` 获取控制终端的文件描述符。)
- en: Write a program that displays information indicating whether the terminal referred
    to by standard input is in canonical or noncanonical mode. If in noncanonical
    mode, then display the values of TIME and MIN.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，显示信息以指示标准输入所指的终端是处于规范模式还是非规范模式。如果是非规范模式，则显示TIME和MIN的值。
