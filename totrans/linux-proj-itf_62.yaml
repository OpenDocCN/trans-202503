- en: Chapter 62. Terminals
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 62 章 终端
- en: Historically, users accessed a UNIX system using a terminal connected via a
    serial line (an RS-232 connection). Terminals were cathode ray tubes (CRTs) capable
    of displaying characters and, in some cases, primitive graphics. Typically, CRTs
    provided a monochrome display of 24 lines by 80 columns. By today’s standards,
    these CRTs were small and expensive. In even earlier times, terminals were sometimes
    hard-copy teletype devices. Serial lines were also used to connect other devices,
    such as printers and modems, to a computer or to connect one computer to another.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，用户通过串行线（RS-232 连接）连接终端来访问 UNIX 系统。终端是能够显示字符的阴极射线管（CRT），在某些情况下也能显示原始图形。通常，CRT
    提供的是单色显示，分为 24 行、80 列。按今天的标准，这些 CRT 既小又贵。早期的终端有时是硬拷贝电传打字机设备。串行线还用于将其他设备（如打印机和调制解调器）连接到计算机，或将一台计算机连接到另一台计算机。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On early UNIX systems, the terminal lines connected to the system were represented
    by character devices with names of the form `/dev/tty`*n*. (On Linux, the /`dev/tty`*n*
    devices are the virtual consoles on the system.) It is common to see the abbreviation
    *tty* (derived from teletype) as a shorthand for *terminal*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 UNIX 系统中，连接到系统的终端线路表示为以 `/dev/tty`*n* 形式命名的字符设备。（在 Linux 上，/`dev/tty`*n*
    设备是系统中的虚拟控制台。）常见的缩写 *tty*（源自电传打字机）常被用作 *terminal*（终端）的简写。
- en: Especially during the early years of UNIX, terminal devices were not standardized,
    which meant that different character sequences were required to perform operations
    such as moving the cursor to the beginning of the line or the top of the screen.
    (Eventually, some vendor implementations of such *escape sequences*—for example,
    Digital’s VT-100—became de facto and, ultimately, ANSI standards, but a wide variety
    of terminal types continued to exist.) This lack of standardization meant that
    it was difficult to write portable programs that used terminal features. The *vi*
    editor was an early example of a program with such requirements. The *termcap*
    and *terminfo* databases (described in [Strang et al., 1988]), which tabulate
    how to perform various screen-control operations for a wide variety of terminal
    types, and the *curses* library ([Strang, 1986]) were developed in response to
    this lack of standardization.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在 UNIX 的早期阶段，终端设备并未标准化，这意味着执行操作（例如将光标移到行首或屏幕顶部）需要不同的字符序列。（最终，某些厂商实现的 *escape
    sequences*（转义序列）——例如 Digital 的 VT-100——成为事实上的标准，并最终成为 ANSI 标准，但各种终端类型仍然存在。）这种缺乏标准化导致编写使用终端功能的可移植程序变得困难。*vi*
    编辑器就是一个具有此类要求的早期示例。为应对这种标准化的缺失，开发了 *termcap* 和 *terminfo* 数据库（参见 [Strang 等, 1988]），它们列出了如何为各种终端类型执行不同的屏幕控制操作，以及
    *curses* 库（[Strang, 1986]）。
- en: It is no longer common to see a conventional terminal. The usual interface to
    modern UNIX systems is an X Window System window manager on a high-performance
    bit-mapped graphical monitor. (An old-style terminal provided functionality roughly
    equivalent to a single terminal window—an *xterm* or similar—in an X Window System.
    The fact that the user of such a terminal had only a single “window” to the system
    was the driving force behind the development of the job-control facilities described
    in Section 34.7.) Similarly, many devices (e.g., printers) that were once connected
    directly to a computer are now often intelligent devices connected via a network.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 传统终端已经不常见。现代 UNIX 系统的常见接口是高性能位图图形显示器上的 X 窗口系统窗口管理器。（老式终端提供的功能大致相当于 X 窗口系统中的单个终端窗口——例如
    *xterm* 或类似的终端。使用这种终端的用户仅能看到系统的单个“窗口”，这也是驱动第 34.7 节中描述的作业控制功能发展的原因。）类似地，许多曾经直接连接到计算机的设备（如打印机）现在通常是通过网络连接的智能设备。
- en: All of the above is a preamble to saying that the need to program terminal devices
    is less frequent than it used to be. Therefore, this chapter focuses on the aspects
    of terminal programming that are particularly relevant to software terminal emulators
    (i.e., *xterm* and similar). It gives only brief coverage to serial lines; references
    for further information about serial programming are provided at the end of this
    chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容作为引言，目的是说明编程终端设备的需求不再像以前那样频繁。因此，本章将重点介绍与软件终端模拟器（即 *xterm* 和类似的）特别相关的终端编程方面。对于串行线的内容，本章仅做简要介绍；关于串行编程的进一步参考资料将在本章末尾提供。
- en: Overview
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Both a conventional terminal and a terminal emulator have an associated terminal
    driver that handles input and output on the device. (In the case of a terminal
    emulator, the device is a pseudoterminal. We describe pseudoterminals in [Chapter 64](ch64.html
    "Chapter 64. Pseudoterminals").) Various aspects of the operation of the terminal
    driver can be controlled using the functions described in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 常规终端和终端仿真器都有一个相关的终端驱动程序，负责处理设备的输入和输出。（对于终端仿真器，设备是伪终端。我们在[第64章](ch64.html "第64章.
    伪终端")中描述了伪终端。）终端驱动程序的各种操作方面可以使用本章中描述的函数进行控制。
- en: 'When performing input, the driver is capable of operating in either of the
    following modes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行输入时，驱动程序能够以以下模式之一进行操作：
- en: '*Canonical mode*: In this mode, terminal input is processed line by line, and
    line editing is enabled. Lines are terminated by a newline character, generated
    when the user presses the *Enter* key. A *read()* from the terminal returns only
    when a complete line of input is available, and returns at most one line. (If
    the *read()* requests fewer bytes than are available in the current line, then
    the remaining bytes are available for the next *read()*.) This is the default
    input mode.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*规范模式*：在这种模式下，终端输入按行处理，并启用了行编辑。每行以换行符结束，当用户按下*Enter*键时生成换行符。*read()* 从终端读取数据仅在完整的一行输入可用时才返回，并且最多返回一行。（如果*read()*请求的字节数少于当前行中的可用字节，则剩余的字节将在下次*read()*中可用。）这是默认的输入模式。'
- en: '*Noncanonical mode*: Terminal input is not gathered into lines. Programs such
    as *vi*, *more*, and *less* place the terminal in noncanonical mode so that they
    can read single characters without the user needing to press the *Enter* key.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非规范模式*：终端输入不按行收集。像*vi*、*more*和*less*这样的程序将终端置于非规范模式，以便它们能够读取单个字符，而无需用户按下*Enter*键。'
- en: The terminal driver also interprets a range of special characters, such as the
    *interrupt* character (normally *Control-C*) and the *end-of-file* character (normally
    *Control-D*). Such interpretation may result in a signal being generated for the
    foreground process group or some type of input condition occurring for a program
    reading from the terminal. Programs that place the terminal in noncanonical mode
    typically also disable processing of some or all of these special characters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 终端驱动程序还会解释一系列特殊字符，如*中断*字符（通常是*Control-C*）和*文件结束*字符（通常是*Control-D*）。这种解释可能会导致为前台进程组生成信号，或者在程序从终端读取时发生某种输入条件。将终端置于非规范模式的程序通常还会禁用对某些或所有这些特殊字符的处理。
- en: 'A terminal driver operates two queues ([Figure 62-1](ch62.html#input_and_output_queues_for_a_terminal_d
    "Figure 62-1. Input and output queues for a terminal device")): one for input
    characters transmitted from the terminal device to the reading process(es) and
    the other for output characters transmitted from processes to the terminal. If
    terminal echoing is enabled, then the terminal driver automatically appends a
    copy of any input character to the end of the output queue, so that input characters
    are also output on the terminal.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 终端驱动程序操作两个队列（[图62-1](ch62.html#input_and_output_queues_for_a_terminal_d "图62-1.
    终端设备的输入输出队列")）：一个用于将从终端设备传输到读取进程的输入字符，另一个用于将从进程传输到终端的输出字符。如果启用了终端回显，终端驱动程序会自动将任何输入字符的副本附加到输出队列的末尾，从而使输入字符也在终端上输出。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 specifies the limit `MAX_INPUT`, which an implementation can use to indicate
    the maximum length of the terminal’s input queue. A related limit, `MAX_CANON`,
    defines the maximum number of bytes in a line of input in canonical mode. On Linux,
    *sysconf(_SC_MAX_INPUT)* and *sysconf(_SC_MAX_CANON)* both return the value 255.
    However, neither of these limits is actually employed by the kernel, which simply
    imposes a limit of 4096 bytes on the input queue. A corresponding limit on the
    size of the output queue also exists. However, applications don’t need to be concerned
    with this, since, if a process produces output faster than the terminal driver
    can handle it, the kernel suspends execution of the writing process until space
    is once more available in the output queue.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定了限制 `MAX_INPUT`，该限制可以被实现用来表示终端输入队列的最大长度。相关的限制 `MAX_CANON` 定义了规范模式下输入行的最大字节数。在
    Linux 上，*sysconf(_SC_MAX_INPUT)* 和 *sysconf(_SC_MAX_CANON)* 都返回值 255。然而，内核实际上并没有使用这些限制，而是直接对输入队列施加了
    4096 字节的限制。同时，输出队列的大小也有相应的限制。不过，应用程序无需关心这一点，因为如果进程产生的输出速度超过终端驱动程序处理的速度，内核会暂停写入进程的执行，直到输出队列中再次有足够空间。
- en: On Linux, we can call *ioctl(fd, FIONREAD, &cnt)* to obtain the number of unread
    bytes in the input queue of the terminal referred to by the file descriptor *fd*.
    This feature is not specified in SUSv3.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，我们可以调用 *ioctl(fd, FIONREAD, &cnt)* 来获取由文件描述符 *fd* 引用的终端输入队列中未读字节的数量。此功能在
    SUSv3 中没有规定。
- en: '![Input and output queues for a terminal device](figs/web/62-1_TERM-IO-queues-scale90.png.jpg)Figure 62-1. Input
    and output queues for a terminal device'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![终端设备的输入输出队列](figs/web/62-1_TERM-IO-queues-scale90.png.jpg)图62-1. 终端设备的输入输出队列'
- en: Retrieving and Modifying Terminal Attributes
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和修改终端属性
- en: The *tcgetattr()* and *tcsetattr()* functions retrieve and modify the attributes
    of a terminal.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcgetattr()* 和 *tcsetattr()* 函数用于检索和修改终端的属性。'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1。
- en: The *fd* argument is a file descriptor that refers to a terminal. (If *fd* doesn’t
    refer to a terminal, these functions fail with the error `ENOTTY`.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*fd* 参数是指向终端的文件描述符。（如果 *fd* 不指向终端，这些函数将因错误 `ENOTTY` 而失败。）'
- en: 'The *termios_p* argument is a pointer to a *termios* structure, which records
    terminal attributes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*termios_p* 参数是指向 *termios* 结构的指针，该结构记录终端属性：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first four fields of the *termios* structure are bit masks (the *tcflag_t*
    data type is an integer type of suitable size) containing flags that control various
    aspects of the terminal driver’s operation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*termios* 结构的前四个字段是位掩码（*tcflag_t* 数据类型是适当大小的整数类型），包含控制终端驱动程序操作的各种标志：'
- en: '*c_iflag* contains flags controlling terminal input;'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*c_iflag* 包含控制终端输入的标志；'
- en: '*c_oflag* contains flags controlling terminal output;'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*c_oflag* 包含控制终端输出的标志；'
- en: '*c_cflag* contains flags relating to hardware control of the terminal line;
    and'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*c_cflag* 包含与终端线路硬件控制相关的标志；'
- en: '*c_lflag* contains flags controlling the user interface for terminal input.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*c_lflag* 包含控制终端输入用户界面的标志。'
- en: All of the flags used in the above fields are listed in [Table 62-2](ch62.html#terminal_flags-id1
    "Table 62-2. Terminal flags") (in [Terminal Flags](ch62.html#terminal_flags "Terminal
    Flags")).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述字段中使用的所有标志列出了[表62-2](ch62.html#terminal_flags-id1 "表62-2. 终端标志")（在[终端标志](ch62.html#terminal_flags
    "Terminal Flags")中）。
- en: The *c_line* field specifies the line discipline for this terminal. For the
    purposes of programming terminal emulators, the line discipline will always be
    set to `N_TTY`, the so-called *new* discipline, a component of the kernel terminal-handling
    code that implements canonical mode I/O processing. Setting the line discipline
    can be relevant when programming serial lines.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*c_line* 字段指定了该终端的行规程。对于终端仿真器的编程，行规程将始终设置为 `N_TTY`，即所谓的 *新* 规程，这是内核终端处理代码的一个组成部分，用于实现规范模式的
    I/O 处理。在编写串口程序时，设置行规程可能是相关的。'
- en: The *c_cc* array contains the terminal special characters (*interrupt*, *suspend*,
    and so on) as well as fields controlling the operation of noncanonical mode input.
    The *cc_t* data type is an unsigned integer type suitable for holding these values,
    and the `NCCS` constant specifies the number of elements in this array. We describe
    the terminal special characters in Section 62.4.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*c_cc* 数组包含终端特殊字符（*中断*、*挂起*等），以及控制非规范模式输入操作的字段。*cc_t* 数据类型是一个无符号整数类型，适合存储这些值，`NCCS`
    常量指定该数组中的元素数量。我们将在第62.4节描述终端特殊字符。'
- en: The *c_ispeed* and *c_ospeed* fields are unused on Linux (and are not specified
    in SUSv3). We explain how Linux stores terminal line speeds in Section 62.7.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，*c_ispeed* 和 *c_ospeed* 字段未使用（且在 SUSv3 中未指定）。我们将在第 62.7 节中解释 Linux
    如何存储终端行速。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Seventh Edition and early BSD terminal driver (known as the *tty* driver)
    had grown over time so that it used no less than four different data structures
    to represent the information equivalent to the *termios* structure. System V replaced
    this baroque arrangement with a single structure called *termio*. The initial
    POSIX committee selected the System V API almost as is, in the process renaming
    it to *termios*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第七版和早期的 BSD 终端驱动程序（称为 *tty* 驱动程序）随着时间的推移，发展到使用不止四个不同的数据结构来表示等同于 *termios* 结构的信息。System
    V 用一个名为 *termio* 的单一结构取代了这种复杂的安排。最初的 POSIX 委员会几乎按照原样选择了 System V API，并在此过程中将其重命名为
    *termios*。
- en: 'When changing terminal attributes with *tcsetattr()*, the *optional_actions*
    argument determines when the change takes effect. This argument is specified as
    one of the following values:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 *tcsetattr()* 更改终端属性时，*optional_actions* 参数决定了更改何时生效。此参数可以指定以下值之一：
- en: '`TCSANOW`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCSANOW`'
- en: The change is carried out immediately.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更改会立即生效。
- en: '`TCSADRAIN`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCSADRAIN`'
- en: The change takes effect after all currently queued output has been transmitted
    to the terminal. Normally, this flag should be specified when making changes that
    affect terminal output, so that we don’t affect output that has already been queued
    but not yet displayed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更改在所有当前排队的输出已传输到终端后生效。通常，在进行影响终端输出的更改时，应该指定此标志，以避免影响已排队但尚未显示的输出。
- en: '`TCSAFLUSH`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCSAFLUSH`'
- en: The change takes effect as for `TCSADRAIN`, but, in addition, any input that
    is still pending at the time the change takes effect is discarded. This is useful,
    for example, when reading a password, where we wish to disable terminal echoing
    and prevent user type-ahead.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 更改生效方式与 `TCSADRAIN` 相同，但此外，任何在更改生效时仍待处理的输入将被丢弃。例如，当读取密码时，我们希望禁用终端回显并防止用户提前输入。
- en: 'The usual (and recommended) way to change terminal attributes is to use *tcgetattr()*
    to retrieve a *termios* structure containing a copy of the current settings, change
    the desired attributes, and then use *tcsetattr()* to push the updated structure
    back to the driver. (This approach ensures that we pass a fully initialized structure
    to *tcsetattr()*.) For example, we can use the following sequence to turn terminal
    echoing off:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 更改终端属性的常用（且推荐）方法是使用 *tcgetattr()* 来获取一个包含当前设置副本的 *termios* 结构，修改所需的属性，然后使用 *tcsetattr()*
    将更新后的结构推送回驱动程序。（这种方法确保我们向 *tcsetattr()* 传递一个完全初始化的结构。）例如，我们可以使用以下序列来关闭终端回显：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The *tcsetattr()* function returns successfully if *any* of the requested changes
    to terminal attributes could be performed; it fails only if *none* of the requested
    changes could be made. This means that, when making multiple attribute changes,
    it may sometimes be necessary to make a further call to *tcgetattr()* to retrieve
    the new terminal attributes and compare them against the requested changes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以执行请求的任何终端属性更改，则 *tcsetattr()* 函数将成功返回；只有在无法进行任何请求的更改时才会失败。这意味着，在进行多个属性更改时，有时可能需要再次调用
    *tcgetattr()* 来获取新的终端属性，并将其与请求的更改进行比较。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Implementing Job Control](ch34.html#implementing_job_control "Implementing
    Job Control"), we noted that if *tcsetattr()* is called from a process in a background
    process group, then the terminal driver suspends the process group by delivering
    a `SIGTTOU` signal, and that, if called from an orphaned process group, *tcsetattr()*
    fails with the error EIO. The same statements apply for various other functions
    described in this chapter, including *tcflush()*, *tcflow()*, *tcsendbreak()*,
    and *tcdrain()*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[实现作业控制](ch34.html#implementing_job_control "Implementing Job Control")中，我们指出，如果从后台进程组中的进程调用
    *tcsetattr()*，则终端驱动程序会通过发送 `SIGTTOU` 信号来暂停该进程组；如果从孤立的进程组调用，则 *tcsetattr()* 会因错误
    EIO 而失败。对于本章中描述的其他各种函数，如 *tcflush()*、*tcflow()*、*tcsendbreak()* 和 *tcdrain()*，同样适用这些说明。
- en: In earlier UNIX implementations, terminal attributes were accessed using *ioctl()*
    calls. Like several other functions described in this chapter, the *tcgetattr()*
    and *tcsetattr()* functions are POSIX inventions designed to address the problem
    that type checking of the third argument of *ioctl()* isn’t possible. On Linux,
    as in many other UNIX implementations, these are library functions layered on
    top of *ioctl()*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 UNIX 实现中，终端属性是通过*ioctl()*调用访问的。与本章中描述的其他几个函数一样，*tcgetattr()*和*tcsetattr()*函数是
    POSIX 发明的，旨在解决*ioctl()*的第三个参数类型检查无法进行的问题。在 Linux 以及许多其他 UNIX 实现中，这些是基于*ioctl()*的库函数。
- en: The *stty* Command
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*stty* 命令'
- en: The *stty* command is the command-line analog of the *tcgetattr()* and *tcsetattr()*
    functions, allowing us to view and change terminal attributes from the shell.
    This is useful when trying to monitor, debug, or undo the effects of programs
    that modify terminal attributes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*stty* 命令是*tcgetattr()*和*tcsetattr()*函数的命令行类比，允许我们从 shell 中查看和更改终端属性。这在尝试监控、调试或撤销修改终端属性的程序的效果时非常有用。'
- en: 'We can view the current settings of all terminal attributes using the following
    command (here carried out on a virtual console):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令查看所有终端属性的当前设置（此命令在虚拟控制台上执行）：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line of the above output shows the terminal line speed (bits per second),
    the terminal window size, and the line discipline in numeric form (0 corresponds
    to `N_TTY`, the new line discipline).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出的第一行显示了终端的行速（每秒比特数）、终端窗口大小和行规程的数字表示形式（0代表`N_TTY`，即新的行规程）。
- en: The next three lines show the settings of the various terminal special characters.
    The notation `^C` denotes *Control-C*, and so on. The string `<undef>` means that
    the corresponding terminal special character is not currently defined. The *min*
    and *time* values relate to noncanonical mode input, and are described in [Noncanonical
    Mode](ch62.html#noncanonical_mode "Noncanonical Mode").
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三行显示了各种终端特殊字符的设置。符号`^C`表示*Control-C*，依此类推。字符串`<undef>`表示相应的终端特殊字符当前未定义。*min*和*time*值与非规范模式输入相关，详情请参见[非规范模式](ch62.html#noncanonical_mode
    "Noncanonical Mode")。
- en: The remaining lines show the settings of the various flags from (in order) the
    *c_cflag*, *c_iflag*, *c_oflag*, and *c_lflag* fields of the *termios* structure.
    Where a flag name is preceded by a hyphen (`-`), the flag is currently disabled;
    otherwise, it is currently enabled.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的几行展示了来自*termios*结构的各个标志的设置（按顺序为：*c_cflag*、*c_iflag*、*c_oflag*和*c_lflag*字段）。如果某个标志前有一个短横线（`-`），则表示该标志当前被禁用；否则，它是启用状态。
- en: When entered without command-line arguments, *stty* shows just the terminal
    line speed, the line discipline, and any of the other settings that deviate from
    sane values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有命令行参数的情况下输入*stty*，它将只显示终端的行速、行规程以及任何偏离合理值的其他设置。
- en: 'We can change the settings of terminal special characters using commands such
    as the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用如下命令更改终端特殊字符的设置：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When specifying a control character as the final argument, we can do so in
    a variety of ways:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定控制字符作为最终参数时，我们可以采用多种方式：
- en: as a 2-character sequence consisting of a caret (`^`) followed by the corresponding
    character (as shown above);
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为由插入符号（`^`）后跟相应字符组成的两个字符序列（如上所示）；
- en: 'as an octal or hexadecimal number (thus: `014` or `0xC`); or'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为八进制或十六进制数字（例如：`014`或`0xC`）；或者
- en: by typing the actual character itself.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过输入实际字符本身。
- en: 'If we employ the final option, and the character in question is one interpreted
    specially by the shell or the terminal driver, then we must precede it with the
    *literal next* character (usually *Control-V*):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用最后一个选项，并且该字符是 shell 或终端驱动程序特别解释的字符，则必须在它前面加上*字面下一个*字符（通常是*Control-V*）：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: (Although, for readability, a space is shown between the *Control-V* and the
    *Control-L* in the above example, no white-space characters should be typed between
    the *Control-V* and the desired character.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: （尽管为了可读性，以上示例中*Control-V*和*Control-L*之间显示了一个空格，但在实际输入时，*Control-V*和目标字符之间不应输入任何空白字符。）
- en: 'It is possible, though unusual, to define terminal special characters to be
    something other than control characters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不常见，但可以将终端特殊字符定义为非控制字符：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, when we do this, we can no longer use the *q* key for its usual purpose
    (i.e., generating the letter *q*).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们这么做时，我们就无法再使用*q*键来执行其常规功能（即生成字母*q*）。
- en: 'To change terminal flags, such as the `TOSTOP` flag, we can use commands such
    as the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改终端标志，例如 `TOSTOP` 标志，我们可以使用以下命令：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sometimes, when developing programs that modify terminal attributes, a program
    may crash, leaving the terminal in a state that renders it all but unusable. On
    a terminal emulator, we have the luxury of simply closing the terminal window
    and starting another. Alternatively, we can type in the following character sequence
    to restore the terminal flags and special characters to a reasonable state:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在开发修改终端属性的程序时，程序可能会崩溃，导致终端进入一个几乎无法使用的状态。在终端仿真器上，我们可以轻松关闭终端窗口并启动另一个。或者，我们可以键入以下字符序列来恢复终端标志和特殊字符到一个合理的状态：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The *Control-J* character is the real newline character (ASCII 10 decimal).
    We use this character because, in some modes, the terminal driver may no longer
    map the *Enter* key (ASCII 13 decimal) into a newline character. We type an initial
    *Control-J* to ensure that we have a fresh command line with no preceding characters.
    This may not be easy to verify if, for example, terminal echoing has been disabled.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*Control-J* 字符是真正的换行字符（ASCII 10 十进制）。我们使用这个字符，因为在某些模式下，终端驱动程序可能不再将 *Enter*
    键（ASCII 13 十进制）映射为换行字符。我们输入一个初始的 *Control-J* 来确保我们有一个没有前导字符的新命令行。如果终端回显被禁用，这一点可能不容易验证。'
- en: 'The *stty* command operates on the terminal referred to by standard input.
    Using the *-F* option, we can (subject to permission checks) monitor and set the
    attributes of a terminal other than the one on which the *stty* command is run:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*stty* 命令作用于标准输入指定的终端。使用 *-F* 选项，我们可以（在权限检查通过的情况下）监控和设置除了运行 *stty* 命令的终端以外的其他终端的属性：'
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The *-F* option is a Linux-specific extension to the *stty* command. On many
    other UNIX implementations, *stty* always acts on the terminal referred to by
    standard input, and we must use the following alternative form (which can also
    be used on Linux):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*-F* 选项是 Linux 特有的扩展，用于 *stty* 命令。在许多其他 UNIX 实现中，*stty* 总是作用于标准输入指定的终端，我们必须使用以下替代形式（在
    Linux 上也可使用）：'
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Terminal Special Characters
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端特殊字符
- en: '[Table 62-1](ch62.html#terminal_special_characters-id1 "Table 62-1. Terminal
    special characters") lists the special characters recognized by the Linux terminal
    driver. The first two columns show the name of the character and the corresponding
    constant that can be used as a subscript in the *c_cc* array. (As can be seen,
    these constants simply prefix the letter *V* in front of the character name.)
    The CR and NL characters don’t have corresponding *c_cc* subscripts, because the
    values of these characters can’t be changed.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 62-1](ch62.html#terminal_special_characters-id1 "表格 62-1. 终端特殊字符")列出了 Linux
    终端驱动程序识别的特殊字符。前两列显示了字符的名称和对应的常量，可以作为 *c_cc* 数组的下标使用。（如所见，这些常量只是将字母 *V* 前缀加在字符名称前面。）CR
    和 NL 字符没有对应的 *c_cc* 下标，因为这些字符的值无法更改。'
- en: The *Default setting* column of the table shows the usual default value for
    the special character. As well as being able to set a terminal special character
    to a specific value, it is also possible to disable the character by setting it
    to the value returned by the call *fpathconf(fd, _PC_VDISABLE)*, where *fd* is
    a file descriptor referring to a terminal. (On most UNIX implementations, this
    call returns the value 0.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的 *默认设置* 列显示了特殊字符的通常默认值。除了能够将终端特殊字符设置为特定值外，还可以通过将字符设置为调用 *fpathconf(fd, _PC_VDISABLE)*
    返回的值来禁用该字符，其中 *fd* 是指向终端的文件描述符。（在大多数 UNIX 实现中，这个调用返回值为 0。）
- en: The operation of each of the special characters is subject to the setting of
    various flags in the *termios* bit-mask fields (described in [Terminal Flags](ch62.html#terminal_flags
    "Terminal Flags")), as shown in the penultimate column of the table.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特殊字符的操作受到 *termios* 位掩码字段中各种标志设置的影响（详细描述见[终端标志](ch62.html#terminal_flags "终端标志")），如表格倒数第二列所示。
- en: The final column indicates which of these characters are specified by SUSv3.
    Regardless of the SUSv3 specification, most of these characters are supported
    on all UNIX implementations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一列指示哪些字符是由 SUSv3 指定的。无论 SUSv3 规范如何，大多数这些字符在所有 UNIX 实现中都受支持。
- en: Table 62-1. Terminal special characters
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 62-1. 终端特殊字符
- en: '| Character | *c_cc* subscript | Description | Default setting | Relevant bit-mask
    flags | SUSv3 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | *c_cc* 下标 | 描述 | 默认设置 | 相关位掩码标志 | SUSv3 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| CR | (none) | Carriage return | `^M` | `ICANON`, `IGNCR`, `ICRNL`, `OPOST`,
    `OCRNL`, `ONOCR` | • |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| CR | (无) | 回车 | `^M` | `ICANON`, `IGNCR`, `ICRNL`, `OPOST`, `OCRNL`, `ONOCR`
    | • |'
- en: '| DISCARD | `VDISCARD` | Discard output | `^O` | (not implemented) |   |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| DISCARD | `VDISCARD` | 丢弃输出 | `^O` | （未实现） |   |'
- en: '| EOF | `VEOF` | End-of-file | `^D` | `ICANON` | • |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| EOF | `VEOF` | 文件结束 | `^D` | `ICANON` | • |'
- en: '| EOL | `VEOL` | End-of-line |   | `ICANON` | • |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| EOL | `VEOL` | 行尾 |   | `ICANON` | • |'
- en: '| EOL2 | `VEOL2` | Alternate end-of-line |   | `ICANON`, `IEXTEN` |   |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| EOL2 | `VEOL2` | 备用行尾 |   | `ICANON`, `IEXTEN` |   |'
- en: '| ERASE | `VERASE` | Erase character | `^?` | `ICANON` | • |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| ERASE | `VERASE` | 擦除字符 | `^?` | `ICANON` | • |'
- en: '| INTR | `VINTR` | Interrupt (`SIGINT`) | `^C` | `ISIG` | • |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| INTR | `VINTR` | 中断（`SIGINT`） | `^C` | `ISIG` | • |'
- en: '| KILL | `VKILL` | Erase line | `^U` | `ICANON` | • |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| KILL | `VKILL` | 擦除行 | `^U` | `ICANON` | • |'
- en: '| LNEXT | `VLNEXT` | Literal next | `^V` | `ICANON`, `IEXTEN` |   |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| LNEXT | `VLNEXT` | 字面量下一个 | `^V` | `ICANON`, `IEXTEN` |   |'
- en: '| NL | (none) | Newline | `^J` | `ICANON`, `INLCR`, `ECHONL`, `OPOST`, `ONLCR`,
    `ONLRET` | • |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| NL | (无) | 换行 | `^J` | `ICANON`, `INLCR`, `ECHONL`, `OPOST`, `ONLCR`, `ONLRET`
    | • |'
- en: '| QUIT | `VQUIT` | Quit (`SIGQUIT`) | `^\` | `ISIG` | • |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| QUIT | `VQUIT` | 退出（`SIGQUIT`） | `^\` | `ISIG` | • |'
- en: '| REPRINT | `VREPRINT` | Reprint input line | `^R` | `ICANON`, `IEXTEN`, `ECHO`
    |   |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| REPRINT | `VREPRINT` | 重新打印输入行 | `^R` | `ICANON`, `IEXTEN`, `ECHO` |   |'
- en: '| START | `VSTART` | Start output | `^Q` | `IXON`, `IXOFF` | • |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| START | `VSTART` | 启动输出 | `^Q` | `IXON`, `IXOFF` | • |'
- en: '| STOP | `VSTOP` | Stop output | `^S` | `IXON`, `IXOFF` | • |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| STOP | `VSTOP` | 停止输出 | `^S` | `IXON`, `IXOFF` | • |'
- en: '| SUSP | `VSUSP` | Suspend (`SIGTSTP`) | `^Z` | `ISIG` | • |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| SUSP | `VSUSP` | 挂起（`SIGTSTP`） | `^Z` | `ISIG` | • |'
- en: '| WERASE | `VWERASE` | Erase word | `^W` | `ICANON`, `IEXTEN` |   |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| WERASE | `VWERASE` | 擦除单词 | `^W` | `ICANON`, `IEXTEN` |   |'
- en: The following paragraphs provide more detailed explanations of the terminal
    special characters. Note that if the terminal driver performs its special input
    interpretation on one of these characters, then—with the exception of CR, EOL,
    EOL2, and NL—the character is discarded (i.e., it is not passed to any reading
    process).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下段落将提供有关终端特殊字符的更详细解释。请注意，如果终端驱动程序对这些字符执行了特殊的输入解释，那么——除了 CR、EOL、EOL2 和 NL——该字符会被丢弃（即，不会传递给任何读取进程）。
- en: CR
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CR
- en: CR is the *carriage return* character. This character is passed to the reading
    process. In canonical mode (`ICANON` flag set) with the `ICRNL` (*map CR to NL
    on input*) flag set (the default), this character is first converted to a newline
    (ASCII 10 decimal, `^J`) before being passed to the reading process. If the `IGNCR`
    (*ignore CR*) flag is set, then this character is ignored on input (in which case
    the true newline character must be used to terminate a line of input). An output
    CR character causes the terminal to move the cursor to the beginning of the line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: CR 是 *回车* 字符。这个字符会传递给读取进程。在规范模式下（`ICANON` 标志被设置），并且设置了 `ICRNL`（*将 CR 映射到 NL
    进行输入*）标志（默认情况下），这个字符会首先转换为换行符（ASCII 10 十进制，`^J`），然后才会传递给读取进程。如果设置了 `IGNCR`（*忽略
    CR*）标志，那么该字符在输入时会被忽略（在这种情况下，必须使用真正的换行符来终止一行输入）。输出的 CR 字符会使终端将光标移动到行首。
- en: DISCARD
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DISCARD
- en: DISCARD is the *discard output* character. Although this character is defined
    within the *c_cc* array, it has no effect on Linux. On some other UNIX implementations,
    typing this character once causes program output to be discarded. This character
    is a toggle—typing it once more reenables the display of output. This is useful
    when a program is generating a large amount of output and we want to skip some
    of it. (This was much more useful on traditional terminals, where line speeds
    were slower and other “terminal windows” were unavailable.) This character is
    not passed to the reading process.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: DISCARD 是 *丢弃输出* 字符。尽管该字符在 *c_cc* 数组中有定义，但在 Linux 上没有作用。在某些其他 UNIX 实现中，输入这个字符一次会导致程序输出被丢弃。这个字符是一个开关——再次输入它会重新启用输出显示。这在程序生成大量输出时很有用，可以跳过部分输出。（这在传统终端上更为有用，因为当时行速较慢，且没有其他“终端窗口”可用。）该字符不会传递给读取进程。
- en: EOF
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: EOF
- en: EOF is the canonical mode *end-of-file* character (usually *Control-D*). Entering
    this character at the beginning of a line causes an end-of-file condition to be
    detected by a process reading from the terminal (i.e., *read()* returns 0). If
    typed anywhere other than the initial character of a line, then this character
    simply causes *read()* to complete immediately, returning the characters so far
    input in the line. In both cases, the EOF character itself is not passed to the
    reading process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: EOF是规范模式下的*文件结束*字符（通常是*Control-D*）。在行的开头输入此字符会导致读取进程检测到文件结束条件（即，*read()*返回0）。如果在行的其他位置输入此字符，则该字符会立即导致*read()*完成，返回到目前为止输入的字符。在这两种情况下，EOF字符本身不会传递给读取进程。
- en: EOL and EOL2
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: EOL和EOL2
- en: EOL and EOL2 are *additional line-delimiter* characters that operate like the
    standard newline (NL) character for canonical mode input, terminating a line of
    input and making it available to the reading process. By default, these characters
    are undefined. If they are defined, they are passed to the reading process. The
    EOL2 character is operational only if the `IEXTEN` (*extended input processing*)
    flag is set (the default).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: EOL和EOL2是*附加行分隔符*字符，类似于规范模式输入中的标准换行（NL）字符，用于终止一行输入并将其提供给读取进程。默认情况下，这些字符未定义。如果定义了这些字符，它们将传递给读取进程。EOL2字符仅在设置了`IEXTEN`（*扩展输入处理*）标志时才有效（默认情况下是如此）。
- en: These characters are rarely used. One application that does use them is *telnet*.
    By setting EOL or EOL2 to be the *telnet* escape character (usually *Control-]*,
    or, alternatively, the tilde character, ~, if operating in *rlogin* mode), *telnet*
    is able to immediately catch that character, even while reading input in canonical
    mode.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符很少使用。有一个应用程序使用它们，那就是*telnet*。通过将EOL或EOL2设置为*telnet*的转义字符（通常是*Control-]*，或者在*rlogin*模式下，使用波浪号字符~），*telnet*能够立即捕捉到该字符，即使在规范模式下读取输入时也是如此。
- en: ERASE
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ERASE
- en: In canonical mode, typing the ERASE character erases the previously input character
    on the current line. The erased character and the ERASE character itself are not
    passed to the reading process.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范模式下，输入ERASE字符会删除当前行上先前输入的字符。被删除的字符和ERASE字符本身不会传递给读取进程。
- en: INTR
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: INTR
- en: INTR is the *interrupt* character. If the `ISIG` (*enable signals*) flag is
    set (the default), typing this character causes an *interrupt* signal (`SIGINT`)
    to be sent to the terminal’s foreground process group ([Process Groups](ch34.html#process_groups
    "Process Groups")). The INTR character itself is not passed to the reading process.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: INTR是*中断*字符。如果设置了`ISIG`（*启用信号*）标志（默认情况下），输入此字符会向终端的前台进程组发送一个*中断*信号（`SIGINT`）（参见[进程组](ch34.html#process_groups
    "进程组")）。INTR字符本身不会传递给读取进程。
- en: KILL
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: KILL
- en: KILL is the *erase line* (also known as *kill line*) character. In canonical
    mode, typing this character causes the current line of input to be discarded (i.e.,
    the characters typed so far, as well as the KILL character itself, are not passed
    to the reading process).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: KILL是*清除行*（也叫*杀死行*）字符。在规范模式下，输入此字符会导致当前输入行被丢弃（即，已经输入的字符以及KILL字符本身不会传递给读取进程）。
- en: LNEXT
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LNEXT
- en: LNEXT is the *literal next* character. In some circumstances, we may wish to
    treat one of the terminal special characters as though it were a normal character
    for input to a reading process. Typing the literal next character (usually *Control-V*)
    causes the next character to be treated literally, voiding any special interpretation
    of the character that the terminal driver would normally perform. Thus, we could
    enter the 2-character sequence *Control-V Control-C* to supply a real *Control-C*
    character (ASCII 3) as input to the reading process. The LNEXT character itself
    is not passed to the reading process. This character is interpreted only in canonical
    mode with the `IEXTEN` (*extended input processing*) flag set (which is the default).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: LNEXT是*字面上的下一个*字符。在某些情况下，我们可能希望将某些终端特殊字符视为普通字符来输入到读取进程中。输入字面下一个字符（通常是*Control-V*）会导致下一个字符被字面处理，忽略终端驱动程序通常对该字符的任何特殊解释。因此，我们可以输入两个字符序列*Control-V
    Control-C*，将真正的*Control-C*字符（ASCII 3）作为输入提供给读取进程。LNEXT字符本身不会传递给读取进程。该字符仅在规范模式下并且设置了`IEXTEN`（*扩展输入处理*）标志时被解释（默认情况下就是如此）。
- en: NL
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NL
- en: NL is the *newline* character. In canonical mode, this character terminates
    an input line. The NL character itself is included in the line returned to the
    reading process. (The CR character is normally converted to NL in canonical mode.)
    An output NL character causes the terminal to move the cursor down one line. If
    the `OPOST` and `ONLCR` (*map NL to CR-NL*) flags are set (the default), then,
    on output, a newline character is mapped to the 2-character sequence CR plus NL.
    (The combination of the `ICRNL` and `ONLCR` flags means that an input CR is converted
    to a NL, and then echoed as CR plus NL.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: NL是*换行*字符。在规范模式下，该字符用于终止输入行。NL字符本身包含在返回给读取进程的行中。（在规范模式下，CR字符通常会转换为NL。）输出的NL字符会使终端光标下移一行。如果设置了`OPOST`和`ONLCR`（*将NL映射为CR-NL*）标志（默认设置），则在输出时，换行字符会被映射为两个字符的序列CR加NL。（`ICRNL`和`ONLCR`标志的组合意味着输入的CR会被转换为NL，然后作为CR加NL回显。）
- en: QUIT
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: QUIT
- en: If the `ISIG` flag is set (the default), typing the QUIT character causes a
    *quit* signal (`SIGQUIT`) to be sent to the terminal’s foreground process group
    ([Process Groups](ch34.html#process_groups "Process Groups")). The QUIT character
    itself is not passed to the reading process.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`ISIG`标志（默认设置），输入QUIT字符会向终端的前台进程组发送一个*退出*信号（`SIGQUIT`）（[进程组](ch34.html#process_groups
    "进程组")）。QUIT字符本身不会传递给读取进程。
- en: REPRINT
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: REPRINT
- en: REPRINT is the *reprint input* character. In canonical mode with the `IEXTEN`
    flag set (the default), typing this character causes the current (as yet incomplete)
    line of input to be redisplayed on the terminal. This is useful if some other
    program (e.g., *wall(1)* or *write(1)*) has written output that has messed up
    the terminal display. The REPRINT character itself is not passed to the reading
    process.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: REPRINT是*重新打印输入*字符。在设置了`IEXTEN`标志（默认设置）的规范模式下，输入该字符会在终端上重新显示当前（尚未完成的）输入行。如果其他程序（例如，*wall(1)*或*write(1)*)输出内容导致终端显示混乱，这个功能会很有用。REPRINT字符本身不会传递给读取进程。
- en: START and STOP
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: START和STOP
- en: START and STOP are the *start output* and *stop output* characters, which operate
    if the `IXON` (*enable start/stop output control*) flag is enabled (the default).
    (The START and STOP characters are not honored by some terminal emulators.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: START和STOP是*开始输出*和*停止输出*字符，当`IXON`（*启用开始/停止输出控制*）标志启用时会生效（默认设置）。(某些终端模拟器不支持START和STOP字符。)
- en: Typing the STOP character suspends terminal output. The STOP character itself
    is not passed to the reading process. If the `IXOFF` flag is set and the terminal
    input queue is full, then the terminal driver automatically sends a STOP character
    to throttle the input.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输入STOP字符会暂停终端输出。STOP字符本身不会传递给读取进程。如果设置了`IXOFF`标志且终端输入队列已满，则终端驱动程序会自动发送STOP字符以限制输入。
- en: Typing the START character causes terminal output to resume after previously
    being stopped by the STOP character. The START character itself is not passed
    to the reading process. If the `IXOFF` (*enable start/stop input control*) flag
    is set (this flag is disabled by default) and the terminal driver had previously
    sent a STOP character because the input queue was full, the terminal driver automatically
    generates a START character when space once more becomes available in the input
    queue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输入START字符会在之前被STOP字符暂停的终端输出后恢复。START字符本身不会传递给读取进程。如果设置了`IXOFF`（*启用开始/停止输入控制*）标志（该标志默认禁用），且终端驱动程序之前由于输入队列已满而发送了STOP字符，当输入队列中再次有空间时，终端驱动程序会自动生成一个START字符。
- en: If the `IXANY` flag is set, then any character, not just `START`, may be typed
    in order to restart output (and that character is similarly not passed to the
    reading process).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`IXANY`标志，那么任何字符，而不仅仅是`START`，都可以用来重新启动输出（且该字符同样不会传递给读取进程）。
- en: The START and STOP characters are used for software flow control in either direction
    between the computer and the terminal device. One function of these characters
    is to allow users to stop and start terminal output. This is output flow control,
    as enabled by `IXON`. However, flow control in the other direction (i.e., control
    of input flow from the device to the computer, as enabled by `IXOFF`) is also
    important when, for example, the device in question is a modem or another computer.
    Input flow control makes sure that no data is lost if the application is slow
    to handle input and the kernel buffers fill up.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: START 和 STOP 字符用于在计算机和终端设备之间进行软件流控制，方向是双向的。这些字符的一个功能是允许用户停止和启动终端输出。这是输出流控制，由
    `IXON` 启用。然而，另一方向的流控制（即从设备到计算机的输入流控制，由 `IXOFF` 启用）也很重要，特别是当设备是调制解调器或另一台计算机时。输入流控制确保在应用程序处理输入缓慢并且内核缓冲区已满时，不会丢失数据。
- en: With the higher line speeds that are nowadays typical, software flow control
    has been superseded by hardware (RTS/CTS) flow control, whereby data flow is enabled
    and disabled using signals sent via separate wires on the serial port. (RTS stands
    for *Request To Send*, and CTS stands for *Clear To Send*.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随着如今典型的更高线路速度，软件流控制已被硬件（RTS/CTS）流控制取代，数据流通过串口上单独的线路发送信号来启用和禁用。（RTS 代表*请求发送*，CTS
    代表*清除发送*。）
- en: SUSP
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SUSP
- en: SUSP is the *suspend* character. If the `ISIG` flag is set (the default), typing
    this character causes a *terminal suspend* signal (`SIGTSTP`) to be sent to the
    terminal’s foreground process group ([Process Groups](ch34.html#process_groups
    "Process Groups")). The SUSP character itself is not passed to the reading process.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SUSP 是*暂停*字符。如果设置了 `ISIG` 标志（默认情况），输入此字符会向终端的前台进程组发送一个*终端暂停*信号（`SIGTSTP`）([进程组](ch34.html#process_groups
    "进程组")）。SUSP 字符本身不会传递给正在读取的进程。
- en: WERASE
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WERASE
- en: WERASE is the *word erase* character. In canonical mode, with the `IEXTEN` flag
    set (the default), typing this character erases all characters back to the beginning
    of the previous word. A word is considered to be a sequence of letters, digits,
    and the underscore character. (On some UNIX implementations, a word is considered
    to be delimited by white space.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: WERASE 是*删除词*字符。在规范模式下，当设置了 `IEXTEN` 标志（默认情况），输入此字符会删除从当前光标位置到前一个单词的所有字符。一个单词被认为是由字母、数字和下划线字符组成的序列。（在某些
    UNIX 实现中，一个单词被认为是由空格分隔的。）
- en: Other terminal special characters
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他终端特殊字符
- en: Other UNIX implementations provide terminal special characters in addition to
    those listed in [Table 62-1](ch62.html#terminal_special_characters-id1 "Table 62-1. Terminal
    special characters").
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 UNIX 实现除了 [表 62-1](ch62.html#terminal_special_characters-id1 "表 62-1. 终端特殊字符")
    中列出的字符外，还提供了其他终端特殊字符。
- en: BSD provides the DSUSP and STATUS characters. The DSUSP character (typically
    *Control-Y*) operates in a fashion similar to the SUSP character, but suspends
    the foreground process group only when it attempts to read the character (i.e.,
    after all preceding input has been read). Several non-BSD-derived implementations
    also provide the DSUSP character.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: BSD 提供了 DSUSP 和 STATUS 字符。DSUSP 字符（通常是*Control-Y*）的作用与 SUSP 字符相似，但仅当前台进程组尝试读取字符时才会暂停（即在读取完所有前面的输入之后）。一些非
    BSD 衍生的实现也提供了 DSUSP 字符。
- en: The STATUS character (typically *Control-T*) causes the kernel to display status
    information on the terminal (including the state of the foreground process and
    how much CPU time it has consumed), and sends a `SIGINFO` signal to the foreground
    process group. If desired, processes can catch this signal and display further
    status information. (Linux provides a vaguely similar feature in the form of the
    magic SysRq *key*; see the kernel source file `Documentation/sysrq.txt` for details.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: STATUS 字符（通常是*Control-T*）使内核在终端显示状态信息（包括前台进程的状态以及它消耗的 CPU 时间），并向前台进程组发送一个`SIGINFO`信号。如果需要，进程可以捕获这个信号并显示更多的状态信息。（Linux
    提供了一个相似的功能，称为魔术 SysRq *键*；详情请参见内核源文件 `Documentation/sysrq.txt`。）
- en: System V derivatives provide the SWTCH character. This character is used to
    switch shells under *shell layers*, a System V predecessor to job control.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: System V 衍生版本提供了 SWTCH 字符。这个字符用于在*shell 层*之间切换，这是 System V 的前身，用于作业控制。
- en: Example program
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 62-1](ch62.html#changing_the_terminal_interrupt_characte "Example 62-1. Changing
    the terminal interrupt character") shows the use of *tcgetattr()* and *tcsetattr()*
    to change the terminal *interrupt* character. This program sets the *interrupt*
    character to be the character whose numeric value is supplied as the program’s
    command-line argument, or disables the *interrupt* character if no command-line
    argument is supplied.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell session demonstrates the use of this program. We begin
    by setting the *interrupt* character to *Control-L* (ASCII 12), and then verify
    the change with *stty*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We then start a process running *sleep(1)*. We find that typing *Control-C*
    no longer has its usual effect of terminating a process, but typing *Control-L*
    does terminate the process.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We now display the value of the shell $? variable, which shows the termination
    status of the last command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We see that the termination status of the process was 130\. This indicates that
    the process was killed by signal 130 - 128 = 2; signal number 2 is `SIGINT`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use our program to disable the *interrupt* character.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we find that neither *Control-C* nor *Control-L* generates a `SIGINT` signal,
    and we must instead use *Control-\* to terminate a program:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Example 62-1. Changing the terminal *interrupt* character
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Terminal Flags
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 62-2](ch62.html#terminal_flags-id1 "Table 62-2. Terminal flags") lists
    the settings controlled by each of the four flag fields of the *termios* structure.
    The constants listed in this table correspond to single bits, except those specifying
    the term *mask*, which are values spanning several bits; these may contain one
    of a range of values, shown in parentheses. The column labeled *SUSv3* indicates
    whether the flag is specified in SUSv3\. The *Default* column shows the default
    settings for a virtual console login.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many shells that provide command-line editing facilities perform their own manipulations
    of the flags listed in [Table 62-2](ch62.html#terminal_flags-id1 "Table 62-2. Terminal
    flags"). This means that if we try using *stty(1)* to experiment with these settings,
    then the changes may not be effective when entering shell commands. To circumvent
    this behavior, we must disable command-line editing in the shell. For example,
    command-line editing can be disabled by specifying the command-line option —*noediting*
    when invoking *bash*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Table 62-2. Terminal flags
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '| Field/Flag | Description | Default | SUSv3 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| *c_iflag* |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| `BRKINT` | Signal interrupt (`SIGINT`) on BREAK condition | on | • |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `ICRNL` | Map CR to NL on input | on | • |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `IGNBRK` | Ignore BREAK condition | off | • |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| `IGNCR` | Ignore CR on input | off | • |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| `IGNPAR` | Ignore characters with parity errors | off | • |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| `IMAXBEL` | Ring bell when terminal input queue is full (unused) | (on) |
      |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| `INLCR` | Map NL to CR on input | off | • |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `INPCK` | Enable input parity checking | off | • |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `ISTRIP` | Strip high bit (bit 8) from input characters | off | • |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `IUTF8` | Input is UTF-8 (since Linux 2.6.4) | off |   |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `IUCLC` | Map uppercase to lowercase on input (if `IEXTEN` also set) | off
    |   |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `IXANY` | Allow any character to restart stopped output | off | • |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `IXOFF` | Enable start/stop input flow control | off | • |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `IXON` | Enable start/stop output flow control | on | • |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| `PARMRK` | Mark parity errors (with 2 prefix bytes: 0377 + 0) | off | • |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| *c_oflag* |   |   |   |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| `BSDLY` | Backspace delay mask (`BS0`, `BS1`) | `BS0` | • |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| `CRDLY` | CR delay mask (`CR0`, `CR1`, `CR2`, `CR3`) | `CR0` | • |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| `FFDLY` | Form-feed delay mask (`FF0`, `FF1`) | `FF0` | • |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| `NLDLY` | Newline delay mask (`NL0`, `NL1`) | `NL0` | • |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| `OCRNL` | Map CR to NL on output (see also `ONOCR`) | off | • |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| `OFDEL` | Use DEL (0177) as fill character; otherwise NUL (0) | off | • |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| `OFILL` | Use fill characters for delay (rather than timed delay) | off |
    • |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| `OLCUC` | Map lowercase to uppercase on output | off |   |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| `ONLCR` | Map NL to CR-NL on output | on | • |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| `ONLRET` | Assume NL performs CR function (move to start of line) | off |
    • |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| `ONOCR` | Don’t output CR if already at column 0 (start of line) | off |
    • |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| `OPOST` | Perform output postprocessing | on | • |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| `TABDLY` | Horizontal-tab delay mask (`TAB0`, `TAB1`, `TAB2`, `TAB3`) | `TAB0`
    | • |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| `VTDLY` | Vertical-tab delay mask (`VT0`, `VT1`) | `VT0` | • |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| *c_cflag* |   |   |   |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| `CBAUD` | Baud (bit rate) mask (`B0`, `B2400`, `B9600`, and so on) | `B38400`
    |   |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `CBAUDEX` | Extended baud (bit rate) mask (for rates > 38,400) | off |  
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `CIBAUD` | Input baud (bit rate), if different from output (unused) | (off)
    |   |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `CLOCAL` | Ignore modem status lines (don’t check carrier signal) | off |
    • |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `CMSPAR` | Use “stick” (mark/space) parity | off |   |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| `CREAD` | Allow input to be received | on | • |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| `CRTSCTS` | Enable RTS/CTS (hardware) flow control | off |   |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| `CSIZE` | Character-size mask (5 to 8 bits: `CS5`, `CS6`, `CS7`, `CS8`) |
    `CS8` | • |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| `CSTOPB` | Use 2 stop bits per character; otherwise 1 | off | • |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| `HUPCL` | Hang up (drop modem connection) on last close | on | • |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| `PARENB` | Parity enable | off | • |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| `PARODD` | Use odd parity; otherwise even | off | • |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| *c_lflag* |   |   |   |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| `ECHO` | Echo input characters | on | • |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| `ECHOCTL` | Echo control characters visually (e.g., `^L`) | on |   |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| `ECHOE` | Perform ERASE visually | on | • |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| `ECHOK` | Echo KILL visually | on | • |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| `ECHOKE` | Don’t output a newline after echoed KILL | on |   |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| `ECHONL` | Echo NL (in canonical mode) even if echoing is disabled | off
    | • |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| `ECHOPRT` | Echo deleted characters backward (between `\` and `/`) | off
    |   |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| `FLUSHO` | Output is being flushed (unused) | - |   |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| `ICANON` | Canonical mode (line-by-line) input | on | • |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| `IEXTEN` | Enable extended processing of input characters | on | • |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| `ISIG` | Enable signal-generating characters (INTR, QUIT, SUSP) | on | •
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| `NOFLSH` | Disable flushing on INTR, QUIT, and SUSP | off | • |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| `PENDIN` | Redisplay pending input at next read (not implemented) | (off)
    |   |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| `TOSTOP` | Generate `SIGTTOU` for background output ([Using Job Control Within
    the Shell](ch34.html#using_job_control_within_the_shell "Using Job Control Within
    the Shell")) | off | • |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| `XCASE` | Canonical upper/lowercase presentation (unimplemented) | (off)
    |   |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: 'Several of the flags listed in [Table 62-2](ch62.html#terminal_flags-id1 "Table 62-2. Terminal
    flags") were provided for historical terminals with limited capabilities, and
    these flags have little use on modern systems. For example, the `IUCLC`, `OLCUC`,
    and `XCASE` flags were used with terminals that were capable of displaying only
    uppercase letters. On many older UNIX systems, if a user tried logging in with
    an uppercase username, the *login* program assumed that the user was sitting at
    such a terminal and would set these flags, and then the following password prompt
    would appear:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From this point on, all lowercase characters were output in uppercase, and real
    uppercase characters were preceded by a backslash (\). Similarly, for input, a
    real uppercase character could be specified by a preceding backslash. The `ECHOPRT`
    flag was also designed for limited-capability terminals.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The various delay masks are also historical, allowing for terminals and printers
    that took longer to echo characters such as carriage return and form feed. The
    related `OFILL` and `OFDEL` flags specified how such a delay was to be performed.
    Most of these flags are unused on Linux. One exception is the `TAB3` setting for
    the `TABDLY` mask, which causes tab characters to be output as (up to eight) spaces.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The following paragraphs provide more details about some of the *termios* flags.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: BRKINT
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the `BRKINT` flag is set and the `IGNBRK` flag is not set, then a `SIGINT`
    signal is sent to the foreground process group when a BREAK condition occurs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most conventional dumb terminals provided a *BREAK* key. Pressing this key doesn’t
    actually generate a character, but instead causes a *BREAK condition*, whereby
    a series of 0 bits is sent to the terminal driver for a specified length of time,
    typically 0.25 or 0.5 seconds (i.e., longer than the time required to transmit
    a single byte). (Unless the `IGNBRK` flag has been set, the terminal driver consequently
    delivers a single 0 byte to the reading process.) On many UNIX systems, the BREAK
    condition acted as a signal to a remote host to change its line speed (baud) to
    something suitable for the terminal. Thus, the user would press the *BREAK* key
    until a valid login prompt appeared, indicating that the line speed was now suitable
    for this terminal.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: On a virtual console, we can generate a BREAK condition by pressing *Control-Break*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: ECHO
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the `ECHO` flag enables echoing of input characters. Disabling echoing
    is useful when reading passwords. Echoing is also disabled within the command
    mode of *vi*, where keyboard characters are interpreted as editing commands rather
    than text input. The `ECHO` flag is effective in both canonical and noncanonical
    modes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: ECHOCTL
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If `ECHO` is set, then enabling the `ECHOCTL` flag causes control characters
    other than tab, newline, START, and STOP to be echoed in the form `^A` (for *Control-A*),
    and so on. If `ECHOCTL` is disabled, control characters are not echoed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The control characters are those with ASCII codes less than 32, plus the DEL
    character (127 decimal). A control character, x, is echoed using a caret (`^`)
    followed by the character resulting from the expression (*x ^ 64*). For all characters
    except DEL, the effect of the XOR (`^`) operator in this expression is to add
    64 to the value of the character. Thus, *Control-A* (ASCII 1) is echoed as caret
    plus `A` (ASCII 65). For DEL, the expression has the effect of subtracting 64
    from 127, yielding the value 63, the ASCII code for ?, so that DEL is echoed as
    `^`?.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: ECHOE
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In canonical mode, setting the `ECHOE` flag causes ERASE to be performed visually,
    by outputting the sequence backspace-space-backspace to the terminal. If `ECHOE`
    is disabled, then the ERASE character is instead echoed (e.g., as `^?`), but still
    performs its function of deleting a character.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '`ECHOK` and `ECHOKE`'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `ECHOK` and `ECHOKE` flags control the visual display when using the KILL
    (erase line) character in canonical mode. In the default case (both flags enabled),
    a line is erased visually (see `ECHOE`). If either of these flags is disabled,
    then a visual erase is not performed (but the input line is still discarded),
    and the KILL character is echoed (e.g., as `^U`). If `ECHOK` is set, but not `ECHOKE`,
    then a newline character is also output.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: ICANON
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the `ICANON` flag enables canonical mode input. Input is gathered into
    lines, and special interpretation of the EOF, EOL, EOL2, ERASE, LNEXT, KILL, REPRINT,
    and WERASE characters is enabled (but note the effect of the `IEXTEN` flag described
    below).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: IEXTEN
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Setting the `IEXTEN` flag enables extended processing of input characters.
    This flag (as well as `ICANON`) must be set in order for the following characters
    to be interpreted: EOL2, LNEXT, REPRINT, and WERASE. The `IEXTEN` flag must also
    be set for the `IUCLC` flag to be effective. SUSv3 merely says that the `IEXTEN`
    flag enables extended (implementation-defined) functions; details may vary on
    other UNIX implementations.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: IMAXBEL
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On Linux, the setting of the `IMAXBEL` flag is ignored. On a console login,
    the bell is always rung when the input queue is full.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: IUTF8
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the `IUTF8` flag enables cooked mode ([Cooked, Cbreak, and Raw Modes](ch62.html#cooked_comma_cbreak_comma_and_raw_modes
    "Cooked, Cbreak, and Raw Modes")) to correctly handle UTF-8 input when performing
    line editing.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: NOFLSH
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, when a signal is generated by typing the INTR, QUIT, or SUSP character,
    any outstanding data in the terminal input and output queues is flushed (discarded).
    Setting the `NOFLSH` flag disables such flushing.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: OPOST
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the `OPOST` flag enables output postprocessing. This flag must be set
    in order for any of the flags in the *c_oflag* field of the *termios* structure
    to be effective. (Put conversely, disabling the `OPOST` flag prevents all output
    postprocessing.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: PARENB, IGNPAR, INPCK, PARMRK, and PARODD
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `PARENB`, `IGNPAR`, `INPCK`, `PARMRK`, and `PARODD` flags are concerned
    with parity generation and checking.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The `PARENB` flag enables generation of parity check bits for output characters
    and parity checking for input characters. If we want to perform only output parity
    generation, then we can disable input parity checking by turning `INPCK` off.
    If the `PARODD` flag is set, then odd parity is used in both cases; otherwise,
    even parity is used.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The remaining flags specify how an input character with parity errors should
    be handled. If the `IGNPAR` flag is set, the character is discarded (not passed
    to the reading process). Otherwise, if the `PARMRK` flag is set, then the character
    is passed to the reading process, but is preceded by the 2-byte sequence 0377
    + 0\. (If the `PARMRK` flag is set and `ISTRIP` is clear, then a real 0377 character
    is doubled to become 0377 + 0377.) If `PARMRK` is not set, but `INPCK` is set,
    then the character is discarded, and a 0 byte is passed to the reading process
    instead. If none of `IGNPAR`, `PARMRK`, or `INPCK` is set, then the character
    is passed as is to the reading process.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 62-2](ch62.html#disabling_terminal_echoing "Example 62-2. Disabling
    terminal echoing") demonstrates the use of *tcgetattr()* and *tcsetattr()* to
    turn off the `ECHO` flag, so that input characters are not echoed. Here is an
    example of what we see when running this program:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Example 62-2. Disabling terminal echoing
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Terminal I/O Modes
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already noted that the terminal driver is capable of handling input
    in either canonical or noncanonical mode, depending on the setting of the `ICANON`
    flag. We now describe these two modes in detail. We then describe three useful
    terminal modes—cooked, cbreak, and raw—that were available in Seventh Edition
    UNIX, and show how these modes are emulated on modern UNIX systems by setting
    appropriate values in the *termios* structure.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Canonical Mode
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Canonical mode input is enabled by setting the `ICANON` flag. Terminal input
    in canonical mode is distinguished by the following features:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Input is gathered into lines, terminated by one of the line-delimiter characters:
    NL, EOL, EOL2 (if the `IEXTEN` flag is set), EOF (at anything other than the initial
    position in the line), or CR (if the `ICRNL` flag is enabled). Except in the case
    of EOF, the line delimiter is passed back to the reading process (as the last
    character in the line).'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line editing is enabled, so that the current line of input can be modified.
    Thus, the following characters are enabled: ERASE, KILL, and, if the `IEXTEN`
    flag is set, WERASE.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `IEXTEN` flag is set, the REPRINT and LNEXT characters are also enabled.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In canonical mode, a terminal *read()* returns when a complete line of input
    is available. (The *read()* itself may fetch only part of that line if it requested
    fewer bytes; remaining bytes will be fetched by subsequent calls to *read()*.)
    A *read()* may also terminate if interrupted by a signal handler and restarting
    of system calls is not enabled for this signal ([Interruption and Restarting of
    System Calls](ch21.html#interruption_and_restarting_of_system_ca "Interruption
    and Restarting of System Calls")).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While describing the `NOFLSH` flag in [Terminal Flags](ch62.html#terminal_flags
    "Terminal Flags"), we noted that the characters that generate signals also cause
    the terminal driver to flush the terminal input queue. This flushing occurs regardless
    of whether the signal is caught or ignored by an application. We can prevent such
    flushing by enabling the `NOFLSH` flag.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Noncanonical Mode
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some applications (e.g., *vi* and *less*) need to read characters from the terminal
    without the user supplying a line delimiter. Noncanonical mode is provided for
    this purpose. In noncanonical mode (`ICANON` unset), no special input processing
    is performed. In particular, input is no longer gathered into lines, but is instead
    available immediately.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'In what circumstances does a noncanonical *read()* complete? We can specify
    that a noncanonical *read()* terminates after a certain time, after a certain
    number of bytes have been read, or both in combination. Two elements of the *termios
    c_cc* array determine the behavior: TIME and MIN. The TIME element (indexed using
    the constant `VTIME`) specifies a timeout value in tenths of a second. The MIN
    element (indexed using `VMIN`) specifies the minimum number of bytes to be read.
    (The MIN and TIME settings have no effect on canonical-mode terminal I/O.)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The precise operation and interaction of the MIN and TIME parameters depends
    on whether they each have nonzero values. The four possible cases are described
    below. Note that in all cases, if, at the time of a *read()*, sufficient bytes
    are already available to satisfy the requirements specified by MIN, *read()* returns
    immediately with the lesser of the number of bytes available and the number of
    bytes requested.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: MIN == 0, TIME == 0 (polling read)
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If data is available at the time of the call, then *read()* returns immediately
    with the lesser of the number of bytes available or the number of bytes requested.
    If no bytes are available, *read()* completes immediately, returning 0.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: This case serves the usual requirements of polling, allowing the application
    to check if input is available without blocking if it is not. This mode is somewhat
    similar to setting the `O_NONBLOCK` flag for the terminal ([Nonblocking I/O](ch05.html#nonblocking_i_solidus_o
    "Nonblocking I/O")). However, with `O_NONBLOCK`, if no bytes are available for
    reading, then *read()* returns -1 with the error `EAGAIN`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: MIN > 0, TIME == 0 (blocking read)
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *read()* blocks (possibly indefinitely) until the lesser of the number of
    bytes requested or MIN bytes are available, and returns the lesser of the two
    values.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Programs such as *less* typically set MIN to 1 and TIME to 0\. This allows the
    program to wait for single key presses without needing to waste CPU time by polling
    in a busy loop.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: If a terminal is placed in noncanonical mode with MIN set to 1 and TIME set
    to 0, then the techniques described in [Chapter 63](ch63.html "Chapter 63. Alternative
    I/O Models") can be used to check whether a single character (rather than a complete
    line) has been typed at the terminal.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: MIN == 0, TIME > 0 (read with timeout)
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A timer is started when *read()* is called. The call returns as soon as at least
    1 byte is available, or when TIME tenths of a second have elapsed. In the latter
    case, *read()* returns 0.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: This case is useful for programs talking to a serial device (e.g., a modem).
    The program can send data to the device and then wait for a response, using a
    timeout to avoid hanging forever in case the device doesn’t respond.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: MIN > 0, TIME > 0 (read with interbyte timeout)
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After the initial byte of input becomes available, a timer is restarted as each
    further byte is received. The *read()* returns when either the lesser of MIN bytes
    or the number of bytes requested have been read, or when the time between receiving
    successive bytes exceeds TIME tenths of a second. Since the timer is started only
    after the initial byte becomes available, at least 1 byte is returned. (A *read()*
    can block indefinitely for this case.)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: This case is useful for handling terminal keys that generate escape sequences.
    For example, on many terminals, the left-arrow key generates the 3-character sequence
    consisting of *Escape* followed by `OD`. These characters are transmitted in quick
    succession. Applications handling such sequences need to distinguish the pressing
    of such a key from the situation where the user slowly types each of the characters
    individually. This can be done by performing a *read()* with a small interbyte
    timeout, say 0.2 seconds. Such a technique is used in the command mode of some
    versions of *vi*. (Depending on the length of the timeout, in such applications,
    we may be able to simulate a left-arrow key press by quickly typing the aforementioned
    3-character sequence.)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Portably modifying and restoring MIN and TIME
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For historical compatibility with some UNIX implementations, SUSv3 allows the
    values of the `VMIN` and `VTIME` constants to be the same as `VEOF` and `VEOL`,
    respectively, which means that these elements of the *termios c_cc* array may
    coincide. (On Linux, the values of these constants are distinct.) This is possible
    because `VEOF` and `VEOL` are unused in noncanonical mode. The fact that `VMIN`
    and `VEOF` may have the same value means that caution is needed in a program that
    enters noncanonical mode, sets MIN (typically to 1), and then later returns to
    canonical mode. On return to canonical mode, EOF will no longer have its usual
    value of ASCII 4 (*Control-D*). The portable way to deal with this problem is
    to save a copy of the *termios* settings prior to changing to noncanonical mode,
    and then use this saved structure to return to canonical mode.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Cooked, Cbreak, and Raw Modes
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The terminal driver in Seventh Edition UNIX (as well as in early versions of
    BSD) was capable of handling input in three modes: *cooked*, *cbreak*, and *raw*.
    The differences between the three modes are summarized in [Table 62-3](ch62.html#differences_between_cooked_comma_cbreak
    "Table 62-3. Differences between cooked, cbreak, and raw terminal modes").'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Table 62-3. Differences between cooked, cbreak, and raw terminal modes
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Mode |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| Cooked | Cbreak | Raw |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| Input available | line by line | char. by char. | char. by char. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| Line-editing? | yes | no | no |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| Signal-generating characters interpreted? | yes | yes | no |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| START/STOP interpreted? | yes | yes | no |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| Other special characters interpreted? | yes | no | no |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| Other input processing performed? | yes | yes | no |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| Other output processing performed? | yes | yes | no |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| Input echoed? | yes | maybe | no |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: Cooked mode was essentially canonical mode with all of the default special character
    processing enabled (i.e., interpretation of `CR`, `NL`, and `EOF`; enabling of
    line editing; handling of signal-generating characters; `ICRNL`; `OCRNL`; and
    so on).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Raw mode was the converse: noncanonical mode, with all input and output processing,
    as well as echoing, switched off. (An application that needed to ensure that the
    terminal driver makes absolutely no changes to the data transferred across a serial
    line would use this mode.)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Cbreak mode was intermediate between cooked and raw modes. Input was noncanonical,
    but signal-generating characters were interpreted, and the various input and output
    transformations could still occur (depending on individual flag settings). Cbreak
    mode did not disable echoing, but applications employing this mode would usually
    disable echoing as well. Cbreak mode was useful in screen-handling applications
    (such as *less*) that permitted character-by-character input, but still needed
    to allow interpretation of characters such as INTR, QUIT, and SUSP.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: setting raw and cbreak mode'
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the Seventh Edition and the original BSD terminal drivers, it was possible
    to switch to raw or cbreak mode by tweaking single bits (called `RAW` and `CBREAK`)
    in the terminal driver data structures. With the transition to the POSIX *termios*
    interface (now supported on all UNIX implementations), single bits for selecting
    raw and cbreak mode are no longer available, and applications emulating these
    modes must explicitly change the required fields of the *termios* structure. [Example 62-3](ch62.html#switching_a_terminal_to_cbreak_and_raw_m
    "Example 62-3. Switching a terminal to cbreak and raw modes") provides two functions,
    *ttySetCbreak()* and *ttySetRaw()*, that implement the equivalents of these terminal
    modes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications that use the *ncurses* library can call the functions *cbreak()*
    and *raw()*, which perform similar tasks to our functions in [Example 62-3](ch62.html#switching_a_terminal_to_cbreak_and_raw_m
    "Example 62-3. Switching a terminal to cbreak and raw modes").
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Example 62-3. Switching a terminal to cbreak and raw modes
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A program that places the terminal in raw or cbreak mode must be careful to
    return the terminal to a usable mode when it terminates. Among other tasks, this
    entails handling all of the signals that are likely to be sent to the program,
    so that the program is not prematurely terminated. (Job-control signals can still
    be generated from the keyboard in cbreak mode.)
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of how to do this is provided in [Example 62-4](ch62.html#demonstrating_cbreak_and_raw_modes
    "Example 62-4. Demonstrating cbreak and raw modes"). This program performs the
    following steps:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Set the terminal to either cbreak mode ![](figs/web/U009.png) or raw mode ![](figs/web/U012.png),
    depending on whether a command-line argument (any string) is supplied ![](figs/web/U008.png).
    The previous terminal settings are saved in the global variable *userTermios*
    ![](figs/web/U001.png).
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the terminal was placed in cbreak mode, then signals can be generated from
    the terminal. These signals need to be handled so that terminating or suspending
    the program leaves the terminal in a state that the user expects. The program
    installs the same handler for `SIGQUIT` and `SIGINT` ![](figs/web/U010.png). The
    `SIGTSTP` signal requires special treatment, so a different handler is installed
    for that signal ![](figs/web/U011.png).
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install a handler for the `SIGTERM` signal, in order to catch the default signal
    sent by the *kill* command ![](figs/web/U013.png).
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute a loop that reads characters one at a time from *stdin* and echoes
    them on standard output ![](figs/web/U014.png). The program treats various input
    characters specially before outputting them ![](figs/web/U015.png):'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All letters are converted to lowercase before being output.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The newline (`\n`) and carriage return (`\r`) characters are echoed without
    change.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Control characters other than the newline and carriage return are echoed as
    a 2-character sequence: caret (`^`) plus the corresponding uppercase letter (e.g.,
    *Control-A* echoes as `^A`).'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All other characters are echoed as asterisks (`*`).
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The letter *q* causes the loop to terminate ![](figs/web/U016.png).
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On exit from the loop, restore the terminal to its state as last set by the
    user, and then terminate ![](figs/web/U017.png).
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program installs the same handler for `SIGQUIT`, `SIGINT`, and `SIGTERM`.
    This handler restores the terminal to its state as last set by the user and terminates
    the program ![](figs/web/U002.png).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'The handler for the `SIGTSTP` signal ![](figs/web/U003.png) deals with the
    signal in the manner described in [Handling Job-Control Signals](ch34.html#handling_job-control_signals
    "Handling Job-Control Signals"). Note the following additional details of the
    operation of this signal handler:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Upon entry, the handler saves the current terminal settings (in *ourTermios*)
    ![](figs/web/U004.png), and then resets the terminal to the settings that were
    in effect (saved in *userTermios*) when the program was started ![](figs/web/U005.png),
    before once more raising `SIGTSTP` to actually stop the process.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon resumption of execution after receipt of `SIGCONT`, the handler once more
    saves the current terminal settings in *userTermios* ![](figs/web/U006.png), since
    the user may have changed the settings while the program was stopped (using the
    *stty* command, for example). The handler then returns the terminal to the state
    (*ourTermios*) required by the program ![](figs/web/U007.png).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 62-4. Demonstrating cbreak and raw modes
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is an example of what we see when we ask the program in [Example 62-4](ch62.html#demonstrating_cbreak_and_raw_modes
    "Example 62-4. Demonstrating cbreak and raw modes") to use raw mode:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the last line of the preceding shell session, we see that the shell printed
    its prompt on the same line as the *q* character that caused the program to terminate.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows an example run using cbreak mode:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Terminal Line Speed (Bit Rate)
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Different terminals (and serial lines) are capable of transmitting and receiving
    at different speeds (bits per second). The *cfgetispeed()* and *cfsetispeed()*
    functions retrieve and modify the input line speed. The *cfgetospeed()* and *cfsetospeed()*
    functions retrieve and modify the output line speed.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term *baud* is commonly used as a synonym for the terminal line speed (in
    bits per second), although this usage is not technically correct. Precisely, baud
    is the per-second rate at which signal changes can occur on the line, which is
    not necessarily the same as the number of bits transmitted per second, since the
    latter depends on how bits are encoded into signals. Nevertheless, the term *baud*
    continues to be used synonymously with *bit rate* (bits per second). (The term
    *baud rate* is often also used synonymously with *baud*, but this is redundant;
    the baud is by definition a rate.) To avoid confusion, we’ll generally use terms
    like *line speed* or *bit rate*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return a line speed from given *termios* structure
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both return 0 on success, or -1 on error
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Each of these functions works on a *termios* structure that must be previously
    initialized by a call to *tcgetattr()*.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to find out the current terminal output line speed, we would do
    the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we then wanted to change this line speed, we would continue as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The *speed_t* data type is used to store a line speed. Rather than directly
    assigning numeric values for line speeds, a set of symbolic constants (defined
    in `<termios.h>`) is used. These constants define a series of discrete values.
    Some examples of such constants are `B300`, `B2400`, `B9600`, and `B38400`, corresponding,
    respectively, to the line speeds 300, 2400, 9600, and 38,400 bits per second.
    The use of a set of discrete values reflects the fact that terminals are normally
    designed to work with a limited set of different (standardized) line speeds, derived
    from the division of some base rate (e.g., 115,200 is typical on PCs) by integral
    values (e.g., 115,200 / 12 = 9600).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 specifies that the terminal line speeds are stored in the *termios* structure,
    but (deliberately) does not specify where. Many implementations, including Linux,
    maintain these values in the *c_cflag* field, using the `CBAUD` mask and the `CBAUDEX`
    flag. (In [Retrieving and Modifying Terminal Attributes](ch62.html#retrieving_and_modifying_terminal_attrib
    "Retrieving and Modifying Terminal Attributes"), we noted that the nonstandard
    *c_ispeed* and *c_ospeed* fields of the Linux *termios* structure are unused.)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Although the *cfsetispeed()* and *cfsetospeed()* functions allow separate input
    and output line speeds to be specified, on many terminals, these two speeds must
    be the same. Furthermore, Linux uses only a single field to store the line speed
    (i.e., the two rates are assumed to be always the same), which means that all
    of the input and output line-speed functions access the same *termios* field.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specifying *speed* as 0 in a call to *cfsetispeed()* means “set the input speed
    to whatever the output speed is when *tcsetattr()* is later called.” This is useful
    on systems where the two line speeds are maintained as separate values.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Terminal Line Control
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *tcsendbreak()*, *tcdrain()*, *tcflush()*, and *tcflow()* functions perform
    tasks that are usually collectively grouped under the term *line control*. (These
    functions are POSIX inventions designed to replace various *ioctl()* operations.)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All return 0 on success, or -1 on error
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: In each function, *fd* is a file descriptor that refers to a terminal or other
    remote device on a serial line.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: The *tcsendbreak()* function generates a BREAK condition, by transmitting a
    continuous stream of 0 bits. The *duration* argument specifies the length of the
    transmission. If *duration* is 0, 0 bits are transmitted for 0.25 seconds. (SUSv3
    specifies at least 0.25 and not more than 0.5 seconds.) If *duration* is greater
    than 0, 0 bits are transmitted for *duration* milliseconds. SUSv3 leaves this
    case unspecified; the handling of a nonzero *duration* varies widely on other
    UNIX implementations (the details described here are for *glibc*).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: The *tcdrain()* function blocks until all output has been transmitted (i.e.,
    until the terminal output queue has been emptied).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The *tcflush()* function flushes (discards) the data in the terminal input queue,
    the terminal output queue, or both queues (see [Figure 62-1](ch62.html#input_and_output_queues_for_a_terminal_d
    "Figure 62-1. Input and output queues for a terminal device")). Flushing the input
    queue discards data that has been received by the terminal driver but not yet
    read by any process. For example, an application can use *tcflush()* to discard
    terminal type-ahead before prompting for a password. Flushing the output queue
    discards data that has been written (passed to the terminal driver) but not yet
    transmitted to the device. The *queue_selector* argument specifies one of the
    values shown in [Table 62-4](ch62.html#values_for_the_tcflush_open_parenthesis
    "Table 62-4. Values for the tcflush() queue_selector argument").
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the term *flush* is used in a different sense with *tcflush()* than
    when talking about file I/O. For file I/O, *flushing* means forcing the output
    to be transferred either user-space memory to the buffer cache in the case of
    the *stdio fflush()*, or from the buffer cache to the disk, in the case of *fsync()*,
    *fdatasync()*, and *sync()*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Table 62-4. Values for the *tcflush() queue_selector* argument
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: '| `TCIFLUSH` | Flush the input queue |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| `TCOFLUSH` | Flush the output queue |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| `TCIOFLUSH` | Flush both the input and the output queues |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: The *tcflow()* function controls the flow of data in either direction between
    the computer and the terminal (or other remote device). The *action* argument
    is one of the values shown in [Table 62-5](ch62.html#values_for_the_tcflush_open_parenthe
    "Table 62-5. Values for the tcflush() action argument"). The `TCIOFF` and `TCION`
    values are effective only if the terminal is capable of interpreting STOP and
    START characters, in which case these operations respectively cause the terminal
    to suspend and resume sending data to the computer, respectively.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Table 62-5. Values for the *tcflush() action* argument
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| `TCOOFF` | Suspend output to the terminal |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| `TCOON` | Resume output to the terminal |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| `TCIOFF` | Transmit a STOP character to the terminal |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '| `TCION` | Transmit a START character to the terminal |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
- en: Terminal Window Size
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a windowing environment, a screen-handling application needs to be able
    to monitor the size of a terminal window, so that the screen can be redrawn appropriately
    if the user modifies the window size. The kernel provides two pieces of support
    to allow this to happen:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: A `SIGWINCH` signal is sent to the foreground process group after a change in
    the terminal window size. By default, this signal is ignored.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At any time—usually following the receipt of a `SIGWINCH` signal—a process can
    use the *ioctl()* `TIOCGWINSZ` operation to find out the current size of the terminal
    window.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *ioctl()* `TIOCGWINSZ` operation is used as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The *fd* argument is a file descriptor referring to a terminal window. The
    final argument to *ioctl()* is a pointer to a *winsize* structure (defined in
    `<sys/ioctl.h>`), used to return the terminal window size:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Like many other implementations, Linux doesn’t use the pixel-size fields of
    the *winsize* structure.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 62-5](ch62.html#monitoring_changes_in_the_terminal_windo "Example 62-5. Monitoring
    changes in the terminal window size") demonstrates the use of the `SIGWINCH` signal
    and the *ioctl()* `TIOCGWINSZ` operation. The following shows an example of the
    output produced when this program is run under a window manager and the terminal
    window size is changed three times:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Example 62-5. Monitoring changes in the terminal window size
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It is also possible to change the terminal driver’s notion of the window size
    by passing an initialized *winsize* structure in an *ioctl()* `TIOCSWINSZ` operation:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the new values in the *winsize* structure differ from the terminal driver’s
    current notion of the terminal window size, two things happen:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: The terminal driver data structures are updated using the values supplied in
    the *ws* argument.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `SIGWINCH` signal is sent to the foreground process group of the terminal.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, however, that these events on their own are insufficient to change the
    actual dimensions of the displayed window, which are controlled by software outside
    the kernel (such as a window manager or a terminal emulator program).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Although not standardized in SUSv3, most UNIX implementations provide access
    to the terminal window size using the *ioctl()* operations described in this section.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Terminal Identification
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Controlling Terminals and Controlling Processes](ch34.html#controlling_terminals_and_controlling_pr
    "Controlling Terminals and Controlling Processes"), we described the *ctermid()*
    function, which returns the name of the controlling terminal for a process (usually
    `/dev/tty` on UNIX systems). The functions described in this section are also
    useful for identifying a terminal.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: The *isatty()* function enables us to determine whether a file descriptor, *fd*,
    is associated with a terminal (as opposed to some other file type).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns true (1) if *fd* is associated with a terminal, otherwise false (0)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: The *isatty()* function is useful in editors and other screen-handling programs
    that need to determine whether their standard input and output are directed to
    a terminal.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Given a file descriptor, the *ttyname()* function returns the name of the associated
    terminal device.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns pointer to (statically allocated) string containing terminal name, or
    `NULL` on error
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the name of the terminal, *ttyname()* uses the *opendir()* and *readdir()*
    functions described in [Reading Directories: *opendir()* and *readdir()*](ch18.html#reading_directories_colon_opendir_open_p
    "Reading Directories: opendir() and readdir()") to walk through the directories
    holding terminal device names, looking at each directory entry until it finds
    one whose device ID (the *st_rdev* field of the *stat* structure) matches that
    of the device referred to by the file descriptor *fd*. Terminal device entries
    normally reside in two directories: `/dev` and `/dev/pts`. The `/dev` directory
    contains entries for virtual consoles (e.g., `/dev/tty1`) and BSD pseudoterminals.
    The `/dev/pts` directory contains entries for (System V-style) pseudoterminal
    slave devices. (We describe pseudoterminals in [Chapter 64](ch64.html "Chapter 64. Pseudoterminals").)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reentrant version of *ttyname()* exists in the form of *ttyname_r()*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: The *tty(1)* command, which displays the name of the terminal referred to by
    its standard input, is the command-line analog of *ttyname()*.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On early UNIX systems, terminals were real hardware devices connected to a computer
    via serial lines. Early terminals were not standardized, meaning that different
    escape sequences were required to program the terminals produced by different
    vendors. On modern workstations, such terminals have been superseded by bit-mapped
    monitors running the X Window System. However, the ability to program terminals
    is still required when dealing with virtual devices, such as virtual consoles
    and terminal emulators (which employ pseudoterminals), and real devices connected
    via serial lines.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Terminal settings (with the exception of the terminal window size) are maintained
    in a structure of type *termios*, which contains four bit-mask fields that control
    various terminal settings and an array that defines the various special characters
    interpreted by the terminal driver. The *tcgetattr()* and *tcsetattr()* functions
    allow a program to retrieve and modify the terminal settings.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: When performing input, the terminal driver can operate in two different modes.
    In canonical mode, input is gathered into lines (terminated by one of the line-delimiter
    characters) and line editing is enabled. By contrast, noncanonical mode allows
    an application to read terminal input a character at a time, without needing to
    wait for the user to type a line-delimiter character. Line editing is disabled
    in noncanonical mode. Completion of a noncanonical mode read is controlled by
    the MIN and TIME fields of the *termios* structure, which determine the minimum
    number of characters to be read and a timeout to be applied to the read operation.
    We described four distinct cases for the operation of noncanonical reads.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the Seventh Edition and BSD terminal drivers provided three input
    modes—cooked, cbreak, and raw—which performed varying degrees of processing of
    terminal input and output. Cbreak and raw modes can be emulated by changing various
    fields within the *termios* structure.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: A range of functions perform various other terminal operations. These include
    changing the terminal line speed and performing line-control operations (generating
    a break condition, pausing until output has been transmitted, flushing terminal
    input and output queues, and suspending or resuming transmission of data in either
    direction between the terminal and the computer). Other functions allow us to
    check if a given file descriptor refers to a terminal and to obtain the name of
    that terminal. The *ioctl()* system call can be used to retrieve and modify the
    terminal window size recorded by the kernel, and to perform a range of other terminal-related
    operations.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Stevens, 1992] also describes terminal programming and goes into much more
    detail on programming serial ports. Several good online resources discuss terminal
    programming. Hosted at the LDP web site ([http://www.tldp.org](http://www.tldp.org))
    are the *Serial HOWTO* and the *Text-terminal HOWTO*, both by David S. Lawyer.
    Another useful source of information is the *Serial Programming Guide for POSIX
    Operating Systems* by Michael R. Sweet, available online at [http://www.easysw.com/~mike/serial/](http://www.easysw.com/~mike/serial/).'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implement *isatty()*. (You may find it useful to read the description of *tcgetattr()*
    in Section 62.2.)
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement *ttyname()*.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the *getpass()* function described in Section 8.5\. (The *getpass()*
    function can obtain a file descriptor for the controlling terminal by opening
    `/dev/tty`.)
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that displays information indicating whether the terminal referred
    to by standard input is in canonical or noncanonical mode. If in noncanonical
    mode, then display the values of TIME and MIN.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
