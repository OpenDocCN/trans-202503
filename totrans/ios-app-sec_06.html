<html><head></head><body>
<h2 class="h2" id="ch04"><a id="page_41"/><strong><span class="big">4</span></strong><br/><strong>BUILDING YOUR TEST PLATFORM</strong></h2>
<p class="noindent">In this chapter, I’ll outline the tools you need to review your code and test your iOS applications, and I’ll show you how to build a robust and useful test platform. That test platform will include a properly set up Xcode instance, an interactive network proxy, reverse engineering tools, and tools to bypass iOS platform security checks.</p>
<p class="indent">I’ll also cover the settings you need to change in Xcode projects to make bugs easier to identify and fix. You’ll then learn to leverage Xcode’s static analyzer and compiler options to produce well-protected binaries and perform more in-depth bug detection.</p>
<h3 class="h3" id="ch04lev1sec01"><strong>Taking Off the Training Wheels</strong></h3>
<p class="noindent">A number of behaviors in a default OS X install prevent you from really digging in to the system internals. To get your OS to stop hiding the things you need, enter the following commands at a Terminal prompt:</p>
<p class="programs">$ defaults write com.apple.Finder AppleShowAllFiles TRUE<br/>$ defaults write com.apple.Finder ShowPathbar -bool true<br/>$ defaults write com.apple.Finder _FXShowPosixPathInTitle -bool true<br/>$ defaults write NSGlobalDomain AppleShowAllExtensions -bool true<br/>$ chflags nohidden ~/Library/</p>
<p class="indent"><a id="page_42"/>These settings let you see all the files in the Finder, even ones that are hidden from view because they have a dot in front of their name. In addition, these changes will display more path information and file extensions, and most importantly, they allow you to see your user-specific <em>Library</em>, which is where the iOS Simulator will store all of its data.</p>
<p class="indent">The <span class="literal">chflags</span> command removes a level of obfuscation that Apple has put on directories that it considers too complicated for you, such as <em>/tmp</em> or <em>/usr</em>. I’m using the command here to show the contents of the iOS Simulator directories without having to use the command line every time.</p>
<p class="indent">One other thing: consider adding <em>$SIMPATH</em> to the Finder’s sidebar for easy access. It’s convenient to use <em>$SIMPATH</em> to examine the iOS Simulator’s filesystem, but you can’t get to it in the Finder by default. To make this change, browse to the following directory in the Terminal:</p>
<p class="programs">$ cd ~/Library/Application\ Support<br/>$ open .</p>
<p class="indent">Then, in the Finder window that opens, drag the iPhone Simulator directory to the sidebar. Once you’re riding without training wheels, it’s time to choose your testing device.</p>
<h3 class="h3" id="ch04lev1sec02"><strong>Suggested Testing Devices</strong></h3>
<p class="noindent">My favorite test device is the Wi-Fi only iPad because it’s inexpensive and easy to jailbreak, which allows for testing iPad, iPhone, and iPod Touch applications. Its lack of cellular-based networking isn’t much of a hindrance, given that you’ll want to intercept network traffic most of the time anyway.</p>
<p class="indent">But this configuration does have some minor limitations. Most significantly, the iPad doesn’t have GPS or SMS, and it obviously doesn’t make phone calls. So it’s not a bad idea to have an actual iPhone of some kind available.</p>
<p class="indent">I prefer to have at least two iPads handy for iOS testing: one jailbroken and one stock. The stock device allows for testing in a legitimate, realistic end-user environment, and it has all platform security mechanisms still intact. It can also register properly for push notifications, which has proven problematic for jailbroken devices in the past. The jailbroken device allows you to more closely inspect the filesystem layout and more detailed workings of iOS; it also facilitates black-box testing that wouldn’t be feasible using a stock device alone.</p>
<h3 class="h3" id="ch04lev1sec03"><a id="page_43"/><strong>Testing with a Device vs. Using a Simulator</strong></h3>
<p class="noindent">Unlike some other mobile operating systems, iOS development uses a <em>simulator</em> rather than an emulator. This means there’s no full emulation of the iOS device because that would require a virtualized ARM environment. Instead, the simulators that Apple distributes with Xcode are compiled for the x64 architecture, and they run natively on your development machine, which makes the process significantly faster and easier. (Try to boot the Android emulator inside a virtual machine, and you’ll appreciate this feature.)</p>
<p class="indentb">On the flip side, some things simply don’t work the same way in the iOS Simulator as they do on the device. The differences are as follows:</p>
<p class="hanging"><strong>Case-sensitivity</strong> Unless you’ve intentionally changed this behavior, OS X systems operate with case-insensitive HFS+ filesystems, while iOS uses the case-sensitive variant. This should rarely be relevant to security but can cause interoperability issues when modifying programs.</p>
<p class="hanging"><strong>Libraries</strong> In some cases, iOS Simulator binaries link to OS X frameworks that may behave differently than those on iOS. This can result in slightly different behavior.</p>
<p class="hanging"><strong>Memory and performance</strong> Since applications run natively in the iOS Simulator, they’ll be taking full advantage of your development machine’s resources. When gauging the impact of things such as PBKDF2 rounds (see <a href="ch13.html#ch13">Chapter 13</a>), you’ll want to compensate for this or test on a real device.</p>
<p class="hanging"><strong>Camera</strong> As of now, the iOS Simulator does not use your development machine’s camera. This is rarely a huge issue, but some applications do contain functionality such as “Take a picture of my check stub or receipt,” where the handling of this photo data can be crucial.</p>
<p class="hanging"><strong>SMS and cellular</strong> You can’t test interaction with phone calls or SMS integration with the iOS Simulator, though you can technically simulate some aspects, such as toggling the “in-call” status bar.</p>
<p class="indentt">Unlike in older versions of iOS, modern versions of the iOS Simulator do in fact simulate the Keychain API, meaning you can manage your own certificate and store and manipulate credentials. You can find the files behind this functionality in <em>$SIMPATH/Library/Keychains</em>.</p>
<h3 class="h3" id="ch04lev1sec04"><strong>Network and Proxy Setup</strong></h3>
<p class="noindent">Most of the time, the first step in testing any iOS application is to run it through a proxy so you can examine and potentially modify traffic going from the device to its remote endpoint. Most iOS security testers I know use BurpSuite<sup><a href="footnote.html#fn23" id="fn_23">1</a></sup> for this purpose.</p>
<h4 class="h4" id="ch04lev2sec01"><a id="page_44"/><em><strong>Bypassing TLS Validation</strong></em></h4>
<p class="noindent">There’s one major catch to running an app under test through a proxy: iOS resolutely refuses to continue TLS/SSL connections when it cannot authenticate the server’s certificate, as well it should. This is, of course, the correct behavior, but your proxy-based testing will screech to a halt rather quickly if iOS can’t authenticate your proxy’s certificate.</p>
<p class="indent">For BurpSuite specifically, you can obtain a CA certificate simply by configuring your device or iOS Simulator to use Burp as a proxy and then browsing to <em><a href="http://burp/cert/">http://burp/cert/</a></em> in Mobile Safari. This should work either on a real device or in the iOS Simulator. You can also install CA certificates onto a physical device by either emailing them to yourself or navigating to them on a web server.</p>
<p class="indent">For the iOS Simulator, a more general approach that works with almost any web proxy is to add the fingerprint of your proxy software’s CA certificate directly into the iOS Simulator trust store. The trust store is a SQLite database, making it slightly more cumbersome to edit than typical certificate bundles. I recommend writing a script to automate this task. If you want to see an example to get you started, Gotham Digital Science has already created a Python script that does the job. You’ll find the script here: <em><a href="https://github.com/GDSSecurity/Add-Trusted-Certificate-to-iOS-Simulator/">https://github.com/GDSSecurity/Add-Trusted-Certificate-to-iOS-Simulator/</a></em>.</p>
<p class="indent">To use this script, you need to obtain the CA certificate you want to install into the trust store. First configure Firefox<sup><a href="footnote.html#fn24" id="fn_24">2</a></sup> to use your local proxy (127.0.0.1, port 8080 for Burp). Then attempt to visit any SSL site; you should get a familiar certificate warning. Navigate to <strong>Add Exception</strong> → <strong>View</strong> → <strong>Details</strong> and click the <strong>PortSwigger CA</strong> entry, as shown in <a href="ch04.html#ch4fig1">Figure 4-1</a>.</p>
<p class="indent">Click <strong>Export</strong> and follow the prompts. Once you’ve saved the CA certificate, open <em>Terminal.app</em> and run the Python script to add the certificate to the store as follows:</p>
<p class="programs">$ python ./add_ca_to_iossim.py ~/Downloads/PortSwiggerCA.pem</p>
<p class="indent">Unfortunately, at the time of writing, there isn’t a native way to configure the iOS Simulator to go through an HTTP proxy without also routing the rest of your system through the proxy. Therefore, you’ll need to configure the proxy in your host system’s Preferences, as shown in <a href="ch04.html#ch4fig2">Figure 4-2</a>.</p>
<p class="indent">If you’re using the machine for both testing and other work activities, you might consider specifically configuring other applications to go through a separate proxy, using something like FoxyProxy<sup><a href="footnote.html#fn25" id="fn_25">3</a></sup> for your browser.</p>
<div class="image"><a id="page_45"/><img alt="image" src="graphics/f04-01.jpg"/></div>
<p class="figcap"><a id="ch4fig1"/><em>Figure 4-1: Selecting the PortSwigger CA for export</em></p>
<div class="image"><img alt="image" src="graphics/f04-02.jpg"/></div>
<p class="figcap"><a id="ch4fig2"/><em>Figure 4-2: Configuring the host system to connect via Burp</em></p>
<h4 class="h4" id="ch04lev2sec02"><a id="page_46"/><em><strong>Bypassing SSL with stunnel</strong></em></h4>
<p class="noindent">One method of bypassing SSL endpoint verification is to set up a termination point locally and then direct your application to use that instead. You can often accomplish this without recompiling the application, simply by modifying a plist file containing the endpoint URL.</p>
<p class="indent">This setup is particularly useful if you want to observe traffic easily in plaintext (for example, with Wireshark), but the Internet-accessible endpoint is available only over HTTPS. First, download and install stunnel,<sup><a href="footnote.html#fn26" id="fn_26">4</a></sup> which will act as a broker between the HTTPS endpoint and your local machine. If installed via Homebrew, stunnel’s configuration file will be in <em>/usr/local/etc/stunnel/stunnel.conf-sample</em>. Move or copy this file to <em>/usr/local/etc/stunnel/stunnel.conf</em> and edit it to reflect the following:</p>
<p class="programs"><span class="green1"><span class="codeitalic">; SSL client mode</span></span><br/>client = yes<br/><br/><span class="green1"><span class="codeitalic">; service-level configuration</span></span><br/>[https]<br/>accept  = 127.0.0.1:80<br/>connect = 10.10.1.50:443<br/>TIMEOUTclose = 0</p>
<p class="indent">This simply sets up stunnel in client mode, instructing it to accept connections on your loopback interface on port 80, while forwarding them to the remote endpoint over SSL. After editing this file, set up Burp so that it uses your loopback listener as a proxy, making sure to select the <strong>Support invisible proxying</strong> option, as shown in <a href="ch04.html#ch4fig3">Figure 4-3</a>. <a href="ch04.html#ch4fig4">Figure 4-4</a> shows the resulting setup.</p>
<div class="image"><img alt="image" src="graphics/f04-03.jpg"/></div>
<p class="figcap"><a id="ch4fig3"/><em>Figure 4-3: Setting up invisible proxying through the local stunnel endpoint</em></p>
<div class="image"><a id="page_47"/><img alt="image" src="graphics/f04-04.jpg"/></div>
<p class="figcap"><a id="ch4fig4"/><em>Figure 4-4: Final Burp/stunnel setup</em></p>
<h4 class="h4" id="ch04lev2sec03"><em><strong>Certificate Management on a Device</strong></em></h4>
<p class="noindent">To install a certificate on a physical iOS device, simply email the certificate to an account associated with the device or put it on a public web server and navigate to it using Mobile Safari. You can then import it into the device’s trust store, as shown in <a href="ch04.html#ch4fig5">Figure 4-5</a>. You can also configure your device to go through a network proxy (that is, Burp) hosted on another machine. Simply install the CA certificate (as described earlier) of the proxy onto the device and configure your proxy to listen on a network-accessible IP address, as in <a href="ch04.html#ch4fig6">Figure 4-6</a>.</p>
<div class="image"><img alt="image" src="graphics/f04-05.jpg"/></div>
<p class="figcap"><a id="ch4fig5"/><em>Figure 4-5: The certificate import prompt</em></p>
<div class="image"><img alt="image" src="graphics/f04-06.jpg"/></div>
<p class="figcap"><a id="ch4fig6"/><em>Figure 4-6: Configuring Burp to use a nonlocalhost IP address</em></p>
<h4 class="h4" id="ch04lev2sec04"><a id="page_48"/><em><strong>Proxy Setup on a Device</strong></em></h4>
<p class="noindent">Once you’ve configured your certificate authorities and set up the proxy, go to <strong>Settings</strong> → <strong>Network</strong> → <strong>Wi-Fi</strong> and click the arrow to the right of your currently selected wireless network. You can enter the proxy address and port from this screen (see <a href="ch04.html#ch4fig7">Figure 4-7</a>).</p>
<div class="image"><img alt="image" src="graphics/f04-07.jpg"/></div>
<p class="figcap"><a id="ch4fig7"/><em>Figure 4-7: Configuring the device to use a test proxy on an internal network</em></p>
<p class="indent">Note that when configuring a device to use a proxy, only connections initiated by <span class="literal">NSURLConnection</span> or <span class="literal">NSURLSession</span> will obey the proxy settings; other connections such as <span class="literal">NSStream</span> and <span class="literal">CFStream</span> (which I’ll discuss further in <a href="ch07.html#ch07">Chapter 7</a>) will not. And of course, since this is an HTTP proxy, it works only for HTTP traffic. If you have an application using <span class="literal">CFStream</span>, you can edit the codebase with the following code snippet to route stream traffic through the same proxy as the host OS:</p>
<p class="programs"><span class="green">CFDictionaryRef</span> systemProxySettings = CFNetworkCopySystemProxySettings();<br/><br/><span class="violet">CFReadStreamSetProperty</span>(readStream, kCFStreamPropertyHTTPProxy, systemProxySettings<br/>    );<br/><br/><span class="violet">CFWriteStreamSetProperty</span>(writeStream, kCFStreamPropertyHTTPProxy,<br/>    systemProxySettings);</p>
<p class="indent"><a id="page_49"/>If you’re using <span class="literal">NSStream</span>, you can accomplish the same by casting the <span class="literal">NSInputStream</span> and <span class="literal">NSOutputStream</span> to their Core Foundation counterparts, like so:</p>
<p class="programs"><span class="green">CFDictionaryRef</span> systemProxySettings = CFNetworkCopySystemProxySettings();<br/><br/><span class="violet">CFReadStreamSetProperty</span>((CFReadStreamRef)readStream, kCFStreamPropertyHTTPProxy, (<br/>     <span class="green">CFTypeRef</span>)systemProxySettings);<br/><br/><span class="violet">CFWriteStreamSetProperty</span>((CFWriteStreamRef)writeStream, kCFStreamPropertyHTTPProxy,<br/>      (<span class="green">CFTypeRef</span>)systemProxySettings);</p>
<p class="indent">If you’re doing black-box testing and have an app that refuses to honor system proxy settings for HTTP requests, you can attempt to direct traffic through a proxy by adding a line to <em>/etc/hosts</em> on the device to point name lookups to your proxy address, as shown in <a href="ch04.html#ch4ex1">Listing 4-1</a>.</p>
<p class="programs">10.50.22.11    myproxy api.testtarget.com</p>
<p class="listcap"><a id="ch4ex1"/><em>Listing 4-1: Adding a hosts file entry</em></p>
<p class="indent">You can also configure the device to use a DNS server controlled by you, which doesn’t require jailbreaking your test device. One way to do this is to use Tim Newsham’s dnsRedir,<sup><a href="footnote.html#fn27" id="fn_27">5</a></sup> a Python script that will provide a spoofed answer for DNS queries of a particular domain, while passing on queries for all other domains to another DNS server (by default, 8.8.8.8, but you can change this with the <span class="literal">-d</span> flag). The script can be used as follows:</p>
<p class="programs">$ dnsRedir.py 'A:www.evil.com.=1.2.3.4'</p>
<p class="indent">This should answer queries for <em><a href="http://www.evil.com">www.evil.com</a></em> with the IP address 1.2.3.4, where that IP address should usually be the IP address of the test machine you’re proxying data through.</p>
<p class="indent">For non-HTTP traffic, things are a little more involved. You’ll need to use a TCP proxy to intercept traffic. The aforementioned Tim Newsham has written a program that can make this simpler—the aptly named tcpprox.<sup><a href="footnote.html#fn28" id="fn_28">6</a></sup> If you use the <span class="literal">hosts</span> file method in <a href="ch04.html#ch4ex1">Listing 4-1</a> to point the device to your proxy machine, you can then have tcpprox dynamically create SSL certificates and proxy the connection to the remote endpoint. To do this, you’ll need to create a certificate authority certificate and install it on the device, as shown in <a href="ch04.html#ch4ex2">Listing 4-2</a>.</p>
<p class="programs"><a id="page_50"/>$ ./prox.py -h<br/>Usage: prox.py [opts] addr port<br/><br/>Options:<br/>  -h, --help    show this help message and exit<br/>  -6            Use IPv6<br/>  -b BINDADDR   Address to bind to<br/>  -L LOCPORT    Local port to listen on<br/>  -s            Use SSL for incoming and outgoing connections<br/>  --ssl-in      Use SSL for incoming connections<br/>  --ssl-out     Use SSL for outgoing connections<br/>  -3            Use SSLv3 protocol<br/>  -T            Use TLSv1 protocol<br/>  -C CERT       Cert for SSL<br/>  -A AUTOCNAME  CName for Auto-generated SSL cert<br/>  -1            Handle a single connection<br/>  -l LOGFILE    Filename to log to<br/><br/>$ ./ca.py -c<br/>$ ./pkcs12.sh ca<br/>  (install CA cert on the device)<br/>$ ./prox.py -s -L 8888 -A ssl.testtarget.com ssl.testtarget.com 8888</p>
<p class="listcap"><a id="ch4ex2"/><em>Listing 4-2: Creating a certificate and using tcpprox to intercept traffic</em></p>
<p class="indent">The <em>ca.py</em> script creates the signed certificate, and the <em>pkcs12.sh</em> script produces the certificate to install on the device, the same as shown in <a href="ch04.html#ch4fig5">Figure 4-5</a>. After running these and installing the certificate, your application should connect to the remote endpoint using the proxy, even for SSL connections. Once you’ve performed some testing, you can read the results with the <em>proxcat.py</em> script included with tcpprox, as follows:</p>
<p class="programs">$ ./proxcat.py -x log.txt</p>
<p class="indent">Once your application is connected through a proxy, you can start setting up your Xcode environment.</p>
<h3 class="h3" id="ch04lev1sec05"><strong>Xcode and Build Setup</strong></h3>
<p class="noindent">Xcode contains a twisty maze of project configuration options—hardly anyone understands what each one does. This section takes a closer look at these options, discusses why you would or wouldn’t want them, and shows you how to get Xcode to help you find bugs before they become real problems.</p>
<h4 class="h4" id="ch04lev2sec05"><a id="page_51"/><em><strong>Make Life Difficult</strong></em></h4>
<p class="noindent">First things first: treat warnings as errors. Most of the warnings generated by clang, Xcode’s compiler frontend, are worth paying attention to. Not only do they often help reduce code complexity and ensure correct syntax, they also catch a number of errors that might be hard to spot, such as signedness issues or format string flaws. For example, consider the following:</p>
<p class="programs">- (<span class="rose">void</span>) validate:(<span class="violet1">NSArray*</span>) someTribbles withValue:(<span class="violet1">NSInteger</span>) desired {<br/><br/>    <span class="rose">if</span> (desired &gt; [someTribbles count]) {<br/>        [<span class="rose">self</span> <span class="violet">allocateTribblesWithNumberOfTribbles</span>:desired];<br/>    }<br/>}</p>
<p class="indent">The <span class="literal">count</span> method of <span class="literal">NSArray</span> returns an unsigned integer, (<span class="literal">NSUInteger</span>). If you were expecting the number of desired tribbles from user input, a submitted value might be –1, presumably indicating that the user would prefer to have an anti-tribble. Because <span class="literal">desired</span> is an integer being compared to an unsigned integer, the compiler will treat both as unsigned integers. Therefore, this method would unexpectedly allocate an absurd number of tribbles because –1 is an extremely large number when converted to an unsigned integer. I’ll discuss this type of integer overflow issue further in <a href="ch11.html#ch11">Chapter 11</a>.</p>
<p class="indent">You can have clang flag this type of of bug by enabling most warnings and treating them as errors, in which case your build would fail with a message indicating <span class="literal">"Comparison of integers of different signs: 'int' and 'NSUInteger' (aka 'unsigned int')"</span>.</p>
<div class="note">
<p class="notet"><strong>NOTE</strong></p>
<p class="notep"><em>In general, you should enable all warnings in your project build configuration and promote warnings to errors so that you are forced to deal with bugs as early as possible in the development cycle.</em></p>
</div>
<p class="indent">You can enable these options in your project and target build settings. To do so, first, under Warning Policies, set Treat Warnings as Errors to <strong>Yes</strong> (<a href="ch04.html#ch4fig8">Figure 4-8</a>). Then, under the Warnings sections, turn on all the desired options.</p>
<p class="indent">Note that not every build warning that clang supports has an exposed toggle in the Xcode UI. To develop in “hard mode,” you can add the <span class="literal">-Wextra</span> or <span class="literal">-Weverything</span> flag, as in <a href="ch04.html#ch4fig9">Figure 4-9</a>. Not all warnings will be useful, but it’s best to try to understand exactly what an option intends to highlight before disabling it.</p>
<p class="indent"><span class="literal">-Weverything</span>, used in <a href="ch04.html#ch4fig9">Figure 4-9</a>, is probably overkill unless you’re curious about clang internals; <span class="literal">-Wextra</span> is normally sufficient. To save you a bit of time, <a href="ch04.html#ch4tab1">Table 4-1</a> discusses two warnings that are almost sure to get in your way (or that are just plain bizarre).</p>
<div class="image"><a id="page_52"/><img alt="image" src="graphics/f04-08.jpg"/></div>
<p class="figcap"><a id="ch4fig8"/><em>Figure 4-8: Treating all warnings as errors</em></p>
<div class="image"><img alt="image" src="graphics/f04-09.jpg"/></div>
<p class="figcap"><a id="ch4fig9"/><em>Figure 4-9: This setting enables all warnings, including options for which there is no exposed UI.</em></p>
<p class="tablecap"><a id="page_53"/><a id="ch4tab1"/><strong>Table 4-1:</strong> Obnoxious Warnings to Disable in Xcode</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="80%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Compiler warning</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Justification for disabling</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table">Implicit synthesized properties</p></td>
<td class="table" valign="top"><p class="table">Since property synthesis is now automatic, this isn’t really an error unless your development guidelines require explicit synthesis.</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Unused parameters/functions/variables etc.</p></td>
<td class="table" valign="top"><p class="table">These can be supremely irritating when writing code, since your code is obviously not completely implemented yet. Consider enabling these only for nondebug builds.</p></td>
</tr>
</tbody>
</table>
<h4 class="h4" id="ch04lev2sec06"><em><strong>Enabling Full ASLR</strong></em></h4>
<p class="noindent">In iOS 4.3, Apple introduced <em>address space layout randomization (ASLR)</em>. ASLR ensures that the in-memory structure of the program and its data (libraries, the main executable, stack and heap, and memory-mapped files) are loaded into less predictable locations in the virtual address space. This makes code execution exploits more difficult because many rely on referencing the virtual addresses of specific library calls, as well as referencing data on the stack or heap.</p>
<p class="indent">For this to be fully effective, however, the application must be built as a <em>position-independent executable (PIE)</em>, which instructs the compiler to build machine code that can function regardless of its location in memory. Without this option, the location of the base executable and the stack will remain the same, even across reboots,<sup><a href="footnote.html#fn29" id="fn_29">7</a></sup> making an attacker’s job much easier.</p>
<p class="indent">To ensure that full ASLR with PIE is enabled, check that Deployment Target in your Target’s settings is set to at least iOS version 4.3. In your project’s Build Settings, ensure that Generate Position-Dependent Code is set to No and that the bizarrely named Don’t Create Position Independent Executable is also set to No. So don’t create position-independent executables. Got it?</p>
<p class="indent">For black-box testing or to ensure that your app is built with ASLR correctly, you can use otool on the binary, as follows:</p>
<p class="programs">$ unzip MyApp.ipa<br/>$ cd Payload/MyApp.app<br/>$ otool -vh MyApp<br/><br/>MyApp (architecture armv7):<br/>Mach header<br/>      magic cputype cpusubtype caps   filetype ncmds sizeofcmds              flags<br/>    MH_MAGIC    ARM         V7 0x00    EXECUTE    21       2672  NOUNDEFS DYLDLINK<br/>                                                                      TWOLEVEL <span class="codestrong">PIE</span><br/><br/>MyApp (architecture armv7s):<br/>Mach header<br/>      magic cputype cpusubtype caps   filetype ncmds sizeofcmds              flags<br/>   MH_MAGIC     ARM        V7S 0x00    EXECUTE    21       2672  NOUNDEFS DYLDLINK<br/>                                                                      TWOLEVEL <span class="codestrong">PIE</span></p>
<p class="indent"><a id="page_54"/>At the end of each <span class="literal">MH_MAGIC</span> line, if you have your settings correct, you should see the <span class="literal">PIE</span> flag, highlighted in bold. (Note that this must be done on a binary compiled for an iOS device and will not work when used on iOS Simulator binaries.)</p>
<h4 class="h4" id="ch04lev2sec07"><em><strong>Clang and Static Analysis</strong></em></h4>
<p class="noindent">In computer security, <em>static analysis</em> generally refers to using tools to analyze a codebase and identify security flaws. This could involve identifying dangerous APIs, or it might include analyzing data flow through the program to identify the potentially unsafe handling of program inputs. As part of the build tool chain, clang is a good spot to embed static analysis language.</p>
<p class="indent">Beginning with Xcode 3.2, clang’s static analyzer<sup><a href="footnote.html#fn30" id="fn_30">8</a></sup> has been integrated with Xcode, providing users with a UI to trace logic, coding flaws, and general API misuse. While clang’s static analyzer is handy, several of its important features are disabled by default in Xcode. Notably, the checks for classic dangerous C library functions, such as <span class="literal">strcpy</span> and <span class="literal">strcat</span>, are oddly absent. Enable these in your Project or Target settings, as in <a href="ch04.html#ch4fig10">Figure 4-10</a>.</p>
<div class="image"><img alt="image" src="graphics/f04-10.jpg"/></div>
<p class="figcap"><a id="ch4fig10"/><em>Figure 4-10: Enabling all clang static analysis checks in Xcode</em></p>
<h4 class="h4" id="ch04lev2sec08"><a id="page_55"/><em><strong>Address Sanitizer and Dynamic Analysis</strong></em></h4>
<p class="noindent">Recent versions of Xcode include a version of clang/llvm that features the Address Sanitizer (ASan). ASan is a dynamic analysis tool similar to Valgrind, but ASan runs faster and has improved coverage.<sup><a href="footnote.html#fn31" id="fn_31">9</a></sup> ASan tests for stack and heap overflows and use-after-free bugs, among other things, to help you track down crucial security flaws. It does have a performance impact (program execution is estimated to be roughly two times slower), so don’t enable it on your release builds, but it should be perfectly usable during testing, quality assurance, or fuzzing runs.</p>
<p class="indent">To enable ASan, add <span class="literal">-fsanitize=address</span> to your compiler flags for debug builds (see <a href="ch04.html#ch4fig11">Figure 4-11</a>). On any unsafe crashes, ASan should write extra debug information to the console to help you determine the nature and severity of the issues. In conjunction with fuzzing,<sup><a href="footnote.html#fn32" id="fn_32">10</a></sup> ASan can be a great help in pinning down serious issues that may be security-sensitive and in giving an idea of their exploitability.</p>
<div class="image"><img alt="image" src="graphics/f04-11.jpg"/></div>
<p class="figcap"><a id="ch4fig11"/><em>Figure 4-11: Setting the ASan compiler flags</em></p>
<h3 class="h3" id="ch04lev1sec06"><strong>Monitoring Programs with Instruments</strong></h3>
<p class="noindent">Regardless of whether you’re analyzing someone else’s application or trying to improve your own, the DTrace-powered Instruments tool is extremely helpful for observing an app’s activity on a fine-grained level. This tool is useful for monitoring network socket usage, finding memory allocation issues, and watching filesystem interactions. Instruments can be an excellent tool for discovering what objects an application stores on local storage in order to find places where sensitive information might leak; I use it in that way frequently.</p>
<h4 class="h4" id="ch04lev2sec09"><em><strong>Activating Instruments</strong></em></h4>
<p class="noindent">To use Instruments on an application from within Xcode, hold down the <strong>Run</strong> button and select the <strong>Build for Profiling</strong> option (see <a href="ch04.html#ch4fig12">Figure 4-12</a>). After building, you will be presented with a list of preconfigured templates tailored for monitoring certain resources, such as disk reads and writes, memory allocations, CPU usage, and so on.</p>
<div class="image"><a id="page_56"/><img alt="image" src="graphics/f04-12.jpg"/></div>
<p class="figcap"><a id="ch4fig12"/><em>Figure 4-12: Selecting the Build for Profiling option</em></p>
<p class="indent">The File Activity template (shown in <a href="ch04.html#ch4fig13">Figure 4-13</a>) will help you monitor your application’s disk I/O operations. After selecting the template, the iOS Simulator should automatically launch your application and begin recording its activity.</p>
<div class="image"><img alt="image" src="graphics/f04-13.jpg"/></div>
<p class="figcap"><a id="ch4fig13"/><em>Figure 4-13: Selecting the File Activity profiling template</em></p>
<p class="indent">There are a few preset views in Instruments for monitoring file activity. A good place to start is Directory I/O, which will capture all file creation or deletion events. Test your application the way you normally would and watch the output here. Each event is listed with its Objective-C caller, the C function call underlying it, the file’s full path, and its new path if the event is a rename operation.</p>
<p class="indent">You’ll likely notice several types of cache files being written here (see <a href="ch04.html#ch4fig14">Figure 4-14</a>), as well as cookies or documents your application has been asked to open. If you suspend your application, you should see the application screenshot written to disk, which I’ll discuss in <a href="ch10.html#ch10">Chapter 10</a>.</p>
<p class="indent">For a more detailed view, you can select the Reads/Writes view, as shown in <a href="ch04.html#ch4fig15">Figure 4-15</a>. This will show any read or write operations on files or sockets, along with statistics on the amount of data read or written.</p>
<div class="image"><a id="page_57"/><img alt="image" src="graphics/f04-14.jpg"/></div>
<p class="figcap"><a id="ch4fig14"/><em>Figure 4-14: Directory I/O view showing files created or deleted</em></p>
<div class="image"><img alt="image" src="graphics/f04-15.jpg"/></div>
<p class="figcap"><a id="ch4fig15"/><em>Figure 4-15: Profiling results showing detailed file reads and writes</em></p>
<h4 class="h4" id="ch04lev2sec10"><a id="page_58"/><em><strong>Watching Filesystem Activity with Watchdog</strong></em></h4>
<p class="noindent">Instruments should catch most iOS Simulator activity, but some file writes or network calls may actually be performed by other system services, thereby escaping the tool’s notice. It’s a good idea to manually inspect the iOS Simulator’s directory tree to get a better feel for the structure of iOS and its applications and to catch application activity that you might otherwise miss.</p>
<p class="indent">One easy way to automate this is to use the Python watchdog module.<sup><a href="footnote.html#fn33" id="fn_33">11</a></sup> Watchdog will use either the kqueue or FSEvents API to monitor directory trees for file activity and can either log events or take specific actions when these events occur. To install watchdog, use the following:</p>
<p class="programs">$ pip install watchdog</p>
<p class="indent">You can write your own scripts to use watchdog’s functionality, but you’ll find a nice command line tool already included with watchdog called watchmedo. If you open a Terminal window and navigate to the Simulator directory, you should be able to use watchmedo to monitor all file changes under the iOS Simulator’s directory tree, as follows:</p>
<p class="programs">$ cd ~/Library/Application\ Support/iPhone\ Simulator/6.1<br/>$ watchmedo log --recursive .<br/>on_modified(self=&lt;watchdog.tricks.LoggerTrick object at 0x103c9b190&gt;, event=&lt;<br/>    DirModifiedEvent: src_path=/Users/dthiel/Library/Application Support/iPhone<br/>    Simulator/6.1/Library/Preferences&gt;)<br/>on_created(self=&lt;watchdog.tricks.LoggerTrick object at 0x103c9b190&gt;, event=&lt;<br/>    FileCreatedEvent: src_path=/Users/dthiel/Library/Application Support/iPhone<br/>    Simulator/6.1/Applications/9460475C-B94A-43E8-89C0-285DD036DA7A/Library/Caches<br/>    /Snapshots/com.yourcompany.UICatalog/UIApplicationAutomaticSnapshotDefault-<br/>    Portrait.png&gt;)<br/>on_modified(self=&lt;watchdog.tricks.LoggerTrick object at 0x103c9b190&gt;, event=&lt;<br/>    DirModifiedEvent: src_path=/Users/dthiel/Library/Application Support/iPhone<br/>    Simulator/6.1/Applications/9460475C-B94A-43E8-89C0-285DD036DA7A/Library/Caches<br/>    /Snapshots&gt;)<br/>on_created(self=&lt;watchdog.tricks.LoggerTrick object at 0x103c9b190&gt;, event=&lt;<br/>    DirCreatedEvent: src_path=/Users/dthiel/Library/Application Support/iPhone<br/>    Simulator/6.1/Applications/9460475C-B94A-43E8-89C0-285DD036DA7A/Library/Caches<br/>    /Snapshots/com.yourcompany.UICatalog&gt;)<br/>on_modified(self=&lt;watchdog.tricks.LoggerTrick object at 0x103c9b190&gt;, event=&lt;<br/>    DirModifiedEvent: src_path=/Users/dthiel/Library/Application Support/iPhone<br/>    Simulator/6.1/Library/SpringBoard&gt;)</p>
<p class="indent"><a id="page_59"/>Entries that start with on <span class="literal">on_modified</span> indicate a file was changed, and entries that start with <span class="literal">on_created</span> indicate a new file. There are several other change indicators you might see from watchmedo, and you can read about them in the Watchdog documentation.</p>
<h3 class="h3" id="ch04lev1sec07"><strong>Closing Thoughts</strong></h3>
<p class="noindent">You should now have your build and test environment configured for running, modifying, and examining iOS apps. In <a href="ch05.html#ch05">Chapter 5</a>, we’ll take a closer look at how to debug and inspect applications dynamically, as well as how to change their behavior at runtime.<a id="page_60"/></p>
</body></html>