<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_401"/>
<h2 class="h2" id="ch18"><strong><span class="big">18</span><br/>GHIDRA PROCESSORS</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindents">Processor modules, the most complex of Ghidra’s module types, are responsible for all of the disassembly operations that take place within Ghidra. Beyond the obvious conversion of machine language opcodes into their assembly language equivalents, processor modules also support the creation of functions, cross-references, and stack frames.</p>
<p class="indent">While the number of processors supported by Ghidra is impressive and increases with every major release, development of a new Ghidra processor module is required in some circumstances. The obvious case for developing a processor module is reverse engineering a binary for which no processor module exists in Ghidra. Among other things, such a binary might represent a firmware image for an embedded microcontroller or an executable image pulled from handheld or Internet of Things (IoT) <span epub:type="pagebreak" id="page_402"/>devices. A less-obvious use for a processor module is to disassemble the instructions of a custom virtual machine embedded within an obfuscated x86 executable. In such cases, the existing Ghidra x86 processor module would help you understand only the virtual machine itself, not the virtual machine’s underlying byte code.</p>
<p class="indent">Should you undertake this arduous task, we want to be sure you have a strong foothold to help support you in this endeavor. Each of our previous module examples (analyzer and loader) required modifying a single Java file. If you created these modules within the Eclipse GhidraDev environment, you were given a module template and task tags within each template to help you complete your task. Processor modules are more complex, and relationships between different files must be maintained for the processor module to work correctly. While we will not build a processor module from scratch in this chapter, we will provide you with a solid foundation to help you understand Ghidra processor modules and demonstrate creating and modifying components within those modules.</p>
<div class="box5">
<p class="boxtitle-c"><strong>WHO IS LIKELY TO AUGMENT GHIDRA?</strong></p>
<p class="noindentb">Based on a thoroughly unscientific study, we strongly suspect that the following categories exist:</p>
<p class="noindent"><strong>Category 1</strong> A small percentage of people who use Ghidra will modify or write a script to customize or automate some functionality related to Ghidra.</p>
<p class="noindent"><strong>Category 2</strong> Of the people in Category 1, a small percentage will choose to modify or develop a plugin to customize some functionality related to Ghidra.</p>
<p class="noindent"><strong>Category 3</strong> Of the people in Category 2, an even smaller percentage will choose to modify or write an analyzer to extend Ghidra’s analysis capabilities.</p>
<p class="noindent"><strong>Category 4</strong> Of the people in Category 3, a small percentage will choose to modify or write a loader for a new file format.</p>
<p class="noindent"><strong>Category 5</strong> A <em>very</em> small percentage of the people in Category 4 will choose to modify or write a Ghidra processor module because the number of instruction sets that require decoding is much smaller than the number of file formats that make use of those instruction sets. Thus, the demand for new processor modules is comparatively low.</p>
<p class="indenta">As you get deeper into the list of categories, the nature of the associated tasks tends to become more and more specialized. However, just because you don’t currently envision yourself authoring a Ghidra processor module doesn’t mean there isn’t some utility in learning how they are built. Processor modules form the foundation on which Ghidra’s disassembly, assembly, and decompilation capabilities are built, and having some insight into their inner workings just might elevate you to Ghidra wizard status in the eyes of your colleagues.</p>
</div>
<span epub:type="pagebreak" id="page_403"/>
<h3 class="h3" id="ch18lev337"><strong>Understanding Ghidra Processor Modules</strong></h3>
<p class="noindent">Creating a processor module for a real-world architecture is a highly specialized, time-consuming effort and is beyond the scope of this book. However, some fundamental understanding of how processors and their associated instruction sets are represented in Ghidra will help you identify where to look so that you have the right resources at your fingertips when you need information about a Ghidra processor module.</p>
<h4 class="h4" id="ch18lev338"><strong><em>Eclipse Processor Modules</em></strong></h4>
<p class="noindent">We will start in somewhat familiar territory. When you use Eclipse ▸ GhidraDev to create a processor module, the resulting folder structure is basically the same as every other module type, but a processor module does not provide a Java source file, complete with comments, task tags, and a <code>TODO</code> list, in the <em>src/main/java</em> folder, as seen in <a href="ch18.xhtml#fig18_1">Figure 18-1</a>.</p>
<div class="image"><img src="Images/fig18-1.jpg" alt="image" width="366" height="711"/></div>
<p class="figcap" id="fig18_1"><em>Figure 18-1: Processor module contents</em></p>
<span epub:type="pagebreak" id="page_404"/>
<p class="indentb">Instead, the <em>data</em> folder (expanded in the figure) contains a lot more than the brief <em>README.txt</em> provided in the data folder for other module types. Let’s briefly meet the nine files contained in the <em>data</em> folder with a focus on their file extensions. (The <em>skel</em> prefix lets us know we are working with a skeleton.)</p>
<p class="uln-indent"><strong><em>skel.cspec</em></strong> This is an XML-formatted, initially overwhelming compiler specification file.</p>
<p class="uln-indent"><strong><em>skel.ldefs</em></strong> This is an XML-formatted language definition file. The skeleton has a commented-out template for defining a language.</p>
<p class="uln-indent"><strong><em>skel.opinion</em></strong> This is an XML-formatted importer opinion file. The skeleton has a commented-out template for defining a language/compiler specification.</p>
<p class="uln-indent"><strong><em>skel.pspec</em></strong> This is an XML-formatted processor specification file.</p>
<p class="uln-indent"><strong><em>skel.sinc</em></strong> This is generally a SLEIGH file for language instructions.<sup><a id="ch18fn1a" href="footnotes.xhtml#ch18fn1">1</a></sup></p>
<p class="uln-indent"><strong><em>skel.slaspec</em></strong> This is a SLEIGH specification file.</p>
<p class="uln-indent"><strong><em>buildLanguage.xml</em></strong> This XML file describes the build process for the files in the <em>data/languages</em> directory.</p>
<p class="uln-indent"><strong><em>README.txt</em></strong> This file is the same in all of the modules, but within this module it finally makes sense as it focuses on the contents of the <em>data/</em> directory.</p>
<p class="uln-indent"><strong><em>sleighArgs.txt</em></strong> This file holds SLEIGH compiler options.</p>
<p class="indenta">The <em>.ldefs</em> and <em>.opinion</em> files were used in <a href="ch17.xhtml#ch17">Chapter 17</a> when building your ELF shellcode loader. Other file extensions will be seen in context as you work through examples. You will learn how to work with these files to modify a processor module, but first let’s discuss a new term specific to processor modules—SLEIGH.</p>
<h4 class="h4" id="ch18lev339"><strong><em>SLEIGH</em></strong></h4>
<p class="noindent"><em>SLEIGH</em> is a language specific to Ghidra that describes microprocessor instruction sets to support the Ghidra disassembly and decompilation processes.<sup><a id="ch18fn2a" href="footnotes.xhtml#ch18fn2">2</a></sup> Files within the <em>languages</em> directory (see <a href="ch18.xhtml#fig18_1">Figure 18-1</a>) are either written in SLEIGH or presented in XML format, so you will definitely need to learn a little about SLEIGH to create or modify a processor module.</p>
<p class="indent">The specification of how instructions are encoded and how they are interpreted by a processor is contained in a <em>.slaspec</em> file (somewhat analogous to the role of a <em>.c</em> file). When a processor family has a number of distinct variants, each variant may have its own <em>.slaspec</em> file, while common behaviors across variants may be factored out into separate <em>.sinc</em> files (similar to the <span epub:type="pagebreak" id="page_405"/>role of <em>.h</em> files), which may be included in many <em>.slaspec</em> files. Ghidra’s ARM processor is an excellent example of this, with over a dozen <em>.slaspec</em> files, each referencing one or more of five <em>.sinc</em> files. These files constitute the SLEIGH source code for a processor module, and it is the SLEIGH compiler’s job to compile them into a <em>.sla</em> file suitable for use by Ghidra.</p>
<p class="indent">Rather than taking a deep dive into SLEIGH from a theoretical perspective, we will introduce various components of the SLEIGH language as we encounter and require them in our examples, but first let’s look at the sort of information that a SLEIGH file contains about instructions.</p>
<p class="indent">To see additional information associated with an instruction in a CodeBrowser listing, right-click and select <strong>Instruction Info</strong> from the context menu. The displayed information is derived from SLEIGH file specifications for the selected instruction. <a href="ch18.xhtml#fig18_2">Figure 18-2</a> shows the Instruction Info window for an x86-64 <code>PUSH</code> instruction.</p>
<div class="image"><img src="Images/fig18-2.jpg" alt="image" width="574" height="630"/></div>
<p class="figcap" id="fig18_2"><em>Figure 18-2: Instruction Info window for x86-64</em> <span class="codeitalic">PUSH</span> <em>instruction</em></p>
<p class="indent">The Instruction Info window combines information about the <code>PUSH</code> instruction from the SLEIGH file with details about the specific use of <code>PUSH</code> at address <code>00100736</code>. Later in the chapter, we will work with instruction definitions within a SLEIGH file and will revisit this window in the context of the instructions we are working with.</p>
<span epub:type="pagebreak" id="page_406"/>
<h4 class="h4" id="ch18lev340"><strong><em>Processor Manuals</em></strong></h4>
<p class="noindent">The documentation provided by the manufacturer of a processor is an important resource for obtaining information about the instruction set. While these copyrighted materials cannot be included within your Ghidra distribution, you can easily incorporate them through a right-click context menu option in the Listing window. If you right-click any instruction and select Processor Manual, you are likely to see a message similar to that shown in <a href="ch18.xhtml#fig18_3">Figure 18-3</a>, informing you that the manual for the current processor is not available in the expected location.</p>
<div class="image"><img src="Images/fig18-3.jpg" alt="image" width="574" height="233"/></div>
<p class="figcap" id="fig18_3"><em>Figure 18-3: Missing Processor Manual dialog</em></p>
<p class="indent">Here, Ghidra provides you the information needed to resolve the missing manual situation. In this particular example, you first need to locate the x86 manual online and then save it with the specified name and location.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>There are many processor manuals associated with the x86. Find the correct manual online by searching for the identifier provided at the end of the manual information:</em> 325383-060US.</p>
</div>
<p class="indent">Once you have a manual properly installed, selecting Processor Manual will display the manual. Since processor manuals tend to be large (this particular manual for the x86 processor weighs in at almost 2,200 pages), Ghidra helpfully includes the capability to process index files that map an instruction to a specific page in a manual. Fortunately, the index for this specific x86 manual has already been created for you.</p>
<p class="indent">Processor manuals should be placed in the <em>Ghidra/Processors/&lt;proc&gt;/data/manuals</em> directory appropriate for your processor. Index files should reside in the same directory as their associated manual. The format of an index file is relatively straightforward. The first few lines of Ghidra’s <em>x86.idx</em> file are shown in the following listing:</p>
<pre>@Intel64_IA32_SoftwareDevelopersManual.pdf [Intel 64 and IA-32 Architectures<br/>
     Software Developer's Manual Volume 2 (2A, 2B, 2C &amp; 2D): Instruction Set<br/>
     Reference, A-Z, Sep 2016 (325383-060US)]<br/>
AAA, 120<br/>
AAD, 122<br/>
BLENDPS, 123<br/>
AAM, 124</pre>
<span epub:type="pagebreak" id="page_407"/>
<p class="indent">The first line in the file (which has been wrapped across three lines in this listing) pairs the manual’s local filename with descriptive text displayed to the user when the manual is not present on the system. The format of the line is as follows:</p>
<pre>@<span class="codeitalic1">FilenameInGhidraManualDirectory</span> [<span class="codeitalic1">Description of manual file</span>]</pre>
<p class="indent">Each additional line is of the form <span class="codeitalic">INSTRUCTION, page</span>. The instruction must be uppercase, and the page number is counted from the first page of the <em>.pdf</em> file. (This is not necessarily the page number that appears on any given page of the document.)</p>
<p class="indent">Several manuals can be referenced in a single <em>.idx</em> file. Simply use additional <code>@</code> directives to delineate each additional manual’s instruction map. More information about processor manual index files may be found in <em>docs/languages/manual_index.txt</em> in your Ghidra installation directory.</p>
<p class="indent">Once you have a manual saved and indexed, selecting Processor Manual for any instruction in the Listing window should take you to its corresponding page within the manual. If the manual does not appear, you may need to choose Edit ▸ Tools Options ▸ Processor Manuals to configure an appropriate viewer application for your manual. A sample viewer setting to open the manual using Firefox is shown in <a href="ch18.xhtml#fig18_4">Figure 18-4</a>.</p>
<div class="image"><img src="Images/fig18-4.jpg" alt="image" width="574" height="175"/></div>
<p class="figcap" id="fig18_4"><em>Figure 18-4: Processor Manuals tool options</em></p>
<p class="indent">Now that you have some basic processor module terminology under your belt, it’s time to dive into the internals of a processor module implementation.</p>
<h3 class="h3" id="ch18lev341"><strong>Modifying a Ghidra Processor Module</strong></h3>
<p class="noindent">Building a processor module from scratch is a significant undertaking. Rather than jumping in headfirst, we are going to start, as we did in in previous examples, by modifying an existing module. Since we want to demonstrate concepts related to real-world problems, we will start by identifying a hypothetical issue regarding Ghidra’s x86 processor module. We will walk through some examples that address the issue and then use what we have learned to create a big picture view of how all of the various components work together to form a complete Ghidra processor module.</p>
<span epub:type="pagebreak" id="page_408"/>
<div class="box5">
<p class="boxtitle-c"><strong>GHIDRA’S SLEIGH EDITOR</strong></p>
<p class="noindentb">To assist you in modifying and building processor modules, Ghidra includes a SLEIGH editor that easily integrates into the Eclipse environment. The installation instructions for the editor are part of the SLEIGH <em>readme</em> file referenced in the preceding section and take only a few steps. Special functionality that the editor supports includes the following:</p>
<p class="noindent"><strong>Syntax highlight</strong> Colorizes content that has special meaning (for example, comments, tokens, strings, variables, and so on).</p>
<p class="noindent"><strong>Validation</strong> Marks many syntax errors and generates warnings for errors that would otherwise remain undetected until compilation.</p>
<p class="noindent"><strong>QuickFix</strong> Provides recommendations for resolving issues detected by the editor. (This is similar to the QuickFix options for <code>import</code> statements we saw in <a href="ch15.xhtml#ch15">Chapter 15</a>.)</p>
<p class="noindent"><strong>Hover</strong> Provides additional information for many constructs when you hover over the construct.</p>
<p class="noindent"><strong>Navigation</strong> Provides navigation functionality specific to SLEIGH (for example, subconstructors, tokens, registers, pcodeops, and so on).</p>
<p class="noindent"><strong>Find references</strong> Quickly finds all uses of a variable.</p>
<p class="noindent"><strong>Renaming</strong> Rather than traditional string-based search and replace, this renames an actual variable in the file and other related <em>.sinc</em> and <em>.slaspec</em> files.</p>
<p class="noindent"><strong>Code formatting</strong> Reformats files specific to the structure of the SLEIGH language (for example, lines up constructors based on keywords, lines up entries within attach, and so on). This functionality can be applied to an entire file or a selected section.</p>
<p class="indenta">While we recommend using this editor, especially for the helpful early syntax checking, the development of our examples in this chapter are not specific to this editor.</p>
</div>
<h4 class="h4" id="ch18lev342"><strong><em>Problem Statement</em></strong></h4>
<p class="noindent">A quick search of the <em>Ghidra/Processors</em> directory in your local installation shows that the x86 processor module includes many instructions but appears to be missing a hypothetical virtual machine extension (VMX) management instruction for the IA32 and IA64 architectures.<sup><a id="ch18fn3a" href="footnotes.xhtml#ch18fn3">3</a></sup> This instruction (which we just invented for this example) is called <code>VMXPLODE</code>. Its behavior is similar to the <code>VMXOFF</code> instruction, which Ghidra does support. While the existing <code>VMXOFF</code> instruction causes the processor to leave VMX operation, <code>VMXPLODE</code> leaves with a flourish! We will walk you through adding this very important instruction to the existing Ghidra x86 processor module in order <span epub:type="pagebreak" id="page_409"/>to introduce some of the concepts associated with building and modifying a processor module.</p>
<h4 class="h4" id="ch18lev343"><strong><em>Example 1: Adding an Instruction to a Processor Module</em></strong></h4>
<p class="noindent">Our first goal is to locate the files we need to modify to support the <code>VMXPLODE</code> instruction. The <em>Ghidra/Processors</em> directory contains subdirectories for all processors supported by Ghidra, one of which is the x86. You can open the x86 processor module (or any other processor module) directly in Eclipse using File ▸ Open Projects from File System or Archive and providing the path to the processor folder (<em>Ghidra/Processors/x86</em>). This will link your Eclipse instance to Ghidra’s x86 processor module, meaning that changes you make within Eclipse will be directly reflected in your Ghidra processor module.</p>
<p class="indent">A partially expanded version of the x86 module in Eclipse, which exactly reflects the associated Ghidra directory structure, is shown in <a href="ch18.xhtml#fig18_5">Figure 18-5</a>. The processor manual you downloaded is present along with the x86 index file.</p>
<div class="image"><img src="Images/fig18-5.jpg" alt="image" width="492" height="330"/></div>
<p class="figcap" id="fig18_5"><em>Figure 18-5: x86 processor module in Eclipse Package Explorer</em></p>
<p class="indent">The <em>x86</em> folder contains a <em>data</em> folder, like the one you saw in the processor module we created using Eclipse ▸ GhidraDev. Within this folder is the <em>languages</em> folder, which contains over 40 files, including 19 <em>.sinc</em> files that define language instructions. Because the x86 instruction set is rather large, the instruction set is broken up into files grouping similar instructions. Instead of creating a new <em>.sinc</em> file for our instruction, we’ll add it to an existing x86 <em>.sinc</em> file. If we were adding a new group of instructions to Ghidra (for example, the x86 <code>SGX</code> instruction set), we might create a new <em>.sinc</em> file to group them all together. (In fact, the <code>SGX</code> instructions are grouped in a common file called <em>sgx.sinc</em>. That accounts for one of the many <em>.sinc</em> files!)</p>
<p class="indent">By searching the <em>.sinc</em> files, we find that <em>ia.sinc</em> contains the definitions of the existing <code>VMX</code> instruction set. We’ll use the definition of <code>VMXOFF</code> in <em>ia.sinc</em> as a model to define <code>VMXPLODE</code>. <code>VMXOFF</code> is referenced in two different sections <span epub:type="pagebreak" id="page_410"/>within <em>ia.sinc</em>. The first section is the definitions for the Intel IA hardware-assisted virtualization instructions:</p>
<pre># MFL: definitions for Intel IA hardware assisted virtualization instructions<br/>
define pcodeop invept;   # Invalidate Translations Derived from extended page<br/>
                         # tables (EPT); opcode 66 0f 38 80<br/>
# -----<span class="codeitalic1">CONTENT OMITTED HERE</span>-----<br/>
define pcodeop vmread;   # Read field from virtual-machine control structure;<br/>
                         # opcode 0f 78<br/>
define pcodeop vmwrite;  # Write field to virtual-machine control structure;<br/>
                         # opcode 0f 79<br/>
define pcodeop vmxoff;   # Leave VMX operation; opcode 0f 01 c4<br/>
define pcodeop vmxon;    # Enter VMX operation; opcode f3 0f C7 /6</pre>
<p class="indent">Each entry in the definitions section defines a pcodeop, which is a new microcode operation for the x86 architecture.</p>
<p class="indent">The definition includes a name and, in this case, a comment that includes a description and an opcode. We will need to populate the comment for our new command. A quick, alt-reality, web search (with a side of testing) confirms that the opcode <code>0f 01 c5</code> has long been reserved for <code>VMXPLODE</code>. We now have the information necessary to add our new instruction to the file. The following shows our new definition in context:</p>
<pre>define pcodeop vmxoff;   # Leave VMX operation; opcode 0f 01 c4<br/>
define pcodeop vmxplode; # Explode (Fake) VMX operation; opcode 0f 01 c5<br/>
define pcodeop vmxon;    # Enter VMX operation; opcode f3 0f C7 /6</pre>
<p class="indent">The second location we encounter <code>VMXOFF</code> within <em>ia.sinc</em> (and where we will insert our new instruction) is the opcode definition section. (We omitted part of this content for clarity and wrapped some instruction definition lines for readability.) While we won’t completely dissect the 8,000+ lines of code in the <em>ia.sinc</em> file, there are several interesting points to make regarding the following listing:</p>
<pre># Intel hardware assisted virtualization opcodes<br/>
# -----<span class="codeitalic1">CONTENT OMITTED HERE</span>-----<br/>
# TODO: invokes a VM function specified in EAX<span class="ent">➊</span><br/>
:VMFUNC EAX     is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xd4 &amp; EAX     { vmfunc(EAX); }<br/>
# TODO: this launches the VM managed by the current VMCS. How is the<br/>
#       VMCS expressed for the emulator?  For Ghidra analysis?<br/>
:VMLAUNCH       is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc2           { vmlaunch(); }<br/>
# TODO: this resumes the VM managed by the current VMCS. How is the<br/>
#       VMCS expressed for the emulator?  For Ghidra analysis?<br/>
:VMRESUME       is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc3           { vmresume(); }<br/>
# -----<span class="codeitalic1">CONTENT OMITTED HERE</span>-----<br/>
:VMWRITE Reg32, rm32 is vexMode=0 &amp; opsize=1 &amp; byte=0x0f; byte=0x79;<span class="ent">➋</span><br/>
         rm32 &amp; Reg32 ... &amp; check_Reg32_dest ... { vmwrite(rm32,Reg32); build check_Reg32_dest; }<br/>
@ifdef IA64<span class="ent">➌</span><br/>
:VMWRITE Reg64, rm64 is vexMode=0 &amp; opsize=2 &amp; byte=0x0f;  byte=0x79;<br/>
         rm64 &amp; Reg64 ...    { vmwrite(rm64,Reg64); }<br/>
@endif<br/>
:VMXOFF         is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc4         { vmxoff(); }<span class="ent">➍</span><br/>
<span epub:type="pagebreak" id="page_411"/>
:VMXPLODE       is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc5         { vmxplode(); }<span class="ent">➎</span><br/>
# -----<span class="codeitalic1">CONTENT OMITTED HERE</span>-----<br/>
#END of changes for VMX opcodes</pre>
<p class="indent"><code>TODO</code> comments <span class="ent">➊</span>, found in many Ghidra files, identify tasks that have yet to be done. Searching for <code>TODO</code> tasks in Ghidra files is a great way to identify opportunities to contribute to this open source project.</p>
<p class="indent">Next, we see the <code>VMWRITE</code> instruction for 32-bit <span class="ent">➋</span> and 64-bit architectures. The 64-bit instruction is surrounded by a test <span class="ent">➌</span> to ensure it is included in only the 64-bit <em>.sla</em> file. While 32-bit instructions are valid in a 64-bit world (for example, <code>EAX</code> is the 32 least-significant bits of <code>RAX</code>), the converse is not true. The conditional statement ensures that instructions that operate on 64-bit registers are included for only 64-bit builds.</p>
<p class="indent">The <code>VMXOFF</code> instruction <span class="ent">➍</span> doesn’t directly involve registers, so there is no need to distinguish between 32- and 64-bit versions of the instruction. The constructor for our new instruction, <code>VMXPLODE</code> <span class="ent">➎</span>, complete with its new opcode, is very similar to the constructor for <code>VMXOFF</code>. Let’s break this into the components that make up the line:</p>
<p class="listhead"><span class="codestrong">:VMXPLODE</span></p>
<p class="listbody">This is the instruction being defined and is displayed in the disassembly listing.</p>
<p class="listhead"><span class="codestrong">is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc5</span></p>
<p class="listbody">These are the bit patterns associated with the instruction and provide a constraint for the instruction. The <code>&amp;</code> represents a logical AND operation. The semicolons serve a dual purpose of concatenation and logical AND. This part says, “If we are not in VEX mode and the opcode is these 3 bytes in this order, then this constraint is met.”<sup><a id="ch18fn4a" href="footnotes.xhtml#ch18fn4">4</a></sup></p>
<p class="listhead"><span class="codestrong">{ vmxplode(); }</span></p>
<p class="listbody">Curly brackets enclose the semantic actions section of an instruction. The SLEIGH compiler translates these actions into an internal Ghidra form known as p-code (discussed later in this chapter). Defining an instruction requires understanding SLEIGH operators and syntax. This portion of the constructor, where the real work associated with most instructions is done, can quickly become a complex sequence of multiple statements separated by semicolons. In this case, since we have defined <code>VMXPLODE</code> as a new p-code operation (<code>define pcodeop vmxplode;</code>), we can invoke the instruction here. In future examples, we will add additional SLEIGH semantic actions to this section.</p>
<p class="indenta">The largest x86 <em>.sinc</em> file is <em>ia.sinc</em> because a lot of instructions are defined within this file (including our new <code>VMXPLODE</code> instruction) and a significant amount of content to define the attributes of the x86 processor <span epub:type="pagebreak" id="page_412"/>(for example, endianness, registers, contexts, tokens, variables, and so on). Much of this x86-specific content within <em>ia.sinc</em> is not replicated in the other <em>.sinc</em> files in this directory, since all the <em>.sinc</em> files are, in turn, included in a SLEIGH specification (<em>.slaspec</em>) file.</p>
<p class="indent">The two <em>.slaspec</em> files for x86, <em>x86.slaspec</em> and <em>x86-64.slaspec</em>, each contain <code>include</code> statements for the required <em>.sinc</em> files. (Note that you could forego the use of <em>.sinc</em> files and directly include the content in the <em>.slaspec</em> file, which might make sense for a processor with a small instruction set.) The contents of <em>x86-64.slaspec</em> are shown in the following listing:</p>
<pre>  @define IA64 "IA64"         # Only in x86-64.slaspec<br/>
<span class="ent">➊</span> @include "ia.sinc"<br/>
  @include "avx.sinc"<br/>
  @include "avx_manual.sinc"<br/>
  @include "avx2.sinc"<br/>
  @include "avx2_manual.sinc"<br/>
  @include "rdrand.sinc"      # Only in x86-64.slaspec<br/>
  @include "rdseed.sinc"      # Only in x86-64.slaspec<br/>
  @include "sgx.sinc"         # Only in x86-64.slaspec<br/>
  @include "adx.sinc"<br/>
  @include "clwb.sinc"<br/>
  @include "pclmulqdq.sinc"<br/>
  @include "mpx.sinc"<br/>
  @include "lzcnt.sinc"<br/>
  @include "bmi1.sinc"<br/>
  @include "bmi2.sinc"<br/>
  @include "sha.sinc"<br/>
  @include "smx.sinc"<br/>
  @include "cet.sinc"<br/>
  @include "fma.sinc"         # Only in x86-64.slaspec</pre>
<p class="indent">We have added EOL comments to denote the content that is unique to the <em>x86-64.slaspec</em> file. (The <em>x86.slaspec</em> file is a subset of the <em>x86-64.slaspec</em> file.) Among the included files is <em>ia.sinc</em> <span class="ent">➊</span>, in which we defined <code>VMXPLODE</code>, so we don’t need to add anything. If you create a new <em>.sinc</em> file, you need to add an <code>include</code> statement in both <em>x86.slaspec</em> and <em>x86-64.slaspec</em> in order for the instruction to be recognized in both 32- and 64-bit binaries.</p>
<p class="indent">To test if Ghidra can recognize the new instruction when it is used in a binary, we construct a test file. The file will first verify that the <code>VMXOFF</code> instruction is still recognized and then verify that <code>VMXPLODE</code> has been added successfully. The C source file for testing <code>VMXOFF</code> contains the following:</p>
<pre>#include &lt;stdio.h&gt;<br/><br/>
// The following function declares an assembly block and tells the<br/>
// compiler that it should execute the code without moving or changing it.<br/><br/>
void do_vmx(int v) {<br/>
   asm volatile (<br/>
      "vmxon %0;"       // Enable hypervisor operation<br/>
      "vmxoff;"         // Disable hypervisor operation<br/>
      "nop;"            // Tiny nop slide to accommodate examples<br/>
<span epub:type="pagebreak" id="page_413"/>
      "nop;"<br/>
      "nop;"<br/>
      "nop;"<br/>
      "nop;"<br/>
      "nop;"<br/>
      "nop;"<br/>
      "vmxoff;"         // Disable hypervisor operation<br/>
      :<br/>
      :"m"(v)           // Holds the input variable<br/>
      :<br/>
   );<br/>
}<br/>
int main() {<br/>
   int x;<br/>
   printf("Enter an int: ");<br/>
   scanf("%d", &amp;x);<br/>
   printf("After input, x=%d\n", x);<br/>
   do_vmx(x);<br/>
   printf("After do_vmx, x=%d\n", x);<br/>
   return 0;<br/>
}</pre>
<p class="indent">When we load the compiled binary into Ghidra, we see the following body of the function <code>do_vmx</code> in the Listing window:</p>
<pre>  0010071a 55             PUSH     RBP<br/>
  0010071b 48 89 e5       MOV      RBP,RSP<br/>
  0010071e 89 7d fc       MOV      dword ptr [RBP + local_c],EDI<br/>
  00100721 f3 0f c7       VMXON    qword ptr [RBP + local_c]<br/>
           75 fc<br/>
<span class="ent">➊</span> 00100726 0f 01 c4       VMXOFF<br/>
  00100729 90             NOP<br/>
  0010072a 90             NOP<br/>
  0010072b 90             NOP<br/>
  0010072c 90             NOP<br/>
  0010072d 90             NOP<br/>
  0010072e 90             NOP<br/>
  0010072f 90             NOP<br/>
<span class="ent">➋</span> 00100730 0f 01 c4       VMXOFF<br/>
  00100733 90             NOP<br/>
  00100734 5d             POP RBP<br/>
  00100735 c3             RET</pre>
<p class="indent">The bytes displayed for the opcode (<code>0f 01 c4</code>) in the two calls to <code>VMXOFF</code> <span class="ent">➊➋</span> match the opcode we observed in <em>ia.sinc</em> for this command. The following listing from the Decompiler window is consistent with what we know about the source code and the associated disassembly:</p>
<pre>void do_vmx(undefined4 param_1)<br/>
{<br/>
   undefined4 unaff_EBP;<br/>
<br/>
   vmxon(CONCAT44(unaff_EBP,param_1));<br/>
   vmxoff();<br/>
   vmxoff();<br/>
   return;<br/>
}</pre>
<span epub:type="pagebreak" id="page_414"/>
<p class="indent">To test that Ghidra detects the <code>VMXPLODE</code> instruction, we replace the first occurrence of <code>VMXOFF</code> in the <code>do_vmx</code> test function with <code>VMXPLODE</code>. However, the <code>VMXPLODE</code> instruction is missing not only from Ghidra’s processor definition, but also from our compiler’s knowledge base. In order for the assembler to accept our code, we hand-assembled the instruction using a data declaration instead of using the instruction mnemonic directly so that the assembler can process the new instruction:</p>
<pre>   //"vmxoff;"                 // replace this line<br/>
   ".byte 0x0f, 0x01, 0xc5;"   // with this hand assembled one</pre>
<p class="indent">When you load your updated binary into Ghidra, you see the following in the Listing window:</p>
<pre>  0010071a 55 PUSH RBP<br/>
  0010071b 48 89 e5 MOV RBP,RSP<br/>
  0010071e 89 7d fc MOV dword ptr [RBP + local_c],EDI<br/>
  00100721 f3 0f c7 VMXON qword ptr [RBP + local_c]<br/>
           75 fc<br/>
<span class="ent">➊</span> 00100726 0f 01 c5 VMXPLODE<br/>
  00100729 90 NOP<br/>
  0010072a 90 NOP<br/>
  0010072b 90 NOP<br/>
  0010072c 90 NOP<br/>
  0010072d 90 NOP<br/>
  0010072e 90 NOP<br/>
  0010072f 90 NOP<br/>
  00100730 0f 01 c4 VMXOFF<br/>
  00100733 90 NOP<br/>
  00100734 5d POP RBP<br/>
  00100735 c3 RET</pre>
<p class="indent">Your new instruction <span class="ent">➊</span> appears along with the opcode (<code>0f 01 c5</code>) that we have assigned to it. The Decompiler window also shows the new instruction:</p>
<pre>void do_vmx(undefined4 param_1)<br/>
{<br/>
   undefined4 unaff_EBP;<br/>
   vmxon(CONCAT44(unaff_EBP,param_1));<br/>
   vmxplode();<br/>
   vmxoff();<br/>
   return;<br/>
}</pre>
<span epub:type="pagebreak" id="page_415"/>
<p class="indent">So, what work has Ghidra undertaken in the background to add our new instruction to its x86 processor instruction set? When Ghidra is restarted (as it needs to be for these changes to take effect), it detects that the underlying <em>.sinc</em> file changed and generates a new <em>.sla</em> file when one is needed.</p>
<p class="indent">In this example, when we were loading the original compiled 64-bit binary file, Ghidra detected the change in the <em>ia.sinc</em> file and displayed the window shown in <a href="ch18.xhtml#fig18_6">Figure 18-6</a> while it was recompiling the <em>ia.sinc</em> file. (Note that it recompiles only when needed, not automatically on restart.) Because we loaded a 64-bit file, only <em>x86-64.sla</em> was updated, and not <em>x86.sla</em>. Later, when we loaded the updated file, complete with the <code>VMXPLODE</code> command, Ghidra did <em>not</em> recompile, as no changes were made to any underlying SLEIGH source files since the previous load.</p>
<div class="image"><img src="Images/fig18-6.jpg" alt="image" width="415" height="238"/></div>
<p class="figcap" id="fig18_6"><em>Figure 18-6: Ghidra window displayed while recompiling a language file</em></p>
<p class="indent">Here is a summary of the steps to add a new instruction to a processor module:</p>
<ol>
<li><p class="noindent">Locate the <em>languages</em> directory for the target processor (for example, <em>Ghidra/Processor/&lt;&lt;targetprocessor&gt;&gt;/data/languages</em>).</p></li>
<li><p class="noindent">Add the instruction to a selected processor .<em>sinc</em> file, or create a new <em>.sinc</em> file (for example, <em>Ghidra/Processor/&lt;targetprocessor&gt;/data/languages/&lt;targetprocessor&gt;.sinc</em>).</p></li>
<li><p class="noindent">If you created a new <em>.sinc</em> file, make sure it is included in the <em>.slaspec</em> file (for example, <em>Ghidra/Processor/&lt;targetprocessor&gt;/data/languages/&lt;targetprocessor&gt;.slaspec</em>).</p></li>
</ol>
<h4 class="h4" id="ch18lev344"><strong><em>Example 2: Modifying an Instruction in a Processor Module</em></strong></h4>
<p class="noindent">We have now successfully added an instruction to the Ghidra x86 processor module, but we have not yet accomplished our goal of making <code>VMXPLODE</code> leave with a <em>flourish</em>. Currently, it just exits without any excitement whatsoever. While it is challenging to make an assembly language instruction do anything that would qualify as a flourish, we can make our instruction <em>dab</em> <span epub:type="pagebreak" id="page_416"/>when it exits.<sup><a id="ch18fn5a" href="footnotes.xhtml#ch18fn5">5</a></sup> In this example, we will step through three options for making <code>VMXPLODE</code> dab for us. For our first option, we will exit after setting <code>EAX</code> to a hardcoded value: <code>0xDAB</code>.</p>
<h5 class="h5" id="ch18lev345"><strong>Option 1: Set EAX to a Constant Value</strong></h5>
<p class="noindent">Having the <code>VMXPLODE</code> instruction set the value of <code>EAX</code> to <code>0xDAB</code> prior to exiting requires only a minor modification to one instruction in the same file (<em>ia.sinc</em>) that we worked with in Example 1. The following listing shows the <code>VMXOFF</code> and <code>VMXPLODE</code> instructions as we left them after Example 1:</p>
<pre>:VMXOFF         is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc4      { vmxoff(); }<br/>
:VMXPLODE       is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc5      { vmxplode(); }</pre>
<p class="indent">Within the instruction contents, add the assignment to <code>EAX</code> immediately before the <code>vmxplode</code> action, as shown in the following listing:</p>
<pre>:VMXOFF         is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc4      { vmxoff(); }<br/>
:VMXPLODE       is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc5      { EAX=0xDAB; vmxplode(); }</pre>
<p class="indent">When we reopen Ghidra and load our test file, Ghidra once again displays the window shown in <a href="ch18.xhtml#fig18_6">Figure 18-6</a> to let us know that it has detected a change in an associated language file and is regenerating <em>x86-64.sla</em>. The Listing window doesn’t show any changes after Ghidra auto analyzes the file, but the difference is apparent in the Decompiler window:</p>
<pre>undefined4 do_vmx(undefined4 param_1)<br/>
{<br/>
   undefined4 unaff_EBP;<br/>
<br/>
   vmxon(CONCAT44(unaff_EBP,param_1));<br/>
   vmxplode();<br/>
   vmxoff();<br/>
   return 0xdab;<br/>
}</pre>
<p class="indent">In the Decompiler window, the <code>return</code> statement now returns the contents of <code>EAX</code> (<code>0xDAB</code>). This is interesting because we know this is a void function and doesn’t have a return value. The Listing window entry for the new instruction doesn’t show that the <code>VMXPLODE</code> command has changed in any way:</p>
<pre>00100726 0f 01 c5       VMXPLODE</pre>
<span epub:type="pagebreak" id="page_417"/>
<p class="indent">An important distinction between decompilers and disassemblers is that decompilers understand and incorporate the full semantic behavior of each instruction as part of their analysis, while disassemblers are focused largely on the proper syntactic representation of each instruction. In this example, <code>VMXPLODE</code> takes no operands and is correctly displayed by the disassembler, providing no visual cue that <code>EAX</code> has changed. When reading a disassembly, it is entirely your responsibility to understand the semantic behavior of each instruction. This example also demonstrates the value of the decompiler, which, understanding the full semantics of <code>VMXPLODE</code>, is able to recognize that <code>EAX</code> is changed as a side effect of the instruction. The decompiler also recognizes that <code>EAX</code> is not used for the remainder of the function and assumes that the value is intended to be returned to the calling function.</p>
<p class="indent">Ghidra offers you the opportunity to dive a little deeper into how instructions work and allows you to detect and test subtle differences in instructions like this one. First, let’s look at the some of the instruction information associated with <code>VMXPLODE</code>, shown in <a href="ch18.xhtml#fig18_7">Figure 18-7</a>.</p>
<div class="image"><img src="Images/fig18-7.jpg" alt="image" width="838" height="421"/></div>
<p class="figcap" id="fig18_7"><em>Figure 18-7:</em> <span class="codeitalic">VMXPLODE</span> <em>instruction info</em></p>
<p class="indent">On the left is our original <code>VMXPLODE</code> instruction, and on the right is the modified version, with <code>0xdab</code> listed in the Input Objects <span class="ent">➊</span> section and <code>EAX</code> under Result Objects <span class="ent">➋</span>. We can obtain additional insight about any instruction by looking at underlying information, called p-code, that we haven’t looked at previously.<sup><a id="ch18fn6a" href="footnotes.xhtml#ch18fn6">6</a></sup> The p-code associated with an instruction can be very informative about what exactly an instruction does.</p>
<span epub:type="pagebreak" id="page_418"/>
<div class="box5">
<p class="boxtitle-c"><strong>P-CODE: HOW LOW CAN YOU GO?</strong></p>
<p class="noindent">The Ghidra documentation describes p-code as a “register transfer language designed for reverse engineering applications.” A <em>register transfer language (RTL)</em> is an architecture-independent, assembly-language-like language often used as an intermediate representation (IR, or IL for intermediate language) between a high-level language such as C and a target assembly language such as x86 or ARM. Compilers are often composed of a language-specific frontend that translates source code into an IR, and an architecture-specific backend that translates IR into a specific assembly language. This modularity allows a C frontend to be combined with an x86 backend to create a C compiler that produces x86 code and offers the flexibility to replace the backend with an ARM module to instantly have a C compiler that generates ARM code. Swap out the C frontend for a FORTRAN frontend and now you have a FORTRAN compiler for ARM.</p>
<p class="indent">Working at the IR level allows us to build tools that operate on our IR rather than maintaining a set of C-specific or ARM-specific tools that are useless to us with other languages or architectures. For example, once we have an optimizer that operates on IR, we can reuse that optimizer with any of our frontend/backend combinations without rewriting the optimizer in each case.</p>
<p class="indent">A reverse engineering toolchain, not unsurprisingly, runs in the opposite direction of a traditional software build chain. An RE frontend needs to translate machine code to IR (a process often called <em>lifting</em>), while an RE backend translates IR to a high-level language such as C. A pure disassembler doesn’t qualify as a frontend under this definition as it gets us only from machine code to assembly language. Ghidra’s decompiler is an IR-to-C backend. Ghidra processor modules are machine-code-to-IR frontends.</p>
<p class="indent">When you build or modify a Ghidra processor module in SLEIGH, one of the first things you do is let the SLEIGH compiler know about any new p-code operations that you need to introduce in order to describe the semantic actions of any new or modified instructions. For example, the operation definition</p>
<pre>define pcodeop vmxplode</pre>
<p class="noindent">that we added to our <em>ia.sinc</em> file instructs the SLEIGH compiler that <code>vmxplode</code> is a valid semantic action available for describing the behavior of any instruction in our architecture. One of the most difficult challenges that you will face is describing each new or changed instruction using a sequence of syntactically correct SLEIGH statements that correctly describe the actions associated with the instruction. All of this information is captured in the <em>.slaspec</em> and included <em>.sinc</em> files that make up your processor. If you do a good enough job, Ghidra will hand you the decompiler backend for free.</p>
</div>
<span epub:type="pagebreak" id="page_419"/>
<p class="indent">To view the p-code within the Listing window, open the <strong>Browser Field Formatter</strong> and choose the <strong>Instruction/Data</strong> tab, right-click the <strong>P-code</strong> bar, and enable the field. Once the Listing window displays the p-code associated with each instruction, we can compare the previous two listings to observe any differences. With p-code enabled, our first implementation of <code>VMXPLODE</code> appears as follows with the p-code displayed after each instruction:</p>
<pre>0010071b 48 89 e5       MOV      RBP,RSP<br/>
                                            RBP = COPY RSP<br/>
                                            $U620:8 = INT_ADD RBP, -4:8<br/>
                                            $U1fd0:4 = COPY EDI<br/>
                                            STORE ram($U620), $U1fd0<br/>
00100721 f3 0f c7 75 fc VMXON    qword ptr [RBP + local_c]<br/>
<br/>
                                            $U620:8 = INT_ADD RBP, -4:8<br/>
                                            $Ua50:8 = LOAD ram($U620)<br/>
                                            CALLOTHER "vmxon", $Ua50<br/>
00100726 0f 01 c5       VMXPLODE<br/>
                                            CALLOTHER "vmxplode"<br/>
00100729 90             NOP</pre>
<p class="indent">And here is the modified <code>VMXPLODE</code>:</p>
<pre>00100726 0f 01 c5       VMXPLODE<br/>
                                            <span class="ent">➊</span> EAX = COPY 0xdab:4<br/>
                                               CALLOTHER "vmxplode"</pre>
<p class="indent">The associated p-code now shows the constant value (<code>0xdab</code>) being moved into <code>EAX</code> <span class="ent">➊</span>.</p>
<h5 class="h5" id="ch18lev346"><strong>Option 2: Set a Register (Determined by an Operand) to a Constant Value</strong></h5>
<p class="noindent">Instruction sets are typically made up of a mix of instructions that operate on zero or more operands. As the number and types of operands associated with an instruction increase, so does the level of difficulty in describing the instruction’s semantics. In this example, we’ll extend the behavior of <code>VMXPLODE</code> to require a single register operand, which will be made to dab. This will require us to visit sections of the <em>ia.sinc</em> file that we have not previously encountered. This time, let’s start with a modified version of the instruction and then work backward. The following listing shows the modifications we need to make to our instruction definition to accept an operand that will identify the register that ultimately will hold <code>0xDAB</code>:</p>
<pre>:VMXPLODE   Reg32<span class="ent">➊</span> is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc5; Reg32<span class="ent">➋</span><br/>
         {  Reg32=0xDAB<span class="ent">➋</span>; vmxplode(); }</pre>
<p class="indent">Here, <code>Reg32</code> <span class="ent">➊</span> is declared as a local identifier and then concatenated with the opcode <span class="ent">➋</span> to become part of the constraints associated with the instruction. Rather than assigning <code>0xDAB</code> directly into <code>EAX</code> as we did previously, the instruction now assigns the value into <code>Reg32</code> <span class="ent">➌</span>. To accomplish our <span epub:type="pagebreak" id="page_420"/>goal, we will need to determine a way to associate the value in <code>Reg32</code> with the x86 register of our choosing. Let’s investigate other components within <em>ia.sinc</em> to help us understand how to correctly map an operand to a specific x86 general-purpose register.</p>
<p class="indent">Near the start of <em>ia.sinc</em>, we see all of the definitions that will be needed by the entire specification, as shown in <a href="ch18.xhtml#exa18_1">Listing 18-1</a>.</p>
<pre># SLA specification file for Intel x86<br/>
@ifdef IA64<span class="ent">➊</span><br/>
@define SIZE     "8"<br/>
@define STACKPTR "RSP"<br/>
@else<br/>
@define SIZE     "4"<br/>
@define STACKPTR "ESP"<br/>
@endif<br/>
define endian=little;<span class="ent">➋</span><br/>
define space ram type=ram_space size=$(SIZE) default;<br/>
define space register type=register_space size=4;<br/>
# General purpose registers<span class="ent">➌</span><br/>
@ifdef IA64<br/>
define register offset=0 size=8 [ RAX    RCX    RDX    RBX    RSP    RBP    RSI    RDI ]<span class="ent">➍</span>;<br/>
define register offset=0 size=4    [ EAX _  ECX _  EDX _  EBX _  ESP _  EBP _  ESI _  EDI ];<br/>
define register offset=0 size=2    [ AX _ _ _ CX _ _ _ DX _ _ _ BX];       # truncated<br/>
define register offset=0 size=1    [ AL AH _ _ _ _ _ _ CL CH _ _ _ _ _ _]; # truncated y<br/>
define register offset=0x80 size=8 [ R8    R9    R10    R11    R12    R13    R14    R15 ]<span class="ent">➎</span>;<br/>
define register offset=0x80 size=4 [ R8D _ R9D _ R10D _ R11D _ R12D _ R13D _ R14D _ R15D ];<br/>
define register offset=0x80 size=2 [ R8W _ _ _ R9W _ _ _ R10W _ _ _ R11W ];  # truncated<br/>
define register offset=0x80 size=1 [ R8B _ _ _ _ _ _ _ R9B _ _ _ _ _ _ _ ];  # truncated<br/>
@else<br/>
define register offset=0 size=4    [  EAX  ECX  EDX  EBX  ESP  EBP  ESI  EDI ];<br/>
define register offset=0 size=2    [  AX _ CX _ DX _ BX _ SP _ BP _ SI _ DI ];<br/>
define register offset=0 size=1    [  AL AH _ _ CL CH _ _ DL DH _ _ BL BH ];<br/>
@endif</pre>
<p class="ex-caption" id="exa18_1"><em>Listing 18-1: Partial SLEIGH specification for x86 registers (adapted from</em> ia.sinc)</p>
<p class="indenta">At the top of the file, we see the name and size of the stack pointer for 32- and 64-bit builds <span class="ent">➊</span>, as well as the endianness <span class="ent">➋</span> for the x86. A comment <span class="ent">➌</span> introduces the start of the definitions of the general-purpose registers. As with all its other components, SLEIGH has a special convention for naming and defining registers: registers reside in a special address space named <code>register</code>, and every register (which may span 1 or more bytes) is assigned an offset within the address space. A SLEIGH register definition indicates the offset at which a list of registers begins within the register address space. All registers in a register list are contiguous unless an underscore is used to create space between them. The address space layout of the 64-bit <code>RAX</code> and <code>RCX</code> registers <span class="ent">➍</span> is shown in more detail in <a href="ch18.xhtml#fig18_8">Figure 18-8</a>.</p>
<span epub:type="pagebreak" id="page_421"/>
<div class="image"><img src="Images/fig18-8.jpg" alt="image" width="834" height="220"/></div>
<p class="figcap" id="fig18_8"><em>Figure 18-8: Register layout for x86-64</em> <span class="codeitalic">RAX</span> <em>and</em> <span class="codeitalic">RCX</span> <em>registers</em></p>
<p class="indent">The register named <code>AL</code> occupies exactly the same location as the least significant byte of <code>RAX</code>, <code>EAX</code>, and <code>AX</code> (since x86 is a little-endian). Similarly, <code>EAX</code> occupies the low 4 bytes of <code>RAX</code>. An underscore indicates that no name is associated with a given range of bytes for the given size. In this case, there is no name for the 4-byte block at offsets four to seven, although these bytes are synonymous with the upper half of the <code>RAX</code> register. <a href="ch18.xhtml#exa18_1">Listing 18-1</a> describes a separate block of registers beginning with <code>R8</code> at offset <code>0x80</code> <span class="ent">➎</span>. The 1-byte register at offset <code>0x80</code> is known as <code>R8B</code>, and the 1-byte register at offset <code>0x88</code> is known as <code>R9B</code>. Hopefully, the similarity between the textual register definition in <a href="ch18.xhtml#exa18_1">Listing 18-1</a> and the tabular representation in <a href="ch18.xhtml#fig18_8">Figure 18-8</a> are obvious, since the register definitions in a SLEIGH file are nothing more than the textual representation of an architecture’s register address space.</p>
<p class="indent">If you are writing a SLEIGH description of an architecture that is entirely unsupported by Ghidra, it will be your job to lay out the register address space for that architecture, ensuring no overlap between registers unless the architecture requires it (such as <code>RAX</code>, <code>EAX</code>, <code>AX</code>, <code>AH</code>, <code>AL</code> in the x86-64 architecture).</p>
<p class="indent">Now that you understand how registers are represented in SLEIGH, let’s return to our objective of choosing a register to <em>dab</em>! In order for our instruction to function properly, it needs to map the identifier <code>Reg32</code> to a general-purpose register. To accomplish this task, we can use an existing definition in <em>ia.sinc</em> that is found within the following lines of code:</p>
<pre><span class="ent">➊</span> define token modrm (8)<br/>
       mod           = (6,7)<br/>
       reg_opcode    = (3,5)<br/>
       reg_opcode_hb = (5,5)<br/>
       r_m           = (0,2)<br/>
       row           = (4,7)<br/>
       col           = (0,2)<br/>
       page          = (3,3)<br/>
       cond          = (0,3)<br/>
       reg8          = (3,5)<br/>
       reg16         = (3,5)<br/>
    <span class="ent">➋</span> reg32         = (3,5)<br/>
       reg64         = (3,5)<br/>
       reg8_x0       = (3,5)</pre>
<span epub:type="pagebreak" id="page_422"/>
<p class="indent">The <code>define</code> statement <span class="ent">➊</span> is declaring an 8-bit token called <code>modrm</code>. A SLEIGH token is a syntactic element used to represent byte-sized components that make up the instructions being modeled.<sup><a id="ch18fn7a" href="footnotes.xhtml#ch18fn7">7</a></sup> SLEIGH allows the definition of any number of bitfields (a range of one or more contiguous bits) within a token. When you’re defining instructions in SLEIGH, these bitfields provide a convenient, symbolic means of specifying the associated operands. In this listing, a bitfield named <code>reg32</code> <span class="ent">➋</span> spans bits 3 through 5 of <code>modrm</code>. This 3-bit field can take on the values 0 to 7 and can be used to choose one of the eight 32-bit x86 registers.</p>
<p class="indent">If we move to the next reference of <code>reg32</code> in the file, we see the following interesting lines of code:</p>
<pre># attach variables fieldlist registerlist;<br/>
  attach variables [ r32   reg32   base   index ]   [ EAX  ECX  EDX  EBX  ESP  EBP  ESI  EDI ];<br/>
#                                                      0    1    2    3    4    5    6    7</pre>
<p class="indent">The first and last lines of the listing contain comments that show the SLEIGH syntax for this statement and the ordinal values for each register. The <code>attach variables</code> statement associates the field with a list (in this case, a list of the x86 general-purpose registers). A rough interpretation of the line of code, taking the preceding <code>modrm</code> definition into account, is the following: The value of <code>reg32</code> is determined by looking at bits 3 to 5 of the token <code>modrm</code>. The resulting value (0 to 7) is then used as an index to select a register from the list.</p>
<p class="indent">We now have a way to identify the general-purpose registers to target for <code>0xDAB</code>. Our next encounter with <code>Reg32</code> within the file finds the following code, which contains the constructor for <code>Reg32</code> for both 32- and 64-bit registers, and now we can see the association between <code>reg32</code> and <code>Reg32</code>:<sup><a id="ch18fn8a" href="footnotes.xhtml#ch18fn8">8</a></sup></p>
<pre>Reg32:    reg32  is rexRprefix=0 &amp; reg32   { export reg32; } #64-bit Reg32<br/>
Reg32:    reg32  is reg32                  { export reg32; } #32-bit Reg32</pre>
<p class="indent">Let’s return to the command that started this little adventure:</p>
<pre>:VMXPLODE Reg32<span class="ent">➊</span>is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc5; Reg32<span class="ent">➋</span><br/>
                                           { Reg32=0xDAB; vmxplode(); }</pre>
<p class="indent">We are going to include an operand with our call to <code>VMXPLODE</code> that will determine which register gets the value <code>0xDAB</code>. We will update our test binary further by removing the first <code>NOP</code> and appending the value <code>0x08</code> to our hand-assembled instruction. The first 3 bytes are the opcode (<code>0f 01 c5</code>), and the following byte (<code>08</code>) will be the operand that specifies the register to use:</p>
<pre>".byte 0x0f, 0x01, 0xc5, 0x08;"            // hand assembled with operand</pre>
<span epub:type="pagebreak" id="page_423"/>
<p class="indent"><a href="ch18.xhtml#fig18_9">Figure 18-9</a> demonstrates the step-by-step translation from the operand through to the determination of the register based on the information in the <em>ia.sinc</em> file.</p>
<div class="image"><img src="Images/fig18-9.jpg" alt="image" width="672" height="197"/></div>
<p class="figcap" id="fig18_9"><em>Figure 18-9: Translation path from operand to register</em></p>
<p class="indent">The original operand value, shown in the first row, is <code>0x08</code> <span class="ent">➊</span>. The value is decoded into its binary <span class="ent">➋</span> form and overlaid with the fields of the <code>modrm</code> token <span class="ent">➌</span>. Bits 3 to 5 are extracted, yielding the <code>Reg32</code> value <code>001</code> <span class="ent">➍</span>. This value is used to index the ordinal map <span class="ent">➎</span> to select the <code>ECX</code> register <span class="ent">➏</span>. Therefore, the operand <code>0x08</code> specifies that <code>ECX</code> will get the value <code>0xDAB</code>.</p>
<p class="indent">When we save the updated <em>ia.sinc</em> file, restart Ghidra, and then load and analyze the file, the following listing is generated, showing the use of our new instruction. As expected, <code>ECX</code> is the register selected to hold <code>0xDAB</code>:</p>
<pre>00100721 f3 0f c7 75 fc VMXON    qword ptr [RBP + local_c]<br/>
<br/>
                                            $U620:8 = INT_ADD RBP, -4:8<br/>
                                            $Ua50:8 = LOAD ram($U620)<br/>
                                            CALLOTHER "vmxon", $Ua50<br/>
00100726 0f 01 c5 08    VMXPLODE ECX<br/>
                                            ECX = COPY 0xdab:4<br/>
                                            CALLOTHER "vmxplode"<br/>
0010072a 90 NOP</pre>
<p class="indent">The value <code>0xDAB</code> no longer appears in the Decompiler window because the decompiler assumes that the return value is in <code>EAX</code>. In this case, we are using <code>ECX</code> so the decompiler does not identify a return value.</p>
<p class="indent">Now that we can make a selected register dab, let’s add a 32-bit immediate value as a second operand. This will double our celebratory potential.</p>
<h5 class="h5" id="ch18lev347"><strong>Option 3: The Register and Value Operands</strong></h5>
<p class="noindent">To extend the syntax of our instruction to take two operands (a destination register and a source constant), update the definition of <code>VMXPLODE</code> as shown here:</p>
<pre>:VMXPLODE Reg32,imm32 is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc5;<br/>
          Reg32; imm32                     { Reg32=imm32; vmxplode(); }</pre>
<span epub:type="pagebreak" id="page_424"/>
<p class="indent">The addition of an immediate 32-bit constant to the instruction requires 4 additional bytes to encode. Accordingly, we replace the next four NOPs with values that correctly encode our <code>imm32</code> in little-endian order, as seen here:</p>
<pre>".byte 0x0f, 0x01, 0xc5, 0x08, 0xb8, 0xdb, 0xee, 0x0f;"<br/>
"nop;"<br/>
"nop;"</pre>
<p class="indent">When we reload the file, <code>VMXPLODE</code> exits with another flourish. As shown in the following listing (with p-code displayed), <code>ECX</code> now has the value <code>0xFEEDBB8</code> (which might be a more appealing exit flourish for science fiction fans):</p>
<pre>00100726 0f 01 c5       VMXPLODE ECX,0xfeedbb8<br/>
         08 b8 db<br/>
         ee 0f<br/>
                                            ECX = COPY 0xfeedbb8:4<br/>
                                            CALLOTHER "vmxplode"</pre>
<h4 class="h4" id="ch18lev348"><strong><em>Example 3: Adding a Register to a Processor Module</em></strong></h4>
<p class="noindent">We close out our processor module examples by extending an architecture with two entirely new registers.<sup><a id="ch18fn9a" href="footnotes.xhtml#ch18fn9">9</a></sup> Recall the definition of the 32-bit general-purpose registers from earlier in the chapter:</p>
<pre>define register offset=0  size=4  [EAX ECX EDX EBX ESP EBP ESI EDI];</pre>
<p class="indent">The definition of a register requires an offset, a size, and the list of registers. We chose a starting offset into the registry memory address space after reviewing the currently allocated offsets and finding the space we need for two 4-byte registers. We can use this information to define two new 32-bit registers in the <em>ia.sinc</em> file called <code>VMID</code> and <code>VMVER</code>, as shown in the following listing:</p>
<pre># Define VMID and VMVER<br/>
define register offset=0x1500 size=4 [ VMID VMVER ];</pre>
<p class="indent">Our instructions need a means to identify which new register (<code>VMID</code> or <code>VMVER</code>) they are operating on. In the previous example, we used a 3-bit field to select one of eight registers. To select between the two new registers requires only a single bit. The following statement defines a 1-bit field within the <code>modrm</code> token and associates the field with <code>vmreg</code>:</p>
<pre># Associate vmreg with a single bit in the modrm token.<br/>
vmreg = (3, 3)</pre>
<span epub:type="pagebreak" id="page_425"/>
<p class="indent">The following statement attaches <code>vmreg</code> to the ordinal set containing the two registers, with 0 representing <code>VMID</code> and 1 representing <code>VMVER</code>:</p>
<pre>attach variables [ vmreg ]   [ VMID  VMVER ];</pre>
<p class="indent">Instruction definitions may refer to <code>vmreg</code> when any of the attached registers are valid within the instruction, while assembly language programmers may refer to <code>VMID</code> and <code>VMER</code> as operands in any instruction that allows a <code>vmreg</code> operand. Let’s compare the following two definitions of <code>VMXPLODE</code>. The first is from our previous example, where we chose the register from among the general-purpose registers, and the second selects one of our two registers rather than any of the general-purpose registers:</p>
<pre>:VMXPLODE Reg32,imm32 is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc5;<br/>
          Reg32, imm32                     { Reg32=imm32; vmxplode(); }<br/>
:VMXPLODE vmreg,imm32 is vexMode=0 &amp; byte=0x0f; byte=0x01; byte=0xc5;<br/>
          vmreg, imm32                     { vmreg=imm32; vmxplode(); }</pre>
<p class="indent"><code>Reg32</code> is replaced with <code>vmreg</code> in the second listing. If we use the same input file with test instruction <code>vmxplode 0x08,0xFEEDBB8</code>, the immediate operand <code>0xFEEDBB8</code> will be loaded into <code>VMVER</code>, since the input value <code>0x08</code> maps to an ordinal value of 1 (because bit 3 is set), as we show in <a href="ch18.xhtml#fig18_10">Figure 18-10</a>, and <code>VMVER</code> is register 1 in <code>vmreg</code>. After loading the test file (after saving <em>ia.sinc</em> and restarting Ghidra), we see that the p-code in the Listing window shows that the immediate operand is loaded into <code>VMVER</code>:</p>
<pre>00100726 0f 01 c5       VMXPLODE   VMVER,0xfeedbb8<br/>
         08 b8 db<br/>
         ee 0f<br/>
                                              VMVER = COPY 0xfeedbb8:4<br/>
                                              CALLOTHER "vmxplode"</pre>
<p class="indent">The associated instruction information, shown in <a href="ch18.xhtml#fig18_10">Figure 18-10</a>, confirms the change as well.</p>
<div class="image"><img src="Images/fig18-10.jpg" alt="image" width="574" height="249"/></div>
<p class="figcap" id="fig18_10"><em>Figure 18-10: Instruction Info for VMXPLODE with new register VMVER selected</em></p>
<span epub:type="pagebreak" id="page_426"/>
<h3 class="h3" id="ch18lev349"><strong>Summary</strong></h3>
<p class="noindent">While we introduced only a small fraction of the x86 processor file contents in this chapter, we looked at the major components of a processor module, including instruction definitions, register definitions, and tokens, as well as how the Ghidra-specific language, SLEIGH, can be used to build, modify, and augment Ghidra processor modules. If you have a desire (or need) to add a new processor to Ghidra, we highly recommend looking at some of the more recent processors added to Ghidra. (The <em>SuperH4.sinc</em> file is particularly well-documented and the processor is significantly less complex than the x86 processor.)</p>
<p class="indent">We cannot emphasize enough the role that patience and experimentation play in any processor-development situation. The hard work more than pays off when you are able to reuse your processor module with each new binary you collect and potentially contribute the module back to the Ghidra project for the benefit of other reverse engineers.</p>
<p class="indent">In the next chapter, we take a deep dive into the functionality associated with the Ghidra Decompiler.</p>
</div>



  </body></html>