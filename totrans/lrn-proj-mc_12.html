<html><head></head><body>
<h2 class="h2" id="ch12"><a id="page_257"/><strong><span class="blue"><span class="big">12</span></span></strong><br/><strong>GETTING CLASSY WITH OBJECT-ORIENTED PROGRAMMING</strong></h2>
<div class="image1"><img src="graphics/common01.jpg" alt="image"/></div>
<p class="noindent">Reusability is a very important aspect of programming. It saves time and effort. You’ve seen this with loops and functions, and now you’ll learn about <em>object-oriented programming</em>.</p>
<p class="indent">Object-oriented programming is an approach to programming that groups functions and variables together to create <em>classes</em>. Each class can be used to create <em>objects</em> that share the same variables and functions as the class. You can create many objects from the same class, making the class’s variables and functions reusable.</p>
<p class="indent">When a function is part of a class, it’s called a <em>method</em>, and a variable that’s part of a class is called an <em>attribute</em>.</p>
<p class="indent">In this chapter, you’ll learn object-oriented programming and use classes to reuse code. Mastering object-oriented programming and classes makes building programs a breeze, and you can even use object-oriented programming to make games. In the missions in this chapter, you’ll use classes to make some basic programs. You’ll start by creating a simple building, but soon you’ll build an entire town.</p>
<h3 class="h3" id="ch12lev1sec01"><a id="page_258"/><strong><span class="blue">OBJECT-ORIENTED BASICS</span></strong></h3>
<p class="noindent">Object-oriented programming is very popular, and you can use it to create all kinds of cool software, but it can be a tricky concept to understand. Let’s relate it to something that’s more familiar: you.</p>
<p class="indent">You’re a person. You have a number of methods: you can eat, breathe, sleep, count to 10, and do lots of other things. You also have attributes: name, age, height, shoe size, and so on.</p>
<p class="indent">Your friend Mary has the same methods as you; she too can eat, breathe, sleep, count to 10, and do lots of other things. She also has the same attributes (name, age, and so on), although they contain different values.</p>
<p class="indent">In fact, everyone has these methods and attributes. You can describe people as a class. You and Mary are both people, so you could say you are both objects in the <code>Person</code> class.</p>
<p class="indent">In object-oriented programming, objects are called <em>instances</em> of a class. All objects share the methods and attributes of the class, but the values of the attributes can be different for each object.</p>
<p class="indent">Let’s jump into Python and make a class.</p>
<h3 class="h3" id="ch12lev1sec02"><strong><span class="blue">CREATING A CLASS</span></strong></h3>
<p class="noindent">You’ll start by creating a class and then create all your objects from that class. To create a class, you use the <code>class</code> keyword, the name you want to call the class, and the <code>object</code> class in parentheses (I’ll explain the <code>object</code> class in “<a href="ch12.html#ch12lev2sec07">Inheriting a Class</a>” on <a href="ch12.html#page_274">page 274</a>):</p>
<pre><span class="orange">class</span> <span class="blue1">ClassName</span>(<span class="rose">object</span>):<br/>    <span class="orange">def</span> <span class="blue1">__init__</span>(self):<br/>        <span class="red"># Body of init</span></pre>
<p class="indent">It’s good practice to capitalize the names of your classes. This makes it easier to tell the difference between classes and functions, which should start with a lowercase letter.</p>
<p class="indent">When you create a new class, you need to include the <code>__init__()</code> method and pass in <code>self</code> as an argument. The <code>self</code> argument is required by every method in a class. It references the class the method belongs to. The <code>__init__()</code> method tells Python what you want the class to do when you use it for the first time in a program. This is called <em>initializing</em> the class, which is what <code>__init__()</code> is short for.</p>
<p class="indent">For example, let’s create a class called <code>Cat</code> and then make some cat objects. The <code>Cat</code> class will store two attributes for each cat, their <code>name</code> and their <code>weight</code> in kilograms. Each cat object will have its own <code>name</code> and <code>weight</code> values. Open a new file in IDLE’s text editor and save it as <em>catClass.py</em> in a new folder called <em>classes</em>. Enter the following code to create a class called <code>Cat</code>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="orange">class</span> <span class="blue1">Cat</span>(<span class="rose">object</span>):<br/><span class="ent">➊</span>     <span class="orange">def</span> <span class="blue1">__init__</span>(self, name, weight):<br/><span class="ent">➋</span>         self.name = name<br/><span class="ent">➌</span>         self.weight = weight</pre>
<p class="indent"><a id="page_259"/>In this example, the <code>__init__()</code> method takes three arguments <span class="ent">➊</span>. The first is <code>self</code>, which is a required argument in every class method. The second argument, <code>name</code>, and the last argument, <code>weight</code>, are additional arguments to create attributes for all the cats.</p>
<p class="indent">The last two lines create the attributes <code>name</code> <span class="ent">➋</span> and <code>weight</code> <span class="ent">➌</span> and set them to the values of the <code>name</code> and <code>weight</code> arguments. When you create attributes inside a class, you use dot notation with <code>self</code>. Attributes are always identified by a <code>self</code>, which tells Python that an attribute belongs to the class.</p>
<p class="indent">Next, you’ll learn how to use this class to create instances of objects.</p>
<h4 class="h4" id="ch12lev2sec01"><strong><span class="blue">CREATING AN OBJECT</span></strong></h4>
<p class="noindent">Using the newly created class, let’s create some cat objects, or instances of the <code>Cat</code> class.</p>
<p class="indent">Initializing an object is similar to creating a variable. To initialize an object, you enter the name of the object, an equal sign (<code>=</code>), and the class name. You pass arguments to the class in parentheses, just as you do with a function call.</p>
<p class="indent">For example, let’s adopt a cat and name it Fluff. Using the <code>Cat</code> class, we can create a cat object called <code>fluff</code> by adding the following code on the last line of <em>catClass.py</em> (notice that it’s not indented):</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="ash">class Cat(object):</span><br/>    <span class="ash">def __init__(self, name, weight):</span><br/>        <span class="ash">self.name = name</span><br/>        <span class="ash">self.weight = weight</span><br/><br/>fluff = Cat(<span class="green">"Fluff"</span>, 4.5)</pre>
<p class="indent">When you create an object, the number of arguments you provide depends on the arguments in its <code>__init__()</code> function. Here we include two arguments, one for <code>name</code> (<code>"Fluff"</code>) and one for <code>weight</code> (<code>4.5</code>). You don’t need to include the <code>self</code> argument when creating an object because the <code>self</code> argument is added automatically by Python.</p>
<p class="indent">Creating an object is also known as <em>calling a constructor</em>. The <code>__init__()</code> method is often referred to as a constructor because it constructs a class when called. The <code>__init__()</code> method is a special type of method because you don’t reference it by name. Instead, it runs when you create an object using the name of the class. For example, here the code <code>fluff = Cat("Fluff", 4.5)</code> calls the <code>__init__()</code> method, which constructs a <code>Cat</code> object called <code>fluff</code>.</p>
<p class="indent">Next, you’ll learn how to access the <code>fluff</code> object’s attributes.</p>
<h4 class="h4" id="ch12lev2sec02"><strong><span class="blue">ACCESSING ATTRIBUTES</span></strong></h4>
<p class="noindent">You can access the attributes of an object to get more information about that object. For example, add the following code to <em>catClass.py</em> after the <code>fluff</code> object to print the <code>weight</code> attribute of the <code>fluff</code> object:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="rose">print</span>(fluff.weight)</pre>
<p class="indent"><a id="page_260"/>The value that prints when you run the program should be 4.5, because that’s what you set the <code>weight</code> attribute to when you created the object.</p>
<p class="indent">Notice that we’re using dot notation between the object’s name, <code>fluff</code>, and the <code>weight</code> attribute. The dot means you want to use the attribute that belongs to a specific object. In this case, the value of the <code>weight</code> attribute belongs to the <code>fluff</code> object. Whenever you get or set the value of an object’s attribute, you use dot notation.</p>
<p class="indent">You can change the value of an attribute as you would any other variable—by using an equal sign (<code>=</code>). For example, let’s change Fluff’s weight to 5 because he gained weight during the winter holidays. We do this by changing the <code>weight</code> attribute in the <code>fluff</code> object to 5:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre>fluff.weight = 5</pre>
<p class="indent">Now whenever you access the <code>weight</code> attribute on the <code>fluff</code> object, it will be 5.</p>
<p class="indent">Using the knowledge you now have about making a class and creating an instance of it, let’s make some cool stuff in Minecraft.</p>
<h4 class="h4a" id="ch12lev2sec03"><strong>MISSION #68: LOCATION OBJECTS</strong></h4>
<p class="noindent">Throughout the book, you’ve stored locations, such as your house, a castle, or a palace, in your Minecraft world. You’ve used variables, lists, tuples, and dictionaries to do this in a variety of ways.</p>
<p class="indent">You can also create and store related information, like locations, using object-oriented programming. For example, you can use objects to store the coordinates of a bunch of different locations.</p>
<p class="indent">Each location has an x-, y-, and z-coordinate, but the values for each location are different. By creating a location class, you can store and access the coordinates of different locations. That will help you keep track of all the awesome things you build in Minecraft. You’ll be able to easily access the coordinates of all your Minecraft creations so you can teleport the player to them in an instant!</p>
<p class="indent"><a href="ch12.html#ch12ex1">Listing 12-1</a> contains the start of the <code>Location</code> class. When the code is finished, it can be used to store the coordinates of a location in a single object. Copy the code into a new file called <em>locationClass.py</em> in the <em>classes</em> folder.</p>
<p class="sidenote"><span class="blue"><em>locationClass.py</em></span></p>
<pre>   <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br/>   mc = Minecraft.create()<br/><br/><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">Location</span>(<span class="rose">object</span>):<br/>       <span class="orange">def</span> <span class="blue1">__init__</span>(self, x, y, z):<br/><span class="ent">➋</span>         self.x = x<br/><span class="ent">➌</span>         <span class="red"># Add the y and z attributes here</span><br/><br/><span class="ent">➍</span> bedroom = Location(64, 52, -8)<br/><span class="ent">➎</span> mc.player.setTilePos(bedroom.x, bedroom.y, bedroom.z)</pre>
<p class="examplet"><a id="ch12ex1"/><em>Listing 12-1: The start of the</em> <code><span class="codeitalic">Location</code></span> <em>class</em></p>
<p class="indent"><a id="page_261"/>To start the class, I included the <code>class</code> keyword and named the class <code>Location</code> <span class="ent">➊</span>. At <span class="ent">➍</span> is the code to initialize an object called <code>bedroom</code>, which will store the location of the bedroom in my Minecraft home. The <code>setTilePos()</code> method sets the player’s position to the bedroom’s location—the <code>bedroom</code> object’s <code>x</code>, <code>y</code>, and <code>z</code> attributes <span class="ent">➎</span>. However, the program is incomplete. You need to finish the <code>__init__()</code> method of the class and set the <code>y</code> and <code>z</code> attributes to the values of the arguments passed to the <code>__init__()</code> method. I set the value of the <code>x</code> attribute <span class="ent">➋</span>, but it’s your task to do the same for the <code>y</code> and <code>z</code> attributes <span class="ent">➌</span>. Don’t forget to use the location of your own bedroom at <span class="ent">➍</span>!</p>
<p class="indent"><a href="ch12.html#ch12fig1">Figure 12-1</a> shows the completed program in action as it teleports the player into my bedroom.</p>
<div class="image"><img src="graphics/f12-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig1"/><em>Figure 12-1: The program has teleported the player into my bedroom.</em></p>
<div class="sidebar">
<p class="sidebart"><strong>BONUS OBJECTIVE: HOME SWEET HOME</strong></p>
<p class="noindent">Which other rooms in your house do you want to teleport to? Create more objects using the <code>Location</code> class to zip around your house in style!</p>
</div>
<h3 class="h3" id="ch12lev1sec03"><strong><span class="blue">UNDERSTANDING METHODS</span></strong></h3>
<p class="noindent">Classes can contain methods, which are functions associated with the class. Writing class methods lets you create functions that all instances of that class can use. This is a great way to save time and reuse code, because you’ll only have to write one method.</p>
<p class="indent">To create a method, you write a function in the body of a class using the <code>def</code> keyword. You’ve used the <code>def</code> keyword in previous chapters to create functions. Methods are also created with the <code>def</code> keyword, but they’re indented under the class they belong to. For example, let’s update the <code>Cat</code> class in <a id="page_262"/><em>catClass.py</em>. We want the cat to be able to eat, so let’s add a method called <code>eat()</code> to the <code>Cat</code> class. Enter the code and make the changes to <em>catClass.py</em> as you follow along:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="ash">class Cat(object):</span><br/>    <span class="ash">def __init__(self, name, weight):</span><br/>        <span class="ash">self.name = name</span><br/>        <span class="ash">self.weight = weight</span><br/><br/>    <span class="orange">def</span> <span class="blue1">eat</span>(self, food):<br/>        self.weight = self.weight + 0.05<br/>        <span class="rose">print</span>(self.name + <span class="green">" is eating "</span> + food)</pre>
<p class="indent">Notice that the method definition and body of the method are indented by an extra four spaces so Python knows they belong to the class.</p>
<p class="indent">Like functions, methods can take arguments. Here the <code>eat()</code> method takes an argument called <code>food</code> that states what the cat is eating. The <code>eat()</code> method increases the <code>weight</code> attribute of the cat by <code>0.05</code> and then prints a message that the cat is eating the food.</p>
<p class="indent">After creating an object, you can call any of its class’s methods. For example, you can call the <code>eat()</code> method using the <code>fluff</code> object. Add this code to the end of <em>catClass.py</em>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="ash">fluff = Cat("Fluff", 4.5)</span><br/>fluff.eat(<span class="green">"tuna"</span>)</pre>
<p class="indent">Here we see our earlier code, where we created an object called <code>fluff</code> that is part of the <code>Cat</code> class. Then we call the <code>eat()</code> method and give it the argument <code>"tuna"</code>. When you run the program, the output will look like this:</p>
<pre><span class="blue1">Fluff is eating tuna</span></pre>
<p class="indent">Now Fluff is happily eating tuna. Remember that the <code>eat()</code> method also increases the weight attribute. After calling the <code>eat()</code> method, add the code to print <code>fluff</code>’s weight.</p>
<p class="indent">You can also call methods from inside the class by calling a method inside another method. Let’s create another method called <code>eatAndSleep()</code> inside the <code>Cat</code> class. The <code>eatAndSleep()</code> method calls the <code>eat()</code> method and then prints that the cat is sleeping. Add this code to <em>catClass.py</em>, just after the <code>eat()</code> method (make sure you indent the new method as shown so Python knows it’s part of the class):</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="orange">def</span> <span class="blue1">eatAndSleep</span>(self, food):<br/>    self.eat(food)<br/>    <span class="rose">print</span>(self.name + <span class="green">" is now sleeping..."</span>)</pre>
<p class="indent">To call a method from inside the class it belongs to, you add <code>self.</code> to the beginning of the method name. Here the <code>eat()</code> method is called using <code>self.eat()</code>. Note that this is different from calling a method outside of <a id="page_263"/>a class. When you do that, you only have to enter the object name and the method you’re calling. For example, the following code calls the new <code>eatAndSleep()</code> method on the <code>fluff</code> object. Add it to your <em>catClass.py</em> file. This should be the last line of code in your program:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre>fluff.eatAndSleep(<span class="green">"tuna"</span>)</pre>
<p class="indent">Here is the output that you should get when you run the program:</p>
<pre><span class="blue1">Fluff is eating tuna</span><br/><span class="blue1">Fluff is now sleeping...</span></pre>
<p class="indent">Here’s the full program so you can see where all the pieces belong:</p>
<pre><span class="orange">class</span> <span class="blue1">Cat</span>(<span class="rose">object</span>):<br/>    <span class="orange">def</span> <span class="blue1">__init__</span>(self, name, weight):<br/>        self.name = name<br/>        self.weight = weight<br/><br/>    <span class="orange">def</span> <span class="blue1">eat</span>(self, food):<br/>        self.weight = self.weight + 0.05<br/>        <span class="rose">print</span>(self.name + <span class="green">" is eating "</span> + food)<br/><br/>    <span class="orange">def</span> <span class="blue1">eatAndSleep</span>(self, food):<br/>        self.eat(food)<br/>        <span class="rose">print</span>(self.name + <span class="green">" is now sleeping..."</span>)<br/><br/>fluff = Cat(<span class="green">"Fluff"</span>, 4.5)<br/><span class="rose">print</span>(fluff.weight)<br/>fluff.eat(<span class="green">"tuna"</span>)<br/>fluff.eatAndSleep(<span class="green">"tuna"</span>)</pre>
<p class="indent">Let’s take the new skills you’ve learned into the world of Minecraft!</p>
<h4 class="h4a" id="ch12lev2sec04"><strong>MISSION #69: GHOST HOUSE</strong></h4>
<p class="noindent">The best thing about programming with Python and Minecraft is that you can start with a silly idea and run with it. Your idea might start small, but with just a few lines of code, you can build a fun program very quickly.</p>
<p class="indent">Wouldn’t it be fun to build a ghost house that appeared in a game, only to disappear 30 seconds later? The house could then reappear somewhere else and then disappear again if you wanted it to.</p>
<p class="indent">Here’s the first version of the ghost house program. Save <a href="ch12.html#ch12ex2">Listing 12-2</a> in a file called <em>ghostHouse.py</em> in the <em>classes</em> folder.</p>
<p class="sidenote"><span class="blue"><em>ghostHouse.py</em></span></p>
<pre>   <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br/>   mc = Minecraft.create()<br/><br/>   <span class="orange">import</span> time<br/><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">Building</span>(<span class="rose">object</span>):<br/><span class="ent">➋</span>     <span class="orange">def</span> <span class="blue1">__init__</span>(self, x, y, z, width, height, depth):<br/>           self.x = x<br/>           self.y = y<br/>           self.z = z<br/><br/>           self.width = width<br/>           self.height = height<br/>           self.depth = depth<br/><br/><span class="ent">➌</span>     <span class="orange">def</span> <span class="blue1">build</span>(self):<br/>           mc.setBlocks(self.x, self.y, self.z,<br/>                        self.x + self.width, self.y + self.height,<br/>                        self.z + self.depth, 4)<br/><br/>           mc.setBlocks(self.x + 1, self.y + 1, self.z + 1,<br/>                        self.x + self.width - 1, self.y + self.height - 1,<br/>                        self.z + self.depth - 1, 0)<br/><span class="ent">➍</span>         <span class="red"># Call the buildDoor() and buildWindows() methods here</span><br/><br/><span class="ent">➎</span>     <span class="orange">def</span> <span class="blue1">clear</span>(self):<br/>           mc.setBlocks(self.x, self.y, self.z,<br/>                        self.x + self.width, self.y + self.height,<br/>                        self.z + self.depth, 0)<br/><span class="ent">➏</span>         <span class="red"># Remove the doors and windows here</span><br/><br/>   pos = mc.player.getTilePos()<br/>   x = pos.x<br/>   y = pos.y<br/>   z = pos.z<br/><br/><span class="ent">➐</span> ghostHouse = Building(x, y, z, 10, 6, 8)<br/>   ghostHouse.build()<br/><br/>   time.sleep(30)<br/><br/>   ghostHouse.clear()<br/><span class="ent">➑</span> ghostHouse.x = 8</pre>
<p class="examplet"><a id="ch12ex2"/><em>Listing 12-2: The</em> <code><span class="codeitalic">Building</code></span> <em>class creates a building.</em></p>
<p class="indent"><a id="page_264"/><a href="ch12.html#ch12ex2">Listing 12-2</a> uses a class called <code>Building</code> <span class="ent">➊</span> with an <code>__init__()</code> method to set the house’s position and size <span class="ent">➋</span>. It creates a <code>Building</code> object with the name <code>ghostHouse</code> <span class="ent">➐</span>. The building appears and then mysteriously disappears after 30 seconds using the <code>build()</code> <span class="ent">➌</span> and <code>clear()</code> <span class="ent">➎</span> methods. The only problem is that it doesn’t look like a house. Right now it looks like a large, empty shell made of cobblestone.</p>
<p class="indent">You need to make the ghost house look more like a house and less like a shell, because ghost shells aren’t as scary as ghost houses. To make the building look more house-like, your mission is to add a method that builds a door at the front of the house and a second method that adds windows. Call these two methods from inside the <code>build()</code> method so they’re built at the same time <span class="ent">➍</span>.</p>
<p class="indent"><a id="page_265"/>After adding the methods to build a door and windows, you’ll need to update the <code>clear()</code> method to delete them <span class="ent">➏</span>; otherwise, they’ll be left behind when the house disappears.</p>
<p class="indent">When you’ve added the extra methods, move the building to a new location by changing the <code>x</code>, <code>y</code>, and <code>z</code> attributes of the <code>ghostHouse</code> object and adding more calls to the <code>build()</code> and <code>clear()</code> methods. I’ve started this for you by changing the house’s <code>x</code> position <span class="ent">➑</span>.</p>
<p class="indent">When you run the program, the ghost house should suddenly appear and then disappear 30 seconds later, only to reappear somewhere else. Spooky!</p>
<p class="indent"><a href="ch12.html#ch12fig2">Figure 12-2</a> shows my ghost house.</p>
<div class="image"><img src="graphics/f12-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig2"/><em>Figure 12-2: The ghost house appears and then disappears.</em></p>
<div class="sidebar">
<p class="sidebart"><a id="page_266"/><strong>BONUS OBJECTIVE: HOME IMPROVEMENT</strong></p>
<p class="noindent">At the moment, the ghost house is very basic. Using the amazing Python skills you’ve learned in this book, add whatever you want to the <code>build()</code> function to customize your house.</p>
</div>
<h3 class="h3" id="ch12lev1sec04"><strong><span class="blue">RETURNING VALUES WITH METHODS</span></strong></h3>
<p class="noindent">Like functions, methods can also return values, or an object’s attributes, using the <code>return</code> keyword. For example, let’s say we want to convert Fluff the cat’s weight from kilograms to grams. A kilogram is equal to 1000 grams, so to make the conversion, you multiply the <code>weight</code> attribute by 1000 and return it. Add the following <code>getWeightInGrams()</code> method to the <code>Cat</code> class in <em>catClass.py</em>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="ash">class Cat(object):</span><br/>    <span class="ash">def __init__(self, name, weight):</span><br/>        <span class="ash">self.name = name</span><br/>        <span class="ash">self.weight = weight</span><br/><br/><br/>    <span class="orange">def</span> <span class="blue1">getWeightInGrams</span>(self):<br/>        <span class="orange">return</span> self.weight * 1000</pre>
<p class="indent">To output the value returned by the method, you create an object and call the method. In the following code, the <code>fluff</code> object is used, and the method is called inside a <code>print()</code> function to get the cat’s weight in grams:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="ash">fluff = Cat("Fluff", 4.5)</span><br/><span class="rose">print</span>(fluff.getWeightInGrams())</pre>
<p class="indent">Now when you run the file, it will output the following:</p>
<pre><span class="blue1">4500</span></pre>
<p class="indent">In the next mission, we’ll extend the ghost house program to include a method that returns information about the building.</p>
<h4 class="h4a" id="ch12lev2sec05"><strong>MISSION #70: GHOST CASTLE</strong></h4>
<p class="noindent">I have all kinds of names in mind for the different places I’ve built in my Minecraft world: the beach house, the plant farm, the animal farm, the storage room, the palace, the underwater palace, the underground palace, and loads more. The problem is that the names only exist in my head!</p>
<p class="indent">With classes, you can create attributes like location and size for things you build, as you saw in <a href="ch12.html#ch12lev2sec04">Mission #69</a> (<a href="ch12.html#page_263">page 263</a>). You can also include names!</p>
<p class="indent"><a id="page_267"/>Let’s name the ghost house and have Python remember it for us. We’ll update the <code>Building</code> class from <a href="ch12.html#ch12lev2sec04">Mission #69</a> to add an extra method that returns the name of the building. Copy <a href="ch12.html#ch12ex3">Listing 12-3</a> into a new file called <em>ghostCastle.py</em> in the <em>classes</em> folder.</p>
<p class="sidenote"><span class="blue"><em>ghostCastle.py</em></span></p>
<pre>   <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br/>   mc = Minecraft.create()<br/><br/>   <span class="orange">import</span> time<br/><br/><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">NamedBuilding</span>(<span class="rose">object</span>):<br/><span class="ent">➋</span>     <span class="orange">def</span> <span class="blue1">__init__</span>(self, x, y, z, width, height, depth, name):<br/>           self.x = x<br/>           self.y = y<br/>           self.z = z<br/><br/>           self.width = width<br/>           self.height = height<br/>           self.depth = depth<br/><br/><span class="ent">➌</span>         self.name = name<br/><br/>      <span class="orange">def</span> <span class="blue1">build</span>(self):<br/>          mc.setBlocks(self.x, self.y, self.z,<br/>                       self.x + self.width, self.y + self.height,<br/>                       self.z + self.depth, 4)<br/><br/>          mc.setBlocks(self.x + 1, self.y + 1, self.z + 1,<br/>                       self.x + self.width - 1, self.y + self.height - 1,<br/>                       self.z + self.depth - 1, 0)<br/><br/>      <span class="orange">def</span> <span class="blue1">clear</span>(self):<br/>          mc.setBlocks(self.x, self.y, self.z,<br/>                       self.x + self.width, self.y + self.height,<br/>                       self.z + self.depth, 0)<br/><br/><span class="ent">➍</span>     <span class="orange">def</span> <span class="blue1">getInfo</span>():<br/>           <span class="red"># Add the body of the getInfo() method here</span><br/><br/>   pos = mc.player.getTilePos()<br/>   x = pos.x<br/>   y = pos.y<br/>   z = pos.z<br/>   ghostCastle = NamedBuilding(x, y, z, 10, 16, 16, <span class="green">"Ghost Castle"</span>)<br/>   ghostCastle.build()<br/><span class="ent">➎</span> mc.postToChat(ghostCastle.getInfo())<br/><br/>   time.sleep(30)<br/><br/>   ghostCastle.clear()</pre>
<p class="examplet"><a id="ch12ex3"/><em>Listing 12-3:</em> <code><span class="codeitalic">NamedBuilding</code></span> <em>is very similar to the</em> <code><span class="codeitalic">Building</code></span> <em>class, except it has an extra attribute called</em> <code><span class="codeitalic">name</code></span> <em>and an extra method that returns a description of the building.</em></p>
<p class="indent"><a id="page_268"/>First, I changed the name of the class to <code>NamedBuilding</code> so we won’t confuse it with the <code>Building</code> class from the previous mission <span class="ent">➊</span>. I’ve added an extra argument and attribute to the constructor called <code>name</code> <span class="ent">➋</span>. The argument allows you to give a name to the building, and the constructor assigns the name to the <code>name</code> attribute <span class="ent">➌</span>.</p>
<p class="indent">Your mission is to add a method called <code>getInfo()</code> to the new class <code>NamedBuilding</code> that returns the name and position of the building. I’ve added the start of the <code>getInfo()</code> method for you at <span class="ent">➍</span>. You just need to add the body. The <code>getInfo()</code> method is called on the <code>ghostCastle</code> object at <span class="ent">➎</span> so it outputs the string returned by the method to the Minecraft chat. For example, if the ghost castle is located at <code>x = -310</code>, <code>y = 64</code>, <code>z = 1081</code>, the <code>getInfo()</code> method should return the string <code>"Ghost Castle's location is at -310, 64, 1081"</code>.</p>
<p class="indent"><a href="ch12.html#ch12fig3">Figure 12-3</a> shows my working program. Although the ghost castle is taller, it looks like the house from <a href="ch12.html#ch12lev2sec04">Mission #69</a>. This is because the <code>build()</code> methods are the same for both, but feel free to change your version of the code so your building looks more like a castle.</p>
<div class="image"><img src="graphics/f12-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig3"/><em>Figure 12-3: The description of the ghost castle is displayed.</em></p>
<div class="sidebar">
<p class="sidebart"><strong>BONUS OBJECTIVE: A WARM WELCOME</strong></p>
<p class="noindent">Wouldn’t it be cool if the name of any building you walked into appeared in the chat automatically? Well, it’s possible, but it’s a bit challenging. If you want to try this, you can use the <em>shower.py</em> program from <a href="ch06.html#ch06lev2sec11">Mission #32</a> (<a href="ch06.html#page_120">page 120</a>) as a starting point. The file should be in your <em>ifStatements</em> folder. You can use the program to detect the coordinates of the player and, if they’re inside the building, call the <code>building</code> object’s <code>getInfo()</code> method.</p>
</div>
<h3 class="h3" id="ch12lev1sec05"><a id="page_269"/><strong><span class="blue">CREATING MULTIPLE OBJECTS</span></strong></h3>
<p class="noindent">You can make several objects from the same class by creating objects with different names using the same class constructor (remember that <em>constructor</em> is another name for the <code>__init__()</code> method). For example, let’s say we found a second cat named Stella who is now friends with Fluff. Open <em>catClass.py</em> and enter the following code to add Stella:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="ash">class Cat(object):</span><br/>    <span class="ash">def __init__(self, name, weight):</span><br/>        <span class="ash">self.name = name</span><br/>        <span class="ash">self.weight = weight</span><br/><br/><span class="ash">fluff = Cat("Fluff", 4.5)</span><br/>stella = Cat(<span class="green">"Stella"</span>, 3.9)</pre>
<p class="indent">Now we have two cat objects, <code>fluff</code> and <code>stella</code>. Each has the same attributes, <code>name</code> and <code>weight</code>, but with different values.</p>
<p class="indent">Add the following code to <em>catClass.py</em> to print the cats’ names:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="rose">print</span>(fluff.name)<br/><span class="rose">print</span>(stella.name)</pre>
<p class="indent">When you run the file, you’ll get this output:</p>
<pre><span class="blue1">Fluff</span><br/><span class="blue1">Stella</span></pre>
<p class="indent">The two cat objects also have access to the same methods. Both can call the <code>eat()</code> function. Add this code to <em>catClass.py</em>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre>fluff.eat(<span class="green">"tuna"</span>)<br/>stella.eat(<span class="green">"cake"</span>)</pre>
<p class="indent">And the output will look like this:</p>
<pre><span class="blue1">Fluff is eating tuna</span><br/><span class="blue1">Stella is eating cake</span></pre>
<p class="indent">Writing a class makes creating lots of objects very easy. Let’s try creating multiple objects with Minecraft!</p>
<h4 class="h4a" id="ch12lev2sec06"><strong>MISSION #71: GHOST TOWN</strong></h4>
<p class="noindent">What’s scarier than one ghost house? That’s right, two ghost houses. But three ghost houses would be even scarier. And more than three ghost houses? I need to stop thinking about this, or I won’t get any sleep tonight!</p>
<p class="indent"><a id="page_270"/>In <a href="ch12.html#ch12lev2sec04">Mission #69</a> (<a href="ch12.html#page_263">page 263</a>), you made a class that builds a house that disappears. Now you can create several objects using the same class, and Python will remember each of the object’s attributes and methods. You can make as many houses as you want, and you can make them appear and disappear with ease.</p>
<p class="indent">Your mission is to create four or more ghost house objects and arrange them in a village. After a certain amount of time, make them all disappear and reappear elsewhere on the map, just like a real ghost town.</p>
<p class="indent">Open <em>ghostHouse.py</em> in IDLE—we’ll use this as a base. When you created a house in the <em>ghostHouse.py</em> program, your code should have looked like this:</p>
<p class="sidenote"><span class="blue"><em>ghostHouse.py</em></span></p>
<pre>ghostHouse = Building(17, 22, -54, 10, 6, 8)<br/>ghostHouse.build()<br/><br/>time.sleep(30)<br/><br/>ghostHouse.clear()</pre>
<p class="indent">Save <em>ghostHouse.py</em> as a new file called <em>ghostVillage.py</em>, and then create three or more objects in the file using the <code>Building</code> class to build the village. To help you get started, I’ve created a second object called <code>shop</code> in <a href="ch12.html#ch12ex4">Listing 12-4</a>. I’ve also set the variables <code>x</code>, <code>y</code>, and <code>z</code> to hold the player’s current position, which we find using <code>player.getTilePos()</code>. This makes it easier to build the village all around you.</p>
<p class="sidenote"><span class="blue"><em>ghostVillage.py</em></span></p>
<pre>pos = mc.player.getTilePos()<br/>x = pos.x<br/>y = pos.y<br/>z = pos.z<br/>ghostHouse = Building(x, y, z, 10, 6, 8)<br/>shop = Building(x + 12, y, z, 8, 12, 10)<br/><span class="red"># Create more ghost building objects here</span><br/><br/>ghostHouse.build()<br/>shop.build()<br/><span class="red"># Build more ghost building objects here</span><br/><br/>time.sleep(30)<br/><br/>ghostHouse.clear()<br/>shop.clear()</pre>
<p class="examplet"><a id="ch12ex4"/><em>Listing 12-4: Creating multiple ghost building objects</em></p>
<p class="indent"><a href="ch12.html#ch12fig4">Figure 12-4</a> shows my ghost village. After 30 seconds, the ghost buildings suddenly disappear.</p>
<div class="image"><a id="page_271"/><img src="graphics/f12-04.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig4"/><em>Figure 12-4: Look at all the ghost buildings in the ghost village!</em></p>
<h3 class="h3" id="ch12lev1sec06"><strong><span class="blue">CLASS ATTRIBUTES</span></strong></h3>
<p class="noindent">Sometimes you might want to set attributes that have the same value for every object instance in a class. It would be redundant to pass the same argument to the class every time an object is created. Instead, you can create a preset attribute in the class, and all the instances of objects in that class will share those attributes.</p>
<p class="indent">When multiple objects share the same attribute, it’s called a <em>class attribute</em>. For example, all the cat objects we’ve created are owned by Craig (me). I can revisit the <code>Cat</code> class in the <em>catClass.py</em> file, create a class attribute called <code>owner</code>, and set it to <code>"Craig"</code>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="ash">class Cat(object):</span><br/>    owner = <span class="green">"Craig"</span><br/><br/>    <span class="ash">def __init__(self, name, weight):</span><br/>        <span class="ash">self.name = name</span><br/>        <span class="ash">self.weight = weight</span></pre>
<p class="indent">As you can see, class attributes don’t use <code>self</code> before their name. In this example, <code>owner</code> is a class attribute and <code>self.name</code> is an attribute. Notice that you define class attributes outside the <code>__init__()</code> function.</p>
<p class="indent">Class attributes work the same as any other attribute in an object. For example, you can access the value of a class attribute as you would a normal attribute. In this case, to find Fluff’s owner, we can print the <code>owner</code> class attribute of the <code>fluff</code> object:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="ash">fluff = Cat("Fluff", 4.5)</span><br/><span class="rose">print</span>(fluff.owner)</pre>
<p class="indent"><a id="page_272"/>The printed value should be <code>"Craig"</code>. If we printed Stella’s owner, the value would be the same because class attributes are the same for every object in that class:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="ash">stella = Cat("Stella", 3.9)</span><br/><span class="rose">print</span>(stella.owner)</pre>
<p class="indent">The printed value here is also <code>"Craig"</code>.</p>
<p class="indent">You can change the value of class attributes for individual objects. This will change the value of the attribute for that object, but no other objects in the class. For example, Stella has been adopted by my friend Matthew, so we need to change Stella’s owner to <code>"Matthew"</code>:</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre>stella.owner = <span class="green">"Matthew"</span><br/><span class="ash">print(stella.owner)<br/>print(fluff.owner)</span></pre>
<p class="indent">When the <code>owner</code> attribute of <code>stella</code> is printed, it shows <code>"Matthew"</code>, but <code>fluff</code>’s owner is still <code>"Craig"</code>.</p>
<p class="indent">After all the changes we’ve made to <em>catClass.py</em>, the final program looks like the following. It’s also available in the book’s resources at <em><a href="https://www.nostarch.com/pythonwithminecraft/">https://www.nostarch.com/pythonwithminecraft/</a></em>.</p>
<p class="sidenote"><span class="blue"><em>catClass.py</em></span></p>
<pre><span class="orange">class</span> <span class="blue1">Cat</span>(<span class="rose">object</span>):<br/>    owner = <span class="green">"Craig"</span><br/><br/>    <span class="orange">def</span> <span class="blue1">__init__</span>(self, name, weight):<br/>        self.name = name<br/>        self.weight = weight<br/><br/>    <span class="orange">def</span> <span class="blue1">eat</span>(self, food):<br/>        self.weight = self.weight + 0.05<br/>        <span class="rose">print</span>(self.name + <span class="green">" is eating "</span> + food)<br/><br/>    <span class="orange">def</span> <span class="blue1">eatAndSleep</span>(self, food):<br/>        self.eat(food)<br/>        <span class="rose">print</span>(self.name + <span class="green">" is now sleeping..."</span>)<br/><br/>    <span class="orange">def</span> <span class="blue1">getWeightInGrams</span>(self):<br/>        <span class="orange">return</span> self.weight * 1000<br/><br/><br/>fluff = Cat(<span class="green">"Fluff"</span>, 4.5)<br/><span class="rose">print</span>(fluff.owner)<br/>stella = Cat(<span class="green">"Stella"</span>, 3.9)<br/><span class="rose">print</span>(stella.owner)<br/><br/><span class="rose">print</span>(fluff.weight)<br/>fluff.eat(<span class="green">"tuna"</span>)<br/>fluff.eatAndSleep(<span class="green">"tuna"</span>)<br/><br/><span class="rose">print</span>(fluff.getWeightInGrams())<br/><span class="rose">print</span>(fluff.name)<br/><span class="rose">print</span>(stella.name)<br/><br/>fluff.eat(<span class="green">"tuna"</span>)<br/>stella.eat(<span class="green">"cake"</span>)<br/><br/>stella.owner = <span class="green">"Matthew"</span><br/><span class="rose">print</span>(stella.owner)<br/><span class="rose">print</span>(fluff.owner)</pre>
<p class="indent"><a id="page_273"/>Now that you’ve seen how to use objects, let’s see how to make them even more powerful with inheritance.</p>
<h3 class="h3" id="ch12lev1sec07"><strong><span class="blue">UNDERSTANDING INHERITANCE</span></strong></h3>
<p class="noindent"><em>Inheritance</em> occurs when classes share the same methods and attributes as other classes. For example, ducks are a type of bird. They share the same methods as other birds (flying, eating, and so on), and they have the same attributes as other birds (weight, wingspan, and so on). So you could say that <em>ducks</em> inherit their attributes and methods from the class <em>birds</em>. <a href="ch12.html#ch12fig5">Figure 12-5</a> shows this relationship in a diagram.</p>
<div class="image"><img src="graphics/f12-05.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig5"/><em>Figure 12-5: Penguins and ducks are both types of birds.</em></p>
<p class="indent">The class that other classes inherit from is called a <em>superclass</em>; the class that inherits from the superclass is called a <em>subclass</em>.</p>
<p class="indent">Inheritance is useful because it allows you to create subtle differences between similar objects. For example, penguins are also a type of bird, but they can swim underwater, unlike most birds. To represent penguins, you need to create a subclass that inherits from the bird class but has adaptations so the penguins can swim underwater. These adaptations are the reason you create subclasses: you can keep the main superclass features to avoid having to write the code again, and just add the methods and attributes you need in the subclass.</p>
<h4 class="h4" id="ch12lev2sec07"><a id="page_274"/><strong><span class="blue">INHERITING A CLASS</span></strong></h4>
<p class="noindent">When a subclass inherits from a superclass, the subclass can use all the superclass’s methods and attributes. The subclass can also add extra classes and attributes without altering the original superclass.</p>
<p class="indent">Let’s use the birds example to illustrate this. First, we’ll write the code for the <code>Bird</code> superclass. Open a new file in IDLE, name it <em>birdClass.py</em>, and then add the following code to make the class:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<pre><span class="ent">➊</span> <span class="orange">class</span> <span class="blue1">Bird</span>(<span class="rose">object</span>):<br/><span class="ent">➋</span>     <span class="orange">def</span> <span class="blue1">__init__</span>(self, name, wingspan):<br/>           self.name = name<br/>           self.wingspan = wingspan<br/><br/><span class="ent">➌</span>     <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br/>           <span class="rose">print</span>(<span class="green">"chirp"</span>)<br/><br/><span class="ent">➍</span>     <span class="orange">def</span> <span class="blue1">fly</span>(self):<br/>           <span class="rose">print</span>(<span class="green">"flap"</span>)</pre>
<p class="indent">We create a class called <code>Bird</code> <span class="ent">➊</span>, but notice that the <code>Bird</code> class inherits from <code>object</code>. The <code>object</code> class is a base class that all other classes will be built on top of. All classes inherit from the <code>object</code> class, and you use it when there are no other superclasses to inherit from. Even if there are several levels of inheritance where lots of classes inherit from each other, the <code>object</code> class will always be the superclass used on the highest level of inheritance.</p>
<p class="indent">The <code>Bird</code> class’s <code>__init__()</code> method takes two arguments that set two attributes: the <code>name</code> of the bird and its <code>wingspan</code> <span class="ent">➋</span>. It has two methods: <code>birdcall()</code> <span class="ent">➌</span> and <code>fly()</code> <span class="ent">➍</span>. At the moment, the <code>birdcall()</code> method just prints <code>"chirp"</code> and the <code>fly()</code> method just prints <code>"flap"</code>.</p>
<p class="indent">In the same file, create an object called <code>gardenBird</code> using the <code>Bird</code> class:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<pre>gardenBird = Bird(<span class="green">"Geoffrey"</span>, 12)<br/>gardenBird.birdcall()<br/>gardenBird.fly()</pre>
<p class="indent">This code will output:</p>
<pre><span class="blue1">chirp</span><br/><span class="blue1">flap</span></pre>
<p class="indent">Now that you’ve created a superclass, you can create a subclass that inherits from the superclass but gets its own method. You’ll do that in the next section.</p>
<h4 class="h4" id="ch12lev2sec08"><a id="page_275"/><strong><span class="blue">ADDING NEW METHODS TO SUBCLASSES</span></strong></h4>
<p class="noindent">Let’s add a class for penguins to <em>birdClass.py</em> and call it <code>Penguin</code>. Because penguins can swim underwater, you can add an extra method to the <code>Penguin</code> class called <code>swim()</code>:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<pre><span class="orange">class</span> <span class="blue1">Penguin</span>(Bird):<br/>    <span class="orange">def</span> <span class="blue1">swim</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"swimming"</span>)</pre>
<p class="indent">When you define a subclass and want it to inherit from another superclass instead of <code>object</code>, you put the name of the superclass to inherent from in parentheses. Notice that I didn’t create an <code>__init__()</code> method for the <code>Penguin</code> class. The reason is that it inherits from the <code>Bird</code> class, so it uses the <code>Bird</code> class <code>__init__()</code> method. Let’s use that <code>__init__()</code> method and test the <code>swim()</code> function by creating a penguin:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<pre>sarahThePenguin = Penguin(<span class="green">"Sarah"</span>, 10)<br/>sarahThePenguin.swim()</pre>
<p class="indent">This code will output the following:</p>
<pre><span class="blue1">swimming</span></pre>
<p class="indent">The <code>Penguin</code> class can also use the <code>fly()</code> and <code>birdcall()</code> methods because it inherits them from <code>Bird</code>.</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<pre>sarahThePenguin.fly()<br/>sarahThePenguin.birdcall()</pre>
<p class="indent">In this case, the output will look like this:</p>
<pre><span class="blue1">flap</span><br/><span class="blue1">chirp</span></pre>
<p class="indent">But <code>flap</code> and <code>chirp</code> don’t make sense for a penguin because penguins can’t fly and their birdcall is more of a quack! We’ll learn how to override inherited methods and fix this in “<a href="ch12.html#ch12lev1sec08">Overriding Methods and Attributes</a>” on <a href="ch12.html#page_278">page 278</a>.</p>
<p class="indent">But first, let’s return to Minecraft and create some new ghost buildings using inheritance.</p>
<h4 class="h4a" id="ch12lev2sec09"><strong>MISSION #72: GHOST HOTEL</strong></h4>
<p class="noindent">Houses and hotels are both types of buildings: they have doors, windows, rooms, stairs, and walls. Hotels are just fancy houses with extras like balconies, lots of rooms, and a pretty entrance.</p>
<p class="indent"><a id="page_276"/>How can you program some ghost hotels using the code you’ve already created for ghost houses? The basic structure of the buildings is the same. So let’s say the only difference is that ghost hotels have extra methods to create carpets inside the rooms and add flowers around the edge of the building. That means the ghost hotel class can inherit all the methods from the ghost house class. Then all the ghost hotel class needs is two extra methods for the carpets and flowers.</p>
<p class="indent">In IDLE, create a new file and save it as <em>ghostHotel.py</em> in the <em>classes</em> folder. Copy and paste the code for the <code>Building</code> class from the <em>ghostHouse.py</em> program into the file.</p>
<p class="indent">Create a new class called <code>FancyBuilding</code> that inherits from the <code>Building</code> class. The <code>FancyBuilding</code> class should have a new method called <code>upgrade()</code> that adds carpet inside the building and flowers around the walls. <a href="ch12.html#ch12ex5">Listing 12-5</a> shows my code for the <code>upgrade()</code> method, but feel free to customize your hotels.</p>
<p class="sidenote"><span class="blue"><em>ghostHotel.py</em></span></p>
<pre><span class="red"># Create a FancyBuilding class here</span><br/><br/>    <span class="orange">def</span> <span class="blue1">upgrade</span>(self):<br/>        <span class="red"># Carpet</span><br/>        mc.setBlocks(self.x + 1, self.y, self.z + 1,<br/>                     self.x + self.width - 1, self.y, self.z + self.depth - 1,<br/>                     35, 6)<br/><br/>        <span class="red"># Flowers</span><br/>        mc.setBlocks(self.x - 1, self.y, self.z -1,<br/>                     self.x - 1, self.y, self.z + self.depth + 1,<br/>                     37)<br/>        mc.setBlocks(self.x - 1, self.y, self.z - 1,<br/>                     self.x + self.width + 1, self.y, self.z – 1,<br/>                     37)<br/>        mc.setBlocks(self.x + self.width + 1, self.y, self.z - 1,<br/>                     self.x + self.width + 1, self.y, self.z + self.depth + 1,<br/>                     37)<br/>        mc.setBlocks(self.x - 1, self.y, self.z + self.depth + 1,<br/>                     self.x + self.width + 1, self.y, self.z + self.depth = 1,<br/>                     37)<br/><br/><span class="red"># Create an instance of the FancyBuilding class</span><br/><span class="red"># Call the build() and upgrade() methods</span></pre>
<p class="examplet"><a id="ch12ex5"/><em>Listing 12-5: A method for the</em> <code><span class="codeitalic">FancyBuilding</code></span> <em>class that adds carpet and flowers to the building</em></p>
<p class="indent">After you’ve created the class and added the new method, create an instance of the <code>FancyBuilding</code> class and call it <code>ghostHotel</code>. Build the ghost hotel using the <code>build()</code> method, and then add the extra bits using the <code>upgrade()</code> method.</p>
<p class="indent"><a href="ch12.html#ch12fig6">Figure 12-6</a> shows my fancy ghost hotel.</p>
<div class="image"><a id="page_277"/><img src="graphics/f12-06.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig6"/><em>Figure 12-6: Look at those flowers and that carpet!</em></p>
<div class="sidebar">
<p class="sidebart"><strong>BONUS OBJECTIVE: FANCY VILLAGE</strong></p>
<p class="noindent">In <a href="ch12.html#ch12lev2sec06">Mission #71</a>, you created a ghost village in which all the buildings looked about the same. It’s rare to see identical buildings in real towns. Change the ghost village program by creating several classes that inherit from the <code>Building</code> class. You could make a <code>Shop</code> class, a <code>Hospital</code> class, and a <code>Restaurant</code> class, for example. Then when you create the objects, you can choose which type of building to create by using the different classes.</p>
</div>
<h3 class="h3" id="ch12lev1sec08"><a id="page_278"/><strong><span class="blue">OVERRIDING METHODS AND ATTRIBUTES</span></strong></h3>
<p class="noindent">It’s possible for a subclass to redefine methods and attributes from its superclass. This is useful when you want to use the same name for a method but you want it to behave differently in the subclass.</p>
<p class="indent">In “<a href="ch12.html#ch12lev1sec07">Understanding Inheritance</a>” on <a href="ch12.html#page_273">page 273</a>, we created a <code>Bird</code> class and a <code>Penguin</code> class. The <code>Penguin</code> class inherited from <code>Bird</code> so it shared all its methods. But penguins can’t fly, and their birdcall is more of a quack sound than a chirp. So, we should change the <code>fly()</code> and <code>birdcall()</code> methods to reflect this. Open <em>birdClass.py</em> and add this code:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<pre>   <span class="ash">class Penguin(Bird):</span><br/>       <span class="ash">def swim(self):</span><br/>           <span class="ash">print("swimming")</span><br/><br/><span class="ent">➊</span>     <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br/>           <span class="rose">print</span>(<span class="green">"sort of a quack"</span>)<br/><br/><span class="ent">➋</span>     <span class="orange">def</span> <span class="blue1">fly</span>(self):<br/>           <span class="rose">print</span>(<span class="green">"Penguins cannot fly :("</span>)</pre>
<p class="indent">I’ve made two changes to the <code>Penguin</code> class. I’ve added a <code>birdcall()</code> <span class="ent">➊</span> method and a <code>fly()</code> <span class="ent">➋</span> method. Because both methods are spelled the same as they are in the <code>Bird</code> superclass, they will override the superclass’s methods.</p>
<p class="indent">Call the methods by adding this code to <em>birdClass.py</em>:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<pre>sarahThePenguin.fly()<br/>sarahThePenguin.birdcall()</pre>
<p class="indent">Now when you run the program, you’ll get this output:</p>
<pre><span class="blue1">Penguins cannot fly :(</span><br/><span class="blue1">sort of a quack</span></pre>
<p class="indent">Overriding a method from a superclass will change what the method does for the subclass but not the superclass. So penguins won’t be able to fly, but other birds that inherit from <code>Bird</code> will still be able to fly.</p>
<p class="indent">You can also overwrite the <code>__init__()</code> method in a subclass. This means that when the subclass object is created, it can have different attributes or behaviors than the superclass.</p>
<p class="indent">For example, let’s create a <code>Parrot</code> subclass of <code>Bird</code> in the same file. Parrots can be different colors, so let’s include an extra argument in the <code>__init__()</code> method for a <code>color</code> attribute:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<pre>   <span class="orange">class</span> <span class="blue1">Parrot</span>(Bird):<br/><span class="ent">➊</span>     <span class="orange">def</span> <span class="blue1">__init__</span>(self, name, wingspan, color):<br/>           self.name = name<br/>           self.wingspan = wingspan<br/>           self.color = color</pre>
<p class="indent"><a id="page_279"/>I’ve included a new <code>__init__()</code> method for the <code>Parrot</code> class that has an extra argument, <code>color</code> <span class="ent">➊</span>, when compared to the original <code>Bird</code> class.</p>
<p class="indent">Now when we create a new <code>Parrot</code> object, we can access the <code>color</code> attribute. We can also access the <code>birdcall()</code> and <code>fly()</code> methods because they were inherited from the <code>Bird</code> superclass:</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<pre>freddieTheParrot = Parrot(<span class="green">"Freddie"</span>, 12, <span class="green">"blue"</span>)<br/><span class="rose">print</span>(freddieTheParrot.color)<br/>freddieTheParrot.fly()<br/>freddieTheParrot.birdcall()</pre>
<p class="indent">This code will output the following:</p>
<pre><span class="blue1">blue</span><br/><span class="blue1">flap</span><br/><span class="blue1">chirp</span></pre>
<p class="indent">Remember that you can overwrite any method that a subclass inherits from a superclass; you can even overwrite the <code>__init__()</code> method. This gives you a lot of control over objects and their many attributes and methods.</p>
<p class="indent">After all the changes we’ve made to <em>birdClass.py</em>, the final program looks like the following. It’s also available in the book’s resources at <em><a href="https://www.nostarch.com/pythonwithminecraft/">https://www.nostarch.com/pythonwithminecraft/</a></em>.</p>
<p class="sidenote"><span class="blue"><em>birdClass.py</em></span></p>
<pre><span class="orange">class</span> <span class="blue1">Bird</span>(<span class="rose">object</span>):<br/>    <span class="orange">def</span> <span class="blue1">__init__</span>(self, name, wingspan):<br/>        self.name = name<br/>        self.wingspan = wingspan<br/><br/>    <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"chirp"</span>)<br/><br/>    <span class="orange">def</span> <span class="blue1">fly</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"flap"</span>)<br/><br/><br/><span class="orange">class</span> <span class="blue1">Penguin</span>(Bird):<br/>    <span class="orange">def</span> <span class="blue1">swim</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"swimming"</span>)<br/><br/>    <span class="orange">def</span> <span class="blue1">birdcall</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"sort of a quack"</span>)<br/><br/>    <span class="orange">def</span> <span class="blue1">fly</span>(self):<br/>        <span class="rose">print</span>(<span class="green">"Penguins cannot fly :("</span>)<br/><br/><span class="orange">class</span> <span class="blue1">Parrot</span>(Bird):<br/>    <span class="orange">def</span> <span class="blue1">__init__</span>(self, name, wingspan, color):<br/>        self.name = name<br/>        self.wingspan = wingspan<br/>        self.color = color<br/><br/>gardenBird = Bird(<span class="green">"Geoffrey"</span>, 12)<br/>gardenBird.birdcall()<br/>gardenBird.fly()<br/><br/>sarahThePenguin = Penguin(<span class="green">"Sarah"</span>, 10)<br/>sarahThePenguin.swim()<br/>sarahThePenguin.fly()<br/>sarahThePenguin.birdcall()<br/><br/>freddieTheParrot = Parrot(<span class="green">"Freddie"</span>, 12, <span class="green">"blue"</span>)<br/><span class="rose">print</span>(freddieTheParrot.color)<br/>freddieTheParrot.fly()<br/>freddieTheParrot.birdcall()</pre>
<p class="indent"><a id="page_280"/>You’ll try overriding methods and attributes in the next mission.</p>
<h4 class="h4a" id="ch12lev2sec10"><strong>MISSION #73: GHOST TREE</strong></h4>
<p class="noindent">You’ve created several forms of ghost buildings. Let’s take it to the next level and create a ghost tree. That’s an amazing idea, but how can we do it? The <code>Building</code> class is for buildings, which have walls and ceilings—trees don’t have walls or ceilings. Worry not! You can work around this by modifying your ghost <code>Building</code> class.</p>
<p class="indent">Like the ghost buildings, the ghost tree will appear and disappear using the <code>build()</code> and <code>clear()</code> methods. But the methods need to work differently because trees look different from houses. So, you need to create a class that inherits from the <code>Building</code> class and then override the <code>build()</code> and <code>clear()</code> methods.</p>
<p class="indent">To get you started, I’ve grabbed the function that creates a tree from the <em>forest.py</em> file (<a href="ch08.html#page_149">page 149</a>) and put it in <a href="ch12.html#ch12ex6">Listing 12-6</a>. Copy it into a new file called <em>ghostTree.py</em> in the <em>classes</em> folder.</p>
<p class="sidenote"><span class="blue"><em>ghostTree.py</em></span></p>
<pre>   <span class="orange">from</span> mcpi.minecraft <span class="orange">import</span> Minecraft<br/>   mc = Minecraft.create()<br/><br/>   <span class="red"># Paste the ghostHouse.py program here</span><br/>   <span class="red"># Create a Tree class here</span><br/><br/><span class="ent">➊</span> <span class="orange">def</span> <span class="blue1">growTree</span>(x, y, z):<br/>       <span class="green">""" Creates a tree at the coordinates given """</span><br/>       wood = 17<br/>       leaves = 18<br/><br/>       <span class="red"># Trunk</span><br/>       mc.setBlocks(x, y, z, x, y + 5, z, wood)<br/><br/>       <span class="red"># Leaves</span><br/>       mc.setBlocks(x - 2, y + 6, z - 2, x + 2, y + 6, z + 2, leaves)<br/>       mc.setBlocks(x - 1, y + 7, z - 1, x + 1, y + 7, z + 1, leaves)<br/><br/>   <span class="red"># Create build() and clear() methods for the Tree class here</span></pre>
<p class="examplet"><a id="ch12ex6"/><em>Listing 12-6: A function to create a tree</em></p>
<p class="indent"><a id="page_281"/>To finish the program, copy and paste the code for the <code>Building</code> class from <em>ghostHouse.py</em> into the new file. Then create a new class called <code>Tree</code> that inherits from the <code>Building</code> class. Inside the <code>Tree</code> class, add a <code>build()</code> method and a <code>clear()</code> method to override the methods from the <code>Building</code> class and build a tree instead of a house. Make sure you include the <code>self</code> argument in front of the attributes in the final <code>growTree()</code> method <span class="ent">➊</span>.</p>
<p class="indent">After you’ve created the program, make a <code>Tree</code> object called <code>ghostTree</code>. Call the <code>build()</code> method to make the tree appear, wait a bit, and then make it vanish using <code>clear()</code>.</p>
<p class="indent"><a href="ch12.html#ch12fig7">Figure 12-7</a> shows the result of my program.</p>
<div class="image"><img src="graphics/f12-07.jpg" alt="image"/></div>
<p class="figcap"><a id="ch12fig7"/><em>Figure 12-7: That’s a spooky tree!</em></p>
<div class="sidebar">
<p class="sidebart"><a id="page_282"/><strong>BONUS OBJECTIVE: GHOST FOREST</strong></p>
<p class="noindent">Modify the code in <em>ghostTree.py</em> to build a ghost forest. What kinds of treasures do you think you could find in a ghost forest?</p>
</div>
<h3 class="h3" id="ch12lev1sec09"><strong><span class="blue">WHAT YOU LEARNED</span></strong></h3>
<p class="noindent">You just learned the basics of one of the most important concepts in programming today: object-oriented programming! You learned how to write a class and create objects, and you learned how to use inheritance to customize classes and object behavior. You’ll be able to apply this very useful skill not only in Minecraft but also in any kind of programming adventure that you choose to go on to next!</p>
</body></html>