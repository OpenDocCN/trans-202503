- en: 'Chapter 8. Timers and Animation: What Would Disney Do?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 定时器与动画：迪士尼会怎么做？
- en: One way that I learned to program in my teens was by programming short games
    and animations, and then changing the code to do something new. I was amazed that
    I could immediately see my code make graphics appear on the screen, and I think
    you’ll enjoy it as much as I did.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我在青少年时期学习编程的一种方式是编写简短的游戏和动画，然后修改代码让它做些新事情。我很惊讶自己可以立即看到代码让图形出现在屏幕上，我相信你也会和我一样喜欢这种体验。
- en: Games and animations have several things in common. First, they’re fun! Second,
    they both involve drawing graphics on the screen and changing those graphics over
    time to give the illusion of motion. We’ve been able to draw graphics from the
    beginning of this book, but the Turtle library is too slow to use for a lot of
    animation or moving objects. In this chapter, we’re going to install and work
    with a new module, *Pygame*, that lets us draw, animate, and even create arcade-style
    games using the skills you’ve picked up so far.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏和动画有几个共同点。首先，它们很有趣！其次，它们都涉及在屏幕上绘制图形，并随着时间的推移改变这些图形，从而产生运动的错觉。从本书开始，我们就能够绘制图形，但
    Turtle 库对于大量的动画或移动对象来说太慢了。在这一章，我们将安装并使用一个新的模块，*Pygame*，它让我们能够绘制、动画化，甚至使用你到目前为止学到的技能创建街机风格的游戏。
- en: Getting All GUI with Pygame
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pygame 获取所有图形界面
- en: A *graphical user interface* (*GUI*, sometimes pronounced “gooey”) includes
    all the buttons, icons, menus, and windows that you see on your computer screen;
    it’s how you interact with a computer. When you drag and drop a file or click
    an icon to open a program, you’re enjoying a GUI. In games, when you press keys,
    move your mouse, or click, the only reason you can expect anything to happen (like
    running, jumping, rotating your view, and so on) is because a programmer set up
    the GUI.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*图形用户界面*（*GUI*，有时读作“gooey”）包括你在计算机屏幕上看到的所有按钮、图标、菜单和窗口；它是你与计算机交互的方式。当你拖放一个文件或点击一个图标打开程序时，你正在享受
    GUI。在游戏中，当你按键、移动鼠标或点击时，你之所以能够期待某些事情发生（例如跑步、跳跃、旋转视角等），是因为程序员设置了 GUI。'
- en: Like the Turtle library, Pygame is very visual, perfect for GUIs for games,
    animations, and more. It’s portable to just about every operating system, from
    Windows to Mac to Linux and beyond, so the games and programs you create in Pygame
    can run on pretty much any computer. [Figure 8-1](ch08.html#pygame_is_freecomma_and_so_are_the_tutor
    "Figure 8-1. Pygame is free, and so are the tutorials and sample games on its
    website.") shows the Pygame website, where you’ll go to download Pygame.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 和 Turtle 库一样，Pygame 非常可视化，非常适合用于游戏、动画等的图形用户界面（GUI）。它几乎可以移植到所有操作系统，从 Windows
    到 Mac，再到 Linux 等，因此你在 Pygame 中创建的游戏和程序几乎可以在任何计算机上运行。[图 8-1](ch08.html#pygame_is_freecomma_and_so_are_the_tutor
    "图 8-1. Pygame 是免费的，其网站上的教程和示例游戏也都是免费的。") 展示了 Pygame 网站，你可以在这里下载 Pygame。
- en: '![Pygame is free, and so are the tutorials and sample games on its website.](httpatomoreillycomsourcenostarchimages2188975.png.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![Pygame 是免费的，其网站上的教程和示例游戏也都是免费的。](httpatomoreillycomsourcenostarchimages2188975.png.jpg)'
- en: Figure 8-1. Pygame is free, and so are the tutorials and sample games on its
    website.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-1. Pygame 是免费的，其网站上的教程和示例游戏也都是免费的。
- en: To get started, install the `pygame` module by downloading the installer from
    the Downloads page at *[http://www.pygame.org/](http://www.pygame.org/)*. For
    Windows, you’ll probably want to download *pygame-1.9.1 .win32-py3.1.msi*, but
    see Appendix B for help if you have any trouble. For Mac and Linux, the installation
    is more involved; see Appendix B or go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    for step-by-step instructions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，首先通过从 *[http://www.pygame.org/](http://www.pygame.org/)* 下载安装程序来安装 `pygame`
    模块。对于 Windows，你可能需要下载 *pygame-1.9.1 .win32-py3.1.msi*，如果遇到问题，可以参考附录 B 获取帮助。对于
    Mac 和 Linux，安装过程更为复杂；请参见附录 B 或访问 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    获取逐步指导。
- en: 'You can check that Pygame installed with no errors by entering the following
    into the Python shell:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 Python shell 中输入以下内容来检查 Pygame 是否安装没有错误：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you get a regular `>>>` prompt in response, you know that Python was able
    to find the `pygame` module without error and the Pygame library is ready to use.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到一个常规的 `>>>` 提示符，说明 Python 能够正确找到 `pygame` 模块并没有出错，Pygame 库已经准备好可以使用了。
- en: Drawing a Dot with Pygame
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Pygame 绘制一个点
- en: Once you have Pygame installed, you can run a short sample program to draw a
    dot on the screen, like the one in [Figure 8-2](ch08.html#showdotdotpy_program_at_work
    "Figure 8-2. The ShowDot.py program at work").
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了 Pygame，你可以运行一个简短的示例程序，在屏幕上绘制一个点，就像[图 8-2](ch08.html#showdotdotpy_program_at_work
    "图 8-2. ShowDot.py 程序的运行")中的那样。
- en: '![The ShowDot.py program at work](httpatomoreillycomsourcenostarchimages2188977.png.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![ShowDot.py 程序的运行](httpatomoreillycomsourcenostarchimages2188977.png.jpg)'
- en: Figure 8-2. The *ShowDot.py* program at work
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2. *ShowDot.py* 程序的运行
- en: 'Type the following in a new IDLE window or download it from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的 IDLE 窗口中输入以下代码，或者从 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    下载它：
- en: ShowDot.py
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ShowDot.py
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s step through this program line by line. First, we import the `pygame`
    module to gain access to its features. At ➊, we [*initialize*](apd.html#gloss01_027)
    Pygame, or set it up for use. The command `pygame.init()` will need to be called
    every time you want to use Pygame, and it always comes after the `import pygame`
    command and before any other Pygame functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析这个程序。首先，我们导入 `pygame` 模块以访问其功能。在 ➊ 处，我们[*初始化*](apd.html#gloss01_027)
    Pygame，或者说为其设置使用环境。每次想使用 Pygame 时，都需要调用 `pygame.init()`，并且它总是紧跟在 `import pygame`
    命令之后，位于其他任何 Pygame 函数之前。
- en: At ➋, `pygame.display.set_mode([800,600])` creates a display window 800 pixels
    wide by 600 pixels tall. We store it in a variable called `screen`. In Pygame,
    windows and graphics are called *surfaces*, and the display surface `screen` is
    the main window where all of our other graphics will be drawn.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋ 处，`pygame.display.set_mode([800,600])` 创建了一个宽 800 像素、高 600 像素的显示窗口。我们将其存储在名为
    `screen` 的变量中。在 Pygame 中，窗口和图形被称为 *表面*，而显示表面 `screen` 是我们所有其他图形将被绘制的主窗口。
- en: 'At ➌, you might recognize our looping variable, `keep_going`: we used this
    in our *HighCard.py* and *FiveDice.py* game loops in [Chapter 6](ch06.html "Chapter 6. Random
    Fun and Games: Go Ahead, Take a Chance!") as a Boolean flag to tell our program
    to keep playing. Here in our Pygame example, we use a game loop to continue drawing
    the graphics screen until the user closes the window.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处，你可能会认出我们的循环变量 `keep_going`：我们在[第 6 章](ch06.html "第 6 章. 随机娱乐和游戏：勇敢尝试！")中的
    *HighCard.py* 和 *FiveDice.py* 游戏循环中也使用了它，作为一个布尔标志来告诉程序继续游戏。在这个 Pygame 示例中，我们使用一个游戏循环来持续绘制图形窗口，直到用户关闭窗口。
- en: At ➍, we set up two variables, `GREEN` and `radius`, for use in drawing our
    circle. The `GREEN` variable is set to the RGB triplet value `(0,255,0)`, a bright
    green. ([*RGB*](apd.html#gloss01_043), or *Red Green Blue*, is one of many ways
    to specify a color. To pick a color, you choose three numbers, each between 0
    and 255\. The first number determines how much red is in your color, the second
    number is the amount of green, and the third is blue. We picked 255 as our value
    for green and 0 for red and blue, so our RGB color is all green and no red or
    blue.) Our variable `GREEN` is a constant. We sometimes write [*constants*](apd.html#gloss01_015)—variables
    we don’t intend to change—in all caps. Since the color should stay the same throughout
    our program, we’ve used all caps for `GREEN`. We set the `radius` variable equal
    to 50 pixels, for a circle 100 pixels in diameter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➍ 处，我们设置了两个变量，`GREEN` 和 `radius`，用于绘制我们的圆形。`GREEN` 变量被设置为 RGB 三元组值 `(0,255,0)`，一种明亮的绿色。（[*RGB*](apd.html#gloss01_043)，即
    *红绿蓝*，是指定颜色的多种方式之一。选择颜色时，需选择三个数字，每个数字的范围是 0 到 255。第一个数字决定颜色中的红色成分，第二个是绿色成分，第三个是蓝色成分。我们将绿色的值设为
    255，红色和蓝色的值设为 0，因此我们的 RGB 颜色是全绿色，且没有红色或蓝色。）我们的 `GREEN` 变量是一个常量。我们有时会将[*常量*](apd.html#gloss01_015)—即我们不打算改变的变量—写成全大写字母。由于该颜色在整个程序中应保持不变，因此我们为
    `GREEN` 使用了全大写字母。我们将 `radius` 变量设置为 50 像素，用于绘制直径为 100 像素的圆形。
- en: The `while` loop at ➎ is our game loop, and it will keep running the Pygame
    window until the user chooses to exit. The `for` loop at ➏ is where we handle
    all the interactive events that the user can trigger in our program. In this simple
    example, the only event we’re checking for is whether the user clicked the red
    X to close the window and exit the program ➐. If so, `keep_going` gets set to
    `False` and our game loop ends.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➎ 处的 `while` 循环是我们的游戏循环，它将不断运行 Pygame 窗口，直到用户选择退出。➏ 处的 `for` 循环是我们处理用户在程序中触发的所有交互事件的地方。在这个简单的示例中，我们唯一需要检查的事件是用户是否点击了红色的
    X 来关闭窗口并退出程序 ➐。如果是这样，`keep_going` 被设置为 `False`，我们的游戏循环结束。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188979.png.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2188979.png.jpg)'
- en: 'At ➑, we draw a green circle with a radius of 50 on the `screen` window at
    position `(100,100)`: right 100 and down 100 pixels from the upper-left corner
    of the window (see [What’s New in Pygame](ch08.html#whatapostrophes_new_in_pygame
    "What’s New in Pygame") for more information on how Pygame’s coordinate system
    is different from Turtle’s). We’re using `pygame.draw`, a Pygame module for drawing
    shapes like circles, rectangles, and line segments. We pass four arguments to
    the `pygame.draw.circle()` function: the surface on which we want to draw the
    circle (`screen`), the color for our circle (`GREEN`), the coordinates of its
    center point, and the radius. The `update()` function at ➒ tells Pygame to refresh
    the screen with the drawing changes.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在➑处，我们在`screen`窗口中的位置(100,100)绘制一个半径为50的绿色圆圈：从窗口的左上角向右移动100像素，向下移动100像素（有关Pygame坐标系统如何不同于海龟图形的更多信息，请参见[What’s
    New in Pygame](ch08.html#whatapostrophes_new_in_pygame)）。我们使用`pygame.draw`，这是Pygame的一个模块，用于绘制圆形、矩形和线段等形状。我们将四个参数传递给`pygame.draw.circle()`函数：我们要在其上绘制圆圈的表面（`screen`），圆圈的颜色（`GREEN`），圆心的坐标和半径。位于➒的`update()`函数告诉Pygame刷新屏幕并应用绘图的变化。
- en: Finally, when the user exits the game loop, the `pygame.quit()` command at ➓
    clears the `pygame` module (it undoes all the setup from ➊) and closes the `screen`
    window so that the program can exit normally.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户退出游戏循环时，位于➓的`pygame.quit()`命令会清除`pygame`模块（它撤销了➊中的所有设置），并关闭`screen`窗口，使得程序能够正常退出。
- en: You should see an image like the one in [Figure 8-2](ch08.html#showdotdotpy_program_at_work
    "Figure 8-2. The ShowDot.py program at work") when you run *ShowDot.py*. Take
    some time to play around with this dot program—create a different RGB color triplet,
    draw the dot in a different location on the screen, or draw a second dot. You’ll
    begin to see the power and ease of drawing graphics with Pygame, and you’ll have
    fun along the way.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行*ShowDot.py*时，你应该看到一个像[图8-2](ch08.html#showdotdotpy_program_at_work "图8-2.
    ShowDot.py程序运行效果")中的图像。花些时间玩一下这个点程序——创建一个不同的RGB颜色三元组，改变点在屏幕上的位置，或者画第二个点。你将开始看到使用Pygame绘制图形的强大功能和简便性，同时也会玩得很开心。
- en: This first program contains the foundation that we’ll build on to create more
    complex graphics, animation, and, eventually, games.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个程序包含了我们将要基于其构建的基础，之后我们可以创建更复杂的图形、动画，最终制作游戏。
- en: What’s New in Pygame
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pygame中的新变化
- en: 'Before we dive deeper into the exciting world of Pygame, it’s worth noting
    some important differences between Pygame and our old friend turtle graphics:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨Pygame的激动人心的世界之前，值得注意的是Pygame和我们之前熟悉的海龟图形之间一些重要的区别：
- en: We have a new coordinate system, as shown in [Figure 8-3](ch08.html#pygame_uses_a_window-oriented_coordinate
    "Figure 8-3. Pygame uses a window-oriented coordinate system."). Back in turtle
    graphics, the origin was at the center of the screen, and *y* got larger as we
    went up the screen. Pygame uses a more common window-oriented coordinate system
    (we see this in many other GUI programming languages, including Java, C++, and
    more). The *upper-left corner* of a window in Pygame is the origin, (0, 0). The
    x-coordinate values still increase as you move to the right (but there are no
    negative x-coordinate values, as they would be off the screen to the left); y-coordinate
    values increase as you move down (and negative y-coordinate values would be off
    the top of the window).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有了一个新的坐标系统，如[图8-3](ch08.html#pygame_uses_a_window-oriented_coordinate "图8-3.
    Pygame使用窗口坐标系统")所示。在海龟图形中，原点位于屏幕的中心，*y*值随着向上移动而增大。Pygame使用的是更常见的窗口坐标系统（在许多其他GUI编程语言中也会看到这种系统，包括Java、C++等）。在Pygame中，窗口的*左上角*是原点(0,
    0)。x坐标值仍然随着向右移动而增大（但没有负的x坐标值，因为它们会在屏幕左侧消失）；y坐标值随着向下移动而增大（负的y坐标值会消失在窗口的顶部）。
- en: '![Pygame uses a window-oriented coordinate system.](httpatomoreillycomsourcenostarchimages2188981.png.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Pygame使用窗口坐标系统。](httpatomoreillycomsourcenostarchimages2188981.png.jpg)'
- en: Figure 8-3. Pygame uses a window-oriented coordinate system.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8-3. Pygame使用窗口坐标系统。
- en: The game loop is always used in Pygame. In our earlier programs, we used a loop
    only if we wanted to keep playing or go back and do something again, but Pygame
    requires the game loop to keep updating the screen and handling events (even if
    the only event we handle is closing the window).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏循环在Pygame中总是被使用。在我们之前的程序中，只有在需要继续播放或者返回重新做某件事时才使用循环，但Pygame要求使用游戏循环来持续更新屏幕并处理事件（即使我们处理的唯一事件只是关闭窗口）。
- en: We handle events in Pygame by calling `pygame.event.get()` to fetch a list of
    events that the user has performed. These events could be mouse clicks, key presses,
    or even window events like the user closing the window. We use a `for` loop to
    handle everything in this list of events from `pygame.event.get()`. In our turtle
    programs, we used callback functions to handle events. In Pygame, we can still
    create functions and call them in our event handler code, but we can process events
    just using `if` statements for those events that we care to listen for.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过调用 `pygame.event.get()` 来获取用户执行的事件列表，从而处理 Pygame 中的事件。这些事件可能是鼠标点击、按键、甚至是窗口事件，例如用户关闭窗口。我们使用
    `for` 循环来处理来自 `pygame.event.get()` 的所有事件。在我们的海龟程序中，我们使用回调函数来处理事件。在 Pygame 中，我们仍然可以创建函数并在事件处理代码中调用它们，但我们可以仅通过
    `if` 语句来处理我们关心的事件。
- en: These differences make Pygame a new way of solving problems, and that’s what
    we’re always looking for! The more tools we have, the more problems we can solve.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异使得 Pygame 成为解决问题的新方法，这正是我们一直在寻找的！工具越多，我们能解决的问题就越多。
- en: The Parts of a Game
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏的组成部分
- en: In this section, we’ll change our *ShowDot.py* program to display a smiley face
    image instead of a green circle, as shown in [Figure 8-4](ch08.html#showpicdotpy_draws_the_image_crazysmiled
    "Figure 8-4. ShowPic.py draws the image CrazySmile.bmp on the screen.").
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将修改 *ShowDot.py* 程序，将其显示笑脸图片，而不是绿色圆形，如 [图 8-4](ch08.html#showpicdotpy_draws_the_image_crazysmiled
    "图 8-4. ShowPic.py 在屏幕上绘制了图片 CrazySmile.bmp。") 所示。
- en: '![ShowPic.py draws the image CrazySmile.bmp on the screen.](httpatomoreillycomsourcenostarchimages2188983.png.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![ShowPic.py 在屏幕上绘制了图片 CrazySmile.bmp。](httpatomoreillycomsourcenostarchimages2188983.png.jpg)'
- en: Figure 8-4. *ShowPic.py* draws the image *CrazySmile.bmp* on the screen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-4. *ShowPic.py* 在屏幕上绘制了图片 *CrazySmile.bmp*。
- en: As we build our *ShowPic.py* program, we’ll learn about the three main parts
    of a game or animation in Pygame. First, there’s the setup, where we import modules
    we need, create our screen, and initialize some important variables. Then comes
    the game loop, which handles events, draws graphics, and updates the display.
    This game loop is a `while` loop that keeps running as long as the user doesn’t
    quit the game. Finally, we need a way to end the program when the user quits the
    game.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的 *ShowPic.py* 程序时，我们将了解 Pygame 中游戏或动画的三个主要部分。首先是设置阶段，我们在这里导入所需的模块，创建屏幕并初始化一些重要的变量。接着是游戏循环，它处理事件、绘制图形并更新显示。这个游戏循环是一个
    `while` 循环，只要用户没有退出游戏，它就会一直运行。最后，我们需要一种方法来在用户退出游戏时结束程序。
- en: Setting Up
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: First, download the smiley face image and save it in the same folder as your
    Python programs. Go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    to find the source code downloads and save the image *CrazySmile.bmp* to the folder
    where you’ve been saving your *.py* files. It doesn’t really matter where you
    keep your *.py* files; just make sure to save the BMP (short for *bitmap*, a common
    image file format) image file to the same location.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载笑脸图片，并将其保存在与 Python 程序相同的文件夹中。访问 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    下载源代码，并将图片 *CrazySmile.bmp* 保存到你保存 *.py* 文件的文件夹中。你保存 *.py* 文件的位置并不重要，只需确保将 BMP（即
    *位图*，一种常见的图片文件格式）图片文件保存到相同的位置即可。
- en: 'Next, let’s take care of the setup:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理设置：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As always, we import the `pygame` module and then initialize using the `pygame.init()`
    function. Next, we set up our `screen` to be a new Pygame window 800×600 pixels
    in size. We create our Boolean flag `keep_going` to control our game loop and
    set it equal to `True`. Finally, we do something new: at ➊, we use `pygame.image.load()`,
    which loads an image from a file. We create a variable for our image file and
    load *CrazySmile.bmp*, which we’ll refer to as `pic` in our program.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我们导入 `pygame` 模块，然后使用 `pygame.init()` 函数进行初始化。接下来，我们设置 `screen` 为一个新的 Pygame
    窗口，大小为 800×600 像素。我们创建布尔标志 `keep_going` 来控制游戏循环，并将其设为 `True`。最后，我们做了一些新尝试：在 ➊
    处，我们使用 `pygame.image.load()`，它从文件中加载一张图片。我们为图片文件创建一个变量，并加载 *CrazySmile.bmp*，在程序中我们将其称为
    `pic`。
- en: Creating a Game Loop
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建游戏循环
- en: 'At this point, we haven’t drawn anything, but we’ve set up Pygame and loaded
    an image. The game loop is where we’ll actually display the smiley face image
    on the screen. It’s also where we’ll handle events from the user. Let’s start
    by handling one important event: the user choosing to quit the game.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们还没有绘制任何东西，但我们已经设置了 Pygame 并加载了一张图片。游戏循环是我们实际在屏幕上显示笑脸图片的地方。它也是我们处理用户事件的地方。我们首先处理一个重要的事件：用户选择退出游戏。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our game loop will keep running as long as `keep_going` is `True`. Inside the
    loop, we immediately check for events from the user. In advanced games, the user
    can trigger a lot of events at the same time, like pressing the down arrow on
    the keyboard while moving the mouse left and scrolling the mouse wheel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏循环将持续运行，直到`keep_going`为`True`。在循环内，我们立即检查用户的事件。在高级游戏中，用户可能同时触发许多事件，比如按下键盘上的下箭头、同时移动鼠标向左，并滚动鼠标滚轮。
- en: In this simple program, the only event we’re listening for is whether the user
    clicked the close window button to quit the program. We check for this at ➊. If
    the user triggered the `pygame.QUIT` event by trying to close the window, we want
    to tell our game loop to exit. We do this by setting `keep_going` to `False`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的程序中，我们监听的唯一事件是用户是否点击了关闭窗口按钮来退出程序。我们在➊处进行检查。如果用户尝试关闭窗口并触发了`pygame.QUIT`事件，我们希望告诉游戏循环退出。我们通过将`keep_going`设置为`False`来实现这一点。
- en: 'We still need to draw our picture to the screen and update the drawing window
    to make sure everything appears on the screen, so we’ll add these two final lines
    to our game loop:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要将图像绘制到屏幕上并更新绘图窗口，以确保所有内容都能显示在屏幕上，因此我们将在游戏循环中添加这两行代码：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `blit()` method draws `pic`, the image that we’ve loaded from disk (our
    smiley face), onto our display surface, `screen`. We’ll use `blit()` when we want
    to copy pixels from one surface (like the image we loaded from disk) onto another
    (like the drawing window). Here, we need to use `blit()` because the `pygame.image.load()`
    function works differently than the `pygame.draw.circle()` function we used earlier
    to draw our green dot. All `pygame.draw` functions accept a surface as an argument,
    so by passing `screen` to `pygame.draw.circle()`, we were able to have `pygame.draw.circle()`
    draw to our display window. But `pygame.image.load()` doesn’t take a surface as
    an argument; instead, it automatically creates a new, separate surface for your
    image. The image won’t appear on the original drawing screen unless you use `blit()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`blit()`方法将`pic`（我们从磁盘加载的图像，笑脸）绘制到我们的显示表面`screen`上。当我们希望将一个表面（比如从磁盘加载的图像）上的像素复制到另一个表面（如绘图窗口）时，我们会使用`blit()`。在这里，我们需要使用`blit()`，因为`pygame.image.load()`函数的工作方式不同于我们之前用来绘制绿色圆点的`pygame.draw.circle()`函数。所有`pygame.draw`函数都接受一个表面作为参数，所以通过将`screen`传递给`pygame.draw.circle()`，我们能够让`pygame.draw.circle()`绘制到我们的显示窗口上。但`pygame.image.load()`不接受表面作为参数；相反，它会自动为你的图像创建一个新的、独立的表面。除非你使用`blit()`，否则图像不会出现在原始的绘图屏幕上。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188985.png.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![无说明的图片](httpatomoreillycomsourcenostarchimages2188985.png.jpg)'
- en: In this case, we’ve told `blit()` that we want to draw `pic` at the location
    `(100,100)`, or right 100 pixels and down 100 pixels from the upper-left corner
    of the screen (in Pygame’s coordinate system, the origin is the upper-left corner;
    see [Figure 8-3](ch08.html#pygame_uses_a_window-oriented_coordinate "Figure 8-3. Pygame
    uses a window-oriented coordinate system.")).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们告诉`blit()`，我们希望将`pic`绘制在位置`(100,100)`，即从屏幕左上角向右偏移100像素、向下偏移100像素（在Pygame的坐标系统中，原点是屏幕的左上角；请参见[图8-3](ch08.html#pygame_uses_a_window-oriented_coordinate
    "图8-3. Pygame使用面向窗口的坐标系统.")）。
- en: The final line of our game loop is the call to `pygame.display.update()`. This
    command tells Pygame to show the drawing window with all the changes that have
    been made during this pass through the loop. That includes our smiley face. When
    `update()` runs, the window will be updated to show all the changes to our `screen`
    surface.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏循环的最后一行是调用`pygame.display.update()`。该命令告诉Pygame显示绘图窗口，并展示这一轮循环中所做的所有更改，包括我们的笑脸。当`update()`运行时，窗口将更新，显示所有`screen`表面上的更改。
- en: So far, we’ve taken care of our setup code, and we have a game loop with an
    event handler that listens for the user hitting the close window button. If the
    user clicks the close window button, the program updates the display and exits
    the loop. Next, we’ll take care of ending the program.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了设置代码，并且有一个带有事件处理器的游戏循环，监听用户点击关闭窗口按钮的事件。如果用户点击关闭窗口按钮，程序将更新显示并退出循环。接下来，我们将处理程序退出的部分。
- en: Exiting the Program
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退出程序
- en: 'The last section of our code will exit the program once the user has chosen
    to quit the game loop:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的最后一部分将在用户选择退出游戏循环后退出程序：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you leave this line out of your programs, the display window will stay open
    even after the user tries to close it. Calling `pygame.quit()` closes the display
    window and frees up the memory that was storing our image, `pic`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序中没有这一行，显示窗口在用户尝试关闭时会保持打开状态。调用`pygame.quit()`可以关闭显示窗口，并释放存储图像`pic`的内存。
- en: Putting It All Together
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汇总
- en: 'Put it all together, and you’ll see our *CrazySmile.bmp* image file— as long
    as you’ve saved the image in the same directory as your *ShowPic.py* program file.
    Here’s the full listing:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有代码组合在一起，你将看到我们的*CrazySmile.bmp*图像文件——前提是你已将图像保存在与*ShowPic.py*程序文件相同的目录下。以下是完整的代码：
- en: ShowPic.py
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ShowPic.py
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you click the close window button, the display window should close.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击关闭窗口按钮时，显示窗口应该会关闭。
- en: 'This code has all the basic components we’ll build on to make our programs
    even more interactive. In the rest of this chapter and in [Chapter 9](ch09.html
    "Chapter 9. User Interaction: Get into the Game"), we’ll add code to our game
    loop to respond to different events (for example, making images on the screen
    move when the user moves the mouse). Now let’s see how to create a program that
    draws an animated bouncing ball!'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了我们将用来构建更加互动的程序的所有基本组件。在本章的其余部分以及在[第9章](ch09.html "第9章 用户互动：进入游戏")中，我们将向游戏循环中添加代码，以响应不同的事件（例如，当用户移动鼠标时，屏幕上的图像也随之移动）。现在，让我们看看如何创建一个绘制动画跳跃球的程序！
- en: 'Timing It Just Right: Move and Bounce'
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恰到好处的时机：移动和弹跳
- en: 'We already have the skills needed to create animation, or the illusion of motion,
    by making one small change to our *ShowPic.py* app. Instead of showing the smiley
    face image at a fixed location every time through the game loop, what if we change
    that location slightly every frame? By [*frame*](apd.html#gloss01_022), I mean
    each pass through the game loop. The term comes from one way people make animations:
    they draw thousands of individual pictures, making each picture slightly different
    from the one before it. One picture is considered one frame. The animators then
    put all the pictures together on a strip of film and run the film through a projector.
    When the pictures are shown one after another very quickly, it looks like the
    characters in the pictures are moving.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经具备了创造动画的技能，或者说是运动的幻觉，只需对我们的*ShowPic.py*程序做一个小改动。我们不再每次都将笑脸图像显示在固定的位置，而是每帧稍微改变一下位置。这里的[*帧*](apd.html#gloss01_022)是指游戏循环中的每次循环。这个术语来源于动画制作的方式：他们绘制数千张单独的图片，使每张图片与前一张有所不同。一张图片被视为一帧。然后，动画师将所有的图片拼接在一条胶片上，并通过放映机播放。当这些图片以非常快的速度依次显示时，就看起来像是画中的人物在运动。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188987.png.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2188987.png.jpg)'
- en: With a computer, we can create the same effect by drawing a picture on the screen,
    clearing the screen, moving the picture slightly, and then drawing it again. The
    effect will look a bit like [Figure 8-5](ch08.html#in_this_first_attempt_at_animationcomma
    "Figure 8-5. In this first attempt at animation, our smiley image will streak
    off the screen.").
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算机，我们可以通过在屏幕上绘制一张图片、清空屏幕、稍微移动图片，然后重新绘制它，来创造出相同的效果。这个效果看起来有点像[图 8-5](ch08.html#in_this_first_attempt_at_animationcomma
    "图 8-5。第一次尝试动画时，我们的笑脸图像会从屏幕上滑出。")。
- en: '![In this first attempt at animation, our smiley image will streak off the
    screen.](httpatomoreillycomsourcenostarchimages2188989.png.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![在第一次尝试动画时，我们的笑脸图像会从屏幕上滑出。](httpatomoreillycomsourcenostarchimages2188989.png.jpg)'
- en: Figure 8-5. In this first attempt at animation, our smiley image will streak
    off the screen.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-5。在第一次尝试动画时，我们的笑脸图像会从屏幕上滑出。
- en: We still call each drawing a *frame*, and the speed of our animation is how
    many [*frames per second (fps)*](apd.html#gloss01_023) we draw. A video game might
    run 60–120 frames per second, like high-definition television. Older, standard-definition
    TVs in the United States run at 30 fps, and many film projectors run at 24 fps
    (newer high-definition digital projectors can run at 60 fps or higher).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然称每一帧绘制为一个*帧*，动画的速度则是我们每秒绘制的[*帧数 (fps)*](apd.html#gloss01_023)。一款视频游戏可能会以每秒60到120帧的速度运行，就像高清电视一样。美国的老式标清电视运行在30
    fps，而许多电影放映机的帧率是24 fps（新型的高清数字放映机可以运行到60 fps或更高）。
- en: If you’ve ever made or seen a flip-book animation (in which you draw on the
    corners of pages in a notebook and then flip through them to create a mini-cartoon),
    you’ve seen that the illusion of motion can be created at many different frame
    rates. We’ll aim for a rate around 60 fps, fast enough to create smooth animations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾制作或见过翻书动画（即在笔记本的角落上绘画，然后翻动它们以创建迷你卡通），你就知道，可以通过不同的帧率创建运动的错觉。我们的目标是约60帧每秒，足够快以创建平滑的动画。
- en: Moving a Smiley
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动表情符号
- en: We can create simple motion in our `while` loop by drawing the smiley face image
    at different locations over time. In other words, in our game loop, we just need
    to update the (*x*, *y*) location of the picture and then draw it at that new
    location each time through the loop.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`while`循环中绘制表情符号图像在不同位置上来实现简单的运动。换句话说，在我们的游戏循环中，我们只需要更新图片的(*x*, *y*)位置，并且每次循环时在新的位置绘制它。
- en: 'We’ll add two variables to *ShowPic.py*: `picx` and `picy`, for the x- and
    y-coordinates of the image on the screen. We’ll add these at the end of the setup
    portion of our program and then save the new version of the program as *SmileyMove.py*
    (the final version is shown in [SmileyMove.py](ch08.html#smileymovedotpy "SmileyMove.py")).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向*ShowPic.py*中添加两个变量：`picx`和`picy`，分别表示图像在屏幕上的x和y坐标。我们将在程序的设置部分末尾添加这两个变量，然后将程序的新版本保存为*SmileyMove.py*（最终版本见[SmileyMove.py](ch08.html#smileymovedotpy
    "SmileyMove.py")）。
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The lines at* ➋ *and* ➌ *are an optional fix for a minor issue. If the* CrazySmile.bmp
    *image looks like it has square black corners on your screen, you can include
    these two lines to make sure those corners look transparent.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*第* ➋ *行和* ➌ *行是一个可选的修复，解决了一个小问题。如果* CrazySmile.bmp *图像在您的屏幕上看起来有黑色方形角落，您可以包含这两行代码以确保这些角落看起来是透明的。*'
- en: 'Notice that we’ve also changed our window screen to 600×600 pixels to make
    the window square at ➊. The game loop will begin the same way it did in *ShowPic.py*,
    but we’ll add code to change the `picx` and `picy` variables by 1 pixel every
    time the loop runs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们也将窗口屏幕的尺寸更改为600×600像素，使窗口在➊处变为正方形。游戏循环将以与*ShowPic.py*中相同的方式开始，但我们会添加代码，每次循环运行时将`picx`和`picy`变量的值增加1像素：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `+=` operator adds something to the variable on the left side (`picx` and
    `picy`), so with `+= 1`, we’ve told the computer we want to change the x- and
    y-coordinates of the picture, `(picx, picy)`, by 1 pixel every time through the
    loop.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`+=`运算符将某些值加到左侧的变量（`picx`和`picy`）上，所以通过`+= 1`，我们告诉计算机每次循环时将图片的x和y坐标`(picx,
    picy)`分别改变1像素。'
- en: 'Finally, we need to copy the image onto the screen at the new location, update
    the display, and tell our program what to do to exit:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将图像复制到新位置并显示，更新显示内容，并告诉我们的程序如何退出：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you run those lines, you’ll see our image take off! In fact, you’ll have
    to look fast because it will move right off the screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这些代码，你会看到我们的图像飞速移动！事实上，你得快点看，因为它会快速离开屏幕。
- en: Look back at [Figure 8-5](ch08.html#in_this_first_attempt_at_animationcomma
    "Figure 8-5. In this first attempt at animation, our smiley image will streak
    off the screen.") for a glimpse of the smiley image before it slides out of view.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请回顾[图8-5](ch08.html#in_this_first_attempt_at_animationcomma "Figure 8-5. 在这一动画初步尝试中，我们的表情符号图像将快速滑出屏幕。")，以了解表情符号图像在它滑出视野之前的样子。
- en: This first version may leave streaks of pixels on the display even when the
    smiley image has left the drawing window. We can make the animation cleaner by
    clearing the screen between each frame. The streaking lines we’re seeing behind
    our smiley are the upper-left pixels of the smiley image; every time we move down
    and over each frame to draw a new version of our image and update the display,
    we’re leaving behind a few stray pixels from the last picture.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本可能会在表情符号图像离开绘图窗口时，屏幕上仍留下像素痕迹。我们可以通过在每一帧之间清除屏幕来让动画看起来更干净。我们看到的表情符号背后留下的拖尾线是表情符号图像的左上角像素；每次我们在每一帧中向下和向右移动来绘制图像的一个新版本并更新显示时，我们都会留下上一张图像的一些散落像素。
- en: We can fix this by adding a `screen.fill()` command to our drawing loop. The
    `screen.fill()` command takes a color as an argument, so we need to tell it what
    color we’d like to use to fill the drawing screen. Let’s add a variable for `BLACK`
    (using all uppercase for `BLACK` to show that it’s a constant) and set it equal
    to black’s RGB color triplet, `(0,0,0)`. We’ll fill the screen surface with black
    pixels, effectively clearing it off, before we draw each new, moved copy of our
    animated image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在绘图循环中添加一个`screen.fill()`命令来解决这个问题。`screen.fill()`命令接受一个颜色作为参数，所以我们需要告诉它我们想要使用哪种颜色来填充绘图屏幕。我们为`BLACK`添加一个变量（使用全大写的`BLACK`表示它是一个常量），并将其设置为黑色的RGB色彩三元组`(0,0,0)`。在我们绘制每一帧新图像之前，先用黑色像素填充屏幕，从而有效地清除它。
- en: 'Add this line to your setup right after `picy = 0` to create the black background
    fill color:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`picy = 0`之后立即在设置中添加这一行，以创建黑色背景填充颜色：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And add this line right before the `screen.blit()` that draws our `pic` image
    on the screen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在绘制我们的`pic`图像到屏幕上的`screen.blit()`语句前添加这一行：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our smiley face still speeds off the screen, but this time we’re not leaving
    a trail of pixels behind our moving image. By filling the screen with black pixels,
    we’ve created the effect of “erasing” the old image from the screen every frame,
    before we draw the new image at the new location. This creates the illusion of
    smoother animation. On a relatively fast computer, though, our smiley flies off
    the screen way too fast. To change this, we need a new tool: a timer or clock
    that can keep us at a steady, predictable rate of frames per second.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的笑脸依旧飞速离开屏幕，但这次我们并没有在移动的图像后面留下像素的痕迹。通过用黑色像素填充屏幕，我们在每一帧中“擦除”旧的图像，然后在新位置绘制新图像。这就创造了更加流畅的动画效果。然而，在一台相对较快的电脑上，我们的笑脸飞出屏幕的速度太快了。为了解决这个问题，我们需要一个新的工具：一个计时器或时钟，可以保持我们每秒固定的帧数。
- en: Animating a Smiley with the Clock Class
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Clock`类为笑脸动画添加动画效果
- en: The final piece to make our *SmileyMove.py* app behave like an animation we
    might see in a game or movie is to limit the number of frames per second our program
    draws. Currently, we’re moving the smiley image only 1 pixel down and 1 pixel
    to the right each time through the game loop, but our computer can draw this simple
    scene so fast that it can produce hundreds of frames per second, causing our smiley
    to fly off the screen in an instant.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的*SmileyMove.py*应用程序像游戏或电影中的动画一样表现出来的最后一块拼图是限制每秒绘制的帧数。目前，我们每次在游戏循环中只让笑脸图像向下移动1个像素，向右移动1个像素，但我们的电脑可以如此迅速地绘制这个简单场景，产生每秒数百帧，从而导致笑脸瞬间飞出屏幕。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188991.png.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![没有说明的图片](httpatomoreillycomsourcenostarchimages2188991.png.jpg)'
- en: Smooth animation is possible with 30 to 60 frames of animation per second, so
    we don’t need the hundreds of frames zooming past us every second.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅的动画每秒需要30到60帧，因此我们不需要每秒数百帧的快速闪过。
- en: 'Pygame has a tool that can help us control the speed of our animation: the
    `Clock` class. A [*class*](apd.html#gloss01_010) is like a template that can be
    used to create [*objects*](apd.html#gloss01_035) of a certain type, with functions
    and values that help those objects behave in a certain way. Think of a class as
    being like a cookie cutter and objects as the cookies: when we want to create
    cookies of a certain shape, we build a cookie cutter that can be reused anytime
    we want another cookie of the same shape. In the same way that functions help
    us package reusable code together, classes allow us to package data and functions
    into a reusable template that we can use to create objects for future programs.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame有一个可以帮助我们控制动画速度的工具：`Clock`类。[*类*](apd.html#gloss01_010)就像一个模板，可以用来创建某种类型的[*对象*](apd.html#gloss01_035)，这些对象具有一些功能和数值，帮助它们以特定方式运行。可以把类看作是饼干模具，而对象就是饼干：当我们想要做某种形状的饼干时，我们会制作一个可以随时用来做出同样形状饼干的模具。就像函数帮助我们将可重用的代码打包在一起一样，类允许我们将数据和函数打包成一个可重用的模板，我们可以用它来创建面向未来程序的对象。
- en: 'We can add an object of the `Clock` class to our program setup with this line:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下这行代码在程序的设置中添加一个`Clock`类的对象：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This creates a variable called `timer` linked to a `Clock` object. This `timer`
    will allow us to gently pause each time through the game loop and wait just long
    enough to make sure we’re not drawing more than a certain number of frames per
    second.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个名为`timer`的变量，链接到一个`Clock`对象。这个`timer`将允许我们在每次游戏循环时轻轻暂停，等待足够的时间，以确保我们不会绘制超过每秒设定帧数的图像。
- en: 'Adding the following line to our game loop will keep the frame rate at 60 fps
    by telling our `Clock` named `timer` to “tick” just 60 times per second:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏循环中添加以下行，将通过让我们名为`timer`的`Clock`每秒仅“tick” 60次，保持帧率为60帧每秒：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following code, *SmileyMove.py*, shows the whole app put together. It gives
    us a smooth, steady animated smiley face slowly gliding off the lower right of
    the screen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码，*SmileyMove.py*，展示了整个应用程序的实现。它呈现了一个平滑、稳定的动画笑脸，慢慢滑出屏幕的右下角。
- en: SmileyMove.py
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SmileyMove.py
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The remaining problem is that the smiley still goes all the way off the screen
    in a few seconds. That’s not very entertaining. Let’s change our program to keep
    the smiley face on the screen, bouncing from corner to corner.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的问题是，笑脸仍然会在几秒钟内完全滑出屏幕。这并不有趣。让我们修改程序，使笑脸保持在屏幕上，并在角落之间反弹。
- en: Bouncing a Smiley Off a Wall
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让笑脸从墙上反弹
- en: We’ve added motion from one frame to the next by changing the position of the
    image we were drawing on each pass through our game loop. We saw how to regulate
    the speed of that animation by adding a `Clock` object and telling it how many
    times per second to `tick()`. In this section, we’ll see how to keep our smiley
    on the screen. The effect will look a bit like [Figure 8-6](ch08.html#our_goal_is_to_keep_the_smiley_quotation
    "Figure 8-6. Our goal is to keep the smiley “bouncing” between the corners of
    the screen."), with the smiley appearing to bounce back and forth between two
    corners of the drawing window.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过改变每次游戏循环中绘制图像的位置，加入了从一帧到下一帧的运动。我们已经看到如何通过添加`Clock`对象并告诉它每秒`tick()`多少次来调节动画的速度。在这一部分，我们将看到如何让笑脸保持在屏幕上。效果将类似于[图8-6](ch08.html#our_goal_is_to_keep_the_smiley_quotation
    "图8-6。我们的目标是让笑脸在屏幕的角落之间“反弹”")，笑脸似乎在绘图窗口的两个角落之间来回反弹。
- en: '![Our goal is to keep the smiley “bouncing” between the corners of the screen.](httpatomoreillycomsourcenostarchimages2188993.png.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![我们的目标是让笑脸在屏幕的角落之间“反弹”。](httpatomoreillycomsourcenostarchimages2188993.png.jpg)'
- en: Figure 8-6. Our goal is to keep the smiley “bouncing” between the corners of
    the screen.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-6。我们的目标是让笑脸在屏幕的角落之间“反弹”。
- en: The reason our image ran off the screen before is that we didn’t set *boundaries*,
    or limits, for our animation. Everything we draw on the screen is *virtual*—meaning
    it doesn’t exist in the real world—so things don’t really bump into one another.
    If we want the virtual objects on our screen to interact, we have to create those
    interactions with programming logic.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图像之前跑出屏幕的原因是因为我们没有为动画设置*边界*或限制。我们在屏幕上绘制的一切都是*虚拟的*——意味着它们并不存在于现实世界中——因此物体并不会真正互相碰撞。如果我们希望屏幕上的虚拟物体进行交互，我们必须通过编程逻辑来创建这些交互。
- en: Hitting the Wall
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 撞墙
- en: When I say that we want the smiley face to “bounce” off the edge of the screen,
    what I mean is that when the smiley comes to the edge of the screen, we want to
    change the direction it’s moving so that it looks like it bounces off the solid
    edge of the screen. To do this, we need to test whether the `(picx,picy)` location
    of the smiley has reached the imaginary boundary at the edge of the screen. We
    call this logic [*collision detection*](apd.html#gloss01_012) because we’re trying
    to *detect*, or notice, when a *collision* occurs, like the smiley face image
    “hitting” the edge of the drawing window.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说我们希望笑脸“反弹”出屏幕的边缘时，我的意思是，当笑脸到达屏幕的边缘时，我们希望改变它的移动方向，使其看起来像是从屏幕的固体边缘反弹回来。为此，我们需要测试笑脸的`(picx,picy)`位置是否到达了屏幕边缘的虚拟边界。我们称这种逻辑为[*碰撞检测*](apd.html#gloss01_012)，因为我们正试图*检测*或注意到*碰撞*发生的时刻，比如笑脸图像“撞到”绘图窗口的边缘。
- en: We know that we can test for conditions using an `if` statement, so we could
    see if our image is touching, or *colliding* with, the right side of the screen
    by checking whether `picx` is greater than some value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道可以使用`if`语句来测试条件，所以我们可以通过检查`picx`是否大于某个值，来判断我们的图像是否与屏幕的右侧“接触”或*碰撞*。
- en: Let’s figure out what that value might be. We know our screen is 600 pixels
    wide because we created our screen with `pygame.display.set_mode([600,600])`.
    We could use 600 as our boundary, but the smiley face would still go off the edge
    of the screen because the coordinate pair `(picx,picy)` is the location of the
    top-left pixel of our smiley face image.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来推测一下这个值可能是什么。我们知道我们的屏幕宽度是600像素，因为我们通过`pygame.display.set_mode([600,600])`创建了屏幕。我们可以使用600作为边界，但笑脸依然会滑出屏幕的边缘，因为坐标对`(picx,picy)`是我们笑脸图像左上角的像素位置。
- en: To find our logical boundary—that is, the virtual line that `picx` has to reach
    for our smiley face to look like it has hit the right edge of the `screen` window—we
    need to know how wide our picture is. Because we know `picx` is the top-left corner
    of the image and it continues to the right, we can just add the width of our picture
    to `picx`, and when that sum equals 600, we’ll know that the right edge of the
    image is touching the right edge of the window.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到我们的逻辑边界——也就是 `picx` 必须到达的虚拟线，以使我们的笑脸看起来像是撞上了 `screen` 窗口的右边缘——我们需要知道图片的宽度。因为我们知道
    `picx` 是图像的左上角，并且它会向右移动，我们只需将图片的宽度加到 `picx` 上，当这个和等于 600 时，我们就知道图像的右边缘触碰到了窗口的右边缘。
- en: One way to find the width of our image is by looking at the properties of the
    file. In Windows, right-click the *CrazySmile.bmp* file, select the Properties
    menu item, and then click the Details tab. On a Mac, click the *CrazySmile.bmp*
    file to select it, press ![](httpatomoreillycomsourcenostarchimages2188973.png.jpg)
    -I to get the file info window, and then click More Info. You’ll see the width
    and height of the picture, as shown in [Figure 8-7](ch08.html#to_determine_our_virtual_boundaries_so_o
    "Figure 8-7. To determine our virtual boundaries so our smiley face can bounce
    off them, we need to know the width of our image file.").
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 查找图像宽度的一种方法是查看文件的属性。在 Windows 中，右键点击 *CrazySmile.bmp* 文件，选择“属性”菜单项，然后点击“详细信息”选项卡。在
    Mac 上，点击选择 *CrazySmile.bmp* 文件，按下 ![](httpatomoreillycomsourcenostarchimages2188973.png.jpg)
    -I 获取文件信息窗口，然后点击“更多信息”。你将看到图像的宽度和高度，如 [图 8-7](ch08.html#to_determine_our_virtual_boundaries_so_o
    "图 8-7. 为了确定我们的虚拟边界，以便让我们的笑脸能够反弹，我们需要知道图像文件的宽度。") 所示。
- en: '![To determine our virtual boundaries so our smiley face can bounce off them,
    we need to know the width of our image file.](httpatomoreillycomsourcenostarchimages2188995.png.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![为了确定我们的虚拟边界，以便让我们的笑脸能够反弹，我们需要知道图像文件的宽度。](httpatomoreillycomsourcenostarchimages2188995.png.jpg)'
- en: Figure 8-7. To determine our virtual boundaries so our smiley face can bounce
    off them, we need to know the width of our image file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-7. 为了确定我们的虚拟边界，以便让我们的笑脸能够反弹，我们需要知道图像文件的宽度。
- en: Our *CrazySmile.bmp* file measures 100 pixels across (and 100 pixels down).
    So if our `screen` is currently 600 pixels wide and the `pic` image needs 100
    pixels to display the full image, our `picx` has to stay left of 500 pixels in
    the x-direction. [Figure 8-8](ch08.html#calculating_a_bounce_against_the_right_s
    "Figure 8-8. Calculating a bounce against the right side of the window") shows
    these measurements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 *CrazySmile.bmp* 文件的宽度是 100 像素（高度也是 100 像素）。所以如果我们的 `screen` 当前是 600 像素宽，而
    `pic` 图像需要 100 像素来显示完整图像，那么我们的 `picx` 必须保持在 x 方向上小于 500 像素。[图 8-8](ch08.html#calculating_a_bounce_against_the_right_s
    "图 8-8. 计算与窗口右侧的反弹") 展示了这些测量值。
- en: '![Calculating a bounce against the right side of the window](httpatomoreillycomsourcenostarchimages2188997.png.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![计算与窗口右侧的反弹](httpatomoreillycomsourcenostarchimages2188997.png.jpg)'
- en: Figure 8-8. Calculating a bounce against the right side of the window
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-8. 计算与窗口右侧的反弹
- en: But what if we change our image file or want to handle images of different widths
    and heights? Fortunately, Pygame has a convenient function in the `pygame.image`
    class that our picture variable `pic` uses. The function `pic.get_width()` returns
    the width in pixels of the image stored in the `pygame.image` variable `pic`.
    We can use this function instead of hardcoding our program to handle only an image
    that measures 100 pixels wide. Similarly, `pic.get_height()` gives us the height
    in pixels of the image stored in `pic`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们更改了图像文件或希望处理不同宽度和高度的图像怎么办呢？幸运的是，Pygame 在 `pygame.image` 类中提供了一个方便的函数，我们的图片变量
    `pic` 就是利用这个函数。函数 `pic.get_width()` 返回存储在 `pygame.image` 变量 `pic` 中图像的宽度（以像素为单位）。我们可以使用这个函数，而不是将程序硬编码为只能处理宽度为
    100 像素的图像。类似地，`pic.get_height()` 给出存储在 `pic` 中图像的高度（以像素为单位）。
- en: 'We can test whether the image `pic` is going off the right side of the screen
    with a statement like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用如下语句测试图像 `pic` 是否已经超出了屏幕的右边缘：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In other words, if the starting x-coordinate of the picture, plus the picture’s
    width, is greater than the width of the screen, we’ll know we’ve gone off the
    right edge of the screen, and we can change the image’s direction of motion.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果图片的起始 x 坐标加上图片的宽度大于屏幕的宽度，我们就知道图像已经超出了屏幕的右边缘，我们可以改变图像的运动方向。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2188999.png.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2188999.png.jpg)'
- en: Changing Direction
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变方向
- en: '“Bouncing” off the edge of the screen means going in the opposite direction
    after hitting that edge. The direction our image is moving is controlled by the
    updates to `picx` and `picy`. In our old *SmileyMove.py*, we just added 1 pixel
    to `picx` and `picy` every time through the `while` loop with these lines:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: “反弹”意味着在撞到屏幕边缘后朝相反的方向移动。图像的移动方向是由 `picx` 和 `picy` 的更新控制的。在我们以前的 *SmileyMove.py*
    中，我们每次通过 `while` 循环时，都会用这两行代码给 `picx` 和 `picy` 各加 1 像素：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, these lines kept our image moving right and down 1 pixel every time;
    there was no “bounce,” or changing direction, because we never changed the number
    added to `picx` and `picy`. Those two lines mean we’re guaranteed to move right
    and down at a speed of 1 pixel per frame, every frame, even after the smiley has
    left the screen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些代码每次都会让我们的图像向右和向下各移动 1 像素；没有出现“反弹”或者方向改变，因为我们从未改变过添加到`picx`和`picy`的数值。这两行代码意味着我们可以确保每一帧都会以每帧
    1 像素的速度向右和向下移动，即使笑脸已经离开了屏幕。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189001.png.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2189001.png.jpg)'
- en: 'Instead, we can change the constant value `1` to a variable that will represent
    the *speed*, or number of pixels the image should move each frame. Speed is the
    amount of movement in a period of time. For example, a car that moves a lot in
    a short time is moving at a *high speed*. A snail that barely moves in the same
    period of time is moving at a *low speed*. We can define a variable called `speed`
    in the setup portion of our program for the amount of movement in pixels that
    we want for each frame:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以将常量值 `1` 改为一个变量，来表示*速度*，即每一帧图像应该移动的像素数。速度是指在一段时间内的移动量。例如，在短时间内移动得很快的车在以*高速*行驶，而在相同时间内几乎不动的蜗牛则在以*低速*爬行。我们可以在程序的设置部分定义一个名为
    `speed` 的变量，表示每一帧所希望的像素移动量：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, all we have to do in our game loop is change `picx` and `picy` by this
    new speed amount (instead of the constant amount `1`) every time through the loop:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的游戏循环中，我们只需要每次通过循环时，将 `picx` 和 `picy` 按照新的速度值（而不是常量 `1`）进行改变：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: One pixel per frame seemed a bit too slow at 60 frames per second in *SmileyMove.py*,
    so I’ve increased the speed to 5 to make it move faster. But we’re still not bouncing
    off the right edge of the screen; we just move off the screen quickly again, because
    the `speed` variable doesn’t change when we hit the edge of the screen.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *SmileyMove.py* 中，60 帧每秒时，每帧 1 像素的速度显得有些慢，所以我将速度提高到了 5 像素，让它移动得更快。但我们仍然没有让图像从屏幕的右边缘反弹回来；我们只是很快地让它移出了屏幕，因为当碰到屏幕边缘时，`speed`
    变量并没有发生变化。
- en: 'We can solve that final problem by adding our collision detection logic—that
    is, our test to see if we’ve hit the imaginary boundary at the left or right edges
    of the screen:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加碰撞检测逻辑来解决这个问题，也就是测试图像是否碰到了屏幕的左或右边缘：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we’re checking both the left and right boundaries of the screen by seeing
    if `picx` is trying to draw at a negative x-coordinate value (off the left of
    the screen where `x < 0`) or if `picx + pic.get_ width()` totals more than the
    600-pixel width of the screen (meaning the picture’s starting x-coordinate plus
    its width have gone off the right edge of the screen). If either of these happens,
    we know we’ve gone too far and we need to change the direction we’re going in.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过检查`picx`是否试图绘制在负的 x 坐标值（也就是屏幕左侧，`x < 0`），或者`picx + pic.get_width()`是否超过了屏幕的
    600 像素宽度（即图片的起始 x 坐标加上它的宽度已经超出了屏幕的右边缘）来检查屏幕的左右边界。如果发生其中任一情况，我们就知道图像已超出边界，需要改变方向。
- en: 'Notice the trick we’re using if either of those boundary tests evaluates to
    `True`. By setting `speed = -speed`, we’re changing the *direction* of the movement
    in our `while` loop by multiplying `speed` by –1, or by making it the negative
    of itself. Think of it this way: if we keep looping with `speed` equal to `5`
    until our `picx` plus the image’s width hits the right edge of the screen at 600
    pixels (`picx + pic.get_width() >= 600`), setting `speed = -speed` will change
    `speed` from `5` to `-5` (negative five). Then, whenever our `picx` and `picy`
    change in the next pass through the loop, we’ll add `-5` to our location. This
    is the same as *subtracting* 5 from `picx` and `picy`, or moving *left and up*
    on our screen. If this works, our smiley face will now bounce off the lower-right
    corner of the screen and start traveling *backward*, back up to (0, 0) at the
    upper-left corner of the screen.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在进行边界测试时使用的小技巧。如果其中任何一个边界测试的结果为`True`，通过设置`speed = -speed`，我们就通过将`speed`乘以-1，或者将它改为自身的相反数，来改变移动的*方向*。可以这么理解：如果我们继续以`speed`等于`5`的速度循环，直到我们的`picx`加上图片的宽度碰到屏幕右边缘（600像素）（`picx
    + pic.get_width() >= 600`），设置`speed = -speed`会将`speed`从`5`变为`-5`（负五）。然后，每当我们的`picx`和`picy`在下一次循环中变化时，我们将会把`-5`加到我们的坐标上。这等于*减去*
    5，意味着我们在屏幕上向*左和上*移动。如果这样工作的话，我们的笑脸就会从屏幕的右下角反弹开始，开始向*后*移动，回到屏幕的左上角（0，0）的位置。
- en: But that’s not all! Because our `if` statement is also checking for the left
    screen boundary (`picx <= 0`), when our smiley face looks like it has hit the
    left side of the screen, it will change `speed` to `-speed` again. If `speed`
    is `-5`, this will change it to `-(-5)`, or `+5`. So if our negative `speed` variable
    was causing us to move to the left and up 5 pixels every frame, once we hit `picx
    <= 0` at the left edge of the screen, `speed = -speed` will turn `speed` back
    to positive `5`, and the smiley image will start moving to the *right and down*
    again, in the positive x- and y-directions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不是全部！因为我们的`if`语句还在检查左边界（`picx <= 0`），当我们的笑脸看起来像是撞到了屏幕的左侧时，它会再次将`speed`的值改为`-speed`。如果`speed`是`-5`，这会将其改为`-(-5)`，即`+5`。所以，如果我们的负值`speed`变量导致我们每帧向左和向上移动5个像素，一旦我们在屏幕的左边缘遇到`picx
    <= 0`，`speed = -speed`会把`speed`改回正值`5`，然后笑脸图像会重新开始向*右和下*移动，沿着正方向的x轴和y轴。
- en: Putting It All Together
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: Try version 1.0 of our app, *SmileyBounce1.py*, to see the smiley face bounce
    from the upper-left corner of the window to the lower-right corner and back again,
    never leaving the drawing screen.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试我们应用的1.0版本，*SmileyBounce1.py*，看看笑脸如何从窗口的左上角跳到右下角，再返回，始终不离开绘图区域。
- en: SmileyBounce1.py
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SmileyBounce1.py
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this first version of the program, we have created what looks like a smoothly
    animated smiley face bouncing back and forth between two corners of a square drawing
    window. We are able to achieve this effect precisely because the window is a perfect
    square, 600×600 pixels in size, and because we always change our `picx` and `picy`
    values by the same amount (`speed`)—our smiley face travels only on the diagonal
    line where *x* = *y*. By keeping our image on this simple path, we only have to
    check whether `picx` goes past the boundary values at the left and right edges
    of the screen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个版本的程序，我们创建了一个看起来像是在两个角落之间平滑跳动的笑脸。我们之所以能够实现这个效果，恰恰是因为窗口是一个完美的正方形，大小为600×600像素，并且因为我们始终以相同的值（`speed`）来更改`picx`和`picy`——我们的笑脸只在*
    x = y*的对角线上移动。通过保持图像在这条简单的路径上，我们只需检查`picx`是否越过了屏幕左右边缘的边界值。
- en: What if we want to bounce off all four edges (top, bottom, left, and right)
    of the screen, in a window that isn’t a perfect square— say, 800×600? We’ll need
    to add some logic to check our `picy` variable to see if it passes an upper or
    lower boundary (the top or bottom of the screen), and we’ll need to keep track
    of horizontal and vertical speed separately. We’ll do that next.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要让笑脸从屏幕的四个边（上、下、左、右）反弹，并且窗口不是完美的正方形——比如说800×600的尺寸，我们需要添加一些逻辑来检查`picy`变量，看看它是否越过了上边界或下边界（屏幕的顶部或底部），并且我们还需要分别跟踪水平和垂直的速度。接下来我们会做这些。
- en: Bouncing a Smiley Off Four Walls
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让笑脸弹跳四个墙壁
- en: In *SmileyBounce1.py*, we kept the horizontal (left-right) and vertical (up-down)
    motion locked so that whenever the image was moving right, it was also moving
    down, and when it was moving left, it was also moving up. This worked well for
    our square window because the width and height of the screen were the same. Let’s
    build on that example to create a bouncing animation that rebounds realistically
    off all four sides of the drawing window. We’ll make the window 800×600 pixels
    in size with `screen = pygame.display.set_mode([800,600])` to make the animation
    more interesting.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在*SmileyBounce1.py*中，我们保持水平（左右）和垂直（上下）运动的锁定，使得每当图像向右移动时，它也会向下移动，而每当图像向左移动时，它也会向上移动。这在我们的正方形窗口中效果很好，因为屏幕的宽度和高度是相同的。让我们在这个例子基础上，创建一个弹跳动画，使其能在绘图窗口的四个边缘上真实地反弹。我们将把窗口大小设置为800×600像素，使用`screen
    = pygame.display.set_mode([800,600])`来使动画更加有趣。
- en: Horizontal and Vertical Speed
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平和垂直速度
- en: 'First, let’s separate the horizontal and vertical components of the speed.
    In other words, let’s create one speed variable, `speedx`, for the *horizontal*
    speed (how fast the image is moving to the right or left), and another speed variable,
    `speedy`, for the *vertical* speed (how fast the image is moving down or up).
    We can accomplish this by changing the `speed = 5` entry in the setup section
    of our app to initialize a `speedx` and `speedy` as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将速度的水平和垂直分量分开。换句话说，我们为*水平*速度（图像向左或向右移动的速度）创建一个速度变量`speedx`，为*垂直*速度（图像向上或向下移动的速度）创建另一个速度变量`speedy`。我们可以通过在应用程序的设置部分将`speed
    = 5`修改为初始化`speedx`和`speedy`，如下所示：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can then modify our image position updates in the game loop:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在游戏循环中修改图像位置的更新：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We change `picx` (the horizontal or x-position) by `speedx` (the horizontal
    speed) and `picy` (the vertical or y-position) by `speedy` (the vertical speed).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`speedx`（水平速度）来改变`picx`（水平或x位置），通过`speedy`（垂直速度）来改变`picy`（垂直或y位置）。
- en: Hitting Four Walls
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞四个墙壁
- en: 'The last part to figure out is the boundary collision detection for each of
    the four edges of the screen (top and bottom in addition to right and left). First,
    let’s modify the left and right boundaries to match the new screen size (800 pixels
    wide) and to use the new horizontal speed `speedx`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要解决的是屏幕四个边缘（上下左右）的边界碰撞检测。首先，让我们修改左右边界，以匹配新的屏幕大小（宽度为800像素），并使用新的水平速度`speedx`：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that our left-edge-boundary case remains the same at `picx <= 0`, because
    0 is still the left boundary value when `picx` is at the left of the screen. This
    time, though, our right-edge-boundary case has changed to `picx + pic.get_width()
    >= 800`, because our screen is now 800 pixels wide, and our image still starts
    at `picx` and then draws its full width to the right. So when `picx + pic.get_width()`
    equals `800`, our smiley face looks like it is touching the right side of the
    drawing window.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，左边界的情况仍然保持不变，即`picx <= 0`，因为当`picx`位于屏幕左侧时，0仍然是左边界的值。不过，这次右边界的情况已经改为`picx
    + pic.get_width() >= 800`，因为我们的屏幕现在是800像素宽，而图像仍然从`picx`开始，然后向右绘制完整的宽度。所以，当`picx
    + pic.get_width()`等于800时，我们的笑脸就看起来像是碰到了绘图窗口的右侧。
- en: We slightly changed the action that our left and right boundaries trigger, from
    `speed = -speed` to `speedx = -speedx`. We now have two components of our speed,
    and `speedx` will control the left and right directions and speeds (negative values
    of `speedx` will move the smiley face left; positive values will move it right).
    So when the smiley hits the right edge of the screen, we turn `speedx` negative
    to make the image go back toward the left, and when it hits the left edge of the
    screen, we turn `speedx` back to a positive value to rebound the image to the
    right.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微修改了左右边界触发的动作，将`speed = -speed`改为`speedx = -speedx`。现在我们有了两个速度分量，`speedx`将控制左右方向和速度（`speedx`的负值会让笑脸向左移动，正值则会让它向右移动）。所以，当笑脸碰到屏幕右边缘时，我们将`speedx`设为负值，让图像向左移动；当它碰到屏幕左边缘时，我们将`speedx`设为正值，让图像反弹回右边。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189003.png.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图像](httpatomoreillycomsourcenostarchimages2189003.png.jpg)'
- en: 'Let’s do the same thing with `picy`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`picy`做同样的处理：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To test whether our smiley has hit the top edge of the screen, we use `picy
    <= 0`, which is similar to `picx <= 0` for the left edge. To figure out whether
    our smiley has hit the bottom edge of the screen, we need to know both the height
    of the drawing window (600 pixels) and the height of the image (`pic.get_height()`),
    and we need to see if the top of our image, `picy`, plus the image’s height, `pic.get_height()`,
    totals more than the height of our screen, 600 pixels.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的笑脸图标是否碰到了屏幕的顶部边缘，我们使用`picy <= 0`，这与测试左边缘的`picx <= 0`类似。为了判断笑脸图标是否碰到了屏幕的底部边缘，我们需要知道绘图窗口的高度（600像素）和图像的高度（`pic.get_height()`），然后判断图像的顶部`picy`加上图像的高度`pic.get_height()`是否超过了屏幕的高度600像素。
- en: If `picy` goes outside these top and bottom boundaries, we need to change the
    direction of the vertical speed (`speedy = -speedy`). This makes the smiley face
    look like it’s bouncing off the bottom edge of the window and heading back up,
    or bouncing off the top and heading back down.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`picy`超出了上下边界，我们需要改变垂直速度的方向（`speedy = -speedy`）。这样，笑脸图标看起来就像是从窗口的底部反弹并向上移动，或者从顶部反弹并向下移动。
- en: Putting It All Together
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整合全部功能
- en: When we put the whole program together in *SmileyBounce2.py*, we get a convincing
    bouncing ball that is able to rebound off all four edges of the screen for as
    long as we run the app.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将整个程序整合到*SmileyBounce2.py*中时，我们得到了一个令人信服的弹跳球，它能够在运行应用程序时，反弹穿过屏幕的四个边缘。
- en: SmileyBounce2.py
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SmileyBounce2.py
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The rebounds look realistic. If the smiley is coming toward the bottom edge
    at a 45-degree angle down and to the right, it bounces off at a 45-degree angle
    up and to the right. You can experiment with different values of `speedx` and
    `speedy` (say, `3` and `5`, or `7` and `4`) to see the angles change for every
    bounce.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 弹跳效果看起来很真实。如果笑脸图标以45度角朝着底部边缘靠近，并且向右下方移动，它会以45度角反弹，向右上方移动。你可以通过改变`speedx`和`speedy`的不同值（例如，`3`和`5`，或者`7`和`4`）来观察每次反弹时角度的变化。
- en: 'Just for fun, you can comment out the line `screen.fill(BLACK)` in *SmileyBounce2.py*
    to see the path traveled by our smiley face as it bounces off each edge of the
    screen. When you *comment out* a line, you turn it into a comment by putting a
    hash mark at the beginning, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹为了好玩，你可以注释掉`screen.fill(BLACK)`这一行代码，在*SmileyBounce2.py*中查看笑脸图标在每次与屏幕边缘反弹时所走的路径。当你*注释掉*一行代码时，通过在行首加上井号，你可以将该行代码变成注释，像这样：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This tells the program to ignore the instruction on that line. Now the screen
    is not erased after each smiley face is drawn, and you’ll see a pattern created
    by the trail your animation is leaving behind, like in [Figure 8-9](ch08.html#if_we_comment_out_the_line_that_clears_o
    "Figure 8-9. If we comment out the line that clears our screen after each frame,
    our smiley face leaves a bouncing trail behind in a cool pattern."). Because each
    new smiley is drawn over the previous one, the result looks like cool, retro 3-D
    screensaver artwork as it draws.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉程序忽略该行指令。现在，屏幕在每次绘制笑脸图标后不会被清除，你会看到一个由你的动画留下的轨迹，像在[图 8-9](ch08.html#if_we_comment_out_the_line_that_clears_o
    "图 8-9. 如果我们注释掉每帧后清除屏幕的那一行代码，笑脸图标在屏幕上留下一个有趣的弹跳轨迹。")中一样形成的图案。由于每个新的笑脸图标覆盖在前一个图标上，最终的效果看起来像是酷炫的复古3D屏幕保护程序艺术作品。
- en: Our collision-detection logic has allowed us to create the illusion of a solid
    smiley face bouncing off all four edges of a solid drawing screen. This is an
    improvement over our original version, which let the smiley slide off into oblivion.
    When we create games that allow the user to interact with pieces on the screen,
    and that allow those pieces to look as if they’re interacting with one another—like
    in Tetris, for example—we’re using the same kind of collision detection and boundary
    checking that we built here.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的碰撞检测逻辑使得我们能够创建一个逼真的笑脸图标，在一个完整的绘图屏幕上反弹并与四个边缘碰撞。相比于我们原来的版本，笑脸图标不再滑向无尽的空白，而是反弹回去。我们在创建允许用户与屏幕上的元素进行交互的游戏时，就会使用类似的碰撞检测和边界检查技术，例如在《俄罗斯方块》游戏中，我们也使用了这种碰撞检测。
- en: '![If we comment out the line that clears our screen after each frame, our smiley
    face leaves a bouncing trail behind in a cool pattern.](httpatomoreillycomsourcenostarchimages2189005.png.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![如果我们注释掉每帧后清除屏幕的那一行代码，笑脸图标在屏幕上留下一个有趣的弹跳轨迹。](httpatomoreillycomsourcenostarchimages2189005.png.jpg)'
- en: Figure 8-9. If we comment out the line that clears our screen after each frame,
    our smiley face leaves a bouncing trail behind in a cool pattern.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-9。如果我们注释掉每帧后清除屏幕的那一行代码，笑脸图标在屏幕上留下一个有趣的弹跳轨迹。
- en: What You Learned
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到的知识
- en: In this chapter, you learned how to create the illusion of motion, what we call
    [*animation*](apd.html#gloss01_002), by drawing images in different locations
    on the screen over time. We saw how the Pygame module can make programming a game
    or animation much quicker, since it has hundreds of functions that can make almost
    everything in a game app easier, from drawing images to creating timer-based animation—
    even checking for collisions. We installed Pygame on our computer so we could
    use its features to create fun apps of our own.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何通过在屏幕上不断地绘制图像来创造运动的错觉，我们称之为[*动画*](apd.html#gloss01_002)。我们看到Pygame模块可以让编程游戏或动画变得更快速，因为它有成百上千个函数，可以让游戏应用中的几乎每一件事都变得更加简单，从绘制图像到创建基于计时器的动画——甚至是检测碰撞。我们在计算机上安装了Pygame，以便利用其功能创建我们自己的有趣应用程序。
- en: You learned about the structure of a game or app that we might build in Pygame,
    with a setup section; a game loop that handles events, updates and draws graphics,
    and then updates the display; and finally an exit section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你学到了我们可能在Pygame中构建的游戏或应用程序的结构，包括一个设置部分；一个处理事件、更新和绘制图形、更新显示的游戏循环；以及最后的退出部分。
- en: We started our Pygame programming by drawing a simple green dot on the screen
    at a chosen location, but we quickly moved on to drawing a picture from an image
    file on disk, saved in the same folder as our program, to our display screen.
    You learned that Pygame has a different coordinate system from the Turtle library,
    with the origin (0, 0) in the upper-left corner of the screen and positive y-coordinate
    values as we move down.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在屏幕上指定位置绘制一个简单的绿色圆点来开始Pygame编程，但我们很快转向从磁盘上的图像文件绘制图片，图像文件保存在与程序相同的文件夹中，并将其显示到屏幕上。你学到Pygame与Turtle库使用不同的坐标系统，屏幕的左上角为原点(0,
    0)，y坐标值随着向下移动而增大。
- en: You learned how to create animation by drawing objects on the screen, clearing
    the screen, and then drawing the objects in a slightly different location. We
    saw that the `pygame.time.Clock()` object could make our animations steadier by
    limiting the number of times our animation draws each second, which is called
    the *frames per second*, or *fps*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何通过在屏幕上绘制物体、清除屏幕并在稍微不同的位置重新绘制物体来创建动画。我们发现`pygame.time.Clock()`对象可以通过限制每秒动画绘制次数来使我们的动画更加稳定，这个限制被称为*每秒帧数*，或*fps*。
- en: We built our own collision detection to check for objects “hitting” the edge
    of the screen, and then we added the logic to make objects look like they’re bouncing
    back by changing the direction of their speed or velocity variables (by multiplying
    them by –1).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了自己的碰撞检测来检查物体是否“撞到”屏幕边缘，然后我们添加了逻辑，通过改变物体的速度或速度变量的方向（通过将它们乘以-1）使物体看起来像是弹回去的。
- en: 'Programming the cool apps in this chapter has given us the skills to do the
    following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章编写这些酷炫应用程序让我们掌握了以下技能：
- en: Install and use the `pygame` module in our own Python programs.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Python程序中安装并使用`pygame`模块。
- en: Explain the structure of a Pygame app, including the setup, game loop, and exit.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Pygame应用程序的结构，包括设置、游戏循环和退出部分。
- en: Build a game loop that handles events, updates and draws graphics, and updates
    the display.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个游戏循环，处理事件，更新和绘制图形，并更新显示。
- en: Draw shapes to the screen using `pygame.draw` functions.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pygame.draw`函数在屏幕上绘制形状。
- en: Load images from disk with `pygame.image.load()`.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pygame.image.load()`从磁盘加载图像。
- en: Draw images and objects to the screen with the `blit()` function.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`blit()`函数将图像和物体绘制到屏幕上。
- en: Create animations by drawing objects to the screen repeatedly in different locations.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过不断地在不同的位置绘制物体来创建动画。
- en: Make animations smooth, clean, and predictable using a `pygame.time.Clock()`
    timer’s `tick()` function to limit the number of frames per second in our animations.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pygame.time.Clock()`计时器的`tick()`函数来限制每秒帧数，使动画变得平滑、整洁且可预测。
- en: Check for collision detection by building the `if` logic to check for boundary
    cases, like a graphic hitting the edge of the screen.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构建`if`逻辑来检查边界情况，检测碰撞，比如图形碰到屏幕边缘时的情况。
- en: Control the horizontal and vertical speeds of moving objects on the screen by
    changing the amount of movement in the x- and y-directions from one frame to the
    next.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过改变每帧中物体在x和y方向的移动量，控制物体在屏幕上水平和垂直的运动速度。
- en: Programming Challenges
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 编程挑战
- en: Here are three challenge problems to extend the skills you developed in this
    chapter. For sample answers, go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个挑战问题，可以扩展你在本章中学到的技能。样例答案请访问 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*。
- en: '**#1: A COLOR-CHANGING DOT**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1: 一个变色的点**'
- en: Let’s explore RGB color triplets further. We worked with some RGB colors in
    this chapter; remember, green was `(0,255,0)`, black was `(0,0,0)`, and so on.
    At *[http://colorschemer.com/online/](http://colorschemer.com/online/)*, enter
    different red, green, and blue values from 0 to 255 to see the colors you can
    create by combining different amounts of red, green, and blue light from your
    screen’s pixels. Start by choosing your own color triplet to use in the *ShowDot.py*
    program. Then modify the program to draw the dot larger or smaller and at different
    locations on the screen. Finally, try creating a random RGB color triplet using
    `random.randint(0,255)` for each of the three color components (remember to `import
    random` at the top of your program) so that the dot changes colors every time
    it draws on the screen. The effect will be a color-changing dot. Call your new
    creation *DiscoDot.py*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探索 RGB 颜色三元组。本章中我们已经使用了一些 RGB 颜色；记住，绿色是`(0,255,0)`，黑色是`(0,0,0)`，等等。在 *[http://colorschemer.com/online/](http://colorschemer.com/online/)*
    上，输入不同的红色、绿色和蓝色值（0 到 255 之间），你可以查看通过组合不同的红、绿、蓝光来创建的颜色。首先，选择一个你自己喜欢的颜色三元组来用于 *ShowDot.py*
    程序。然后修改程序，使得点可以更大或更小，并且位于屏幕的不同位置。最后，尝试使用 `random.randint(0,255)` 为每个颜色分量创建一个随机的
    RGB 颜色三元组（记得在程序顶部 `import random`），使得每次绘制时点的颜色都会变化。效果将是一个变色的点。将你的新程序命名为 *DiscoDot.py*。
- en: '**#2: 100 RANDOM DOTS**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**#2: 100 个随机点**'
- en: 'As a second challenge, let’s replace the single dot with 100 dots in random
    colors, sizes, and locations. To do this, let’s set up three arrays capable of
    storing 100 values each for the colors, locations, and sizes:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个挑战，让我们用 100 个随机颜色、大小和位置的点替代单个点。为此，我们需要设置三个数组，分别能存储 100 个颜色、位置和大小的值：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, fill those three arrays with random color triplets, location pairs, and
    size/radius values for 100 random dots:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，填充这三个数组，分别为 100 个随机点的颜色三元组、位置对和大小/半径值：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, instead of drawing one dot in our `while` loop, add a `for` loop to
    draw the 100 random dots by using the `colors`, `locations`, and `sizes` arrays:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的`while`循环中，不再绘制一个点，而是添加一个`for`循环，使用`colors`、`locations`和`sizes`数组绘制 100
    个随机点：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Call your new creation *RandomDots.py*. The final app should look something
    like [Figure 8-10](ch08.html#advanced_version_of_our_dot_programcomma "Figure 8-10. An
    advanced version of our dot program, RandomDots.py, gives us 100 dots of random
    color, location, and size.") when complete.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的新创建命名为*RandomDots.py*。最终的应用程序完成后应该类似于[图 8-10](ch08.html#advanced_version_of_our_dot_programcomma
    "图 8-10. 我们的点程序的高级版本，RandomDots.py，展示了 100 个随机颜色、位置和大小的点。")。
- en: '![An advanced version of our dot program, RandomDots.py, gives us 100 dots
    of random color, location, and size.](httpatomoreillycomsourcenostarchimages2189007.png.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![我们点程序的高级版本，RandomDots.py，展示了 100 个随机颜色、位置和大小的点。](httpatomoreillycomsourcenostarchimages2189007.png.jpg)'
- en: Figure 8-10. An advanced version of our dot program, *RandomDots.py*, gives
    us 100 dots of random color, location, and size.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-10. 我们的点程序的高级版本，*RandomDots.py*，展示了 100 个随机颜色、位置和大小的点。
- en: '**#3: RAINING DOTS**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**#3: 下雨的点**'
- en: 'Finally, let’s take *RandomDots.py* one step further by programming the dots
    to “rain” off the bottom and right sides of the screen and reappear along the
    top and left. You’ve learned in this chapter that we create animation by changing
    the location of an object over time. We have the location of each dot in an array
    called `locations`, so if we change each dot’s x- and y-coordinates, we can animate
    our dots. Change the `for` loop from *RandomDots.py* to calculate a new x- and
    y-coordinates for each dot based on the previous value, like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将 *RandomDots.py* 进一步扩展，编程让这些点从屏幕的底部和右侧“下雨”，然后从顶部和左侧重新出现。你在本章中学到，通过随着时间变化改变物体的位置来创建动画。我们将每个点的位置保存在一个名为
    `locations` 的数组中，所以如果我们改变每个点的 x 和 y 坐标，就能实现点的动画。将 *RandomDots.py* 中的 `for` 循环更改为，根据之前的值计算每个点的新的
    x 和 y 坐标，如下所示：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This change calculates new x- and y-coordinates (`new_x` and `new_y`) for each
    dot every pass through the game loop, but it lets the dots fall off the right
    and bottom edges of the screen. Let’s fix this by checking whether each dot’s
    `new_x` or `new_y` is beyond the right or bottom edges of the screen and, if so,
    move the dot back up or back to the left before we store the new location:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化会在每次游戏循环中为每个点计算新的x和y坐标（`new_x`和`new_y`），但它允许这些点从屏幕的右侧和底部掉落。我们可以通过检查每个点的`new_x`或`new_y`是否超出了屏幕的右边或底边来修复这个问题，如果是的话，就将点移回到屏幕的顶部或左侧，然后再存储新的位置：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The combined effect of these changes will be a steady flow of random dots “raining”
    down and to the right, disappearing off the bottom right of the screen and popping
    back up on the top or left edge. Four frames in this sequence are shown in [Figure 8-11](ch08.html#four_frames_showing_100_random_dots_as_t
    "Figure 8-11. Four frames showing 100 random dots as they move right and down
    across the screen"); you can follow groups of dots as they move down and to the
    right across the three images.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化的综合效果是，随机点会稳定地“下落”并向右移动，消失在屏幕的右下角，然后从顶部或左侧重新出现。在[图8-11](ch08.html#four_frames_showing_100_random_dots_as_t
    "图8-11. 四帧图像展示了100个随机点随着时间向右和向下移动穿过屏幕")中展示了这一序列的四帧图像；你可以跟踪这些点群在三张图像中向下和向右移动的过程。
- en: Save your new app as *RainingDots.py*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的新应用保存为*RainingDots.py*。
- en: '![Four frames showing 100 random dots as they move right and down across the
    screen](httpatomoreillycomsourcenostarchimages2189009.png.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![四帧图像展示了100个随机点随着时间向右和向下移动穿过屏幕](httpatomoreillycomsourcenostarchimages2189009.png.jpg)'
- en: Figure 8-11. Four frames showing 100 random dots as they move right and down
    across the screen
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-11. 四帧图像展示了100个随机点随着时间向右和向下移动穿过屏幕
