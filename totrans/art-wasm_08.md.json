["```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Collision detection</title>\n</head>\n<body>\n1 <canvas 2id=\"cnvs\" 3width=\"512\" 4height=\"512\"></canvas>\n...\n```", "```\n...\n<script>\n1 const cnvs_size = 512;  // square canvas where width and height = 512\n\n2 const no_hit_color = 0xff_00_ff_00; // no hit color (green)\n  const hit_color = 0xff_00_00_ff;    // hit color (red)\n\n // pixels count is canvas_size x canvas_size because it's a square canvas\n3 const pixel_count = cnvs_size * cnvs_size; \n\n4 const canvas = document.getElementById(\"cnvs\");\n5 const ctx = canvas.getContext(\"2d\");\n  ctx.clearRect(0, 0, 512, 512);\n\n // the number of bytes needed for that pixel data is the number of pixels * 4\n6 const obj_start = pixel_count * 4; // 4 bytes in every pixel.\n  const obj_start_32 = pixel_count;  // 32-bit offset to the starting object\n  const obj_size = 4;       // how many pixels is the square object\n  const obj_cnt = 3000;     // 3000 objects\n  const stride_bytes = 16;  // there are 16 bytes in each stride\n\n  const x_offset  = 0;      // x attribute is bytes 0-3\n  const y_offset  = 4;      // y attribute is bytes 4-7\n  const xv_offset = 8;      // x velocity attribute is bytes 8-11\n  const yv_offset = 12;     // y velocity attribute is bytes 12-15\n\n7 const memory = new WebAssembly.Memory({initial: 80});\n  const mem_i8 = new Uint8Array(memory.buffer);         // 8-bit view\n  const mem_i32 = new Uint32Array(memory.buffer);       // 32-bit view\n\n8 const importObject = {\n  env: {\n    buffer: memory,\n\n    cnvs_size: cnvs_size,\n    no_hit_color: no_hit_color,\n hit_color: hit_color,\n    obj_start: obj_start,\n    obj_cnt: obj_cnt,\n    obj_size: obj_size,\n\n    x_offset: x_offset,\n    y_offset: y_offset,\n    xv_offset: xv_offset,\n    yv_offset: yv_offset\n  }\n };\n\n // An ImageData object can be blitted onto the canvas\n  const image_data = \n  9 new ImageData( new Uint8ClampedArray(memory.buffer, 0, obj_start),\n                 cnvs_size, \n                 cnvs_size );\n...\n```", "```\n...\n1 const stride_i32 = stride_bytes/4;\n2 for( let i = 0; i < obj_cnt * stride_i32; i += stride_i32 ) {\n\n // value less than canvas_size\n  3 let temp = Math.floor(Math.random() * cnvs_size);\n\n // set object x attribute to random value\n  4 mem_i32[obj_start_32 + i] = temp; \n\n //random value less than canvas_size\n  5 temp = Math.floor(Math.random()*cnvs_size);\n\n // set object y attribute to random value\n  6 mem_i32[obj_start_32 + i + 1] = temp; \n\n // random value between -2 and 2\n  7 temp = (Math.round(Math.random() * 4) - 2); \n\n // set x velocity to random value\n  8 mem_i32[obj_start_32 + i + 2] = temp; \n\n // random value between -2 and 2\n  9 temp = (Math.round(Math.random() * 4) - 2);  \n\n // set y velocity to random value\n a mem_i32[obj_start_32 + i + 3] = temp; \n}\n...\n```", "```\n...\n1 var animation_wasm; // the webassembly function we will call every frame\n\n2 function animate() {\n  3 animation_wasm();\n  4 ctx.putImageData(image_data, 0, 0); // render pixel data\n 5 requestAnimationFrame(animate);\n  }\n...\n```", "```\n...\n(async () => {\n  let obj = await\n  1 WebAssembly.instantiateStreaming( fetch('collide.wasm'),\n                                     importObject );\n  2 animation_wasm = obj.instance.exports.main;\n  3 requestAnimationFrame(4animate);\n})();\n</script>\n</body>\n</html>\n```", "```\n(module\n1 (global $cnvs_size    (import \"env\" \"cnvs_size\")    i32)\n\n2 (global $no_hit_color (import \"env\" \"no_hit_color\") i32)\n  (global $hit_color    (import \"env\" \"hit_color\")    i32)\n3 (global $obj_start    (import \"env\" \"obj_start\")    i32)\n4 (global $obj_size     (import \"env\" \"obj_size\")     i32)\n5 (global $obj_cnt      (import \"env\" \"obj_cnt\")      i32)\n\n6 (global $x_offset     (import \"env\" \"x_offset\")     i32)  ;; bytes 00-03\n  (global $y_offset     (import \"env\" \"y_offset\")     i32)  ;; bytes 04-07\n7 (global $xv_offset    (import \"env\" \"xv_offset\")    i32)  ;; bytes 08-11\n  (global $yv_offset    (import \"env\" \"yv_offset\")    i32)  ;; bytes 12-15\n 8 (import \"env\" \"buffer\" (memory 80))                       ;; canvas buffer\n...\n```", "```\n...\n;; clear the entire canvas\n(func $clear_canvas \n  (local $i       i32)\n  (local $pixel_bytes  i32)\n\n  global.get $cnvs_size\n  global.get $cnvs_size\n  i32.mul                  ;; multiply $width and $height\n\n  i32.const 4\n  i32.mul                  ;; 4 bytes per pixel\n\n1 local.set $pixel_bytes   ;; $pixel_bytes = $width * $height * 4\n\n2 (loop $pixel_loop\n  3 (i32.store (local.get $i) (i32.const 0xff_00_00_00)) \n\n    (i32.add (local.get $i) (i32.const 4))\n  4 local.set $i           ;; $i += 4 (bytes per pixel)\n\n ;; if $i < $pixel_bytes\n 5 (i32.lt_u (local.get $i) (local.get $pixel_bytes)) \n  6 br_if $pixel_loop ;; break loop if all pixels set\n  )\n)\n...\n```", "```\n...\n;; this function returns an absolute value when a value is passed in\n(func $abs \n  (param $value       i32) \n  (result             i32)\n\n1 (i32.lt_s (local.get $value) (i32.const 0)) ;; is $value negative?\n2 if ;; if $value is negative subtract it from 0 to get the positive value\n    i32.const 0\n    local.get $value\n  3 i32.sub\n  4 return\n  end\n5 local.get $value  ;; return original value\n)\n...\n```", "```\n...\n;; this function sets a pixel at coordinates $x, $y to the color $c\n(func $set_pixel\n  (param $x       i32)    ;; x coordinate\n  (param $y       i32)    ;; y coordinate\n  (param $c       i32)    ;; color value\n\n ;; is $x > $cnvs_size\n  1 (i32.ge_u (local.get $x) (global.get $cnvs_size)) \n  if    ;; $x is outside the canvas bounds\n    return\n  end\n\n2 (i32.ge_u (local.get $y) (global.get $cnvs_size))  ;; is $y > $cnvs_size\n  if    ;; $y is outside the canvas bounds\n    return\n  end\n\n  local.get $y\n  global.get $cnvs_size\n3 i32.mul\n\n  local.get $x\n4 i32.add       ;; $x + $y * $cnvs_size (get pixels into linear memory)\n\n  i32.const 4\n5 i32.mul       ;; multiply by 4 because each pixel is 4 bytes\n\n  local.get $c  ;; load color value\n\n6 i32.store     ;; store color in memory location\n)\n...\n```", "```\n...\n;; draw multi pixel object as a square given coordinates $x, $y and color $c\n(func $draw_obj \n  (param $x i32)    ;; x position of the object\n  (param $y i32)    ;; y position of the object\n  (param $c i32)    ;; color of the object     \n\n  (local $max_x       i32)\n  (local $max_y       i32)\n\n  (local $xi          i32)\n  (local $yi          i32)\n\n  local.get $x\n1 local.tee $xi\n  global.get $obj_size\n  i32.add\n2 local.set $max_x        ;; $max_x = $x + $obj_size\n\n  local.get $y\n  local.tee $yi\n  global.get $obj_size\n  i32.add\n3 local.set $max_y        ;; $max_y = $y + $obj_size\n\n  (block $break (loop $draw_loop \n\n    local.get $xi\n    local.get $yi\n    local.get $c\n  4 call $set_pixel     ;; set pixel at $xi, $yi to color $c\n\n    local.get $xi\n    i32.const 1\n    i32.add\n  5 local.tee $xi       ;; $xi++\n\n    local.get $max_x\n  6 i32.ge_u            ;; is $xi >= $max_x\n\n    if\n      local.get $x\n    7 local.set $xi     ;; reset $xi to $x\n\n      local.get $yi\n      i32.const 1\n      i32.add\n    8 local.tee $yi     ;; $yi++\n\n      local.get $max_y\n    9 i32.ge_u          ;; is $yi >= $max_y\n\n br_if $break\n\n    end\n    br $draw_loop\n  ))\n)\n...\n```", "```\n...\n;; set the attribute of an object in linear memory using the object number,\n;; the attributes offset and a value used to set the attribute\n(func $set_obj_attr\n  (param $obj_number  i32)\n  (param $attr_offset i32)\n  (param $value       i32)\n\n  local.get $obj_number\n\n i32.const 16\n1 i32.mul                 ;;  16 byte stride multiplied by the object number \n\n  global.get $obj_start   ;;  add the starting byte for the objects (base)\n2 i32.add                 ;;  ($obj_number*16) + $obj_start\n\n  local.get $attr_offset  ;; add the attribute offset to the address\n3 i32.add                 ;; ($obj_number*16) + $obj_start + $attr_offset\n\n  local.get $value\n\n ;; store $value at location ($obj_number*16)+$obj_start+$attr_offset\n4 i32.store  \n)\n...\n```", "```\n...\n;; get the attribute of an object in linear memory using the object\n;; number, and the attributes offset\n(func $get_obj_attr\n  (param $obj_number  i32)\n (param $attr_offset i32)\n  (result i32)\n\n  local.get $obj_number\n  i32.const 16\n1 i32.mul                  ;; $obj_number * 16\n\n  global.get $obj_start\n2 i32.add                  ;; ($obj_number*16) + $obj_start\n\n  local.get $attr_offset\n3 i32.add                  ;; ($obj_number*16) + $obj_start + $attr_offset\n\n4 i32.load                 ;; load the pointer above\n ;; returns the attribute\n)\n...\n```", "```\n...\n;; move and detect collisions between all of the objects in our app\n(func $main (export \"main\")\n1 (local $i           i32) ;; outer loop index\n  (local $j           i32) ;; inner loop index\n2 (local $outer_ptr   i32) ;; pointer to outer loop object\n  (local $inner_ptr   i32) ;; pointer to inner loop object\n\n3 (local $x1          i32) ;; outer loop object x coordinate\n  (local $x2          i32) ;; inner loop object x coordinate\n  (local $y1          i32) ;; outer loop object y coordinate\n  (local $y2          i32) ;; inner loop object y coordinate\n\n4 (local $xdist       i32) ;; distance between objects on x axis\n  (local $ydist       i32) ;; distance between objects on y axis\n\n5 (local $i_hit       i32) ;; i object hit boolean flag\n6 (local $xv          i32) ;; x velocity\n  (local $yv          i32) ;; y velocity\n\n7 (call $clear_canvas) ;; clear the canvas to black\n...\n```", "```\n...\n1 (loop $move_loop\n    ;; get x attribute\n    (call $get_obj_attr (local.get $i) (global.get $x_offset))\n    local.set $x1\n\n    ;; get y attribute\n    (call $get_obj_attr (local.get $i) (global.get $y_offset)) \n    local.set $y1\n\n    ;; get x velocity attribute\n    (call $get_obj_attr (local.get $i) (global.get $xv_offset)) \n    local.set $xv\n ;; get y velocity attribute\n    (call $get_obj_attr (local.get $i) (global.get $yv_offset)) \n    local.set $yv\n\n    ;; add velocity to x and force it to stay in the canvas bounds\n  2 (i32.add (local.get $xv) (local.get $x1))\n    i32.const 0x1ff  ;; 511 in decimal\n  3 i32.and          ;; clear high-order 23 bits\n    local.set $x1\n\n    ;; add velocity to y and force it to stay in the canvas bounds\n    (i32.add (local.get $yv) (local.get $y1))\n    i32.const 0x1ff  ;; 511 in decimal\n    i32.and          ;; clear high-order 23 bits\n  4 local.set $y1\n\n    ;; set the x attribute in linear memory\n  5 (call $set_obj_attr \n    (local.get $i) \n    (global.get $x_offset)\n    (local.get $x1)\n  )\n\n    ;; set the y attribute in linear memory\n    (call $set_obj_attr \n    (local.get $i) \n    (global.get $y_offset)\n    (local.get $y1)\n  )\n\n  local.get $i\n  i32.const 1\n6 i32.add\n7 local.tee $i        ;; increment $i\n\n  global.get $obj_cnt\n  i32.lt_u            ;; $i < $obj_cnt\n\n8 if  ;; if $i < $obj_count branch back to top of $move_loop\n    br $move_loop\n  end\n\n )\n\n  i32.const 0\n9 local.set $i\n...\n```", "````The `loop` will add the velocity variables (`$xv` and `$yv`) to the position variables `($x1` and `$y1`) with a call to `i32.add` 2. Before `$x1` is set to the new position, an `i32.and` 3 is used to mask the last nine bits of the `x` position. This holds the value of the x-coordinate between 0 and 511, wrapping the value back around to 0 if it exceeds 511\\. The same is then done for `$y1` 4 to set the `y` position. Once the new values of `$x1` and `$y1` are set, the `$set_obj_attr` 5 function is called for those values to set them in linear memory. The loop counter `$i` 6 is incremented with a call to `i32.and` and `local.tee` 7. If the value in `$i` is less than the object count (`$obj_count` 8), the code branches back to the top of the `loop`. Otherwise, `local.set` 9 is called to set `$i` to `0`.    The squares in [Listing 8-14](#listing8-14) wrap around on the canvas so when one goes offscreen on the right, it loops back around and appears on the left side of the screen, as in the old-school arcade games. Games like Atari’s *Asteroids* and Namco’s *Pac-Man* didn’t need any extra code to have this effect; instead, their screens were 256 pixels wide and used an 8-bit number to store the x-coordinate. So if a game object had an x-coordinate of 255 and moved one pixel to the right, the single byte value would roll back over to 0, and the game object would reappear on the left side of the screen, as shown in [Figure 8-6](#figure8-6).  ![f08006](Images/f08006.png)    Figure 8-6: Player’s character goes off the screen to the right and appears on the left.      We can accomplish this effect using `i32.and` to mask all but the bottom nine bits. The code calls `$get_obj_attr` to get the attributes for `$x1`, `$y1`, `$xv`, and `$yv` 1. The new `$x1` value is calculated by adding `$xv` 2 and then using the `i32.and` 3 against the constant `0x1ff`. In binary, `0x1ff` has the lowest nine bits all set to 1, and all the higher bits are set to 0\\. Chapter 4 explained how to use an `i32.and` to set specific bits to 0, as illustrated in [Figure 8-7](#figure8-7).  ![f08007](Images/f08007.png)    Figure 8-7: The 0s in our mask turn any values in the initial value to 0.      When we call `i32.and` 3 on `$x1` and `0x1ff` (binary 00000000000000000000000111111111), the resulting value has the top 23 bits set to 0\\. That limits the `$x1` value to nine bits, so if the number goes above what a 9-bit number can hold, the `$x1` value rolls back over, similar to an odometer. That creates an old-school arcade effect where objects that move offscreen to the left reappear on the right, and objects that move offscreen on the top reappear on the bottom of the screen.    After making changes to the x- and y-coordinates, the `$i` index is incremented 8, and if `$i` is less than `$obj_count`, the code branches back to the top of the `$move_loop`. When the loop is complete, the `$i` 9 index variable is reset to `0`.    #### Beginning of the Outer Loop    Now we need to define our double loop, which compares every object against every other object to see whether any collisions have occurred. The next part of the `$main` function defines the outer loop of our double loop, which will determine the first object of our collision test. The loop begins by initializing `$j` to `0`. The `$i` local variable is the increment variable for the outer loop. The inner loop will use `$j` to loop through all the objects to check each one against `$i` until it finds a collision or makes its way through every object. The outer loop starts with the first object, and then the inner loop checks that object for a collision with every other object. This continues until the outer loop has checked every object. Add the code in [Listing 8-15](#listing8-15) to the `$main` function.    **collide.wat (part 10 of 12)**    ``` ...   (loop $outer_loop (block $outer_break     i32.const 0   1 local.tee $j        ;; setting j to 0      ;; $i_hit is a boolean value.  0 for false, 1 for true   2 local.set $i_hit    ;; setting i_hit to 0      ;; get x attribute for object $i     (call $get_obj_attr (local.get $i) (global.get $x_offset))   3 local.set $x1      ;; get y attribute for object $i     (call $get_obj_attr (local.get $i) (global.get $y_offset))   4 local.set $y1 ... ```    Listing 8-15: The outer loop of a collision detection double loop    The beginning of the loop resets `$j` 1 and `$i_hit` 2 to `0`. The code then calls the `$get_obj_attr` function to find the values for `$x1` 3 and `$y1` 4.    #### The Inner Loop    The next section of the `$main` function is the inner loop, whose function is to detect a collision between two squares. Square collision detection is very simple: you compare the x-coordinates and size to see whether the objects overlap on the x-axis. If the x-axis doesn’t overlap but the y-axis does, it looks like [Figure 8-8](#figure8-8) and has no collision.    If the x-axis overlaps but the y-axis doesn’t, there is no collision between the objects, as in [Figure 8-9](#figure8-9).  ![f08008](Images/f08008.png)    Figure 8-8: The x-axis doesn’t overlap but the y-axis does.    ![f08009](Images/f08009.png)    Figure 8-9: The x-axis overlaps but the y-axis doesn’t.      The only collision scenario is when the x-axis and y-axis overlap, as in [Figure 8-10](#figure8-10).  ![f08010](Images/f08010.png)    Figure 8-10: The x-axis and y-axis overlap, so there is a collision.      The inner loop performs this check against every object in linear memory. [Listing 8-16](#listing8-16) shows the code.    **collide.wat (part 11 of 12)**    ``` ... 1 (loop $inner_loop (block $inner_break       local.get $i       local.get $j       i32.eq     2 if              ;; if $i == $j increment $j         local.get $j         i32.const 1         i32.add         local.set $j       end        local.get $j       global.get $obj_cnt       i32.ge_u     3 if              ;; if $j >= $obj_count break from inner loop         br $inner_break       end   ;; get x attribute     4 (call $get_obj_attr (local.get $j)(global.get $x_offset))        local.set $x2  ;; set the x attribute for inner loop object   ;; distance between $x1 and $x2       (i32.sub (local.get $x1) (local.get $x2))        call $abs  ;; distance is not negative so get the absolute value     5 local.tee $xdist  ;; $xdist = the absolute value of ($x1 - $x2)        global.get $obj_size       i32.ge_u       6 if  ;; if $xdist >= $obj_size object does not collide         local.get $j         i32.const 1         i32.add         local.set $j          br $inner_loop  ;; increment $j and jump to beginning of inner loop       end   ;; get y attribute       (call $get_obj_attr (local.get $j)(global.get $y_offset))       local.set $y2        (i32.sub (local.get $y1) (local.get $y2))       call $abs     7 local.tee $ydist        global.get $obj_size       i32.ge_u       8 if         local.get $j         i32.const 1         i32.add         local.set $j          br $inner_loop       end        i32.const 1     9 local.set $i_hit  ;; exit the loop if there is a collision   )) ;; end of inner loop ... ```    Listing 8-16: The inner loop of a collision detection double loop    The inner `loop` 1 compares the current object of the outer loop against every other object that hasn’t already been checked against it. First, it needs to make sure it’s not checking an object against itself. An object always completely collides with itself, so if `$i` is equal to `$j` 2, we ignore it and need to increment `$j`. Then we compare `$j` with `$obj_cnt` 3 to see whether the code has tested all the objects yet. If it has, the code exits the inner `loop`  .  If the code hasn’t tested all objects, the `x` attribute is loaded into the `$x2` variable by calling `$get_obj_attr` 4. We then get the distance between `$x1` and `$x2` by subtracting `$x2` from `$x1`, taking the absolute value and setting the `$xdist` 5 variable. We compare the `x` distance between the two objects to the object size to see whether the two objects overlap on the x-axis. If they don’t overlap because `$xdist` is greater than `$obj_size` 6, the code increments `$j` and jumps back to the top of the `loop`.    In the same way, the `y` distance is calculated and stored in the `$ydist` 7 variable, and the code checks whether the `$ydist` variable is greater than `$obj_size` 8. If so, these objects don’t collide, so we increment `$j` and jump back to the top of the `loop`. If we haven’t jumped to the top of the loop at this point, we know that the x- and y-axis of the objects overlap, indicating a collision, so we set `$i_hit` 9 to `1` and exit the inner `loop`.    #### Redrawing the Objects    When the code has exited the inner loop, either a collision was found or it wasn’t. The code checks the hit variable (`$i_hit`) and calls the `$draw_obj` function with the no collision color (green) if there wasn’t a collision and with the `$hit_color` (red) if there was a collision. Then `$`i is incremented, and if `$i` is less than the number of objects, the code jumps back to the top of the outer loop. [Listing 8-17](#listing8-17) shows the last section of code to add to the WAT file.    **collide.wat (part 12 of 12)**    ``` ...     local.get $i_hit     i32.const 0     i32.eq   1 if      ;; if $i_hit == 0 (no hit)       (call $draw_obj         (local.get $x1) (local.get $y1)  (global.get $no_hit_color))   2 else    ;; if $i_hit == 1 (hit)       (call $draw_obj         (local.get $x1) (local.get $y1) (global.get $hit_color))     end      local.get $i     i32.const 1     i32.add   3 local.tee $i          ;; increment $i      global.get $obj_cnt     i32.lt_u   4 if                    ;; if $i < $obj_cnt jump to top of the outer loop       br $outer_loop     end 5 )) ;; end of outer loop ) ;; end of function ) ;; end of module ```    Listing 8-17: Drawing the object inside the inner loop    Immediately after the inner loop ends, the outer loop checks whether the `$i_hit` variable was set to `0` 1 , indicating no collision. If it was, `$draw_obj` is called, passing in the `$no_hit_color` global variable as the last parameter and drawing the square in green. If the `$i_hit` variable is set to `1` 2 (true), `$draw_obj` is called with `$hit_color` (red). At this point, `$i` 3 is incremented, and if it’s less than `$obj_cnt` 4, indicating we’ve not completed drawing our objects, the code jumps back to the top of the loop. If not 5, the code exits the loop and this function is complete.    ### Compiling and Running the App    Before we run the collider application, we need to compile our WAT into a WebAssembly module. Use the following `wat2wasm` command to compile *collide.wat* into *collide.wasm*:    ``` wat2wasm collide.wat ```    When you run a web server and open the *collide.html* file in a web browser from localhost, your screen should look similar to [Figure 8-11](#figure8-11).  ![f08011](Images/f08011.png)    Figure 8-11: The collider app      The boxes should move about the canvas, appearing on the left side of the canvas when they move off the right side and on the top when they move off the bottom. Boxes that collide with each other appear in red, and boxes that don’t collide with other boxes appear in green.    ## Summary    In this chapter, we explored how WebAssembly and the HTML canvas can work together to create fantastic animations on a web page. You should now understand when it’s best to use WebAssembly and when using JavaScript is a better option. Rendering to the canvas from WebAssembly can be done quickly and efficiently by modifying memory locations that represent bitmap data. The collider app we created used many JavaScript constants to define its details. That allowed us to tweak and play with the numbers in the app without recompiling the WebAssembly module. JavaScript can easily generate random numbers that we can use in the app. Generating random numbers from WebAssembly is much more challenging. Because the random numbers only need to be generated once, using JavaScript isn’t a significant performance hit.    You learned about bitmap image data and how to use WebAssembly to generate that image data inside linear memory. We used the `requestAnimationFrame` function from within JavaScript to call the WebAssembly module once per frame, using WebAssembly to generate the bitmap image data to be used in the canvas. This image data is moved into the HTML canvas using the `putImageData` function on the canvas context.    In the WAT module code, we set up and modified an area of memory dedicated to the image data, and created a canvas clearing function. We drew a specific pixel color to the canvas; then we drew objects larger than a single pixel and made those objects appear at the opposite side of the canvas when they moved out of the element’s bounds. Lastly, we used box collision detection to detect and change the color of our objects if there were collisions between objects.    We didn’t spend a lot of time or effort trying to make the collider application fast. In the next chapter, we’ll make this application run as fast as possible with some performance tuning.````"]