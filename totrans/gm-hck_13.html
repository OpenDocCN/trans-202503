<html><head></head><body>
<h2 class="h2c" id="ch09"><span epub:type="pagebreak" id="page_189"/><span class="big1"><strong>9</strong></span><br/><strong>USING EXTRASENSORY PERCEPTION TO WARD OFF FOG OF WAR</strong></h2>&#13;
<div class="image"><img src="../images/common.jpg" alt="image"/></div>&#13;
<p class="noindent"><em>Fog of war</em> (often shortened to just <em>fog</em>) is a mechanism that game developers commonly use to limit a player’s situational awareness and hide information about the game environment. Fog is often a literal lack of sight in massive online battle arena (MOBA) games, but the concept also includes any lack or obscurity of pertinent gameplay information. Cloaked figures, dark rooms, and enemies hiding behind walls are all forms of fog.</p>&#13;
<p class="indent">Game hackers can reduce or even completely remove fog using an <em>extrasensory perception (ESP)</em> hack. An ESP hack uses hooking, memory manipulation, or both to force a game to display hidden information. These hacks take advantage of the fact that some types of fog are often implemented on the client side, as opposed to the server side, meaning that the game clients still contain information (partial or complete) about what is being hidden.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_190"/>In this chapter, you will learn how to implement different types of ESP hacks. First, you’ll learn to light up dark environments. Next, you’ll use x-ray vision to see through walls. Finally, you’ll learn about zoom hacking, tweaking heads-up displays, and other simple ESP hacks that can reveal all sorts of useful (but otherwise hidden) information about the game you’re playing.</p>&#13;
<h3 class="h3" id="ch00lev1sec184"><strong>Background Knowledge</strong></h3>&#13;
<p class="noindent">This chapter starts the transition from hacking, puppeteering, and reverse engineering to coding. From here on out, you’ll be learning how to actually code your own hacks. To keep on topic, everything I’ve talked about thus far will be treated as background knowledge. If you see a technique used that you don’t quite remember, such as memory scanning, setting memory breakpoints, hooking, or writing memory, flip back to the relevant chapters and study them a bit more before continuing. Throughout the text, you’ll find notes to remind you where you can brush up on certain topics.</p>&#13;
<p class="indent">Specifically, this chapter will talk a lot about Direct3D. In “<a href="ch08.xhtml#ch00lev1sec174">Applying Jump Hooks and VF Hooks to Direct3D</a>” on <a href="ch08.xhtml#page_175">page 175</a>, I explained how to hook into a game’s Direct3D drawing loop. The example code for that chapter includes a fully featured Direct3D hooking engine in <em>GameHackingExamples/Chapter8_Direct3DHook</em>. A lot of the hacks in this chapter build on that hook, and their example code can be found in the <em>main.cpp</em> file of the Direct3D hook code. You can run the compiled application from <em>GameHackingExamples/Chapter8_Direct3DApplication</em> to see the hacks in action on a test application.</p>&#13;
<h3 class="h3" id="ch00lev1sec185"><strong>Revealing Hidden Details with Lighthacks</strong></h3>&#13;
<p class="noindent"><em>Lighthacks</em> increase lighting in dark environments, allowing you to clearly see enemies, treasure chests, pathways, and anything else that is normally obscured by darkness. Lighting is often a cosmetic change that’s added at a game’s graphical layer, and it can usually be directly modified with a hook on the graphics layer.</p>&#13;
<p class="indent">Optimal lighting depends on camera orientation, environment layout, and even specific traits of a game’s engine, and you can manipulate any of these factors to create lighthacks. But the easiest way is simply to add more light to a room.</p>&#13;
<h4 class="h4" id="ch00lev1sec186"><strong><em>Adding a Central Ambient Light Source</em></strong></h4>&#13;
<p class="noindent">The online resources for this book include two small lighthack examples. The first is the <span class="literal">enableLightHackDirectional()</span> function in <em>main.cpp</em>, which is shown in <a href="ch09.xhtml#ch9exe1">Listing 9-1</a>.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_191"/>void enableLightHackDirectional(LPDIRECT3DDEVICE9 pDevice)<br/>{<br/>    D3DLIGHT9 light;<br/>    ZeroMemory(&amp;light, sizeof(light));<br/>    light.Type = D3DLIGHT_DIRECTIONAL;<br/>    light.Diffuse = D3DXCOLOR(0.5f, 0.5f, 0.5f, 1.0f);<br/>    light.Direction = D3DXVECTOR3(-1.0f, -0.5f, -1.0f);<br/><br/>    pDevice-&gt;SetLight(0, &amp;light);<br/>    pDevice-&gt;LightEnable(0, TRUE);<br/>}When you know how much experience you</p>&#13;
<p class="listt"><a id="ch9exe1"/><em>Listing 9-1: A directional lighthack</em></p>&#13;
<p class="indent">This code is called from the <span class="literal">EndScene()</span> hook, and it adds light to the scene by creating a light source called <span class="literal">light</span>. The code sets <span class="literal">light.Type</span> to directional, which means the light source will act like a spotlight and project light in a specific direction. The code then sets the red, green, and blue values of <span class="literal">light.Diffuse</span> to 0.5, 0.5, and 0.5, giving the light an off-white shine when reflected from a surface. Next, it sets <span class="literal">light.Direction</span> to an arbitrary point in the three-dimensional space. Finally, the code uses the game’s Direct3D device to set up the light at index 0 and enable lighting effects.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In the example application, the light shines up and to the right from the bottom left of the scene. You may need to change this location depending on how your target game is rendered.</em></p>&#13;
</div>&#13;
<p class="indent">Note that inserting the light at index 0 works for this proof of concept, but it won’t always work. Games typically have multiple light sources defined, and setting your light at an index the game uses might override critical lighting effects. In practice, you might try setting the index to an arbitrarily high number. There’s an issue with this type of lighthack, though: directional lights will be blocked by objects such as walls, creatures, and terrain, meaning shadows can still be cast. Directional lights work great for wide-open spaces, but not so well for tightly wound corridors or underground caves.</p>&#13;
<h4 class="h4" id="ch00lev1sec187"><strong><em>Increasing the Absolute Ambient Light</em></strong></h4>&#13;
<p class="noindent">The other lighthack method, seen in the <span class="literal">enableLightHackAmbient()</span> function, is far more aggressive than the one in <a href="ch09.xhtml#ch9exe1">Listing 9-1</a>. It affects the light level globally, rather than adding an extra light source. Here’s what the code looks like:</p>&#13;
<p class="programs">void enableLightHackAmbient(LPDIRECT3DDEVICE9 pDevice)<br/>{<br/>    pDevice-&gt;SetRenderState(D3DRS_AMBIENT, D3DCOLOR_XRGB(100, 100, 100));<br/>}</p>&#13;
<p class="indent">This lighthack sets the absolute ambient light (which you indicate by passing <span class="literal">D3DRS_AMBIENT</span> to the <span class="literal">SetRenderState()</span> function) to a medium-strength white. The <span class="literal">D3DCOLOR_XRGB</span> macro sets that strength, taking <span class="literal">100</span> as <span epub:type="pagebreak" id="page_192"/>its parameters for the red, green, and blue levels. This lights up objects using an omnidirectional white light, effectively revealing everything at the cost of shadows and other lighting-based details.</p>&#13;
<h4 class="h4" id="ch00lev1sec188"><strong><em>Creating Other Types of Lighthacks</em></strong></h4>&#13;
<p class="noindent">There are many other ways to create lighthacks, but they differ from game to game. One creative way to affect the light in a game is to NOP the code that the game uses to call the <span class="literal">device-&gt;SetRenderState()</span> function. Since this function is used to set up the global ambient light strength, disabling calls to it leaves Direct3D at the default light settings and makes everything visible. This is perhaps the most powerful type of lighthack, but it requires your bot to know the address of the lighting code to NOP.</p>&#13;
<p class="indent">There are also memory-based lighthacks. In some games, players and creatures emit light of different colors and strengths, often depending on attributes like their equipment, mount, or active spells. If you understand the structure of the game’s creature list, you can directly modify the values that determine a creature’s light level.</p>&#13;
<p class="indent">For instance, imagine a game in which characters emit a bluish ball of light when under a healing or strengthening spell. Somewhere in the game’s memory are values associated with each creature that tell the game the color and intensity of light the creature should emit. If you can locate these values in memory, you can change them so that the creatures effectively emit orbs of light. This type of lighthack is commonly used in games with a 2D top-down style, since the orbs around individual creatures produce a cool artistic effect while shedding light on important parts of the screen. In 3D games, however, this sort of hack just turns creatures into blobs of light that run around.</p>&#13;
<p class="indent">You can also hook the <span class="literal">SetLight()</span> member function at index 51 in the VF table of the game’s Direct3D device. Then, whenever your hook callback is invoked, you can modify the properties of the intercepted <span class="literal">D3DLIGHT9</span> light structure before passing it to the original function. You might, for instance, change all lights to the <span class="literal">D3DLIGHT_POINT</span> type, causing any existing light sources in the game to radiate light in every direction like a light bulb. This type of lighthack is very powerful and accurate, but it can produce some disturbing visuals. It also tends to break in any environment that has no lighting, and opaque obstacles still block point light sources.</p>&#13;
<p class="indent">Lighthacks are very powerful, but they don’t reveal anything. If information is hidden behind an obstacle, rather than by darkness, you’ll need a wallhack to reveal it.</p>&#13;
<h3 class="h3" id="ch00lev1sec189"><strong>Revealing Sneaky Enemies with Wallhacks</strong></h3>&#13;
<p class="noindent">You can use <em>wallhacks</em> to show enemies that are hidden by walls, floors, and other obstacles. There are a few ways to create these hacks, but the most common method takes advantage of a type of rendering known as <em>z-buffering</em>.</p>&#13;
<h4 class="h4" id="ch00lev1sec190"><span epub:type="pagebreak" id="page_193"/><strong><em>Rendering with Z-Buffering</em></strong></h4>&#13;
<p class="noindent">Most graphics engines, including Direct3D, support z-buffering, which is a way to make sure that when there are overlapping objects in a scene, only the top object is drawn. Z-buffering works by “drawing” the scene to a two-dimensional array that describes how close the object at each pixel on the screen is to the viewer. Think of the array’s indices as axes: they correspond to the x-axis (right and left) and y-axis (up and down) for each pixel on the screen. Each value stored in the array is the z-axis value for a pixel.</p>&#13;
<p class="indent">When a new object appears, whether it is actually drawn on the screen is decided by the z-buffer array. If the spot at the object’s x- and y-position is already filled in the array, that means there’s another object at that pixel on the screen. The new object will appear only if it has a lower z-axis value (that is, if it’s closer to the viewer) than the pixel already there. When the scene is finished being drawn to the array, it is flushed to the screen.</p>&#13;
<p class="indent">To illustrate this, imagine a three-dimensional space that needs to be drawn to a two-dimensional canvas by some game with 4×4-pixel viewport. The z-buffer for this scenario would look like <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>.</p>&#13;
<div class="image"><img src="../images/f09-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch9fig1"/><em>Figure 9-1: An empty z-buffer</em></p>&#13;
<p class="indent">To start, the game draws a blue background that completely fills the viewport and is located as far away on the z-axis as possible; let’s say the highest z-value is 100. Next, the game draws a 2×2-pixel red rectangle at <span epub:type="pagebreak" id="page_194"/>position (0,0) with a z-position of 5. Finally, the game draws a 2×2-pixel green rectangle at position (1,1) with a z-position of 3. The z-buffer would now look like <a href="ch09.xhtml#ch9fig2">Figure 9-2</a>.</p>&#13;
<div class="image"><img src="../images/f09-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch9fig2"/><em>Figure 9-2: A filled z-buffer</em></p>&#13;
<p class="indent">The z-buffer neatly handled overlapping objects based on their z-positions. The green square that’s closest on the z-axis overlaps the red square that’s a bit farther away, and both squares overlap the blue background, which is very far away.</p>&#13;
<p class="indent">This behavior allows a game to draw its map, players, creatures, details, and particles without worrying about what is actually visible to the player. This is a huge optimization for game developers, but it exposes a large area of attack. Since all game models are <em>always</em> given to the graphics engine, you can use hooks to detect objects that the player can’t actually see.</p>&#13;
<h4 class="h4" id="ch00lev1sec191"><strong><em>Creating a Direct3D Wallhack</em></strong></h4>&#13;
<p class="noindent">You can create wallhacks that manipulate z-buffering in Direct3D using a hook on the <span class="literal">DrawIndexedPrimitive()</span> function, which is called when a game draws a 3D model to the screen. When an enemy player model is drawn, a wallhack of this type disables z-buffering, calls the original function to draw the model, and then reenables z-buffering. This causes the enemy model to be drawn on top of everything else in the scene, regardless of what’s in front of it. Some wallhacks can also render specific models in a solid color, such as red for enemies and green for allies.</p>&#13;
<h5 class="h5" id="ch00lev1sec192"><span epub:type="pagebreak" id="page_195"/><strong>Toggling Z-Buffering</strong></h5>&#13;
<p class="noindent">The Direct3D hook in <em>main.cpp</em> from <em>GameHackingExamples/Chapter8_ Direct3DHook</em> has this example wallhack in the <span class="literal">onDrawIndexedPrimitive()</span> function:</p>&#13;
<p class="programs">void onDrawIndexedPrimitive(<br/>    DirectXHook* hook,<br/>    LPDIRECT3DDEVICE9 device,<br/>    D3DPRIMITIVETYPE primType,<br/>    INT baseVertexIndex, UINT minVertexIndex,<br/>    UINT numVertices, UINT startIndex, UINT primCount)<br/>{<br/>    if (numVertices == 24 &amp;&amp; primCount == 12) {<br/>        // it's an enemy, do the wallhack<br/>    }<br/>}</p>&#13;
<p class="indent">This function is used as a callback for a hook on <span class="literal">DrawIndexedPrimitive()</span> at VF index 82 of the game’s Direct3D device. Every model the game draws passes through this function, accompanied by some model-specific properties. By inspecting a subset of the properties, namely the <span class="literal">numVertices</span> and <span class="literal">primCount</span> values, the hook detects when an enemy model is drawn and commences the wallhack. In this example, the values representing an enemy model are <span class="literal">24</span> and <span class="literal">12</span>.</p>&#13;
<p class="indent">The magic happens inside the <span class="literal">if()</span> statement. Using just a few lines of code, the wallhack draws the model in a way that ignores z-buffering, like so:</p>&#13;
<p class="programs">device-&gt;SetRenderState(D3DRS_ZENABLE, false); // disable z-buffering<br/>DirectXHook::origDrawIndexedPrimitive(        // draw model<br/>    device, primType, baseVertexIndex,<br/>    minVertexIndex, numVertices, startIndex, primCount);<br/>device-&gt;SetRenderState(D3DRS_ZENABLE, true);  // enable z-buffering</p>&#13;
<p class="indent">Simply put, this code disables z-buffering when drawing the enemy model and reenables it afterward. With z-buffering off, the enemy is drawn in front of everything.</p>&#13;
<h5 class="h5" id="ch00lev1sec193"><strong>Changing an Enemy Texture</strong></h5>&#13;
<p class="noindent">When a model is rendered onscreen, a <em>texture</em> is used to skin the model. Textures are 2D images that are stretched around 3D models to apply the colors and patterns that make up the model’s 3D artwork. To change the way an enemy looks when it’s drawn in your wallhack, you can set it to be drawn with a different texture, as in this example:</p>&#13;
<p class="programs">// when hook initializes<br/>LPDIRECT3DTEXTURE9 red;<br/>D3DXCreateTextureFromFile(device, "red.png", &amp;red);<br/>// just before drawing the primitive<br/>device-&gt;SetTexture(0, red);</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_196"/>The first block of this code loads the texture from a file and is executed only once—when the hook is initialized. The full example code does this in an <span class="literal">initialize()</span> function, which gets called the first time the <span class="literal">EndScene()</span> hook callback is invoked. The second block of this code happens right before the call to the original <span class="literal">DrawIndexedPrimitive()</span> function in the wallhack, and it causes the model to be drawn with the custom texture.</p>&#13;
<h4 class="h4" id="ch00lev1sec194"><strong><em>Fingerprinting the Model You Want to Reveal</em></strong></h4>&#13;
<p class="noindent">The trickiest part to creating a good wallhack is finding the right values for <span class="literal">numVertices</span> and <span class="literal">primCount</span>. To do this, you can create a tool that logs every unique combination of the two variables and allows you to iterate over the list using your keyboard. Working example code for this tool won’t be useful in the example application provided with this chapter, but I’ll give you some high-level implementation details.</p>&#13;
<p class="indentb">First, in the global scope, you’d declare a structure that has members to store the following:</p>&#13;
<p class="bull">• <span class="literal">numVertices</span> and <span class="literal">primCount</span></p>&#13;
<p class="bull">• A <span class="literal">std::set</span> of this structure (let’s call it <span class="literal">seenParams</span>)</p>&#13;
<p class="bull">• An instance of that structure (let’s call it <span class="literal">currentParams</span>)</p>&#13;
<p class="indentt">The <span class="literal">std::set</span> requires a comparator for this structure, so you’d also declare a comparison functor that calls <span class="literal">memcmp()</span> to compare two of the structures using <span class="literal">memcmp()</span>. Each time the <span class="literal">DrawIndexedPrimitive()</span> callback is invoked, your hack could create a structure instance with the intercepted values and pass it to a <span class="literal">seenParams.insert()</span> function, which should insert the parameter pair into the list only if the pair isn’t already there.</p>&#13;
<p class="indent">Using the <span class="literal">GetAsyncKeyState()</span> Windows API function, you could then detect when the spacebar is pressed and execute something similar to this pseudocode:</p>&#13;
<p class="programs">auto current = seenParams.find(currentParam);<br/>if (current == seenParams.end())<br/>    current = seenParams.begin();<br/>else<br/>    current++;<br/>currentParams = *current;</p>&#13;
<p class="indent">This would set <span class="literal">currentParams</span> to the next pair in <span class="literal">seenParams</span> when the spacebar is pressed. With this code in place, you could use code similar to a wallhack to change the texture of models matching <span class="literal">currentParams.numVertices</span> and <span class="literal">currentParams.primCount</span>. The tool could also draw those values on the screen so you could see them and write them down.</p>&#13;
<p class="indent">With a tool like this, finding the proper models is as easy as starting up a game in a mode where your character won’t die (against a friend, in <span epub:type="pagebreak" id="page_197"/>a customization mode, and so on), running the bot, and pressing the spacebar until each model you need is highlighted. Once you have the values for your target models, you’ll modify the <span class="literal">numVertices</span> and <span class="literal">primCount</span> check in your wallhack so it knows which models to highlight.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Character models are commonly made up of smaller models for individual body segments, and games often show different models of a character at different distances. That means a game may have 20 or more models for one type of character. Even in that case, selecting only one model (say, the enemy’s torso) to show in your wallhack may be enough.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec195"><strong>Getting a Wider Field of Vision with Zoomhacks</strong></h3>&#13;
<p class="noindent">Many games in the MOBA and real-time strategy (RTS) genres use a 3D top-down style that makes them immune to wallhacks. They also use darkness on the map as a type of fog, but showing the dark areas using a lighthack doesn’t give any extra information; models hidden inside the fog are known only to the game server, not to the client.</p>&#13;
<p class="indent">This style makes most types of ESP hacks useless: there’s little unknown information to reveal, so these hacks only augment your view of the information you can already see. One type of ESP hack, however, can still be helpful. <em>Zoomhacks</em> let you zoom out much farther than a game normally allows, effectively revealing large portions of the map that you couldn’t see otherwise—and thus getting around the game’s wallhack and lighthack immunity.</p>&#13;
<h4 class="h4" id="ch00lev1sec196"><strong><em>Using NOPing Zoomhacks</em></strong></h4>&#13;
<p class="noindent">MOBA and RTS games typically allow players a variable but limited amount of zoom. The simplest type of zoomhack finds the value of the <em>zoom factor</em> (a multiplier that changes as the zoom level changes, typically a <span class="literal">float</span> or <span class="literal">double</span>) and overwrites it with a larger value.</p>&#13;
<p class="indent">To find the zoom factor, fire up Cheat Engine and search for a <span class="literal">float</span> with an unknown initial value. (To brush up on Cheat Engine, head over to “<a href="ch01.xhtml#ch00lev1sec9">Cheat Engine’s Memory Scanner</a>” on <a href="ch01.xhtml#page_5">page 5</a>.) For rescans, repeat the following process until there are only a few values left to find the zoom factor:</p>&#13;
<ol>&#13;
<li><p class="noindenta">Go to the game window and zoom in.</p></li>&#13;
<li><p class="noindenta">Search for an increased value in Cheat Engine.</p></li>&#13;
<li><p class="noindenta">Go to the game window and zoom out.</p></li>&#13;
<li><p class="noindenta">Search for a decreased value in Cheat Engine.</p></li>&#13;
</ol>&#13;
<p class="indent">Try to get the value list down to one option. To confirm that the remaining value is the zoom factor, freeze it in Cheat Engine and see how zoom behaves in-game; freezing the proper value will disable zooming. If you fail to find the zoom factor using a <span class="literal">float</span> search, retry the search using <span epub:type="pagebreak" id="page_198"/>a <span class="literal">double</span>. If both searches fail, try them again but correspond zooming in with decreased values and zooming out with increased values instead. Once you’ve found the zoom factor in memory, you can write a small bot to overwrite it to the zoom factor that best suits you.</p>&#13;
<p class="indent">More advanced zoomhacks NOP the game code responsible for making sure the zoom factor is within a set range. You should be able to find this code with OllyDbg. Set a memory on-write breakpoint on the zoom factor, zoom in-game to trigger the breakpoint, and inspect the code at the breakpoint. (To hone your OllyDbg memory breakpoint skills, flip to “<a href="ch02.xhtml#ch00lev1sec55">Controlling OllyDbg Through the Command Line</a>” on <a href="ch02.xhtml#page_43">page 43</a>.) You should see the code that modified the zoom factor. Zoom limitation code is typically easy to spot: constants that match the minimum and maximum zoom values are a dead giveaway.</p>&#13;
<p class="indent">If you can’t find the limitation code using this method, then the limitation may be applied when the graphics are redrawn at a new zoom level, rather than when the zoom factor changes. In this case, switch your breakpoint to memory on-read and look for the same clues.</p>&#13;
<h4 class="h4" id="ch00lev1sec197"><strong><em>Scratching the Surface of Hooking Zoomhacks</em></strong></h4>&#13;
<p class="noindent">You can also create zoomhacks by using a Direct3D hook on the function <span class="literal">device-&gt;SetTransform(type, matrix)</span>, but this requires a deep understanding of how a game sets up the player’s perspective. There are a few different ways to manage perspective, but you control zoom level using either <em>view</em> (transform type <span class="literal">D3DTS_VIEW</span>) or <em>projection</em> (transform type <span class="literal">D3DTS_PROJECTION</span>).</p>&#13;
<p class="indent">Properly manipulating transform matrices that control view and projection requires some pretty extensive knowledge of the mathematics behind 3D graphics, though, so I stay away from this method at all costs—and I’ve never had trouble simply manipulating the zoom factor. If you’re interested in this kind of hack, though, I recommend reading a 3D game programming book to learn more about 3D mathematics first.</p>&#13;
<p class="indent">But sometimes, even a zoomhack isn’t enough. Some useful information may remain hidden as a part of a game’s internal state or may simply be hard for a player to determine at a moment’s glance. For these situations, a heads-up display is the tool for the job.</p>&#13;
<h3 class="h3" id="ch00lev1sec198"><strong>Displaying Hidden Data with HUDs</strong></h3>&#13;
<p class="noindent">A <em>heads-up display (HUD)</em> is a type of ESP hack that displays critical game information in an overlay. HUDs often resemble a game’s existing interface for displaying information like your remaining ammunition, a mini-map, your current health level, any active ability cooldowns, and so on. HUDs typically display either historical or aggregated information, and they’re mostly used on MMORPGs. They are often text based, but some also contain sprites, shapes, and other small visual effects.</p>&#13;
<p class="indentb"><span epub:type="pagebreak" id="page_199"/>The HUDs you can create depend on what data is available in the game. Common data points are these:</p>&#13;
<p class="bull">• Experience gain per hour (exp/h)</p>&#13;
<p class="bull">• Creature kills per hour (KPH)</p>&#13;
<p class="bull">• Damage per second (DPS)</p>&#13;
<p class="bull">• Gold looted per hour (GPH)</p>&#13;
<p class="bull">• Healing per minute</p>&#13;
<p class="bull">• Estimated time until next level</p>&#13;
<p class="bull">• Amount of gold spent on supplies</p>&#13;
<p class="bull">• Overall gold value of items looted</p>&#13;
<p class="indentt">More advanced custom HUDs may display large tables containing items looted, supplies used, the number of kills for each type of creature, and the names of players that have recently been seen.</p>&#13;
<p class="indent">Beyond what you’ve already learned about reading memory, hooking graphics engines, and displaying customized data, there’s not much else I can teach you about how to create a HUD. Most games have a simple enough architecture that you can easily obtain most of the information you need from memory. Then, you can run some basic hourly, percentage, or summation calculations to get the data into a usable format.</p>&#13;
<h4 class="h4" id="ch00lev1sec199"><strong><em>Creating an Experience HUD</em></strong></h4>&#13;
<p class="noindent">Imagine you want a HUD that displays your current level, hourly experience, and how long you’ll have to play before your character levels up. First, you could use Cheat Engine to find the variables that contain your level and experience. When you know those values, you can use either a game-specific algorithm or a hardcoded experience table to calculate the experience required to reach the next level.</p>&#13;
<p class="indent">When you know how much experience you need to level up, you can calculate your hourly experience. Put into pseudocode, that process might look like this:</p>&#13;
<p class="programs">   // this example assumes the time is stored in milliseconds<br/>   // for seconds, remove the "1000 * "<br/>   timeUnitsPerHour = 1000 * 60 * 60<br/>   timePassed = (currentTime - startTime)<br/><span class="ent">➊</span> timePassedToHourRatio = timeUnitsPerHour / timePassed<br/><span class="ent">➋</span> expGained = (currentExp - startExp)<br/>   hourlyExp = expGained * timePassedToHourRatio<br/><br/><span class="ent">➌</span> remainingExp = nextExp - currentExp<br/><span class="ent">➍</span> hoursToGo = remainingExp / hourlyExp</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_200"/>To find your hourly experience, <span class="literal">hourlyExp</span>, you’d store your experience and the time when your HUD first starts; these are <span class="literal">startExp</span> and <span class="literal">startTime</span>, respectively. This example also assumes <span class="literal">currentLevel</span> and <span class="literal">currentExp</span> are previously defined, where <span class="literal">currentLevel</span> is the character’s level and <span class="literal">currentExp</span> is the current amount of experience.</p>&#13;
<p class="indent">With these values, <span class="literal">hourlyExp</span> can be calculated by multiplying a ratio <span class="ent">➊</span> of the time units in an hour to the time that has passed by the experience gained since <span class="literal">startTime</span> <span class="ent">➋</span>. In this case, the time unit is a millisecond, so the time units get multiplied by 1,000.</p>&#13;
<p class="indent">Next, <span class="literal">currentExp</span> is subtracted from <span class="literal">nextExp</span> to determine the remaining experience <span class="ent">➌</span> to level up. To calculate how many hours are left to level up, your remaining experience is divided by your hourly experience <span class="ent">➍</span>.</p>&#13;
<p class="indent">When you have all this information, you can finally display it onscreen. Using the Direct3D hooking engine provided in this book’s example code, you’d draw the text using this call inside the <span class="literal">EndScene()</span> hook callback:</p>&#13;
<p class="programs">hook-&gt;drawText(<br/>    10, 10,<br/>    D3DCOLOR_ARGB(255, 255, 0, 0),<br/>    "Will reach level %d in %0.20f hours (%d exp per hour)",<br/>    currentLevel, hoursToGo, hourlyExp);</p>&#13;
<p class="indent">That’s all you need for a working, experience-tracking HUD. Variations of these same equations can be used to calculate KPH, DPS, GPH, and other useful time-based measures. Furthermore, you can use the <span class="literal">drawText()</span> function of the Direct3D hook to display any information you can locate and normalize. The hook also contains <span class="literal">addSpriteImage()</span> and <span class="literal">drawSpriteImage()</span> functions that you can use to draw your own custom images, allowing you to make your HUDs as fancy as you want.</p>&#13;
<h4 class="h4" id="ch00lev1sec200"><strong><em>Using Hooks to Locate Data</em></strong></h4>&#13;
<p class="noindent">Memory reading isn’t the only way to get data for a custom HUD. You can also gather information by counting the number of times a specific model is drawn by the <span class="literal">DrawIndexedPrimitive()</span> function, hooking the game’s internal functions responsible for drawing certain types of text, or even intercepting function calls responsible for processing data packets from the game server. The methods you use to do this will be drastically different for every game, and finding those methods will require you to pair everything you’ve learned from this book with your own ingenuity and programming instincts.</p>&#13;
<p class="indent">For instance, to create a HUD that displays how many enemies are on the map, you could use the model-fingerprinting methods used by wallhacks to count the number of enemies and output that number to the screen. This method is better than creating a way to read the list of enemies from memory, since it doesn’t require new memory addresses every time the game patches.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_201"/>Another example is displaying a list of enemy cooldowns, which would require you to intercept incoming packets that tell the client which spell effects to display. You could then correlate certain spells with certain enemies based on spell and enemy location, spell type, and so on, and use that information to track spells each enemy has used. If you correlate the data with a database of cooldown times, you can display exactly when each enemy spell can be used again. This is especially powerful because most games don’t store enemy cooldowns in memory.</p>&#13;
<h3 class="h3" id="ch00lev1sec201"><strong>An Overview of Other ESP Hacks</strong></h3>&#13;
<p class="noindent">In addition to the hacks discussed in this chapter, there are a number of ESP hacks that don’t have common names and are specific to certain genres or even certain games. I’ll quickly take you through the theory, background, and architecture of some of these hacks.</p>&#13;
<p class="term"><strong>Range Hacks</strong></p>&#13;
<p class="termp">Range hacks use a method similar to wallhacks to detect when the models for different types of champions or heroes are drawn. Then they draw circles on the ground around each hero model. The radius of each circle corresponds to the maximum attack range of the champion or hero it surrounds, effectively showing you areas where you can be damaged by each enemy.</p>&#13;
<p class="term"><strong>Loading-Screen HUDs</strong></p>&#13;
<p class="termp">Loading-screen HUDs are common in MOBA and RTS games that require all players to sit through a loading screen while everyone’s game is starting up. These hacks take advantage of the fact that such games often have websites where historical player statistics can be queried. You can write a bot that automatically queries the statistics of each player in the game and seamlessly displays the information as an overlay on your loading screen, allowing you to study your enemies before launching into battle.</p>&#13;
<p class="term"><strong>Pick-Phase HUDs</strong></p>&#13;
<p class="termp">Pick-phase HUDs are similar to their loading-screen cousins, but they are displayed during the pregame phase when each player is picking a champion or hero to play. Instead of showing enemy statistics, pick-phase HUDs show statistics about allies. This allows you to quickly assess the strengths and weaknesses of your allies so you can make better decisions about which character to play.</p>&#13;
<p class="term"><strong>Floor Spy Hacks</strong></p>&#13;
<p class="termp">Floor spy hacks are common in older 2D top-down games that have different distinct floors or platforms. If you’re on the top floor, you might want to know what’s going on downstairs before you go charging in. You can write floor spy hacks that modify the current floor value (typically an <span class="literal">unsigned int</span>) to a different floor above or below you, allowing you to spy on other floors.</p>&#13;
<p class="indentt"><span epub:type="pagebreak" id="page_202"/>Games often recalculate the current floor value every frame based on player position, so NOPs are sometimes required to keep the value from being reset every time a frame is redrawn. Finding the current floor value and the code to NOP would be similar to finding the zoom factor, as discussed in “<a href="ch09.xhtml#ch00lev1sec196">Using NOPing Zoomhacks</a>” on <a href="ch09.xhtml#page_197">page 197</a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec202"><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">ESP hacks are powerful ways to obtain extra information about a game. Some of them can be done pretty easily through Direct3D hooks or simple memory editing. Others require you to learn about a game’s internal data structures and hook proprietary functions, giving you a reason to employ your reverse engineering skills.</p>&#13;
<p class="indent">If you want to experiment with ESP hacks, study and tweak the example code for this chapter. For practice with more specific ESP hacks, I encourage you to go out and find some games to play around with.</p>&#13;
</body></html>