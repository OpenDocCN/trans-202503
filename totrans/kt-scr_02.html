<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch1" epub:type="chapter" role="doc-chapter">
<span aria-label="3" epub:type="pagebreak" id="pg_3" role="doc-pagebreak"/>
<hgroup>
<h2 class="title" id="ch1">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">1</span></span>
<span class="ct"><span class="sans_dogma_ot_bold_b_">KOTLIN BASICS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="380" src="../images/icon.jpg" width="381"/>
</figure>
<p class="chapterintro">This chapter will guide you through the fundamental building blocks of the Kotlin programming language. We’ll explore essential language features such as comments, variables, operators, flow control structures, functions (including lambda expressions), and basic input and output techniques.</p>
<p class="tx">Together, these elements allow you to manage and manipulate data within your code, govern the program’s behavior so that it responds dynamically to different scenarios, and keep your code well organized and easy to maintain. Understanding these basic elements will also pave the way for the more sophisticated language features discussed in <span><a href="chapter2.xhtml" class="calibre2">Chapter 2</a></span>, such as arrays, collections, and custom data structures (including classes).</p>
<p class="tx">The topics covered here are core elements in any programming language, serving as the foundational elements for application development. If you’ve already worked with another language, these elements will look familiar in Kotlin. Conversely, if Kotlin is your first language, what you <span aria-label="4" epub:type="pagebreak" id="pg_4" role="doc-pagebreak"/>learn here will be readily transferable to other languages. We’ll explore these components in a practical way, with short code snippets illustrating each new idea. At the end of the chapter, we’ll tie everything together with a simple project.</p>
<p class="tx">I’m assuming you’re using the free version of IntelliJ IDEA as your integrated development environment (IDE) for developing and running code. See the <span>appendix</span> for instructions on installing, setting up, and using this tool with a basic “Hello, world!” program.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h" id="sec1"><span id="h1-8"/><span class="sans_futura_std_bold_b_">Using Comments</span></h3>
<p class="tni">A <i class="calibre9">comment</i> is a line (or several lines) of explanatory text in a code file that the compiler will ignore when it runs the code. The text is meant to provide helpful hints, such as what the next code segment does, why a particular method was chosen, or how to properly use a language feature in a code segment. When you’re coding, you should insert comments to remind yourself what each piece of code is about. Experienced coders know that documenting code is essential to guard against forgetting important details down the road. Also, when others use or build on your code, your comments can be a lifesaver.</p>
<p class="tx">In Kotlin, you have two main ways to add comments. The first is to use <span class="sans_thesansmonocd_w5regular_">//</span> to start a single-line comment. The compiler will ignore anything on the line after the two slashes. The other way is to use <span class="sans_thesansmonocd_w5regular_">/*</span> and <span class="sans_thesansmonocd_w5regular_">*/</span> to start and end a comment that spans multiple lines. Here’s an example of how these two commenting styles work:</p>
<pre class="calibre10"><code class="calibre11">// This is a single-line comment.

/*
   This code block will be ignored by the compiler
   as it is inside a multiline comment block.
*/</code></pre>
<p class="tx">Kotlin also provides a third type of comment, which is used for automatically generating documentation. This sort of comment begins with <span class="sans_thesansmonocd_w5regular_">/**</span> and ends with <span class="sans_thesansmonocd_w5regular_">*/</span>. Documentation comments are used to describe variables, functions, and classes more formally, and they often include tags such as <span class="sans_thesansmonocd_w5regular_">@param</span>, <span class="sans_thesansmonocd_w5regular_">@return</span>, and <span class="sans_thesansmonocd_w5regular_">@throws</span> to explain standard aspects of a piece of code. Here’s an example that compares multiline and documentation comments:</p>
<pre class="calibre10"><code class="calibre11">/* This is a multiline comment
   used for providing useful tips or reminders. */

/**
* This is a documentation comment.
*
* @param name The name of the person
* @return The greeting string
*/
<span aria-label="5" epub:type="pagebreak" id="pg_5" role="doc-pagebreak"/>fun greet(name: String): String {
    return "Hello, $name!"
}</code></pre>
<p class="tx">While these two types of comments use a similar syntax, they serve different purposes. Multiline comments are intended to be read within the code file itself. Documentation comments, on the other hand, are intended to be exported from the code file to generate official documentation for production-ready code that other developers can consult.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="h" id="sec2"><span id="h1-9"/><span class="sans_futura_std_bold_b_">Variables</span></h3>
<p class="tni">In coding, a <i class="calibre9">variable</i> is a name given to a data element. For simplicity, we can think of variables as containers that hold various data types in a computer’s memory. Once assigned, the variable name can be used as a stand-in for the value it represents. In this way, variables allow us to store and manage data, enabling the persistence of information within a program.</p>
<p class="tx">Every variable should have a meaningful name that clearly describes its purpose or function or otherwise reflects the nature of the data assigned to it. For example, a variable holding a person’s name could be called <span class="sans_thesansmonocd_w5regular_">name</span>, and a variable holding a person’s age could be called <span class="sans_thesansmonocd_w5regular_">age</span>. By convention, variable names should consist of a lowercase word or use <i class="calibre9">camelCase</i> to join multiple words. In the latter case, no spaces appear between words, and every word after the first starts with a capital letter, as in <span class="sans_thesansmonocd_w5regular_">lastName</span> or <span class="sans_thesansmonocd_w5regular_">ageInYears</span>.</p>
<p class="tx">In Kotlin, you create a new variable by <i class="calibre9">declaring</i> its name with a keyword such as <span class="sans_thesansmonocd_w5regular_">val</span> or <span class="sans_thesansmonocd_w5regular_">var</span> and <i class="calibre9">initializing</i> it (assigning it to a value). (A <i class="calibre9">keyword</i> is a reserved word that has a special meaning in a programming language. A keyword can’t be used as an identifier—for example, as a variable or function name.) Which keyword you use depends on whether you want the variable’s value to stay the same or change during program execution. A variable declared with <span class="sans_thesansmonocd_w5regular_">val</span> is <i class="calibre9">read-only</i>, meaning its value can’t change after it’s been initialized. A variable declared with <span class="sans_thesansmonocd_w5regular_">var</span> is <i class="calibre9">mutable</i>, meaning the variable can be assigned a different value after it’s been initialized. You can change the value of a mutable variable as many times as needed.</p>
<p class="tx">Consider this example, where we use two variables to create a message:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    val name = "John Sinclair"
    val age = 30
    println("$name is $age years old")
}</code></pre>
<p class="tx">We declare two variables, <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span>, and assign them the values <span class="sans_thesansmonocd_w5regular_">"John Sinclair"</span> and <span class="sans_thesansmonocd_w5regular_">30</span>, respectively. Both variables are declared with the <span class="sans_thesansmonocd_w5regular_">val</span> keyword, so they can’t be reassigned to different values later. We then include both variables in a message to be printed to the console by adding a dollar sign (<span class="sans_thesansmonocd_w5regular_">$</span>) before each variable name. (We’ll discuss how this syntax works in <span aria-label="6" epub:type="pagebreak" id="pg_6" role="doc-pagebreak"/>more detail in <span>“Working with Strings”</span> on <span><a href="#pg_14" class="calibre2">page 14</a></span>.) If you run this code (using <small class="calibre12">CTRL</small>-<small class="calibre12">SHIFT</small>-F10 in IntelliJ IDEA), the output should look like this:</p>
<pre class="calibre10"><code class="calibre11">John Sinclair is 30 years old</code></pre>
<p class="tx">Notice how the output shows the values assigned to the <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> variables rather than the variable names themselves. But what if we want to assign new values to these variables over the course of the program? For that, we have to use the <span class="sans_thesansmonocd_w5regular_">var</span> keyword instead of <span class="sans_thesansmonocd_w5regular_">val</span>, as shown here:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    var name = "John Sinclair"
    var age = 30
    println("$name is $age years old")
  <span aria-label="annotation1" class="code_codeannotation">❶</span> name = "John Sinclair Jr."
    age = 12
    println("$name is $age years old")
}</code></pre>
<p class="tx">Here we declare the <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> variables with the <span class="sans_thesansmonocd_w5regular_">var</span> keyword, giving them the same initial values as before. Then we assign them new values <span aria-label="annotation1" class="codeannotation">❶</span>. Notice that the second time around, we no longer need the <span class="sans_thesansmonocd_w5regular_">var</span> (or <span class="sans_thesansmonocd_w5regular_">val</span>) keyword when setting the values of the variables. Once we’ve declared and initialized a variable for the first time, we can work with the variable using only its name.</p>
<p class="tx">If you now run the program, this is what you should see:</p>
<pre class="calibre10"><code class="calibre11">John Sinclair is 30 years old
John Sinclair Jr. is 12 years old</code></pre>
<p class="tni">We’ve successfully reassigned the variable names because they were declared with the <span class="sans_thesansmonocd_w5regular_">var</span> keyword. Try changing the <span class="sans_thesansmonocd_w5regular_">var</span> keyword back to <span class="sans_thesansmonocd_w5regular_">val</span> for one or both variables and running the code again. The IDE will instantly generate an error message about how you can’t assign a new value to a variable declared with <span class="sans_thesansmonocd_w5regular_">val</span>, and it won’t let you run the program until you fix the error.</p>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="h1" id="sec3"><span id="h2-1"/><span class="sans_futura_std_bold_condensed_oblique_">Constants</span></h4>
<p class="tni">Kotlin also provides the <span class="sans_thesansmonocd_w5regular_">const</span> keyword (short for <i class="calibre9">constant</i>) for setting the immutable value of a variable at the beginning of a file. The value must be known during compilation of the code. Declaring a variable with <span class="sans_thesansmonocd_w5regular_">const</span> is allowed only for primitive types or strings. (We discuss the common data types in Kotlin in the next section.) The judicious use of constants has two important benefits: it improves program efficiency in accessing fixed values, and it improves code clarity by avoiding hardcoded “magic numbers” deep inside the code without clear context. Here’s an example of creating a variable with the <span class="sans_thesansmonocd_w5regular_">const</span> keyword:</p>
<pre class="calibre10"><code class="calibre11">const val PI = 3.14159265359</code></pre>
<p class="tx"><span aria-label="7" epub:type="pagebreak" id="pg_7" role="doc-pagebreak"/>In this case, we know the value of the mathematical constant pi, and we know that this value won’t change over the course of a program, so it makes sense to declare it using the <span class="sans_thesansmonocd_w5regular_">const</span> keyword at the start of the program. In Kotlin, it’s customary to use all caps for top-level constant names, as we’ve done here for <span class="sans_thesansmonocd_w5regular_">PI</span>. Multiple words can be joined using an underscore.</p>
<p class="tx">Kotlin has many other naming conventions for various code constructs. <a href="chapter1.xhtml#tab1-1" class="calibre2">Table 1-1</a> summarizes the most common ones.</p>
<p class="tt" id="tab1-1"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 1-1:</span></span> <span class="sans_futura_std_book_">Naming Conventions in Kotlin</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Name</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Convention</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Example</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Package name</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Use lowercase letters with no underscores.</span></p>
<p class="tableheader"><span class="sans_futura_std_book_">Join multiple words or use camelCase.</span></p>
<p class="tableheader"><span class="sans_futura_std_book_">Use reverse domain notation (autogenerated by the IDE).</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">org.example.myProject</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Class name</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Use PascalCase for class and inheritance names.</span></p>
<p class="tb1"><span class="sans_futura_std_book_">Choose words that are nouns or noun phrases.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">FlightSimulation</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Function name</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Use camelCase for function and method names.</span></p>
<p class="tableheader"><span class="sans_futura_std_book_">Use verbs or verb phrases.</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">calculateShortestPath()</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Variable name</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Use a single word or camelCase to join multiple words.</span></p>
<p class="tb1"><span class="sans_futura_std_book_">Choose a word that describes the purpose, function, or property of the variable (make it meaningful).</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">username</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">Constant and final variable name</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">Use uppercase letters with underscores to separate words.</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">MAX_VALUE</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">These naming conventions are based on the recommendations in the official Kotlin documentation at <span class="copyright_accent"><a href="https://kotlinlang.org" class="calibre2">https://kotlinlang.org</a></span>. We’ll revisit them as we discuss the code constructs they relate to.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h1" id="sec4"><span id="h2-2"/><span class="sans_futura_std_bold_condensed_oblique_">Common Data Types</span></h4>
<p class="tni">A value in code can be of various <i class="calibre9">data types</i>. For example, a value might represent a number, some text, or a logical value (<span class="sans_thesansmonocd_w5regular_">true</span> or <span class="sans_thesansmonocd_w5regular_">false</span>). In Kotlin, each variable is associated with a specific data type, and once a variable’s data type has been set, it can’t hold values of other types. A variable with a numeric value can be associated with different types, such as <span class="sans_thesansmonocd_w5regular_">Int</span> for whole numbers only or <span class="sans_thesansmonocd_w5regular_">Double</span> or <span class="sans_thesansmonocd_w5regular_">Float</span> for numbers with decimal components. A variable holding text values can be of type <span class="sans_thesansmonocd_w5regular_">Char</span> for a single character or type <span class="sans_thesansmonocd_w5regular_">String</span> for multiple characters. A logical value will have a <span class="sans_thesansmonocd_w5regular_">Boolean</span> type. <a href="chapter1.xhtml#tab1-2" class="calibre2">Table 1-2</a> lists the common data types in Kotlin and their key characteristics.</p>
<span aria-label="8" epub:type="pagebreak" id="pg_8" role="doc-pagebreak"/>
<p class="tt" id="tab1-2"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 1-2:</span></span> <span class="sans_futura_std_book_">Common Kotlin Data Types</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Data type</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Description</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Size (in bits)</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Range of values</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">Byte</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Signed integer</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">8</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">–128 to 127</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">Short</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Signed integer</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">16</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">–32,768 to 32,767</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">Int</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Signed integer</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">32</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">–2,147,483,648 to 2,147,483,647</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">Long</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Signed integer</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">64</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">–9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">Float</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Floating point (single precision)</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">32</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">–3.4028235E+38 to 3.4028235E+38</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">Double</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Floating point (double precision)</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">64</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">–1.7976931348623157E+308 to 1.7976931348623157E+308</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">Char</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">16-bit Unicode character</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">16</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">0 to 65,535 (in decimal)</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">Boolean</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Represents true or false</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">true</span> <span class="sans_futura_std_book_">or</span> <span class="sans_thesansmonocd_w5regular_">false</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">String</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">A sequence of characters</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">Varies</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">N/A</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">We choose the data type for a variable based on problem-specific needs, focusing on factors such as the data type’s ability to accommodate values, its level of precision, and its memory utilization. If you know a numeric variable will hold only integer values, for example, <span class="sans_thesansmonocd_w5regular_">Int</span> would be a better choice than <span class="sans_thesansmonocd_w5regular_">Float</span>. If those values need to be exceptionally large, <span class="sans_thesansmonocd_w5regular_">Long</span> would be more appropriate than <span class="sans_thesansmonocd_w5regular_">Int</span>.</p>
<section aria-labelledby="sec5" epub:type="division">
<h5 class="h2" id="sec5"><span id="h3-1"/><span class="sans_futura_std_bold_b_">Type Inference</span></h5>
<p class="tni">When declaring a variable in Kotlin, it isn’t mandatory to explicitly specify its data type. The Kotlin compiler excels at <i class="calibre9">inferring</i> the variable’s data type based on the assigned value. Here, for example, Kotlin infers that <span class="sans_thesansmonocd_w5regular_">name</span> is of type <span class="sans_thesansmonocd_w5regular_">String</span>, since its value is a series of characters enclosed in quotation marks:</p>
<pre class="calibre10"><code class="calibre11">val name = "John Sinclair"</code></pre>
<p class="tx">You also have the option to explicitly declare a variable’s data type. Here’s how to explicitly declare <span class="sans_thesansmonocd_w5regular_">name</span> as a <span class="sans_thesansmonocd_w5regular_">String</span>:</p>
<pre class="calibre10"><code class="calibre11">val name: String = "John Sinclair"</code></pre>
<p class="tx">To declare the data type, we place a colon after the variable name, followed by the desired type. This can be any acceptable data type, including custom data types you might have created to represent complex structures with specific properties and behaviors (for example, classes or data classes, which we’ll discuss in <span><a href="chapter2.xhtml" class="calibre2">Chapter 2</a></span>).</p>
<p class="tx">For numeric values, Kotlin infers the <span class="sans_thesansmonocd_w5regular_">Int</span> type if a variable is first assigned a whole-number value or the <span class="sans_thesansmonocd_w5regular_">Double</span> type if it’s assigned a value <span aria-label="9" epub:type="pagebreak" id="pg_9" role="doc-pagebreak"/>with a decimal component. If you need a different numeric type, you can explicitly indicate it by using a type suffix at the end of the value itself, such as <span class="sans_thesansmonocd_w5regular_">L</span> for <span class="sans_thesansmonocd_w5regular_">Long</span> and <span class="sans_thesansmonocd_w5regular_">f</span> for <span class="sans_thesansmonocd_w5regular_">Float</span>. For example:</p>
<pre class="calibre10"><code class="calibre11">val regularInt = 42
val floatNumber = 3.14f
val longNumber = 123456789L</code></pre>
<p class="tx">In this code, <span class="sans_thesansmonocd_w5regular_">regularInt</span> is inferred as <span class="sans_thesansmonocd_w5regular_">Int</span> by default, while <span class="sans_thesansmonocd_w5regular_">floatNumber</span> and <span class="sans_thesansmonocd_w5regular_">longNumber</span> are explicitly declared to be of types <span class="sans_thesansmonocd_w5regular_">Float</span> and <span class="sans_thesansmonocd_w5regular_">Long</span>, respectively, using the <span class="sans_thesansmonocd_w5regular_">f</span> and <span class="sans_thesansmonocd_w5regular_">L</span> suffixes.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h5 class="h2" id="sec6"><span id="h3-2"/><span class="sans_futura_std_bold_b_">Type Casting</span></h5>
<p class="tni"><i class="calibre9">Type casting</i>, also known as <i class="calibre9">type conversion</i>, is the process of changing a variable’s or expression’s data type to another compatible data type. (An <i class="calibre9">expression</i> is a code snippet that evaluates to a particular data type.) This process is primarily used to resolve type mismatches. In general, Kotlin enforces strict type checking to prevent common sources of runtime errors, such as unintended type conversions. Implicit type casting may be allowed only when no risk of data loss or unexpected behavior exists. For example, smaller numeric types can be implicitly promoted to larger numeric types since no risk of data loss exists, as shown here:</p>
<pre class="calibre10"><code class="calibre11">val intNumber = 22  // type inferred as Int
val longNumber: Long = intNumber  // implicit type casting</code></pre>
<p class="tx">We take the value of the <span class="sans_thesansmonocd_w5regular_">intNumber</span> variable and assign it to the <span class="sans_thesansmonocd_w5regular_">longNumber</span> variable, implicitly converting the value from type <span class="sans_thesansmonocd_w5regular_">Int</span> to <span class="sans_thesansmonocd_w5regular_">Long</span>. This may work, but the default setting of most IDEs is to prevent the use of implicit type casting altogether. Instead, you’re encouraged to use explicit type-casting methods to achieve type conversion. Some of the common type-casting methods supported in Kotlin include <span class="sans_thesansmonocd_w5regular_">toByte()</span>, <span class="sans_thesansmonocd_w5regular_">toInt()</span>, <span class="sans_thesansmonocd_w5regular_">toLong()</span>, <span class="sans_thesansmonocd_w5regular_">toShort()</span>, <span class="sans_thesansmonocd_w5regular_">toDouble()</span>, <span class="sans_thesansmonocd_w5regular_">toFloat()</span>, <span class="sans_thesansmonocd_w5regular_">toChar()</span>, and <span class="sans_thesansmonocd_w5regular_">toString()</span>. Here is an example of explicit type casting:</p>
<pre class="calibre10"><code class="calibre11">val intNumber = 44  // type inferred as Int
val doubleNumber: Double = intNumber.toDouble()</code></pre>
<p class="tx">We first create the <span class="sans_thesansmonocd_w5regular_">intNumber</span> variable and assign it a value of <span class="sans_thesansmonocd_w5regular_">44</span>. The compiler will infer <span class="sans_thesansmonocd_w5regular_">intNumber</span> to be of the <span class="sans_thesansmonocd_w5regular_">Int</span> type. Then we explicitly cast it to type <span class="sans_thesansmonocd_w5regular_">Double</span> using the <span class="sans_thesansmonocd_w5regular_">toDouble()</span> method before assigning it to <span class="sans_thesansmonocd_w5regular_">doubleNumber</span>.</p>
<p class="tx">Since type casting is allowed only when the associated data types are compatible, not all conversions are possible. For example, you can’t always convert a text type into a numeric or logical type. To illustrate, try running the following lines of code:</p>
<pre class="calibre10"><code class="calibre11">val message: String = "Hello, world!"
val intValue: Int = message.toInt()</code></pre>
<p class="tx"><span aria-label="10" epub:type="pagebreak" id="pg_10" role="doc-pagebreak"/>Here we try to take the string in the <span class="sans_thesansmonocd_w5regular_">message</span> variable and cast it to an integer with the <span class="sans_thesansmonocd_w5regular_">toInt()</span> method. This will throw a <span class="sans_thesansmonocd_w5regular_">NumberFormatException</span> error at runtime, indicating the conversion isn’t possible due to the incompatible data types. This error seems reasonable: How should Kotlin know the numeric equivalent of the <span class="sans_thesansmonocd_w5regular_">"Hello, world!"</span> string?</p>
<aside aria-label="box-1" class="box">
<p class="boxtitle" id="box-1"><span class="sans_futura_std_bold_b_">FUNCTIONS AND METHODS</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">In Kotlin, a</span> <span class="sans_futura_std_book_oblique_">function</span> <span class="sans_futura_std_book_">is a block of code that performs a specific task, such as adding two numbers and returning their sum. It’s the basic unit of code organization. A</span> <span class="sans_futura_std_book_oblique_">method</span> <span class="sans_futura_std_book_">is a specific type of function that’s declared as part of a class or data type. Type-casting functions like</span> <span class="sans_thesansmonocd_w5regular_">toInt()</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">toString()</span> <span class="sans_futura_std_book_">are technically methods because they’re associated with values of a particular data type.</span></p>
<p class="box1"><span class="sans_futura_std_book_">Whereas a regular function is invoked simply by using the function name, as when we call the</span> <span class="sans_thesansmonocd_w5regular_">println()</span> <span class="sans_futura_std_book_">function, a method is invoked using</span> <span class="sans_futura_std_book_oblique_">dot notation</span><span class="sans_futura_std_book_">. With this syntax, you provide a value, followed by a period, followed by the name of a method associated with that value. For example,</span> <span class="sans_thesansmonocd_w5regular_">age.toString()</span> <span class="sans_futura_std_book_">calls the</span> <span class="sans_thesansmonocd_w5regular_">toString()</span> <span class="sans_futura_std_book_">method on the value stored in the</span> <span class="sans_thesansmonocd_w5regular_">age</span> <span class="sans_futura_std_book_">variable (presumably an integer), creating a string version of that value.</span></p>
<p class="boxlast"><span class="sans_futura_std_book_">We’ll discuss functions in detail later in this chapter, and we’ll discuss methods in <a href="chapter2.xhtml" class="calibre2">Chapter 2</a>, when we study classes.</span></p>
</aside>
</section>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="h" id="sec7"><span id="h1-10"/><span class="sans_futura_std_bold_b_">Operators</span></h3>
<p class="tni"><i class="calibre9">Operators</i> are special symbols for manipulating variables and other values in your code. Each operator performs a specific mathematical, logical, or text-based operation. In this section, we’ll review the most common categories of operators in Kotlin.</p>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="h1" id="sec8"><span id="h2-3"/><span class="sans_futura_std_bold_condensed_oblique_">Arithmetic</span></h4>
<p class="tni">Arithmetic operators are for performing basic mathematical operations such as addition (<span class="sans_thesansmonocd_w5regular_">+</span>), subtraction (<span class="sans_thesansmonocd_w5regular_">-</span>), multiplication (<span class="sans_thesansmonocd_w5regular_">*</span>), and division (<span class="sans_thesansmonocd_w5regular_">/</span>). Here are some examples of how to use arithmetic operators in Kotlin:</p>
<pre class="calibre10"><code class="calibre11">val a = 20
val b = 7
val sum = a + b            // addition, yields 27
val difference = a – b     // subtraction, yields 13
val product = a * b        // multiplication, yields 140
val quotient = a / b       // division, yields 2</code></pre>
<p class="tx">Here we apply the four main arithmetic operations to the <span class="sans_thesansmonocd_w5regular_">a</span> and <span class="sans_thesansmonocd_w5regular_">b</span> variables. Notice that when you divide two integers using the division operator <span class="sans_thesansmonocd_w5regular_">/</span>, <span aria-label="11" epub:type="pagebreak" id="pg_11" role="doc-pagebreak"/>the result is also an integer, with any fractional part discarded. In this case, <span class="sans_thesansmonocd_w5regular_">20 / 7</span> gives a result of <span class="sans_thesansmonocd_w5regular_">2</span>, not <span class="sans_thesansmonocd_w5regular_">2.857143</span>. If you need to retain the fractional part, you must convert one of the numbers into a floating-point number, as shown here:</p>
<pre class="calibre10"><code class="calibre11">val a = 20
val b = 7
val quotientInt = a / b               // integer division
val quotientFloat = a.toFloat() / b   // real division</code></pre>
<p class="tx">Here, <span class="sans_thesansmonocd_w5regular_">quotientInt</span> will have a value of <span class="sans_thesansmonocd_w5regular_">2</span>, but <span class="sans_thesansmonocd_w5regular_">quotientFloat</span> will have a value of <span class="sans_thesansmonocd_w5regular_">2.857143</span> since we use <span class="sans_thesansmonocd_w5regular_">toFloat()</span> to convert <span class="sans_thesansmonocd_w5regular_">a</span> from an integer to a floating-point number.</p>
<p class="tx">The <i class="calibre9">remainder</i> or <i class="calibre9">modulo</i> operator is another mathematical operator we’ll use many times in this book. It’s designated by the <span class="sans_thesansmonocd_w5regular_">%</span> symbol. This operator returns only the remainder from the integer division of two numbers. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">val a = 20
val b = 7
val result = a % b // The result is 6.</code></pre>
<p class="tx">In this example, <span class="sans_thesansmonocd_w5regular_">a % b</span> returns the remainder when <span class="sans_thesansmonocd_w5regular_">a</span> is divided by <span class="sans_thesansmonocd_w5regular_">b</span>. Since 20 divided by 7 has a remainder of 6, the value of <span class="sans_thesansmonocd_w5regular_">result</span> is <span class="sans_thesansmonocd_w5regular_">6</span>. Can you guess what the result would be if we flipped the numbers around—that is, if we calculated <span class="sans_thesansmonocd_w5regular_">7 % 20</span>? Additionally, what would be the result of the integer division <span class="sans_thesansmonocd_w5regular_">7 / 20</span>? These questions may sound trivial, but I encourage you to write a few lines of code to verify your guesses.</p>
<p class="tx">Kotlin uses the same order of operations for arithmetic operators as regular mathematics: division and multiplication take precedence over addition and subtraction. To avoid confusion about the order of operations, it’s good practice to use parentheses to clearly isolate different operational blocks. For example:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    // example without parentheses
    val resultWithoutParentheses = 5 + 3 * 2
    println("Result without parentheses: $resultWithoutParentheses")

    // example with parentheses
    val resultWithParentheses = (5 + 3) * 2
    println("Result with parentheses: $resultWithParentheses")
}</code></pre>
<p class="tx">In the first calculation, <span class="sans_thesansmonocd_w5regular_">5</span> <span class="sans_thesansmonocd_w5regular_">+</span> <span class="sans_thesansmonocd_w5regular_">3 * 2</span>, multiplication takes precedence over addition, so it evaluates to <span class="sans_thesansmonocd_w5regular_">5</span> <span class="sans_thesansmonocd_w5regular_">+</span> <span class="sans_thesansmonocd_w5regular_">(3 * 2)</span>, resulting in <span class="sans_thesansmonocd_w5regular_">11</span>. In the second calculation, <span class="sans_thesansmonocd_w5regular_">(5</span> <span class="sans_thesansmonocd_w5regular_">+</span> <span class="sans_thesansmonocd_w5regular_">3) * 2</span>, the addition inside the parentheses is performed first, and then the multiplication, resulting in <span class="sans_thesansmonocd_w5regular_">16</span>. This demonstrates how using parentheses can clarify and control the order of operations in mathematical expressions.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<span aria-label="12" epub:type="pagebreak" id="pg_12" role="doc-pagebreak"/>
<h4 class="h1" id="sec9"><span id="h2-4"/><span class="sans_futura_std_bold_condensed_oblique_">Assignment</span></h4>
<p class="tni">Assignment operators are used to assign values to variables. We’ve already been using the main assignment operator (<span class="sans_thesansmonocd_w5regular_">=</span>) throughout this chapter’s examples to set a variable’s value from scratch. Other assignment operators, like <span class="sans_thesansmonocd_w5regular_">+=</span> and <span class="sans_thesansmonocd_w5regular_">-=</span>, take a variable’s existing value and modify it. Here are some examples:</p>
<pre class="calibre10"><code class="calibre11">var a = 10
a += 5         // equivalent to a = a + 5 (a becomes 15)
a -= 5         // equivalent to a = a – 5 (a becomes 5)
a *= 5         // equivalent to a = a * 5 (a becomes 50)
a /= 5         // equivalent to a = a / 5 (a becomes 2)</code></pre>
<p class="tx">The assignment <span class="sans_thesansmonocd_w5regular_">a</span> <span class="sans_thesansmonocd_w5regular_">+=</span> <span class="sans_thesansmonocd_w5regular_">5</span> is equivalent to saying, “Take the value of <span class="sans_thesansmonocd_w5regular_">a</span>, add <span class="sans_thesansmonocd_w5regular_">5</span> to it, and put the result back in the <span class="sans_thesansmonocd_w5regular_">a</span> variable.” Similar assignment operators exist for the other three arithmetic operations.</p>
<p class="tx">You can try using <span class="sans_thesansmonocd_w5regular_">+=</span> with a string variable too, if it was declared with <span class="sans_thesansmonocd_w5regular_">var</span>. For example:</p>
<pre class="calibre10"><code class="calibre11">var s = "John Smith"
s += " Jr."           // The s becomes "John Smith Jr."</code></pre>
<p class="tx">Be mindful that this operation essentially creates a new string and assigns it to the previously used variable name, rather than directly modifying the old string (which is discarded). For strings, other assignment operators (for example, <span class="sans_thesansmonocd_w5regular_">-=</span>) will generate errors.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h1" id="sec10"><span id="h2-5"/><span class="sans_futura_std_bold_condensed_oblique_">Unary</span></h4>
<p class="tni">Whereas most operators have two operands, unary operators have just one. The <i class="calibre9">increment</i> (<span class="sans_thesansmonocd_w5regular_">++</span>) and <i class="calibre9">decrement</i> (<span class="sans_thesansmonocd_w5regular_">--</span>) unary operators increase or decrease a variable’s value by <span class="sans_thesansmonocd_w5regular_">1</span>, respectively. Here’s how to use these operators in Kotlin:</p>
<pre class="calibre10"><code class="calibre11">var a = 10
a++         // equivalent to a = a + 1 (a becomes 11)
a--         // equivalent to a = a – 1 (a becomes 10 again)</code></pre>
<p class="tx">Essentially, <span class="sans_thesansmonocd_w5regular_">a++</span> is a shorter way of writing <span class="sans_thesansmonocd_w5regular_">a</span> <span class="sans_thesansmonocd_w5regular_">+=</span> <span class="sans_thesansmonocd_w5regular_">1</span>, itself a shorter way of writing <span class="sans_thesansmonocd_w5regular_">a</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">a</span> <span class="sans_thesansmonocd_w5regular_">+</span> <span class="sans_thesansmonocd_w5regular_">1</span>. Likewise, <span class="sans_thesansmonocd_w5regular_">a--</span> is equivalent to <span class="sans_thesansmonocd_w5regular_">a -=</span> <span class="sans_thesansmonocd_w5regular_">1</span>.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="h1" id="sec11"><span id="h2-6"/><span class="sans_futura_std_bold_condensed_oblique_">Relational</span></h4>
<p class="tni">Relational operators compare two values and return a Boolean value (<span class="sans_thesansmonocd_w5regular_">true</span> or <span class="sans_thesansmonocd_w5regular_">false</span>) based on the comparison. These operators include <span class="sans_thesansmonocd_w5regular_">==</span> and <span class="sans_thesansmonocd_w5regular_">!=</span> for equality and inequality, and <span class="sans_thesansmonocd_w5regular_">&gt;</span> and <span class="sans_thesansmonocd_w5regular_">&lt;</span> for greater than and less than. Here are some examples of these operators in action:</p>
<pre class="calibre10"><code class="calibre11">val a = 10
val b = 5
val isEqual = (a == b)      // equality check
<span aria-label="13" epub:type="pagebreak" id="pg_13" role="doc-pagebreak"/>val isNotEqual = (a != b)   // inequality check
val isGreater = (a &gt; b)     // greater than check
val isLesser = (a &lt; b)      // less than check</code></pre>
<p class="tx">In this code segment, <span class="sans_thesansmonocd_w5regular_">isEqual</span> will be <span class="sans_thesansmonocd_w5regular_">false</span> because <span class="sans_thesansmonocd_w5regular_">a</span> and <span class="sans_thesansmonocd_w5regular_">b</span> aren’t equal, and <span class="sans_thesansmonocd_w5regular_">isNotEqual</span> will be <span class="sans_thesansmonocd_w5regular_">true</span>. Meanwhile, <span class="sans_thesansmonocd_w5regular_">isGreater</span> will be <span class="sans_thesansmonocd_w5regular_">true</span> because <span class="sans_thesansmonocd_w5regular_">a</span> is greater than <span class="sans_thesansmonocd_w5regular_">b</span>, and <span class="sans_thesansmonocd_w5regular_">isLesser</span> will be <span class="sans_thesansmonocd_w5regular_">false</span>. Notice how we put each comparison in parentheses. This isn’t strictly necessary, but it helps visually separate the comparison from the assignment operation it’s a part of.</p>
<p class="tx">The preceding examples used numeric values, but relational operators can also be used for comparing strings:</p>
<pre class="calibre10"><code class="calibre11">val text1 = "Hello"
val text2 = "World"
val isNotEqual = (text1 != text2) // true
val isGreater = (text1 &gt; text2)   // false</code></pre>
<p class="tx">In Kotlin, strings are compared lexicographically, character by character, based on their Unicode values. The comparison starts from the first character of each string and continues until a difference is found or one of the strings ends. The string with the smaller Unicode value at the first differing character is considered lesser. This implies that earlier letters in the alphabet are considered lesser than later letters and that uppercase letters are considered lesser than lowercase letters.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="h1" id="sec12"><span id="h2-7"/><span class="sans_futura_std_bold_condensed_oblique_">Logical</span></h4>
<p class="tni">Logical operators are used to perform logical operations such as AND (<span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span>), OR (<span class="sans_thesansmonocd_w5regular_">||</span>), and NOT (<span class="sans_thesansmonocd_w5regular_">!</span>) on Boolean values. Here are some examples of how to use logical operators in Kotlin:</p>
<pre class="calibre10"><code class="calibre11">val x = true
val y = false

val andResult = (x &amp;&amp; y)   // logical AND operation (returns false)
val orResult = (x || y)    // logical OR operation (returns true)
val notResult = !x         // logical NOT operation (returns false)</code></pre>
<p class="tx">The result of a logical operation involving two Boolean values can be summarized in a <i class="calibre9">truth table</i> like the one shown in <a href="chapter1.xhtml#tab1-3" class="calibre2">Table 1-3</a>. A truth table shows the output corresponding to every possible combination of input values.</p>
<p class="tt" id="tab1-3"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 1-3:</span></span> <span class="sans_futura_std_book_">Truth Table for Two Logical Values</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Value 1</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Value 2</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">AND</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">OR</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">true</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">true</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">true</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">true</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">true</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">false</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">false</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">true</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">false</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">true</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">false</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">true</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">false</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">false</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">false</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">false</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span aria-label="14" epub:type="pagebreak" id="pg_14" role="doc-pagebreak"/>In this table, the operands are Boolean values, which can be either <span class="sans_thesansmonocd_w5regular_">true</span> or <span class="sans_thesansmonocd_w5regular_">false</span>. For example, in the first row, both Value 1 and Value 2 are <span class="sans_thesansmonocd_w5regular_">true</span>. The result of an AND operation on these operands is <span class="sans_thesansmonocd_w5regular_">true</span>, and the result of an OR operation is also <span class="sans_thesansmonocd_w5regular_">true</span>. Unlike AND and OR, a NOT operation has just one Boolean operand, which gets inverted. For instance, the NOT operator turns <span class="sans_thesansmonocd_w5regular_">true</span> into <span class="sans_thesansmonocd_w5regular_">false</span>.</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="h" id="sec13"><span id="h1-11"/><span class="sans_futura_std_bold_b_">Working with Strings</span></h3>
<p class="tni">In Kotlin, a <i class="calibre9">string</i> is a sequence of characters represented by the <span class="sans_thesansmonocd_w5regular_">String</span> data type. Strings are helpful for storing and manipulating text data in a program. They’re commonly used to represent words, sentences, and other textual information. User input data is also initially read as strings and then converted as needed into other types using functions such as <span class="sans_thesansmonocd_w5regular_">toInt()</span>, <span class="sans_thesansmonocd_w5regular_">toDouble()</span>, and <span class="sans_thesansmonocd_w5regular_">toBoolean()</span>.</p>
<p class="tx">The individual characters in a string are numbered, or <i class="calibre9">indexed</i>, starting from zero. You can access a specific character in a string by placing its index in square brackets after the variable name representing that string. For example, to get the second character of a string in the <span class="sans_thesansmonocd_w5regular_">msg</span> variable, use <span class="sans_thesansmonocd_w5regular_">msg[1]</span>. Alternatively, you can use the <span class="sans_thesansmonocd_w5regular_">get()</span> method of the <span class="sans_thesansmonocd_w5regular_">String</span> class to retrieve the character at a specific index. For example, <span class="sans_thesansmonocd_w5regular_">msg.get(1)</span> returns the same second character as <span class="sans_thesansmonocd_w5regular_">msg[1]</span>.</p>
<p class="tx">In this section, we’ll discuss some common techniques for working with strings. Keep in mind as you read that strings are immutable objects in Kotlin, so once a string is created, its content can’t be changed. Any operation that appears to modify a string creates a new string, and the original value is discarded.</p>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="h1" id="sec14"><span id="h2-8"/><span class="sans_futura_std_bold_condensed_oblique_">Concatenation</span></h4>
<p class="tni"><i class="calibre9">Concatenation</i> is the process of combining two or more strings into a single string. In Kotlin, you can do this in multiple ways. For example, you can use the <span class="sans_thesansmonocd_w5regular_">+</span> operator, or you can use a string’s <span class="sans_thesansmonocd_w5regular_">plus()</span> method. Both techniques are demonstrated here:</p>
<pre class="calibre10"><code class="calibre11">val a = "Hello,"
val b = "world!"

// Use the plus (+) operator.
var c = a + " " + b
println(c) // output: Hello, world!

// Use the plus() method of the String class.
c = a.plus(" ").plus(b)
println(c) // output: Hello, world!</code></pre>
<p class="tx">In this code segment, we first create two string variables, <span class="sans_thesansmonocd_w5regular_">a</span> and <span class="sans_thesansmonocd_w5regular_">b</span>, with values <span class="sans_thesansmonocd_w5regular_">"Hello,"</span> and <span class="sans_thesansmonocd_w5regular_">"world!"</span>, respectively. Then we use the <span class="sans_thesansmonocd_w5regular_">+</span> operator to concatenate (join) the two strings and add a space (the string <span class="sans_thesansmonocd_w5regular_">" "</span>) in <span aria-label="15" epub:type="pagebreak" id="pg_15" role="doc-pagebreak"/>between, assigning the resulting string to the <span class="sans_thesansmonocd_w5regular_">c</span> variable. The output of <span class="sans_thesansmonocd_w5regular_">println(c)</span> is:</p>
<pre class="calibre10"><code class="calibre11">Hello, world!</code></pre>
<p class="tx">Notice how we call the <span class="sans_thesansmonocd_w5regular_">plus()</span> method twice in the same expression to concatenate string <span class="sans_thesansmonocd_w5regular_">a</span> with a space and string <span class="sans_thesansmonocd_w5regular_">b</span>. This technique is known as <i class="calibre9">method chaining</i>; the second method call is applied to the result of the first.</p>
<p class="tx">Another way to join multiple strings is to use the <span class="sans_thesansmonocd_w5regular_">buildString</span> function, as in this example:</p>
<pre class="calibre10"><code class="calibre11">val c = buildString {
           append("Hello,")
           append(" ")
           append("world!")
       }
println(c) // output: Hello, world!</code></pre>
<p class="tx">We create a variable <span class="sans_thesansmonocd_w5regular_">c</span> to hold the concatenated string and append all the string segments through a single call to the <span class="sans_thesansmonocd_w5regular_">buildString</span> function.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="h1" id="sec15"><span id="h2-9"/><span class="sans_futura_std_bold_condensed_oblique_">String Templates</span></h4>
<p class="tni">Most characters that appear between the opening and closing quotation marks of a string are interpreted literally as ordinary text. <i class="calibre9">String templates</i>, however, are a powerful feature in Kotlin that allow you to embed code within a string. They’re a concise and expressive way to combine static text with dynamic values resulting from variables, expressions, or even function calls. As hinted at when we first discussed variables, string templates use dollar signs (<span class="sans_thesansmonocd_w5regular_">$</span>) to signal that what follows should be treated as code rather than as literal text. For example, consider the following code snippet:</p>
<pre class="calibre10"><code class="calibre11">val name = "John"
val age = 30
val message = "My name is $name and I'm $age years old."
println(message)</code></pre>
<p class="tx">Here we embed the variables <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">age</span> within the <span class="sans_thesansmonocd_w5regular_">message</span> string template using the <span class="sans_thesansmonocd_w5regular_">$</span> symbol. The values of these variables are automatically substituted into the resulting string when it’s evaluated. When you run this code snippet, the output should therefore look like this:</p>
<pre class="calibre10"><code class="calibre11">My name is John and I'm 30 years old.</code></pre>
<p class="tx">Notice how <span class="sans_thesansmonocd_w5regular_">John</span> and <span class="sans_thesansmonocd_w5regular_">30</span> have been inserted into the string in place of <span class="sans_thesansmonocd_w5regular_">$name</span> and <span class="sans_thesansmonocd_w5regular_">$age</span>. Compare the string template syntax with how we might generate the same message using string concatenation:</p>
<pre class="calibre10"><code class="calibre11">val message = "My name is " + name + " and I'm " + age + " years old."</code></pre>
<p class="tni"><span aria-label="16" epub:type="pagebreak" id="pg_16" role="doc-pagebreak"/>The string template version is much more readable and spares us from the tedium of including all the <span class="sans_thesansmonocd_w5regular_">+</span> operators and remembering to add spaces to the strings before and after each variable. This isn’t to say that string concatenation is never useful, but if your goal is to inject values from your code into a string, a string template is likely the better choice.</p>
<p class="tx">String templates can also handle more complex expressions by enclosing them within braces (the <span class="sans_thesansmonocd_w5regular_">{</span>and} symbols) after the dollar sign. This allows you to perform calculations, access object properties, or invoke functions directly within the template. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">val x = 20
val y = 15
val result = "$x + $y = ${x + y}"
println(result) // output: 20 + 15 = 35</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">${x</span> <span class="sans_thesansmonocd_w5regular_">+</span> <span class="sans_thesansmonocd_w5regular_">y}</span> in this string template tells Kotlin to add the values in the <span class="sans_thesansmonocd_w5regular_">x</span> and <span class="sans_thesansmonocd_w5regular_">y</span> variables and insert the result into the string.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="h1" id="sec16"><span id="h2-10"/><span class="sans_futura_std_bold_condensed_oblique_">Escape Sequences</span></h4>
<p class="tni"><i class="calibre9">Escape sequences</i> are special character combinations used in strings to represent characters such as whitespace that are difficult to input directly. They’re prefixed with a backslash. For example, the escape sequence <span class="sans_thesansmonocd_w5regular_">\n</span> represents a newline character, and <span class="sans_thesansmonocd_w5regular_">\t</span> represents a tab character. Escape sequences are often used within string templates to format the output. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    val name = "John"
    val age = 30

    // using escape characters in string template
    val message = "Name: $name\nAge: $age"

    println(message)
}</code></pre>
<p class="tx">In this example, the <span class="sans_thesansmonocd_w5regular_">\n</span> in the middle of the <span class="sans_thesansmonocd_w5regular_">message</span> string adds a line break between the name and age, improving the formatting of the output. If you run the code, the output should break across two lines, like this:</p>
<pre class="calibre10"><code class="calibre11">Name: John
Age: 30</code></pre>
<p class="tx">Other common escape sequences include <span class="sans_thesansmonocd_w5regular_">\\</span> for a backslash and <span class="sans_thesansmonocd_w5regular_">\$</span> for a dollar sign. These are needed because otherwise a backslash in a string is interpreted as the start of an escape sequence and a dollar sign as the start of some Kotlin code to be inserted into a string template.</p>
</section>
</section>
<section aria-labelledby="sec17" epub:type="division">
<span aria-label="17" epub:type="pagebreak" id="pg_17" role="doc-pagebreak"/>
<h3 class="h" id="sec17"><span id="h1-12"/><span class="sans_futura_std_bold_b_">Null and Nullable Types</span></h3>
<p class="tni"><i class="calibre9">Null</i> represents the absence of a value. By default, Kotlin’s type system assumes that a variable can’t hold <span class="sans_thesansmonocd_w5regular_">null</span>. Consider this example:</p>
<pre class="calibre10"><code class="calibre11">var str: String = "Hello, world!"  // valid initialization
str = null  // invalid, will result in compilation error</code></pre>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">str</span> variable is declared to be of the <span class="sans_thesansmonocd_w5regular_">String</span> type, so its value must be a string. Trying to set the variable to <span class="sans_thesansmonocd_w5regular_">null</span> will therefore trigger an error. If you want to allow a variable to be <span class="sans_thesansmonocd_w5regular_">null</span>, you must explicitly declare the variable to be of a <i class="calibre9">nullable type</i> by appending <span class="sans_thesansmonocd_w5regular_">?</span> to the type declaration, as shown here:</p>
<pre class="calibre10"><code class="calibre11">var str: String? = "hello world" // valid initialization
str = null // reassigned to null, no compilation error</code></pre>
<p class="tni">The type declaration <span class="sans_thesansmonocd_w5regular_">str: String?</span> indicates that the <span class="sans_thesansmonocd_w5regular_">str</span> variable can hold either a string or <span class="sans_thesansmonocd_w5regular_">null</span>. Because the variable is of the <span class="sans_thesansmonocd_w5regular_">String?</span> nullable type, setting it to <span class="sans_thesansmonocd_w5regular_">null</span> is now valid and won’t cause an error.</p>
<p class="tx">Kotlin’s not-nullable-by-default type system is designed to prevent <i class="calibre9">null pointer exceptions</i>, which are common runtime errors in languages that freely allow variables to have null values. A null pointer exception occurs when a program tries to access or manipulate data using a null reference, which doesn’t point to a valid memory location or object. Proper handling of null values is essential to prevent these exceptions and the code from crashing.</p>
<p class="tx">You can ensure null safety in Kotlin in multiple ways. One way is to explicitly check whether a nullable variable holds <span class="sans_thesansmonocd_w5regular_">null</span>, before accessing its properties or methods. For instance:</p>
<pre class="calibre10"><code class="calibre11">val str: String? = "Hello, world!"
val len = if (str != null) str.length else -1</code></pre>
<p class="tni">In this example, we check whether the variable <span class="sans_thesansmonocd_w5regular_">str</span> is <span class="sans_thesansmonocd_w5regular_">null</span> by using an <span class="sans_thesansmonocd_w5regular_">if...else</span> conditional statement. If <span class="sans_thesansmonocd_w5regular_">str</span> is not <span class="sans_thesansmonocd_w5regular_">null</span>, its <span class="sans_thesansmonocd_w5regular_">length</span> property is accessed; otherwise, <span class="sans_thesansmonocd_w5regular_">-1</span> is assigned to <span class="sans_thesansmonocd_w5regular_">len</span>. (We’ll discuss conditional statements in the next section.)</p>
<p class="tx">Another mechanism is Kotlin’s <i class="calibre9">safe call operator</i> (<span class="sans_thesansmonocd_w5regular_">?.</span>), which allows us to call a method on a nullable object without risking an error. If the object contains <span class="sans_thesansmonocd_w5regular_">null</span>, the result is <span class="sans_thesansmonocd_w5regular_">null</span> as well. Otherwise, the method is called as usual. For example:</p>
<pre class="calibre10"><code class="calibre11">val len = str?.length</code></pre>
<p class="tni">In this case, if <span class="sans_thesansmonocd_w5regular_">str</span> is <span class="sans_thesansmonocd_w5regular_">null</span>, <span class="sans_thesansmonocd_w5regular_">len</span> will be assigned <span class="sans_thesansmonocd_w5regular_">null</span>; otherwise, <span class="sans_thesansmonocd_w5regular_">len</span> will be assigned the length (number of characters) of <span class="sans_thesansmonocd_w5regular_">str</span>.</p>
<p class="tx">Kotlin also provides the <i class="calibre9">Elvis operator</i> (<span class="sans_thesansmonocd_w5regular_">?:</span>). Used in conjunction with the safe call operator, it allows you to give a default value (instead of <span class="sans_thesansmonocd_w5regular_">null</span>) for an expression involving a nullable object. If the object isn’t <span class="sans_thesansmonocd_w5regular_">null</span>, the <span aria-label="18" epub:type="pagebreak" id="pg_18" role="doc-pagebreak"/>expression will be evaluated as normal; otherwise, the default value will be used. For example:</p>
<pre class="calibre10"><code class="calibre11">val len = str?.length ?: -1</code></pre>
<p class="tni">In this case, if <span class="sans_thesansmonocd_w5regular_">str</span> isn’t <span class="sans_thesansmonocd_w5regular_">null</span>, its length will be assigned to the <span class="sans_thesansmonocd_w5regular_">len</span> variable; otherwise, the value after the <span class="sans_thesansmonocd_w5regular_">?:</span> operator (<span class="sans_thesansmonocd_w5regular_">-1)</span> will be assigned.</p>
<blockquote class="calibre17">
<p class="note"><span class="sans_dogma_ot_bold_b_15-n">NOTE</span></p>
</blockquote>
<p class="note-txt"><i class="calibre9">The examples we’ve discussed so far have focused on the</i> <span class="sans_thesansmonocd_w5regular_italic_">String?</span> <i class="calibre9">nullable type, but note that the</i> <span class="sans_thesansmonocd_w5regular_italic_">?</span> <i class="calibre9">operator can be applied to other data types, such as</i> <span class="sans_thesansmonocd_w5regular_italic_">Int</span><i class="calibre9">,</i> <span class="sans_thesansmonocd_w5regular_italic_">Double</span><i class="calibre9">, or even</i> <span class="sans_thesansmonocd_w5regular_italic_">Boolean</span><i class="calibre9">. This flexibility in using nullable types is particularly helpful when working with user input.</i></p>
<p class="tx">Finally, Kotlin has another related operator called the <i class="calibre9">null assertion operator</i> (also called the <i class="calibre9">double-bang operator</i>), denoted by two exclamation points (<span class="sans_thesansmonocd_w5regular_">!!</span>). It can be used to assert that a nullable variable doesn’t contain <span class="sans_thesansmonocd_w5regular_">null</span> even though the compiler can’t guarantee this to be true. Using <span class="sans_thesansmonocd_w5regular_">!!</span> is a way of saying that you’re sure a particular nullable variable isn’t <span class="sans_thesansmonocd_w5regular_">null</span> so that the compiler will skip checking for nullability. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">val name: String? = "John"
val length = name!!.length</code></pre>
<p class="tx">We declare <span class="sans_thesansmonocd_w5regular_">name</span> as a nullable string, but by using <span class="sans_thesansmonocd_w5regular_">!!</span> while accessing the string’s length, we’re asserting that it’s not <span class="sans_thesansmonocd_w5regular_">null</span>. If <span class="sans_thesansmonocd_w5regular_">name</span> actually were <span class="sans_thesansmonocd_w5regular_">null</span>, this snippet would result in a <span class="sans_thesansmonocd_w5regular_">NullPointerException</span>. As such, it’s best to avoid or limit the use of the null assertion operator and favor safer constructs like safe calls (<span class="sans_thesansmonocd_w5regular_">?.</span>) and null checks (<span class="sans_thesansmonocd_w5regular_">?:</span>). Alternatively, aim to design your code to reduce nullable types, for increased reliability and predictability.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="h" id="sec18"><span id="h1-13"/><span class="sans_futura_std_bold_b_">Flow Control</span></h3>
<p class="tni"><i class="calibre9">Flow control</i> is an essential aspect of programming, providing mechanisms to regulate when and how code is executed. Kotlin’s flow control constructs enable developers to create flexible and dynamic programs by effectively managing the sequence of statements and controlling the program’s behavior. In this section we’ll discuss two important types of control structures: conditionals and loops. These concepts are foundational to any programming language.</p>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="h1" id="sec19"><span id="h2-11"/><span class="sans_futura_std_bold_condensed_oblique_">Conditional Statements</span></h4>
<p class="tni">Conditional statements allow you to determine what a program should do based on certain tests. Kotlin has two primary conditional statements: <span class="sans_thesansmonocd_w5regular_">if</span> and <span class="sans_thesansmonocd_w5regular_">when</span>. They both introduce branching into code, the idea that a program can take different forks depending on the circumstances. In general, <span class="sans_thesansmonocd_w5regular_">if</span> statements are appropriate for straightforward binary decisions or when facing a limited number of conditions. On the other hand, if you need to <span aria-label="19" epub:type="pagebreak" id="pg_19" role="doc-pagebreak"/>manage several conditions, handle various cases, or strive for cleaner and more structured code when implementing branching logic, <span class="sans_thesansmonocd_w5regular_">when</span> could be your preferred tool.</p>
<section aria-labelledby="sec20" epub:type="division">
<h5 class="h2" id="sec20"><span id="h3-3"/><span class="sans_futura_std_bold_b_">if Statements</span></h5>
<p class="tni">An <span class="sans_thesansmonocd_w5regular_">if</span> statement runs a block of code when a given condition evaluates to <span class="sans_thesansmonocd_w5regular_">true</span>. Here’s a simple example:</p>
<pre class="calibre10"><code class="calibre11">val x = 10
if (x &gt; 0) println("x is positive")</code></pre>
<p class="tni">The condition for an <span class="sans_thesansmonocd_w5regular_">if</span> statement, in this case <span class="sans_thesansmonocd_w5regular_">x &gt; 0</span>, must be an expression that evaluates to a Boolean <span class="sans_thesansmonocd_w5regular_">true</span> or <span class="sans_thesansmonocd_w5regular_">false</span> value, and it must be given in parentheses after the <span class="sans_thesansmonocd_w5regular_">if</span> keyword. The code after the condition will run if the condition is <span class="sans_thesansmonocd_w5regular_">true</span>, so this snippet prints a message only when the variable <span class="sans_thesansmonocd_w5regular_">x</span> has a positive value. If <span class="sans_thesansmonocd_w5regular_">x</span> isn’t positive, the <span class="sans_thesansmonocd_w5regular_">println</span> statement will simply be skipped.</p>
<p class="tx">An <span class="sans_thesansmonocd_w5regular_">if</span> statement can have an optional <span class="sans_thesansmonocd_w5regular_">else</span> clause that gets executed if the test expression evaluates to <span class="sans_thesansmonocd_w5regular_">false</span>. Once an <span class="sans_thesansmonocd_w5regular_">else</span> clause is included (or if there’s just an <span class="sans_thesansmonocd_w5regular_">if</span> clause but it includes multiple lines of code), the body of each clause should be indented and enclosed in braces, as shown here:</p>
<pre class="calibre10"><code class="calibre11">val x = -10
if (x &gt; 0) {
    println("x is positive")
} else {
    println("x is not positive")
}</code></pre>
<p class="tx">This time, since the <span class="sans_thesansmonocd_w5regular_">x &gt; 0</span> condition evaluates to <span class="sans_thesansmonocd_w5regular_">false</span>, the code in the <span class="sans_thesansmonocd_w5regular_">else</span> clause will run. Notice how the opening brace goes on the same line as the <span class="sans_thesansmonocd_w5regular_">if</span> or <span class="sans_thesansmonocd_w5regular_">else</span> keyword, while the closing brace goes on a new line after the last statement in that clause.</p>
<p class="tx">You can extend an <span class="sans_thesansmonocd_w5regular_">if...else</span> structure to include three or more possible branches by adding <span class="sans_thesansmonocd_w5regular_">else if</span> clauses between the initial <span class="sans_thesansmonocd_w5regular_">if</span> and the final <span class="sans_thesansmonocd_w5regular_">else</span>. Each <span class="sans_thesansmonocd_w5regular_">else if</span> clause adds a new condition to test if the previous condition is found to be <span class="sans_thesansmonocd_w5regular_">false</span>. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    val a = 100
    val b = -30
  <span aria-label="annotation1" class="code_codeannotation">❶</span> val max: Int

    if (a &gt; b) {
        max = a
        println("a is greater than b.")
        println("max of $a and $b is: $max")
    } else if (a &lt; b) {
        max = b
        println("b is greater than a.")
<span aria-label="20" epub:type="pagebreak" id="pg_20" role="doc-pagebreak"/>        println("max of $a and $b is: $max")
    } else
        println("a and b have the same value: $a")
}</code></pre>
<p class="tx">Here, we initialize two variables, <span class="sans_thesansmonocd_w5regular_">a</span> and <span class="sans_thesansmonocd_w5regular_">b</span>, with the values <span class="sans_thesansmonocd_w5regular_">100</span> and <span class="sans_thesansmonocd_w5regular_">-30</span>, respectively. Subsequently, we declare a variable <span class="sans_thesansmonocd_w5regular_">max</span> of type <span class="sans_thesansmonocd_w5regular_">Int</span> without providing an initial value <span aria-label="annotation1" class="codeannotation">❶</span>. (In Kotlin, this is allowed as long as the variable will eventually be initialized before using it for the first time.) We then use an <span class="sans_thesansmonocd_w5regular_">if...else if...else</span> structure to compare the values of <span class="sans_thesansmonocd_w5regular_">a</span> and <span class="sans_thesansmonocd_w5regular_">b</span> and print an appropriate message. First, the <span class="sans_thesansmonocd_w5regular_">if</span> clause tests if <span class="sans_thesansmonocd_w5regular_">a</span> is greater than <span class="sans_thesansmonocd_w5regular_">b</span>. If this fails, the <span class="sans_thesansmonocd_w5regular_">else if</span> clause tests if <span class="sans_thesansmonocd_w5regular_">a</span> is less than <span class="sans_thesansmonocd_w5regular_">b</span>. If this also fails, <span class="sans_thesansmonocd_w5regular_">a</span> and <span class="sans_thesansmonocd_w5regular_">b</span> must be equal, as the <span class="sans_thesansmonocd_w5regular_">else</span> clause says.</p>
<p class="tx">The syntax for this kind of control structure is:</p>
<pre class="calibre10"><code class="calibre11">if (<var class="calibre18">condition 1</var>) {
    // code to execute when condition 1 is true
} else if (<var class="calibre18">condition 2</var>) {
    // code to execute when condition 2 is true
} else {
    // code to execute when conditions 1 and 2 are not true
}</code></pre>
<p class="tni">You can adjust this template by adding more <span class="sans_thesansmonocd_w5regular_">else if</span> blocks or deleting them altogether, depending on your needs.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h5 class="h2" id="sec21"><span id="h3-4"/><span class="sans_futura_std_bold_b_">when Statements</span></h5>
<p class="tni">A <span class="sans_thesansmonocd_w5regular_">when</span> statement checks a value against multiple conditions and executes the code block of the first matching condition. If you’re familiar with <span class="sans_thesansmonocd_w5regular_">switch</span> statements from languages like Java, C, or C++, the concept is similar. A <span class="sans_thesansmonocd_w5regular_">when</span> statement can also have an <span class="sans_thesansmonocd_w5regular_">else</span> clause for when none of the conditions match, as shown here:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    val x = 5

    when {
        x &gt; 0 -&gt; println("x is positive")
        x == 0 -&gt; println("x is zero")
        x &lt; 0 -&gt; println("x is negative")
        else -&gt; println("x is not a real number")
    }
}</code></pre>
<p class="tx">We assign a value of <span class="sans_thesansmonocd_w5regular_">5</span> to the variable <span class="sans_thesansmonocd_w5regular_">x</span>, then use a <span class="sans_thesansmonocd_w5regular_">when</span> statement to test this variable’s value. Each line of the <span class="sans_thesansmonocd_w5regular_">when</span> statement has its own conditional test (such as <span class="sans_thesansmonocd_w5regular_">x &gt; 0</span>) followed by the <span class="sans_thesansmonocd_w5regular_">-&gt;</span> symbol, which points to the expression that should be executed if the condition is <span class="sans_thesansmonocd_w5regular_">true</span>. As soon as a <span class="sans_thesansmonocd_w5regular_">true</span> condition is found, the remainder of the <span class="sans_thesansmonocd_w5regular_">when</span> statement is skipped, even if it contains additional tests that would pass. In this case, since <span class="sans_thesansmonocd_w5regular_">x</span> is greater than <span class="sans_thesansmonocd_w5regular_">0</span>, the <span class="sans_thesansmonocd_w5regular_">when</span> statement will print <span class="sans_thesansmonocd_w5regular_">"x is positive"</span>.</p>
<p class="tx"><span aria-label="21" epub:type="pagebreak" id="pg_21" role="doc-pagebreak"/>As with <span class="sans_thesansmonocd_w5regular_">if</span> statements, including an <span class="sans_thesansmonocd_w5regular_">else</span> clause in a <span class="sans_thesansmonocd_w5regular_">when</span> statement is optional. However, it’s considered good practice to provide an <span class="sans_thesansmonocd_w5regular_">else</span> clause; it improves the robustness of your code by offering a fallback option for unmatched cases.</p>
<p class="tx">It’s also possible to provide the variable to be tested in parentheses immediately after the <span class="sans_thesansmonocd_w5regular_">when</span> keyword. In this case, the <span class="sans_thesansmonocd_w5regular_">when</span> statement conducts tests based on exact values or ranges of values for that variable, without repeating the variable name. For example:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    val hour = 13

    when (hour) {
        in 0..11 -&gt; println("Good morning")
        in 12..16 -&gt; println("Good afternoon")
        in 17..23 -&gt; println("Good evening")
        else -&gt; println("Invalid hour")
    }
}</code></pre>
<p class="tx">Here, we pass the <span class="sans_thesansmonocd_w5regular_">hour</span> variable to the <span class="sans_thesansmonocd_w5regular_">when</span> statement, which prints different greetings based on the variable’s value. For example, the condition <span class="sans_thesansmonocd_w5regular_">in 0..11</span> tests whether the value of <span class="sans_thesansmonocd_w5regular_">hour</span> is between <span class="sans_thesansmonocd_w5regular_">0</span> and <span class="sans_thesansmonocd_w5regular_">11</span>, inclusive. We’ll look more closely at how to use the <span class="sans_thesansmonocd_w5regular_">..</span> operator to specify a range of values in the next section, when we discuss loops.</p>
<aside aria-label="box-2" class="box2">
<p class="boxtitle" id="box-2"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Create a program that determines a user’s eligibility to vote based on their age. Follow these steps to complete the exercise:</span></p>
<div class="spc">
<p class="boxlistnumber"><span class="sans_futura_std_book_">1.  Prompt the user to enter their age as an integer. As we’ll discuss in</span> <span class="sans_futura_std_book_">“Basic Input and Output” on <a href="#pg_37" class="calibre2">page 37</a>, this can be done as follows:</span></p>
<pre class="calibre10"><code class="calibre11">println("Enter your age:")
val age = readln()</code></pre>
<p class="boxlistnumber"><span class="sans_futura_std_book_">2.  Use a conditional</span> <span class="sans_thesansmonocd_w5regular_">if...else</span> <span class="sans_futura_std_book_">statement to check the user’s age and provide an appropriate response:</span></p>
<p class="boxlistlettersub"><span class="sans_futura_std_book_">a.  If the age is less than 18, display a message saying, “You are not eligible to vote yet.”</span></p>
<p class="boxlistlettersub"><span class="sans_futura_std_book_">b.  If the age is between 18 and 120 (inclusive), display a message saying, “You are eligible to vote.”</span></p>
<p class="boxlistlettersub"><span class="sans_futura_std_book_">c.  If the age is greater than 120, display a message saying, “Please enter a valid age.”</span></p>
<p class="boxlistnumber"><span aria-label="22" epub:type="pagebreak" id="pg_22" role="doc-pagebreak"/><span class="sans_futura_std_book_">3.  Run the program and test it with various ages to verify that it accurately determines eligibility to vote based on the age entered.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">4.  Repeat these steps using a</span> <span class="sans_thesansmonocd_w5regular_">when</span> <span class="sans_futura_std_book_">statement instead of</span> <span class="sans_thesansmonocd_w5regular_">if...else</span><span class="sans_futura_std_book_">.</span></p>
</div>
</aside>
</section>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="h1" id="sec22"><span id="h2-12"/><span class="sans_futura_std_bold_condensed_oblique_">Loops</span></h4>
<p class="tni"><i class="calibre9">Loops</i> are essential constructs in programming that allow you to repeat a block of code multiple times. Kotlin offers a few types of loops, each with its own use cases and advantages. In this section, we’ll explore loops in Kotlin, including how to specify ranges for iteration.</p>
<section aria-labelledby="sec23" epub:type="division">
<h5 class="h2" id="sec23"><span id="h3-5"/><span class="sans_futura_std_bold_b_">for Loops</span></h5>
<p class="tni">A <span class="sans_thesansmonocd_w5regular_">for</span> loop iterates through the elements in a collection, such as an array, list, or range. One common usage is to loop through a range of numbers, effectively creating a loop with a fixed number of repetitions. As we just saw with <span class="sans_thesansmonocd_w5regular_">when</span> statements, an inclusive range is specified in Kotlin using the <span class="sans_thesansmonocd_w5regular_">..</span> operator. Here’s how this syntax fits with a <span class="sans_thesansmonocd_w5regular_">for</span> loop:</p>
<pre class="calibre10"><code class="calibre11">// inclusive range (1 to 4)
for (i in 1..4) {
    println("Current value of i is: $i")
}</code></pre>
<p class="tx">The logic governing a <span class="sans_thesansmonocd_w5regular_">for</span> loop is given in parentheses immediately after the <span class="sans_thesansmonocd_w5regular_">for</span> keyword. In this case, we create the loop variable <span class="sans_thesansmonocd_w5regular_">i</span>, which takes on values <span class="sans_thesansmonocd_w5regular_">1</span> through <span class="sans_thesansmonocd_w5regular_">4</span> (inclusive). In the body of the loop, which is enclosed in braces, we print the current value of <span class="sans_thesansmonocd_w5regular_">i</span> using a string template. This <span class="sans_thesansmonocd_w5regular_">for</span> loop should produce the following output:</p>
<pre class="calibre10"><code class="calibre11">Current value of i is: 1
Current value of i is: 2
Current value of i is: 3
Current value of i is: 4</code></pre>
<p class="tx">If you want to create a range that excludes the last value, use the <span class="sans_thesansmonocd_w5regular_">until</span> keyword instead of the <span class="sans_thesansmonocd_w5regular_">..</span> operator. Additionally, with either style of range, you can specify a <i class="calibre9">step</i> value to increment the loop variable by some amount other than <span class="sans_thesansmonocd_w5regular_">1</span>. Here we use an <span class="sans_thesansmonocd_w5regular_">until</span> range with a step size of <span class="sans_thesansmonocd_w5regular_">3</span>:</p>
<pre class="calibre10"><code class="calibre11">// exclusive range with step
for (i in 1 until 10 step 3) {
    println("Current value of i is: $i")
}</code></pre>
<p class="tx"><span aria-label="23" epub:type="pagebreak" id="pg_23" role="doc-pagebreak"/>In this example, the loop variable <span class="sans_thesansmonocd_w5regular_">i</span> begins with a value of <span class="sans_thesansmonocd_w5regular_">1</span> and then increases by <span class="sans_thesansmonocd_w5regular_">3</span> each time through the loop, taking on the values <span class="sans_thesansmonocd_w5regular_">4</span> and <span class="sans_thesansmonocd_w5regular_">7</span> before the loop terminates. The output should look like this:</p>
<pre class="calibre10"><code class="calibre11">Current value of i is: 1
Current value of i is: 4
Current value of i is: 7</code></pre>
<p class="tni">Notice that there’s no output line for when <span class="sans_thesansmonocd_w5regular_">i</span> is <span class="sans_thesansmonocd_w5regular_">10</span>. This is because we used <span class="sans_thesansmonocd_w5regular_">until</span>, which excludes the upper bound of the range.</p>
<p class="tx">If you need a <span class="sans_thesansmonocd_w5regular_">for</span> loop to iterate in reverse order, create a range with the <span class="sans_thesansmonocd_w5regular_">downTo</span> keyword. This keyword allows you to specify a range where the loop variable starts at a higher value and counts down to a lower value. Like the <span class="sans_thesansmonocd_w5regular_">..</span> operator, <span class="sans_thesansmonocd_w5regular_">downTo</span> ranges are inclusive. Here’s how it works:</p>
<pre class="calibre10"><code class="calibre11">for (i in 4 downTo 1) {
    println("Current value of i is: $i")
}</code></pre>
<p class="tni">This <span class="sans_thesansmonocd_w5regular_">for</span> loop should output the following:</p>
<pre class="calibre10"><code class="calibre11">Current value of i is: 4
Current value of i is: 3
Current value of i is: 2
Current value of i is: 1</code></pre>
<p class="tni">Thanks to the <span class="sans_thesansmonocd_w5regular_">downTo</span> keyword, the looping variable <span class="sans_thesansmonocd_w5regular_">i</span> counts down from <span class="sans_thesansmonocd_w5regular_">4</span> to <span class="sans_thesansmonocd_w5regular_">1</span>.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h5 class="h2" id="sec24"><span id="h3-6"/><span class="sans_futura_std_bold_b_">continue and break Statements</span></h5>
<p class="tni">Kotlin makes it possible to disrupt the flow of a <span class="sans_thesansmonocd_w5regular_">for</span> loop using the <span class="sans_thesansmonocd_w5regular_">continue</span> and <span class="sans_thesansmonocd_w5regular_">break</span> keywords. Usually, these keywords work in conjunction with an <span class="sans_thesansmonocd_w5regular_">if</span> statement to interrupt the loop when some condition is met. The <span class="sans_thesansmonocd_w5regular_">continue</span> keyword halts the current iteration of the loop and immediately skips ahead to the next iteration. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">for (i in 1..4) {
    if (i == 3) {
        // Skip the current iteration when i is 3.
        continue
    }
    println("Current value of i is: $i")
}</code></pre>
<p class="tx">When the loop variable is set to <span class="sans_thesansmonocd_w5regular_">3</span>, the loop will continue by moving on to the next value of the loop variable. As a result, the <span class="sans_thesansmonocd_w5regular_">println()</span> function won’t execute when <span class="sans_thesansmonocd_w5regular_">i</span> is <span class="sans_thesansmonocd_w5regular_">3</span>, yielding the following output:</p>
<pre class="calibre10"><code class="calibre11">Current value of i is: 1
Current value of i is: 2
Current value of i is: 4</code></pre>
<p class="tx"><span aria-label="24" epub:type="pagebreak" id="pg_24" role="doc-pagebreak"/>The <span class="sans_thesansmonocd_w5regular_">break</span> keyword, by contrast, completely terminates a <span class="sans_thesansmonocd_w5regular_">for</span> loop, as shown here:</p>
<pre class="calibre10"><code class="calibre11">for (i in 1..4) {
    if (i == 3) {
        // Exit the loop when i is 3.
        break
    }
    println("Current value of i is: $i")
}</code></pre>
<p class="tni">This loop will “break” when the loop variable equals <span class="sans_thesansmonocd_w5regular_">3</span>. As a result, the output should look like this:</p>
<pre class="calibre10"><code class="calibre11">Current value of i is: 1
Current value of i is: 2</code></pre>
<p class="tni">Even though the range had a few values to go, the <span class="sans_thesansmonocd_w5regular_">break</span> keyword ended the loop early.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h5 class="h2" id="sec25"><span id="h3-7"/><span class="sans_futura_std_bold_b_">Nested and Named for Loops</span></h5>
<p class="tni">It’s common to nest one <span class="sans_thesansmonocd_w5regular_">for</span> loop inside another such that the entire inner <span class="sans_thesansmonocd_w5regular_">for</span> loop executes multiple times, as determined by the outer loop. Here’s an example of a nested set of <span class="sans_thesansmonocd_w5regular_">for</span> loops that prints a pattern of asterisks in a square shape:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    val size = 4 // Change this value to adjust the size of the square.

    // nested for loops to print a square pattern of asterisks
    for (i in 1..size) {
        for (j in 1..size) {
          <span aria-label="annotation1" class="code_codeannotation">❶</span> print("* ")
        }
      <span aria-label="annotation2" class="code_codeannotation">❷</span> println() // Move to the next line after each row.
    }
}</code></pre>
<p class="tx">In this example, the outer loop <span class="sans_thesansmonocd_w5regular_">for (i in 1..size)</span> iterates over the rows, and the inner loop <span class="sans_thesansmonocd_w5regular_">for (j in 1..size)</span> iterates over the columns within each row. The <span class="sans_thesansmonocd_w5regular_">print("* ")</span> statement prints an asterisk followed by a space for each element in a row. Unlike <span class="sans_thesansmonocd_w5regular_">println()</span>, the <span class="sans_thesansmonocd_w5regular_">print()</span> function <span aria-label="annotation1" class="codeannotation">❶</span> doesn’t add a newline character each time it’s called, so each time through the outer loop, the inner loop will print a series of asterisks all together on one line. The empty <span class="sans_thesansmonocd_w5regular_">println()</span> statement after the inner loop <span aria-label="annotation2" class="codeannotation">❷</span> moves the cursor to the next line to separate the rows. The output of this code, with <span class="sans_thesansmonocd_w5regular_">size</span> set to <span class="sans_thesansmonocd_w5regular_">4</span>, should look like this:</p>
<pre class="calibre10"><code class="calibre11">* * * *
* * * *
<span aria-label="25" epub:type="pagebreak" id="pg_25" role="doc-pagebreak"/>* * * *
* * * *</code></pre>
<p class="tx">When you have nested loops, it can be helpful—though not strictly necessary—to assign each loop a name. The name comes before the <span class="sans_thesansmonocd_w5regular_">for</span> keyword and must be followed by an at sign (<span class="sans_thesansmonocd_w5regular_">@</span>). If the loops are named, you can explicitly apply keywords like <span class="sans_thesansmonocd_w5regular_">continue</span> and <span class="sans_thesansmonocd_w5regular_">break</span> to one loop or the other by adding the loop’s name after the keyword. This gives you more control over when and how the nested loops can be disrupted. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">loop1@ for (i in 1..5) {
    loop2@ for (j in 1..5) {
        print("$i,$j ")
      <span aria-label="annotation1" class="code_codeannotation">❶</span> if (i == j) break@loop2
    }
    println()
}</code></pre>
<p class="tx">We have two nested <span class="sans_thesansmonocd_w5regular_">for</span> loops, named <span class="sans_thesansmonocd_w5regular_">loop1</span> and <span class="sans_thesansmonocd_w5regular_">loop2</span>. The loop variables, <span class="sans_thesansmonocd_w5regular_">i</span> and <span class="sans_thesansmonocd_w5regular_">j</span>, both vary from <span class="sans_thesansmonocd_w5regular_">1</span> to <span class="sans_thesansmonocd_w5regular_">5</span> inclusive. Ignoring the conditional logic inside <span class="sans_thesansmonocd_w5regular_">loop2</span> for a moment, this nested loop would iterate for a total of 25 (5 × 5) times, printing each <span class="sans_thesansmonocd_w5regular_">(i,j)</span> pair, starting with <span class="sans_thesansmonocd_w5regular_">(1,1)</span> through <span class="sans_thesansmonocd_w5regular_">(1,5)</span> for the first time through <span class="sans_thesansmonocd_w5regular_">loop1</span>, then <span class="sans_thesansmonocd_w5regular_">(2,1)</span> through <span class="sans_thesansmonocd_w5regular_">(2,5)</span> for the second, and so on. The output would look like this, with the <span class="sans_thesansmonocd_w5regular_">println()</span> after each full cycle of the inner loop again ensuring that each group of five pairs is printed on its own line:</p>
<pre class="calibre10"><code class="calibre11">1,1 1,2 1,3 1,4 1,5
2,1 2,2 2,3 2,4 2,5
3,1 3,2 3,3 3,4 3,5
4,1 4,2 4,3 4,4 4,5
5,1 5,2 5,3 5,4 5,5</code></pre>
<p class="tx">Now consider what the conditional logic in the inner loop does <span aria-label="annotation1" class="codeannotation">❶</span>. It applies the <span class="sans_thesansmonocd_w5regular_">break</span> keyword specifically to <span class="sans_thesansmonocd_w5regular_">loop2</span> (using the syntax <span class="sans_thesansmonocd_w5regular_">break@loop2</span>) if <span class="sans_thesansmonocd_w5regular_">i</span> and <span class="sans_thesansmonocd_w5regular_">j</span> are equal, halting the inner loop and returning to the outer loop for the call to <span class="sans_thesansmonocd_w5regular_">println()</span>. (Notice how the <span class="sans_thesansmonocd_w5regular_">@</span> symbol follows the loop name when the name is being assigned but precedes it when the name is being referenced.) This logic prints only the lower-left portion of the grid of <span class="sans_thesansmonocd_w5regular_">(i,j)</span> pairs, up to the main diagonal, where <span class="sans_thesansmonocd_w5regular_">i</span> and <span class="sans_thesansmonocd_w5regular_">j</span> are equal:</p>
<pre class="calibre10"><code class="calibre11">1,1
2,1 2,2
3,1 3,2 3,3
4,1 4,2 4,3 4,4
5,1 5,2 5,3 5,4 5,5</code></pre>
<p class="tx">In truth, specifying that <span class="sans_thesansmonocd_w5regular_">break</span> applies to <span class="sans_thesansmonocd_w5regular_">loop2</span> isn’t necessary here, since by default, keywords like <span class="sans_thesansmonocd_w5regular_">break</span> and <span class="sans_thesansmonocd_w5regular_">continue</span> apply to the innermost loop that contains them—in this case, <span class="sans_thesansmonocd_w5regular_">loop2</span>. Still, including the loop name helps clarify the intent behind the code. Furthermore, consider that another way to <span aria-label="26" epub:type="pagebreak" id="pg_26" role="doc-pagebreak"/>achieve a similar result would be to replace <span class="sans_thesansmonocd_w5regular_">break@loop2</span> with <span class="sans_thesansmonocd_w5regular_">continue@loop1</span>, in which case referencing the loop name becomes necessary. I encourage you to try making this change as an exercise—you’ll also need to think about what to do with the call to <span class="sans_thesansmonocd_w5regular_">println()</span> to keep the output nicely formatted.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h5 class="h2" id="sec26"><span id="h3-8"/><span class="sans_futura_std_bold_b_">while Loops</span></h5>
<p class="tni">A <span class="sans_thesansmonocd_w5regular_">while</span> loop is best employed when you need to repetitively execute a code block but you don’t know the exact number of iterations in advance. It keeps looping until a termination condition is satisfied. The condition is given in parentheses after the <span class="sans_thesansmonocd_w5regular_">while</span> keyword, before the start of the loop body. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">var count = 0
while (count &lt; 4) {
    println("Current value of count: $count")
    count++
}</code></pre>
<p class="tx">We initialize the <span class="sans_thesansmonocd_w5regular_">count</span> variable to <span class="sans_thesansmonocd_w5regular_">0</span>, then create a <span class="sans_thesansmonocd_w5regular_">while</span> loop that will continue repeating as long as the condition <span class="sans_thesansmonocd_w5regular_">count &lt; 4</span> remains <span class="sans_thesansmonocd_w5regular_">true</span>. The loop checks this condition <i class="calibre9">before</i> each repetition. Inside the loop, we print the current value of <span class="sans_thesansmonocd_w5regular_">count</span> and then increase its value by <span class="sans_thesansmonocd_w5regular_">1</span> using a unary <span class="sans_thesansmonocd_w5regular_">++</span> operator to get ready for the next iteration. This should produce the following output:</p>
<pre class="calibre10"><code class="calibre11">Current value of count: 0
Current value of count: 1
Current value of count: 2
Current value of count: 3</code></pre>
<p class="tx">At the end of the fourth time through the loop, <span class="sans_thesansmonocd_w5regular_">count</span> increments from <span class="sans_thesansmonocd_w5regular_">3</span> to <span class="sans_thesansmonocd_w5regular_">4</span>. Then, when the loop gets ready to start its fifth iteration, it finds that the loop condition is no longer <span class="sans_thesansmonocd_w5regular_">true</span> and the loop terminates.</p>
<p class="tx">Another style of <span class="sans_thesansmonocd_w5regular_">while</span> loop uses the condition <span class="sans_thesansmonocd_w5regular_">while (true)</span>. Since <span class="sans_thesansmonocd_w5regular_">true</span> always evaluates to <span class="sans_thesansmonocd_w5regular_">true</span>, this theoretically sets up an infinite loop. The real conditional logic of halting the loop is instead moved inside the loop body itself. Here’s the same <span class="sans_thesansmonocd_w5regular_">while</span> loop as before, implemented in this other style:</p>
<pre class="calibre10"><code class="calibre11">var count = 0
while (true) {
    println("Current value of count: $count")
    count++
    if (count &gt;= 4) break
}</code></pre>
<p class="tx">This time we use an <span class="sans_thesansmonocd_w5regular_">if</span> statement at the end of the loop body to trigger the <span class="sans_thesansmonocd_w5regular_">break</span> keyword and terminate the loop when <span class="sans_thesansmonocd_w5regular_">count</span> is greater than or equal to <span class="sans_thesansmonocd_w5regular_">4</span>. Without this conditional, the program would get stuck in an infinite loop, causing it to run indefinitely.</p>
<p class="tx"><span aria-label="27" epub:type="pagebreak" id="pg_27" role="doc-pagebreak"/>One further variation on the <span class="sans_thesansmonocd_w5regular_">while</span> loop is the <span class="sans_thesansmonocd_w5regular_">do...while</span> loop, which has the following syntax:</p>
<pre class="calibre10"><code class="calibre11">do {
    // code to be executed
} while (<var class="calibre18">condition</var>)</code></pre>
<p class="tni">A <span class="sans_thesansmonocd_w5regular_">do...while</span> loop checks the stopping condition <i class="calibre9">after</i> each iteration, rather than before. This ensures that the loop will be executed at least once. By contrast, if the condition for a regular <span class="sans_thesansmonocd_w5regular_">while</span> loop is already <span class="sans_thesansmonocd_w5regular_">false</span> before the loop begins, it won’t execute at all.</p>
<p class="tx">Just like <span class="sans_thesansmonocd_w5regular_">for</span> loops, you can nest multiple <span class="sans_thesansmonocd_w5regular_">while</span> loops and use them with the <span class="sans_thesansmonocd_w5regular_">continue</span> keyword as well as with <span class="sans_thesansmonocd_w5regular_">break</span>.</p>
<aside aria-label="box-3" class="box2">
<p class="boxtitle" id="box-3"><span class="sans_futura_std_bold_b_">EXERCISES</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Use</span> <span class="sans_thesansmonocd_w5regular_">for</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">while</span> <span class="sans_futura_std_book_">loops to do the following:</span></p>
<div class="spc">
<p class="boxlistnumber"><span class="sans_futura_std_book_">1.  Write a</span> <span class="sans_thesansmonocd_w5regular_">for</span> <span class="sans_futura_std_book_">loop that prints a right-angled triangle pattern using asterisks (</span><span class="sans_thesansmonocd_w5regular_">*</span><span class="sans_futura_std_book_">). The number of rows in the triangle should be given by a variable called</span> <span class="sans_thesansmonocd_w5regular_">n</span><span class="sans_futura_std_book_">. For example, if</span> <span class="sans_thesansmonocd_w5regular_">n</span> <span class="sans_futura_std_book_">is</span> <span class="sans_thesansmonocd_w5regular_">5</span><span class="sans_futura_std_book_">, the output should be:</span></p>
<pre class="calibre10"><code class="calibre11">*
**
***
****
*****</code></pre>
<p class="boxlistnumber"><span class="sans_futura_std_book_">2.  Write a</span> <span class="sans_thesansmonocd_w5regular_">while</span> <span class="sans_futura_std_book_">loop that checks if a given string is a palindrome. A</span> <span class="sans_futura_std_book_oblique_">palindrome</span> <span class="sans_futura_std_book_">is a word or phrase that’s the same when read forward or backward, such as</span> <span class="sans_futura_std_book_oblique_">radar</span> <span class="sans_futura_std_book_">or</span> <span class="sans_futura_std_book_oblique_">madam</span><span class="sans_futura_std_book_">. The loop should compare the first and last characters of the string, and then move inward until either the characters don’t match or the middle of the string is reached. The loop should print “Palindrome” if the string is a palindrome or “Not a palindrome” otherwise.</span></p>
</div>
</aside>
</section>
</section>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h3 class="h" id="sec27"><span id="h1-14"/><span class="sans_futura_std_bold_b_">Functions</span></h3>
<p class="tni">A <i class="calibre9">function</i> is a reusable block of code that performs a specific task or computation. Functions are a fundamental building block of any Kotlin program and are used to encapsulate logic, promote code reusability, and improve code organization. Kotlin’s standard library comes with many built-in functions to simplify common programming tasks. One example is the <span class="sans_thesansmonocd_w5regular_">println()</span> <span aria-label="28" epub:type="pagebreak" id="pg_28" role="doc-pagebreak"/>function we’ve been using throughout this chapter to output text to the console; other examples include various mathematical functions, some of which we’ll explore shortly. For more specialized tasks particular to the application at hand, you’ll have to create your own custom functions. We’ll discuss how to do that as well.</p>
<section aria-labelledby="sec28" epub:type="division">
<h4 class="h1" id="sec28"><span id="h2-13"/><span class="sans_futura_std_bold_condensed_oblique_">Built-in Mathematical Functions</span></h4>
<p class="tni">Throughout this book, we’ll leverage a multitude of mathematical functions that come prepackaged in the standard Kotlin library. For example, you can effortlessly compute the square root of a number with the <span class="sans_thesansmonocd_w5regular_">sqrt()</span> function or raise a value to a specific power (exponent) using the <span class="sans_thesansmonocd_w5regular_">pow()</span> function. These functions are part of the <span class="sans_thesansmonocd_w5regular_">kotlin.math</span> package and must be <i class="calibre9">imported</i> at the start of a program using the <span class="sans_thesansmonocd_w5regular_">import</span> keyword. Here’s a simple program that uses these two functions:</p>
<pre class="calibre10"><code class="calibre11">import kotlin.math.sqrt
import kotlin.math.pow

fun main() {
    val x = 100.0
    val y = 10.0

    val squareRoot = "The square root of $x is: ${sqrt(x)}"
    val toThePower2 = "$y raised to the 2nd power is: ${y.pow(2.0)}"

    println(squareRoot)
    println(toThePower2)
}</code></pre>
<p class="tx">First, we import the two math functions we need. Then we use them to calculate the square root of <span class="sans_thesansmonocd_w5regular_">x</span> (<span class="sans_thesansmonocd_w5regular_">squareRoot</span>) and <span class="sans_thesansmonocd_w5regular_">y</span> to the second power (<span class="sans_thesansmonocd_w5regular_">toThePower2</span>) inside the string templates using the <span class="sans_thesansmonocd_w5regular_">${}</span> syntax discussed in “<span>String Templates</span>” on <span><a href="#pg_15" class="calibre2">page 15</a></span>. The code segment should produce the following output:</p>
<pre class="calibre10"><code class="calibre11">The square root of 100.0 is: 10.0
10.0 raised to the 2nd power is: 100.0</code></pre>
<p class="tx">In some cases, you may need to use many built-in functions in the same module. Technically, it’s possible to import the entire collection by including an asterisk (<span class="sans_thesansmonocd_w5regular_">*</span>) in the import statement. For example, <span class="sans_thesansmonocd_w5regular_">import kotlin .math.*</span> would import every function in the <span class="sans_thesansmonocd_w5regular_">kotlin.math</span> module. It’s considered good practice to import only the functions you need, however. This approach helps avoid <i class="calibre9">namespace pollution</i>, where your code gets cluttered with unnecessary—or worse, conflicting—identifiers like variable and function names. Importing only what you need gives you more flexibility to name your own variables and functions without causing conflicts with the names of the built-in functions.</p>
<p class="tx"><span aria-label="29" epub:type="pagebreak" id="pg_29" role="doc-pagebreak"/>The remaining functions in the <span class="sans_thesansmonocd_w5regular_">kotlin.math</span> module handle trigonometry and other useful mathematical computations. For a comprehensive list of standard mathematical functions available and instructions on how to use them, search for <span class="sans_thesansmonocd_w5regular_">kotlin.math</span> in the official Kotlin documentation at <span class="copyright_accent"><a href="https://kotlinlang.org" class="calibre2">https://kotlinlang.org</a></span>.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h4 class="h1" id="sec29"><span id="h2-14"/><span class="sans_futura_std_bold_condensed_oblique_">Custom Functions</span></h4>
<p class="tni">When you have some code that accomplishes a particular task in your application—especially a task that will be repeated—it’s common to encapsulate that code in a custom function. This keeps your code well organized and efficient. Each custom function must be <i class="calibre9">declared</i>, or defined, before it can be used. Here’s Kotlin’s syntax for a function declaration:</p>
<pre class="calibre10"><code class="calibre11">fun <var class="calibre18">functionName</var>(<var class="calibre18">parameter1</var>: <var class="calibre18">Type</var>,
                 <var class="calibre18">parameter2</var>: <var class="calibre18">Type</var>, ...): <var class="calibre18">ReturnType</var> {
    // function body
}</code></pre>
<p class="tx">The declaration begins with the <span class="sans_thesansmonocd_w5regular_">fun</span> keyword, followed by the function name and a set of parentheses. Inside the parentheses, you provide the names of the function’s <i class="calibre9">parameters</i>, if any, along with their data types. These parameters serve as placeholders for values that the function expects to receive when it’s called. They allow you to pass data into the function. A function can have many parameters of different data types (including parameters that are other functions) or no parameters at all, in which case the function name will be followed by a set of empty parentheses. When a function is called, specific values, called <i class="calibre9">arguments</i>, are provided for the parameters. Notice that function parameters are implicitly treated as read-only (immutable) variables within the function body. Using <span class="sans_thesansmonocd_w5regular_">val</span> or <span class="sans_thesansmonocd_w5regular_">var</span> on function parameters is not allowed.</p>
<p class="tx">After the parameter list, the function declaration continues with a colon (<span class="sans_thesansmonocd_w5regular_">:</span>) followed by the function’s <i class="calibre9">return type</i>. This specifies the data type of the value the function will generate and provide to its caller. The built-in <span class="sans_thesansmonocd_w5regular_">sqrt()</span> function we discussed in “<span>Built-in Mathematical Functions</span>” on <span><a href="#pg_28" class="calibre2">page 28</a></span> returns the square root of its parameter as either a <span class="sans_thesansmonocd_w5regular_">Double</span> or a <span class="sans_thesansmonocd_w5regular_">Float</span>, for example. If a function returns nothing, you can omit the return type. It will be assumed to be <span class="sans_thesansmonocd_w5regular_">Unit</span>, akin to the <span class="sans_thesansmonocd_w5regular_">void</span> type in other languages. A function would return nothing if, for example, its purpose is to print output to the console, make changes to global variables, make changes to elements of an array or object supplied to the function as an argument, or call other functions.</p>
<p class="tx">Taken together, the function name and the parameter names and types define the <i class="calibre9">signature</i> of the function. The compiler uses function signatures to determine which function to use when multiple functions have the same name but different parameters (a practice called <i class="calibre9">function overloading</i> that we’ll discuss shortly). The return type isn’t part of the function signature, but it’s an important part of the function declaration nonetheless.</p>
<p class="tx"><span aria-label="30" epub:type="pagebreak" id="pg_30" role="doc-pagebreak"/>Once the function signature and the return type are specified (when applicable), all that remains is to declare the function <i class="calibre9">body</i>, which is enclosed in braces. This is the block of code that will be executed when the function is called. It may include additional variable declarations, conditional statements, loops, and expressions—anything necessary for the function to do its work.</p>
<p class="tx">Let’s now examine a real function that performs a simple task: adding two integers together and returning the result. Here’s the function’s declaration:</p>
<pre class="calibre10"><code class="calibre11">fun add(x: Int, y: Int): Int {
    return x + y
}</code></pre>
<p class="tx">We declare a function named <span class="sans_thesansmonocd_w5regular_">add()</span> that takes two parameters, <span class="sans_thesansmonocd_w5regular_">x</span> and <span class="sans_thesansmonocd_w5regular_">y</span>, both of type <span class="sans_thesansmonocd_w5regular_">Int</span>, and returns a value also of type <span class="sans_thesansmonocd_w5regular_">Int</span>. The function body calculates <span class="sans_thesansmonocd_w5regular_">x</span> <span class="sans_thesansmonocd_w5regular_">+</span> <span class="sans_thesansmonocd_w5regular_">y</span> and uses the <span class="sans_thesansmonocd_w5regular_">return</span> keyword to deliver that result to the function caller. Note that if the return type implied by the value being returned is different from the function’s declared return type, the compiler will generate an error. In this case, since both <span class="sans_thesansmonocd_w5regular_">x</span> and <span class="sans_thesansmonocd_w5regular_">y</span> are integers, <span class="sans_thesansmonocd_w5regular_">x</span> <span class="sans_thesansmonocd_w5regular_">+</span> <span class="sans_thesansmonocd_w5regular_">y</span> will be an integer as well.</p>
<p class="tx">With the <span class="sans_thesansmonocd_w5regular_">add()</span> function declared, we can call it from <span class="sans_thesansmonocd_w5regular_">main()</span> as follows:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    // Declare the variables.
    val a = 3
    val b = 6

    // Call the function to add two integers.
    val sum = add(a, b)
    println("The sum of $a and $b is $sum.")
}</code></pre>
<p class="tx">We declare the <span class="sans_thesansmonocd_w5regular_">a</span> and <span class="sans_thesansmonocd_w5regular_">b</span> variables and initialize them to <span class="sans_thesansmonocd_w5regular_">3</span> and <span class="sans_thesansmonocd_w5regular_">6</span>, respectively. Next, we declare <span class="sans_thesansmonocd_w5regular_">sum</span> and assign it the value returned by <span class="sans_thesansmonocd_w5regular_">add()</span>. Running this code should yield the following output:</p>
<pre class="calibre10"><code class="calibre11">The sum of 3 and 6 is 9.</code></pre>
<p class="tx">Kotlin enforces strong typing, so the compiler will flag errors for mismatches between declared parameter types and the types of the arguments passed to the function. The number of arguments should also match the number of parameters, unless some parameters are assigned default values.</p>
<aside aria-label="box-4" class="box">
<p class="boxtitle" id="box-4"><span class="sans_futura_std_bold_b_">SINGLE-EXPRESSION FUNCTIONS</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">In Kotlin, when the compiler can infer a function’s return type and the function body consists of a single expression, you can declare the function using a</span> <span aria-label="31" epub:type="pagebreak" id="pg_31" role="doc-pagebreak"/><span class="sans_futura_std_book_">concise syntax known as a</span> <span class="sans_futura_std_book_oblique_">single-expression function</span><span class="sans_futura_std_book_">. For example, here’s how to declare a simple</span> <span class="sans_thesansmonocd_w5regular_">add()</span> <span class="sans_futura_std_book_">function using this syntax:</span></p>
<pre class="calibre10"><code class="calibre11">fun add(x: Int, y: Int) = (x + y)</code></pre>
<p class="boxlast"><span class="sans_futura_std_book_">The function declaration is compressed to one line, without the need for braces around the function body or a declared return type. In this case, the return type is inferred to be</span> <span class="sans_thesansmonocd_w5regular_">Int</span><span class="sans_futura_std_book_">, and the function body</span> <span class="sans_thesansmonocd_w5regular_">(x</span> <span class="sans_thesansmonocd_w5regular_">+</span> <span class="sans_thesansmonocd_w5regular_">y)</span> <span class="sans_futura_std_book_">is a single expression that directly represents the result of the function—with no need for the</span> <span class="sans_thesansmonocd_w5regular_">return</span> <span class="sans_futura_std_book_">keyword. This shorthand is particularly useful for simple functions with a short, one-line expression.</span></p>
</aside>
<section aria-labelledby="sec30" epub:type="division">
<h5 class="h2" id="sec30"><span id="h3-9"/><span class="sans_futura_std_bold_b_">Providing Default Parameter Values</span></h5>
<p class="tni">If a parameter has the same value most of the time a function is called, it can be given a default, preset value when the function is declared. This way, you need to provide an argument for that parameter only when you want it to be something other than the default. The parameters with default values should be listed last in the function declaration. Here’s an example of how to declare a default parameter value:</p>
<pre class="calibre10"><code class="calibre11">fun greet(name: String, greeting: String = "Hello") {
    println("$greeting $name!")
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">greet()</span> function takes two parameters, <span class="sans_thesansmonocd_w5regular_">name</span> and <span class="sans_thesansmonocd_w5regular_">greeting</span>, and combines them to print out a customized greeting. A value for <span class="sans_thesansmonocd_w5regular_">name</span> will need to be provided each time the function is called, but if no value for <span class="sans_thesansmonocd_w5regular_">greeting</span> is specified, the function will use the default value of <span class="sans_thesansmonocd_w5regular_">"Hello"</span>. This default value is set in the parameter list, after the parameter’s data type.</p>
<p class="tx">If we call the function with <span class="sans_thesansmonocd_w5regular_">greet("Nathan")</span>, supplying an argument only for the <span class="sans_thesansmonocd_w5regular_">name</span> parameter, it should result in the following output, including the default value for <span class="sans_thesansmonocd_w5regular_">greeting</span>:</p>
<pre class="calibre10"><code class="calibre11">Hello Nathan!</code></pre>
<p class="tni">Consider how you would call this function if you wanted it to instead print <span class="sans_thesansmonocd_w5regular_">"Good morning, Nathan!"</span> as a message.</p>
</section>
<section aria-labelledby="sec31" epub:type="division">
<h5 class="h2" id="sec31"><span id="h3-10"/><span class="sans_futura_std_bold_b_">Using Named Arguments</span></h5>
<p class="tni">When a function has many parameters, keeping track of their order and type can be a hassle. Using <i class="calibre9">named arguments</i> comes in handy in such situations. This is a style of function call where you include the parameter names along with the desired argument values. With the names included, the arguments can be given in any order.</p>
<p class="tx"><span aria-label="32" epub:type="pagebreak" id="pg_32" role="doc-pagebreak"/>Say you’ve declared this function with four parameters:</p>
<pre class="calibre10"><code class="calibre11">fun printPersonInfo(firstName: String, lastName: String,
                    age: Int, gender: String) {
    println("Person info: $firstName $lastName, " +
            "Age: $age, Gender: $gender")
}</code></pre>
<p class="tni">Calling the function using named arguments relieves you from the burden of remembering the order in which the parameters were declared:</p>
<pre class="calibre10"><code class="calibre11">printPersonInfo(lastName = "Keller", firstName = "Jeffrey",
                age = 40, gender = "Male")</code></pre>
<p class="tx">Here each argument is given in the form <span class="sans_thesansmonocd_w5regular_italic_">parameterName</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_italic_">value</span>. This function call will work just fine, even though the parameters are out of order, thanks to the use of named arguments. This is allowed as long as you provide names for all arguments or the compiler is able to figure out the order of the arguments.</p>
</section>
<section aria-labelledby="sec32" epub:type="division">
<h5 class="h2" id="sec32"><span id="h3-11"/><span class="sans_futura_std_bold_b_">Overloading a Function</span></h5>
<p class="tni"><i class="calibre9">Function overloading</i> in Kotlin allows you to define multiple functions with the same name in the same scope but with different parameter lists. Perhaps they have a different number of parameters, or the parameters are of different data types. Here’s an example of function overloading:</p>
<pre class="calibre10"><code class="calibre11">// function to add two integers
fun add(a: Int, b: Int): Int {
    return a + b
}

// function to add two doubles
fun add(a: Double, b: Double): Double {
    return a + b
}</code></pre>
<p class="tx">We declare two functions called <span class="sans_thesansmonocd_w5regular_">add()</span> with different parameter lists; one adds two integers, and the other adds two floating-point numbers. When the <span class="sans_thesansmonocd_w5regular_">add()</span> function is called, the compiler will determine which version of the function to invoke by comparing the argument types to the declared function signatures. This is how you would call both functions:</p>
<pre class="calibre10"><code class="calibre11">val result1 = add(2, 3)
val result2 = add(40.5, 23.9)</code></pre>
<p class="tx">With function overloading, you can use the same function name for operations that conceptually do the same thing (in this case, addition) but with different parameter types. This makes your code more readable, intuitive, and error resistant. In this example, we’ve anticipated that we may <span aria-label="33" epub:type="pagebreak" id="pg_33" role="doc-pagebreak"/>want to add floating-point numbers as well as integers. Overloading the function gives us the flexibility to do either without triggering an error.</p>
</section>
<section aria-labelledby="sec33" epub:type="division">
<h5 class="h2" id="sec33"><span id="h3-12"/><span class="sans_futura_std_bold_b_">Referencing a Function Without Calling It</span></h5>
<p class="tni">In Kotlin, you can use the member reference operator (<span class="sans_thesansmonocd_w5regular_">::</span>) to refer to a function by its name without actually invoking it. This is helpful in many situations, such as when you need to assign a function reference to a variable. Say you have two functions and you’re trying to decide which to use in your code. Perhaps they’re both ways of accomplishing the same task and you want to see which is more efficient, or perhaps they implement two different operations that would be appropriate in different situations. Rather than rewriting all the code to call one function or the other, you can assign to a variable a reference to the appropriate function and then call the function (whichever one you choose) via the variable, minimizing the changes to the code. Here’s an example illustrating how this works:</p>
<pre class="calibre10"><code class="calibre11">fun add(x: Double, y: Double): Double {
    return x + y
}

fun multiply(x: Double, y: Double): Double {
    return x * y
}

// Change this condition to use add() or multiply().
val useAdd = true

fun main() {
    // Declare a function variable using member reference.
  <span aria-label="annotation1" class="code_codeannotation">❶</span> val selectedFunction = if (useAdd) ::add else ::multiply

    val x = 3.0
    val y = 4.0

    // Calculate the value of the selected function.
  <span aria-label="annotation2" class="code_codeannotation">❷</span> val result = selectedFunction(x, y)

    // Print the result.
    println("Result: $result")
}</code></pre>
<p class="tx">We first declare two functions: <span class="sans_thesansmonocd_w5regular_">add()</span> calculates the sum of <span class="sans_thesansmonocd_w5regular_">x</span> and <span class="sans_thesansmonocd_w5regular_">y</span>, and <span class="sans_thesansmonocd_w5regular_">multiply()</span> calculates the product of <span class="sans_thesansmonocd_w5regular_">x</span> and <span class="sans_thesansmonocd_w5regular_">y</span>. We’ll want to use only one of these functions in <span class="sans_thesansmonocd_w5regular_">main()</span>. To control which one, we declare a Boolean variable <span class="sans_thesansmonocd_w5regular_">useAdd</span> and set it to <span class="sans_thesansmonocd_w5regular_">true</span>. Inside the <span class="sans_thesansmonocd_w5regular_">main()</span> function, we then create another variable named <span class="sans_thesansmonocd_w5regular_">selectedFunction</span> and use <i class="calibre9">conditional expression syntax</i> to set its value to one of the functions <span aria-label="annotation1" class="codeannotation">❶</span>. This syntax uses an <span class="sans_thesansmonocd_w5regular_">if...else</span> structure to return a value and assign it to a variable based on a condition—in this case, the state of the <span class="sans_thesansmonocd_w5regular_">useAdd</span> variable. If <span class="sans_thesansmonocd_w5regular_">useAdd</span> is <span class="sans_thesansmonocd_w5regular_">true</span>, <span class="sans_thesansmonocd_w5regular_">selectedFunction</span> is assigned a reference to <span class="sans_thesansmonocd_w5regular_">add()</span>; otherwise, it references <span class="sans_thesansmonocd_w5regular_">multiply()</span>. Notice how we precede each function name with the <span class="sans_thesansmonocd_w5regular_">::</span> operator and don’t include <span aria-label="34" epub:type="pagebreak" id="pg_34" role="doc-pagebreak"/>parentheses after the function name, since we’re referencing rather than invoking the functions. With the <span class="sans_thesansmonocd_w5regular_">selectedFunction</span> variable holding a reference to a function, we can now invoke that function by calling <span class="sans_thesansmonocd_w5regular_">selectedFunction()</span> rather than by calling <span class="sans_thesansmonocd_w5regular_">add()</span> or <span class="sans_thesansmonocd_w5regular_">multiply()</span> directly <span aria-label="annotation2" class="codeannotation">❷</span>. We store the returned value in the <span class="sans_thesansmonocd_w5regular_">result</span> variable and print it to the console.</p>
<p class="tx">Try changing the value of <span class="sans_thesansmonocd_w5regular_">useAdd</span> from <span class="sans_thesansmonocd_w5regular_">true</span> to <span class="sans_thesansmonocd_w5regular_">false</span> to switch between using <span class="sans_thesansmonocd_w5regular_">add()</span> and <span class="sans_thesansmonocd_w5regular_">multiply()</span>. Then consider how convenient this solution is for toggling between two functions, especially if you need to use the function in multiple places in the code. Instead of updating the function name at each usage, we can simply change the value of <span class="sans_thesansmonocd_w5regular_">useAdd</span> and rely on the <span class="sans_thesansmonocd_w5regular_">selectedFunction</span> variable to stand in for whichever function we want.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">::</span> operator is particularly useful when you need to pass a function reference as an argument to another function. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">fun printMessage(message: String) {
    println(message)
}

fun applyFunction(function: (String) -&gt; Unit, input: String) {
    function(input)
}

fun main() {
    // using :: to reference the printMessage function
    applyFunction(::printMessage, "Hello, Kotlin!")
}</code></pre>
<p class="tx">We define a function called <span class="sans_thesansmonocd_w5regular_">printMessage()</span> that takes a string parameter and prints it to the console. We also define another function called <span class="sans_thesansmonocd_w5regular_">applyFunction()</span> with two parameters: <span class="sans_thesansmonocd_w5regular_">function</span>, which will hold a reference to a function, and <span class="sans_thesansmonocd_w5regular_">input</span>, a string. The <span class="sans_thesansmonocd_w5regular_">function</span> parameter’s type needs to match the parameter and return types of the function it will reference; <span class="sans_thesansmonocd_w5regular_">(String) -&gt; Unit</span> indicates that the function will take a string as a parameter and return nothing. In the body of <span class="sans_thesansmonocd_w5regular_">applyFunction()</span>, we call whatever function was passed in, using the <span class="sans_thesansmonocd_w5regular_">input</span> string as its argument.</p>
<p class="tx">In <span class="sans_thesansmonocd_w5regular_">main()</span>, we create a reference to <span class="sans_thesansmonocd_w5regular_">printMessage()</span> using <span class="sans_thesansmonocd_w5regular_">::</span> and pass it to <span class="sans_thesansmonocd_w5regular_">applyFunction()</span> along with the string <span class="sans_thesansmonocd_w5regular_">"Hello, Kotlin!"</span> as the second argument. This will effectively make <span class="sans_thesansmonocd_w5regular_">applyFunction()</span> call <span class="sans_thesansmonocd_w5regular_">printMessage()</span> with the given string and print it to the console. The output should be:</p>
<pre class="calibre10"><code class="calibre11">Hello, Kotlin!</code></pre>
<p class="tx">Of course, you can do more with the <span class="sans_thesansmonocd_w5regular_">::</span> operator than we’ve discussed here. I encourage you to consult the official Kotlin documentation to explore the operator’s other use cases.</p>
</section>
</section>
</section>
<section aria-labelledby="sec34" epub:type="division">
<h3 class="h" id="sec34"><span id="h1-15"/><span class="sans_futura_std_bold_b_">Scope Functions</span></h3>
<p class="tni">In Kotlin, <i class="calibre9">scope functions</i> are a set of built-in functions used to manage the scope of variables, access properties of objects, and execute a block of code <span aria-label="35" epub:type="pagebreak" id="pg_35" role="doc-pagebreak"/>in a specific context. The scope functions in Kotlin are <span class="sans_thesansmonocd_w5regular_">run</span>, <span class="sans_thesansmonocd_w5regular_">with</span>, <span class="sans_thesansmonocd_w5regular_">let</span>, <span class="sans_thesansmonocd_w5regular_">also</span>, and <span class="sans_thesansmonocd_w5regular_">apply</span>. They’re often used to simplify and improve the readability of code, especially when working with objects or managing the flow of operations. Here is a simple example of how to use the <span class="sans_thesansmonocd_w5regular_">run</span> function:</p>
<pre class="calibre10"><code class="calibre11">val result = run {
    val x = 10
    val y = 20
    x + y // The value of this final expression is returned.
}
println("Result: $result") // prints "Result: 30"</code></pre>
<p class="tx">We begin by declaring a variable called <span class="sans_thesansmonocd_w5regular_">result</span>. Its value is determined by the last expression within a code block executed using the <span class="sans_thesansmonocd_w5regular_">run</span> scope function. Inside this block, we define and assign values to two integers, and the final expression computes their sum. The resulting value from this final expression is returned by the code block and assigned to the <span class="sans_thesansmonocd_w5regular_">result</span> variable. Finally, we use <span class="sans_thesansmonocd_w5regular_">println()</span> to print the value of <span class="sans_thesansmonocd_w5regular_">result</span>, which will display <span class="sans_thesansmonocd_w5regular_">Result: 30</span>.</p>
</section>
<section aria-labelledby="sec35" epub:type="division">
<h3 class="h" id="sec35"><span id="h1-16"/><span class="sans_futura_std_bold_b_">Lambda Expressions</span></h3>
<p class="tni"><i class="calibre9">Lambda expressions</i>, often referred to simply as <i class="calibre9">lambdas</i>, are a way to define and pass around blocks of function-like code in a flexible and concise manner. They’re essentially anonymous functions, allowing you to create functions on the fly without giving them a name. Lambda expressions are a fundamental part of functional programming, a programming style or paradigm that uses functions as the main building blocks. They make it easier to work with <i class="calibre9">higher-order functions</i>, functions that can take functions as arguments, return functions as values, or both. Higher-order functions can help create reusable and modular code that can be customized with different functions.</p>
<p class="tx">Here’s an example of a simple lambda that takes in a name and generates a greeting:</p>
<pre class="calibre10"><code class="calibre11">val greet (String) -&gt; String = {name -&gt; "Hello, $name!"}</code></pre>
<p class="tni">The lambda itself is the part of the code enclosed in braces: <span class="sans_thesansmonocd_w5regular_">{name -&gt; "Hello, $name!"}</span>. It consists of input parameters (in this case, just one, <span class="sans_thesansmonocd_w5regular_">name</span>) and a body (<span class="sans_thesansmonocd_w5regular_">"Hello, $name!"</span>), separated by an arrow (<span class="sans_thesansmonocd_w5regular_">-&gt;</span>) symbol. Think of this arrow as passing the parameters along to the lambda body. The <span class="sans_thesansmonocd_w5regular_">return</span> keyword is implied in the lambda body; if the body consists of a single expression, that expression will automatically be returned.</p>
<p class="tx">In this example, we assign the lambda to the <span class="sans_thesansmonocd_w5regular_">greet</span> variable. The <span class="sans_thesansmonocd_w5regular_">(String) -&gt; String</span> before the assignment operator specifies the lambda’s parameter and return types, again using the <span class="sans_thesansmonocd_w5regular_">-&gt;</span> symbol to separate the two. We can also incorporate these type declarations into the lambda itself, in which case we’d write the entire expression as:</p>
<pre class="calibre10"><code class="calibre11">val greet = {name: String -&gt; "Hello, $name!"}</code></pre>
<p class="tni"><span aria-label="36" epub:type="pagebreak" id="pg_36" role="doc-pagebreak"/>Here we specify that the <span class="sans_thesansmonocd_w5regular_">name</span> parameter is of the <span class="sans_thesansmonocd_w5regular_">String</span> type from within the braces. With this syntax, the return type, like the <span class="sans_thesansmonocd_w5regular_">return</span> keyword itself, is implied.</p>
<p class="tx">Whichever syntax we use, we now have a function that returns a string greeting inside the <span class="sans_thesansmonocd_w5regular_">greet</span> variable. We can therefore call the lambda via this variable, just like we would call an ordinary function:</p>
<pre class="calibre10"><code class="calibre11">println(greet("Alice")) // output: Hello, Alice!
println(greet("Bob"))   // output: Hello, Bob!</code></pre>
<p class="tx">Lambdas are often used for quick manipulation of data, such as adding two numbers or calculating the square of a number:</p>
<pre class="calibre10"><code class="calibre11">val sum: (Int, Int) -&gt; Int = {a, b -&gt; a + b}
println(sum(3, 4)) // output: 7

val square: (Int) -&gt; Int = {it * it}
println(square(5)) // output: 25</code></pre>
<p class="tx">Lambda parameters can be explicitly typed or inferred. For simple lambdas, Kotlin can infer types automatically. Also, if a lambda has a single parameter, you can omit the parameter declaration and use the implicit <span class="sans_thesansmonocd_w5regular_">it</span> keyword directly in the lambda’s body as a stand-in for the parameter. This is what we’ve done for the <span class="sans_thesansmonocd_w5regular_">square</span> lambda: <span class="sans_thesansmonocd_w5regular_">{it * it}</span> indicates that the lambda will take a single unnamed parameter and multiply it by itself.</p>
<p class="tx">Lambdas can span multiple lines to carry out more complex tasks and can be nested like <span class="sans_thesansmonocd_w5regular_">for</span> loops. We’ll use multiline, nested lambdas in the next section in relation to copying the content of a file.</p>
<aside aria-label="box-5" class="box2">
<p class="boxtitle" id="box-5"><span class="sans_futura_std_bold_b_">EXERCISES</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Use the following exercises to practice creating lambda expressions:</span></p>
<div class="spc">
<p class="boxlistnumber"><span class="sans_futura_std_book_">1.  Write a lambda expression that takes two integers as parameters and returns the larger one. If the integers are equal, return either one. Assign the lambda expression to a variable called</span> <span class="sans_thesansmonocd_w5regular_">max</span><span class="sans_futura_std_book_">, and use it to find the maximum of some pairs of integers.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">2.  Write a lambda expression that takes a string as a parameter and returns a new string that’s the reverse of the original string (without using Kotlin’s built-in</span> <span class="sans_thesansmonocd_w5regular_">reversed()</span> <span class="sans_futura_std_book_">method). For example, if the input is</span> <span class="sans_thesansmonocd_w7bold_">Kotlin</span><span class="sans_futura_std_book_">, the output should be</span> <span class="sans_thesansmonocd_w5regular_">niltoK</span><span class="sans_futura_std_book_">. Hint: Inside the body of the lambda, define a variable called</span> <span class="sans_thesansmonocd_w5regular_">reversed</span> <span class="sans_futura_std_book_">as an empty string, then use a</span> <span class="sans_thesansmonocd_w5regular_">for</span> <span class="sans_futura_std_book_">loop to iterate over the characters of the input string in reverse order, appending them to</span> <span class="sans_thesansmonocd_w5regular_">reversed</span><span class="sans_futura_std_book_">. When done, use</span> <span class="sans_thesansmonocd_w5regular_">reversed</span> <span class="sans_futura_std_book_">as the last line inside the lambda block to return the reversed string.</span></p>
</div>
</aside>
</section>
<section aria-labelledby="sec36" epub:type="division">
<span aria-label="37" epub:type="pagebreak" id="pg_37" role="doc-pagebreak"/>
<h3 class="h" id="sec36"><span id="h1-17"/><span class="sans_futura_std_bold_b_">Basic Input and Output</span></h3>
<p class="tni">Most commercial software these days has a graphical user interface (GUI) so that you can easily interact with it. You can create a GUI for your Kotlin app using third-party tools such as JavaFX or Jetpack Compose, but we won’t cover that in this book. Instead, in this section we’ll focus on how to work with text-based input and output in Kotlin. This helps you quickly test and debug your code. Text-based output is also useful for tasks like scripting, keeping logs, and watching what’s happening on networks of computers and devices, which is what system administrators often do.</p>
<section aria-labelledby="sec37" epub:type="division">
<h4 class="h1" id="sec37"><span id="h2-15"/><span class="sans_futura_std_bold_condensed_oblique_">Console-Based Input and Output</span></h4>
<p class="tni">To get user input from the console in Kotlin, use the <span class="sans_thesansmonocd_w5regular_">readln()</span> function. It returns whatever text the user enters into the console or an empty string if the user simply presses the <small class="calibre12">ENTER</small> key. Here’s an example:</p>
<pre class="calibre10"><code class="calibre11">println("Enter some text:")
val userInput = readln()
println("You entered: $userInput")</code></pre>
<p class="tx">Here, the user input (a line of text) is read into the <span class="sans_thesansmonocd_w5regular_">userInput</span> variable and then displayed as output to the console using the familiar <span class="sans_thesansmonocd_w5regular_">println()</span> function. If the user just presses <small class="calibre12">ENTER</small>, then <span class="sans_thesansmonocd_w5regular_">readln()</span> will return an empty string, and the program will end normally after printing the following:</p>
<pre class="calibre10"><code class="calibre11">You entered:</code></pre>
<p class="tx">When reading input from the console in Kotlin, keep in mind that all input is initially treated as text, resulting in a <span class="sans_thesansmonocd_w5regular_">String</span> data type. If you require a different data type, you must perform type casting, assuming the types are compatible. It’s also helpful to inform users about the expected input type by using prompts such as <span class="sans_thesansmonocd_w5regular_">Enter your name</span> or <span class="sans_thesansmonocd_w5regular_">Enter an integer</span>.</p>
<p class="tx">Even with a clear prompt, though, you shouldn’t automatically assume that the input will be valid. The user may input incorrect characters that can’t be successfully type-cast into the desired format. To prevent the program from crashing due to potential errors, it’s essential to implement error-handling mechanisms when receiving input from users. This extra step ensures robustness and a smoother user experience. Here’s a complete example of a fail-safe method for reading an integer from the console:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    while (true) {
        print("Enter an integer: ")
        val num = readln()

        // Validate using a try...catch block.
        try {
            val intValue = num.toInt()
            println("You entered: $intValue")
<span aria-label="38" epub:type="pagebreak" id="pg_38" role="doc-pagebreak"/>            break // Stop the loop on success.
        } catch (e: NumberFormatException) {
            println("Invalid input. Try again.")
        }
    }
}</code></pre>
<p class="tx">We begin by creating a <span class="sans_thesansmonocd_w5regular_">while</span> loop that continues to run until a valid input is provided. Next, we read the user input as a string and assign that to a variable called <span class="sans_thesansmonocd_w5regular_">num</span>. We check the validity of the input inside a <span class="sans_thesansmonocd_w5regular_">try...catch</span> construct for graceful error handling. This construct consists of two code blocks: a <span class="sans_thesansmonocd_w5regular_">try</span> block containing the code you’d like to run and a <span class="sans_thesansmonocd_w5regular_">catch</span> block containing an alternative code path or fallback option in case an error occurs during the <span class="sans_thesansmonocd_w5regular_">try</span> block. The <span class="sans_thesansmonocd_w5regular_">catch</span> block prevents the entire program from crashing abruptly from an error. This mechanism helps with debugging during testing and improves the overall user experience in commercial applications.</p>
<p class="tx">In this case, the <span class="sans_thesansmonocd_w5regular_">try</span> block attempts to convert the user’s input, stored in the variable <span class="sans_thesansmonocd_w5regular_">num</span>, into an integer using <span class="sans_thesansmonocd_w5regular_">toInt()</span>. If this conversion is successful, a message containing the integer value is printed.</p>
<p class="tx">However, if the conversion fails and a <span class="sans_thesansmonocd_w5regular_">NumberFormatException</span> is raised, the <span class="sans_thesansmonocd_w5regular_">catch</span> block is activated, printing an error message before the next iteration of the <span class="sans_thesansmonocd_w5regular_">while</span> loop begins. Notice the <span class="sans_thesansmonocd_w5regular_">(e: NumberFormatException)</span> immediately after the <span class="sans_thesansmonocd_w5regular_">catch</span> keyword. This specifies the particular type of exception that the <span class="sans_thesansmonocd_w5regular_">catch</span> block is designed to handle.</p>
<aside aria-label="box-6" class="box">
<p class="boxtitle" id="box-6"><span class="sans_futura_std_bold_b_">A SNEAK PEEK AT OBJECT-ORIENTED PROGRAMMING</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">“Simple File Operations” on <a href="#pg_39" class="calibre2">page 39</a></span> <span class="sans_futura_std_book_">references terms and concepts that will be discussed in detail in <a href="chapter2.xhtml" class="calibre2">Chapter 2</a> in relation to classes and object-oriented programming. For now, you can think of</span> <span class="sans_futura_std_book_oblique_">classes</span><span class="sans_futura_std_book_">, such as the</span> <span class="sans_thesansmonocd_w5regular_">File</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">Scanner</span> <span class="sans_futura_std_book_">classes discussed in the section, as blocks of code that have associated</span> <span class="sans_futura_std_book_oblique_">properties</span> <span class="sans_futura_std_book_">(variables) and</span> <span class="sans_futura_std_book_oblique_">methods</span> <span class="sans_futura_std_book_">(functions). An</span> <span class="sans_futura_std_book_oblique_">object</span> <span class="sans_futura_std_book_">is a particular instance of a class, created using the blueprint that the class provides. Likewise, Kotlin’s built-in data types are essentially classes, and instances of those data types are objects of those classes. For example, a string such as</span> <span class="sans_thesansmonocd_w5regular_">"Hello, world!"</span> <span class="sans_futura_std_book_">is an instance of the</span> <span class="sans_thesansmonocd_w5regular_">String</span> <span class="sans_futura_std_book_">class. This means it automatically has properties such as</span> <span class="sans_thesansmonocd_w5regular_">length</span> <span class="sans_futura_std_book_">(to report the number of characters in the string) and methods such as</span> <span class="sans_thesansmonocd_w5regular_">plus()</span> <span class="sans_futura_std_book_">(for concatenation with another string).</span></p>
</aside>
</section>
<section aria-labelledby="sec38" epub:type="division">
<span aria-label="39" epub:type="pagebreak" id="pg_39" role="doc-pagebreak"/>
<h4 class="h1" id="sec38"><span id="h2-16"/><span class="sans_futura_std_bold_condensed_oblique_">Simple File Operations</span></h4>
<p class="tni">Kotlin provides simple and effective ways to read and write files, a feature that’s very helpful when you want to retrieve previously saved data or save the data from the current run of a program. For this functionality, Kotlin relies on the Java standard library. For example, here’s how to read data from a file using Java’s <span class="sans_thesansmonocd_w5regular_">File</span> and <span class="sans_thesansmonocd_w5regular_">Scanner</span> classes:</p>
<pre class="calibre10"><code class="calibre11">import java.io.File
import java.util.Scanner

fun main() {
    // Replace the path below with the path to your file.
    val inputFile = "inputfile.txt"

    try {
      <span aria-label="annotation1" class="code_codeannotation">❶</span> val file = File(inputFile)
      <span aria-label="annotation2" class="code_codeannotation">❷</span> val sc = Scanner(file)
        while (sc.hasNextLine()) {
            val line = sc.nextLine()
            println(line)
        }
    } catch (e: Exception) {
        println("An error occurred: ${e.message}")
    }
}</code></pre>
<p class="tx">The example shows how to read a text file line by line. After importing the <span class="sans_thesansmonocd_w5regular_">File</span> and <span class="sans_thesansmonocd_w5regular_">Scanner</span> classes, we assign a string containing the full pathname of the input file to the <span class="sans_thesansmonocd_w5regular_">inputFile</span> variable. We then use this variable to create the <span class="sans_thesansmonocd_w5regular_">File</span> object called <span class="sans_thesansmonocd_w5regular_">file</span> <span aria-label="annotation1" class="codeannotation">❶</span>, which in turn is used to create a <span class="sans_thesansmonocd_w5regular_">Scanner</span> object called <span class="sans_thesansmonocd_w5regular_">sc</span> <span aria-label="annotation2" class="codeannotation">❷</span> that gives us access to the file’s contents. Then, in a <span class="sans_thesansmonocd_w5regular_">while</span> loop, we read the content of the file one line at a time using the <span class="sans_thesansmonocd_w5regular_">Scanner</span> object’s <span class="sans_thesansmonocd_w5regular_">nextLine()</span> method and print the result to the console. The loop continues until we reach the end of the file, indicated when the <span class="sans_thesansmonocd_w5regular_">Scanner</span> object’s <span class="sans_thesansmonocd_w5regular_">hasNextLine()</span> method returns <span class="sans_thesansmonocd_w5regular_">false</span>. We place all this code in a <span class="sans_thesansmonocd_w5regular_">try</span> block and use a corresponding <span class="sans_thesansmonocd_w5regular_">catch</span> block to handle any errors that arise while trying to access the file—for example, if the filename or filepath is wrong. The <span class="sans_thesansmonocd_w5regular_">(e: Exception)</span> indicates the <span class="sans_thesansmonocd_w5regular_">catch</span> block can handle any kind of exception, unlike the earlier <span class="sans_thesansmonocd_w5regular_">catch</span> block that was designed specifically for exceptions of type <span class="sans_thesansmonocd_w5regular_">NumberFormatException</span>. In this case, the <span class="sans_thesansmonocd_w5regular_">catch</span> block prints the default error message associated with the exception, accessible as <span class="sans_thesansmonocd_w5regular_">e.message</span>.</p>
<p class="tx">My test file at location <i class="calibre9">inputfile.txt</i> contained a limerick, and the program reproduced it on the console line by line:</p>
<pre class="calibre10"><code class="calibre11">There once was a man named Bob
Who loved to eat corn on the cob
He ate so much corn
That he grew a horn
And now he is known as Corn-Bob</code></pre>
<p class="tx"><span aria-label="40" epub:type="pagebreak" id="pg_40" role="doc-pagebreak"/>To read from <i class="calibre9">and</i> write to a file, you can’t use the <span class="sans_thesansmonocd_w5regular_">Scanner</span> class, since it doesn’t support writing output. Instead, you can use the <span class="sans_thesansmonocd_w5regular_">appendText()</span> method of the <span class="sans_thesansmonocd_w5regular_">File</span> class. Here’s a simple example:</p>
<pre class="calibre10"><code class="calibre11">import java.io.File

fun main() {
    // Replace the file locations as needed.
  <span aria-label="annotation1" class="code_codeannotation">❶</span> val inputFile = File("inputfile.txt")
  <span aria-label="annotation2" class="code_codeannotation">❷</span> val outputFile = File("outputfile.txt")

    // Read all lines from the input file.
  <span aria-label="annotation3" class="code_codeannotation">❸</span> val lines = inputFile.readLines()

    // Write all lines to the output file.
  <span aria-label="annotation4" class="code_codeannotation">❹</span> for (line in lines) {
        outputFile.appendText("$line\n")
    }
    println("Copied input_file.txt to output_file.txt")
}</code></pre>
<p class="tx">This Kotlin code reads all the lines from an input file (<i class="calibre9">inputfile.txt</i>) and writes them to an output file (<i class="calibre9">outputfile.txt</i>). The input file is represented using one <span class="sans_thesansmonocd_w5regular_">File</span> object <span aria-label="annotation1" class="codeannotation">❶</span> and the output file with another <span aria-label="annotation2" class="codeannotation">❷</span>. We use the <span class="sans_thesansmonocd_w5regular_">File</span> class’s <span class="sans_thesansmonocd_w5regular_">readLines()</span> method to read all the lines from the input file and return them as a list of strings <span aria-label="annotation3" class="codeannotation">❸</span>. (A <i class="calibre9">list</i> in Kotlin is a collection of items; in this case it’s a collection of strings, one for each line of the file. We’ll discuss lists in detail in <span><a href="chapter2.xhtml" class="calibre2">Chapter 2</a></span>.) We store this list of strings in the <span class="sans_thesansmonocd_w5regular_">lines</span> variable. We then use a <span class="sans_thesansmonocd_w5regular_">for</span> loop to iterate over the <span class="sans_thesansmonocd_w5regular_">lines</span> list, with the looping variable <span class="sans_thesansmonocd_w5regular_">line</span> standing for one line at a time <span aria-label="annotation4" class="codeannotation">❹</span>. For each line, we use the <span class="sans_thesansmonocd_w5regular_">appendText()</span> method to add the line to the output file. We also append a newline character (<span class="sans_thesansmonocd_w5regular_">\n</span>) to the end of each line to ensure it’s written on its own line of the output file. We conclude the code by printing a message to the console, indicating that the input file has been copied to the output file.</p>
<p class="tx">Notice that we didn’t use the <span class="sans_thesansmonocd_w5regular_">try...catch</span> block in this example, as the goal was to quickly show how to write data to a file. In real-world applications, file operations may have to be wrapped in a <span class="sans_thesansmonocd_w5regular_">try...catch</span> block to handle potential exceptions or errors, depending on your specific requirements.</p>
<p class="tx">You can use many other techniques for reading from and writing to files in Java and Kotlin. See the official Kotlin documentation for information about other methods.</p>
<p class="headaexercise" id="pre-1"><span class="sans_dogma_ot_bold_b_15-n">Project 1: Build a Console-Based Calculator</span></p>
<p class="tni">Now that we’ve explored some of the basic features of Kotlin, let’s put that knowledge to work in a real project. We’ll develop an interactive, console-based calculator application. The application will take a pair of valid numbers as input, ask the reader to choose an arithmetic operation (addition, subtraction, multiplication, or division), and then display the result of that <span aria-label="41" epub:type="pagebreak" id="pg_41" role="doc-pagebreak"/>operation in the console. We’ll also program the application to show helpful error messages when required.</p>
<p class="tx">At the start of any coding project, it’s crucial to begin by creating a mental map of the application’s structure. This involves identifying the necessary variables and data structures, as well as pinpointing the essential functionalities that the program should include. Once these components are identified, we can move forward by generating a list of the key components that need to be implemented, followed by the actual coding phase.</p>
<p class="tx">For more complex projects, it can also be beneficial to create a flowchart visualizing the application logic or to develop detailed pseudocode offering step-by-step instructions for coding the entire project. However, given the relatively straightforward nature of the calculator project, we’ll start by listing its key components:</p>
<p class="listnumber">  1.  Input collection: We’ll gather user input for two numbers and ensure the inputs are valid.</p>
<p class="listnumber1">  2.  Operation selection: The user will choose addition, subtraction, multiplication, or division.</p>
<p class="listnumber1">  3.  Calculation: The selected operation will be applied to the input numbers.</p>
<p class="listnumber1">  4.  Result display: The calculated result will be presented to the user via the console.</p>
<p class="listnumber2">  5.  Error messages: Throughout steps 1 through 3, we’ll display helpful error messages for invalid inputs, such as nonnumerical characters for the number inputs or an unrecognized mathematical operation.</p>
<p class="tx">We’ll use these five key components to guide the development process as we start coding our first mini project.</p>
</section>
<section aria-labelledby="sec39" epub:type="division">
<h4 class="h1" id="sec39"><span id="h2-17"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">We’ll discuss the code from the top down, starting with the <span class="sans_thesansmonocd_w5regular_">main()</span> function, which coordinates the program’s actions through a series of helper functions. This approach allows us to align the code with the key components we outlined.</p>
<pre class="calibre10"><code class="calibre11">import kotlin.system.exitProcess

fun main() {
    println("***  Console Calculator  ***")

    // step 1: input collection
    println("\nEnter two numbers:\n")
    val number1 = readDoubleInput("Number 1: ")
    val number2 = readDoubleInput("Number 2: ")

    // step 2: operation selection
    showChoices()
    val operation = getArithmeticOperation()

<span aria-label="42" epub:type="pagebreak" id="pg_42" role="doc-pagebreak"/>    // step 3: calculation
    val result = performCalculation(number1, number2, operation)

    // step 4: result display
    println("\nResult:\n" +
            "$number1 $operation $number2 = $result")
}</code></pre>
<p class="tx">We begin by importing the <span class="sans_thesansmonocd_w5regular_">exitProcess()</span> function from Kotlin’s standard library. We’ll use this method to exit the program if the user provides invalid input or if the code comes across an invalid operation type (for example, division by zero).</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">main()</span> function itself is divided into four clear steps, each related to one of the key project functions. In the first step, we ask the user to provide two numbers, which we store in the <span class="sans_thesansmonocd_w5regular_">number1</span> and <span class="sans_thesansmonocd_w5regular_">number2</span> variables. To manage and verify the input, we use the <span class="sans_thesansmonocd_w5regular_">readDoubleInput()</span> function, declared here:</p>
<pre class="calibre10"><code class="calibre11">fun readDoubleInput(prompt: String): Double {
    print(prompt)
    val num = readln()

    // Check input validity.
    try {
        return num.toDouble()
    } catch (e: Exception) {
        println("Error reading input: ${e.message}")
        exitProcess(1) // Exit with error code 1.
    }
}</code></pre>
<p class="tx">This function takes a single argument, a string serving as a prompt for user input in the console. It returns a numeric value (of type <span class="sans_thesansmonocd_w5regular_">Double</span>) if the user provides a valid input. The function displays the prompt using <span class="sans_thesansmonocd_w5regular_">print()</span> rather than <span class="sans_thesansmonocd_w5regular_">println()</span> so that the user’s response will go on the same line. Then it reads the user’s input with <span class="sans_thesansmonocd_w5regular_">readln()</span> and processes the string input inside a <span class="sans_thesansmonocd_w5regular_">try...catch</span> block. When the string is successfully converted into a numeric value of type <span class="sans_thesansmonocd_w5regular_">Double</span>, its value is returned. Otherwise, we enter the catch part of the block, where an error message is printed, and the program exits with an error code of 1.</p>
<blockquote class="calibre17">
<p class="note"><span class="sans_dogma_ot_bold_b_15-n">NOTE</span></p>
</blockquote>
<p class="note-txt"><i class="calibre9">When using the</i> <span class="sans_thesansmonocd_w5regular_italic_">exitProcess()</span> <i class="calibre9">function, any integer can be used as an error code. However, it’s important to first decide on a scheme for error codes based on the different types of errors that the application might generate. This will allow you to quickly locate the source of the error. In more complex projects, creating and maintaining a log or wiki of error codes is recommended.</i></p>
<p class="tx">After the <span class="sans_thesansmonocd_w5regular_">main()</span> function receives two valid numeric values (<span class="sans_thesansmonocd_w5regular_">number1</span> and <span class="sans_thesansmonocd_w5regular_">number2</span>), we move on to step 2, choosing the mathematical operation. For that, we first call the <span class="sans_thesansmonocd_w5regular_">showChoices()</span> function, which offers a list of arithmetic operations to the user. This function is simply made up of a number of <span class="sans_thesansmonocd_w5regular_">println()</span> calls:</p>
<pre class="calibre10"><code class="calibre11"><span aria-label="43" epub:type="pagebreak" id="pg_43" role="doc-pagebreak"/>fun showChoices() {
    println("\nOperation Options:")
    println("1. Addition (+)")
    println("2. Subtraction (-)")
    println("3. Multiplication (*)")
    println("4. Division (/)")
}</code></pre>
<p class="tx">Next, we use the <span class="sans_thesansmonocd_w5regular_">getArithmeticOperation()</span> function to take in a valid operation from the user. The result is assigned to the string variable <span class="sans_thesansmonocd_w5regular_">operation</span> in <span class="sans_thesansmonocd_w5regular_">main()</span>. Here’s what the <span class="sans_thesansmonocd_w5regular_">getArithmeticOperation()</span> function looks like:</p>
<pre class="calibre10"><code class="calibre11">fun getArithmeticOperation(): String {
    print("\nEnter an arithmetic operation (+, -, *, /): ")
    val operation = readln()

    if(!"+-*/".contains(operation, true)){
        println("\nInvalid operation. Exiting.")
        exitProcess(2) // Exit with error code 2.
    }
    return operation
}</code></pre>
<p class="tx">Within this function, the user is prompted to select one of the four valid arithmetic operators. This choice is captured using the <span class="sans_thesansmonocd_w5regular_">readln()</span> method. Subsequently, we use an <span class="sans_thesansmonocd_w5regular_">if</span> statement to verify whether the user input is valid. Specifically, if the string <span class="sans_thesansmonocd_w5regular_">"+-*/"</span> does not include the user’s input, an error message is printed, indicating that an invalid operator has been provided. The program then terminates with an error code of 2.</p>
<p class="tx">Back in <span class="sans_thesansmonocd_w5regular_">main()</span>, we can now move to step 3 and call the <span class="sans_thesansmonocd_w5regular_">performCalculation()</span> function to carry out the selected arithmetic operation and return the result. Here’s that function’s declaration:</p>
<pre class="calibre10"><code class="calibre11">fun performCalculation(number1: Double, number2: Double,
                       operation: String): Double {
    return when (operation) {
        "+" -&gt; number1 + number2
        "-" -&gt; number1 - number2
        "*" -&gt; number1 * number2
        "/" -&gt; if (number2 != 0.0) number1 / number2
               else {
                   println("\nDivision by zero is not allowed. Exiting.")
                   exitProcess(3)
               }
      <span aria-label="annotation1" class="code_codeannotation">❶</span> else -&gt; {
            println("\nUnexpected error encountered. Exiting.")
            exitProcess(4)
        }
    }
}</code></pre>
<p class="tx"><span aria-label="44" epub:type="pagebreak" id="pg_44" role="doc-pagebreak"/>This function takes in the two input numbers and the string containing the desired operation as parameters and returns the result of the calculation as a number of type <span class="sans_thesansmonocd_w5regular_">Double</span>. It employs a <span class="sans_thesansmonocd_w5regular_">when</span> statement to execute the desired calculation based on the value of <span class="sans_thesansmonocd_w5regular_">operation</span>. By this stage, both the numbers and the operation type have been validated. However, one potential source of error remains: division by zero. We address this with an <span class="sans_thesansmonocd_w5regular_">if...else</span> block in the <span class="sans_thesansmonocd_w5regular_">"/"</span> case of the <span class="sans_thesansmonocd_w5regular_">when</span> statement, which prints an error message and exits the program if <span class="sans_thesansmonocd_w5regular_">number2</span> is <span class="sans_thesansmonocd_w5regular_">0.0</span>.</p>
<p class="tx">Notice that we also include an <span class="sans_thesansmonocd_w5regular_">else</span> clause for the overall <span class="sans_thesansmonocd_w5regular_">when</span> statement <span aria-label="annotation1" class="codeannotation">❶</span>, even though no further errors should remain at this point (hence the “Unexpected error encountered” message). Having this clause as a fallback is good practice in case unexpected issues or compiler bugs lead to unpredictable errors.</p>
<p class="tx">With the calculation performed, our <span class="sans_thesansmonocd_w5regular_">main()</span> function moves on to step 4 and displays the result using a string template. Looking back at <span class="sans_thesansmonocd_w5regular_">main()</span>, notice how our use of custom functions to encapsulate the various individual tasks of the program has kept the <span class="sans_thesansmonocd_w5regular_">main()</span> function itself tidy and easy to read. In this way, functions help us maintain well-organized applications.</p>
</section>
<section aria-labelledby="sec40" epub:type="division">
<h4 class="h1" id="sec40"><span id="h2-18"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">Here’s a sample run of the program to multiply two numbers, 37 and 9. The user input is shown in bold.</p>
<pre class="calibre10"><code class="calibre11">***  Console Calculator  ***

Enter two numbers:

Number 1: <b class="calibre6">37</b>
Number 2: <b class="calibre6">9</b>

Operation Options:
1. Addition (+)
2. Subtraction (-)
3. Multiplication (*)
4. Division (/)

Enter an arithmetic operation (+, -, *, /): <b class="calibre6">*</b>

Result:
37.0 * 9.0 = 333.0</code></pre>
<p class="tx">Notice that even though the inputs are integers, they get converted to the <span class="sans_thesansmonocd_w5regular_">Double</span> type before conducting the multiplication. That is, <span class="sans_thesansmonocd_w5regular_">37</span> becomes <span class="sans_thesansmonocd_w5regular_">37.0</span> and <span class="sans_thesansmonocd_w5regular_">9</span> becomes <span class="sans_thesansmonocd_w5regular_">9.0</span>, as shown at the end of the output under <span class="sans_thesansmonocd_w5regular_">Result</span>. Feel free to experiment with invalid numbers or operators and observe how the program behaves. We can learn a lot from our mistakes!</p>
<span aria-label="45" epub:type="pagebreak" id="pg_45" role="doc-pagebreak"/>
<aside aria-label="box-7" class="box2">
<p class="boxtitle" id="box-7"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">In <a href="chapter1.xhtml#pre-1" class="calibre2">Project 1</a>, you created a basic calculator. Now it’s time to level up your calculator’s capabilities. In this exercise, you’ll add more advanced mathematical operations and scientific functions, making your calculator a more versatile tool. Here are some tasks to enhance the program:</span></p>
<div class="spc">
<p class="boxlistnumber"><span class="sans_futura_std_book_">1.  Implement the modulo (%) operation, allowing users to find the remainder when one integer is divided by another.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">2.  Add the ability to raise an input number</span> <span class="sans_futura_std_book_oblique_">x</span> <span class="sans_futura_std_book_">to a given power</span> <span class="sans_futura_std_book_oblique_">n</span> <span class="sans_futura_std_book_">(that is,</span> <span class="sans_futura_std_book_oblique_">x</span><span class="sans_futura_std_book_oblique_sup_">n</span><span class="sans_futura_std_book_">) and display the result.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">3.  Allow the calculation of the square root of a positive number.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">4.  Incorporate the ability to calculate and display the sine (sin), cosine (cos), and tangent (tan) of a given angle</span> <span class="sans_futura_std_book_oblique_">x</span><span class="sans_futura_std_book_">. Users should provide the angle in degrees.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">5.  Take in a value</span> <span class="sans_futura_std_book_oblique_">x</span> <span class="sans_futura_std_book_">and calculate</span> <span class="sans_futura_std_book_oblique_">e</span><span class="sans_futura_std_book_oblique_sup_">x</span> <span class="sans_futura_std_book_">(the exponential function).</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">6.  Enable the natural logarithm (log</span><span class="sans_futura_std_book_oblique_sub_">e</span><span class="sans_futura_std_book_">) function, allowing users to find the natural logarithm of</span> <span class="sans_futura_std_book_oblique_">x</span><span class="sans_futura_std_book_">.</span></p>
</div>
<p class="boxlast"><span class="sans_futura_std_book_">Hint: Notice that some of these operations require two input numbers, while others require just one. You should therefore prompt the user for the operation they want to perform first, and then request the necessary numeric inputs. You’ll need mathematical functions from the</span> <span class="sans_thesansmonocd_w5regular_">kotlin.math</span> <span class="sans_futura_std_book_">module to implement many of these operations.</span></p>
</aside>
</section>
</section>
<section aria-labelledby="sec41" epub:type="division">
<h3 class="h" id="sec41"><span id="h1-18"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">In this chapter, we covered an array of fundamental elements of the Kotlin language. You learned how to use comments to enhance code clarity, variables to store and manage data, and operators to manipulate that data. You explored flow control structures like conditionals and loops to dictate your program’s behavior, and functions to encapsulate and reuse code effectively. With lambda expressions, you saw a way to write and use functions on the fly and got a glimpse of the functional programming style. You also practiced receiving input and providing output, for both console- and file-based interactions. To conclude the chapter, you gained hands-on practice bringing these elements together through a project implementing a console-based calculator.</p>
</section>
<section aria-labelledby="sec42" epub:type="division">
<h3 class="h" id="sec42"><span id="h1-19"/><span class="sans_futura_std_bold_b_">Resource</span></h3>
<p class="reference">Kotlin. “Kotlin Docs.” (The official Kotlin documentation.) Accessed June 15, 2024. <i class="calibre9"><a href="https://kotlinlang.org/docs/home.xhtml" class="calibre2">https://kotlinlang.org/docs/home.xhtml</a></i>.</p>
</section>
</section>
</div></body></html>