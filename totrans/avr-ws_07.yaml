- en: '[7](nsp-boxall502581-0008.xhtml#rch07)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Pulse-Width Modulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-ct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you need a digital output to simulate an analog signal, such as operating
    an LED at partial brightness, you can use *pulse-width modulation (PWM)* to adjust
    the amount of time between each high and low signal from a digital output pin.
    PWM can generate various effects, such as adjusting the brightness of an LED,
    controlling the speed of an electric motor, and creating sounds using tools that
    convert electricity into vibrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: • Learn how pulse-width modulation works and is generated by AVRs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Use PWM with ATtiny85 and ATmega328P-PU microcontrollers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Make varying tones of sound using piezo elements with PWM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Learn how to use PWM to create colorful effects using RGB LEDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pulse-Width Modulation and Duty Cycles](nsp-boxall502581-0008.xhtml#rah0901)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PWM allows us to control the perceived brightness of an LED, instead of simply
    switching it on and off as we’ve done in previous chapters. The LED’s brightness
    is determined by the *duty cycle* , or the length of time the PORT *x* pin is
    on (meaning the LED is lit) versus the length of time it is off (the LED is unlit).
    Duty cycle is expressed as the percentage of “on” time. The greater the duty cycle—that
    is, the longer the PORT *x* pin is on compared to off in each cycle—the greater
    the perceived brightness of the LED connected to the pin.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the higher the frequency of the PWM signal is—that is, the faster
    the signal is turned on and off—the smoother the visual effect is. If you’re controlling
    a motor, a higher PWM frequency will make the rotational speed a closer approximation
    of the actual speed required.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](nsp-boxall502581-0017.xhtml#f07001) shows four possible PWM duty
    cycles. The filled-in gray areas represent the amount of time that the LED is
    on; as you can see, this increases with the duty cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram of four PWM duty cycles: 100%, 60%, 40%, and 20%](images/nsp-boxall502581-f07001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: Various PWM duty cycles'
  prefs: []
  type: TYPE_NORMAL
- en: We can only use certain pins on our AVR microcontrollers for PWM. For the ATtiny85,
    we use PB0, PB1, and PB4; for the ATmega328P-PU, we use PB1 to PB3 and PD3, PD5,
    and PD6\. To create a PWM signal, we need to set the required registers depending
    on the microcontroller used. I’ll demonstrate this for both microcontrollers in
    this chapter. Let’s begin with the ATtiny85.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 31: Demonstrating PWM with the ATtiny85](nsp-boxall502581-0008.xhtml#rpro31)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll learn how to trigger the available PWM outputs offered
    by the ATtiny85 microcontroller. We trigger each output slightly differently,
    but the process is always simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0901)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATtiny85 microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Three LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Three 560 Ω resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 7-2](nsp-boxall502581-0017.xhtml#f07002)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 31](images/nsp-boxall502581-f07002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: Schematic for [Project 31](nsp-boxall502581-0017.xhtml#pro31)'
  prefs: []
  type: TYPE_NORMAL
- en: With your circuit assembled, connect the USBasp to your microcontroller in the
    usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0902)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 31* subfolder of this book’s
    *Chapter 7* folder, and enter the command `make flash` as usual. Once the project’s
    code has been uploaded to the microcontroller the LEDs connected to PB4, PB1,
    and PB0 should all start to fade on and off at the same time, repeatedly displaying
    rising then falling levels of brightness.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how this works. Open the *main.c* file for [Project 31](nsp-boxall502581-0017.xhtml#pro31)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code defines the function `initPWM()` . The function operates every pin
    at the same time, but we’ll go over how to initialize and operate each pin one
    by one.
  prefs: []
  type: TYPE_NORMAL
- en: We first set the required pins, PORTB0, PORTB1, and PORTB4, to outputs ❶. Next,
    in turn we address the required three registers to enable PWM on PORTB0\. To set
    the timer to fast PWM mode, we allocate the timer signal to pin PORTB0—note that
    we don’t use a prescaler, so the PWM can operate at its maximum frequency ❷. We
    only need to address one register to allow PWM over PORTB1 ❸, but using PWM on
    PORTB4 requires a different timer, so we have to address different registers ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to assign values to the PWM pins to set their duty cycle. The
    microcontrollers require a value between 1 and 254, which maps out to a duty cycle
    of just over 0 to just under 100\. (If you use 0, this is a 0 percent duty cycle—that
    is, the pin will be off. If you use 255, this is a 100 percent duty cycle, so
    the pin will be on continuously.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Three registers store the duty cycle value for our three PWM pins:'
  prefs: []
  type: TYPE_NORMAL
- en: • OCR0A for PORTB0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • OCR0B for PORTB1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • OCR1B for PORTB4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we add a simple loop that causes the duty value to rise incrementally,
    increasing the brightness of the LEDs over time ❺. This process is then reversed
    by using another loop that decreases the brightness of the LEDs over time ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment with adjusting the value in the `_delay_ms()` functions to alter
    the speed of the change in brightness. You may notice that there’s little to no
    difference in brightness between higher duty cycle values. That’s because during
    high-frequency PWM operations (anything faster than 50 cycles per second), the
    LED blinks too rapidly for the average human eye to perceive when it’s off.
  prefs: []
  type: TYPE_NORMAL
- en: '[Individual PWM Pin Control for the ATtiny85](nsp-boxall502581-0008.xhtml#rah0902)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve assembled and tested all the PWM pins using the ATtiny85, it’s
    time to learn how to use each PWM pin so you can apply them in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate all the PWM pins at once, simply use the `initPWM()` function as
    used in [Project 31](nsp-boxall502581-0017.xhtml#pro31) . (You’ll learn how to
    deactivate them all later on.) To activate and deactivate each pin individually,
    follow the instructions in this list:'
  prefs: []
  type: TYPE_NORMAL
- en: Activating PWM on ATtiny85 pin PORTB0
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate PWM on PORTB0, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can then set the duty cycle by allocating a value between 1 and 254 inclusive
    to the OCR0A register.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Activating PWM on ATtiny85 pin PORTB1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To activate PWM on PORTB1, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can then set the duty cycle by allocating a value between 1 and 254 to the
    OCR0B register.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Activating PWM on ATtiny85 pin PORTB4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To activate PWM on PORTB4, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can then set the duty cycle by allocating a value between 1 and 254 to the
    OCR1B register.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Deactivating ATtiny85 PWM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If your project needs to use a pin for both PWM and output on or off, then
    you must deactivate PWM mode before using `PORT` `x` `|=` commands. You’ll need
    to define `initPWM()` and `disablePWM()` functions to switch PWM on and off when
    required. Use the following code to disable PWM for all the pins (PORTB0, PORTB1,
    and PORTB4):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In general, it’s a good idea to keep these lines of code required to set up
    PWM in their own function, as in [Project 31](nsp-boxall502581-0017.xhtml#pro31)
    . Now that we’ve reviewed the ins and outs of PWM on the ATtiny85, let’s have
    some fun making noise with a piezo element.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 32: Experimenting with Piezo and PWM](nsp-boxall502581-0008.xhtml#rpro32)'
  prefs: []
  type: TYPE_NORMAL
- en: A *piezo element* is a device that converts an electrical charge into a different
    form of energy. It can convert electrical energy into physical movement in the
    form of vibration, which generates sound waves that you can hear. By applying
    an electrical current and varying it using PWM, you can change the piezo’s tone.
    For this project you can use a small, prewired piezo like the one shown in [Figure
    7-3](nsp-boxall502581-0017.xhtml#f07003) .
  prefs: []
  type: TYPE_NORMAL
- en: '![A prewired piezo element used for making sounds or sensing vibrations](images/nsp-boxall502581-f07003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: A prewired 27 mm piezo element'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-4](nsp-boxall502581-0017.xhtml#f07004) shows the schematic symbol
    for our piezo element.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbol for a piezo element](images/nsp-boxall502581-f07004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: Schematic symbol for piezo element'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll learn to change the pitch of sound from a piezo element
    by adjusting a trimpot. We’ll use an ADC to read the trimpot value, then use that
    value to determine the duty cycle for PWM control of the piezo element.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0903)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATtiny85 microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Prewired piezo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 10 kΩ breadboard-compatible linear trimpot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 7-5](nsp-boxall502581-0017.xhtml#f07005)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 32](images/nsp-boxall502581-f07005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-5: Schematic for [Project 32](nsp-boxall502581-0017.xhtml#pro32)'
  prefs: []
  type: TYPE_NORMAL
- en: With your circuit assembled, connect the USBasp to your microcontroller via
    the solderless breadboard in the same way you have for previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0904)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 32* subfolder of this book’s
    *Chapter 7* folder, and enter the command `make flash` . Once the code has been
    uploaded to the microcontroller, slowly turn the trimpot in different directions,
    altering the piezo’s tone.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, open the *main.c* file for [Project 32](nsp-boxall502581-0017.xhtml#pro32)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code recalls that from [Project 31](nsp-boxall502581-0017.xhtml#pro31)
    and the other PWM examples in this chapter. It accomplishes its goal of setting
    the duty cycle, as the code takes the 8-bit value of the ADC register and places
    it in the PWM register OCR0A.
  prefs: []
  type: TYPE_NORMAL
- en: The code initializes the ADC and uses pin PORTB4 for the input ❶. It then initializes
    the PWM output on PB0 ❷, as in [Project 31](nsp-boxall502581-0017.xhtml#pro31)
    , starts the ADC ❸, and initializes the PWM ❹. Next, it reads the analog input
    ❺ and then finally assigns the ADC value (which falls between 0 and 255) to the
    PWM duty cycle register, thereby driving the piezo ❻.
  prefs: []
  type: TYPE_NORMAL
- en: '[Individual PWM Pin Control for the ATmega328P-PU](nsp-boxall502581-0008.xhtml#rah0903)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it’s time to move on to the PWM functions available for the ATmega328P-PU.
    [Table 7-1](nsp-boxall502581-0017.xhtml#tab0701) lists the six ATmega328P-PU pins
    that can be used with PWM.
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 7-1 : ATmega328P-PU PWM Pins |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Port register bit | Physical pin | Duty cycle register |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| PORTB1 | 15 | OCR1A |'
  prefs: []
  type: TYPE_TB
- en: '| PORTB2 | 16 | OCR1B |'
  prefs: []
  type: TYPE_TB
- en: '| PORTB3 | 17 | OCR2A |'
  prefs: []
  type: TYPE_TB
- en: '| PORTD3 | 5 | OCR2B |'
  prefs: []
  type: TYPE_TB
- en: '| PORTD5 | 11 | OCR0B |'
  prefs: []
  type: TYPE_TB
- en: '| PORTD6 | 12 | OCR0A |'
  prefs: []
  type: TYPE_TB
- en: Let’s go over how to activate (and deactivate) these pins for use with PWM.
  prefs: []
  type: TYPE_NORMAL
- en: Activating PWM on ATmega328P-PU pins PORTD5/6
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate PWM on PORTD5/6, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then connect the PWM output to pins PORTD5/6 with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the duty cycle by allocating a value between 1 and 254 to the duty cycle
    registers. If you want to control the pins directly, to use them as regular inputs
    or outputs, you will need to disconnect them from the PWM output. You can do this
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Activating PWM on ATmega328P-PU pins PORTB1/2
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate PWM on PORTB1/2, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then connect the PWM output to pins PORTB1/2 with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To disconnect the pins from PWM, use the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Activating PWM on ATmega328P-PU pins PORTB3 and PORTD3
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate PWM on PORTB3 and PORTD3, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then connect the PWM output to pins PORTB3 and PORTD3 like so:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To disconnect the pins from PWM, use the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that you can connect and disconnect pins from PWM when required only
    if you’ve run the activation code first.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already seen a few ways to use PWM in this chapter, and next I’ll give
    you one more example: generating colors using RGB LEDs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[The RGB LED](nsp-boxall502581-0008.xhtml#rah0904)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An RGB LED is simply three LED elements—one red, one green, one blue—in a single
    enclosure, as shown in [Figure 7-6](nsp-boxall502581-0017.xhtml#f07006) . These
    LEDs are great for saving space, and you can also use them to create your own
    colors by changing the brightness of the individual elements. RGB LEDs are available in
    many sizes; one common option is 10 mm in diameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![A red, green, and blue light-emitting diode](images/nsp-boxall502581-f07006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-6: Typical RGB LED'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, RGB LEDs have four legs. As with the single-color LEDs discussed
    in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03) , there two types of these LEDs
    available: *common anode* and *common cathode* . In the common-anode configuration,
    all three LED anodes are connected, while the cathodes are separate. The common-cathode
    configuration has three separate anodes, with all three cathodes connected. [Figure
    7-7](nsp-boxall502581-0017.xhtml#f07007) shows the schematics for both.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic symbols for the two types of RGB LEDs](images/nsp-boxall502581-f07007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-7: Schematic symbols for RGB LEDs: common anode (left) and common
    cathode (right)'
  prefs: []
  type: TYPE_NORMAL
- en: The pinouts for each LED unfortunately may vary, so check with your supplier.
    However, if you cannot find this information, the longest pin is usually the common
    anode or cathode pin. You can order clear (where the body of the LED is transparent)
    or diffused (with a clouded LED body) RGB LEDs. I recommend the latter, as diffused
    LEDs work better at blending their three primary color elements to make color
    combinations.
  prefs: []
  type: TYPE_NORMAL
- en: For the projects in this book, starting with the next one, we’ll use common-cathode
    RGB LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 33: Experimenting with RGB LEDs and PWM](nsp-boxall502581-0008.xhtml#rpro33)'
  prefs: []
  type: TYPE_NORMAL
- en: This project allows you to generate various colors by mixing two of the three
    primary colors in an RGB LED with varying brightness caused by PWM. The diagram
    in [Figure 7-8](nsp-boxall502581-0017.xhtml#f07008) shows which color combinations
    will result in a given hue.
  prefs: []
  type: TYPE_NORMAL
- en: '![A chart showing the colors that result when primary colors are mixed](images/nsp-boxall502581-f07008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-8: Results of mixing red, green, and blue in various combinations'
  prefs: []
  type: TYPE_NORMAL
- en: For example, mixing red and green light will create a yellow glow. By increasing
    the brightness of one color while decreasing the brightness of the other color,
    you can run through multiple shades of yellow. This project mixes only two colors,
    but you can mix three at once to create a white light if you wish in your own
    projects. You’ll use the ATmega328P-PU microcontroller for this project; it has
    many more pins than the ATtiny85, so you can use it to work with the RGB LED and
    still have pins left over for other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0905)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One diffused common-cathode RGB LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Three 560 Ω resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 7-9](nsp-boxall502581-0017.xhtml#f07009)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 33](images/nsp-boxall502581-f07009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-9: Schematic for [Project 33](nsp-boxall502581-0017.xhtml#pro33)'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 33* subfolder of this book’s
    *Chapter 7* folder, and enter the command `make flash` . Once you’ve uploaded
    the code to the microcontroller, your RGB LED should begin to glow with constantly
    changing colors. (If your LED has a clear body, you can easily diffuse the output
    for a better effect by placing some white paper over the LED.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, open the *main.c* file for [Project 33](nsp-boxall502581-0017.xhtml#pro33)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We begin with our usual `initPWM()` function, which sets up the PORTB1, PORTB2,
    and PORTB3 pins as PWM outputs ❷. This is followed by three simple functions,
    one for each LED ❸❹❺, that pass on the required duty cycle, to make controlling
    each of the primary colors in the LED easy when required.
  prefs: []
  type: TYPE_NORMAL
- en: The main code sets up PORTB1, PORTB2, and PORTB3 as output pins, then initializes
    the PWM outputs ❻. Finally, to mix the colors we use the three functions we defined
    to mix two of the LED colors by starting one color at a high level of brightness
    with the other color at a low level, then gradually decreasing and increasing
    the levels of the two colors, respectively ❼❽❾. You can adjust the speed of the
    color transition by changing the value of `wait` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope you found making sound effects with the piezo element and light effects
    with the RGB LED enjoyable. You’re just getting started: there are many more uses
    for PWM, including controlling motors for robotics and electric fans, as well
    as learning how to use MOSFETs to controller larger currents. We’ll explore all
    of these in the [next chapter](nsp-boxall502581-0018.xhtml#ch08) .'
  prefs: []
  type: TYPE_NORMAL
