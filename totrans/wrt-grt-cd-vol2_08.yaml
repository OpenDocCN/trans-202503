- en: '**8**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ARRAY DATA TYPES**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'High-level language abstractions hide how the machine deals with *composite
    data types* (a complex data type composed of smaller data objects). Although these
    abstractions are often convenient, if you don’t understand the details behind
    them you might inadvertently use a construct that generates unnecessary code or
    runs slower than need be. In this chapter, we’ll take a look at one of the most
    important composite data types: the array. We’ll consider the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to declare arrays in various languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How arrays are represented in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing elements of arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring, representing, and accessing multidimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Row-major and column-major multidimensional array access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic versus static arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How using arrays can impact the performance and size of your applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays are very common in modern applications, so you should have a solid understanding
    of how programs implement and use them in memory in order to write great code.
    This chapter will give you the foundation you need to use arrays more efficiently
    in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1 Arrays**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays are one of the most common composite (or *aggregate*) data types, yet
    few programmers fully grasp how they operate. Once they understand how arrays
    work at the machine level, programmers frequently view them from a completely
    different perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Abstractly, an array is an aggregate data type whose members (elements) are
    all of the same type. To select a member from the array, you specify the member’s
    array index with an integer (or with some value whose underlying representation
    is an integer, such as character, enumerated, and Boolean types). In this chapter,
    we’ll assume that all of the integer indices of an array are numerically contiguous.
    That is, if both `x` and `y` are valid indices of the array, and if `x` < `y`,
    then all `i` such that `x` < `i` < `y` are also valid indices. We’ll also typically
    assume that array elements occupy contiguous locations in memory, although this
    is not required by the general definition of an array. An array with five elements
    appears in memory as shown in [Figure 8-1](ch08.xhtml#ch8fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: Array layout in memory*'
  prefs: []
  type: TYPE_NORMAL
- en: The *base address* of an array is the address of its first element that occupies
    the lowest memory location. The second array element directly follows the first
    in memory, the third element follows the second, and so on. Note that the indices
    do not have to start at `0`; they can start with any number as long as they are
    contiguous. However, discussing array access is easier if the first index is `0`,
    so arrays in this chapter begin at index `0` unless otherwise indicated.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you apply the indexing operator to an array, the result is the unique
    array element specified by that index. For example, `A[i]` chooses the `i`th element
    from array `A`.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.1 Array Declarations**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Array declarations are very similar across many high-level languages (HLLs).
    This section presents examples in several languages.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.1.1 Declaring Arrays in C, C++, and Java**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'C, C++, and Java all let you declare an array by specifying the total number
    of elements. The syntax for an array declaration in these languages is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some sample C/C++ array declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you declare these arrays as automatic variables, C/C++ initializes them
    with whatever bit patterns happen to exist in memory. If, on the other hand, you
    declare these arrays as static objects, C/C++ initializes each array element with
    `0`. If you want to initialize an array yourself, you can use the following C/C++
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The C/C++ compiler stores these initial array values in the object code file,
    and the operating system will load these values into the memory locations associated
    with `intArray` when it loads the program into memory. To see how this works,
    consider the following short C/C++ program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Microsoft’s Visual C++ compiler emits the following 80x86 assembly code for
    the two array declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Each `DD` (“define double word”) statement reserves 4 bytes of storage, and
    the operand specifies their initial value when the OS loads the program into memory.
    The `intArray` declaration appears in the `_DATA` segment, which in the Microsoft
    memory model can contain initialized data. The `array2` variable, on the other
    hand, is declared inside the `_BSS` segment, where MSVC++ places uninitialized
    variables (the `?` character in the operand field tells the assembler that the
    data is uninitialized; the `8 dup (?)` operand tells the assembler to duplicate
    the declaration eight times). When the OS loads the `_BSS` segment into memory,
    it simply zeros out all the memory associated with that segment. In both the initialized
    and uninitialized cases, the compiler allocates all eight elements of these arrays
    in sequential memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.1.2 Declaring Arrays in HLA**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'HLA’s array declaration syntax takes the following form, which is semantically
    equivalent to the C/C++ declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of HLA array declarations that allocate storage for
    uninitialized arrays (the second example assumes you have defined the `integer`
    data type in a `type` section of the HLA program):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also initialize the array elements using declarations like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Both of these definitions create arrays with eight elements. The first definition
    initializes each 4-byte `real32` array element with one of the values in the range
    `0.0..7.0`. The second declaration initializes each `integer` array element with
    one of the values in the range `8..15`.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.1.3 Declaring Arrays in Pascal/Delphi**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Pascal/Delphi uses the following syntax to declare an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the previous examples, array_name is the identifier and data_type is
    the type of each element in this array. In Pascal/Delphi (unlike C/C++, Java,
    and HLA) you specify the upper and lower bounds of the array rather than the array’s
    size. The following are typical array declarations in Pascal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Although these Pascal examples start their indices at `0`, Pascal does not
    require it. The following is a perfectly valid array declaration in Pascal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The program that declares this array would use indices `1998..2028` when accessing
    elements of this array, not `0..30`.
  prefs: []
  type: TYPE_NORMAL
- en: Many Pascal compilers provide a very useful feature to help you locate defects
    in your programs. Whenever you access an element of an array, these compilers
    automatically insert code that will verify that the array index is within the
    bounds specified by the declaration. This extra code will stop the program if
    the index is out of range. For example, if an index into `ProfitsByYear` is outside
    the range `1998..2028`, the program will abort with an error.^([1](footnotes.xhtml#ch8fn1))
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.1.4 Declaring Arrays in Swift**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Array declarations in Swift are a bit different from those of other C-based
    languages. Swift array declarations take one of the following two (equivalent)
    forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike in other languages, arrays in Swift are purely dynamic. You don’t normally
    specify the number of elements when you first create the array; instead, you add
    elements to the array as needed using functions like `append()`. If you want to
    predeclare an array with some number of elements, you can use a special array
    constructor form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, initial_value is a value of type element_type and elements
    is the number of elements to create in the array. For example, the following Swift
    code creates two arrays of 100 `Int` values, each initialized to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can still extend the size of this array (for example, by using
    the `append()` function); because Swift arrays are dynamic, their size can grow
    or shrink at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to create a Swift array with initial values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Swift, like Pascal, checks the validity of array indices at runtime. Swift will
    raise an exception if you attempt to access an array element that doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.1.5 Declaring Arrays with Noninteger Index Values**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Generally, array indices are integer values, although some languages allow
    other *ordinal types* (data types that use an underlying integer representation).
    For example, Pascal allows `char` and `boolean` array indices. In Pascal, it’s
    perfectly reasonable and useful to declare an array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You access elements of `alphaCnt` using a character expression as the array
    index. For example, consider the following Pascal code, which initializes each
    element of `alphaCnt` to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Assembly language and C/C++ treat most ordinal values as special instances of
    integer values, so they are legal array indices. Most implementations of BASIC
    allow a floating-point number as an array index, although BASIC always truncates
    the value to an integer before using it as an index.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*BASIC allows you to use floating-point values as array indices because the
    original language did not provide support for integer expressions; it provided
    only real and string values.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.2 Array Representation in Memory**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Abstractly, an array is a collection of variables that you access using an index.
    Semantically, you can define an array any way you please, as long as it maps distinct
    indices to distinct objects in memory and always maps the same index to the same
    object. In practice, however, most languages utilize a few common algorithms that
    provide efficient access to the array data.
  prefs: []
  type: TYPE_NORMAL
- en: The most common implementation of arrays is to store elements in consecutive
    memory locations. As noted earlier, most programming languages store the first
    element of an array at a low memory address and then store the following elements
    in successively higher memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following C program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the corresponding PowerPC assembly code that GCC emits for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of bytes an array consumes is the number of elements multiplied
    by the number of bytes per element. In the previous example, each array element
    is a single byte, so the array consumes the same number of bytes as it has elements.
    However, for arrays with larger elements, the entire array size (in bytes) is
    correspondingly larger. Consider the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the corresponding GCC assembly language output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Many languages also add a few bytes of padding at the end of an array so that
    the array’s total length will be a multiple of a convenient value like 2 or 4
    (making it easy to compute indices into the array using shifts or to add extra
    padding bytes for the next object in memory; see [Chapter 3](ch03.xhtml#ch03)
    of *WGC1* for details). However, a program must not count on those extra padding
    bytes, because they may or may not be present. Some compilers always put them
    in, others never do, and still others put them in depending on the type of object
    that immediately follows the array in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Many optimizing compilers try to start an array at a memory address that is
    a multiple of a common size like 2, 4, or 8 bytes. Effectively, this adds padding
    bytes before the beginning of the array or, if you prefer to think of it this
    way, after the previous object in memory (see [Figure 8-2](ch08.xhtml#ch8fig2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-2: Adding padding bytes before an array*'
  prefs: []
  type: TYPE_NORMAL
- en: On machines that do not support byte-addressable memory, compilers that attempt
    to place the first element of an array on an easily accessed boundary will allocate
    storage for an array on whatever boundary the machine supports. In the previous
    example, notice that the `.align 2` directive precedes the `_array` declaration.
    In Gas syntax, the `.align` directive tells the assembler to adjust the memory
    address of the next object declared in the source file so that it starts at an
    address that is a multiple of some power (specified by `.align`’s operand) of
    2\. In this example, `.align 2` tells the assembler to align the first element
    of `_array` on an address boundary that is a multiple of 4 (that is, 2²).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the size of each array element is less than the minimum-sized memory object
    the CPU supports, the compiler implementer has two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocate the smallest accessible memory object for each element of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pack multiple array elements into a single memory cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Option 1 has the advantage of being fast, but it wastes memory because each
    array element carries some extra storage that it doesn’t need. The following C
    example allocates storage for an array whose element size is 5 bytes, where each
    element is a structure object consisting of a 4-byte `long` object and a 1-byte
    `char` object (we’ll look at C structures in [Chapter 11](ch11.xhtml#ch11)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When GCC compiles this code to run on a PowerPC processor, which requires double-word
    alignment for `long` objects, the compiler automatically inserts 3 bytes of padding
    between each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Option 2 is compact but slower, as it requires extra instructions to pack and
    unpack data when accessing array elements. Compilers on such machines often provide
    an option that lets you specify whether you want the data packed or unpacked so
    you can choose between space and speed.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that if you’re working on a byte-addressable machine (like the
    80x86), then you probably don’t have to worry about this issue. However, if you’re
    using an HLL and your code might run on a different machine at some point in the
    future, you should choose an array organization that is efficient on all machines
    (that is, an organization that pads each element of the array with extra bytes).
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.3 Swift Array Implementation**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although the examples so far have included arrays in Swift, Swift arrays have
    a different implementation. First of all, Swift arrays are an opaque type^([2](footnotes.xhtml#ch8fn2))
    based on `struct` objects, rather than just a collection of elements in memory.
    Swift doesn’t guarantee that array elements appear in continuous memory locations;
    thus, you can’t assume that object elements and certain other element types in
    a Swift array are stored contiguously. As a workaround, Swift provides the `ContiguousArray`
    type specification. To guarantee that array elements appear in contiguous memory
    locations, you can specify `ContiguousArray` rather than `Array` when declaring
    array variables in Swift, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The internal implementation of a Swift array is a structure containing a count
    (current number of array elements), a capacity (current number of allocated array
    elements), and a pointer to the storage holding the array elements. Because Swift
    arrays are an opaque type, this implementation could change at any time; however,
    somewhere in the structure there will be a pointer to the actual array data in
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift allocates storage for arrays dynamically, which means you’ll never see
    the array storage embedded in the object code file that the Swift compiler produces
    (unless the Swift language definition changes to support statically allocated
    arrays). You can increase the size of an array by appending elements to it, but
    if you attempt to extend it beyond its current capacity, the Swift runtime system
    may need to dynamically relocate an array object. For performance reasons, Swift
    uses an exponential allocation scheme: whenever you append a value to an array
    that would exceed its capacity, the Swift runtime system will allocate twice (or
    some other constant) as much storage as the current capacity, copy the data from
    the current array buffer to the new buffer, and then point the array’s internal
    pointer at the new block. One important aspect of this process is that you can
    never assume that the pointer to the array’s data remains static or that the array’s
    data remains in the same buffer location in memory—at different points in time,
    the array could appear in different locations in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.4 Accessing Elements of an Array**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you allocate all the storage for an array in contiguous memory locations,
    and the first index of the array is `0`, then accessing an element of a one-dimensional
    array is simple. You can compute the address of any given element of an array
    using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Element_Size is the number of bytes that each array element occupies. Therefore,
    if the array contains elements of type `byte`, the Element_Size field is `1` and
    the math is very easy. If each element of the array is a `word` (or other 2-byte
    type), then `Element_Size` is `2`, and so on. Consider the following Pascal array
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To access an element of the `SixteenInts` array on a byte-addressable machine,
    assuming 4-byte integers, you’d use this calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In HLA assembly language (where you’d have to do this calculation manually
    rather than having the compiler do it for you), you could use code like this to
    access array element `SixteenInts[index]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To see this in action, consider the following Pascal/Delphi program and the
    resulting 32-bit 80x86 code (which I obtained by disassembling the *.exe* output
    from the Delphi compiler and pasting the result back into the original Pascal
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the HLA example, the Delphi compiler uses the 80x86 scaled-index addressing
    mode to multiply the index into the array by the element size (4 bytes). The 80x86
    provides four different scaling values for the scaled-index addressing mode: 1,
    2, 4, or 8 bytes. If the array’s element size is not one of these four values,
    the machine code must explicitly multiply the index by the array element’s size.
    The following Delphi/Pascal code (and corresponding 80x86 code from the disassembly)
    demonstrates this process using a record that has 9 bytes of active data (Delphi
    rounds this up to the next multiple of 4 bytes, so it actually allocates 12 bytes
    for each element of the array of records):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Microsoft’s C/C++ compilers emit comparable code (also allocating 12 bytes for
    each element of the array of records).
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.5 Padding vs. Packing**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These Pascal examples reiterate an important point: compilers generally pad
    each array element to a multiple of 4 bytes, or whatever size is most convenient
    for the machine’s architecture, to improve access to array elements (and record
    fields) by ensuring that they are always aligned on a reasonable memory boundary.
    Some compilers give you the option of eliminating the padding at the end of each
    array element, so that successive array elements immediately follow the previous
    element in memory. In Pascal/Delphi, for example, you can achieve this by using
    the `packed` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `packed` reserved word is just a hint to a Pascal compiler. A generic Pascal
    compiler can choose to ignore it; the Pascal standard does not make any explicit
    claims about its impact on a compiler’s code generation. Delphi uses the `packed`
    keyword to tell the compiler to pack array (and record) elements on a byte boundary
    rather than a 4-byte boundary. Other Pascal compilers actually use this keyword
    to align objects on bit boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*See your compiler’s documentation for more information about the packed keyword.*'
  prefs: []
  type: TYPE_NORMAL
- en: Few other languages provide a way, within the generic language definition, to
    pack data into a given boundary. In the C/C++ languages, for example, many compilers
    provide pragmas or command-line switches to control array element padding, but
    these facilities are almost always specific to a particular compiler.
  prefs: []
  type: TYPE_NORMAL
- en: In general, choosing between packed and padded array elements (when you have
    a choice) is usually a tradeoff between speed and space. Packing lets you save
    a small amount of space for each array element at the cost of slower access to
    it (for example, when accessing a `dword` object at an odd address in memory).
    Furthermore, computing the index into an array whose element size is not a convenient
    multiple of 2 (or, better yet, a power of 2) can require more instructions, which
    also slows down programs that access elements of such arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, some machine architectures don’t allow misaligned data access, so
    if you’re writing portable code that must compile and run on different CPUs, you
    shouldn’t count on the fact that array elements can be tightly packed into memory.
    Some compilers may not give you this option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before closing this discussion, it’s worthwhile to emphasize that the best
    array element sizes are those that are some power of 2\. Generally, it takes only
    a single instruction to multiply any array index by a power of 2 (that single
    instruction is a shift-left instruction). Consider the following C program and
    the assembly output produced by Borland’s C++ compiler, which uses arrays that
    have 32-byte elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the Borland C++ compiler emits a `shl` instruction to multiply
    the index by 32.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.6 Multidimensional Arrays**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *multidimensional* array is one that lets you select an element of the array
    using two or more independent index values. A classic example is a two-dimensional
    data structure (matrix) that tracks product sales versus date. One index into
    the table could be the date, while the other index could be the product’s identification
    (some integer designation). The element of the array selected by these two indices
    would be the total sales of that product on a given date. A three-dimensional
    extension of this example could be sales of products by date and by country. Again,
    a combination of product value, date value, and country value would address an
    element in the array to give you the sales of that product within that country
    on the specified date.
  prefs: []
  type: TYPE_NORMAL
- en: Most CPUs can easily handle one-dimensional arrays using an indexed addressing
    mode. Unfortunately, there is no magic addressing mode that lets you easily access
    the elements of multidimensional arrays. That’s going to take some work and several
    machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.6.1 Declaring Multidimensional Arrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An “*m* by *n*” array has `m` × `n` elements and requires `m` × `n` × Element_Size
    bytes of storage. With one-dimensional arrays, the syntax is very similar among
    HLLs. However, their syntax starts to differ with multidimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C, C++, and Java, you use the following syntax to declare a multidimensional
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, here’s a three-dimensional array declaration in C/C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This example creates an array with 64 elements organized with a depth of 4 by
    2 rows by 8 columns. Assuming each `int` object requires 4 bytes, this array consumes
    256 bytes of storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pascal’s syntax supports two equivalent ways of declaring multidimensional
    arrays. The following example demonstrates both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first Pascal declaration is technically an *array of arrays*, whereas the
    second declaration is a standard multidimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Semantically, there are only two major differences in the way different languages
    handle multidimensional arrays: whether the array declaration specifies the overall
    size of each array dimension or the upper and lower bounds; and whether the starting
    index is `0`, `1`, or a user-specified value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.6.2 Declaring Swift Multidimensional Arrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Swift doesn’t support a native multidimensional array, but rather an array
    of arrays. For most programming languages, where an array object is strictly the
    sequence of array elements in memory, an array of arrays and a multidimensional
    array are the same thing (see the Pascal examples given earlier). However, Swift
    uses descriptor (`struct`-based) objects to specify an array. Like string descriptors,
    Swift arrays consist of a data structure that contains various fields (such as
    capacity, current size, and a pointer to data; see “Swift Array Implementation”
    on [page 234](ch08.xhtml#page_234) for more details). When you create an array
    of arrays, you’re actually creating an array of these descriptors, with each pointing
    at a subarray. Consider the following (equivalent) Swift array-of-arrays declarations
    and sample program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this program produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is reasonable—for two-dimensional arrays you’d expect this type of output.
    However, internally, `a1` and `a2` are one-dimensional arrays with two elements
    each. Those two elements are array descriptors that themselves point at arrays
    (each containing three elements in this example). It is unlikely that the six
    array elements associated with `a2` will appear in contiguous memory locations,
    even though `a2` is a contiguous array type. The two array descriptors held in
    `a2` may appear in contiguous memory locations, but that doesn’t necessarily carry
    over to the six data elements at which they collectively point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Swift allocates array storage dynamically, the rows in a two-dimensional
    array could have differing element counts. Consider the following modification
    to the previous Swift program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this program produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the two rows in the `a2` array have different sizes. This could be
    useful or a source of defects, depending on what you’re trying to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: One way to get standard multidimensional array storage in Swift is to declare
    a one-dimensional `ContiguousArray` with sufficient elements for all the elements
    of the multidimensional array. Then use the row-major (or column-major) functionality
    to compute the index into the array (see “Implementing Row-Major Ordering” on
    [page 244](ch08.xhtml#page_244) and “Implementing Column-Major Ordering” on [page
    247](ch08.xhtml#page_247)).
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.6.3 Mapping Multidimensional Array Elements to Memory**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that you’ve seen how arrays are declared, you need to know how to implement
    them in memory. The first challenge is storing a multidimensional object into
    a one-dimensional memory space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a Pascal array of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This array contains 16 bytes organized as four rows of four characters. You
    need to map each of the 16 bytes in this array to each of the 16 contiguous bytes
    in main memory. [Figure 8-3](ch08.xhtml#ch8fig3) shows one way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can map positions within the array grid to memory addresses in different
    ways, as long as you adhere to two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: No two entries in the array can occupy the same memory location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each element in the array always maps to the same memory location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, what you really need is a function with two input parameters (one
    for a row and one for a column value) that produces an offset into a contiguous
    block of 16 memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-3: Mapping a 4×4 array to sequential memory locations*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, any old function that satisfies these two constraints will work fine.
    However, what you really want is a mapping function that can compute efficiently
    at runtime and works for arrays with any number of dimensions and any bounds on
    those dimensions. While there are numerous options that fit this bill, most HLLs
    use one of two organizations: *row-major ordering* and *column-major ordering*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.6.4 Implementing Row-Major Ordering**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Row-major ordering assigns array elements to successive memory locations by
    moving across the rows and then down the columns. [Figure 8-4](ch08.xhtml#ch8fig4)
    demonstrates this mapping for `A[col,row`].
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: Row-major ordering for a 4×4 array*'
  prefs: []
  type: TYPE_NORMAL
- en: Row-major ordering is the method employed by most high-level programming languages,
    including Pascal, C/C++/C#, Java, Ada, and Modula-2\. It is very easy to implement
    and easy to use in machine language. The conversion from a two-dimensional structure
    to a linear sequence is very intuitive. [Figure 8-5](ch08.xhtml#ch8fig5) provides
    another view of row-major ordering for a 4×4 array.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: Another view of row-major ordering for a 4x4 array*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function that converts the set of multidimensional array indices into a
    single offset is a slight modification of the formula for computing the address
    of an element of a one-dimensional array. The generic formula to compute the offset
    into a two-dimensional row-major-ordered array given an access of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As usual, Base_Address is the address of the first element of the array (`A[0][0]`
    in this case), and Element_Size is the size of an individual element of the array
    in bytes. Row_size is the number of elements in one row of the array (`4`, in
    this case, because each row has four elements). Assuming Element_Size is `1` and
    row_size is `4`, this formula computes the offsets shown in [Table 8-1](ch08.xhtml#ch8tab1)
    from the base address.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a three-dimensional array, the formula to compute the offset into memory
    is only slightly more complex. Consider a C/C++ array declaration given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Table 8-1:** Offsets for Two-Dimensional Row-Major-Ordered Array'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Column index** | **Row index** | **Offset into array** |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `2` | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `3` | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` | `4` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `5` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `2` | `6` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `3` | `7` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `0` | `8` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `1` | `9` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `2` | `10` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `3` | `11` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `0` | `12` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `1` | `13` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `2` | `14` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `3` | `15` |'
  prefs: []
  type: TYPE_TB
- en: 'If you have an array access similar to `array[depth_index`] [col_index] [row_index],
    then the computation that yields the offset into memory is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Again, Element_Size is the size, in bytes, of a single array element.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a four-dimensional array, declared in C/C++ as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'the formula for computing the address of an array element when accessing element
    `A[i][j][k][m]` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have an *n*-dimensional array declared in C/C++ as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'and you want to access the following element of this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'then you can compute the address of a particular array element using the following
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It would be very rare for a compiler to actually execute such a loop in order
    to compute an array index. There’s usually a small number of dimensions and the
    compiler will unroll the loop, thereby avoiding the overhead of the loop control
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.6.5 Implementing Column-Major Ordering**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Column-major ordering, the other common array element address function, is used
    by FORTRAN, OpenGL, and various dialects of BASIC (such as older versions of Microsoft
    BASIC) to index arrays. A column-major-ordered array (accessing `A[col,row]`)
    is organized as shown in [Figure 8-6](ch08.xhtml#ch8fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/08fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-6: Column-major ordering*'
  prefs: []
  type: TYPE_NORMAL
- en: The formula for computing the address of an array element when using column-major
    ordering is very similar to that for row-major ordering. The difference is that
    you reverse the order of the index and size variables in the computation. That
    is, rather than working from the leftmost index to the rightmost, you operate
    on the indices from the rightmost toward the leftmost.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a two-dimensional column-major array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For a three-dimensional column-major array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: And so on. Other than using these new formulas, accessing elements of an array
    using column-major ordering is identical to accessing arrays using row-major ordering.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.6.6 Accessing Elements of a Multidimensional Array**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It’s so easy to access an element of a multidimensional array in an HLL that
    many programmers do so without considering the associated costs. In this section,
    to give you a clearer picture of these costs, we’ll look at some of the assembly
    language sequences compilers commonly generate to access elements of a multidimensional
    array. Because arrays are one of the more common data structures found in modern
    applications, and multidimensional arrays are also quite common, compiler designers
    have put a lot of work into ensuring that they compute array indices as efficiently
    as possible. Given a declaration such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'and an array reference like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'accessing the array element (using row-major ordering) requires computing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In brute-force assembly code, this might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In practice, however, compiler authors avoid using the 80x86 `intmul` (`imul`)
    instruction because it is slow. Many different machine idioms can be used to simulate
    multiplication using a short sequence of addition, shift, and “load effective
    address” instructions. Most optimizing compilers use sequences that compute the
    array element address rather than the brute-force code that uses a multiply instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following C program, which initializes the 16 elements of a 4×4
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the assembly code that the Borland C++ v5.0 compiler (an old compiler)
    emits for the `for` loop in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the computation `rowIndex * 4 + columnIndex` is handled by
    the following four instructions (which also store away the array element):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that this code sequence used the scaled-index addressing mode (along with
    the `lea` instruction) and the `shl` instruction to do the necessary multiplications.
    Because multiplication tends to be an expensive operation, most compilers avoid
    using it when calculating indices into multidimensional arrays. Nevertheless,
    by comparing this code against the examples given for one-dimensional array access,
    you can see that two-dimensional array access is a bit more expensive in terms
    of the number of machine instructions you must use to compute the index into the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three-dimensional array access is even costlier than two-dimensional array
    access. Here is a C/C++ program that initializes the elements of a three-dimensional
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the 32-bit 80x86 assembly language output that the Microsoft Visual
    C++ compiler produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If you’re interested, you can write your own short HLL programs and analyze
    the assembly code emitted for *n*-dimensional arrays (*n* being greater than or
    equal to 4).
  prefs: []
  type: TYPE_NORMAL
- en: The choice of column-major or row-major array ordering is generally dictated
    by your compiler, if not by the programming language definition. No compiler I’m
    aware of will let you choose which array ordering you prefer on an array-by-array
    basis (or even across a whole program, for that matter). However, there’s really
    no need to do this, as you can easily simulate either storage mechanism by simply
    changing the definitions of “rows” and “columns” in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following C/C++ array declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, you’d access an element of this array using a reference like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If you increment through all the column index values for each row index value
    (which you also increment), you’ll access sequential memory locations when accessing
    elements of this array. That is, the following C `for` loop initializes sequential
    locations in memory with `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If NumRow and NumCols are the same value, then accessing the array elements
    in column-major rather than row-major order is trivial. Simply swap the indices
    in the previous code fragment to obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If NumCols and NumRows are not the same value, you’ll have to manually compute
    the index into the column-major array and allocate the storage in a one-dimensional
    array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift users who want a true multidimensional array implementation (not an array-of-arrays
    implementation) will need to allocate storage for the whole array as a single
    `ContiguousArray` type and then compute the indices into the array manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output from this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it’s possible to access arrays using a column-major organization if
    your application requires it, you should exercise extreme caution when accessing
    arrays in a manner other than the language’s default scheme. Many optimizing compilers
    are smart enough to recognize when you’re accessing arrays in the default manner,
    and they generate far better code in those circumstances. Indeed, the examples
    presented so far have explicitly accessed arrays in uncommon ways in order to
    thwart the compilers’ optimizers. Consider the following C code and the Visual
    C++ output (with optimization enabled):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the Visual C++ assembly language output for the `for` loops in the previous
    code. In particular, note how the compiler substituted an 80x86 `stosd` instruction
    in place of the three loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If you rearrange your indices so that you’re not storing zeros into consecutive
    memory locations, Visual C++ will not compile to the `stosd` instruction. Even
    if the end result is the zeroing of the entire array, the compiler believes that
    the semantics of `stosd` are different. (Imagine two threads in a program that
    are both reading and writing `ThreeByThreeByThree` array elements concurrently;
    the program’s behavior could be different based on the order of the writes to
    the array.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to compiler semantics, there are also good hardware reasons not
    to change the default array ordering. Modern CPU performance is highly dependent
    on the effectiveness of the CPU’s cache. Because cache performance depends on
    the temporal and spatial locality of the data in the cache, you must be careful
    not to access data in a way that disturbs locality. In particular, accessing array
    elements in a manner that is inconsistent with their storage order will dramatically
    impact spatial locality and in turn hurt performance. The moral of the story:
    adopt the compiler’s array organization unless you really know what you’re doing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.6.7 Improving Array Access Efficiency in Your Applications**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Follow these rules when using arrays in your applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Never use a multidimensional array when a one-dimensional array will work. This
    is not to suggest that you should simulate multidimensional arrays by manually
    computing a row-major (or column-major) index into a one-dimensional array, but
    if you can express an algorithm using a one-dimensional array rather than a multidimensional
    array, you should.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you must use multidimensional arrays in your application, try to use array
    bounds that are powers of 2 or, at least, multiples of 4\. Compilers can compute
    indices into such arrays much more efficiently than arrays with arbitrary bound
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When accessing elements of a multidimensional array, try to do so in a manner
    than supports sequential memory access. For row-major-ordered arrays, this implies
    sequencing through the rightmost index the fastest and the leftmost index the
    slowest (and vice versa for column-major ordered arrays).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your language supports operations on entire rows or columns (or other large
    pieces of the array) with a single operation, use those facilities rather than
    accessing individual elements using nested loops. Often, the loop overhead, amortized
    over each array element you access, is greater than the cost of the index calculation
    and element access. This is particularly important when the array operation is
    the only thing happening in the loop(s).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always keep in mind the issues of spatial and temporal locality when accessing
    array elements. Accessing a large number of array elements in a random (or non–cache-friendly)
    fashion can cause thrashing in the cache and virtual memory subsystem.^([3](footnotes.xhtml#ch8fn3))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last point is particularly important. Consider the following HLA program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Simply swapping the loops around—so that the EBX loop is the outermost loop
    and the ECX loop is the innermost loop—can make this program run up to 10 times
    faster. The reason is that the program, as currently written, accesses an array
    stored in row-major order nonsequentially. Changing the rightmost index (ECX)
    most frequently and the leftmost index (EBX) least frequently, then, means this
    program will access memory sequentially. This allows the cache to work better,
    which dramatically improves program performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.7 Dynamic vs. Static Arrays**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some languages allow you to declare arrays whose size isn’t known until the
    program is running. Such arrays are quite useful, because many programs cannot
    predict how much space they will need for a data structure until they receive
    input from a user. For example, consider a program that reads a text file from
    disk, line by line, into an array of strings. Until the program actually reads
    the file and counts the number of lines, it doesn’t know how many elements it
    will need for the array of strings. When writing the program, the programmer had
    no way of knowing how large the array would need to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Languages that provide support for such arrays generally call them *dynamic
    arrays*. This section explores the issues surrounding them and their counterpart,
    *static arrays*. A good place to start is with some definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static array (or pure static array)**'
  prefs: []
  type: TYPE_NORMAL
- en: An array whose size the program knows during compilation. This means the compiler/linker/operating
    system can allocate storage for the array before the program begins execution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pseudo-static array**'
  prefs: []
  type: TYPE_NORMAL
- en: An array whose size is known to the compiler, but for which the program doesn’t
    actually allocate storage until runtime. Automatic variables (that is, nonstatic
    local variables in a function or procedure) are good examples of pseudo-static
    objects. The compiler knows their exact size while compiling the program, but
    the program doesn’t actually allocate storage for them in memory until the function
    or procedure containing the declaration executes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pseudo-dynamic array**'
  prefs: []
  type: TYPE_NORMAL
- en: An array whose size the compiler cannot determine prior to program execution.
    Typically, the program determines the size of the array at runtime as a result
    of user input or as part of some other calculation. Once the program allocates
    storage for a pseudo-dynamic array, however, the size of the array remains fixed
    until the program either terminates or deallocates storage for that array. In
    particular, you cannot change the size of a pseudo-dynamic array to add or delete
    selected elements without deallocating the storage for the whole array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic array (or pure dynamic array)**'
  prefs: []
  type: TYPE_NORMAL
- en: An array whose size the compiler cannot determine until the program runs and,
    in fact, cannot even be sure of once it creates the array. A program may change
    the size of a dynamic array at any time, adding or deleting elements, without
    affecting the values already present in the array (of course, if you delete some
    array elements, their values are lost).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Static and pseudo-static arrays are examples of the static and automatic objects
    discussed previously in this book. See [Chapter 7](ch07.xhtml#ch07) for a review.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.7.1 One-Dimensional Pseudo-Dynamic Arrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Most languages that claim support for dynamic arrays actually support pseudo-dynamic
    arrays. That is, you may specify the size of an array when you first create it,
    but once you’ve done so, you can’t easily change the array’s size without first
    deallocating the original storage for the array. Consider the following Visual
    Basic statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Assuming `i` is an integer variable that you’ve assigned some value prior to
    this statement’s execution, upon encountering this statement Visual Basic will
    create an array with `i`×`2` elements. In languages that do support (pseudo-)
    dynamic arrays, array declarations are usually executable statements, whereas
    in languages that don’t support dynamic arrays, such as C and Pascal, they are
    not. They are simply declarations that the compiler processes for bookkeeping
    reasons, but for which the compiler generates no machine code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although standard C/C++ does not support pseudo-dynamic arrays, the GNU C/C++
    implementation does. Therefore, it’s legal to write a function like the following
    in GNU C/C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if you use this feature in GCC, you’ll only be able to compile your
    programs with GCC.^([4](footnotes.xhtml#ch8fn4)) That’s why you won’t see many
    C/C++ programmers using this type of code in their programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using a language like C/C++ that doesn’t support pseudo-dynamic arrays,
    but does provide a generic memory allocation function, then you can easily create
    arrays that act just like one-dimensional pseudo-dynamic arrays. This is particularly
    easy in languages that don’t check the range of array indices, like C/C++. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: One issue with using a memory allocation function like `malloc()` is that you
    must remember to explicitly free the storage prior to returning from the function
    (as the `free()` call does in this case). Some versions of the C standard library
    include a `talloc()` function that allocates dynamic storage on the stack. Calls
    to `talloc()` are much faster than calls to `malloc()` and `free()`, and `talloc()`
    automatically frees up the storage when you return.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.7.2 Multidimensional Pseudo-Dynamic Arrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you want to create multidimensional pseudo-dynamic arrays, that’s another
    problem altogether. With a one-dimensional pseudo-dynamic array, the program really
    doesn’t need to keep track of the array bounds for any reason but to verify that
    the array index is valid. For multidimensional arrays, however, the program must
    maintain additional information about the upper and lower bounds of each dimension
    of the array; the program needs that size information to compute the offset of
    an array element from a list of array indices, as you saw earlier in the chapter.
    So, in addition to maintaining a pointer containing the address of the base element
    of the array, programs using pseudo-dynamic arrays must also keep track of the
    array bounds.^([5](footnotes.xhtml#ch8fn5)) This collection of information—the
    base address, number of dimensions, and bounds for each dimension—is known as
    a *dope vector*. In a language like HLA, C/C++, or Pascal, you’d typically create
    a `struct` or `record` to maintain the dope vector (see [Chapter 11](ch11.xhtml#ch11)
    for more information about `struct`s and records). Here’s an example of a dope
    vector you might create for a two-dimensional integer array using HLA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the HLA code you would use to read the bounds of a two-dimensional array
    from the user and allocate storage for the pseudo-dynamic array using this dope
    vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This example emphasizes that the program must compute the size of the array
    as the product of the array dimensions and the element size. When processing static
    arrays, the compiler can compute this product during compilation. When working
    with dynamic arrays, however, the compiler must emit machine instructions to compute
    this product at runtime, which means your program will be slightly larger and
    slightly slower than if you had used a static array.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a language doesn’t directly support pseudo-dynamic arrays, you’ll have to
    translate a list of indices into a single offset using the row-major function
    (or something comparable). This is true in HLLs as well as assembly language.
    Consider the following C++ example, which uses row-major ordering to access an
    element of a pseudo-dynamic array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: As for one-dimensional pseudo-dynamic arrays, memory allocation and deallocation
    can be more expensive than the actual array access—particularly if you allocate
    and deallocate many small arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'A big problem with multidimensional dynamic arrays is that the compiler doesn’t
    know the array bounds at compile time, so it can’t generate array access code
    that’s as efficient as what’s possible for pseudo-static and static arrays. As
    an example, consider the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Here’s the pertinent portion of the PowerPC code that GCC emits for this C program
    (manually annotated). The important thing to notice here is that the dynamic array
    code is forced to use an expensive multiply instruction, whereas the pseudo-static
    array code doesn’t need this instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Different compilers and different optimization levels handle dynamic and pseudo-static
    array access in different ways. Some compilers generate the same code for both
    sequences, but many do not. The bottom line is that multidimensional dynamic array
    access is never faster than pseudo-static multidimensional array access, and it
    is sometimes slower.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.1.7.3 Pure Dynamic Arrays**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Pure dynamic arrays are even more difficult to manage. You’ll rarely find them
    outside of very high-level languages like APL, SNOBOL4, LISP, and Prolog. The
    one notable exception is Swift, whose arrays are pure dynamic arrays. Most languages
    that support pure dynamic arrays don’t force you to explicitly declare or allocate
    storage for an array. Instead, you just use elements of an array, and if an element
    isn’t currently present in the array, the language automatically creates it for
    you. So, what happens if you currently have an array with elements `0` through
    `9` and you decide to use element `100`? Well, the result is language dependent.
    Some languages that support pure dynamic arrays will automatically create array
    elements `10..100` and initialize elements `10..99` with `0` (or some other default
    value). Other languages may allocate only element `100` and keep track of the
    fact that the other elements are not yet present in the array. Regardless, the
    extra bookkeeping necessary for each access to the array can be quite expensive.
    That’s why languages that support pure dynamic arrays aren’t more popular—they
    tend to execute programs slowly.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using a language that supports dynamic arrays, keep in mind the costs
    associated with array access in that language. If you’re using a language that
    doesn’t support dynamic arrays, but does support memory allocation/deallocation
    (for example, C/C++, Java, or assembly), you can implement dynamic arrays yourself.
    You’ll be painfully aware of the costs of using such an array, because you’ll
    probably have to write all the code that manipulates its elements, although that’s
    not an altogether bad thing. If you’re using C++, you can even overload the array
    index operator (`[ ]`) to hide the complexity of dynamic array element access.
    Generally, though, programmers who need the true semantics of dynamic arrays will
    usually choose a language that directly supports them. Again, if you choose to
    go this route, just be mindful of the costs.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.2 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Knuth, Donald. *The Art of Computer Programming, Volume I: Fundamental Algorithms.
    3rd ed.* Boston: Addison-Wesley Professional, 1997.'
  prefs: []
  type: TYPE_NORMAL
