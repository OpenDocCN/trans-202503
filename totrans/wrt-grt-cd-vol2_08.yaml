- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**ARRAY DATA TYPES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组数据类型**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'High-level language abstractions hide how the machine deals with *composite
    data types* (a complex data type composed of smaller data objects). Although these
    abstractions are often convenient, if you don’t understand the details behind
    them you might inadvertently use a construct that generates unnecessary code or
    runs slower than need be. In this chapter, we’ll take a look at one of the most
    important composite data types: the array. We’ll consider the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 高级语言的抽象隐藏了机器如何处理*复合数据类型*（由较小的数据对象组成的复杂数据类型）。虽然这些抽象通常很方便，但如果你不了解它们背后的细节，你可能会不经意地使用某些构造，导致生成不必要的代码或运行速度比需要的慢。本章将介绍一个最重要的复合数据类型：数组。我们将考虑以下主题：
- en: The definition of an array
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的定义
- en: How to declare arrays in various languages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在不同的语言中声明数组
- en: How arrays are represented in memory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组在内存中的表示方式
- en: Accessing elements of arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问数组元素
- en: Declaring, representing, and accessing multidimensional arrays
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明、表示和访问多维数组
- en: Row-major and column-major multidimensional array access
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行优先和列优先的多维数组访问
- en: Dynamic versus static arrays
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态数组与静态数组
- en: How using arrays can impact the performance and size of your applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组如何影响应用程序的性能和大小
- en: Arrays are very common in modern applications, so you should have a solid understanding
    of how programs implement and use them in memory in order to write great code.
    This chapter will give you the foundation you need to use arrays more efficiently
    in your programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在现代应用程序中非常常见，因此你应该深入理解程序如何在内存中实现和使用数组，这样才能编写出优秀的代码。本章将为你提供在程序中更高效使用数组所需的基础。
- en: '**8.1 Arrays**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**8.1 数组**'
- en: Arrays are one of the most common composite (or *aggregate*) data types, yet
    few programmers fully grasp how they operate. Once they understand how arrays
    work at the machine level, programmers frequently view them from a completely
    different perspective.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是最常见的复合（或*聚合*）数据类型之一，但很少有程序员能完全理解它们是如何工作的。一旦他们理解了数组在机器级别的运作方式，程序员通常会从完全不同的角度看待它们。
- en: Abstractly, an array is an aggregate data type whose members (elements) are
    all of the same type. To select a member from the array, you specify the member’s
    array index with an integer (or with some value whose underlying representation
    is an integer, such as character, enumerated, and Boolean types). In this chapter,
    we’ll assume that all of the integer indices of an array are numerically contiguous.
    That is, if both `x` and `y` are valid indices of the array, and if `x` < `y`,
    then all `i` such that `x` < `i` < `y` are also valid indices. We’ll also typically
    assume that array elements occupy contiguous locations in memory, although this
    is not required by the general definition of an array. An array with five elements
    appears in memory as shown in [Figure 8-1](ch08.xhtml#ch8fig1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从抽象的角度来看，数组是一种聚合数据类型，其成员（元素）都是相同类型的。要选择数组中的成员，你需要使用整数（或某些其底层表示为整数的值，例如字符、枚举和布尔类型）来指定该成员的数组索引。在本章中，我们假设数组的所有整数索引都是数值上连续的。也就是说，如果`x`和`y`都是数组的有效索引，并且如果`x`
    < `y`，那么所有满足`x` < `i` < `y`的`i`也是有效的索引。我们还通常假设数组元素在内存中占据连续的位置，尽管这不是数组的一般定义所要求的。一个包含五个元素的数组在内存中的表现如[图8-1](ch08.xhtml#ch8fig1)所示。
- en: '![Image](../images/08fig01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig01.jpg)'
- en: '*Figure 8-1: Array layout in memory*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-1：数组在内存中的布局*'
- en: The *base address* of an array is the address of its first element that occupies
    the lowest memory location. The second array element directly follows the first
    in memory, the third element follows the second, and so on. Note that the indices
    do not have to start at `0`; they can start with any number as long as they are
    contiguous. However, discussing array access is easier if the first index is `0`,
    so arrays in this chapter begin at index `0` unless otherwise indicated.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的*基地址*是其第一个元素的地址，该元素占据最低的内存位置。第二个数组元素直接跟在第一个元素后面，第三个元素跟在第二个元素后面，依此类推。请注意，索引不必从`0`开始；它们可以从任何数字开始，只要它们是连续的。然而，讨论数组访问时，如果第一个索引是`0`会更容易，因此除非另有说明，本章中的数组从索引`0`开始。
- en: Whenever you apply the indexing operator to an array, the result is the unique
    array element specified by that index. For example, `A[i]` chooses the `i`th element
    from array `A`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你对数组应用索引操作符时，结果就是由该索引指定的唯一数组元素。例如，`A[i]`选择数组`A`中的第`i`个元素。
- en: '**8.1.1 Array Declarations**'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**8.1 数组声明**'
- en: Array declarations are very similar across many high-level languages (HLLs).
    This section presents examples in several languages.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数组声明在许多高级语言（HLL）中非常相似。本节提供了几种语言的示例。
- en: '**8.1.1.1 Declaring Arrays in C, C++, and Java**'
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.1.1 在C、C++和Java中声明数组**'
- en: 'C, C++, and Java all let you declare an array by specifying the total number
    of elements. The syntax for an array declaration in these languages is:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C、C++和Java都允许你通过指定元素的总数来声明数组。这些语言中的数组声明语法如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are some sample C/C++ array declarations:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些C/C++数组声明的示例：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you declare these arrays as automatic variables, C/C++ initializes them
    with whatever bit patterns happen to exist in memory. If, on the other hand, you
    declare these arrays as static objects, C/C++ initializes each array element with
    `0`. If you want to initialize an array yourself, you can use the following C/C++
    syntax:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些数组声明为自动变量，C/C++会使用内存中现有的位模式初始化它们。另一方面，如果你将这些数组声明为静态对象，C/C++会将每个数组元素初始化为`0`。如果你想自行初始化数组，可以使用以下C/C++语法：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s a typical example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的例子：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The C/C++ compiler stores these initial array values in the object code file,
    and the operating system will load these values into the memory locations associated
    with `intArray` when it loads the program into memory. To see how this works,
    consider the following short C/C++ program:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++编译器将这些初始数组值存储在目标代码文件中，当操作系统将程序加载到内存时，会将这些值加载到与`intArray`相关联的内存位置。为了查看这一过程是如何工作的，考虑以下简短的C/C++程序：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Microsoft’s Visual C++ compiler emits the following 80x86 assembly code for
    the two array declarations:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft的Visual C++编译器为这两个数组声明生成以下80x86汇编代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Each `DD` (“define double word”) statement reserves 4 bytes of storage, and
    the operand specifies their initial value when the OS loads the program into memory.
    The `intArray` declaration appears in the `_DATA` segment, which in the Microsoft
    memory model can contain initialized data. The `array2` variable, on the other
    hand, is declared inside the `_BSS` segment, where MSVC++ places uninitialized
    variables (the `?` character in the operand field tells the assembler that the
    data is uninitialized; the `8 dup (?)` operand tells the assembler to duplicate
    the declaration eight times). When the OS loads the `_BSS` segment into memory,
    it simply zeros out all the memory associated with that segment. In both the initialized
    and uninitialized cases, the compiler allocates all eight elements of these arrays
    in sequential memory locations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`DD`（“定义双字”）语句预留4字节的存储空间，操作数指定它们在操作系统将程序加载到内存时的初始值。`intArray`声明出现在`_DATA`段中，该段在Microsoft内存模型中可以包含初始化数据。另一方面，`array2`变量是在`_BSS`段内声明的，MSVC++将未初始化的变量放置在该段中（操作数字段中的`?`字符告诉汇编器数据未初始化；`8
    dup (?)`操作数告诉汇编器将声明复制八次）。当操作系统将`_BSS`段加载到内存时，它会将与该段关联的所有内存清零。在初始化和未初始化的情况下，编译器都会在连续的内存位置上分配这两个数组的所有八个元素。
- en: '**8.1.1.2 Declaring Arrays in HLA**'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.1.2 在HLA中声明数组**'
- en: 'HLA’s array declaration syntax takes the following form, which is semantically
    equivalent to the C/C++ declaration:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: HLA的数组声明语法如下，它在语义上等同于C/C++声明：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are some examples of HLA array declarations that allocate storage for
    uninitialized arrays (the second example assumes you have defined the `integer`
    data type in a `type` section of the HLA program):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些HLA数组声明的例子，它们为未初始化的数组分配存储空间（第二个例子假设你已经在HLA程序的`type`部分定义了`integer`数据类型）：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also initialize the array elements using declarations like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下声明初始化数组元素：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Both of these definitions create arrays with eight elements. The first definition
    initializes each 4-byte `real32` array element with one of the values in the range
    `0.0..7.0`. The second declaration initializes each `integer` array element with
    one of the values in the range `8..15`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种定义都创建了包含八个元素的数组。第一个定义将每个4字节的`real32`数组元素初始化为`0.0..7.0`范围内的某个值。第二个声明将每个`integer`数组元素初始化为`8..15`范围内的某个值。
- en: '**8.1.1.3 Declaring Arrays in Pascal/Delphi**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.1.3 在Pascal/Delphi中声明数组**'
- en: 'Pascal/Delphi uses the following syntax to declare an array:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal/Delphi使用以下语法声明数组：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As in the previous examples, array_name is the identifier and data_type is
    the type of each element in this array. In Pascal/Delphi (unlike C/C++, Java,
    and HLA) you specify the upper and lower bounds of the array rather than the array’s
    size. The following are typical array declarations in Pascal:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，array_name 是标识符，data_type 是该数组中每个元素的类型。在 Pascal/Delphi 中（不同于 C/C++、Java
    和 HLA），你指定数组的上下边界，而不是数组的大小。以下是 Pascal 中的典型数组声明：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Although these Pascal examples start their indices at `0`, Pascal does not
    require it. The following is a perfectly valid array declaration in Pascal:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些 Pascal 示例的索引从 `0` 开始，但 Pascal 并不要求这样做。以下是 Pascal 中一个完全有效的数组声明：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The program that declares this array would use indices `1998..2028` when accessing
    elements of this array, not `0..30`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 声明此数组的程序在访问该数组元素时会使用索引 `1998..2028`，而不是 `0..30`。
- en: Many Pascal compilers provide a very useful feature to help you locate defects
    in your programs. Whenever you access an element of an array, these compilers
    automatically insert code that will verify that the array index is within the
    bounds specified by the declaration. This extra code will stop the program if
    the index is out of range. For example, if an index into `ProfitsByYear` is outside
    the range `1998..2028`, the program will abort with an error.^([1](footnotes.xhtml#ch8fn1))
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Pascal 编译器提供了一个非常有用的功能，帮助你在程序中找到缺陷。每当你访问数组的元素时，这些编译器会自动插入代码，验证数组索引是否在声明时指定的范围内。如果索引超出范围，这段额外的代码会停止程序。例如，如果
    `ProfitsByYear` 的索引超出了 `1998..2028` 范围，程序将因错误而中止。^([1](footnotes.xhtml#ch8fn1))
- en: '**8.1.1.4 Declaring Arrays in Swift**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.1.4 在 Swift 中声明数组**'
- en: 'Array declarations in Swift are a bit different from those of other C-based
    languages. Swift array declarations take one of the following two (equivalent)
    forms:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的数组声明与其他基于 C 的语言有所不同。Swift 的数组声明有以下两种（等效的）形式：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Unlike in other languages, arrays in Swift are purely dynamic. You don’t normally
    specify the number of elements when you first create the array; instead, you add
    elements to the array as needed using functions like `append()`. If you want to
    predeclare an array with some number of elements, you can use a special array
    constructor form as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言不同，Swift 中的数组是完全动态的。你通常不会在第一次创建数组时指定元素的数量；相反，你可以根据需要使用 `append()` 等函数向数组添加元素。如果你想预声明一个包含一定数量元素的数组，你可以使用特殊的数组构造形式，如下所示：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, initial_value is a value of type element_type and elements
    is the number of elements to create in the array. For example, the following Swift
    code creates two arrays of 100 `Int` values, each initialized to `0`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，initial_value 是元素类型的值，elements 是要在数组中创建的元素数量。例如，以下 Swift 代码创建了两个包含 100
    个 `Int` 值的数组，每个数组都初始化为 `0`：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that you can still extend the size of this array (for example, by using
    the `append()` function); because Swift arrays are dynamic, their size can grow
    or shrink at runtime.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你仍然可以扩展此数组的大小（例如，通过使用 `append()` 函数）；由于 Swift 数组是动态的，它们的大小可以在运行时增长或缩小。
- en: 'It is also possible to create a Swift array with initial values:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用初始值来创建一个 Swift 数组：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Swift, like Pascal, checks the validity of array indices at runtime. Swift will
    raise an exception if you attempt to access an array element that doesn’t exist.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 和 Pascal 一样，会在运行时检查数组索引的有效性。如果你尝试访问一个不存在的数组元素，Swift 会抛出异常。
- en: '**8.1.1.5 Declaring Arrays with Noninteger Index Values**'
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.1.5 声明非整数索引值的数组**'
- en: 'Generally, array indices are integer values, although some languages allow
    other *ordinal types* (data types that use an underlying integer representation).
    For example, Pascal allows `char` and `boolean` array indices. In Pascal, it’s
    perfectly reasonable and useful to declare an array as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数组索引是整数值，尽管一些语言允许其他*序数类型*（使用基础整数表示的类型）。例如，Pascal 允许使用 `char` 和 `boolean`
    类型作为数组索引。在 Pascal 中，声明数组如下是完全合理且有用的：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You access elements of `alphaCnt` using a character expression as the array
    index. For example, consider the following Pascal code, which initializes each
    element of `alphaCnt` to `0`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用字符表达式作为数组索引来访问 `alphaCnt` 的元素。例如，考虑下面的 Pascal 代码，它将 `alphaCnt` 中的每个元素初始化为
    `0`：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Assembly language and C/C++ treat most ordinal values as special instances of
    integer values, so they are legal array indices. Most implementations of BASIC
    allow a floating-point number as an array index, although BASIC always truncates
    the value to an integer before using it as an index.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言和 C/C++ 将大多数顺序值视为整数值的特殊实例，因此它们是合法的数组索引。大多数 BASIC 的实现允许将浮点数作为数组索引，尽管 BASIC
    在使用它作为索引之前总是将值截断为整数。
- en: '**NOTE**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*BASIC allows you to use floating-point values as array indices because the
    original language did not provide support for integer expressions; it provided
    only real and string values.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*BASIC 允许你使用浮点值作为数组索引，因为原始语言不支持整数表达式；它只提供了实数和字符串值。*'
- en: '**8.1.2 Array Representation in Memory**'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**8.1.2 数组在内存中的表示**'
- en: Abstractly, an array is a collection of variables that you access using an index.
    Semantically, you can define an array any way you please, as long as it maps distinct
    indices to distinct objects in memory and always maps the same index to the same
    object. In practice, however, most languages utilize a few common algorithms that
    provide efficient access to the array data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象地说，数组是一组变量，你可以通过索引来访问它们。在语义上，你可以按任何方式定义数组，只要它将不同的索引映射到内存中的不同对象，并且始终将相同的索引映射到相同的对象。然而，实际上，大多数语言使用一些常见的算法来提供对数组数据的高效访问。
- en: The most common implementation of arrays is to store elements in consecutive
    memory locations. As noted earlier, most programming languages store the first
    element of an array at a low memory address and then store the following elements
    in successively higher memory locations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 数组最常见的实现方式是将元素存储在连续的内存位置。如前所述，大多数编程语言将数组的第一个元素存储在较低的内存地址，然后将后续元素存储在逐渐更高的内存位置。
- en: 'Consider the following C program:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 C 程序：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the corresponding PowerPC assembly code that GCC emits for it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 GCC 为它生成的相应 PowerPC 汇编代码：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The number of bytes an array consumes is the number of elements multiplied
    by the number of bytes per element. In the previous example, each array element
    is a single byte, so the array consumes the same number of bytes as it has elements.
    However, for arrays with larger elements, the entire array size (in bytes) is
    correspondingly larger. Consider the following C code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数组占用的字节数是元素个数与每个元素占用字节数的乘积。在前面的例子中，每个数组元素占用一个字节，因此数组占用的字节数与元素个数相同。然而，对于更大元素的数组，整个数组的大小（以字节为单位）相应地更大。考虑以下
    C 代码：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s the corresponding GCC assembly language output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相应的 GCC 汇编语言输出：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Many languages also add a few bytes of padding at the end of an array so that
    the array’s total length will be a multiple of a convenient value like 2 or 4
    (making it easy to compute indices into the array using shifts or to add extra
    padding bytes for the next object in memory; see [Chapter 3](ch03.xhtml#ch03)
    of *WGC1* for details). However, a program must not count on those extra padding
    bytes, because they may or may not be present. Some compilers always put them
    in, others never do, and still others put them in depending on the type of object
    that immediately follows the array in memory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言还会在数组的末尾添加一些填充字节，以使数组的总长度成为像 2 或 4 这样的方便值的倍数（这使得使用位移计算数组索引变得容易，或者为内存中紧跟数组后的下一个对象添加额外的填充字节；详细信息请参见
    *WGC1* 的[第 3 章](ch03.xhtml#ch03)）。然而，程序不能依赖这些额外的填充字节，因为它们可能存在也可能不存在。一些编译器总是将它们加入，另一些则从不加入，还有一些编译器根据内存中紧跟数组的对象类型决定是否加入。
- en: Many optimizing compilers try to start an array at a memory address that is
    a multiple of a common size like 2, 4, or 8 bytes. Effectively, this adds padding
    bytes before the beginning of the array or, if you prefer to think of it this
    way, after the previous object in memory (see [Figure 8-2](ch08.xhtml#ch8fig2)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多优化编译器会尝试将数组放置在内存地址为常见大小（如 2、4 或 8 字节）倍数的地址上。实际上，这会在数组的开始前添加填充字节，或者，如果你更愿意这样理解的话，在内存中紧跟数组的前一个对象之后添加填充字节（参见[图
    8-2](ch08.xhtml#ch8fig2)）。
- en: '![Image](../images/08fig02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig02.jpg)'
- en: '*Figure 8-2: Adding padding bytes before an array*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：在数组前添加填充字节*'
- en: On machines that do not support byte-addressable memory, compilers that attempt
    to place the first element of an array on an easily accessed boundary will allocate
    storage for an array on whatever boundary the machine supports. In the previous
    example, notice that the `.align 2` directive precedes the `_array` declaration.
    In Gas syntax, the `.align` directive tells the assembler to adjust the memory
    address of the next object declared in the source file so that it starts at an
    address that is a multiple of some power (specified by `.align`’s operand) of
    2\. In this example, `.align 2` tells the assembler to align the first element
    of `_array` on an address boundary that is a multiple of 4 (that is, 2²).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在不支持字节寻址内存的机器上，尝试将数组的第一个元素放置在容易访问的边界上的编译器，将根据机器支持的边界分配数组的存储。在前面的示例中，注意到`.align
    2`指令位于`_array`声明之前。在Gas语法中，`.align`指令告诉汇编器调整源文件中下一个声明对象的内存地址，使其开始于某个边界地址，而这个边界地址是2的某个幂（由`.align`的操作数指定）的倍数。在这个示例中，`.align
    2`告诉汇编器将`_array`的第一个元素对齐到一个是4的倍数的地址边界（即2²）。
- en: 'If the size of each array element is less than the minimum-sized memory object
    the CPU supports, the compiler implementer has two options:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个数组元素的大小小于CPU支持的最小内存对象大小，编译器的实现者有两个选择：
- en: Allocate the smallest accessible memory object for each element of the array.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为数组的每个元素分配最小的可访问内存对象。
- en: Pack multiple array elements into a single memory cell.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将多个数组元素打包到一个内存单元中。
- en: Option 1 has the advantage of being fast, but it wastes memory because each
    array element carries some extra storage that it doesn’t need. The following C
    example allocates storage for an array whose element size is 5 bytes, where each
    element is a structure object consisting of a 4-byte `long` object and a 1-byte
    `char` object (we’ll look at C structures in [Chapter 11](ch11.xhtml#ch11)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 选项1的优点是速度快，但它浪费了内存，因为每个数组元素都携带一些它不需要的额外存储。以下C语言示例为一个元素大小为5字节的数组分配存储空间，其中每个元素是一个结构体对象，由一个4字节的`long`对象和一个1字节的`char`对象组成（我们将在[第11章](ch11.xhtml#ch11)中讨论C语言结构体）。
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When GCC compiles this code to run on a PowerPC processor, which requires double-word
    alignment for `long` objects, the compiler automatically inserts 3 bytes of padding
    between each element:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当GCC将此代码编译为在PowerPC处理器上运行时，该处理器需要对`long`对象进行双字对齐，编译器会自动在每个元素之间插入3个字节的填充：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Option 2 is compact but slower, as it requires extra instructions to pack and
    unpack data when accessing array elements. Compilers on such machines often provide
    an option that lets you specify whether you want the data packed or unpacked so
    you can choose between space and speed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 选项2比较紧凑，但速度较慢，因为它在访问数组元素时需要额外的指令来打包和解包数据。在这种机器上的编译器通常提供一个选项，让你指定是否希望数据被打包或解包，从而在空间和速度之间做出选择。
- en: Keep in mind that if you’re working on a byte-addressable machine (like the
    80x86), then you probably don’t have to worry about this issue. However, if you’re
    using an HLL and your code might run on a different machine at some point in the
    future, you should choose an array organization that is efficient on all machines
    (that is, an organization that pads each element of the array with extra bytes).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你在使用字节寻址的机器（如80x86）上工作，那么你可能不需要担心这个问题。然而，如果你正在使用高级语言（HLL），并且你的代码将来可能会在不同的机器上运行，那么你应该选择一种在所有机器上都高效的数组组织方式（即，采用填充每个数组元素的额外字节的组织方式）。
- en: '**8.1.3 Swift Array Implementation**'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**8.1.3 Swift数组实现**'
- en: 'Although the examples so far have included arrays in Swift, Swift arrays have
    a different implementation. First of all, Swift arrays are an opaque type^([2](footnotes.xhtml#ch8fn2))
    based on `struct` objects, rather than just a collection of elements in memory.
    Swift doesn’t guarantee that array elements appear in continuous memory locations;
    thus, you can’t assume that object elements and certain other element types in
    a Swift array are stored contiguously. As a workaround, Swift provides the `ContiguousArray`
    type specification. To guarantee that array elements appear in contiguous memory
    locations, you can specify `ContiguousArray` rather than `Array` when declaring
    array variables in Swift, like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管到目前为止的示例都涉及 Swift 中的数组，但 Swift 数组有不同的实现方式。首先，Swift 数组是基于 `struct` 对象的一个不透明类型^([2](footnotes.xhtml#ch8fn2))，而不仅仅是内存中元素的集合。Swift
    不保证数组元素在连续的内存位置出现；因此，你不能假设在 Swift 数组中的对象元素和某些其他元素类型是连续存储的。作为解决方法，Swift 提供了 `ContiguousArray`
    类型说明。为了保证数组元素出现在连续的内存位置，你可以在声明 Swift 数组变量时指定 `ContiguousArray` 而非 `Array`，如下所示：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The internal implementation of a Swift array is a structure containing a count
    (current number of array elements), a capacity (current number of allocated array
    elements), and a pointer to the storage holding the array elements. Because Swift
    arrays are an opaque type, this implementation could change at any time; however,
    somewhere in the structure there will be a pointer to the actual array data in
    memory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 数组的内部实现是一个包含计数（当前数组元素数量）、容量（当前已分配的数组元素数量）和指向存储数组元素的指针的结构体。由于 Swift 数组是一个不透明类型，这种实现可能随时发生变化；然而，在结构体中的某个位置会有指向实际数组数据的内存指针。
- en: 'Swift allocates storage for arrays dynamically, which means you’ll never see
    the array storage embedded in the object code file that the Swift compiler produces
    (unless the Swift language definition changes to support statically allocated
    arrays). You can increase the size of an array by appending elements to it, but
    if you attempt to extend it beyond its current capacity, the Swift runtime system
    may need to dynamically relocate an array object. For performance reasons, Swift
    uses an exponential allocation scheme: whenever you append a value to an array
    that would exceed its capacity, the Swift runtime system will allocate twice (or
    some other constant) as much storage as the current capacity, copy the data from
    the current array buffer to the new buffer, and then point the array’s internal
    pointer at the new block. One important aspect of this process is that you can
    never assume that the pointer to the array’s data remains static or that the array’s
    data remains in the same buffer location in memory—at different points in time,
    the array could appear in different locations in memory.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 动态地分配数组存储，这意味着你永远看不到 Swift 编译器生成的目标代码文件中嵌入的数组存储（除非 Swift 语言规范发生变化，支持静态分配数组）。你可以通过向数组追加元素来增加数组的大小，但如果你尝试将其扩展超过当前容量，Swift
    运行时系统可能需要动态地重新定位数组对象。为了提高性能，Swift 使用指数分配方案：每当你向数组追加一个会超过其容量的值时，Swift 运行时系统会分配当前容量的两倍（或其他常数）存储空间，将当前数组缓冲区的数据复制到新缓冲区中，然后将数组的内部指针指向新的内存块。这个过程的一个重要方面是，你永远不能假设指向数组数据的指针是静态的，也不能假设数组数据始终保存在内存中的同一缓冲区位置——在不同的时间点，数组可能出现在内存中的不同位置。
- en: '**8.1.4 Accessing Elements of an Array**'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**8.1.4 访问数组元素**'
- en: 'If you allocate all the storage for an array in contiguous memory locations,
    and the first index of the array is `0`, then accessing an element of a one-dimensional
    array is simple. You can compute the address of any given element of an array
    using the following formula:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为数组分配了所有存储空间，并且数组的第一个索引是 `0`，那么访问一维数组的元素就变得很简单。你可以使用以下公式计算数组中任何给定元素的地址：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Element_Size is the number of bytes that each array element occupies. Therefore,
    if the array contains elements of type `byte`, the Element_Size field is `1` and
    the math is very easy. If each element of the array is a `word` (or other 2-byte
    type), then `Element_Size` is `2`, and so on. Consider the following Pascal array
    declaration:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Element_Size 是每个数组元素所占的字节数。因此，如果数组包含 `byte` 类型的元素，则 Element_Size 字段为 `1`，计算就非常简单。如果数组的每个元素是
    `word`（或其他 2 字节类型），则 Element_Size 为 `2`，依此类推。考虑以下 Pascal 数组声明：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To access an element of the `SixteenInts` array on a byte-addressable machine,
    assuming 4-byte integers, you’d use this calculation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字节可寻址的机器上访问 `SixteenInts` 数组的元素，假设使用的是 4 字节整数，你需要使用以下计算：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In HLA assembly language (where you’d have to do this calculation manually
    rather than having the compiler do it for you), you could use code like this to
    access array element `SixteenInts[index]`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HLA 汇编语言中（在这里你必须手动进行这个计算，而不是让编译器为你完成），你可以使用类似这样的代码来访问数组元素 `SixteenInts[index]`：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To see this in action, consider the following Pascal/Delphi program and the
    resulting 32-bit 80x86 code (which I obtained by disassembling the *.exe* output
    from the Delphi compiler and pasting the result back into the original Pascal
    code):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个过程的实际操作，请考虑以下 Pascal/Delphi 程序和生成的 32 位 80x86 代码（我通过反汇编 Delphi 编译器输出的 *.exe*
    文件并将结果粘贴回原始 Pascal 代码中获得）：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As in the HLA example, the Delphi compiler uses the 80x86 scaled-index addressing
    mode to multiply the index into the array by the element size (4 bytes). The 80x86
    provides four different scaling values for the scaled-index addressing mode: 1,
    2, 4, or 8 bytes. If the array’s element size is not one of these four values,
    the machine code must explicitly multiply the index by the array element’s size.
    The following Delphi/Pascal code (and corresponding 80x86 code from the disassembly)
    demonstrates this process using a record that has 9 bytes of active data (Delphi
    rounds this up to the next multiple of 4 bytes, so it actually allocates 12 bytes
    for each element of the array of records):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如同 HLA 示例中所示，Delphi 编译器使用 80x86 缩放索引寻址模式，将索引乘以元素大小（4 字节）。80x86 提供了四种不同的缩放值用于缩放索引寻址模式：1、2、4
    或 8 字节。如果数组的元素大小不是这四个值中的任何一个，机器代码必须显式地将索引乘以数组元素的大小。以下 Delphi/Pascal 代码（及来自反汇编的相应
    80x86 代码）演示了这个过程，其中使用了一个有 9 字节活动数据的记录（Delphi 将其四舍五入到下一个 4 字节的倍数，因此实际上为每个记录数组元素分配了
    12 字节）：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Microsoft’s C/C++ compilers emit comparable code (also allocating 12 bytes for
    each element of the array of records).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的 C/C++ 编译器生成可比的代码（也为每个记录数组元素分配 12 字节）。
- en: '**8.1.5 Padding vs. Packing**'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**8.1.5 填充与打包**'
- en: 'These Pascal examples reiterate an important point: compilers generally pad
    each array element to a multiple of 4 bytes, or whatever size is most convenient
    for the machine’s architecture, to improve access to array elements (and record
    fields) by ensuring that they are always aligned on a reasonable memory boundary.
    Some compilers give you the option of eliminating the padding at the end of each
    array element, so that successive array elements immediately follow the previous
    element in memory. In Pascal/Delphi, for example, you can achieve this by using
    the `packed` keyword:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 Pascal 示例重申了一个重要的观点：编译器通常会将每个数组元素填充到 4 字节的倍数，或者根据机器架构的要求填充到最合适的大小，以提高访问数组元素（和记录字段）的效率，确保它们始终在合理的内存边界上对齐。一些编译器提供了选项，可以消除每个数组元素末尾的填充，使得连续的数组元素在内存中紧接在前一个元素之后。例如，在
    Pascal/Delphi 中，你可以通过使用 `packed` 关键字来实现这一点：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `packed` reserved word is just a hint to a Pascal compiler. A generic Pascal
    compiler can choose to ignore it; the Pascal standard does not make any explicit
    claims about its impact on a compiler’s code generation. Delphi uses the `packed`
    keyword to tell the compiler to pack array (and record) elements on a byte boundary
    rather than a 4-byte boundary. Other Pascal compilers actually use this keyword
    to align objects on bit boundaries.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`packed` 保留字仅仅是给 Pascal 编译器的一个提示。通用的 Pascal 编译器可以选择忽略它；Pascal 标准并没有明确说明它对编译器代码生成的影响。Delphi
    使用 `packed` 关键字来告诉编译器将数组（和记录）元素打包到字节边界，而不是 4 字节边界。其他 Pascal 编译器实际上使用这个关键字将对象对齐到比特边界。'
- en: '**NOTE**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*See your compiler’s documentation for more information about the packed keyword.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关 `packed` 关键字的更多信息，请参阅编译器文档。*'
- en: Few other languages provide a way, within the generic language definition, to
    pack data into a given boundary. In the C/C++ languages, for example, many compilers
    provide pragmas or command-line switches to control array element padding, but
    these facilities are almost always specific to a particular compiler.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有其他语言在通用语言定义中提供将数据打包到给定边界的方式。例如，在 C/C++ 语言中，许多编译器提供了 pragma 或命令行开关来控制数组元素的填充，但这些功能几乎总是特定于某个编译器。
- en: In general, choosing between packed and padded array elements (when you have
    a choice) is usually a tradeoff between speed and space. Packing lets you save
    a small amount of space for each array element at the cost of slower access to
    it (for example, when accessing a `dword` object at an odd address in memory).
    Furthermore, computing the index into an array whose element size is not a convenient
    multiple of 2 (or, better yet, a power of 2) can require more instructions, which
    also slows down programs that access elements of such arrays.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在选择打包和填充数组元素（当你有选择时）时，通常是在速度和空间之间进行权衡。打包可以为每个数组元素节省少量空间，但代价是访问速度变慢（例如，当访问内存中位于奇数地址的`dword`对象时）。此外，计算数组中元素的索引（当元素大小不是2的倍数时，或者更好的是2的幂次）可能需要更多的指令，这也会减慢访问此类数组元素的程序的速度。
- en: Of course, some machine architectures don’t allow misaligned data access, so
    if you’re writing portable code that must compile and run on different CPUs, you
    shouldn’t count on the fact that array elements can be tightly packed into memory.
    Some compilers may not give you this option.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一些机器架构不允许未对齐的数据访问，因此，如果你正在编写必须在不同CPU上编译和运行的可移植代码，你不应指望数组元素可以紧密地打包到内存中。一些编译器可能不提供这个选项。
- en: 'Before closing this discussion, it’s worthwhile to emphasize that the best
    array element sizes are those that are some power of 2\. Generally, it takes only
    a single instruction to multiply any array index by a power of 2 (that single
    instruction is a shift-left instruction). Consider the following C program and
    the assembly output produced by Borland’s C++ compiler, which uses arrays that
    have 32-byte elements:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这段讨论之前，值得强调的是，最佳的数组元素大小是2的幂次。通常，只需一条指令就可以将任何数组索引乘以2的幂（这条指令是左移指令）。考虑以下C程序和Borland
    C++编译器生成的汇编输出，它使用具有32字节元素的数组：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the Borland C++ compiler emits a `shl` instruction to multiply
    the index by 32.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Borland C++编译器发出`shl`指令来将索引乘以32。
- en: '**8.1.6 Multidimensional Arrays**'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**8.1.6 多维数组**'
- en: A *multidimensional* array is one that lets you select an element of the array
    using two or more independent index values. A classic example is a two-dimensional
    data structure (matrix) that tracks product sales versus date. One index into
    the table could be the date, while the other index could be the product’s identification
    (some integer designation). The element of the array selected by these two indices
    would be the total sales of that product on a given date. A three-dimensional
    extension of this example could be sales of products by date and by country. Again,
    a combination of product value, date value, and country value would address an
    element in the array to give you the sales of that product within that country
    on the specified date.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*多维*数组是指允许使用两个或更多独立的索引值来选择数组元素的数组。一个经典的例子是二维数据结构（矩阵），它跟踪按日期的产品销售情况。表中的一个索引可能是日期，另一个索引可能是产品的标识（某个整数值）。通过这两个索引选择的数组元素将是该产品在某个特定日期的总销售额。这个例子的三维扩展可以是按日期和国家销售的产品。再次，产品值、日期值和国家值的组合将用来定位数组中的元素，从而得到该产品在该国家指定日期的销售情况。'
- en: Most CPUs can easily handle one-dimensional arrays using an indexed addressing
    mode. Unfortunately, there is no magic addressing mode that lets you easily access
    the elements of multidimensional arrays. That’s going to take some work and several
    machine instructions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数CPU可以轻松处理使用索引寻址模式的一维数组。不幸的是，没有一种神奇的寻址模式可以让你轻松访问多维数组的元素。这将需要一些工作和几条机器指令。
- en: '**8.1.6.1 Declaring Multidimensional Arrays**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.6.1 声明多维数组**'
- en: An “*m* by *n*” array has `m` × `n` elements and requires `m` × `n` × Element_Size
    bytes of storage. With one-dimensional arrays, the syntax is very similar among
    HLLs. However, their syntax starts to differ with multidimensional arrays.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“*m*乘*n*”的数组有`m` × `n`个元素，需要`m` × `n` × 元素大小字节的存储空间。对于一维数组，高级语言的语法非常相似。然而，它们的语法在多维数组中开始有所不同。
- en: 'In C, C++, and Java, you use the following syntax to declare a multidimensional
    array:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在C、C++和Java中，你可以使用以下语法声明一个多维数组：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For example, here’s a three-dimensional array declaration in C/C++:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个C/C++中的三维数组声明：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This example creates an array with 64 elements organized with a depth of 4 by
    2 rows by 8 columns. Assuming each `int` object requires 4 bytes, this array consumes
    256 bytes of storage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例创建了一个包含 64 个元素的数组，按 4 深度、2 行、8 列的结构组织。假设每个 `int` 对象需要 4 字节，那么这个数组消耗了 256
    字节的存储空间。
- en: 'Pascal’s syntax supports two equivalent ways of declaring multidimensional
    arrays. The following example demonstrates both:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 的语法支持两种等效的声明多维数组的方式。以下示例演示了这两种方式：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first Pascal declaration is technically an *array of arrays*, whereas the
    second declaration is a standard multidimensional array.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 Pascal 声明在技术上是一个*数组的数组*，而第二个声明是一个标准的多维数组。
- en: 'Semantically, there are only two major differences in the way different languages
    handle multidimensional arrays: whether the array declaration specifies the overall
    size of each array dimension or the upper and lower bounds; and whether the starting
    index is `0`, `1`, or a user-specified value.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，不同语言处理多维数组的方式有两个主要差异：是否数组声明指定了每个数组维度的总体大小或上下边界；以及起始索引是否为`0`、`1`或用户指定的值。
- en: '**8.1.6.2 Declaring Swift Multidimensional Arrays**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.6.2 声明 Swift 多维数组**'
- en: 'Swift doesn’t support a native multidimensional array, but rather an array
    of arrays. For most programming languages, where an array object is strictly the
    sequence of array elements in memory, an array of arrays and a multidimensional
    array are the same thing (see the Pascal examples given earlier). However, Swift
    uses descriptor (`struct`-based) objects to specify an array. Like string descriptors,
    Swift arrays consist of a data structure that contains various fields (such as
    capacity, current size, and a pointer to data; see “Swift Array Implementation”
    on [page 234](ch08.xhtml#page_234) for more details). When you create an array
    of arrays, you’re actually creating an array of these descriptors, with each pointing
    at a subarray. Consider the following (equivalent) Swift array-of-arrays declarations
    and sample program:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 不支持原生的多维数组，而是使用数组的数组。对于大多数编程语言来说，数组对象严格来说是内存中数组元素的序列，因此数组的数组和多维数组是相同的（参见前面的
    Pascal 示例）。然而，Swift 使用描述符（基于 `struct`）对象来指定数组。与字符串描述符类似，Swift 数组由一个包含各种字段的数据结构组成（例如容量、当前大小和指向数据的指针；有关更多细节，请参见
    [第 234 页](ch08.xhtml#page_234)的“Swift 数组实现”）。当你创建一个数组的数组时，实际上是在创建一个包含这些描述符的数组，每个描述符都指向一个子数组。考虑以下（等效的）Swift
    数组的数组声明和示例程序：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Running this program produces the following output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序会产生以下输出：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is reasonable—for two-dimensional arrays you’d expect this type of output.
    However, internally, `a1` and `a2` are one-dimensional arrays with two elements
    each. Those two elements are array descriptors that themselves point at arrays
    (each containing three elements in this example). It is unlikely that the six
    array elements associated with `a2` will appear in contiguous memory locations,
    even though `a2` is a contiguous array type. The two array descriptors held in
    `a2` may appear in contiguous memory locations, but that doesn’t necessarily carry
    over to the six data elements at which they collectively point.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合理的——对于二维数组，你会期望看到这种类型的输出。然而，从内部来看，`a1` 和 `a2` 是具有两个元素的单维数组。这两个元素是数组描述符，它们分别指向数组（每个数组在本示例中包含三个元素）。尽管
    `a2` 是一个连续的数组类型，但与 `a2` 相关的六个数组元素不太可能出现在连续的内存位置。`a2` 中持有的两个数组描述符可能出现在连续的内存位置，但这不一定会延续到它们共同指向的六个数据元素上。
- en: 'Because Swift allocates array storage dynamically, the rows in a two-dimensional
    array could have differing element counts. Consider the following modification
    to the previous Swift program:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Swift 动态分配数组存储，二维数组中的行可以具有不同的元素数量。考虑对之前的 Swift 程序进行以下修改：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running this program produces the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序会产生以下输出：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice how the two rows in the `a2` array have different sizes. This could be
    useful or a source of defects, depending on what you’re trying to accomplish.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`a2` 数组中的两行具有不同的大小。这可能是有用的，或者根据你要实现的目标可能是缺陷的来源。
- en: One way to get standard multidimensional array storage in Swift is to declare
    a one-dimensional `ContiguousArray` with sufficient elements for all the elements
    of the multidimensional array. Then use the row-major (or column-major) functionality
    to compute the index into the array (see “Implementing Row-Major Ordering” on
    [page 244](ch08.xhtml#page_244) and “Implementing Column-Major Ordering” on [page
    247](ch08.xhtml#page_247)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中获取标准的多维数组存储的一种方法是声明一个一维的 `ContiguousArray`，该数组的元素数足够容纳所有多维数组的元素。然后使用行主序（或列主序）功能计算数组中的索引（参见[第
    244 页](ch08.xhtml#page_244)的“实现行主序”以及[第 247 页](ch08.xhtml#page_247)的“实现列主序”）。
- en: '**8.1.6.3 Mapping Multidimensional Array Elements to Memory**'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.6.3 将多维数组元素映射到内存**'
- en: Now that you’ve seen how arrays are declared, you need to know how to implement
    them in memory. The first challenge is storing a multidimensional object into
    a one-dimensional memory space.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何声明数组，接下来需要知道如何在内存中实现它们。第一个挑战是将多维对象存储到一维内存空间中。
- en: 'Consider a Pascal array of the following form:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个如下形式的 Pascal 数组：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This array contains 16 bytes organized as four rows of four characters. You
    need to map each of the 16 bytes in this array to each of the 16 contiguous bytes
    in main memory. [Figure 8-3](ch08.xhtml#ch8fig3) shows one way to do this.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组包含 16 字节，组织为四行四列的字符。您需要将该数组中的每个 16 字节映射到主内存中每个连续的 16 字节。[图 8-3](ch08.xhtml#ch8fig3)展示了其中一种方法。
- en: 'You can map positions within the array grid to memory addresses in different
    ways, as long as you adhere to two rules:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过不同的方式将数组网格中的位置映射到内存地址，只要遵循两个规则：
- en: No two entries in the array can occupy the same memory location.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组中的任何两个元素不能占用相同的内存位置。
- en: Each element in the array always maps to the same memory location.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组中的每个元素始终映射到相同的内存位置。
- en: Therefore, what you really need is a function with two input parameters (one
    for a row and one for a column value) that produces an offset into a contiguous
    block of 16 memory locations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您真正需要的是一个具有两个输入参数的函数（一个用于行值，一个用于列值），它会生成一个偏移量，指向一个连续的 16 个内存位置的块。
- en: '![Image](../images/08fig03.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig03.jpg)'
- en: '*Figure 8-3: Mapping a 4×4 array to sequential memory locations*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：将 4×4 数组映射到连续内存位置*'
- en: 'Now, any old function that satisfies these two constraints will work fine.
    However, what you really want is a mapping function that can compute efficiently
    at runtime and works for arrays with any number of dimensions and any bounds on
    those dimensions. While there are numerous options that fit this bill, most HLLs
    use one of two organizations: *row-major ordering* and *column-major ordering*.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何满足这两个约束的旧函数都能正常工作。然而，您真正需要的是一个映射函数，它能在运行时高效地计算，并且适用于具有任意维数和维度边界的数组。虽然有许多选项符合这一要求，但大多数高级编程语言使用两种组织方式之一：*行主序*和*列主序*。
- en: '**8.1.6.4 Implementing Row-Major Ordering**'
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.6.4 实现行主序**'
- en: Row-major ordering assigns array elements to successive memory locations by
    moving across the rows and then down the columns. [Figure 8-4](ch08.xhtml#ch8fig4)
    demonstrates this mapping for `A[col,row`].
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 行主序通过跨越行并向下移动列来将数组元素分配到连续的内存位置。[图 8-4](ch08.xhtml#ch8fig4)演示了`A[col,row]`的这种映射。
- en: '![Image](../images/08fig04.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig04.jpg)'
- en: '*Figure 8-4: Row-major ordering for a 4×4 array*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：4×4 数组的行主序*'
- en: Row-major ordering is the method employed by most high-level programming languages,
    including Pascal, C/C++/C#, Java, Ada, and Modula-2\. It is very easy to implement
    and easy to use in machine language. The conversion from a two-dimensional structure
    to a linear sequence is very intuitive. [Figure 8-5](ch08.xhtml#ch8fig5) provides
    another view of row-major ordering for a 4×4 array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 行主序是大多数高级编程语言使用的方法，包括 Pascal、C/C++/C#、Java、Ada 和 Modula-2。它非常容易实现，并且在机器语言中也很容易使用。从二维结构到线性序列的转换非常直观。[图
    8-5](ch08.xhtml#ch8fig5)提供了一个 4×4 数组的行主序的另一种视图。
- en: '![Image](../images/08fig05.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig05.jpg)'
- en: '*Figure 8-5: Another view of row-major ordering for a 4x4 array*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：4×4 数组的行主序的另一种视图*'
- en: 'The function that converts the set of multidimensional array indices into a
    single offset is a slight modification of the formula for computing the address
    of an element of a one-dimensional array. The generic formula to compute the offset
    into a two-dimensional row-major-ordered array given an access of the form:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将多维数组索引集转换为单一偏移量的函数，是计算一维数组元素地址公式的一个轻微修改。给定形式的二维行优先顺序数组访问时，计算偏移量的通用公式如下：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'is:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As usual, Base_Address is the address of the first element of the array (`A[0][0]`
    in this case), and Element_Size is the size of an individual element of the array
    in bytes. Row_size is the number of elements in one row of the array (`4`, in
    this case, because each row has four elements). Assuming Element_Size is `1` and
    row_size is `4`, this formula computes the offsets shown in [Table 8-1](ch08.xhtml#ch8tab1)
    from the base address.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，Base_Address 是数组第一个元素的地址（在本例中为 `A[0][0]`），Element_Size 是数组中单个元素的大小（以字节为单位）。Row_size
    是数组每行元素的数量（在本例中是 4，因为每行有四个元素）。假设 Element_Size 为 `1` 且 row_size 为 `4`，则该公式计算出从基地址开始的偏移量，如
    [表 8-1](ch08.xhtml#ch8tab1) 所示。
- en: 'For a three-dimensional array, the formula to compute the offset into memory
    is only slightly more complex. Consider a C/C++ array declaration given as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三维数组，计算偏移量的公式仅稍微复杂一些。考虑以下给定的 C/C++ 数组声明：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Table 8-1:** Offsets for Two-Dimensional Row-Major-Ordered Array'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** 二维行优先顺序数组的偏移量'
- en: '| **Column index** | **Row index** | **Offset into array** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **列索引** | **行索引** | **数组偏移量** |'
- en: '| `0` | `0` | `0` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` |'
- en: '| `0` | `1` | `1` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` |'
- en: '| `0` | `2` | `2` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `2` | `2` |'
- en: '| `0` | `3` | `3` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `3` | `3` |'
- en: '| `1` | `0` | `4` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `4` |'
- en: '| `1` | `1` | `5` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `5` |'
- en: '| `1` | `2` | `6` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `2` | `6` |'
- en: '| `1` | `3` | `7` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `3` | `7` |'
- en: '| `2` | `0` | `8` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `0` | `8` |'
- en: '| `2` | `1` | `9` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `1` | `9` |'
- en: '| `2` | `2` | `10` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `2` | `10` |'
- en: '| `2` | `3` | `11` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `3` | `11` |'
- en: '| `3` | `0` | `12` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `0` | `12` |'
- en: '| `3` | `1` | `13` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `1` | `13` |'
- en: '| `3` | `2` | `14` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `2` | `14` |'
- en: '| `3` | `3` | `15` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `3` | `15` |'
- en: 'If you have an array access similar to `array[depth_index`] [col_index] [row_index],
    then the computation that yields the offset into memory is:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有类似 `array[depth_index] [col_index] [row_index]` 的数组访问，则产生内存偏移量的计算公式为：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Again, Element_Size is the size, in bytes, of a single array element.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Element_Size 是单个数组元素的大小（以字节为单位）。
- en: 'For a four-dimensional array, declared in C/C++ as:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于四维数组，声明为 C/C++ 如下：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'the formula for computing the address of an array element when accessing element
    `A[i][j][k][m]` is:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 访问元素 `A[i][j][k][m]` 时，计算数组元素地址的公式为：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you have an *n*-dimensional array declared in C/C++ as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 C/C++ 中声明了一个 *n* 维数组，如下所示：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'and you want to access the following element of this array:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 并且你希望访问该数组的以下元素：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'then you can compute the address of a particular array element using the following
    algorithm:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以使用以下算法计算特定数组元素的地址：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It would be very rare for a compiler to actually execute such a loop in order
    to compute an array index. There’s usually a small number of dimensions and the
    compiler will unroll the loop, thereby avoiding the overhead of the loop control
    instructions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器实际执行这样的循环来计算数组索引是非常罕见的。通常维度较小，编译器会展开循环，从而避免了循环控制指令的开销。
- en: '**8.1.6.5 Implementing Column-Major Ordering**'
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.6.5 实现列优先顺序**'
- en: Column-major ordering, the other common array element address function, is used
    by FORTRAN, OpenGL, and various dialects of BASIC (such as older versions of Microsoft
    BASIC) to index arrays. A column-major-ordered array (accessing `A[col,row]`)
    is organized as shown in [Figure 8-6](ch08.xhtml#ch8fig6).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列优先顺序，另一种常见的数组元素地址函数，被 FORTRAN、OpenGL 和各种 BASIC 方言（如早期版本的 Microsoft BASIC）用于索引数组。列优先顺序的数组（访问形式为
    `A[col,row]`）的组织方式如 [图 8-6](ch08.xhtml#ch8fig6) 所示。
- en: '![Image](../images/08fig06.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig06.jpg)'
- en: '*Figure 8-6: Column-major ordering*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：列优先顺序*'
- en: The formula for computing the address of an array element when using column-major
    ordering is very similar to that for row-major ordering. The difference is that
    you reverse the order of the index and size variables in the computation. That
    is, rather than working from the leftmost index to the rightmost, you operate
    on the indices from the rightmost toward the leftmost.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列主序（column-major）排序时，计算数组元素地址的公式与行主序（row-major）排序时非常相似。不同之处在于，你需要反转计算中的索引和大小变量的顺序。也就是说，计算时不是从最左边的索引开始，而是从最右边的索引开始操作。
- en: 'For a two-dimensional column-major array:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二维列主序数组：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For a three-dimensional column-major array:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三维列主序数组：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: And so on. Other than using these new formulas, accessing elements of an array
    using column-major ordering is identical to accessing arrays using row-major ordering.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推。除了使用这些新公式之外，使用列主序访问数组元素与使用行主序访问数组元素是相同的。
- en: '**8.1.6.6 Accessing Elements of a Multidimensional Array**'
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.6.6 访问多维数组的元素**'
- en: 'It’s so easy to access an element of a multidimensional array in an HLL that
    many programmers do so without considering the associated costs. In this section,
    to give you a clearer picture of these costs, we’ll look at some of the assembly
    language sequences compilers commonly generate to access elements of a multidimensional
    array. Because arrays are one of the more common data structures found in modern
    applications, and multidimensional arrays are also quite common, compiler designers
    have put a lot of work into ensuring that they compute array indices as efficiently
    as possible. Given a declaration such as:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级语言中访问多维数组的元素非常容易，以至于许多程序员在没有考虑相关成本的情况下就这么做了。在本节中，为了让你更清楚地了解这些成本，我们将查看编译器常常生成的一些汇编语言序列，用于访问多维数组的元素。由于数组是现代应用程序中最常见的数据结构之一，而多维数组也非常常见，因此编译器设计师投入了大量的工作，以确保它们尽可能高效地计算数组索引。给定如下声明：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'and an array reference like the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以及像下面这样的数组引用：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'accessing the array element (using row-major ordering) requires computing the
    following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数组元素（使用行主序）需要计算以下内容：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In brute-force assembly code, this might be:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在暴力汇编代码中，这可能是：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In practice, however, compiler authors avoid using the 80x86 `intmul` (`imul`)
    instruction because it is slow. Many different machine idioms can be used to simulate
    multiplication using a short sequence of addition, shift, and “load effective
    address” instructions. Most optimizing compilers use sequences that compute the
    array element address rather than the brute-force code that uses a multiply instruction.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，编译器作者避免使用 80x86 的`intmul`（`imul`）指令，因为它很慢。许多不同的机器惯用法可以用来模拟乘法，利用短小的加法、移位和“加载有效地址”指令序列来实现。大多数优化编译器使用计算数组元素地址的指令序列，而不是使用乘法指令的暴力代码。
- en: 'Consider the following C program, which initializes the 16 elements of a 4×4
    array:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 C 程序，它初始化了一个 4×4 数组的 16 个元素：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now consider the assembly code that the Borland C++ v5.0 compiler (an old compiler)
    emits for the `for` loop in this example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 Borland C++ v5.0 编译器（一个老旧的编译器）为此示例中的`for`循环生成的汇编代码：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In this example, the computation `rowIndex * 4 + columnIndex` is handled by
    the following four instructions (which also store away the array element):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，计算 `rowIndex * 4 + columnIndex` 通过以下四条指令来处理（这些指令也存储了数组元素）：
- en: '[PRE58]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that this code sequence used the scaled-index addressing mode (along with
    the `lea` instruction) and the `shl` instruction to do the necessary multiplications.
    Because multiplication tends to be an expensive operation, most compilers avoid
    using it when calculating indices into multidimensional arrays. Nevertheless,
    by comparing this code against the examples given for one-dimensional array access,
    you can see that two-dimensional array access is a bit more expensive in terms
    of the number of machine instructions you must use to compute the index into the
    array.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码使用了缩放索引寻址模式（以及`lea`指令）和`shl`指令来完成必要的乘法运算。由于乘法操作通常是昂贵的操作，大多数编译器避免在计算多维数组的索引时使用它。尽管如此，通过将这段代码与用于一维数组访问的示例进行比较，你可以看到在计算数组索引时，二维数组访问在机器指令数量上稍微更为昂贵。
- en: 'Three-dimensional array access is even costlier than two-dimensional array
    access. Here is a C/C++ program that initializes the elements of a three-dimensional
    array:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 三维数组的访问比二维数组的访问更昂贵。这里有一个 C/C++ 程序，它初始化了一个三维数组的元素：
- en: '[PRE59]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And here’s the 32-bit 80x86 assembly language output that the Microsoft Visual
    C++ compiler produces:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Microsoft Visual C++编译器生成的32位80x86汇编语言输出：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you’re interested, you can write your own short HLL programs and analyze
    the assembly code emitted for *n*-dimensional arrays (*n* being greater than or
    equal to 4).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，你可以编写自己的短小HLL程序，并分析为*n*维数组（*n*大于或等于4）生成的汇编代码。
- en: The choice of column-major or row-major array ordering is generally dictated
    by your compiler, if not by the programming language definition. No compiler I’m
    aware of will let you choose which array ordering you prefer on an array-by-array
    basis (or even across a whole program, for that matter). However, there’s really
    no need to do this, as you can easily simulate either storage mechanism by simply
    changing the definitions of “rows” and “columns” in your programs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列主序或行主序数组的选择通常由编译器决定，如果没有，则由编程语言的定义决定。我所知道的没有任何编译器允许你按数组逐个选择你偏好的数组排序方式（或者甚至是跨整个程序）。然而，实际上没有必要这样做，因为你可以通过简单地改变程序中“行”和“列”的定义来轻松模拟这两种存储机制。
- en: 'Consider the following C/C++ array declaration:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下C/C++数组声明：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Normally, you’d access an element of this array using a reference like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会通过如下引用访问此数组的元素：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you increment through all the column index values for each row index value
    (which you also increment), you’ll access sequential memory locations when accessing
    elements of this array. That is, the following C `for` loop initializes sequential
    locations in memory with `0`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按每行的列索引值递增（你也会递增行索引值），你将在访问此数组的元素时访问连续的内存位置。也就是说，以下C `for`循环用`0`初始化内存中的连续位置：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If NumRow and NumCols are the same value, then accessing the array elements
    in column-major rather than row-major order is trivial. Simply swap the indices
    in the previous code fragment to obtain:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果NumRow和NumCols的值相同，那么以列主序而不是行主序访问数组元素是微不足道的。只需交换前面代码片段中的索引即可得到：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If NumCols and NumRows are not the same value, you’ll have to manually compute
    the index into the column-major array and allocate the storage in a one-dimensional
    array, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果NumCols和NumRows的值不相同，你将需要手动计算列主序数组中的索引，并像下面这样分配一个一维数组的存储：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Swift users who want a true multidimensional array implementation (not an array-of-arrays
    implementation) will need to allocate storage for the whole array as a single
    `ContiguousArray` type and then compute the indices into the array manually:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 希望实现真正的多维数组（而不是数组的数组实现）的Swift用户需要为整个数组分配存储空间，作为一个单一的`ContiguousArray`类型，然后手动计算数组中的索引：
- en: '[PRE66]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here’s the output from this program:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该程序的输出：
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Although it’s possible to access arrays using a column-major organization if
    your application requires it, you should exercise extreme caution when accessing
    arrays in a manner other than the language’s default scheme. Many optimizing compilers
    are smart enough to recognize when you’re accessing arrays in the default manner,
    and they generate far better code in those circumstances. Indeed, the examples
    presented so far have explicitly accessed arrays in uncommon ways in order to
    thwart the compilers’ optimizers. Consider the following C code and the Visual
    C++ output (with optimization enabled):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如果应用程序需要，使用列主序方式访问数组是可能的，但在以非语言默认方案的方式访问数组时，应该非常小心。许多优化编译器足够聪明，能够识别你是否以默认方式访问数组，并且在这种情况下，它们会生成更好的代码。事实上，迄今为止呈现的示例显式地以不常见的方式访问数组，以阻止编译器的优化器。请考虑以下C代码和启用优化后的Visual
    C++输出：
- en: '[PRE68]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here’s the Visual C++ assembly language output for the `for` loops in the previous
    code. In particular, note how the compiler substituted an 80x86 `stosd` instruction
    in place of the three loops:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面代码中`for`循环的Visual C++汇编语言输出。特别地，注意编译器如何将三个循环替换为一个80x86的`stosd`指令：
- en: '[PRE69]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If you rearrange your indices so that you’re not storing zeros into consecutive
    memory locations, Visual C++ will not compile to the `stosd` instruction. Even
    if the end result is the zeroing of the entire array, the compiler believes that
    the semantics of `stosd` are different. (Imagine two threads in a program that
    are both reading and writing `ThreeByThreeByThree` array elements concurrently;
    the program’s behavior could be different based on the order of the writes to
    the array.)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新排列索引，使得不再将零存储到连续的内存位置，Visual C++ 将不会编译成 `stosd` 指令。即使最终结果是将整个数组置零，编译器仍然认为
    `stosd` 的语义不同。（想象一下程序中有两个线程，它们同时读写 `ThreeByThreeByThree` 数组元素；程序的行为可能会根据写入数组的顺序不同而有所不同。）
- en: 'In addition to compiler semantics, there are also good hardware reasons not
    to change the default array ordering. Modern CPU performance is highly dependent
    on the effectiveness of the CPU’s cache. Because cache performance depends on
    the temporal and spatial locality of the data in the cache, you must be careful
    not to access data in a way that disturbs locality. In particular, accessing array
    elements in a manner that is inconsistent with their storage order will dramatically
    impact spatial locality and in turn hurt performance. The moral of the story:
    adopt the compiler’s array organization unless you really know what you’re doing.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编译器语义之外，还有一些硬件方面的原因不建议更改默认的数组顺序。现代 CPU 的性能高度依赖于 CPU 缓存的有效性。由于缓存性能取决于缓存中数据的时间局部性和空间局部性，因此必须小心避免以破坏局部性的方式访问数据。特别是，以与存储顺序不一致的方式访问数组元素，会显著影响空间局部性，从而降低性能。这个故事的寓意是：除非你真的知道自己在做什么，否则应该采用编译器的数组组织方式。
- en: '**8.1.6.7 Improving Array Access Efficiency in Your Applications**'
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.6.7 在应用程序中提高数组访问效率**'
- en: 'Follow these rules when using arrays in your applications:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中使用数组时，遵循以下规则：
- en: Never use a multidimensional array when a one-dimensional array will work. This
    is not to suggest that you should simulate multidimensional arrays by manually
    computing a row-major (or column-major) index into a one-dimensional array, but
    if you can express an algorithm using a one-dimensional array rather than a multidimensional
    array, you should.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一维数组能够满足需求时，切勿使用多维数组。这并不是建议你通过手动计算行优先（或列优先）索引将多维数组模拟成一维数组，而是如果你可以使用一维数组来表达算法而不是多维数组，应该选择一维数组。
- en: When you must use multidimensional arrays in your application, try to use array
    bounds that are powers of 2 or, at least, multiples of 4\. Compilers can compute
    indices into such arrays much more efficiently than arrays with arbitrary bound
    values.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当必须在应用程序中使用多维数组时，尽量使用 2 的幂次方或至少是 4 的倍数作为数组的边界值。编译器可以比使用任意边界值的数组更有效地计算索引。
- en: When accessing elements of a multidimensional array, try to do so in a manner
    than supports sequential memory access. For row-major-ordered arrays, this implies
    sequencing through the rightmost index the fastest and the leftmost index the
    slowest (and vice versa for column-major ordered arrays).
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问多维数组的元素时，尽量以支持顺序内存访问的方式进行。对于行优先顺序的数组，这意味着应从最右侧的索引开始最快地进行访问，而从最左侧的索引开始最慢地进行访问（对于列优先顺序的数组则相反）。
- en: If your language supports operations on entire rows or columns (or other large
    pieces of the array) with a single operation, use those facilities rather than
    accessing individual elements using nested loops. Often, the loop overhead, amortized
    over each array element you access, is greater than the cost of the index calculation
    and element access. This is particularly important when the array operation is
    the only thing happening in the loop(s).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的编程语言支持对整个行或列（或其他大型数组片段）进行单次操作，那么应该使用这些功能，而不是通过嵌套循环访问单个元素。通常，循环的开销在每个访问的数组元素上摊销后，往往大于索引计算和元素访问的成本。当数组操作是循环中唯一的操作时，这一点尤为重要。
- en: Always keep in mind the issues of spatial and temporal locality when accessing
    array elements. Accessing a large number of array elements in a random (or non–cache-friendly)
    fashion can cause thrashing in the cache and virtual memory subsystem.^([3](footnotes.xhtml#ch8fn3))
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问数组元素时，始终牢记空间局部性和时间局部性的问题。以随机（或非缓存友好）方式访问大量数组元素可能会导致缓存和虚拟内存子系统的抖动。^([3](footnotes.xhtml#ch8fn3))
- en: 'The last point is particularly important. Consider the following HLA program:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条尤其重要。考虑以下 HLA 程序：
- en: '[PRE70]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Simply swapping the loops around—so that the EBX loop is the outermost loop
    and the ECX loop is the innermost loop—can make this program run up to 10 times
    faster. The reason is that the program, as currently written, accesses an array
    stored in row-major order nonsequentially. Changing the rightmost index (ECX)
    most frequently and the leftmost index (EBX) least frequently, then, means this
    program will access memory sequentially. This allows the cache to work better,
    which dramatically improves program performance.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅交换循环的顺序——使得EBX循环成为最外层循环，ECX循环成为最内层循环——就可以使这个程序运行速度提高最多10倍。原因在于，当前写法下，程序以行主序的方式非顺序访问数组。频繁改变最右侧的索引（ECX）而最不频繁改变最左侧的索引（EBX），这意味着该程序将顺序访问内存。这使得缓存能够更好地工作，从而显著提升程序性能。
- en: '**8.1.7 Dynamic vs. Static Arrays**'
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**8.1.7 动态数组与静态数组**'
- en: Some languages allow you to declare arrays whose size isn’t known until the
    program is running. Such arrays are quite useful, because many programs cannot
    predict how much space they will need for a data structure until they receive
    input from a user. For example, consider a program that reads a text file from
    disk, line by line, into an array of strings. Until the program actually reads
    the file and counts the number of lines, it doesn’t know how many elements it
    will need for the array of strings. When writing the program, the programmer had
    no way of knowing how large the array would need to be.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言允许你声明在程序运行之前其大小未知的数组。这些数组非常有用，因为许多程序在接收到用户输入之前无法预测数据结构需要多少空间。例如，考虑一个程序，它将从磁盘逐行读取文本文件，并将内容存入字符串数组中。在程序实际读取文件并计算行数之前，它并不知道需要多少元素来存储字符串数组。在编写程序时，程序员无法知道数组需要多大。
- en: 'Languages that provide support for such arrays generally call them *dynamic
    arrays*. This section explores the issues surrounding them and their counterpart,
    *static arrays*. A good place to start is with some definitions:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 支持这种数组的语言通常称其为*动态数组*。本节探讨与动态数组及其对应物*静态数组*相关的问题。一个好的起点是一些定义：
- en: '**Static array (or pure static array)**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态数组（或纯静态数组）**'
- en: An array whose size the program knows during compilation. This means the compiler/linker/operating
    system can allocate storage for the array before the program begins execution.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数组，其大小在编译期间程序就已知道。这意味着编译器/链接器/操作系统可以在程序执行之前为该数组分配存储空间。
- en: '**Pseudo-static array**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪静态数组**'
- en: An array whose size is known to the compiler, but for which the program doesn’t
    actually allocate storage until runtime. Automatic variables (that is, nonstatic
    local variables in a function or procedure) are good examples of pseudo-static
    objects. The compiler knows their exact size while compiling the program, but
    the program doesn’t actually allocate storage for them in memory until the function
    or procedure containing the declaration executes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数组，其大小编译器知道，但程序直到运行时才实际分配存储空间。自动变量（即，函数或过程中的非静态局部变量）就是伪静态对象的一个很好的例子。编译器在编译程序时就知道它们的确切大小，但程序直到包含声明的函数或过程执行时，才会为它们分配内存存储空间。
- en: '**Pseudo-dynamic array**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪动态数组**'
- en: An array whose size the compiler cannot determine prior to program execution.
    Typically, the program determines the size of the array at runtime as a result
    of user input or as part of some other calculation. Once the program allocates
    storage for a pseudo-dynamic array, however, the size of the array remains fixed
    until the program either terminates or deallocates storage for that array. In
    particular, you cannot change the size of a pseudo-dynamic array to add or delete
    selected elements without deallocating the storage for the whole array.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数组，其大小编译器无法在程序执行前确定。通常，程序会在运行时根据用户输入或其他计算来确定数组的大小。然而，一旦程序为伪动态数组分配了存储空间，该数组的大小将保持不变，直到程序终止或释放该数组的存储空间。特别地，不能在不释放整个数组存储空间的情况下更改伪动态数组的大小以添加或删除特定元素。
- en: '**Dynamic array (or pure dynamic array)**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态数组（或纯动态数组）**'
- en: An array whose size the compiler cannot determine until the program runs and,
    in fact, cannot even be sure of once it creates the array. A program may change
    the size of a dynamic array at any time, adding or deleting elements, without
    affecting the values already present in the array (of course, if you delete some
    array elements, their values are lost).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数组，其大小编译器无法在程序运行前确定，实际上，即使创建了数组，编译器也不能确保它的大小。程序可以随时改变动态数组的大小，添加或删除元素，而不会影响数组中已有的值（当然，如果删除了一些数组元素，它们的值会丢失）。
- en: '**NOTE**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Static and pseudo-static arrays are examples of the static and automatic objects
    discussed previously in this book. See [Chapter 7](ch07.xhtml#ch07) for a review.*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态数组和伪静态数组是本书之前讨论过的静态和自动对象的例子。请参阅[第7章](ch07.xhtml#ch07)进行复习。*'
- en: '**8.1.7.1 One-Dimensional Pseudo-Dynamic Arrays**'
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.7.1 一维伪动态数组**'
- en: 'Most languages that claim support for dynamic arrays actually support pseudo-dynamic
    arrays. That is, you may specify the size of an array when you first create it,
    but once you’ve done so, you can’t easily change the array’s size without first
    deallocating the original storage for the array. Consider the following Visual
    Basic statement:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数声称支持动态数组的语言实际上只支持伪动态数组。也就是说，当你首次创建数组时，可以指定数组的大小，但一旦指定了大小，就无法轻松更改数组的大小，除非先释放原始的数组存储空间。考虑以下
    Visual Basic 语句：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Assuming `i` is an integer variable that you’ve assigned some value prior to
    this statement’s execution, upon encountering this statement Visual Basic will
    create an array with `i`×`2` elements. In languages that do support (pseudo-)
    dynamic arrays, array declarations are usually executable statements, whereas
    in languages that don’t support dynamic arrays, such as C and Pascal, they are
    not. They are simply declarations that the compiler processes for bookkeeping
    reasons, but for which the compiler generates no machine code.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `i` 是你在执行此语句之前已赋值的整数变量，当 Visual Basic 遇到此语句时，它将创建一个包含 `i`×`2` 个元素的数组。在支持（伪）动态数组的语言中，数组声明通常是可执行语句，而在不支持动态数组的语言（如
    C 和 Pascal）中，数组声明则不是可执行的。它们只是声明，编译器出于记账目的进行处理，但编译器不会为此生成机器代码。
- en: 'Although standard C/C++ does not support pseudo-dynamic arrays, the GNU C/C++
    implementation does. Therefore, it’s legal to write a function like the following
    in GNU C/C++:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标准 C/C++ 不支持伪动态数组，但 GNU C/C++ 实现支持。因此，在 GNU C/C++ 中编写如下函数是合法的：
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Of course, if you use this feature in GCC, you’ll only be able to compile your
    programs with GCC.^([4](footnotes.xhtml#ch8fn4)) That’s why you won’t see many
    C/C++ programmers using this type of code in their programs.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你在 GCC 中使用这个功能，你将只能使用 GCC 编译你的程序。^([4](footnotes.xhtml#ch8fn4)) 这就是为什么你不会看到很多
    C/C++ 程序员在他们的程序中使用这种类型的代码。
- en: 'If you’re using a language like C/C++ that doesn’t support pseudo-dynamic arrays,
    but does provide a generic memory allocation function, then you can easily create
    arrays that act just like one-dimensional pseudo-dynamic arrays. This is particularly
    easy in languages that don’t check the range of array indices, like C/C++. Consider
    the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是像 C/C++ 这样的语言，且该语言不支持伪动态数组，但提供了通用的内存分配函数，那么你可以轻松创建像一维伪动态数组一样的数组。特别是在像
    C/C++ 这种不检查数组索引范围的语言中，这尤其容易实现。考虑以下代码：
- en: '[PRE73]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: One issue with using a memory allocation function like `malloc()` is that you
    must remember to explicitly free the storage prior to returning from the function
    (as the `free()` call does in this case). Some versions of the C standard library
    include a `talloc()` function that allocates dynamic storage on the stack. Calls
    to `talloc()` are much faster than calls to `malloc()` and `free()`, and `talloc()`
    automatically frees up the storage when you return.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 `malloc()` 这样的内存分配函数的一个问题是，必须记得在函数返回之前显式释放存储（如本例中的 `free()` 调用）。某些版本的 C
    标准库包括一个 `talloc()` 函数，该函数在堆栈上分配动态存储。调用 `talloc()` 比调用 `malloc()` 和 `free()` 更快，并且
    `talloc()` 会在你返回时自动释放存储。
- en: '**8.1.7.2 Multidimensional Pseudo-Dynamic Arrays**'
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.7.2 多维伪动态数组**'
- en: 'If you want to create multidimensional pseudo-dynamic arrays, that’s another
    problem altogether. With a one-dimensional pseudo-dynamic array, the program really
    doesn’t need to keep track of the array bounds for any reason but to verify that
    the array index is valid. For multidimensional arrays, however, the program must
    maintain additional information about the upper and lower bounds of each dimension
    of the array; the program needs that size information to compute the offset of
    an array element from a list of array indices, as you saw earlier in the chapter.
    So, in addition to maintaining a pointer containing the address of the base element
    of the array, programs using pseudo-dynamic arrays must also keep track of the
    array bounds.^([5](footnotes.xhtml#ch8fn5)) This collection of information—the
    base address, number of dimensions, and bounds for each dimension—is known as
    a *dope vector*. In a language like HLA, C/C++, or Pascal, you’d typically create
    a `struct` or `record` to maintain the dope vector (see [Chapter 11](ch11.xhtml#ch11)
    for more information about `struct`s and records). Here’s an example of a dope
    vector you might create for a two-dimensional integer array using HLA:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建多维伪动态数组，那是完全不同的问题了。对于一维伪动态数组，程序实际上不需要跟踪数组的边界，除非是为了验证数组索引是否合法。而对于多维数组，程序必须维护每个维度的上下边界的额外信息；程序需要这些大小信息来计算数组元素相对于数组索引列表的偏移量，正如你在本章之前看到的那样。因此，除了保持一个指针来保存数组基元素的地址外，使用伪动态数组的程序还必须跟踪数组的边界。^([5](footnotes.xhtml#ch8fn5))
    这一信息集合——基地址、维度数和每个维度的边界——被称为*多维向量*。在像 HLA、C/C++ 或 Pascal 这样的语言中，你通常会创建一个 `struct`
    或 `record` 来维护多维向量（有关 `struct` 和记录的更多信息，请参见[第 11 章](ch11.xhtml#ch11)）。以下是你可能为一个二维整数数组创建的多维向量的示例，使用
    HLA：
- en: '[PRE74]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here’s the HLA code you would use to read the bounds of a two-dimensional array
    from the user and allocate storage for the pseudo-dynamic array using this dope
    vector:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将用来从用户读取二维数组的边界并使用此多维向量为伪动态数组分配存储的 HLA 代码：
- en: '[PRE75]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This example emphasizes that the program must compute the size of the array
    as the product of the array dimensions and the element size. When processing static
    arrays, the compiler can compute this product during compilation. When working
    with dynamic arrays, however, the compiler must emit machine instructions to compute
    this product at runtime, which means your program will be slightly larger and
    slightly slower than if you had used a static array.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例强调了程序必须将数组的大小计算为数组维度的乘积与元素大小的乘积。在处理静态数组时，编译器可以在编译时计算这个乘积。然而，在处理动态数组时，编译器必须在运行时生成机器指令来计算这个乘积，这意味着你的程序会比使用静态数组时稍大且稍慢。
- en: 'If a language doesn’t directly support pseudo-dynamic arrays, you’ll have to
    translate a list of indices into a single offset using the row-major function
    (or something comparable). This is true in HLLs as well as assembly language.
    Consider the following C++ example, which uses row-major ordering to access an
    element of a pseudo-dynamic array:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某种语言不直接支持伪动态数组，你将不得不使用行主序函数（或类似的函数）将索引列表转换为单一偏移量。这在高级语言和汇编语言中都是如此。考虑以下 C++
    示例，它使用行主序方式访问伪动态数组的一个元素：
- en: '[PRE76]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: As for one-dimensional pseudo-dynamic arrays, memory allocation and deallocation
    can be more expensive than the actual array access—particularly if you allocate
    and deallocate many small arrays.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 至于一维伪动态数组，内存分配和回收可能比实际的数组访问更昂贵——尤其是当你分配和回收许多小数组时。
- en: 'A big problem with multidimensional dynamic arrays is that the compiler doesn’t
    know the array bounds at compile time, so it can’t generate array access code
    that’s as efficient as what’s possible for pseudo-static and static arrays. As
    an example, consider the following C code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 多维动态数组的一个大问题是编译器在编译时无法知道数组的边界，因此它无法生成像伪静态数组和静态数组那样高效的数组访问代码。举个例子，考虑以下的 C 代码：
- en: '[PRE77]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here’s the pertinent portion of the PowerPC code that GCC emits for this C program
    (manually annotated). The important thing to notice here is that the dynamic array
    code is forced to use an expensive multiply instruction, whereas the pseudo-static
    array code doesn’t need this instruction.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 GCC 为该 C 程序生成的 PowerPC 代码的相关部分（手动注释）。需要注意的重要一点是，动态数组代码被迫使用昂贵的乘法指令，而伪静态数组代码则不需要这条指令。
- en: '[PRE78]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Different compilers and different optimization levels handle dynamic and pseudo-static
    array access in different ways. Some compilers generate the same code for both
    sequences, but many do not. The bottom line is that multidimensional dynamic array
    access is never faster than pseudo-static multidimensional array access, and it
    is sometimes slower.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编译器和不同的优化级别以不同的方式处理动态数组和伪静态数组的访问。有些编译器为这两种序列生成相同的代码，但很多编译器并不如此。底线是，多维动态数组访问从来不比伪静态多维数组访问更快，有时甚至更慢。
- en: '**8.1.7.3 Pure Dynamic Arrays**'
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**8.1.7.3 纯动态数组**'
- en: Pure dynamic arrays are even more difficult to manage. You’ll rarely find them
    outside of very high-level languages like APL, SNOBOL4, LISP, and Prolog. The
    one notable exception is Swift, whose arrays are pure dynamic arrays. Most languages
    that support pure dynamic arrays don’t force you to explicitly declare or allocate
    storage for an array. Instead, you just use elements of an array, and if an element
    isn’t currently present in the array, the language automatically creates it for
    you. So, what happens if you currently have an array with elements `0` through
    `9` and you decide to use element `100`? Well, the result is language dependent.
    Some languages that support pure dynamic arrays will automatically create array
    elements `10..100` and initialize elements `10..99` with `0` (or some other default
    value). Other languages may allocate only element `100` and keep track of the
    fact that the other elements are not yet present in the array. Regardless, the
    extra bookkeeping necessary for each access to the array can be quite expensive.
    That’s why languages that support pure dynamic arrays aren’t more popular—they
    tend to execute programs slowly.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 纯动态数组的管理更加困难。你很少能在像 APL、SNOBOL4、LISP 和 Prolog 这样的高级语言之外看到它们。唯一的显著例外是 Swift，它的数组就是纯动态数组。大多数支持纯动态数组的语言不会强制要求你显式声明或分配数组的存储空间。相反，你只需使用数组中的元素，如果某个元素当前不在数组中，语言会自动为你创建它。那么，如果你当前有一个包含元素
    `0` 到 `9` 的数组，决定使用元素 `100` 会发生什么呢？嗯，结果依赖于语言。一些支持纯动态数组的语言会自动创建数组元素 `10..100`，并将元素
    `10..99` 初始化为 `0`（或其他默认值）。其他语言可能只分配元素 `100`，并跟踪其他元素尚未出现在数组中的事实。不管怎样，每次访问数组时所需的额外记录是相当昂贵的。这就是为什么支持纯动态数组的语言不太流行——它们通常执行程序较慢。
- en: If you’re using a language that supports dynamic arrays, keep in mind the costs
    associated with array access in that language. If you’re using a language that
    doesn’t support dynamic arrays, but does support memory allocation/deallocation
    (for example, C/C++, Java, or assembly), you can implement dynamic arrays yourself.
    You’ll be painfully aware of the costs of using such an array, because you’ll
    probably have to write all the code that manipulates its elements, although that’s
    not an altogether bad thing. If you’re using C++, you can even overload the array
    index operator (`[ ]`) to hide the complexity of dynamic array element access.
    Generally, though, programmers who need the true semantics of dynamic arrays will
    usually choose a language that directly supports them. Again, if you choose to
    go this route, just be mindful of the costs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是支持动态数组的语言，请记住该语言中与数组访问相关的开销。如果你使用的语言不支持动态数组，但支持内存分配/释放（例如，C/C++、Java
    或汇编语言），你可以自行实现动态数组。你将深刻意识到使用此类数组的开销，因为你可能需要编写所有操作其元素的代码，尽管这并不完全是坏事。如果你使用的是 C++，你甚至可以重载数组索引运算符（`[
    ]`）来隐藏动态数组元素访问的复杂性。不过，一般来说，真正需要动态数组语义的程序员通常会选择直接支持动态数组的语言。同样，如果你选择了这种方式，记得留意其开销。
- en: '**8.2 For More Information**'
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**8.2 更多信息**'
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Duntemann, Jeff. *汇编语言一步一步*. 第3版。印第安纳波利斯：Wiley，2009年。
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Hyde, Randall. *汇编语言艺术*. 第2版。旧金山：No Starch Press，2010年。
- en: 'Knuth, Donald. *The Art of Computer Programming, Volume I: Fundamental Algorithms.
    3rd ed.* Boston: Addison-Wesley Professional, 1997.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth, Donald. *计算机程序设计艺术，第一卷：基础算法，第三版*。波士顿：Addison-Wesley Professional，1997年。
