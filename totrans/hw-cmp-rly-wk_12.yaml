- en: '## **12'
  prefs: []
  type: TYPE_NORMAL
- en: THE WORLD WIDE WEB**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous chapter described the internet, the globally connected set of computer
    networks that share a suite of protocols. The World Wide Web is a system built
    on top of the internet, one so popular that it is often confused with the internet
    itself. In this chapter, we dive into the details of the web. We first look at
    its key attributes and related programming languages, and then we look at web
    browsers and web servers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview of the World Wide Web**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *World Wide Web*, often just called the *web*, is a set of resources, delivered
    using *HyperText Transfer Protocol (HTTP)* over the internet. A web *resource*
    is anything that can be accessed using the web, such as a document or an image.
    A computer or software program that hosts web resources is called a *web server*,
    and a *web browser* is a type of application commonly used to access content on
    the web. Browsers are used to view documents known as *web pages*, and a collection
    of related web pages is known as a *website*. The web is distributed, addressable,
    and linked. Let’s begin by examining each of those core attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Distributed Web***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The World Wide Web is *distributed*. No centralized organization or system governs
    what content can be published to the web. Any computer connected to the internet
    can run a web server, and the owner of such a computer can make available any
    content they wish. That said, organizations or countries may choose to block users
    from accessing certain content on the web, and governments can shut down websites
    that host illegal content. Aside from those cases, the web is an open platform
    for publishing whatever people wish to publish, and no single organization controls
    what content is made available.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Addressable Web***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The web uses *Uniform Resource Locators (URLs)* to give every resource on the
    web a unique address that includes both its location and how to access it. URLs
    are commonly referred to as *web addresses* or just *addresses*. To illustrate
    how these addresses are structured, let’s use a URL for a fictitious travel website,
    as shown in [Figure 12-1](ch12.xhtml#ch12fig1). This URL identifies a page with
    information about traveling to the Carolinas.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: An example URL*'
  prefs: []
  type: TYPE_NORMAL
- en: A URL is composed of multiple parts. The URL *scheme* identifies the application
    layer protocol for accessing the resource. In this case, the protocol is HTTP,
    which we’ll cover in more detail later. The colon (:) character indicates the
    end of the scheme portion. Following two forward slashes (//) is the *authority*
    portion of the URL. In this example, the authority portion contains a DNS hostname
    of the server(s) where the resource resides, *travel.example.com*. An IP address
    can be used here as well. Other information besides the host can also go in this
    section, such as a username (preceding the host and followed by an @ sign) or
    port number (following the host and prefixed with a colon). The *path* portion
    of the URL is next; it specifies the location of a resource on the web server.
    A URL path is analogous to a filesystem path, organizing resources into a logical
    hierarchy. In our example, the path */destinations/carolinas* implies that the
    site has a collection of pages that describe travel destinations, and the particular
    page specified in the URL is a page about the Carolinas. We could reasonably assume
    that if the site had a page describing Florida as a destination, it would be found
    at */destinations/florida*. Finally, the *query* portion of the URL acts as a
    modifier to the resource returned to the client. In our example, the query indicates
    that the *carolinas* page should display locations at the beach. The format and
    meaning of the query portion of the URL varies from site to site.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of information is packed into that URL, so let me restate how to read
    it in plain language. A website is running on a computer named *travel.example.com*.
    The site speaks HTTP, so use that protocol when connecting to the site. On that
    site there’s a page called *carolinas*, part of a collection of *destinations*.
    The query string directs the page to only show locations that are at the beach.
  prefs: []
  type: TYPE_NORMAL
- en: A URL does not have to include every element in the example in [Figure 12-1](ch12.xhtml#ch12fig1).
    It may also contain some elements not included in this example. A URL that includes
    only the scheme and the authority is perfectly valid, such as *[http://travel.example.com](http://travel.example.com)*.
    In that scenario, the website serves its default page, since no path is provided.
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISE 12-1: IDENTIFY THE PARTS OF A URL**'
  prefs: []
  type: TYPE_NORMAL
- en: For the following URLs, identify the scheme, username, host, port, path, and
    query. Not all URLs include all these parts.
  prefs: []
  type: TYPE_NORMAL
- en: '*[https://example.com/photos?subject=cat&color=black](https://example.com/photos?subject=cat&color=black)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[http://192.168.1.20:8080/docs/set5/two-trees.pdf](http://192.168.1.20:8080/docs/set5/two-trees.pdf)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[mailto:someone@example.com](mailto:someone@example.com)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can check your answers in [Appendix A](appa.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: A web browser typically displays the current URL in its address bar, as illustrated
    in [Figure 12-2](ch12.xhtml#ch12fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-2: The address bar*'
  prefs: []
  type: TYPE_NORMAL
- en: Today, it’s common for browsers to exclude the scheme, colon, and forward slashes
    in the address bar representation of the URL. This doesn’t mean these elements
    of the URL are no longer used by the browser. The browser is just trying to simplify
    things for users. The specifics of how the URL is displayed continue to change
    over time, with various browsers behaving differently.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-3](ch12.xhtml#ch12fig3) shows examples of how Google Chrome (version
    77) displays URLs in its address bar.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-3: Chrome’s address bar*'
  prefs: []
  type: TYPE_NORMAL
- en: The top image in [Figure 12-3](ch12.xhtml#ch12fig3) shows the address bar when
    an HTTP site is loaded. Chrome doesn’t display the *http://* prefix in its address
    bar. Note the `Not secure` text. The lower image shows the address bar when an
    HTTPS site is loaded. HTTPS is the secure version of HTTP. Chrome omits the *https://*
    prefix but displays a padlock icon indicating this is an HTTPS site.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been discussing URLs in the context of web pages, but URLs extend to other
    resources on the web too. An image shown on a web page, for example, has its own
    URL, as does a script file or an XML data file. A web browser only shows the URL
    of the web page in its address bar, but a typical web page references various
    other resources by URL; the browser automatically loads those resources.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it isn’t necessary to include the scheme, hostname, or even the full
    path in a URL. When a URL omits one or more of these elements, it’s known as a
    *relative URL*. A relative URL is interpreted as relative to the context in which
    it’s found. For example, if a URL like */images/cat.jpg* is used on a web page,
    the browser that loads the page assumes that the scheme and hostname of the cat
    photo match the scheme and hostname of the page itself.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Linked Web***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The nature of URLs, where every resource on the web has a unique address, makes
    it easy for one web resource to reference another. A reference from one web document
    to another is known as a *hyperlink*, or just a *link*. Such links are one-way;
    any web page can link to another page without permission or a reciprocal link.
    This system of pages linking to one another is what puts the “web” in World Wide
    Web. Documents like web pages that can be connected with hyperlinks are known
    as *hypertext* documents.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Protocols of the Web***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The web is delivered using *HyperText Transfer Protocol (HTTP)*, and its secure
    variant, *HTTPS*.
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Despite its name, HTTP isn’t just for transferring hypertext; it’s used for
    reading, creating, updating, and deleting all resources on the web. HTTP typically
    relies on TCP/IP. TCP ensures that data is reliably transferred, and IP handles
    host addressing. HTTP itself is based on a model of *request* and *response*.
    An HTTP request is sent to a web server, and the server replies with a response.
  prefs: []
  type: TYPE_NORMAL
- en: Each HTTP request includes an *HTTP method*, also informally called an *HTTP
    verb*, that describes what kind of action the client is requesting of the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some commonly used HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: GET   Retrieve a resource without modifying it.
  prefs: []
  type: TYPE_NORMAL
- en: PUT   Create or modify a resource at a specific URL on the server.
  prefs: []
  type: TYPE_NORMAL
- en: POST   Create a resource on the server, as a child of an existing URL.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE   Remove a resource from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Any HTTP method can be attempted on any resource, but the server hosting a specific
    resource often won’t allow some methods on that resource. For example, most websites
    do not allow clients to delete resources. Those that do allow deletion almost
    always require the user to log on with an account that has permission to delete
    content.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used method on a typical website is `GET`. When a web browser
    navigates to a website, the browser performs a `GET` on the requested page. That
    page may include references to scripts, images, and so forth, and the browser
    then also uses the `GET` method to obtain those resources before the page can
    be fully displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Each HTTP response includes an *HTTP status code* that describes the server’s
    response. Each status code is a 3-digit number, where the most significant digit
    indicates the general class of response. Responses in the 100 range are informational.
    Responses in the 200 range indicate success. Responses in the 300 range indicate
    redirection. Responses in the 400s indicate an error on the client side—the request
    wasn’t properly formed by the client. A 500 range response means the server encountered
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some commonly used HTTP status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**200**   Success. The server was able to fulfill the request.'
  prefs: []
  type: TYPE_NORMAL
- en: '**301**   Moved Permanently. The browser should redirect the request to a different
    URL, specified in the response.'
  prefs: []
  type: TYPE_NORMAL
- en: '**401**   Unauthorized. Authentication is required.'
  prefs: []
  type: TYPE_NORMAL
- en: '**403**   Forbidden. The user doesn’t have access to the requested resource.'
  prefs: []
  type: TYPE_NORMAL
- en: '**404**   Not Found. The server didn’t find the requested resource.'
  prefs: []
  type: TYPE_NORMAL
- en: '**500**   Internal Server Error. Something unexpected happened on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP is fairly easy to understand. It uses human-readable text to describe
    requests and responses. The first line of a request includes an HTTP method, the
    URL of the resource, and the requested version of HTTP. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This simply means that the client is asking the server to send it the content
    of */documents/hello.txt* using HTTP version `1.1`. Following the request line,
    an HTTP request usually includes header fields that provide more information about
    the request and an optional message body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, an HTTP response uses a simple text format. The first line includes
    a version of HTTP, a status code, and a response phrase. Here’s an example of
    the first line of an HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example response, the server is indicating a status code of `200` and
    a response phrase of `OK`. Just like HTTP requests, responses may also include
    header values and a message body. [Figure 12-4](ch12.xhtml#ch12fig4) provides
    a more detailed, but still simplified, example of an HTTP request and response.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-4: A simplified HTTP request and response*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please see [Project #36](ch12.xhtml#proj36) on [page 283](ch12.xhtml#page_283),
    where you can look at HTTP network traffic*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTPS**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A secure variation of HTTP known as *HTTPS (HyperText Transfer Protocol Secure)*
    is commonly used on the web to encrypt data sent over the internet. *Encryption*
    is the process of encoding data into a format that’s unreadable. *Decryption*
    is the reversal of encryption, making encrypted data readable again. Cryptographic
    algorithms encrypt and decrypt data using a secret sequence of bytes known as
    a *cryptographic key*. Because keys can be kept secret, the algorithm itself can
    be well-known.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTPS uses two kinds of encryption. *Symmetric encryption* uses a single *shared
    key* both for encrypting and decrypting a message. *Asymmetric encryption* uses
    two keys (a *key pair*): a *public key* is used to encrypt data, and a *private*
    *key* is used to decrypt data. Asymmetric encryption allows a public key to be
    shared freely so that anyone can encrypt and send data, whereas a private key
    is shared only with trusted parties who need to be able to receive and decrypt
    the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Without HTTPS, web traffic is transmitted “in the clear,” meaning it is unencrypted
    and can be intercepted or modified in transit by malicious parties. HTTPS helps
    to reduce these risks. With HTTPS, the entire HTTP request is encrypted, including
    the URL, headers, and body. The same is true of an HTTPS response; it’s fully
    encrypted. HTTPS takes an HTTP request and encrypts it using a protocol called
    *Transport Layer Security (TLS)*. In the past, a similar protocol called *Secure
    Sockets Layer (SSL)* was used, but due to security issues, it has since been deprecated
    in favor of TLS. When we speak of HTTPS, what we mean is HTTP encrypted with TLS.
  prefs: []
  type: TYPE_NORMAL
- en: When an HTTPS session begins, the client connects to the server with a *client
    hello* message with details of how it wishes to securely communicate. The server
    responds with a *server hello* message that confirms how the communication will
    occur. The server also sends a set of bytes known as a *digital certificate*,
    which includes the server’s public cryptographic key, used for asymmetric encryption.
    The client then checks if the server’s certificate is valid. If so, the client
    encrypts a string of bytes using the server’s public key and then sends the encrypted
    message to the server. The server decrypts the bytes using its private key. The
    server and client both use the information previously exchanged to compute a shared
    secret key, used for symmetric encryption. Once both client and server have the
    shared key, that key is used to encrypt and decrypt all communication between
    the client and server for the duration of the session.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS was previously only used in limited cases, for websites that dealt with
    particularly sensitive information. However, the web is moving to a state in which
    HTTPS is the norm rather than the exception. There is a growing belief that the
    security and privacy benefits of HTTPS make sense for most, if not all, traffic
    on the web. Google has encouraged this change, by marking HTTP sites as “Not secure”
    in Chrome and by using the presence of HTTPS as a positive signal to its search
    engine, helping to boost the Google search rank of HTTPS sites.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please see [Project #37](ch12.xhtml#proj37) on [page 285](ch12.xhtml#page_285),
    where you can set up a simple web server on your local network.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Searchable Web***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For many people, the typical entry point to the web is a search. Rather than
    navigate to a particular URL, a user types some search terms into their browser
    and sees what comes up. Browser design encourages this, since browsers commonly
    leverage the address bar as a search box too. Even when a user wants to visit
    a particular site, they often perform a search for that site, then click the resulting
    link, rather than entering the full URL in the address bar. This is a design that
    enhances usability of the browser, even as it blurs the distinction between URLs
    and search terms, browser and search engine.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the prevalence and usefulness of searching the web, the capability of
    searching isn’t a native feature of the web. There isn’t a standard specification
    for how searching should work. This means that searching, one of the key features
    of the web, relies on nonstandard, proprietary search engines. At the time of
    this writing, Google dominates the web searching space, and although there are
    good alternative search engines, their worldwide usage is a fraction of Google’s.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Languages of the Web**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any content that can be saved as a file can be hosted on the web. For example,
    a web server can host a collection of Excel files, and they can be downloaded
    from the website and opened in Excel. However, a web browser is much more than
    just a tool for downloading files to be opened in other applications. A web browser
    not only downloads content, but also renders web pages. These pages can be simple
    documents, or interactive web applications. To make this possible, browsers understand
    three computer languages, which are used to construct websites.
  prefs: []
  type: TYPE_NORMAL
- en: '**HyperText Markup Language (HTML)**   Defines the structure of a web page.
    In other words, it defines *what is on the page*. For example, HTML can specify
    that a button exists on a web page.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cascading Style Sheets (CSS)**   Defines the appearance of a web page. In
    other words, it defines *how the page looks*. For example, CSS can specify that
    the aforementioned button is 30 pixels wide and blue.'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**   Defines the behavior of a web page. In other words, it defines
    *how the page functions*. For example, JavaScript can be used to add two numbers
    together when a button is clicked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These three languages are used together to create the content of the web. It’s
    worth noting that web browsers are also capable of rendering some other data types
    too, notably certain image, video, and audio formats, but we won’t go into those
    in detail. Let’s now dive into each of the three foundational languages of the
    web: HTML, CSS, and JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Structuring the Web with HTML***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: HTML is a markup language that describes the structure of a web page. Note that
    HTML isn’t a programming language. A programming language describes operations
    that a computer should perform, whereas a markup language describes the structure
    of data. In the case of HTML, the data in question represents a web page. A web
    page can contain various elements such as paragraphs, headings, and images. Here’s
    an example of a simple web page described in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You see a number of items enclosed in less than (`<`) and greater than (`>`)
    signs. These are known as *HTML tags*, sets of text characters used to define
    the parts of an HTML document. As an example, the tag used to indicate the start
    of a paragraph is `<p>`. A corresponding tag is used to indicate the end of a
    paragraph, `</p>`. Note the slash in the end tag, differentiating it from the
    start tag. An *HTML element* is a portion of the page beginning with a start tag,
    ending with an end tag, and including the content between the tags. For example,
    this is an HTML element: `<p>This is a cat.</p>`. In truth, not all elements require
    an end tag. For example, the `img` element, used for representing an image, needs
    no end tag. You can see this in the previous HTML code example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-5](ch12.xhtml#ch12fig5) shows how the example HTML might be rendered
    in a web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-5: Our example web page rendered in a web browser*'
  prefs: []
  type: TYPE_NORMAL
- en: The document intentionally included no information about how it should be presented,
    so a browser uses a default font and size for the heading and paragraph. In this
    example, the browser also defaulted to black text on a white background—again,
    that wasn’t specified in the document. Since this HTML example contains no style
    information, different browsers can choose to render this page slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the HTML code example more closely. The first line of an HTML
    document declares that the file is an HTML document, like so: `<!DOCTYPE html>`.
    After that, an HTML document is structured as a tree, with parent elements and
    child elements. The `<html>` tag is the top-level parent tag; everything is enclosed
    between `<html>` and `</html>`. You can interpret those two tags as “HTML starts
    here” and “HTML ends here.” This makes sense—everything in an HTML document should
    be HTML! The `<html>` tag also contains an attribute called `lang` that identifies
    the language of this document as `en`, the code for English.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `html` element has two child elements: `head` and `body`. Elements contained
    in the head (between `<head>` and `</head>`) describe the document, whereas elements
    in the body (between `<body>` and `</body>`) make up the contents of the document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the head contains two elements: a `meta` element describing
    the character set used to encode our document, and a `title`. Browsers typically
    show the title text on a page’s tab and use it as a default name when a user adds
    a bookmark or favorite. Search engines use the title text when showing results.
    For those reasons it’s important for web developers to give meaningful titles
    to their pages.'
  prefs: []
  type: TYPE_NORMAL
- en: The body in our example includes an `<h1>` tag, which is used for a heading
    element. Heading tags of `<h1>` through `<h6>` are available, with `h1` intended
    to be used as the highest level of section headings, and `h6` as the lowest level.
    A paragraph follows the heading, indicated with a `<p>` tag, and after that an
    image is included using `<img>`. Note that the bytes of the image itself aren’t
    present in the HTML. Instead, the `<img>` tag simply references an image file
    by a relative URL (*cat.jpg*). To fully load this page, a browser needs to make
    a separate HTTP request to download the image. In this example, the image URL
    is simply a filename, meaning it’s hosted on the same server and in the same path
    as the document itself. If the image were hosted elsewhere, a URL with a path
    or a server name could be used. The `<img>` tag also has an `alt` attribute, which
    provides alternate text that describes the image. This is used in cases in which
    the image cannot be rendered, such as when a text-only browser or a screen reader
    that reads the contents of the page aloud is being used.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the earlier HTML code used indentation to show the
    nesting of various elements on the page. For example, the `<h1>` and `<p>` tags
    are indented to the same level, showing that they are child elements of the `<body>`
    tag. This is a common practice in web development to improve readability of HTML,
    but it’s not required. In fact, whitespace beyond a single space or tab doesn’t
    matter in an HTML document! We could remove all the extra spaces, tabs, and line
    breaks, leaving us with the HTML all on a single line, and the document would
    render the same way in a browser. Web browsers ignore extra whitespace, so spacing
    out elements on a page is only helpful to developers.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please see [Project #38](ch12.xhtml#proj38) on [page 287](ch12.xhtml#page_287),
    where you can have your local website return a document structured with HTML rather
    than simple text*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML elements we’ve covered so far are only a small percentage of the total
    elements recognized by web browsers. We won’t exhaustively cover all of HTML here;
    it is well documented online. The specifications for HTML were previously maintained
    by two organizations: the World Wide Web Consortium (W3C) and the Web Hypertext
    Application Technology Working Group (WHATWG). The last major version of HTML
    to receive “Recommendation” status from the W3C was *HTML5*. In 2019, the two
    organizations agreed that ongoing development of the HTML standard will be handled
    principally by the WHATWG, in what is known as the *HTML Living Standard*, which
    is continually maintained.'
  prefs: []
  type: TYPE_NORMAL
- en: Modern browsers attempt to support both current and older versions of HTML,
    since plenty of web content was authored with earlier HTML standards in mind.
    In the past, browsers introduced nonstandard HTML elements, some of which eventually
    became standardized, while others fell out of use and lost support. Web browser
    developers must balance innovation with adherence to standards, while still supporting
    less-than-perfect HTML that’s sometimes found on the web. Web browsers are ever
    evolving, and different browsers sometimes render the same content differently.
    This means that web developers regularly test their creations on multiple browsers
    to ensure consistent behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '***Styling the Web with CSS***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In our earlier example HTML, we used tags that described the structure of a
    document, but those tags did not convey any information about how the document
    should be presented. This was intentional; we want to keep structure and style
    separate. A division between the two allows for the same content to be rendered
    with different styles in different contexts. For example, most web content should
    be rendered differently on a large PC screen versus a small mobile screen.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cascading Style Sheets (CSS)* is the language used to describe the style of
    a web page. A style sheet is a list of rules. Each rule describes a style that
    should be applied to a certain part of the page. Each rule includes a selector,
    which indicates what elements on the page should have the style applied. The *cascading*
    term refers to the ability for multiple rules to apply to the same element. Let’s
    look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, style rules are defined for paragraph (`p`) elements and heading
    1 (`h1`) elements. When this CSS is applied to a page, all paragraphs on that
    page use the specified font, with a size of 11 point, a left margin of 10 pixels,
    and gray text. Similarly, h1 headings use the specified bolded font with a size
    of 18 point. Note that `font-family` is a list of fonts, not just a single font.
    This means that a web browser should try to find a matching font, starting with
    the leftmost font and proceeding to the right until a font match is found. Not
    every client device has the first choice of font installed; specifying multiple
    fonts increases the chance that a matching font will be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply a style sheet to a web page in a couple of ways. One option is
    to include the CSS rules within a `style` element on the page. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn’t ideal, because the style and structure are now closely related.
    A better option is to specify the CSS rules in a separate file, also hosted on
    the web. This approach keeps our HTML and CSS completely separate, and it allows
    multiple HTML files to use the same style sheet. This way we can change a CSS
    rule, and it will apply to multiple pages at once. A single element in the HTML’s
    head section can be used to apply the style sheet rules from a CSS file, like
    so (where `style.css` is the URL of the CSS file to apply):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we apply this style sheet to our example cat page, we see these changes to
    the heading and paragraph text, as shown in [Figure 12-6](ch12.xhtml#ch12fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-6: Our example web page with CSS applied*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please see [Project #39](ch12.xhtml#proj39) on [page 288](ch12.xhtml#page_288),
    where you can update your cat web page with some CSS*.'
  prefs: []
  type: TYPE_NORMAL
- en: This CSS example is simple, but CSS allows for much more advanced styling as
    well. If you’re familiar with the amazing variety of visual styles to be found
    on the web, then you have already seen the power of CSS in action.
  prefs: []
  type: TYPE_NORMAL
- en: '***Scripting the Web with JavaScript***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The web was originally envisioned as a means of sharing information through
    hypertext documents. HTML gives us that capability, and CSS gives us a method
    of controlling the presentation of such documents. However, the web evolved into
    a platform for interactive content, and JavaScript became the standard means for
    enabling interactivity. *JavaScript* is a programming language that enables web
    pages to respond to users’ actions and programmatically perform various tasks.
    With JavaScript, a web browser becomes not just a document reader, but a full
    application development platform.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is an interpreted language; it isn’t compiled to machine code before
    it’s delivered to the browser. Web servers host JavaScript code in text format,
    and that code is downloaded by a browser and interpreted at runtime. That said,
    some browsers use a *just-in-time (JIT) compiler* that compiles JavaScript at
    runtime, leading to increased performance. Some developers *minify* their JavaScript
    before deploying it, removing whitespace, comments, and generally reducing the
    size of the script. Minifying JavaScript can improve the load time of a website.
    Minification isn’t the same as compilation; the minified file is still high-level
    code, not compiled machine code.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript has a syntax that’s similar to C and other languages that borrowed
    from C (such as C++, Java, and C#). However, the similarity is superficial, as
    JavaScript is quite different from those languages. Don’t let the name confuse
    you: JavaScript has little to do with Java. The language is object-oriented but
    fundamentally relies on *prototypes* rather than classes. That is, an existing
    object, rather than a class, acts a template for other objects.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript interacts with an HTML page using a browser-supplied representation
    of the page called the *Document Object Model (DOM)*. The DOM is a hierarchical
    tree structure of page elements, and it can be programmatically modified. An update
    to an element in the DOM causes the browser to update the element on the displayed
    web page. JavaScript includes methods for working with the DOM, and by using these
    methods, JavaScript code can both respond to events that occur on the page (such
    as the click of a button) and change the contents of the rendered page.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at part of a simple script that interacts with our example page.
    The script adds the text `Meow!` to our page’s paragraph every time the cat photo
    is clicked (or tapped on a touchscreen).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first line here adds an event handler that runs when the cat photo is clicked.
    The event handler code is defined on the next line, and it tells the browser to
    add the text `Meow!` to the paragraph. Since this is defined as an event handler,
    the code only runs when the image click event occurs. Note that the script references
    the photo and paragraph by IDs, `cat-photo` and `cat-para`, respectively. HTML
    elements can be given IDs; this allows us to easily reference them programmatically.
    Our script only works if we add these IDs to our HTML. Here is the updated HTML
    that references the script (named `cat.js`) and adds the needed IDs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once the script code is saved as *cat.js*, and the HTML is updated as shown,
    then reloading the page and clicking the cat image appends `Meow!` to our paragraph.
    If we click the image multiple times, we end up with something like what is shown
    in [Figure 12-7](ch12.xhtml#ch12fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-7: Our example web page after running JavaScript code to append
    text*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please see [Project #40](ch12.xhtml#proj40) on [page 289](ch12.xhtml#page_289),
    where you can update your web page with JavaScript*.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript can be used to build full applications that run in a web browser.
    The previous example is a just a taste of what it can do. JavaScript is standardized
    in a specification known as *ECMAScript*. Various browsers implement script engines
    that attempt to comply with all or part of the ECMAScript standard, which is updated
    regularly.
  prefs: []
  type: TYPE_NORMAL
- en: '***Structuring the Web’s Data with JSON and XML***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Websites aren’t the only type of content available on the web. A *web service*
    provides data over HTTP and is intended to be interacted with programmatically.
    This is in contrast to a website that returns HTML (and related assets) and is
    intended for user consumption via a web browser. Most end users never directly
    interact with web services, although the websites and apps we use are often underpinned
    by web services.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you run a website with information about local bands that perform
    in your city. The site contains a profile of each band, including band members,
    background, where the band will be playing, and so forth. An end user can visit
    your website and easily read up on their favorite musicians. Now, let’s say you’re
    approached by an app developer who wants to include the latest information from
    your website in their app. However, the app has its own presentation that’s totally
    different from your web pages—the developer doesn’t want to just display your
    web pages in the app. They need a way to get at the underlying data on your site.
    They could try to programmatically read your web pages and extract the relevant
    information, but this process is complicated and error-prone, particularly if
    your site’s layout changes.
  prefs: []
  type: TYPE_NORMAL
- en: You could make things much easier for this developer by providing a web service
    that presents the data from your site in a format other than HTML. Although HTML
    does provide a certain structure, it’s a structure that describes a document (headers,
    paragraphs, and so on) and provides little insight into the data types referenced
    in that document. HTML makes sense for a human reader, but it’s difficult for
    software to parse. So what format should your web service use to structure data
    about bands? The most common general-purpose data formats in use today by web
    services are XML and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '*Extensible Markup Language (XML)* has been around since the 1990s and is a
    popular means of exchanging data over the web. Like HTML, it’s a text-based markup
    language, but rather than having a set of predefined tags, XML allows for custom
    tags that describe your data. In the case of our fictitious band information service,
    we might define a `<band>` tag and a `<concert>` tag. Let’s look at an imaginary
    band described using XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the specific XML tags and their attributes are tailored to our
    needs, while the general structure of start tags, end tags, and tree hierarchy
    follows a pattern similar to HTML. The flexibility of XML, where tags can be arbitrarily
    defined, means that both the producer and the consumer of the XML need to agree
    on the expected tags and their meanings. This is true of HTML as well, but with
    HTML, all parties agree to a standard. In the case of XML, only the general format
    is standardized while the specific tags vary.
  prefs: []
  type: TYPE_NORMAL
- en: XML is a popular method for sharing data over the web, with many web services
    using XML as their primary means of representing data. However, XML is verbose
    and parsing it properly can be tricky.
  prefs: []
  type: TYPE_NORMAL
- en: '*JavaScript Object Notation (JSON)*, like XML, is a method of describing data
    in a text format. JSON avoids using markup tags and instead embraces a style that’s
    similar to JavaScript’s syntax for describing objects, hence the name. In JSON,
    objects are wrapped in curly braces (`{` and `}`) and arrays (collections of objects)
    are enclosed in brackets (`[` and `]`). Its syntax is terser than XML, which is
    helpful in reducing the size of data transmitted over a network. The popularity
    of JSON rose in the 2010s, when it began to displace XML as the preferred data
    format for new web services. Here is the same imaginary band described in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Both XML and JSON ignore extra whitespace, so just like with HTML, we can remove
    all extra spaces, tabs, and line breaks without affecting how the data is interpreted.
    Doing so produces a fairly compact rendering of data, particularly in the case
    of JSON.
  prefs: []
  type: TYPE_NORMAL
- en: XML and JSON are not formats meant for direct rendering in a web browser. Opening
    JSON or XML content in certain browsers may cause the browser to display something
    (perhaps a lightly formatted version of the data), but really JSON and XML aren’t
    intended to be directly consumed by web browsers. They are meant to be read by
    code that in turn does something useful with the data. Perhaps that code is a
    smartphone app that shows information about what bands are playing nearby, as
    in our example. Or maybe the code is client-side JavaScript that transforms JSON
    into HTML for a browser to display.
  prefs: []
  type: TYPE_NORMAL
- en: '**Web Browsers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve covered the languages used to describe the web, let’s take a
    look at software on the client side of the web, the web browser. The first web
    browser was called *WorldWideWeb* (not to be confused with the subject of this
    chapter). It was developed by Tim Berners-Lee in 1990\. This first browser was
    the client for the first web server, *CERN httpd*. In a few years WorldWideWeb
    was supplanted by *Mosaic*, a browser that helped popularize the web. The next
    major browser release was *Netscape Navigator*, which also had a large following.
    In 1995, Microsoft released their first browser, *Internet Explorer*, as a direct
    competitor to Netscape Navigator, and Internet Explorer became the dominant browser
    of its time. Today, the browser landscape has shifted dramatically, and at the
    time of this writing, the dominant browsers are *Google Chrome*, *Apple Safari*,
    and *Mozilla Firefox*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rendering a Page***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s now look at the process a web browser goes through to render a page. A
    typical visit to a website starts with a request of the default page of a site
    (such as *[http://www.example.com](http://www.example.com)/*) or a request of
    a specific page on the site (such as *[http://www.example.com/animals/cat.html](http://www.example.com/animals/cat.html)*).
    A user may enter this URL directly in the address bar, or the user could arrive
    at this URL by following a link. In either case, the browser requests the contents
    at the specified URL. Assuming the URL is valid and represents a web page, the
    server responds with HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The web browser must then take the returned HTML and generate a DOM representation
    of the page. The HTML may contain references to other resources, like images,
    scripts, and style sheets. Each of these resources has its own URL, and the browser
    makes separate requests for each resource, as illustrated in [Figure 12-8](ch12.xhtml#ch12fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-8: A web browser requests a page and its referenced content*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the browser has retrieved the various resources of the page, it displays
    the HTML, using any specified CSS to determine the appropriate presentation. Any
    scripts are handed off to a JavaScript engine to run. JavaScript code may immediately
    make changes to the page, or it may register event handlers that run later when
    certain events occur. JavaScript code may also request data from a web service
    and use that data to update the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web browsers consist of a rendering engine (for HTML and CSS), a JavaScript
    engine, and a user interface that ties things together. Although the user interface
    provides the look and feel of the browser itself (such as the appearance of the
    back button and address bar), it’s the rendering engine and JavaScript engine
    that determine how websites are presented and behave (this includes things like
    how the page is laid out and how it responds to input). Since each rendering engine
    and JavaScript engine handle things slightly differently, a web page may look
    or act differently when viewed on different browsers. Ideally, all browsers would
    render content the same way, exactly as the site developer intended, but that’s
    not always the case. At the time of this writing, only three major rendering engines
    are in active development: WebKit, Blink, and Gecko.'
  prefs: []
  type: TYPE_NORMAL
- en: '*WebKit* is the rendering engine and JavaScript engine for Apple’s Safari browser.
    It’s also used in applications found in the iOS App Store, since Apple requires
    all iOS apps that display web content to use this engine. *Blink*, which is a
    fork of WebKit, is the rendering engine for the *Chromium* open source project,
    which also includes the *V8* JavaScript engine. Chromium is the basis for Google
    Chrome and Opera. In December 2018, Microsoft announced that the *Microsoft Edge*
    browser would also be Chromium-based; Microsoft chose to halt development of its
    own rendering and JavaScript engines. That leaves only one major browser that
    doesn’t trace its roots to WebKit—Mozilla Firefox, which has its own *Gecko* rendering
    engine and *SpiderMonkey* JavaScript engine.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A software fork occurs when developers make a copy of a project’s source code
    and then make changes to that copy. This allows the original and forked projects
    to coexist as separate software*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The User Agent String***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The formal, technical term for a web browser is a *user agent*. This term can
    be applied to other software as well (anything that acts on behalf of a user),
    but here we’re talking specifically about web browsers. This term pops up in technical
    documentation about the web, although it’s rarely used outside of formal communication.
    That said, one place where the term is used in practice is the *user agent string*.
    When a browser makes a request to a web server, it commonly includes a header
    value called `User-Agent` that describes the browser. As an example, here is the
    user agent string sent by Chrome (version 71) on Windows 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This may seem contradictory. What does all this mean?
  prefs: []
  type: TYPE_NORMAL
- en: The first entry, `Mozilla/5.0`, is a holdover from the early days of the web.
    Mozilla was the user agent name for Netscape Navigator, and many sites specifically
    looked for “Mozilla” in the user agent string as an indicator to send the cutting-edge
    version of their website to the browser. At the time, other browsers wanted to
    get the best versions of websites too, so they identified themselves as Mozilla,
    even though they weren’t Mozilla at all. Fast forward to today, when essentially
    *every* browser identifies itself as Mozilla, and we find that portion of the
    user agent string fairly meaningless.
  prefs: []
  type: TYPE_NORMAL
- en: The next section in parentheses, `(Windows NT 10.0; Win64; x64)`, specifies
    the platform on which the browser is running.
  prefs: []
  type: TYPE_NORMAL
- en: Following that is the rendering engine, `AppleWebKit/537.36` in this case. As
    mentioned earlier, Chrome’s Blink engine is a fork of WebKit and still identifies
    itself as such. The following text, `(KHTML, like Gecko)`, is just a further elaboration
    on this; KHTML is a legacy engine that WebKit was based on.
  prefs: []
  type: TYPE_NORMAL
- en: Now we get to the actual browser name and version, `Chrome/71.0.3578.98`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have an awkward mention of Apple’s browser `Safari/537.36`, included
    for sites that give Safari special treatment. By including this text, Chrome attempts
    to ensure that those sites send it the same content that Safari would receive.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a rather complicated way to identify Chrome, but other browsers do the
    same kind of thing to ensure compatibility with all manner of websites. This complexity
    is an unfortunate side effect of historically fragmented capabilities in different
    browsers and websites that tried to send tailored versions of their content based
    on the particular browser. Browsers evolved so that today there is less variation
    in browser capabilities. However, many websites didn’t evolve and still send content
    tailored for specific browsers, forcing modern browsers to continue to trick old
    sites into believing they are communicating with a different browser.
  prefs: []
  type: TYPE_NORMAL
- en: '**Web Servers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve focused primarily on the technologies used on the client side
    of the web. Web browsers speak a common trio of languages: HTML, CSS, and JavaScript.
    What about on the web’s server side? What languages and technologies are used
    to power web servers? In short, any programming language or technology can be
    used on a web server, as long as that technology can communicate over HTTP and
    return data in a format that the client understands.'
  prefs: []
  type: TYPE_NORMAL
- en: Broadly speaking, websites are designed as either static or dynamic. A *static
    website* returns HTML, CSS, or JavaScript that was built ahead of time. Typically,
    the content of the site is stored in files on the server, and the server simply
    returns the contents of those files without modification. This means that any
    required runtime processing must be implemented in JavaScript that runs in the
    browser. On the other hand, a *dynamic website* performs processing on the server,
    generating HTML when a request comes in.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of the web, nearly everything was static. Pages were simple
    HTML, and there was little interactivity. As time went on, developers began adding
    code that ran on the web server, allowing the server to return dynamic content
    or accept a file upload or form submission from a user. This trend continued,
    and it became commonplace for requests to go through server-side processing before
    the server would respond.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how server-side processing on a dynamic website typically works,
    as illustrated in [Figure 12-9](ch12.xhtml#ch12fig9). Assume that the dynamic
    website represented in [Figure 12-9](ch12.xhtml#ch12fig9) is a blog. A browser
    makes a request for a blog post. When the web server receives the request for
    the blog post, it reads the requested URL and determines that it needs to generate
    HTML. Code on the server then queries a database (which may be on the web server
    or on another server), retrieves the relevant blog text data, formats that text
    as HTML, and then responds to the client with that HTML. This approach is useful
    because it allows the content of a site to be managed separately from the website’s
    code, but dynamic sites also have some drawbacks. The increased complexity on
    the server means more work to set things up, a slower response at runtime, a potentially
    heavy load on the server, and an increased risk of security problems.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-9: A typical dynamic website handles a request*'
  prefs: []
  type: TYPE_NORMAL
- en: Recently, there has been a trend to move back to static sites where possible.
    The flow of a page request on a static site is shown in [Figure 12-10](ch12.xhtml#ch12fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-10: A static website handles a request*'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 12-10](ch12.xhtml#ch12fig10), the static website’s server-side
    processing is simplified, as compared to the dynamic site. The server-side processing
    on a static site is simply a matter of returning the static file that matches
    the requested URL. The content has already been built; the server does not need
    to retrieve raw data and format it. Reducing the complexity on the server side
    generally means simpler, faster, and more secure sites.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that in this context, the terms *static* and *dynamic*
    are from the server’s perspective, not the user’s. A static site’s content comes
    unchanged from files on the server, whereas a dynamic site’s content is generated
    on the server. The terms aren’t a description of how a user experiences the site,
    such as whether the site is interactive or if content is automatically updated.
    These experiences can be achieved using JavaScript in the browser, sometimes in
    conjunction with a separate web service, regardless of whether the website itself
    is static or dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re hosting a static site, all you need is web server software that can
    respond to requests for your static files and serve the contents of those files.
    No custom code required. Many software packages and online services are available
    for hosting static sites. Typically, the software for serving a static site is
    configured to point to a directory of files on the server, and when a request
    comes in for a certain file, the server simply returns the contents of that file.
    For example, if the files for the website at *example.com* reside in a directory
    on the server called */websites/example*, then a request for *[http://example.com/images/cat.jpg](http://example.com/images/cat.jpg)*
    maps to */websites/example/images/cat.jpg*. The web server simply reads the matching
    file from its local directory and returns the bytes contained in that file to
    the client. The website developed in Projects #37 through #40 is an example of
    a static site.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re building a dynamic website or web service, either you can use existing
    software that manages your content and serves up dynamic pages, or you can write
    your own custom code that generates web content. Assuming you’re writing custom
    code, you’ll find things are quite different on the server side as compared to
    the client side of web development. Any programming language, any operating system,
    any platform can be used for a web server. Anything goes, as long as the web server
    responds over HTTP and returns data in a format that the client understands! The
    client doesn’t care what technologies were used to generate HTML or JavaScript;
    it just needs a response in a format it can handle.
  prefs: []
  type: TYPE_NORMAL
- en: Since it doesn’t really matter to clients what technology is used on the web
    server side, many options are available to developers who wish to write code that
    runs on the server. Client-side web development is limited to the trio of HTML,
    CSS, and JavaScript, whereas server-side web development can take place in Python,
    C#, JavaScript, Java, Ruby, PHP, and more. Server-side web development often includes
    interfacing with a database of some kind. In the same way that any programming
    language can be used on the server, any kind of database can be used for server-side
    web development.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter we covered the web—a set of distributed, addressable, linked
    resources, delivered by HTTP over the internet. You learned how web pages are
    structured with HTML, styled with CSS, and scripted with JavaScript. We looked
    at web browsers, which are used to access content on the web, and we examined
    web servers—the software that hosts web resources. In the next chapter, we’ll
    look at some trends in modern computing, and you’ll have a chance to complete
    a final project that ties together various concepts found throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #36: EXAMINE HTTP TRAFFIC**'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll use Google Chrome or Chromium to examine HTTP traffic
    between a web browser and a web server. You can either use Chrome on a Windows
    PC or a Mac, or use the Chromium web browser on your Raspberry Pi. The following
    steps assume you’re using a Raspberry Pi, but the process is similar on a Windows
    PC or a Mac; just use Chrome instead of Chromium.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren’t using the graphical desktop on your Raspberry Pi, switch to it
    now. Unlike previous projects, this project cannot be completed from a terminal
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Raspberry** (icon in the upper left corner)▶ **Internet**▶ **Chromium
    Web Browser**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to a website, such as *[http://www.example.com](http://www.example.com)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the F12 key (or CTRL-SHIFT-I) to open the developer tools (DevTools),
    shown in [Figure 12-11](ch12.xhtml#ch12fig11).![image](../images/fig12-11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 12-11: Developer tools in Chromium*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the DevTools menu, choose the **Network** menu item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press F5 (or hit the reload icon) to reload the page. You’ll see the HTTP requests
    that are made to load the page you’re currently visiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you actually use *www.example.com* you’ll likely see a fairly boring request.
    If you want to see something more interesting, visit a more complicated site and
    watch the network requests, as shown in [Figure 12-12](ch12.xhtml#ch12fig12).![image](../images/fig12-12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 12-12: Example of HTTP traffic for a website shown in Chromium’s DevTools*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each line represents a request to the web server. You can see the resource name
    that was requested, the status of the request (`200` means success), and more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can click each line and see the specifics of the request, such as the headers
    and the content returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I recommend you try this on several websites to get a feel for the number of
    requests made for a site. You may be surprised at how much content is transferred!  **PROJECT
    #37: RUN YOUR OWN WEB SERVER**'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll set up a Raspberry Pi to act as a web server. You’ll
    use Python 3 to do this, so you can actually follow these steps on any device
    with Python 3 installed, although the steps here were written with the Raspberry
    Pi in mind. Our simple website will return the contents of a file when it receives
    a request.
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal window and create a directory that will hold the files your
    website will serve, and then set that new directory as your current directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When a request is made to the root of your website, the web server software
    looks for a file named *index.html* and returns the contents of that file to the
    client. Let’s create a very simple *index.html* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That command creates a text file named *index.html* with the text `Hello, Web!`
    in the file. You can view the contents of the text file to ensure it was created
    successfully by opening the file in a text editor, or you can display the contents
    in the terminal like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once your file is in place, let’s use Python’s built-in web server to serve
    up your `Hello, Web!` message to anyone who connects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This command tells Python to run an HTTP server on port `8888`. Let’s test
    this out to see if it’s working as expected. Open another terminal window on your
    Raspberry Pi. From this second terminal window, enter the following command to
    make a `GET` request to the root of your new website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `curl` utility can be used to make HTTP `GET` requests, and `localhost`
    is a hostname that refers to the computer you’re currently using. This command
    tells the `curl` utility to perform an HTTP `GET` to port `8888` on the local
    computer. You should see the text `Hello, Web!` returned. Also, back in the original
    terminal, you should see that a `GET` request came in.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s try connecting to your website from a web browser. From the Raspberry
    Pi desktop, open the Chromium web browser. In the address bar, enter http://localhost:8888.
    You should see the text from your website appear in the browser, as shown in [Figure
    12-13](ch12.xhtml#ch12fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig12-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-13: Connecting to a local web server using the Chromium browser*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try connecting to your website from another device. For this to work, the
    second device has to be on the same network as your Raspberry Pi. For example,
    they should both be on the same Wi-Fi network. Or, if your Raspberry Pi has a
    public IP address (see [Project #34](ch11.xhtml#proj34) on [page 259](ch11.xhtml#page_259)),
    then your website is available to any device on the internet! First, get your
    Raspberry Pi’s IP address by running the following command in the second terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This likely returns several IP addresses. You can’t use `127.0.0.1` when connecting
    from a remote device, so choose another IP address assigned to your Raspberry
    Pi. Once you have the IP address, open a browser on another device. This can be
    a smartphone, laptop, or really any device on your network that has a web browser.
    In the browser window, enter the following in the address bar: *`http://w.x.y.z:8888`*
    (replacing *`w.x.y.z`* with the IP address of your device). Press ENTER or the
    appropriate button in the browser to navigate to that address. You should see
    `Hello, Web!` appear in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: If this didn’t work for you, and your Raspberry Pi does not have a public IP
    address, make sure the two devices are on the same physical local network. Also,
    sometimes the Python web server becomes unresponsive to new requests. If the web
    server stops responding, you can restart it. To stop the web server, go to the
    terminal where the server command was executed, and press CTRL-C on the keyboard.
    Then restart the server by running the python3 -m http.server 8888 command again
    (press the keyboard up arrow to get the last command).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your site working, try editing the *index.html* file and change
    the message to say whatever you want. You can use the text editor of your choice
    to do this. Once your *index.html* file is updated, reload the web page in a web
    browser to see your changes!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want other devices to be able to access your website, you can
    restrict things so that only requests from the Raspberry Pi itself get a response.
    Running the Python web server with the `--bind` option can accomplish this, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To run the web server with the `--bind` option, you first need to stop any running
    instance of the web server (press CTRL-C on the keyboard).
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #38: RETURN HTML FROM YOUR WEB SERVER**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prerequisite: [Project #37](ch12.xhtml#proj37).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you’ll update your local web server to return HTML instead
    of simple text. Use the text editor of your choice to open *index.html* (that
    was created in [Project #37](ch12.xhtml#proj37)) and replace all the text in the
    file with the following HTML. This is the same HTML code that was discussed in
    the chapter. You don’t need to worry about the indentation of each line, since
    extra whitespace in HTML doesn’t matter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once your file has been updated, you’ll use Python’s built-in web server again.
    If it isn’t already running, start it with this command. Just be sure that your
    terminal window is currently in the *web* directory before running the command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use a web browser to connect to your web server as you did in [Project
    #37](ch12.xhtml#proj37). You should see the page rendered, but without the cat
    photo. If you look at the terminal window where you ran the Python web server
    command, you should see an attempt to get the cat photo that failed, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `404` error code indicates that the resource can’t be found, which makes
    sense given that you don’t have a file named *cat.jpg* in this directory! Why
    did the web browser even ask for a cat photo? If you look back at the HTML for
    the page, you see an HTML `<img>` tag that directs the browser to render the `cat.jpg`
    image. The browser requests the image, but it fails to retrieve it since the file
    is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s fix the missing cat image issue. You need to download an image of a cat
    (or an image of anything really) in JPEG format and save it as *~/web/cat.jpg*.
    To make this easy, you can download the image used in the chapter with the following
    command. Be sure that your terminal window is currently in the *web* directory
    before running the command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have *cat.jpg* stored in your *web* directory. Reload the page
    in a web browser to see the cat image in the page. Reminder: if the web server
    seems stuck, restart it as described in [Project #37](ch12.xhtml#proj37).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth noting that not only can you view the cat image in your page, but
    you can also request the image directly from the server, since it has its own
    URL. Try pointing your browser to the following URL (replacing *`SERVER`* with
    the hostname or IP address you’ve been using for your website): `http://*SERVER*:8888/cat.jpg`.
    You should see the cat image rendered in the browser, outside of the web page.
    Every resource referenced on a web page has its own URL and can be accessed directly!'
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #39: ADD CSS TO YOUR WEBSITE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prerequisite: [Project #38](ch12.xhtml#proj38).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you’ll use CSS to style your website. First, use the text
    editor of your choice to create a file named *style.css* in the *web* directory.
    This file will contain your CSS rules. Be sure the file is named *style.css* and
    is saved to the *web* directory alongside your *index.html* and *cat.jpg* files.
    The contents of *style.css* should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once *style.css* has been created, open *index.html* for editing, as you did
    in the previous project. Leave the existing HTML in place. We just want to add
    a single line to the head section, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve made this update ❶ to *index.html*, start your web server (if it
    isn’t already running), and reload the page in your web browser. You should see
    the style of the page update. Reminder: if the web server seems stuck, restart
    it as described in [Project #37](ch12.xhtml#proj37).'
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to edit *style.css* to try different styles. Maybe you want to make
    the paragraph font huge or a different color! Edit the style to your liking, save
    *style.css*, and reload the page in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren’t seeing your updates reflected in the browser, it may be because
    your web browser is loading a cached copy of your website rather than downloading
    the latest version. Try opening the page in a new tab or restarting the browser
    altogether. You can also tell your browser to bypass its local cache when reloading.
    To do this, navigate to the page, and then press CTRL-F5 to force the page to
    reload. This works on most browsers on Windows and Linux. On a Mac, you can force
    a refresh in Chrome and Firefox with CMD-SHIFT-R. Sometimes multiple refreshes
    are needed before the browser renders the latest content.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #40: ADD JAVASCRIPT TO YOUR WEBSITE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prerequisite: [Project #39](ch12.xhtml#proj39).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you’ll use JavaScript to make your website interactive. First,
    use the text editor of your choice to create a file named *cat.js* in the *web*
    directory. This file will contain JavaScript code. Be sure the file is named *cat.js*
    and is saved to the *web* directory alongside your *index.html* and *cat.jpg*
    files. The contents of *cat.js* should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once *cat.js* has been saved, open *index.html* for editing, as you did in
    the previous project. Leave the existing HTML in place and make the changes shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These changes reference the script ❶ and give IDs to the paragraph ❷ and image
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve made this update to *index.html*, start your web server (if it
    isn’t already running), and reload the page in a web browser. You should now be
    able to click (or touch) the cat photo and see the word `Meow!` appended to the
    paragraph. Reminder: if the web server seems stuck, restart it as described in
    [Project #37](ch12.xhtml#proj37).'
  prefs: []
  type: TYPE_NORMAL
