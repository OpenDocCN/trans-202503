- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">NEO-NAZIS
    AND THEIR CHATROOMS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: In early August 2017, hundreds of white supremacists assembled in the city of
    Charlottesville, Virginia, for the Unite the Right rally. The protesters—hailing
    from groups like Vanguard America, Identity Evropa, League of the South, and the
    Ku Klux Klan—flew Nazi and Confederate battle flags, wore red “Make America Great
    Again” hats, and chanted slogans like “Jews will not replace us!”
  prefs: []
  type: TYPE_NORMAL
- en: On August 12, James Alex Fields Jr., described by his high school history teacher
    as “deeply into Adolf Hitler and white supremacy,” drove a car into a group of
    counterprotesters, murdering 32-year-old Heather Heyer and injuring 19 other people.
    Earlier in the event, Fields was seen marching with a Vanguard America shield.
    That same day, a group of six white men followed 20-year-old Black special ed
    assistant teacher DeAndre Harris into a parking garage and beat him with poles
    and metal pipes, an attack that was caught on film and posted to the internet.
    In response to the racist violence, Trump famously said that there were “very
    fine people on both sides.”
  prefs: []
  type: TYPE_NORMAL
- en: The Unite the Right rally, like much of the American fascist movement’s activism
    during the 2017–2021 Trump presidency, was largely organized online using Discord,
    a group chat platform designed for gamers. In Discord, users join *servers*, a
    group of chatrooms, or a *channel*, a single chatroom. Each channel covers different
    topics. Fascists created Discord servers for their regional hate groups, as well
    as for projects like organizing Unite the Right.
  prefs: []
  type: TYPE_NORMAL
- en: An antifascist infiltrator gained access to the server used to organize Unite
    the Right, called Charlottesville 2.0, as well as many other servers used by fascists
    at the time. They then leaked the chat logs to Chris Schiano and Dan Feidt, journalists
    working with the independent nonprofit news collective Unicorn Riot. The leak
    took the form of screenshots from the Discord app, large JSON files containing
    thousands of messages, and audio recordings from voice meetings.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I describe how the JSON chat log files were structured and
    how I went about analyzing them, using techniques covered in [Chapter 11](chapter11.xhtml).
    I’ll describe the custom app that I wrote to investigate this dataset and explain
    how I used it to investigate a Discord server called Pony Power, whose members
    doxed their political enemies. You’ll also learn the inside story of DiscordLeaks,
    Unicorn Riot’s public searchable archive based on my app, which contains millions
    of chat messages from far-right Discord servers. Finally, I discuss a major hack
    of the American neo-Nazi organization Patriot Front that took place four and a
    half years after the Charlottesville rally. This hack included chat logs from
    RocketChat, a self-hosted system that Unicorn Riot also hosts in DiscordLeaks.
  prefs: []
  type: TYPE_NORMAL
- en: Like my reporting on the AFLDS dataset, this case study is an example of journalism
    with real-world impact. My work, along with that of Unicorn Riot, antifascist
    infiltrators, and other anonymous developers, helped lead to a court settlement
    against the most notorious American white supremacist leaders and organizations,
    resulting in over $25 million worth of damages. I hope that this case study will
    inspire your own work on datasets of structured chat logs, should you obtain them
    in the future. With the rise of remote work and the increasing popularity of chat
    platforms like Discord, Slack, and RocketChat, this type of leak is only getting
    more common.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start with a brief description of how these chat logs were leaked.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Antifascists Infiltrated Neo-Nazi
    Discord Servers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unicorn Riot reporters covered the Unite the Right gathering on the ground in
    Charlottesville. In the following days, the collective announced that it had received
    anonymously leaked chat logs from the far-right groups that took part in the rally,
    and particularly from the Charlottesville 2.0 Discord server. It began publishing
    articles based on these leaks, showing evidence of premeditated plans for violence,
    memes about hitting protesters with cars, and posts made after the event celebrating
    Heather Heyer’s murder. It also published ZIP files containing thousands of screenshots
    from the infiltrated Discord servers. Researchers, both amateur and professional,
    immediately began correlating breadcrumbs from these chat logs with photos and
    videos of the event that were posted to social media to identify specific fascist
    activists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alongside Charlottesville 2.0, other leaked fascist Discord servers had names
    like Vibrant Diversity, Ethnoserver, Safe Space 3, and 4th Reich. Some servers
    only had a few dozen users, while others had over a thousand. The most active
    server at the time, Vibrant Diversity, included a channel called #problematic_oven,
    where users shared racist memes. The 4th Reich server included a #rare_hitlers
    channel, where users shared vintage propaganda from Nazi Germany.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the reporting of Unicorn Riot and others had made it clear to Discord that
    Nazis were relying on its service, the chat platform shut down many far-right
    chat servers and accounts. “Discord’s mission is to bring people together around
    gaming. We’re about positivity and inclusivity. Not hate. Not violence,” the company
    said in a statement. “We will continue to take action against white supremacy,
    nazi ideology, and all forms of hate.” Shutting down individual servers and accounts
    didn’t work, though; fascists simply created new accounts and set up new chat
    servers. Just as quickly, antifascists infiltrated those new servers and continued
    to leak chat logs to Unicorn Riot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fascists started spreading conspiracy theories that there were no infiltrators
    but that Discord itself was selling their chat logs to the Southern Poverty Law
    Center, a nonprofit that monitors hate groups. “The Charlottesville planning server
    was leaked, even though it was highly secure and no one could figure out who could
    have leaked it,” Andrew Anglin, founder of the notorious neo-Nazi website the
    Daily Stormer, wrote in an April 2018 blog post. “Since then, servers have been
    repeatedly leaked. People have been doxed without being able to figure out how
    they were doxed. Repeatedly and consistently, I have been given reason to believe
    that these are not Discord ‘leaks,’ but data being bought by our enemies.” This
    wasn’t true, of course. Anglin provided no evidence for the claim, Discord’s privacy
    policy promises that it doesn’t sell user data, and we know exactly how the data
    was leaked: antifascists were invited into the group by pretending to be racists.'
  prefs: []
  type: TYPE_NORMAL
- en: A few weeks after Unite the Right, I got a hold of some of these chat logs myself
    and began to analyze them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Analyzing Leaked Chat Logs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In late August of 2017, after Unicorn Riot had started publishing articles based
    on leaked chats, someone from the collective asked me if I’d like to cover the
    fascist chat logs for The Intercept. While journalism can be competitive, with
    each newsroom racing to publish breaking news first without getting scooped, the
    opposite is often true when it comes to complicated datasets. When it’s clear
    that there’s no way that a single newsroom has the resources to discover all of
    the revelations in a dataset, it only makes sense to bring in other newsrooms
    and share access to the data. This sort of collaboration helps everyone because
    different newsrooms have different audiences, and it makes real-world impact from
    the reporting more likely.
  prefs: []
  type: TYPE_NORMAL
- en: My Unicorn Riot contact sent me a ZIP file full of JSON files and screenshots
    of Discord chats that covered several Discord servers. The JSON files contained
    more complete logs of everything posted to these chatrooms, while the screenshots
    captured only specific conversations. While screenshots are initially simpler
    to use because you don’t need to write any code or use special tools to read them,
    having the chat logs in a structured data format like JSON is much more useful
    in the long run. The best way to peruse screenshots of chats is to open individual
    images, read them one at a time, take note of the filenames that contain interesting
    content, and refer back to them as needed. This quickly becomes unwieldy when
    you’re dealing with thousands of screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: I started digging into the JSON files to see what I was dealing with. Specifically,
    I used the handy command line tool <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    to figure out exactly how this data was structured in order to find the lists
    of users and channels and read the messages in each channel.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Besides manually reading screenshots and taking notes, another option would
    have been to index the screenshots in software like Aleph, which you used in [Chapter
    5](chapter5.xhtml). Aleph would then perform OCR on the images, extracting their
    text and enabling me to search them for keywords. This might be helpful in locating
    specific messages, but in the end, it’s still not as useful as structured data.
    If I were dealing with this data today and only had screenshots without access
    to JSON data, I would definitely rely on Aleph.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making JSON Files
    Readable</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each JSON file within the ZIP file sent by my source contained the entire archive
    of chat logs from a given Discord server. For example, one 29MB JSON file was
    called *VibrantDiversityComplete-Sept5at327PM*. For the purposes of this book,
    I’ve renamed it *VibrantDiversity.json* to make the following examples easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I opened this file in a text editor, its contents looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This block of data is not very human-readable. As you learned in [Chapter 11](chapter11.xhtml),
    it’s much easier to read JSON data that’s been reformatted using line breaks,
    indentation, and syntax highlighting. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    command, I formatted it and added syntax highlighting in my terminal like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Running this command added formatting and syntax highlighting to the file’s
    contents, but still resulted in 29MB of text madly scrolling through my terminal.
    To understand the data better, I needed to run more specific commands that would
    reveal its overall structure.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring Objects,
    Keys, and Values with jq</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I could tell by looking at the beginning of the JSON data that the whole file
    was one large JSON object, and one of that object’s keys was <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>.
    I ran the following <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> command
    to see what other keys there were:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output told me that the data for each Discord server includes two parts,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Guessing that <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> included
    the metadata for the server, I ran the following command to determine the keys
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command piped the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">cat
    VibrantDiversity.json</samp> as input into the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq
    '.meta | keys'</samp> command. It looks like there’s a second pipe there, but
    there’s not. The string <samp class="SANS_TheSansMonoCd_W5Regular_11">'.meta |
    keys'</samp> is actually just a single argument into <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>.
    The pipe character is how you chain multiple <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    filters together so that the output of one gets piped into the output of the next;
    in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta</samp> outputs
    the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> key
    and pipes it into <samp class="SANS_TheSansMonoCd_W5Regular_11">keys</samp>, which
    outputs the keys from that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output showed me that the metadata included information about channels,
    servers, and users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, I had only looked at the keys of JSON objects. It was time to look
    at some of the content, starting with the servers. By running <samp class="SANS_TheSansMonoCd_W5Regular_11">jq
    ''.meta .servers''</samp>, I could look at the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>
    key inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The output in [Listing 14-1](#list14-1) showed that *VibrantDiversity.json*
    lists a single server in the metadata sections, Vibrant Diversity, just as I expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: The list of servers
    in</samp> <samp class="SANS_Futura_Std_Book_11">VibrantDiversity.json</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: I could tell that this output was an array, since it was a list of items surrounded
    by brackets ([and]).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I wanted to see what channels this server had, so I ran the following
    command to view the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>
    key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 14-2](#list14-2) shows the output of this command.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: The list of channels
    in the Vibrant Diversity server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Whereas the output in [Listing 14-1](#list14-1) was an array, the output for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.channels</samp> was a JSON
    object, as indicated by the braces (<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and})
    surrounding it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys for this object are long numbers, presumably the ID of the channel,
    and their values are objects that contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> keys. For example,
    the channel with key <samp class="SANS_TheSansMonoCd_W5Regular_11">288508006990348299</samp>
    has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">{"server": 0, "name":
    "problematic_oven"}</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>
    value for all of these channels is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    I guessed that this was the index of the servers array from [Listing 14-1](#list14-1).
    Since there was only one server in this JSON file, the index for all of the channels
    is the first item in the list, <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> value was <samp
    class="SANS_TheSansMonoCd_W5Regular_11">problematic_oven</samp>. When I later
    read the chats in this channel, it was full of antisemitic posts and Nazi memes,
    and the word *oven* was clearly a reference to the Holocaust. This was definitely
    a neo-Nazi chat server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I wanted to see a list of this server’s users, so I ran the following command
    to view the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp>
    key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp> object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 14-3](#list14-3) shows my output.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-3: The list of users
    in the Vibrant Diversity server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Just like the list of channels in [Listing 14-2](#list14-2), the output for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.users</samp> in [Listing 14-3](#list14-3)
    is a JSON object. The keys are long numbers, presumably the ID of the user, and
    the values are objects with just a single key, the user’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, I had explored the metadata keys <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp>,
    but there was one left: the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    key. I ran the following command to view the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    key’s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 14-4](#list14-4) shows my output.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-4: The list of user
    IDs for each user in the Vibrant Diversity server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The output for the <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userlist</samp>
    command was a JSON array rather than an object, and each item in the array was
    a string that looks like a Discord ID. Sure enough, the first item, <samp class="SANS_TheSansMonoCd_W5Regular_11">231148326249037824</samp>,
    turned out to be the ID of the first user from [Listing 14-3](#list14-3), D’Marcus
    Liebowitz. At this point I didn’t fully understand the purpose of <samp class="SANS_TheSansMonoCd_W5Regular_11">userlist</samp>,
    but it soon became clear, as you’ll see later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with a basic understanding of the server’s metadata, I ran the following
    command to find the keys for the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 14-5](#list14-5) shows my output.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-5: The keys to the
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">data</samp> object in the
    Vibrant Diversity server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'These keys are the same channel IDs from [Listing 14-2](#list14-2), so I guessed
    that the values of each key contained the actual messages in those chat channels.
    Because I needed to start somewhere, I decided to view the chat messages from
    the #problematic_oven channel, so I ran the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The full argument for this <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    command is surrounded by single quotes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp>
    part of the filter looks in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>,
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">."288508006990348299"</samp>
    part of the filter looks in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">288508006990348299</samp>,
    which is the ID of the #problematic_oven channel. I put the ID in quotes so that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> would know that this key
    was a string and not a number.'
  prefs: []
  type: TYPE_NORMAL
- en: As with the first time I used <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    to read this JSON file, the output of this command scrolled through a large block
    of text, though considerably less than before. In this case, the output showed
    chat messages from only a single channel, rather than showing all of the data
    in the JSON file. [Listing 14-6](#list14-6) shows just a few chat messages from
    the middle of the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-6: Chat messages
    from the #problematic_oven channel in the Vibrant Diversity server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Just like the channels in [Listing 14-2](#list14-2), this output is a JSON object
    with keys that contain long numbers. In this case, these keys appeared to be message
    IDs, and the values appeared to be details about that specific chat message. In
    each message, the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> field
    represented the user and the <samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp>
    field contained the message content. The <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp>
    field was a Unix timestamp, the number of seconds or sometimes milliseconds since
    January 1, 1970, a common way to represent specific dates and times in computer
    science. These particular timestamps were in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I knew that I was looking at a conversation between two neo-Nazis.
    The top two messages in [Listing 14-6](#list14-6) are from a user with the ID
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, and the bottom two
    messages are from a user with the ID of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Because the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">t</samp> gets
    bigger with each message, these appear to be displayed in chronological order.
    I decided to take a closer look at the message <samp class="SANS_TheSansMonoCd_W5Regular_11">352992512752746496</samp>,
    from user <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, with the timestamp
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1504230373324</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Timestamps</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unix timestamps are a useful way for computers to store an entire date—the year,
    month, day, and time of day—in a single number. I needed to convert the timestamp
    associated with that message into human-readable format to find out the date and
    time when the message was posted.
  prefs: []
  type: TYPE_NORMAL
- en: 'I used the following lines of code in the Python interpreter to convert the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1504230373324</samp> timestamp into
    a more human-readable Python <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The syntax in this code is similar to the code you used to import modules in
    [Chapter 8](chapter8.xhtml). Rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">module</samp>, this code
    takes the syntax <samp class="SANS_TheSansMonoCd_W5Regular_11">from</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">module</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">resource_name</samp>, loading
    a single <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> resource
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp> module.
    Next, the code defines a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">timestamp</samp>
    and sets its value to the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime.fromtimestamp()</samp>
    function. This function takes the number of seconds since January 1, 1970, as
    an argument. Because the Discord logs are in milliseconds rather than seconds,
    this code first divides the Discord timestamp by 1,000 to convert it to seconds
    before passing it into the function. The function returns a Python <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I displayed the <samp class="SANS_TheSansMonoCd_W5Regular_11">datetime</samp>
    object with <samp class="SANS_TheSansMonoCd_W5Regular_11">print(timestamp)</samp>,
    I could see that this chat message was posted on August 31, 2017, at 6:46 PM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I now had an idea of the timeframe in which this chat exchange took place. Next,
    I wanted to see which users were involved.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Usernames</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I wanted to find the username for person who’d posted the <samp class="SANS_TheSansMonoCd_W5Regular_11">352992512752746496</samp>
    message in [Listing 14-6](#list14-6). The <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    value for this message was <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>,
    so I checked to see if <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
    was a valid user ID from the output in [Listing 14-3](#list14-3) but found that
    it wasn’t there; all of the user IDs in that JSON object are 18 digits long. I
    turned to the output in [Listing 14-4](#list14-4) that shows the value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    object. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    is an array of strings, each an 18-digit user ID.
  prefs: []
  type: TYPE_NORMAL
- en: As described in [Chapter 11](chapter11.xhtml), JSON arrays are lists of items
    in a specific order. Objects, on the other hand, don’t have any order. You select
    values from arrays using their numerical indices, starting from index 0 for the
    first item. Because objects don’t have numerical indices, there’s no concept of
    the first, second, or third item in the object; you could edit a JSON file to
    rearrange the object’s items, and it would still be the same object. For this
    reason, I guessed that the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    value was actually an index of the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine which user ID corresponded to the user whose <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    value was <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, I looked for
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp> at
    index <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is similar to the one in [Listing 14-4](#list14-4), but because
    it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userindex[4]</samp>,
    it selects the value at index <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">.meta.userindex</samp> array
    and just displays that result. My output showed that this value was the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp>, an 18-digit
    user ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that I had a user ID, I used it in the following command to find the matching
    username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the previous command, this command selects just one value to output. In
    this case, it selects the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    key, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp> key,
    then the <samp class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp>
    key. The result is an object that includes a <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The name *badtanman* was the username I was looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the chat logs quoted in [Listing 14-6](#list14-6), the user *badtanman*
    is talking to someone with the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp>
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. To find that
    person’s username, I ran the same commands, substituting the appropriate ID numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: I’d found that the snippet of chat messages in [Listing 14-6](#list14-6) was
    a conversation between *badtanman* and *northern_confederate* on the night of
    August 31, 2017.
  prefs: []
  type: TYPE_NORMAL
- en: Running all of these <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    commands, along with running code in the Python interpreter to convert timestamps,
    is tedious. If confronted with a large volume of chat logs, you don’t want to
    research every group of messages this way. But when you’re exploring an unfamiliar
    dataset for the first time, you need to manually explore it like this until you
    better understand how the data is structured. After doing this preliminary analysis,
    I could use my new understanding of the chat logs to write Python scripts or even
    a full custom app (like I ended up developing for this dataset) to aid my research.
  prefs: []
  type: TYPE_NORMAL
- en: Before I actually started writing Python code to more easily parse these chat
    logs, though, I noticed a file that I’d missed before in the Unicorn Riot ZIP
    file that might make researching this dataset a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Discord History Tracker</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ZIP file from my Unicorn Riot contact had dozens of files in it, most of
    them JSON files and PNG screenshots, along with a few folders containing other
    JSON files. I’d immediately zeroed in on the JSON files to analyze their data
    structure, but until now I hadn’t noticed the file *logviewer.html*. This was
    an HTML and JavaScript file that, when opened in a web browser, would allow me
    to load JSON chat log files and read through them.
  prefs: []
  type: TYPE_NORMAL
- en: After talking with my Unicorn Riot contact, I learned that this local HTML file
    is part of a piece of open source software called Discord History Tracker. This
    software, not affiliated with Discord, lets users save an offline copy of everything
    they have access to in a given Discord server in JSON format. Antifascist activists
    used this software to exfiltrate chat logs from Vibrant Diversity, Charlottesville
    2.0, and other fascist-run Discord servers.
  prefs: []
  type: TYPE_NORMAL
- en: Discord History Tracker included two components. The main component was in charge
    of actually creating a backup of a Discord server. The user would load the Discord
    server in their web browser, open their developer tools, and copy and paste the
    Discord History Tracker JavaScript code into their browser’s console. This would
    then scrape all of the data in the Discord server and save a backup file in JSON
    format. The second component of Discord History Tracker was the *logviewer.html*
    file, which contained offline HTML software for viewing those backup files.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-1](#fig14-1) shows *logviewer.html* loaded in a web browser. In
    the screenshot, I’ve scrolled to the aforementioned messages between *badtanman*
    and *northern_confederate* from the #problematic_oven channel.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The screenshot in [Figure 14-1](#fig14-1) shows software from 2017\. The Discord
    History Tracker interface has changed considerably since then. Among other changes,
    it now saves the data in SQLite databases, rather than as JSON files, and you
    can view the logs in a desktop app instead of using the* logviewer.html *file.
    You can learn more about the software at* [https://dht.chylex.com](https://dht.chylex.com)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the Discord log viewer web application, showing the chat
    logs from the #problematic_oven channel in the Vibrant Diversity Discord server.](Images/Figure14-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: The August 31,
    2017, chat between</samp> <samp class="SANS_Futura_Std_Book_11">badtanman</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_11">northern_confederate</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, viewed in the Discord Offline History
    web app</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This offline HTML viewer software made it considerably easier to navigate and
    read the contents of the JSON files. I could click through the channels on the
    left, and then read through a page of chats at a time. However, it also lacked
    some features that would be important for my ongoing investigation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There was no simple way to search for individual messages. For example, suppose
    I wanted to search for mentions of Berkeley, the city I lived in at the time.
    I would have to click a channel like #general, use my web browser’s search feature
    to search for *Berkeley*, and then find which messages appeared in the #general
    channel. I would also need to change the settings to display all messages per
    page so I could search them all at once, rather than displaying just 1,000 messages
    at a time, as shown in [Figure 14-1](#fig14-1). I would then have to replicate
    this search for every other channel in the server, and if I wanted to search other
    Discord servers as well, I’d have to replicate it for each channel in each server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The offline viewer only supported looking at one server at a time, but I wanted
    to be able to search multiple servers at once and also track a single user’s messages
    across different servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There was no way to generate hyperlinks leading to individual messages. When
    you’re taking notes for a story based on chat logs like this, it’s helpful to
    track the messages of interest. Without links, you’ll regularly have to go back
    and search for specific messages all over again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I decided to build my own web application to add these missing features. I already
    had all of the chat logs in a structured format, which is by far the biggest requirement
    to build a custom app, as you learned in [Chapter 10](chapter10.xhtml)’s discussion
    of BlueLeaks Explorer. If I’d had only screenshots of the Discord servers, a custom
    app with these features wouldn’t have been possible. Screenshots aren’t structured
    data, and there’s no easy way to write software that allows you to browse the
    chat messages they contain.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Script to Search the JSON Files</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you’ve learned throughout this book, understanding how the data is structured
    is a prerequisite to writing code that works with it. Therefore, I decided to
    use the knowledge I’d gained from manually investigating the JSON files with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> to build a simple Python script
    that let me search one of the JSON files for keywords. Initially I thought I might
    be able to use this script to do all of the analysis I needed, but that turned
    out to be wrong; I ended up writing a complete custom app to investigate this
    dataset as well. Even so, this first (considerably simpler) script allowed me
    to use Python code to express the structure of the dataset that I’d already gleaned,
    which simplified the process of programming the full web app. In this section
    I go over exactly how my initial Discord JSON search script worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I knew my script needed to be able to display chat messages based
    on what I searched for. Let’s say I wanted my code to display the following chat
    message from [Listing 14-6](#list14-6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> key
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, but now I knew how
    to find the actual username of the person who posted this message. First, my code
    needed to look in the JSON’s <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    object and select the fourth item in the <samp class="SANS_TheSansMonoCd_W5Regular_11">userindex</samp>
    array, which is the user ID <samp class="SANS_TheSansMonoCd_W5Regular_11">289851780521787392</samp>.
    My code then would look again in the JSON’s <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    object, this time for the <samp class="SANS_TheSansMonoCd_W5Regular_11">users</samp>
    key, and use that user ID as the key to get this user object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: My code would select the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    string from that object to get the username of the message poster, <samp class="SANS_TheSansMonoCd_W5Regular_11">badtanman</samp>,
    and then replicate the whole process to display the correct username for every
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'I opened my text editor and started writing a Python script, *discord-json
    -search.py*, to search one of the JSON files for keywords. Here’s my completed
    source code (you can also find it at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/discord<wbr>-json<wbr>-search<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/discord-json-search.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s simplest to explain how this script worked from bottom to top, since that’s
    how it executed and also how I programmed it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function ❽ is a Click command that takes two arguments: the filename for a JSON
    file with Discord chat logs called <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>,
    and a search term called <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp>.
    The code opened the filename that was passed in and parsed it using <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>
    to turn it into a JSON object. Then it called the <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp>
    function, passing in the data from the JSON file and the search query.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp> function
    ❸ is where all the magic happened. I knew from my previous analysis that these
    Discord JSON objects had two keys: the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    key, which contained the messages in each channel, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">meta</samp>
    key, which contained metadata about these messages. My script started by looping
    through every channel in <samp class="SANS_TheSansMonoCd_W5Regular_11">data[''data'']</samp>
    ❹, then using its <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>
    to look up that channel’s name and server in the metadata ❺. It then looped through
    every message in that channel ❻ and stored the message’s username, timestamp,
    and the message itself in variables.'
  prefs: []
  type: TYPE_NORMAL
- en: The code then checked to see if the search query that was passed into the script
    as a CLI argument (stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">query</samp>)
    existed in the message (stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>)
    ❼. As described in [Chapter 7](chapter7.xhtml), it converted both strings to lowercase
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">lower()</samp> method
    to make the search case insensitive. If the lowercase version of the message contained
    the lowercase version of the search term, the script then passed all of the relevant
    variables into the <samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp>
    function to display the message in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp> function
    ❷ took arguments for metadata about a message, the message text itself, and the
    search term and used those to display the message. This code used <samp class="SANS_TheSansMonoCd_W5Regular_11">click.echo()</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> to display
    text to the terminal, and it used <samp class="SANS_TheSansMonoCd_W5Regular_11">click.style()</samp>
    to apply different colors and formatting. (You could do all of this just with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function, but
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> module makes it
    simpler to style terminal output.) After displaying two lines of metadata for
    the message, the script then displayed the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">highlight()</samp>
    function, which returned the message itself in color with the search term underlined.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">highlight()</samp> function
    ❶ created an empty string called <samp class="SANS_TheSansMonoCd_W5Regular_11">new_message</samp>
    and then made it a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>,
    the original message it displayed, except with all instances of the search term
    underlined using <samp class="SANS_TheSansMonoCd_W5Regular_11">click.style()</samp>.
    It then returned <samp class="SANS_TheSansMonoCd_W5Regular_11">new_message</samp>
    and displayed it to the terminal in the <samp class="SANS_TheSansMonoCd_W5Regular_11">display()</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I wanted to search *VibrantDiversity.json* for the term *berkeley*,
    I could run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output listed over a hundred chat messages that mentioned Berkeley. Each
    message showed the name of the channel, the name of the Discord server, the user
    who posted it and when, and the content of the message. Here’s the first snippet
    of output, which highlighted the search term in the message with an underline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first message that mentioned Berkeley was a post from the user *Hector*
    in the #general channel on September 3, 2017\. This user was complaining about
    the relatively small number of fascists that showed up to their rallies in Boston
    and Berkeley, compared to the “antifa” counterprotesters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script allowed me to search a full Discord server for keywords, but it
    still lacked several of the features that I wanted: it could work with only one
    Discord leak at a time, and there was no easy way to browse through and read the
    data sequentially or to save links to specific interesting messages. I started
    building out a web application to help me perform these missing tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">My Discord Analysis Code</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve found that after obtaining a large dataset full of structured data, building
    a custom web application to explore it, as I did with BlueLeaks Explorer, makes
    it much easier to find its hidden revelations. After writing *discord-json -search.py*,
    I spent about a week creating Discord Analysis, a custom web app to analyze leaked
    Discord chat logs.
  prefs: []
  type: TYPE_NORMAL
- en: Since I wanted to be able to search multiple Discord servers at once, I decided
    that the best solution would be to convert all of the data from JSON files into
    a SQL database. I used a Python tech stack that I was already familiar with, Flask
    (discussed briefly in [Chapter 10](chapter10.xhtml)), for the web app and SQLAlchemy
    for communicating with the SQL database.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy is an *Object Relational Mapping (ORM)* Python module that’s useful
    for making code that works with SQL databases simpler to write and more secure.
    ORMs allow you to work with SQL databases in such a way that you don’t have to
    directly write any SQL code yourself, which means your projects won’t be vulnerable
    to SQL injection. This web app used Flask-SQLAlchemy, a Flask extension that adds
    SQLAlchemy support to Flask apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'While developing my Discord Analysis web app, I was actively using it to research
    the leaked neo-Nazi chat logs. If I had new questions about the data (like what
    other messages a user posted) or found that I needed new features (like limiting
    my search to a single server), I would program them in as I went along. This is
    typically how I build research tools: I start using them long before they’re complete,
    and I let the direction of my research guide which features I add next.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, I explain how I went about developing the different components
    of the app: designing a SQL database, importing chat logs from the Discord JSON
    files into that database, and building the web interface to research the chat
    logs. You’ll learn how I used SQLAlchemy to define database tables, insert rows
    into them, and select rows from them. You’ll also learn how I used Flask to build
    this web app, including how to make Jinja templates and how to define routes—skills
    you’ll need if you build your own Flask web apps in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Fully explaining how to build a Flask and SQLAlchemy web app is outside the
    scope of this book. Instead, I go over how I went about building this app in broad
    strokes, which should still be useful if you ever decide to build a similar one
    yourself. The best way to learn how to make your own Flask app is by exploring
    Flask’s excellent documentation at* [https://flask.palletsprojects.com](https://flask.palletsprojects.com)*;*
    *that’s how I learned. The Flask documentation includes a tutorial that walks
    you through every step of developing* *a simple web app. The Python skills you’ve
    learned from [Chapters 7](chapter7.xhtml) and [8](chapter8.xhtml) are more than
    enough for you to follow along with the tutorial. You can also find docs for SQLAlchemy
    at* [https://<wbr>www<wbr>.sqlalchemy<wbr>.org](https://www.sqlalchemy.org) *and
    for Flask’s SQLAlchemy extension at* [https://flask-sqlalchemy.palletsprojects.com](https://flask-sqlalchemy.palletsprojects.com)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: The code for Discord Analysis, which has quietly been public on my GitHub account
    for years, hasn’t been updated much since 2017, with the exception of some small
    changes I made when preparing it for this book. I don’t plan on maintaining it.
    Still, you should be able to get it running locally if you’d like to explore it
    further, and you can use it as inspiration for your own future projects that use
    a similar tech stack. Read through this section to see how it works, and then
    if you’re curious, try getting it running locally yourself.
  prefs: []
  type: TYPE_NORMAL
- en: As I explain the app, I’ll quote sections of the source code. It’s too long
    to include all of it here, but you can find the full code online in the book’s
    GitHub repository at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/tree<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis*](https://github.com/micahflee/hacks-leaks-and-revelations/tree/main/chapter-14/discord-analysis).
    I recommend that you pull up the full source code for each file as I describe
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Designing the SQL
    Database</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I started my web app with a Python script called *app.py*. You can find the
    full source code for this file at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/app<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py).
    First, my code imported the appropriate Flask and SQLAlchemy modules, created
    a new Flask app object called <samp class="SANS_TheSansMonoCd_W5Regular_11">app</samp>,
    and created a new Flask-SQLAlchemy object called <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: I started by importing several items from the <samp class="SANS_TheSansMonoCd_W5Regular_11">flask</samp>
    module, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Flask</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">render_template</samp>, that I knew I’d
    need later in the program. In the next line, I also imported <samp class="SANS_TheSansMonoCd_W5Regular_11">SQLAlchemy</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">flask_sqlalchemy</samp>
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Using the newly imported <samp class="SANS_TheSansMonoCd_W5Regular_11">Flask</samp>,
    I then created a Flask object called <samp class="SANS_TheSansMonoCd_W5Regular_11">app</samp>.
    Every Flask web app includes such an object (and usually by that name) to define
    exactly how the app will work. I modified the <samp class="SANS_TheSansMonoCd_W5Regular_11">app.config</samp>
    dict to set some configuration settings, telling it that I wanted to use a SQLite3
    database stored in the file *database.sqlite3*, and I wanted to turn debug mode
    on, which is useful while you’re actively developing a web app. Finally, I created
    the SQLAlchemy object called <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>,
    passing in <samp class="SANS_TheSansMonoCd_W5Regular_11">app</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next bit of code, I’ll introduce you to a new Python concept that I
    didn’t explicitly cover in [Part III](part3.xhtml) but that you’ve technically
    been using all along: classes. In Python, a *class* is a template for creating
    new objects that can store data (using variables called *attributes*) and perform
    actions (using functions called *methods*). For example, strings are technically
    classes. When you run the code <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"example"</samp>,
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is an instance
    of the string class, the data it stores is the string <samp class="SANS_TheSansMonoCd_W5Regular_11">example</samp>,
    and it has a bunch of methods you can call on it, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">s.upper()</samp>,
    which returns an uppercase version of the string. When you write SQLAlchemy code,
    you define a class for each database table. This way, you can write code that
    works with Python objects without needing to write the SQL queries yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I started writing code to define the SQL tables that would store Discord data
    for servers, users, channels, and messages. For example, the following code defines
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> class, which represents
    the SQL table to store data about servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Using SQLAlchemy requires that you define your own classes. You can think of
    this <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> class as a description
    of a new type of Python object that represents a row in the server SQL table.
    Because I defined it as <samp class="SANS_TheSansMonoCd_W5Regular_11">Server(db
    .Model)</samp>, this class inherited all of the functionality of the <samp class="SANS_TheSansMonoCd_W5Regular_11">db.Model</samp>
    class, which is part of SQLAlchemy. Inside the class definition, I defined the
    table’s columns: <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp> (an auto-incrementing
    number) and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> (a string).
    Next, I defined this table’s relationships to other tables, in this case relating
    <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">channels</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp>—both the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp> table and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp>
    table have a <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> column.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>
    method. When you define a class, you must call the first argument of every method
    <samp class="SANS_TheSansMonoCd_W5Regular_11">self</samp> to represent this Python
    object itself. You can optionally include other arguments, too. The <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>
    method is a type of method called a *constructor*, which runs as soon as you create
    the object. This constructor sets the value of the object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    attribute (which you access within the class as <samp class="SANS_TheSansMonoCd_W5Regular_11">self.name</samp>)
    to the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, which
    is a variable passed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">__init__()</samp>
    method as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to add a row to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    table in the SQL database for the Vibrant Diversity Discord server, I could run
    the code in [Listing 14-7](#list14-7). (My Discord Analysis app doesn’t actually
    use this code—it loads the servers from the JSON data—but I’m including this example
    to help you understand how to use SQLAlchemy classes to interact with databases
    without needing to write SQL queries.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-7: Using SQLAlchemy
    to insert data into a SQL database</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of code creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    object by running <samp class="SANS_TheSansMonoCd_W5Regular_11">Server("Vibrant
    Diversity")</samp>. This would run the constructor method, passing in the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Vibrant Diversity</samp> as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>. The constructor would then
    set the value of its <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    attribute to the name that was passed in. When the constructor finishes running,
    the code would save this newly created Python object in the <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>
    variable. The next two lines of code use the SQLAlchemy object <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>
    to run the <samp class="SANS_TheSansMonoCd_W5Regular_11">INSERT</samp> query in
    the SQL database and insert this row. The <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session
    .add()</samp> method collects a list of SQL queries, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session.commit()</samp>
    method runs those SQL queries on the database. In SQL, sometimes it’s more efficient
    to run several queries and then commit them all at once rather than one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the code in [Listing 14-7](#list14-7) is basically the same
    as running the SQL query <samp class="SANS_TheSansMonoCd_W5Regular_11">INSERT
    INTO server SET name='Vibrant Diversity';</samp>, except this way all you need
    to do is interact with Python objects, not write any SQL yourself. After creating
    the server object, I could then access that object’s ID attribute with <samp class="SANS_TheSansMonoCd_W5Regular_11">server.id</samp>
    or the object’s name attribute with <samp class="SANS_TheSansMonoCd_W5Regular_11">server.name</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    table I just described, I also created the following tables, which you can view
    in detail in the *app.py* file at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/app<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py):'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">User</samp> A Discord user. I included
    the columns <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>
    column is an auto-incrementing number, and <samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>
    is the original ID that Discord itself used. This is useful for identifying the
    same user across servers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Channel</samp> A channel in a Discord
    server. The columns are <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> column forms a relationship
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> table, since
    each server has a set of channels. Every Discord server JSON file contains a list
    of channels. Adding this relationship means that the SQL database I was designing
    would match the data structure in the JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Message</samp> A Discord message.
    The columns are <samp class="SANS_TheSansMonoCd_W5Regular_11">id</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">discord_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">timestamp</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">attachments_json</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">attachments _json</samp> column contains
    extra data from messages with attachments, like when someone posts an image to
    Discord. The <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>
    columns form relationships with the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    tables. These also would match the structure found in the JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-2](#fig14-2) shows the relationship between these four tables. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp> table includes a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp> column, so it’s
    related to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> table.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp> table includes
    columns for <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_id</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp>,
    so it’s related to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    tables.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A chart showing four table names, clockwise from top left: Server, User,
    Message, and Channel. Channel points to Server, and Message points to Channel,
    Server, and User.](Images/Figure14-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: Relationships
    between the SQL tables in the Discord Analysis app</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: My goal for this web app would be to build an interface that allows me to explore
    the data stored in these SQL tables. I wanted to be able to search all of the
    messages at once, including from multiple servers, to see which users posted in
    multiple servers and to be able to generate links to individual messages that
    I could store in my notes. Before building the web interface, though, I needed
    to load the database with data from the JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Importing Chat Logs
    into the SQL Database</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I wrote a separate script, *admin.py*, that I used to import data into the SQL
    database. This script took a command as its first argument. If I passed in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">create-db</samp>, it would use SQLAlchemy
    to create the SQL tables that I had defined in *app.py*. When I passed in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp>, followed by the filename
    of a JSON file, the code would import Discord data from that JSON file into the
    SQL database. I also eventually added the <samp class="SANS_TheSansMonoCd_W5Regular_11">user-stats</samp>
    command, which displayed how many messages each user in the whole database posted,
    and on which servers.
  prefs: []
  type: TYPE_NORMAL
- en: This *admin,py* file is too long to include in this chapter in its entirety,
    but as with *app.py*, you can find a copy of the complete code in the book’s GitHub
    repo at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/admin<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/admin.py).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll explain how I built the <samp class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp>
    command (specifically, the <samp class="SANS_TheSansMonoCd_W5Regular_11">import_json()</samp>
    function, which is what gets called when you run <samp class="SANS_TheSansMonoCd_W5Regular_11">import-json</samp>),
    the most interesting part of the script. This is the code that opens up the JSON
    files containing Discord server leaks, loops through all the data, and then inserts
    it into the SQL database. As with the *discord-json -search.py* script, I relied
    on my previous manual analysis of the Discord JSON files to write this code. Basically,
    this is the part that requires an understanding of the structure of the original
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">import_json()</samp> function
    is too long to display it all here, so instead I’ll display snippets that explain
    the general idea of how it works. The function takes the filename for a JSON file
    containing Discord leaks as an argument. It opens this file, loads it into a variable
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>, and then uses
    the information in <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> to
    add servers, users, channels, and messages to the SQL database. I’ll show the
    code that adds users, channels, and messages soon, but first, [Listing 14-8](#list14-8)
    shows the code that adds servers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-8: Code from</samp>
    <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    add servers to the database</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code looped through all of the servers it found in <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["servers"]</samp>,
    adding a row to the database for each server that it found. For example, in [Listing
    14-1](#list14-1), I used <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>
    to view this list of servers for *VibrantDiversity.json* and found that it contained
    only a single server. [Listing 14-8](#list14-8) uses Python code to find that
    same list of servers from the same part of the target leaked JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: For each server it found, the code stored the server’s name in the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    variable, then tried to add that server to the database. This code used Python
    exception handling, which you learned about in [Chapter 7](chapter7.xhtml). In
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block, the code created
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp> object (this
    represents a row in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    table in SQLAlchemy), added that row to the database using <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.add(server)</samp>, and finally committed
    the database changes with <samp class="SANS_TheSansMonoCd_W5Regular_11">db.session.commit()</samp>,
    just like in the SQLAlchemy code in [Listing 14-7](#list14-7). After the server
    was successfully inserted into the database, the program displayed a plus sign
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>) and moved on to the next
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: When I defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server</samp>
    table in *app.py*, I specified that the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    column should be unique, meaning that there could be no two rows with the same
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> column. If SQLAlchemy
    threw the <samp class="SANS_TheSansMonoCd_W5Regular_11">sqlalchemy.exc.IntegrityError</samp>
    exception while the script was trying to add the row to the database, that meant
    a server with that name already existed in the database, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp>
    block should run instead. If this happened, then the code rolled back the change
    that it was about to make and displayed a dot (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>)
    instead of a plus sign.
  prefs: []
  type: TYPE_NORMAL
- en: Why did I worry about catching these exceptions to begin with instead of just
    adding rows to the database? As with the programming exercises that you completed
    in previous chapters, I didn’t write the whole script perfectly the first time
    and then run it. Instead, I wrote small bits of code at a time and ran them to
    make sure my script was working so far. This exception handling allowed me to
    rerun an import on the same JSON file over and over while starting where I left
    off. If my script showed a plus sign, I knew it had added a new row to the database.
    If it showed a dot, that meant the row already existed and the script moved on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also notice that the familiar <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    function calls look odd in [Listing 14-8](#list14-8): my code passed in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">end=""</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">flush=True</samp>
    keyword arguments. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    displays the string the user passes in as an argument, then adds a newline character
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>) to the end. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">end</samp> argument replaces that newline
    with something else (in this case, an empty string). In other words, this is how
    I could print a string without moving on to the next line. The <samp class="SANS_TheSansMonoCd_W5Regular_11">flush=True</samp>
    argument makes sure that the output gets displayed to the screen immediately;
    without it, the output would still get displayed, but not right after the function
    call. This allowed me to watch the progress of an import.'
  prefs: []
  type: TYPE_NORMAL
- en: After adding servers, the script added users, as shown in [Listing 14-9](#list14-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-9: Code from</samp>
    <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    add users to the database</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code is very similar to [Listing 14-8](#list14-8), but instead of looping
    through the list <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["servers"]</samp>,
    it looped through the dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["users"]</samp>.
    [Listing 14-3](#list14-3) shows this JSON object of users from *VibrantDiversity
    .json*. As described in [Chapter 8](chapter8.xhtml), when you loop through a dictionary,
    you’re actually looping through the dictionary’s keys. In this case, the script
    stored each key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_discord_id</samp>
    variable. Armed with the user’s Discord ID, it then looked up that user’s name
    in the metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block, the
    script then created a new <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    object, this time with both the user’s Discord ID and name, and tried adding it
    to the database. When I defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    table in *app.py*, I specified that <samp class="SANS_TheSansMonoCd_W5Regular_11">user_discord_id</samp>
    should be unique in order to prevent duplicate users. Like [Listing 14-8](#list14-8),
    the code displayed a plus sign when adding the user to the database and a dot
    if it hit an error. This error-handling code would be important when I started
    importing multiple servers: if a Discord user was already in the database because
    they were a member of a previous server, the code wouldn’t create a duplicate
    user for them.'
  prefs: []
  type: TYPE_NORMAL
- en: After adding servers and users, the script then added channels, using the code
    in [Listing 14-10](#list14-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-10: Code from</samp>
    <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    add channels to the database</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code is also similar to Listings 14-8 and 14-9\. This time however, it
    looped through the keys of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["meta"]["channels"]</samp>
    dictionary, storing each key as <samp class="SANS_TheSansMonoCd_W5Regular_11">channel_discord_id</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-2](#list14-2) showed this JSON object of channels from *VibrantDiversity
    .json*, which you can revisit to remind yourself what this dictionary looks like.
    For each channel, the code in [Listing 14-8](#list14-8) stored the name of the
    channel in <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> and that
    channel’s server index in <samp class="SANS_TheSansMonoCd_W5Regular_11">server_id</samp>.
    It then queried the SQL database itself to get the server row in [Listing 14-10](#list14-10)
    ❶, which should have been added earlier by the code in [Listing 14-9](#list14-9),
    and stored this value in <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>.
    The SQL query that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Server.query.filter_by()</samp>
    function call ran was similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">SELECT
    * FROM servers WHERE name=''</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">name</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">'';</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">name</samp>
    is the server name.'
  prefs: []
  type: TYPE_NORMAL
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block, the code
    then created a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp>
    object, this time telling it the server, the channel’s Discord ID, and the channel
    name. As with the previous listings, it tried adding this channel to the database,
    displaying a plus sign on success and a dot if the channel already existed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after adding servers, users, and channels, the code added all of the
    messages, as shown in [Listing 14-11](#list14-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-11: Code from</samp>
    <samp class="SANS_Futura_Std_Book_11">admin.py</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    add messages to the database</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This time, this code looped through all of the keys of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data["data"]</samp>
    dictionary. As you learned in [Listing 14-5](#list14-5), this dictionary’s keys
    are the Discord IDs of channels. My code stored each ID in the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">channel _discord_id</samp>. I then used
    SQLAlchemy to query the database to load this actual channel row ❶ (the SQL query
    that this command ran was similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">SELECT
    * FROM channel WHERE channel_discord_id=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_discord_id</samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_discord_id</samp>
    is the channel ID). After learning what channel it was dealing with, the code
    then looped through all of that channel’s messages to add them to the database,
    storing each message’s Discord ID as <samp class="SANS_TheSansMonoCd_W5Regular_11">message_discord_id</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code in [Listing 14-11](#list14-11) is also similar to Listings
    14-8 through 14-10\. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp>
    block, for each message, the code stored the timestamp and message in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">timestamp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">message</samp>
    variables. It then looked up the user Discord ID from the metadata and queried
    the SQL database for the <samp class="SANS_TheSansMonoCd_W5Regular_11">User</samp>
    object ❷, and, if the message included an attachment, it also created a string
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">attachments_json</samp>.
    Finally, it created a <samp class="SANS_TheSansMonoCd_W5Regular_11">Message</samp>
    object and inserted this message into the database. As before, the code displayed
    a plus sign if it successfully inserted a message or a dot if that message was
    already in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Since exception handling ensured *admin.py* wouldn’t import duplicate rows,
    I could use this script to import newer versions of JSON files from the same Discord
    server. For example, if Unicorn Riot’s infiltrator used Discord History Tracker
    to save another offline copy of everything in Vibrant Diversity a month later,
    and I imported that new JSON file, it would import only the new messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this code was written, I used it to import all of the JSON Discord files
    that I had received from Unicorn Riot. To import data from the Vibrant Diversity
    channel, I would run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Each plus sign in this output represents a different row of data inserted into
    the database. The *VibrantDiversity.json* file added 1 server, 530 users, 9 channels,
    and a total of 255,349 messages, importing a message at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'I then used *admin.py* to import the rest of the Discord JSON files I had,
    including chat logs from Anticom, 4th Reich, Ethnoserver, and other leaked servers.
    For example, next I imported one of the smaller servers called Pony Power, which
    I’ll discuss further later in this chapter, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output from that command (in this case, I’d already imported
    the Vibrant Diversity data, and these two Discord channels had some overlapping
    users, so my script skipped importing some of the users):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This JSON file included 50 users. The code skipped 17 of them (displaying dots
    instead of plus signs) because they were already in the database from Vibrant
    Diversity, and it added 33 new users.
  prefs: []
  type: TYPE_NORMAL
- en: My database was now full of neo-Nazi chat logs, preparing me to build a web
    interface to explore them. When you’re building a web app to investigate data,
    you need some data to explore to make sure your app is actually working as intended.
    If I hadn’t imported the actual data first, I would have had to make up and import
    some test data so I’d have something to troubleshoot with while building the web
    app. But I decided to import the real data first because I knew I’d need to write
    that code eventually anyway.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Web
    Interface</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you build web apps, it’s often useful to split your web pages into reusable
    components, like headers, footers, and sidebars. Individual pages may have their
    own reusable components, too. For example, the page that lists chat messages might
    repeat the same message component for each message on the page. You define these
    components in *templates*, HTML files that can contain variables and logic, like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements or <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops. You can render a template (convert it into HTML) by passing the template
    file along with variables into a *templating engine*, or code that converts a
    template into HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Flask comes with a popular templating engine called Jinja. To build the web
    interface to explore the chat logs I’d just imported, I started by creating the
    layout template in Jinja. In short, I wrote the HTML code that would make up the
    layout of all of the pages in my web app, but also included Python variables and
    loops. [Listing 14-12](#list14-12) shows the code for *layout.html*, my layout
    template.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-12: The</samp> <samp
    class="SANS_Futura_Std_Book_11">layout.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">layout
    template</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 14-12](#list14-12) looks like HTML at a glance, but if
    you look closely you’ll see that it’s actually a Jinja template. For example,
    look at the code that adds the *CSS (Cascading Style Sheets)* file—which defines
    the page’s style—to the page ❶. The HTML syntax for adding a stylesheet is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">style.css</samp>
    is the path or URL of a CSS file. Instead of an actual filename, the code in [Listing
    14-12](#list14-12) uses this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In a Jinja template, putting a Python expression between <samp class="SANS_TheSansMonoCd_W5Regular_11">{{</samp>and}<samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp> means Python will evaluate this
    expression when the template is rendered. In this case, [Listing 14-12](#list14-12)
    rendered that line as <samp class="SANS_TheSansMonoCd_W5Regular_11"><link rel=stylesheet
    type=text/css href="/static/style.css"></samp> because the <samp class="SANS_TheSansMonoCd_W5Regular_11">url_for()</samp>
    function, which is part of Flask, returned the <samp class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp>
    string.
  prefs: []
  type: TYPE_NORMAL
- en: The template in [Listing 14-12](#list14-12) also included some <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops. In Jinja, you start a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop with the code <samp class="SANS_TheSansMonoCd_W5Regular_11">{% for</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">item</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">list</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">%}</samp>
    and end it with <samp class="SANS_TheSansMonoCd_W5Regular_11">{% endfor %}</samp>.
    In the left sidebar of the layout, the template listed all of the Discord servers
    in the databases ❷, looping through the items in the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>
    list one at a time. (For this template to render properly, I’d need to make sure
    to pass <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> into the
    template as a variable when I render it in the Flask code.) For each server, after
    displaying the server name, it looped through all of the channels in that server
    ❸, getting the list of channels from <samp class="SANS_TheSansMonoCd_W5Regular_11">server.channels</samp>.
    For each channel, the code displayed a link to view messages in that channel followed
    by the number of messages it contains.
  prefs: []
  type: TYPE_NORMAL
- en: The template also included a search bar at the top of the page ❹, as well as
    a drop-down menu with options to search a specific server or to search them all
    ❺. It also included a list of notification messages ❻ I could use if I wanted
    to display an error message—for example, if I tried loading a link to view messages
    in a channel that didn’t exist in the database. Finally, the template displayed
    the content block for that particular page ❼. While all pages shared this template,
    the content block differed for each page.
  prefs: []
  type: TYPE_NORMAL
- en: After starting on my templates, I wrote code for a handful of *routes*, which
    let the web app know which page the user’s web browser was trying to view. In
    web development, you can think of a route as a path for a web page, except it
    can include placeholders. For example, if the web app is hosted at *http://<wbr>localhost:5000*,
    and the Python code defines the route <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>
    for the search page, users can view that route with the URL *http://<wbr>localhost:5000<wbr>/search*.
  prefs: []
  type: TYPE_NORMAL
- en: The home page route (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>),
    shown in [Listing 14-13](#list14-13), was by far the simplest one in my web app.
    This page displayed the message “This is a web app that will let you research
    the alt-right chatroom leak, published by Unicorn Riot.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-13: The home page
    route (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">/)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In Flask, each route is a function that returns the HTML for that web page.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">index()</samp> function starts
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">@app.route("/")</samp>
    decorator, which is how Flask knows that the <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>
    route should call this function. This function first runs a SQL query to get all
    of the servers in the database, stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>.
    It then calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">render_template()</samp>
    function, rendering the *index.html* template, passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>
    variable into the template, and returning the HTML it receives.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-14](#list14-14) shows the code for the *index.html* Jinja template
    that was rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-14: The</samp> <samp
    class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">template</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of code in this template means that Jinja should render the *layout.html*
    template but replace <samp class="SANS_TheSansMonoCd_W5Regular_11">{% block content
    %}{% endblock %}</samp> with the content block defined here—some text that says,
    “Alt-right chatroom research” and a brief description of the web app. Also notice
    that in [Listing 14-13](#list14-13), I passed the <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp>
    variable into the template; the *layout.html* template in [Listing 14-11](#list14-11)
    used this variable to make the list of servers in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-3](#fig14-3) shows what the app’s home page looked like at this
    point, with the home page text as defined in *index.html* and with the servers
    on the left and the search bar at the top as defined in *layout.html*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of my Discord Analysis web app with the header “Alt-right chatroom
    research.” The sidebar lists all of the Discord servers and channels imported
    in the database.](Images/Figure14-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The home page
    of my Discord Analysis web app</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at one more route that does a bit more than the <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>
    route, the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp> route,
    which will help explain how one of the web app’s core features—searching the chat
    logs—works. Here’s the Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">search()</samp> function starts
    with the decorator <samp class="SANS_TheSansMonoCd_W5Regular_11">@app.route("/search")</samp>,
    so Flask knows that the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>
    route should call this function. At the beginning of the function, I defined the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp>
    variables as the values from the URL’s query string. For example, if the URL ends
    in */search?q*=*berkeley*, then this code would set the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: I got this query string information from the Flask variable <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args</samp>,
    which is a dictionary containing all of the values after the <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    in the URL. The code got the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    key in this dictionary by evaluating <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args.get("q")</samp>,
    but <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args["q"]</samp> would
    work just the same. When using the <samp class="SANS_TheSansMonoCd_W5Regular_11">.get()</samp>
    method on dictionaries, you can choose default values, as I did in the following
    line. The expression <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args.get("s",
    0)</samp> looks through <samp class="SANS_TheSansMonoCd_W5Regular_11">request.args</samp>
    for the key <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> and returns
    it if it finds it. If the expression doesn’t find <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>,
    it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: On the search page, <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> is
    the search query and <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> is
    the ID of the server to search (if <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, this means I want to
    search all servers). The <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp> variables are
    used for *pagination*, which determines how an app displays a limited number of
    results per page. The <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp>
    variable is the page number, and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp>
    is the number of results per page.
  prefs: []
  type: TYPE_NORMAL
- en: Since three of the routes in my app used pagination (<samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/channel</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">/user</samp>),
    I wrote the code to find the <samp class="SANS_TheSansMonoCd_W5Regular_11">page</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">per_page</samp> query strings
    in the function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_pagination_args()</samp>,
    which allowed me to just call that function instead of repeating the same code
    in multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: I then queried the SQL database for the server with the ID stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>,
    saving the result as <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp> variable is used
    to optionally search a single Discord server, rather than all of them. If the
    SQL database doesn’t have any servers with that ID, then <samp class="SANS_TheSansMonoCd_W5Regular_11">server</samp>
    is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>, which means
    the app should search all servers. I then started building the SQL query to search
    for all of the messages, storing the results in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">messages</samp>.
    If this search was limited to a specific server (that is, if there’s a value for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>), the code modified <samp
    class="SANS_TheSansMonoCd_W5Regular_11">messages</samp> to filter just by messages
    from that server. Finally, I used the SQLAlchemy pagination feature to run the
    SQL query, making sure to select the correct page of results, storing the search
    results in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">pagination</samp>.
    Part of the SQLAlchemy query included <samp class="SANS_TheSansMonoCd_W5Regular_11">Message.message.like(f"%{q}%")</samp>
    to ultimately run a SQL query that used SQL’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LIKE</samp>
    operator, which did a case-insensitive search for any messages containing the
    string <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>, as described in
    [Chapter 12](chapter12.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: In the following <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement,
    my code defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>
    variable as a description of the search, showing either just the search query
    or both it and the name of the server being searched. It then loaded all of the
    servers with <samp class="SANS_TheSansMonoCd_W5Regular_11">servers</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Server.query.all()</samp>,
    which the *layout.html* layout template needs to render the sidebar. Finally,
    the code rendered the *results.html* Jinja template, passing in all of the appropriate
    variables, resulting in the search results page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the home page route (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>)
    and the search route (<samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>),
    I created these other routes for my web app:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/view/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">message_id</samp> The
    hyperlink to a specific Discord message
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/channel/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">channel_id</samp> The
    hyperlink to a specific channel in a Discord server
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/users</samp> A page that listed
    all Discord users in the database, along with how many messages each has posted
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/users/</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">user_id</samp> A
    page that listed the messages that each Discord user has posted, spanned across
    all servers and channels that they posted in
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 14-3](#fig14-3), the Discord servers that I imported
    while developing the app are all listed in the left sidebar, along with each server’s
    channels. To start my research, I could search for keywords (using the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search</samp>
    route), or I could click a channel name on the left and read its chat logs (using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">/channel/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp>
    route).
  prefs: []
  type: TYPE_NORMAL
- en: You can view the code for all of these routes in *app.py* at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-14<wbr>/discord<wbr>-analysis<wbr>/app<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-14/discord-analysis/app.py).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how the Discord Analysis web app works, let’s look at how
    I went about using it to analyze the Discord leaks.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Discord Analysis
    to Find Revelations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After I had built enough of the Discord Analysis web app that I could start
    using it for actual research, I started by reading a cross section of all of the
    Discord leaks I had imported and taking notes on what might make good articles—all
    the while fixing bugs as I discovered them, and adding features as I felt I needed
    them. I went one Discord server at a time, trying to understand the gist of what
    was discussed in each channel. I searched for terms like *WikiLeaks* to see what
    the fascists were saying about it, since it had recently played a role in Trump’s
    2016 election victory. I stumbled upon various conversations about digital security
    advice and which encrypted messaging apps to trust, all of it mixed up with numerous
    conspiracy theories, racist diatribes, and selfies of people holding guns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the process of using Discord Analysis on my computer actually worked.
    When I wanted to run my web app to test it during development or to start researching
    neo-Nazi chats, I’d run <samp class="SANS_TheSansMonoCd_W5Regular_11">python3
    app.py</samp>. It showed this output, which is the typical output you see every
    time you start a Flask web app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output said that the Flask web server started and was running at the URL
    *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:5000*. The web server continued to run until
    I was ready to quit it by pressing CTRL-C. I loaded that URL in my web browser
    to view the web app. As I made web requests, my terminal output showed me web
    service logs. For example, when I loaded the home page, my app produced these
    logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The left column is the IP address (<samp class="SANS_TheSansMonoCd_W5Regular_11">127.0.0.1</samp>)
    of the web browser that loaded each route; in this case, I loaded routes from
    my own computer. It also shows the timestamp the route was loaded, which route
    was loaded, and other information. The first route that I loaded was the home
    page (you can tell because the first log line says <samp class="SANS_TheSansMonoCd_W5Regular_11">GET
    /</samp>), and it responded with the HTTP code <samp class="SANS_TheSansMonoCd_W5Regular_11">200</samp>,
    which means it loaded successfully. Immediately after that, my browser loaded
    the CSS stylesheet at <samp class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp>,
    which successfully loaded too, and tried to load the favicon (the icon in the
    corner of a web browser tab) at <samp class="SANS_TheSansMonoCd_W5Regular_11">/favicon.ico</samp>.
    However, the server replied with the HTTP code <samp class="SANS_TheSansMonoCd_W5Regular_11">404</samp>,
    “File not found,” because I hadn’t bothered creating a favicon for my app.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of each page in the web app was a search bar, next to which was
    the drop-down menu that let me choose to search all servers or just one. For example,
    I tried searching all Discord servers from which I had imported data for the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>. Back in my terminal,
    I could see that my browser had loaded the <samp class="SANS_TheSansMonoCd_W5Regular_11">/search?q=berkeley&s=</samp>
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The search page loaded the CSS stylesheet at <samp class="SANS_TheSansMonoCd_W5Regular_11">/static/style.css</samp>
    as well, but this time it returned with the HTTP code <samp class="SANS_TheSansMonoCd_W5Regular_11">304</samp>,
    which means that the stylesheet hadn’t been modified since the last time my browser
    made that request.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-4](#fig14-4) shows the Discord Analysis web app showing these search
    results. You can see that the page has the URL *http://127.0.0.1:5000/search?q*=*berkeley&s*=
    and lists search results from all servers for the string <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of my Discord Analysis web app showing search results for the
    search term “berkeley.” The sidebar lists all of the Discord servers and channels
    imported in the database. There are 417 messages that include the word “berkeley,”
    and these messages are displayed with the search term highlighted.](Images/Figure14-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: Searching for
    the string berkeley in my Discord Analysis web app</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: My search found 417 messages that contained the string <samp class="SANS_TheSansMonoCd_W5Regular_11">berkeley</samp>,
    along with information on who posted each message, in what channel, in what server,
    at what time, and the content of the message, with the search term itself highlighted.
    If I clicked on the user’s name, which linked to the <samp class="SANS_TheSansMonoCd_W5Regular_11">/users/</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">user_id</samp> route, I’d see
    all of the posts from that user, including those on multiple Discord servers.
  prefs: []
  type: TYPE_NORMAL
- en: Each message also had a view link, which led to the <samp class="SANS_TheSansMonoCd_W5Regular_11">/view/</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">message_id</samp> route and pulled
    up a page displaying that individual message. This allowed me to store links to
    individual messages in my notes. When I clicked on a view link I’d saved, the
    web app would show me not only that message but also the 20 messages before and
    after it, so I could easily see the rest of the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app also allowed me to explore the leaked chats by manually reading through
    each channel. I could select individual channels by clicking the links in the
    left sidebar. For example, [Figure 14-5](#fig14-5) shows the #general channel
    in the Pony Power server. In this case, the URL was *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:5000<wbr>/channel<wbr>/10*,
    meaning the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">/channel/</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">channel_id</samp>
    route was <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>. The ID field
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Channel</samp> table auto-increments,
    so the first row starts at 1, then 2, then 3, and so on. I imported the Vibrant
    Diversity JSON file first, which created channels with IDs 1 through 9, then imported
    the Pony Power JSON file, which created channels with IDs 10 through 13.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of my Discord Analysis web app. The #general-chat channel in
    the Pony Power server is highlighted on the left, and you can see the messages
    in this server themselves on the right.](Images/Figure14-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: Viewing chat logs
    for the #general-chat channel in the Pony Power server in my Discord Analysis
    web app</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: With this case study as inspiration, I hope that you’ll feel confident building
    similar custom apps for your future investigations when you get your hands on
    large structured datasets like these.
  prefs: []
  type: TYPE_NORMAL
- en: After spending a few days splitting my time between writing code and reading
    some of the worst stuff on the internet, I ultimately decided to write about Pony
    Power, a server set up for the sole purpose of harassing and doxing people.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Pony Power Discord Server</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pony Power was one of the smaller servers, with only 50 users and just over
    1,000 messages posted over the course of just 10 days. More than any other server,
    it was full of PII for perceived members of antifa. I decided to focus my reporting
    on this server because this harassment campaign was clearly newsworthy, and because
    the server was small enough that I could read through all of the messages and
    write about the highlights. As a single reporter, it would have taken me considerably
    longer to do the same for larger servers, like Vibrant Diversity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Pony Power chat logs, I found private data from over 50 people from
    14 states across the country, from California to Florida. The information often
    included users’ photographs, social media profiles, home addresses, phone numbers,
    email addresses, dates of birth, driver’s license numbers, vehicle information,
    places of employment, and in one instance, a Social Security number. As I read
    through the Pony Power chat logs, from the beginning to the end, I built up a
    spreadsheet listing each person who was doxed to help me keep track of them, as
    well as Discord Analysis links to the messages where the doxing happened. The
    server’s #faces-of-rainbow-ponies channel contained nearly all of the PII.'
  prefs: []
  type: TYPE_NORMAL
- en: The Pony Power fascists weren’t very selective about their targets. Anyone they
    considered to be a member of antifa or an antifa sympathizer was fair game, as
    were journalists they disagreed with, professors from liberal universities, or
    anyone who spoke out against racism.
  prefs: []
  type: TYPE_NORMAL
- en: Eight times in 2017, fascists traveled to Berkeley to hold protests. They came
    prepared with racist and antisemitic signs and armed with weapons for street fighting.
    One of these protests, a Say No to Marxism rally, was scheduled for late August.
    In response, antifascists began preparing a counterprotest. “So who is going to
    be there to stand up against Antifa? This is a good chance to dox them so we can
    have an idea who they are,” one of the Pony Power members posted in the chat.
    “We should go onto their [Facebook] page if they have an active one and dox all
    the ones who plan on being there and who liked the post.”
  prefs: []
  type: TYPE_NORMAL
- en: Another Pony Power user posted a link to a website for “white people striving
    to be allies in the fight for Black Liberation” and said, “These white allies
    need doxing.” Another wanted to dox members of the Democratic Socialists of America
    and the Southern Poverty Law Center. Some members of the group disagreed about
    the strategy of doxing everyone they didn’t like, though. “Fuck these random ass
    people to be honest,” another user posted. “We need to dox journalists and leadership
    of activist groups.” A person going by the name *Klaus Albricht* suggested, “It’s
    time we start mapping out the liberal teachers of universities.”
  prefs: []
  type: TYPE_NORMAL
- en: '*Albricht* decided to dox a 22-year-old college student because her Facebook
    cover photo showed her wearing a shirt reading “Punch more Nazis,” a reference
    to Richard Spencer, a white supremacist best known for the viral video in which
    he is punched in the face while being interviewed. *Albricht* outlined a plan
    to trick her into clicking a malicious link so he could learn her IP address.
    He also said that he would dox people who liked her shirt. Less than 20 minutes
    later, he posted her home address, what she was studying at college, and links
    to all her social media accounts.'
  prefs: []
  type: TYPE_NORMAL
- en: While writing my story, I reached out to the woman who was doxed. She told me,
    “I never clicked the link because it seemed hella sketch.” She also said that
    she hadn’t gone out to protest fascists and that she was annoyed that they had
    doxed her just because she hurt their feelings. She was “terrified” that they
    had her address because “it’s not just myself who’s at risk, but now also my parents
    who live here as well.”
  prefs: []
  type: TYPE_NORMAL
- en: In the 10 days’ worth of Pony Power chat logs I had at my disposal, I also found
    the fascists doxing Emily Gorcenski, an antifascist data scientist from Charlottesville
    who had witnessed Fields’s car plow into protesters. She’s a trans woman, and
    the fascists posted her deadname (the name she went by before she transitioned)
    and her home address. She has since moved to Germany.
  prefs: []
  type: TYPE_NORMAL
- en: Fascists also doxed 10 alleged members of an antifa group from Gainesville,
    Florida. A user who went by the name *adolphus (not hitler)* posted, “I lost my
    job because of these [homophobic slur]s,” later posting again that he lost his
    job because he attended the Unite the Right rally in Charlottesville, so “I’ve
    got some scores to settle with my local antifa.” I searched the internet for terms
    like *Gainesville Charlottesville fired* and quickly found news articles about
    a Gainesville man who was fired from his job after marching in Charlottesville
    with neo-Nazis. He was a member of the pro-slavery hate group League of the South,
    and he had gotten arrested in Charlottesville for carrying a concealed handgun.
    I tracked down a court document related to his arrest and found one that included
    his phone number. Because I decided to name him in the article, I called him to
    give him a chance to provide his side of the story, per the journalistic practices
    described in [Chapter 1](chapter1.xhtml). To keep my actual phone number private
    from him and the League of the South, I used a new virtual phone number I had
    created just for this purpose (today, I have a public phone number that I use
    solely for communicating with sources like this). I left messages, but he never
    responded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pony Power members also went after Michael Novick, at the time a 70-year-old
    retired teacher from Los Angeles who had been an antifascist activist for over
    50 years. In the late 1980s, Novick helped found a group called Anti-Racist Action,
    and he’s been dealing with threats from neo-Nazis ever since. Because Novick’s
    name appeared on antiracist websites, Pony Power users decided that he must be
    an antifa leader. “Michael is behind what we know as the power structure,” *Albricht*
    posted. The Pony Power users then hit what they believed to be a gold mine: they
    discovered a video of Novick speaking at the 2011 Los Angeles Housing & Hunger
    Crisis Conference in which he said, “I’m of Jewish descent.” “HE ADMITS HE IS
    JEWISH! I KNEW IT!” *Albricht* exclaimed. “We have our link. Antifa is a Jewish
    organization!” He added, “Now let’s tear these [antisemitic slur]s apart!” and
    began inventing an antifa organization chart that placed Novick on top. “This
    man we know for a fact is the leader of Antifa. […] All other branches report
    to him.”'
  prefs: []
  type: TYPE_NORMAL
- en: Novick told me it’s no secret that he’s Jewish. “My father came to the US in
    the early ’30s as a teenager from Poland, and most of his family (many aunts,
    uncles, and cousins) were wiped out by the Nazis either in Bialystok during a
    ghetto rebellion or in the camps,” he said. He also told me that there’s no antifa
    “command structure” or “organization chart.” He added, “Some antifa are Jewish.
    Hardly surprising, given the level of antisemitism displayed by the fascists and
    neo-Nazis.”
  prefs: []
  type: TYPE_NORMAL
- en: According to a story by Unicorn Riot reporter Chris Schiano, the Pony Power
    server was started by Dan Kleve. At the time, Kleve was a biochemistry major at
    the University of Nebraska–Lincoln and a member of the neo-Nazi group Vanguard
    America. After Klein was outed as one of the fascists who marched in Charlottesville,
    people began calling the head of his department to demand that he be expelled.
    Schiano wrote that Kleve created the Pony Power server, in apparent retaliation
    against those demanding his expulsion, “to seek revenge by maliciously publishing
    the personal information of alleged antifascists and encouraging others to harass
    them and bring them harm.”
  prefs: []
  type: TYPE_NORMAL
- en: You can read my full reporting on the Pony Power Discord chat logs at [*https://<wbr>theintercept<wbr>.com<wbr>/2017<wbr>/09<wbr>/06<wbr>/how<wbr>-right<wbr>-wing<wbr>-extremists<wbr>-stalk<wbr>-dox<wbr>-and<wbr>-harass<wbr>-their<wbr>-enemies<wbr>/*](https://theintercept.com/2017/09/06/how-right-wing-extremists-stalk-dox-and-harass-their-enemies/).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Launch of DiscordLeaks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After publishing my Pony Power article, I was sure that there were many more
    revelations spread throughout the hundreds of thousands of messages in the leaked
    chat logs, but I decided I needed a break from Nazis. I wanted to make it possible
    for others to analyze the rest of the Discord servers, though, and I knew from
    my own experience with these datasets that there were technical challenges to
    analyzing them, which is why I developed Discord Analysis to begin with. I spoke
    with the journalists from Unicorn Riot and showed them the Discord Analysis web
    app I had used to write my article. We decided that Unicorn Riot would run a public
    version of this app for researchers, journalists, and members of the public to
    use. This is how DiscordLeaks was born.
  prefs: []
  type: TYPE_NORMAL
- en: DiscordLeaks ([*https://<wbr>discordleaks<wbr>.unicornriot<wbr>.ninja*](https://discordleaks.unicornriot.ninja))
    is a searchable public database designed to make it easy for anyone to access
    the massive corpus of fascist chat logs from hundreds of Discord servers infiltrated
    by antifascists. I and a small team of anonymous developers worked in our spare
    time to add new features to the app and handle the scaling issues that come with
    hosting a public website that gets lots of traffic. We kept the modified source
    code for DiscordLeaks private, but it’s based on the Discord Analysis source code
    that I just described. By late 2017, DiscordLeaks was live, and by early 2018
    it was full of chat logs from several Discord servers uploaded by Unicorn Riot
    journalists, including the one used to organize Unite the Right. The only redactions
    to the chat logs on DiscordLeaks are the PII for victims of doxing and harassment
    by far-right extremists; the rest of the data is fully public.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the years, Unicorn Riot has obtained a steady stream of leaked Discord
    chat logs from fascist groups and continued to index them into DiscordLeaks. I
    eventually stopped contributing to the project myself. In the time I’ve been away,
    it’s matured: the infrastructure is now running in Docker containers, and the
    speed of search has greatly improved thanks to the addition of an Elasticsearch
    database (both technologies were discussed in [Chapter 5](chapter5.xhtml)). Today,
    DiscordLeaks contains millions of messages from nearly 300 Discord servers used
    by the far right, available for the public to research. It also contains chat
    logs from RocketChat servers, which I discuss in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Aftermath</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By 2019, I had stopped writing code for DiscordLeaks myself, but I still kept
    in touch with the developers and promoted the website. I was proud of my role
    in developing this important tool for extremism research, but at the time I still
    had no idea how much positive impact it would ultimately have.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section I’ll discuss two major developments in the DiscordLeaks project
    since I wrote the initial code back in 2017\. In 2021, survivors of the Charlottesville
    terrorist attack won a $25 million settlement against the organizers of Unite
    the Right in a lawsuit made possible, in part, by evidence published on DiscordLeaks.
    DiscordLeaks continues to be a vital tool for extremism researchers: in 2022,
    DiscordLeaks’ anonymous developers updated it to include another major leak of
    neo-Nazi chat logs, this time from the group Patriot Front.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Lawsuit Against
    Unite the Right</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 1871, in response to the wave of racist terrorism against Black people that
    swept the South after the end of the Civil War, the US Congress passed the Ku
    Klux Klan Act. This law allows victims of racist violence to sue the perpetrators
    in civil court. If the victims can prove there was a conspiracy to deprive them
    of their civil rights, they can force the racists to pay monetary damages. This
    is exactly what nine survivors from Charlottesville did.
  prefs: []
  type: TYPE_NORMAL
- en: The plaintiffs in these cases were all Charlottesville residents, some of whom
    were severely injured that day—one suffered a fractured skull, another a broken
    leg and ankle. They filed the Sines v. Kessler lawsuit in October 2017 against
    14 individuals and 10 organizations, with the goal of bankrupting the American
    fascist movement. The individual defendants included Jason Kessler, the primary
    organizer of Unite the Right; James Alex Fields Jr., the neo-Nazi terrorist serving
    a prison sentence for Heather Heyer’s murder; Richard Spencer; and leaders of
    the fascist groups that organized Unite the Right. Defendants also included fascist
    groups themselves like Vanguard America, Traditionalist Worker Party, various
    branches of the Ku Klux Klan, and the National Socialist Movement.
  prefs: []
  type: TYPE_NORMAL
- en: The Charlottesville survivors’ lawsuit was organized and funded by a legal nonprofit
    called Integrity First for America (IFA). The mission of the organization, founded
    in response to the violence of Unite the Right, was “defending democratic norms
    and ensuring equal rights for every American.” Using over 5TB of evidence in the
    form of phone records, text messages, videos from Unite the Right, email messages,
    social media posts, and private messages and chat logs, the plaintiffs successfully
    made their case. IFA made all of the evidence used in the lawsuit available to
    the public at [*https://<wbr>www<wbr>.integrityfirstforamerica<wbr>.org<wbr>/exhibits*](https://www.integrityfirstforamerica.org/exhibits).
  prefs: []
  type: TYPE_NORMAL
- en: On its blog, IFA explained that while its lawyers did eventually get copies
    of the neo-Nazi chat logs directly from Discord as part of the lawsuit’s discovery
    process, DiscordLeaks provided “an immense amount” of detail before the lawsuit
    was filed. In the chat logs published by Unicorn Riot, Unite the Right attendees
    discussed whether they could hit protesters with cars and then claim self-defense,
    which is what happened. This evidence “provided crucial early information that
    made the speed and breadth of the initial complaint possible.”
  prefs: []
  type: TYPE_NORMAL
- en: In November 2021, the court found the fascist organizers guilty and ordered
    them to pay over $25 million in damages. In late 2022, IFA wound down its operations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Patriot Front
    Chat Logs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the aftermath of the violent Unite the Right protests in Charlottesville,
    one of the neo-Nazi groups in attendance, Vanguard America, broke apart due to
    infighting. Out of the ashes of Vanguard America, a new fascist group called Patriot
    Front was born. Patriot Front, based out of Texas, is known for requiring members
    to do weekly “activism” involving vandalizing property with racist messages and
    posting Patriot Front propaganda, like stickers, all over the place. According
    to the Anti-Defamation League, Patriot Front was responsible for 82 percent of
    all reported incidents in 2021 involving the distribution of racist, antisemitic,
    and other hateful propaganda in the US.
  prefs: []
  type: TYPE_NORMAL
- en: In January 2022, someone hacked Patriot Front and leaked 400GB of data to Unicorn
    Riot, including thousands of messages posted to the group’s internal RocketChat
    server, an open source chat platform that anyone can host themselves. Unicorn
    Riot collaborated with DDoSecrets to publish the 400GB Patriot Front dataset,
    which you can find at [*https://<wbr>ddosecrets<wbr>.com<wbr>/wiki<wbr>/Patriot<wbr>_Front*](https://ddosecrets.com/wiki/Patriot_Front).
    In response to this leak, the DiscordLeaks developers also updated the app to
    include support for RocketChat, and they imported over 12,000 new messages into
    it from two Patriot Front chat servers. You can find Patriot Front’s chat logs
    at [*https://<wbr>discordleaks<wbr>.unicornriot<wbr>.ninja<wbr>/rocket<wbr>-chat<wbr>/*](https://discordleaks.unicornriot.ninja/rocket-chat/).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-6](#fig14-6) shows a still from a video in the Patriot Front dataset
    of members reading their manifesto and chanting “Life, liberty, victory!” The
    video includes a few seconds at the end where one of the neo-Nazis, apparently
    thinking the recording was over, yells, “Seig fucking Heil!”'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot from a Patriot Front video. It shows five men wearing identical
    uniforms that include hats, sunglasses, and face masks. Four of the men are standing
    in front of fascist flags, and one is sitting at a table reading a statement.](Images/Figure14-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: Patriot Front
    members, from a video in the hacked dataset</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the American fascist movement has steadily grown since the election
    of Donald Trump in 2016\. But there’s a wealth of public datasets about this movement,
    just waiting for researchers like you to dig in and expose it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned how antifascists infiltrated the Discord servers
    used by the American fascist movement, including organizers of the deadly Unite
    the Right rally in 2017, and leaked millions of chat logs to Unicorn Riot in JSON
    format. You saw how I went about analyzing these JSON files to understand their
    structure, how the custom Flask and SQLAlchemy web app I built worked under the
    hood, and how the app ultimately became DiscordLeaks. I also described my own
    investigation into the Pony Power server that fascists used to dox their enemies.
    Finally, you read about the amazing results from the Sines v. Kessler lawsuit
    and the continued success of DiscordLeaks tools.
  prefs: []
  type: TYPE_NORMAL
