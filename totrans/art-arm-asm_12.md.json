["```\n// Assume nibbleIn is in the range 0-15: \n\ncharOut = nibbleIn + '0'; \nif(charOut > '9') charOut = charOut + ('A' - '9' - 1); \n```", "```\n// Listing9-1.S \n\n#include \"aoaa.inc\"\n\n            proc    btoh_simple \n            and     x1, x1, #0xFF   // Ensure only 8 bits. \n            mov     x0, x1          // Save LO nibble. \n\n            // Process the HO nibble: \n\n          ❶ lsr     x1, x1, #4      // Move HO nibble to LO posn. \n            orr     x1, x1, #'0'    // Convert to 0x30 to 0x3F. \n            cmp     x1, #'9'        // See if 0x3A to 0x3F. \n            bls     le9as \n            add     x1, x1, #7      // Convert 0x3A to 0x3F to \n le9as:                             // 'A' through 'F'. \n\n            // Process the LO nibble: \n\n          ❷ and     x0, x0, #0xF    // Strip away HO nibble. \n            orr     x0, x0, #'0'    // Convert to 0x30 to 0x3F. \n            cmp     x0, #'9'        // See if 0x3A to 0x3F. \n            bls     le9bs \n            add     x0, x0, #7      // Convert 0x3A to 0x3F to \n le9bs:                             // 'A' through 'F'. \n            // Merge the 2 bytes into X1\\. \n\n            orr     x1, x1, x0, lsl #8 \n            ret \n            endp    btoh_simple \n```", "```\n// Listing9-2.S \n\n#include \"aoaa.inc\"\n\n`Include both simple and other code here necessary for a working program.` \n\n            proc    asmMain, public \n\n            locals  am                  // Preserve the X20 and \n            dword   saveX20             // X21 registers that \n            dword   saveX21             // this program uses \n            byte    stackspace, 64      // as loop-control \n            endl    am                  // variables. \n\n            enter   am.size    // Create activation record. \n\n            str     x20, [fp, #saveX20] // Preserve nonvolatile \n            str     x21, [fp, #saveX21] // registers. \n\n// Outer loop executes 10,000,000 times: \n\n            ldr     x20, =10000000 \nouter: \n\n// Inner loop executes 256 times, once for each byte value. \n// It just calls the btoh_*** function and ignores the \n// return value. Do this to measure the speed of the \n// function. \n\n#define funcToCall btoh_x1 // btoh_x1, btoh2, btoh_nob, or btoh_simple \n\n            mov     x21, #256 \ninner:      add     x1, x20, #-1 \n            bl      funcToCall \n            adds    x21, x21, #-1 \n            bne     inner \n            adds    x20, x20, #-1 \n            bne     outer \n\n            mov     x1, #0x9a       // Value to test \n            mov     x6, x1          // Save for later. \n            bl      funcToCall \n\n            // Print btoh_*** return result: \n\n            and     x2, x1, #0xff   // Print HO nibble first. \n            mstr    x2, [sp, #8] \n            lsr     x3, x1, #8      // Print LO nibble second. \n mstr    x3, [sp, #16] \n            mov     x1, x6          // Retrieve save value. \n            mstr    x1, [sp] \n            lea     x0, fmtStr1 \n            bl      printf \n            ldr     x21, [fp, #saveX21] // Restore nonvolatile \n            ldr     x20, [fp, #saveX20] // registers. \n            leave \n            ret \n\n            endp    asmMain \n```", "```\n$ ./build Listing9-2 \n$ time ./Listing9-2 \nCalling Listing9-2: \nValue=9a, as hex=9A \nListing9-2 terminated \n./Listing9-2  3.49s user 0.01s system 98% cpu 3.542 total \n```", "```\n// Listing9-3.S \n\n `Usual header code snipped` \n\n// dtobuf \n//\n// Convert a dword to a string of 16 hexadecimal digits. \n//\n// Inputs: \n//  X0-     Pointer to the buffer. Must have at least \n//          17 bytes available. \n//  X1-     Value to convert \n//\n// Outputs: \n//  X0-     Points at zero-terminating byte at the end \n//          of the converted string \n//\n// Note:    This function does not preserve any registers. \n//          It is the caller's responsibility to preserve \n//          registers. \n//\n//          Registers modified: X0, X2 \n\n            proc    dtobuf \n\n#define AtoF   ('A'-'9'-1) \n\n            // Process the HO nibble: \n\n          ❶ lsr     x2, x1, #60 \n            orr     w2, w2, #'0'    // Convert to 0x30 to 0x3F. \n            cmp     w2, #'9'        // See if 0x3A to 0x3F. \n            bls     dec15           // Skip if 0 to 9\\. \n            add     w2, w2, #AtoF   // If it was A to F \n dec15: \n            strb    w2, [x0], #1    // Store byte to memory. \n\n            // Process nibble 14: \n\n            lsr     x2, x1, #56     // See comments for HO nibble. \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec14 \n            add     w2, w2, #AtoF \ndec14:      strb    w2, [x0], #1 \n\n            // Process nibble 13: \n\n            lsr     x2, x1, #52 \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec13 \n            add     w2, w2, #AtoF \ndec13:      strb    w2, [x0], #1 \n\n            // Process nibble 12: \n\n            lsr     x2, x1, #48 \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec12 \n            add     w2, w2, #AtoF \ndec12:      strb    w2, [x0], #1 \n\n            // Process nibble 11: \n\n            lsr     x2, x1, #44 \n            and     x2, x2, 0xf \n orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec11 \n            add     w2, w2, #AtoF \ndec11:      strb    w2, [x0], #1 \n\n            // Process nibble 10: \n\n            lsr     x2, x1, #40 \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec10 \n            add     w2, w2, #AtoF \ndec10:      strb    w2, [x0], #1 \n\n            // Process nibble 9: \n\n            lsr     x2, x1, #36 \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec9 \n            add     w2, w2, #AtoF \ndec9:       strb    w2, [x0], #1 \n\n            // Process nibble 8: \n\n            lsr     x2, x1, #32 \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec8 \n            add     w2, w2, #AtoF \ndec8:       strb    w2, [x0], #1 \n\n// Entry point for wtobuf \n//\n// wtobuf \n//\n// Convert a word to a string of 8 hexadecimal digits. \n//\n// Inputs: \n//  X0-     Pointer to the buffer. Must have at least \n//          9 bytes available. \n//  X1-     Value to convert \n//\n// Outputs: \n//  X0-     Points at zero-terminating byte at the end \n//          of the converted string \n//\n// Note:    This function does not preserve any registers. \n//          It is the caller's responsibility to preserve \n//          registers. \n//\n//          Registers modified: X0, X2 \n\n❷ wtobuf: \n            // Process nibble 7: \n\n            lsr     x2, x1, #28 // See comments for nibble 15\\. \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec7 \n            add     w2, w2, #AtoF \ndec7:       strb    w2, [x0], #1 \n\n            // Process nibble 6: \n\n            lsr     x2, x1, #24 \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec6 \n            add     w2, w2, #AtoF \ndec6:       strb    w2, [x0], #1 \n\n            // Process nibble 5: \n\n            lsr     x2, x1, #20 \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec5 \n            add     w2, w2, #AtoF \ndec5:       strb    w2, [x0], #1 \n\n            // Process nibble 4: \n\n            lsr     x2, x1, #16 \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec4 \n            add     w2, w2, #AtoF \ndec4:       strb    w2, [x0], #1 \n\n// Entry point for htobuf: \n//\n// htobuf \n//\n// Convert a half word to a string of 4 hexadecimal digits. \n//\n// Inputs: \n//  X0-     Pointer to the buffer. Must have at least \n//          5 bytes available. \n//  X1-     Value to convert \n//\n// Outputs: \n//  X0-     Points at zero-terminating byte at the end \n//          of the converted string \n//\n// Note:    This function does not preserve any registers. \n//          It is the caller's responsibility to preserve \n//          registers. \n//\n//          Registers modified: X0, X2 \n\n❸ htobuf: \n            // Process nibble 3: \n\n            lsr     x2, x1, #12 // See comments for nibble 15\\. \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec3 \n            add     w2, w2, #AtoF \ndec3:       strb    w2, [x0], #1 \n\n            // Process nibble 2: \n\n            lsr     x2, x1, #8 \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec2 \n            add     w2, w2, #AtoF \ndec2:       strb    w2, [x0], #1 \n\n// Entry point for btobuf: \n//\n// btobuf \n//\n// Convert a byte to a string of two hexadecimal digits. \n//\n// Inputs: \n//  X0-     Pointer to the buffer. Must have at least \n//          3 bytes available. \n//  X1-     Value to convert \n//\n// Outputs: \n//  X0-     Points at zero-terminating byte at the end \n//          of the converted string \n//\n// Note:    This function does not preserve any registers. \n//          It is the caller's responsibility to preserve \n//          registers. \n//\n//          Registers modified: X0, X2 \n\n // Process nibble 1: \n\n❹ btobuf: \n            lsr     x2, x1, #4      // See comments for nibble 15\\. \n            and     x2, x2, 0xf \n            orr     w2, w2, #'0' \n            cmp     w2, #'9' \n            bls     dec1 \n            add     w2, w2, #AtoF \ndec1:       strb    w2, [x0], #1 \n\n            // Process LO nibble: \n\n            and     x2, x1, 0xf \n            orr     x2, x2, #'0' \n            cmp     w2, #'9' \n            bls     dec0 \n            add     w2, w2, #AtoF \ndec0:       strb    w2, [x0], #1 \n\n            strb    wzr, [x0]       // Zero-terminate. \n            ret \n            endp    dtobuf \n```", "```\n// Listing9-4.S \n//\n// btoStr, htoStr, wtoStr, and dtoStr functions \n// Also includes btobuf, htobuf, wtobuf, and \n// dtobuf functions \n\n            #include    \"aoaa.inc\"\n\n            .section    .rodata, \"\" \nttlStr:     .asciz      \"Listing 9-4\"\n\n            .data \n\n// Buffer space used by main program \n\nbuffer:     .space      256,0 \n\n            .code \n            .extern     printf \n\n// Return program title to C++ program: \n\n            proc    getTitle, public \n            lea     x0, ttlStr \n            ret \n            endp    getTitle \n\n❶ `Insert the code for dtobuf here. See Listing 9-3.` \n\n// btoStr-\n//\n// Inputs: \n//\n//  X0- Pointer to buffer that will hold the result \n//      (must allocate at least 3 bytes for buffer) \n//  X1- Value to print (in LO byte) \n//\n// Outputs: \n//\n//  Buffer pointed at by X0 receives the two-character \n//  conversion of the value in X1 to a hexadecimal string. \n//\n//  Preserves all registers. \n\n          ❷ proc    btoStr \n\n            str     x2, [sp, #-16]! \n            stp     x0, lr, [sp, #-16]! \n\n bl      btobuf \n\n            // Restore registers and return: \n\n            ldp     x0, lr, [sp], #16 \n            ldr     x2, [sp], #16 \n            ret \n            endp    btoStr \n\n// htoStr \n//\n// Inputs: \n//\n//  X0- Pointer to buffer that will hold the result \n//      (must allocate at least 5 bytes for buffer) \n//  X1- Value to print (in LO hword) \n//\n// Outputs: \n//\n//  Buffer pointed at by X0 receives the four-character \n//  conversion of the hword value in X1 to a hexadecimal string. \n//\n//  Preserves all registers \n\n          ❸ proc    htoStr \n\n            str     x2, [sp, #-16]! \n            stp     x0, lr, [sp, #-16]! \n\n            bl      htobuf \n\n            // Restore registers and return: \n\n            ldp     x0, lr, [sp], #16 \n            ldr     x2, [sp], #16 \n            ret \n            endp    htoStr \n\n// wtoStr \n//\n// Inputs: \n//\n//  X0- Pointer to buffer that will hold the result \n//      (must allocate at least 9 bytes for buffer) \n//  X1- Value to print (in LO word) \n//\n// Outputs: \n//\n//  Buffer pointed at by X0 receives the eight-character \n//  conversion of the word value in X1 to a hexadecimal string. \n//\n//  Preserves all registers \n\n          ❹ proc    wtoStr \n\n str     x2, [sp, #-16]! \n            stp     x0, lr, [sp, #-16]! \n\n            bl      wtobuf \n\n            // Restore registers and return: \n\n            ldp     x0, lr, [sp], #16 \n            ldr     x2, [sp], #16 \n            ret \n            endp    wtoStr \n\n// dtoStr \n//\n// Inputs: \n//\n//  X0- Pointer to buffer that will hold the result \n//      (must allocate at least 17 bytes for buffer) \n//  X1- Value to print \n//\n// Outputs: \n//\n//  Buffer pointed at by X0 receives the 16-character \n//  conversion of the dword value in X1 to a hexadecimal string. \n//\n//  Preserves all registers \n\n          ❺ proc    dtoStr \n\n            str     x2, [sp, #-16]! \n            stp     x0, lr, [sp, #-16]! \n\n            bl      dtobuf \n\n            // Restore registers and return: \n\n            ldp     x0, lr, [sp], #16 \n            ldr     x2, [sp], #16 \n            ret \n            endp    dtoStr \n\n// Utility functions to print bytes, hwords, words, and dwords: \n\npbStr:      wastr   \"Byte=%s\\n\"\n\n            proc    pByte \n\n            locals  pb \n            qword   pb.saveX0X1 \n            byte    pb.buffer, 32 \n            byte    pb.stkSpace, 64 \n            endl    pb \n\n            enter   pb.size \n            stp     x0, x1, [fp, #pb.saveX0X1] \n\n mov     x1, x0 \n            add     x0, fp, #pb.buffer  // lea x0, stkSpace \n            bl      btoStr \n\n            lea     x0, pbStr \n            add     x1, fp, #pb.buffer \n            mstr    x1, [sp] \n            bl      printf \n\n            ldp     x0, x1, [fp, #pb.saveX0X1] \n            leave \n            endp    pByte \n\nphStr:      wastr   \"Hword=%s\\n\"\n\n            proc    pHword \n\n            locals  ph \n            qword   ph.saveX0X1 \n            byte    ph.buffer, 32 \n            byte    ph.stkSpace, 64 \n            endl    ph \n\n            enter   ph.size \n            stp     x0, x1, [fp, #ph.saveX0X1] \n\n            mov     x1, x0 \n            add     x0, fp, #ph.buffer  // lea x0, stkSpace \n            bl      htoStr \n\n            lea     x0, phStr \n            add     x1, fp, #ph.buffer \n            mstr    x1, [sp] \n            bl      printf \n\n            ldp     x0, x1, [fp, #ph.saveX0X1] \n            leave \n            endp    pHword \n\npwStr:      wastr   \"Word=%s\\n\"\n\n            proc    pWord \n\n            locals  pw \n            qword   pw.saveX0X1 \n            byte    pw.buffer, 32 \n            byte    pw.stkSpace, 64 \n            endl    pw \n\n            enter   pw.size \n            stp     x0, x1, [fp, #pw.saveX0X1] \n\n            mov     x1, x0 \n            add     x0, fp, #pw.buffer  // lea x0, stkSpace \n            bl      wtoStr \n\n lea     x0, pwStr \n            add     x1, fp, #pw.buffer \n            mstr    x1, [sp] \n            bl      printf \n\n            ldp     x0, x1, [fp, #pw.saveX0X1] \n            leave \n            endp    pWord \n\npdStr:      wastr   \"Dword=%s\\n\"\n\n            proc    pDword \n\n            locals  pd \n            qword   pd.saveX0X1 \n            byte    pd.buffer, 32 \n            byte    pd.stkSpace, 64 \n            endl    pd \n\n            enter   pd.size \n            stp     x0, x1, [fp, #pd.saveX0X1] \n\n            mov     x1, x0 \n            add     x0, fp, #pd.buffer  // lea x0, stkSpace \n            bl      dtoStr \n\n            lea     x0, pdStr \n            add     x1, fp, #pd.buffer \n            mstr    x1, [sp] \n            bl      printf \n\n            ldp     x0, x1, [fp, #pd.saveX0X1] \n            leave \n            endp    pDword \n\n// Here is the asmMain function: \n\n            proc    asmMain, public \n\n            // Local storage: \n\n            locals  am \n            byte    stackspace, 64 \n            endl    am \n\n            enter   am.size             // Create activation record. \n\n            ldr     x0, =0x0123456789abcdef \n            bl      pByte \n            bl      pHword \n            bl      pWord \n            bl      pDword \n\n            leave \n ret \n\n            endp    asmMain \n```", "```\n$ ./build Listing9-4 \n$ ./Listing9-4 \nCalling Listing9-4: \nByte=EF \nHword=CDEF \nWord=89ABCDEF \nDword=0123456789ABCDEF \nListing9-4 terminated \n```", "```\n// Listing9-5.S \n//\n// qtoStr \n//\n// Inputs: \n//\n//  X0-     Pointer to buffer that will hold the result \n//          (must allocate at least 33 bytes for buffer) \n//  X2:X1-  Value to print \n//\n// Outputs: \n//\n//  Buffer pointed at by X0 receives the 32-character \n//  conversion of the dword value in X2:X1 to a hexadecimal string. \n//\n//  Preserves all registers \n\n            proc    qtoStr \n\n            str     x2, [sp, #-16]! \n            stp     x0, lr, [sp, #-16]! \n            str     x1, [sp, #-16]!     // Save for later. \n\n            mov     x1, x2              // Convert HO dword first. \n            bl      dtobuf \n            ldr     x1, [sp], #16       // Restore X1 value. \n            bl      dtobuf \n\n            // Restore registers and return: \n\n            ldp     x0, lr, [sp], #16 \n            ld4     x2, [sp], #16 \n            ret \n            endp    qtoStr \n```", "```\n// Listing9-6.S \n//\n// u64toBuf function \n\n            #include    \"aoaa.inc\"\n\n            .section    .rodata, \"\" \nttlStr:     .asciz      \"Listing 9-6\"\nfmtStr1:    .asciz      \"Value(%llu) = string(%s)\\n\"\n\n            .align      3 \nqwordVal:   .dword      0x1234567890abcdef \n            .dword      0xfedcba0987654321 \n\n            .data \nbuffer:     .space      256,0 \n\n            .code \n            .extern     printf \n\n// Return program title to C++ program: \n\n proc    getTitle, public \n            lea     x0, ttlStr \n            ret \n            endp    getTitle \n\n// u64ToStr \n//\n//  Converts a 64-bit unsigned integer to a string \n//\n//  Inputs: \n//      X0-     Pointer to buffer to receive string \n//      X1-     Unsigned 64-bit integer to convert \n//\n//  Outputs: \n//      Buffer- Receives the zero-terminated string \n//\n//  Buffer must have at least 21 bytes allocated for it. \n//  This function preserves all registers. \n\n          ❶ proc    u64ToStr \n            stp     x0, x1, [sp, #-16]! \n            stp     x2, x3, [sp, #-16]! \n            str     lr, [sp, #-16]! \n\n            bl      u64ToBuf \n\n            ldr     lr, [sp], #16 \n            ldp     x2, x3, [sp], #16 \n            ldp     x0, x1, [sp], #16 \n            ret \n            endp    u64ToStr \n\n// u64ToBuf \n//\n//  Converts a 64-bit unsigned integer to a string \n//\n//  Inputs: \n//      X0-     Pointer to buffer to receive string \n//      X1-     Unsigned 64-bit integer to convert \n//\n//  Outputs: \n//      X0-     Points at zero-terminating byte \n//      Buffer- Receives the zero-terminated string \n//\n//  Buffer must have at least 21 bytes allocated for it. \n//\n//  Caller must preserve X0, X1, X2, and X3! \n\n          ❷ proc    u64ToBuf \n            cmp     x1, xzr         // See if X1 is 0\\. \n            bne     u64ToBufRec \n\n            // Special case for zero, just write \n            // \"0\" to the buffer. Leave X0 pointing \n // at the zero-terminating byte. \n\n            mov     w1, #'0' \n            strh    w1, [x0], #1    // Also emits zero byte \n            ret \n            endp    u64ToBuf \n\n// u64ToBufRec is the recursive version that handles \n// nonzero values: \n\n          ❸ proc    u64ToBufRec \n            stp     x2, lr, [sp, #-16]! // Preserve remainder. \n\n            // Divide X1 by 10 and save quotient and remainder: \n\n          ❹ mov     x2, #10 \n            udiv    x3, x1, x2      // X3 = quotient \n            msub    x2, x3, x2, x1  // X2 = remainder \n\n            // Make recursive call if quotient is not 0: \n\n            cmp     x3, xzr \n            beq     allDone \n\n          ❺ mov     x1, x3              // Set up for call. \n            bl      u64ToBufRec \n\n            // When this function has processed all the \n            // digits, write them to the buffer. Also \n            // write a zero-terminating byte, in case \n            // this is the last digit to output. \n\n❻ allDone:    orr     w2, w2, #'0'    // Convert to char. \n            strh    w2, [x0], #1    // Bump pointer after store. \n          ❼ ldp     x2, lr, [sp], #16 \n            ret \n            endp    u64ToBufRec \n\n// Here is the \"asmMain\" function. \n\n            proc    asmMain, public \n\n            enter   64              // Reserve space on stack. \n\n// Test u64ToBuf: \n\n            mov     x1, 0xFFFF \n            movk    x1, 0xFFFF, lsl #16 \n            movk    x1, 0xFFFF, lsl #32 \n            movk    x1, 0xFFFF, lsl #48 \n            lea     x0, buffer \n            bl      u64ToStr \n\n            lea     x2, buffer \n mstr    x2, [sp, #8] \n            mov     x1, 0xFFFF \n            movk    x1, 0xFFFF, lsl #16 \n            movk    x1, 0xFFFF, lsl #32 \n            movk    x1, 0xFFFF, lsl #48 \n            mstr    x1, [sp] \n            lea     x0, fmtStr1 \n            bl      printf \n\n            leave \n            ret \n            endp    asmMain \n```", "```\n$ ./build Listing9-6 \n$ ./Listing9-6 \nCalling Listing9-6: \nValue(18446744073709551615) = string(18446744073709551615) \nListing9-6 terminated \n```", "```\n// Listing9-7.S \n//\n// u64toStr function (nonrecursive, straight-line \n// code version) \n\n            #include    \"aoaa.inc\"\n\n            .section    .rodata, \"\" \nttlStr:     .asciz      \"Listing 9-7\"\nfmtStr1:    .asciz      \"low=%s, \" \nfmtStr2:    .asciz      \"hi=%s\\n\"\n\nloData:     .dword      0, 1, 10, 100, 1000, 10000, 100000 \n            .dword      1000000, 10000000, 100000000 \n            .dword      1000000000, 10000000000, 100000000000 \n            .dword      1000000000000, 10000000000000 \n            .dword      100000000000000, 1000000000000000 \n            .dword      10000000000000000, 100000000000000000 \n            .dword      1000000000000000000, 10000000000000000000 \n            .equ        dataCnt, .-loData \n\nhiData:     .dword      9, 9, 99, 999, 9999, 99999, 999999 \n            .dword      9999999, 99999999, 999999999 \n            .dword      9999999999, 99999999999, 999999999999 \n            .dword      9999999999999, 99999999999999 \n            .dword      999999999999999, 9999999999999999 \n            .dword      99999999999999999, 999999999999999999 \n            .dword      9999999999999999999 \n            .dword      -1 \n\n            .data \nbuffer:     .space      256, 0 \n\n            .code \n            .extern     printf \n\n// Return program title to C++ program: \n\n            proc    getTitle, public \n            lea     x0, ttlStr \n            ret \n            endp    getTitle \n\n// u64ToBuf \n//\n//  Converts a 64-bit unsigned integer to a string \n//\n//  Inputs: \n//      X0-     Pointer to buffer to receive string \n//      X1-     Unsigned 64-bit integer to convert \n//\n//  Outputs: \n//      Buffer- Receives the zero-terminated string \n//      X0-     Points at zero-terminating byte in string \n//\n//  Buffer must have at least 21 bytes allocated for it. \n//  Note: Caller is responsible for preserving X0-X7! \n\n          ❶ proc    u64ToBuf \n\n          ❷ mov     x4, #10 \n            mov     x5, xzr \n            mov     x6, xzr \n            mov     x7, xzr \n\n            // Handle the LO digit here: \n\n          ❸ udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n            cmp     x2, #0 \n            beq     allDone1 \n\n            // Handle the 10's digit here: \n\n          ❹ udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n            cmp     x1, #0 \n            beq     allDone2 \n\n            // Handle the 100's digit here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n            cmp     x2, #0 \n            beq     allDone3 \n\n            // Handle the 1000's digit here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n            cmp     x1, #0 \n            beq     allDone4 \n\n            // Handle the 10,000's digit here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n            cmp     x2, #0 \n            beq     allDone5 \n\n            // Handle the 100,000's digit here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n            cmp     x1, #0 \n            beq     allDone6 \n\n            // Handle the 1,000,000's digit here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x6, x3, #'0' \n            cmp     x2, #0 \n            beq     allDone7 \n\n            // Handle the 10,000,000's digit here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x6, x3, x6, lsl #8 \n            cmp     x1, #0 \n            beq     allDone8 \n\n            // Handle the 100,000,000's digit here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x6, x3, x6, lsl #8 \n            cmp     x2, #0 \n            beq     allDone9 \n\n            // Handle the 1,000,000,000's digit here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x6, x3, x6, lsl #8 \n            cmp     x1, #0 \n            beq     allDone10 \n\n            // Handle the 10,000,000,000's digit here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n orr     x3, x3, #'0' \n            orr     x6, x3, x6, lsl #8 \n            cmp     x2, #0 \n            beq     allDone11 \n\n            // Handle the 100,000,000,000's digit here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x6, x3, x6, lsl #8 \n            cmp     x1, #0 \n            beq     allDone12 \n\n            // Handle the 1,000,000,000,000's digit here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x6, x3, x6, lsl #8 \n            cmp     x2, #0 \n            beq     allDone13 \n\n            // Handle the 10,000,000,000,000's digit here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x6, x3, x6, lsl #8 \n            cmp     x1, #0 \n            beq     allDone14 \n\n            // Handle the 100,000,000,000,000's digit here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x7, x3, #'0' \n            orr     x6, x3, x6, lsl #8\n            cmp     x2, #0 \n            beq     allDone15 \n\n            // Handle the 1,000,000,000,000,000's digit here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x7, x3, x7, lsl #8 \n            cmp     x1, #0 \n            beq     allDone16 \n\n            // Handle the 10,000,000,000,000,000's digit here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n orr     x3, x3, #'0' \n            orr     x7, x3, x7, lsl #8     \n            cmp     x2, #0 \n            beq     allDone17 \n\n            // Handle the 100,000,000,000,000,000's digit here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x7, x3, x7, lsl #8 \n            cmp     x1, #0 \n            beq     allDone18 \n\n            // Handle the 1,000,000,000,000,000,000's digit here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x7, x3, x7, lsl #8 \n            cmp     x2, #0 \n            beq     allDone19 \n\n          ❺ udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x7, x3, x7, lsl #8 \n\nallDone20:  str     x7, [x0], #6 \n            str     x6, [x0], #8 \n            str     x5, [x0], #7 \n            ret \n\n            // When this function has processed all the \n            // digits, write them to the buffer. Also \n            // write a zero-terminating byte, in case \n            // this is the last digit to output. \n\n❻ allDone1: strh    w5, [x0], #1 \n            ret \n\n  allDone2: strh    w5, [x0], #2 \n            strb    wzr, [x0] \n            ret \n\n  allDone3: str     w5, [x0], #3 \n            ret \n\n  allDone4: str     w5, [x0], #4 \n            strb    wzr, [x0] \n            ret \n\n  allDone5: str     x5, [x0], #4 \n            lsr     x5, x5, #32 \n strh    w5, [x0], #1 \n            ret \n\n  allDone6: str     w5, [x0], #4 \n            lsr     x5, x5, #32 \n            strh    w5, [x0], #2 \n            strb    wzr, [x0] \n            ret \n\n❼ allDone7: strb    w6, [x0], #1 \n            str     x5, [x0], #7 \n            ret \n\n  allDone8: strh    w6, [x0], #2 \n            str     x5, [x0], #7    // Writes an extra garbage byte \n            ret \n\n  allDone9: str     w6, [x0], #3 \n            str     x5, [x0], #7 \n            ret \n\n  allDone10: \n            str     w6, [x0], #4 \n            str     x5, [x0], #7 \n            ret \n\n  allDone11: \n            str     x6, [x0], #5 \n            str     x5, [x0], #7 \n            ret \n\n  allDone12: \n            str     x6, [x0], #6 \n            str     x5, [x0], #7 \n            ret \n\n  allDone13: \n            str     x6, [x0], #7 \n            str     x5, [x0], #7 \n            ret \n\n  allDone14: \n\n            str     x6, [x0], #8 \n            str     x5, [x0], #7 \n            ret \n\n❽ allDone15: \n            strb    w7, [x0], #1 \n            str     x6, [x0], #8 \n            str     x5, [x0], #7 \n            ret \n\n  allDone16: \n            strh    w7, [x0], #2 \n            str     x6, [x0], #8 \n str     x5, [x0], #7 \n            ret \n\n  allDone17: \n            str     w7, [x0], #3 \n            str     x6, [x0], #8 \n            str     x5, [x0], #7 \n            ret \n\n  allDone18: \n            str     w7, [x0], #4 \n            str     x6, [x0], #8 \n            str     x5, [x0], #7 \n            ret \n\n  allDone19: \n            str     x7, [x0], #5 \n            str     x6, [x0], #8 \n            str     x5, [x0], #7 \n            ret \n            endp    u64ToBuf \n\n// u64ToStr \n//\n//  Version of u64ToBuf that preserves the registers \n\n          ❾ proc    u64ToStr \n            stp     x0, x1, [sp, #-16]! // Preserve registers. \n            stp     x2, x3, [sp, #-16]! \n            stp     x4, x5, [sp, #-16]! \n            stp     x6, x7, [sp, #-16]! \n            str     lr, [sp, #-16]! \n            bl      u64ToBuf \n            ldr     lr, [sp], #16 \n            ldp     x6, x7, [sp], #16   // Restore registers. \n            ldp     x4, x5, [sp], #16 \n            ldp     x2, x3, [sp], #16 \n            ldp     x0, x1, [sp], #16 \n            ret \n            endp    u64ToStr \n\n// Here is the asmMain function: \n\n            proc    asmMain, public \n\n            locals  am \n            qword   am.x20_x21 \n            dword   am.x22 \n            byte    stk, 64 \n            endl    am \n\n            enter   am.size             // Create act rec. \n\n // Preserve nonvolatile registers: \n\n            stp     x20, x21, [fp, #am.x20_x21] \n            str     x22, [fp, #am.x22] \n\n            lea     x20, loData \n            lea     x21, hiData \n            mov     x22, xzr \n loop: \n            lea     x0, buffer \n            ldr     x1, [x20, x22, lsl #3] \n            bl      u64ToStr \n\n            lea     x0, fmtStr1 \n            lea     x1, buffer \n            mstr    x1, [sp] \n            bl      printf \n\n            lea     x0, buffer \n            ldr     x1, [x21, x22, lsl #3] \n            bl      u64ToStr \n\n            lea     x0, fmtStr2 \n            lea     x1, buffer \n            mstr    x1, [sp] \n            bl      printf \n\n            add     x22, x22, #1 \n            cmp     x22, #(dataCnt / 8) \n            blo     loop \n\n            ldr     x22, [fp, #am.x22] \n            ldp     x20, x21, [fp, #am.x20_x21] \n\n            leave \n            endp    asmMain \n```", "```\n$ ./build Listing9-7 \n$ time ./Listing9-7 \nCalling Listing9-7: \nlow=0, hi=9 \nlow=1, hi=9 \nlow=10, hi=99 \nlow=100, hi=999 \nlow=1000, hi=9999 \nlow=1000, hi=9999 \nlow=100000, hi=999999 \nlow=1000000, hi=9999999 \nlow=10000000, hi=99999999 \nlow=100000000, hi=999999999 \nlow=1000000000, hi=9999999999 \nlow=10000000000, hi=99999999999 \nlow=100000000000, hi=999999999999 \nlow=1000000000000, hi=9999999999999 \nlow=10000000000000, hi=99999999999999 \nlow=100000000000000, hi=999999999999999 \nlow=1000000000000000, hi=9999999999999999 \nlow=10000000000000000, hi=99999999999999999 \nlow=100000000000000000, hi=999999999999999999 \nlow=1000000000000000000, hi=9999999999999999999 \nlow=10000000000000000000, hi=18446744073709551615 \nListing9-7 terminated \n```", "```\nListing9-7a  404.58s user 0.42s system 99% cpu 6:46.25 total \n```", "```\nListing9-7a  173.60s user 0.15s system 99% cpu 2:53.78 total \n```", "```\n// Listing9-8.S \n\n`Code taken from Listing 9-7 goes here.` \n\n// i64ToStr \n//\n//  Converts a signed 64-bit integer to a string \n//  If the number is negative, this function will \n//  print a '-' character followed by the conversion \n//  of the absolute value of the number. \n//\n// Inputs: \n//\n//      X0- Pointer to buffer to hold the result. \n//          Buffer should be capable of receiving \n//          as many as 22 bytes (including zero-\n//          terminating byte). \n//      X1- Signed 64-bit integer to convert \n//\n// Outputs: \n//\n//      Buffer- Contains the converted string \n\n            proc    i64ToStr \n\n            locals  i64 \n            dword   i64.x0 \n            byte    i64.stk, 32 \n            endl    i64 \n\n            enter   i64.size \n\n            // Need to preserve X1 in \n            // case this code negates it. \n\n            str     x1, [fp, #i64.x0] \n\n            cmp     x1, #0 \n            bpl     isPositive \n\n            mov     w1, #'-'    // Emit '-' \n            strb    w1, [x0], #1 \n\n            // Negate X0 and convert \n            // unsigned value to integer: \n\n            ldr     x1, [fp, #i64.x0] \n            neg     x1, x1 \n\nisPositive: bl      u64ToStr \n            ldr     x1, [fp, #i64.x0] \n            leave \n            endp    i64ToStr \n\n`Code taken from Listing 9-7 goes here.` \n```", "```\n// Listing9-9.S \n//\n// u128toStr function \n\n            #include    \"aoaa.inc\"\n\n            .section    .rodata, \"\" \nttlStr:     .asciz      \"Listing 9-9\"\nfmtStr1:    .asciz      \"Value = %s\\n\"\n\nqdata:      .qword      1 \n            .qword      21 \n            .qword      302 \n            .qword      4003 \n            .qword      50004 \n            .qword      600005 \n            .qword      7000006 \n            .qword      80000007 \n            .qword      900000008 \n            .qword      1000000009 \n            .qword      11000000010 \n            .qword      120000000011 \n            .qword      1300000000012 \n            .qword      14000000000013 \n            .qword      150000000000014 \n            .qword      1600000000000015 \n            .qword      17000000000000016 \n            .qword      180000000000000017 \n            .qword      1900000000000000018 \n            .qword      20000000000000000019 \n            .qword      210000000000000000020 \n            .qword      2200000000000000000021 \n            .qword      23000000000000000000022 \n            .qword      240000000000000000000023 \n            .qword      2500000000000000000000024 \n            .qword      26000000000000000000000025 \n            .qword      270000000000000000000000026 \n            .qword      2800000000000000000000000027 \n            .qword      29000000000000000000000000028 \n            .qword      300000000000000000000000000029 \n            .qword      3100000000000000000000000000030 \n            .qword      32000000000000000000000000000031 \n            .qword      330000000000000000000000000000032 \n            .qword      3400000000000000000000000000000033 \n            .qword      35000000000000000000000000000000034 \n            .qword      360000000000000000000000000000000035 \n            .qword      3700000000000000000000000000000000036 \n            .qword      38000000000000000000000000000000000037 \n            .qword      300000000000000000000000000000000000038 \n            .qword      340282366920938463463374607431768211455 \nqcnt        =           (.-qdata)/16 \n\n .data \nbuffer:     .space      256,0 \n\n            .code \n            .extern     printf \n\n// Return program title to C++ program: \n\n            proc    getTitle, public \n            lea     x0, ttlStr \n            ret \n            endp    getTitle \n\n// div10 \n//\n// This procedure does a general 128-bit / 10 division operation \n// using the following algorithm (assume all variables except \n// Remainder are 128-bit objects; Remainder is 64 bits): \n//\n// Quotient := Dividend; \n// Remainder := 0; \n// for i := 1 to NumberBits do \n//\n//  Remainder:Quotient := Remainder:Quotient SHL 1; \n//  if Remainder >= 10 then \n//\n//     Remainder := Remainder - 10; \n//     Quotient := Quotient + 1; \n//\n//  endif \n// endfor \n//\n// Data passed: \n//\n// 128-bit dividend in X6:X5 \n//\n// Data returned: \n//\n// 128-bit quotient in X6:X5 \n// 64-bit remainder in X4 \n//\n// Modifies X1 \n\n          ❶ proc    div10 \n\n#define remainder  x4 \n#define dividendL  x5 \n#define dividendH  x6 \n#define quotientL  dividendL \n#define quotientH  dividendH \n\n// Initialize remainder with 0: \n\n            mov     remainder, #0 \n\n// Copy the dividend to local storage: \n\n            mov     w1, #128           // Count off bits in W0\\. \n\n// Compute Remainder:Quotient := Remainder:Quotient LSL 1 \n//\n// Note: adds x, x, x is equivalent to lsl x, x, #1 \n//       adcs x, x, x is equivalent to rol x, x, #1 \n//                    (if rol existed) \n//\n// The following four instructions perform a 256-bit \n// extended-precision shift (left) dividend through \n// remainder. \n\nrepeatLp:   adds    dividendL, dividendL, dividendL \n            adcs    dividendH, dividendH, dividendH \n            adc     remainder, remainder, remainder \n\n// Do a comparison to see if the remainder \n// is greater than or equal to 10: \n\n            cmp     remainder, #10 \n            blo     notGE \n\n// Remainder := Remainder - Divisor \n\nisGE:       sub     remainder, remainder, #10 \n\n// Quotient := Quotient + 1 \n\n            adds    quotientL, quotientL, #1 \n            adc     quotientH, quotientH, xzr \n\n// Repeat for 128 bits: \n\nnotGE:      subs    w1, w1, #1 \n            bne     repeatLp \n\n            ret     // Return to caller. \n            endp    div10 \n\n// u128toStr: \n//\n//  Converts a 128-bit unsigned integer to a string \n//\n//  Inputs: \n//      X0-     Pointer to buffer to receive string \n//      X1-     Points at the unsigned 128-bit integer to convert \n//\n//  Outputs: \n//      Buffer- Receives the zero-terminated string \n//\n//  Buffer must have at least 40 bytes allocated for it. \n\n ❷ proc    u128toStr \n            stp     x0, x1, [sp, #-16]! \n            stp     x4, x5, [sp, #-16]! \n            stp     x6, lr, [sp, #-16]! \n\n            ldp     x5, x6, [x1]    // Test value for 0\\. \n            orr     x4, x5, x6 \n            cmp     x4, xzr         // Z = 1 if X6:X5 is 0\\. \n            bne     doRec128 \n\n            // Special case for zero, just write \n            // \"0\" to the buffer \n\n            mov     w4, #'0' \n            strb    w4, [x0], #1 \n            b.al    allDone2 \n\ndoRec128:   bl      u128toStrRec    // X6:X5 contain value. \n\n            // Restore registers: \n\nallDone2:   strb    wzr, [x0]       // Zero-terminating byte \n            ldp     x6, lr, [sp], #16 \n            ldp     x4, x5, [sp], #16 \n            ldp     x0, x1, [sp], #16 \n            ret \n            endp    u128toStr \n\n// u128toStrRec is the recursive version that handles \n// nonzero values. \n//\n// Value to convert is passed in X6:X5\\. \n\n          ❸ proc    u128toStrRec \n            stp     x4, lr, [sp, #-16]! \n\n            // Convert LO digit to a character: \n\n            bl      div10          // Quotient -> X6:X5, Rem -> W4 \n\n            // Make recursive call if quotient is not 0: \n\n            orr     lr, x5, x6     // Use LR as a temporary. \n            cmp     lr, #0 \n            beq     allDone \n\n            // New value is quotient (X6:X5) from above: \n\n            bl      u128toStrRec \n\n            // When this function has processed all the \n            // digits, write them to the buffer: \n\nallDone:    orr     w4, w4, #'0'    // Convert to char. \n            strb    w4, [x0], #1    // Bump pointer after store. \n\n // Restore state and return: \n\n            ldp     x4, lr, [sp], #16    // Restore prev char. \n            ret \n            endp    u128toStrRec \n\n// Here is the asmMain function. \n\n            proc    asmMain, public \n\n            locals  am \n            dword   am.x2021 \n            byte    stk, 64 \n            endl    am \n\n            enter   am.size              // Reserve space on stack. \n\n            stp     x20, x21, [fp, #am.x2021] \n\n            lea     x20, qdata \n            mov     x21, #qcnt \nloop:       mov     x1, x20 \n            lea     x0, buffer \n            bl      u128toStr \n\n            lea     x1, buffer \n            mstr    x1, [sp] \n            lea     x0, fmtStr1 \n            bl      printf \n\n            add     x20, x20, #16       // Next value to convert \n            subs    x21, x21, #1 \n            bne     loop \n\n            ldp     x20, x21, [fp, #am.x2021] \n            leave \n            ret \n            endp    asmMain \n```", "```\n$ ./build Listing9-9 \n$ ./Listing9-9 \nCalling Listing9-9: \nValue = 1 \nValue = 21 \nValue = 302 \nValue = 4003 \nValue = 50004 \nValue = 600005 \nValue = 7000006 \nValue = 80000007 \nValue = 900000008 \nValue = 1000000009 \nValue = 11000000010 \nValue = 120000000011 \nValue = 1300000000012 \nValue = 14000000000013 \nValue = 150000000000014 \nValue = 1600000000000015 \nValue = 17000000000000016 \nValue = 180000000000000017 \nValue = 1900000000000000018 \nValue = 20000000000000000019 \nValue = 210000000000000000020 \nValue = 2200000000000000000021 \nValue = 23000000000000000000022 \nValue = 240000000000000000000023 \nValue = 2500000000000000000000024 \nValue = 26000000000000000000000025 \nValue = 270000000000000000000000026 \nValue = 2800000000000000000000000027 \nValue = 29000000000000000000000000028 \nValue = 300000000000000000000000000029 \nValue = 3100000000000000000000000000030 \nValue = 32000000000000000000000000000031 \nValue = 330000000000000000000000000000032 \nValue = 3400000000000000000000000000000033 \nValue = 35000000000000000000000000000000034 \nValue = 360000000000000000000000000000000035 \nValue = 3700000000000000000000000000000000036 \nValue = 38000000000000000000000000000000000037 \nValue = 300000000000000000000000000000000000038 \nValue = 340282366920938463463374607431768211455 \nListing9-9 terminated \n```", "```\n// Listing9-10.S \n//\n// u64Size function: Computes the size \n// of an unsigned 64-bit integer (in \n// print positions) \n\n            #include    \"aoaa.inc\"\n\n            .section    .rodata, \"\" \nttlStr:     .asciz      \"Listing 9-10\"\nfmtStr:     .asciz      \"Value = %llu, size=%d\\n\"\n\n// Values to test the u64Size function: \n\ndVals:      .dword      1 \n            .dword      10 \n            .dword      100 \n            .dword      1000 \n            .dword      10000 \n            .dword      100000 \n            .dword      1000000 \n            .dword      10000000 \n            .dword      100000000 \n            .dword      1000000000 \n            .dword      10000000000 \n            .dword      100000000000 \n            .dword      1000000000000 \n            .dword      10000000000000 \n            .dword      100000000000000 \n            .dword      1000000000000000 \n            .dword      10000000000000000 \n .dword      100000000000000000 \n            .dword      1000000000000000000 \n            .dword      10000000000000000000 \ndCnt        =           (.-dVals) / 8 \n\n            .code \n            .extern     printf \n\n// Return program title to C++ program: \n\n            proc    getTitle, public \n            lea     x0, ttlStr \n            ret \n            endp    getTitle \n\n// u64Size \n//\n//  Counts the number of output positions \n//  required for an integer-to-decimal-\n//  string conversion \n//\n//  Uses a binary search to quickly \n//  count the digits required by a value \n//\n// Input: \n//  X1- Unsigned integer to count \n//\n// Output: \n//  X1- Digit count \n//\n// Table of digit counts and values: \n//\n//   1: 1 \n//   2: 10 \n//   3: 100 \n//   4: 1,000 \n//   5: 10,000 \n//   6: 100,000 \n//   7: 1,000,000 \n//   8: 10,000,000 \n//   9: 100,000,000 \n//  10: 1,000,000,000 \n//  11: 10,000,000,000 \n//  12: 100,000,000,000 \n//  13: 1,000,000,000,000 \n//  14: 10,000,000,000,000 \n//  15: 100,000,000,000,000 \n//  16: 1,000,000,000,000,000 \n//  17: 10,000,000,000,000,000 \n//  18: 100,000,000,000,000,000 \n//  19: 1,000,000,000,000,000,000 \n//  20: 10,000,000,000,000,000,000 \n\n          ❶ proc    u64Size \n            stp     x0, x2, [sp, #-16]! \n\n ❷ mov     x2, x1 \n            ldr     x0, =1000000000 // 10: 1,000,000,000 \n            cmp     x2, x0 \n            bhs     ge10 \n\n            ldr     x0, =10000 \n            cmp     x2, x0 \n            bhs     ge5 \n\n            // Must be 1 to 4 digits here: \n\n            mov     x1, #1 \n            cmp     x2, #1000 \n            cinc    x1, x1, hs \n            cmp     x2, #100 \n            cinc    x1, x1, hs \n            cmp     x2, #10 \n            cinc    x1, x1, hs \n            ldp     x0, x2, [sp], #16 \n            ret \n\n// Must be 5 to 9 digits here: \n\nge5:        ldr     x0, =1000000    // 7: 1,000,000 \n            cmp     x2, x0 \n            bhs     ge7 \n\n            // Must be 5 or 6 digits: \n\n            mov     x1, #5 \n            ldr     x0, =100000     // 6: 100,000 \n            cmp     x2, x0 \n            cinc    x1, x1, hs \n            ldp     x0, x2, [sp], #16 \n            ret \n\n// Must be 7 to 9 digits here: \n\nge7:        mov     x1, #7 \n            ldr     x0, =10000000   // 8: 10,000,000 \n            cmp     x2, x0 \n            cinc    x1, x1, hs \n            ldr     x0, =100000000  // 9: 100,000,000 \n            cmp     x2, x0 \n            cinc    x1, x1, hs \n            ldp     x0, x2, [sp], #16 \n            ret \n\n// Handle 10 or more digits here: \n\nge10:       ldr     x0, =100000000000000    // 15: 100,000,000,000,000 \n            cmp     x2, x0 \n            bhs     ge15 \n\n // 10 to 14 digits here: \n\n            ldr     x0, =1000000000000      // 13: 1,000,000,000,000 \n            cmp     x2, x0 \n            bhs     ge13 \n\n            // 10 to 12 digits here: \n\n            mov     x1, #10 \n            ldr     x0, =10000000000        // 11: 10,000,000,000 \n            cmp     x2, x0 \n          ❸ cinc    x1, x1, hs \n            ldr     x0, =100000000000       // 12: 100,000,000,000 \n            cmp     x2, x0 \n            cinc    x1, x1, hs \n            ldp     x0, x2, [sp], #16 \n            ret \n\n// 13 or 14 digits here: \n\nge13:       mov     x1, #13 \n            ldr     x0, =10000000000000     // 14: 10,000,000,000,000 \n            cmp     x2, x0 \n            cinc    x1, x1, hs \n            ldp     x0, x2, [sp], #16 \n            ret \n\n// 15 to 20 digits here: \n\nge15:       ldr     x0, =100000000000000000 // 18: 100,000,000,000,000,000 \n            cmp     x2, x0 \n            bhs     ge18 \n\n            // 15, 16, or 17 digits here: \n\n            mov     x1, #15 \n            ldr     x0, =1000000000000000   // 16: 1,000,000,000,000,000 \n            cmp     x2, x0 \n            cinc    x1, x1, hs \n            ldr     x0, =10000000000000000  // 17: 10,000,000,000,000,000 \n            cmp     x2, x0 \n            cinc    x1, x1, hs \n            ldp     x0, x2, [sp], #16 \n            ret \n\n// 18 to 20 digits here: \n\nge18:       mov     x1, #18 \n            ldr     x0, =1000000000000000000  // 19: 1,000,000,000,000,000,000 \n            cmp     x2, x0 \n            cinc    x1, x1, hs \n            ldr     x0, =10000000000000000000 // 20 digits \n            cmp     x2, x0 \n            cinc    x1, x1, hs \n ldp     x0, x2, [sp], #16 \n            ret \n            endp    u64Size \n```", "```\n$ ./build Listing9-10 \n$ ./Listing9-10 \nCalling Listing9-10: \nValue = 1, size=1 \nValue = 10, size=2 \nValue = 100, size=3 \nValue = 1000, size=4 \nValue = 10000, size=5 \nValue = 100000, size=6 \nValue = 1000000, size=7 \nValue = 10000000, size=8 \nValue = 100000000, size=9 \nValue = 1000000000, size=10 \nValue = 10000000000, size=11 \nValue = 100000000000, size=12 \nValue = 1000000000000, size=13 \nValue = 10000000000000, size=14 \nValue = 100000000000000, size=15 \nValue = 1000000000000000, size=16 \nValue = 10000000000000000, size=17 \nValue = 100000000000000000, size=18 \nValue = 1000000000000000000, size=19 \nValue = 10000000000000000000, size=20 \nListing9-10 terminated \n```", "```\n// Listing9-11.S \n//\n// i64Size: \n//\n// Computes the number of character positions that \n// the i64toStr function will emit \n\n proc    i64Size \n            str     lr, [sp, #-16]! \n\n            cmp     x1, #0          // If less than zero, \n            bge     isPositive      // negate and treat \n                                    // like an uns64\\. \n            neg     x1, x1 \n\n            bl      u64Size \n            add     x1, x1, #1      // Adjust for \"-\". \n            ldr     lr, [sp], #16 \n            ret \n\nisPositive: bl      u64Size \n            ldr     lr, [sp], #16 \n            ret \n            endp    i64Size \n```", "```\n// Listing9-12.S (partial) \n//\n// u64ToSizeStr \n//\n//  Converts an unsigned 64-bit integer to \n//  a character string, using a minimum field \n//  width \n//\n//  Inputs: \n//      X0- Pointer to buffer to receive string \n//\n//      X1- Unsigned 64-bit integer to convert \n//          to a string \n//\n//      X2- Minimum field width for the string \n//          (maximum value is 1,024). Note: if \n//          the minimum field width value is less \n//          than the actual output size of the \n//          integer, this function will ignore \n//          the value in X2 and use the correct \n//          number of output positions for the \n//          value. \n//\n//  Outputs: \n//\n//      Buffer- Receives converted characters. \n//              Buffer must be at least 22 bytes \n//              or X1 + 1 bytes long. \n\n          ❶ proc    u64ToStrSize \n            stp     x0, lr, [sp, #-16]! \n            stp     x1, x2, [sp, #-16]! \n            stp     x23, x24, [sp, #-16]! \n            stp     x25, x26, [sp, #-16]! \n\n            // Initialize x25 and x26 with \n            // appropriate functions to call: \n\n            lea     x25, u64Size \n            lea     x26, u64ToStr \n\n            b.al    toSizeStr \n            endp    u64ToStrSize \n\n/////////////////////////////////////////////////////\n//\n// i64ToStrSize: \n//\n//  Just like u64ToStrSize, but handles signed integers \n//\n//  Inputs: \n//      X0- Pointer to buffer to receive string \n//\n//      X1- Signed 64-bit integer to convert \n//          to a string \n//\n//      X2- Minimum field width for the string \n//          (maximum value is 1,024). Note: if \n//          the minimum field width value is less \n//          than the actual output size of the \n//          integer, this function will ignore \n//          the value in X2 and use the correct \n//          number of output positions for the \n//          value. \n//\n//      Note:   Don't forget that if the number \n//              is negative, the '-' consumes \n//              an output position. \n//\n//  Outputs: \n//      Buffer- Receives converted character. \n//              Buffer must be at least 22 bytes \n//              or X2 + 1 bytes long. \n\n          ❷ proc    i64ToStrSize \n            stp     x0, lr, [sp, #-16]! \n            stp     x1, x2, [sp, #-16]! \n            stp     x23, x24, [sp, #-16]! \n            stp     x25, x26, [sp, #-16]! \n\n            // Initialize x25 and x26 with \n            // appropriate functions to call: \n\n            lea     x25, i64Size \n            lea     x26, i64ToStr \n\n            b.al    toSizeStr   // Technically, this could just fall through. \n            endp    i64ToStrSize \n\n///////////////////////////////////////////////////////\n//\n// toSizeStr: \n//\n//  Special function to handle signed and \n//  unsigned conversions for u64ToSize and i64ToSize \n\n          ❸ proc    toSizeStr \n\n            mov     x24, x1 // Save for now. \n          ❹ blr     x25     // Compute size of number. \n\n            // Compute difference between actual size \n            // and desired size. Set to the larger of \n            // the two: \n\n          ❺ cmp     x2, x1 \n            csel    x23, x2, x1, ge \n\n            // Just as a precaution, limit the \n            // size to 1,024 characters (including \n            // the zero-terminating byte): \n\n            mov     x2, #1023   // Don't count 0 byte here. \n            cmp     x23, x2 \n            csel    x23, x23, x2, ls \n\n // Compute the number of spaces to emit before \n            // the first digit of the number: \n\n            subs    x23, x23, x1 \n            beq     spacesDone \n\n            // Emit that many spaces to the buffer: \n\n          ❻ mov     x1, #0x2020 \n            movk    x1, #0x2020, lsl #16 \n            movk    x1, #0x2020, lsl #32 \n            movk    x1, #0x2020, lsl #48 \n            b.al    tst8 \n\n            // Handle sequences of eight spaces: \n\nwhl8:       str     x1, [x0], #8 \n            sub     x23, x23, #8 \ntst8:       cmp     x23, #8 \n            bge     whl8 \n\n            // If four to seven spaces, emit four \n            // spaces here: \n\n            cmp     x23, #4 \n            blt     try2 \n            str     w1, [x0], #4 \n            sub     x23, x23, #4 \n\n            // If two or three spaces, emit two \n            // here: \n\ntry2:       cmp     x23, #2 \n            blt     try1 \n            strh    w1, [x0], #2 \n            sub     x23, x23, #2 \n\n            // If one space left, emit it here: \n\ntry1:       cmp     x23, #1 \n            blt     spacesDone \n            strb    w1, [x0], #1 \n\n            // Okay, emit the digits here: \n\nspacesDone: mov     x1, x24 // Retrieve value. \n          ❼ blr     x26     // XXXToStr \n\n            ldp     x25, x26, [sp], #16 \n            ldp     x23, x24, [sp], #16 \n            ldp     x1, x2,   [sp], #16 \n            ldp     x0, lr,   [sp], #16 \n            ret \n            endp    toSizeStr \n\n///////////////////////////////////////////////////////\n//\n// printSize \n//\n// Utility used by the main program to \n// compute sizes and print them \n\n          ❽ proc    printSize \n\n            locals  ps \n            dword   stk, 64 \n            endl    ps \n\n            enter   ps.size \n\n            mov     x6, x1 \n            lea     x0, buffer \n            blr     x27         // Call XXXToStrSize. \n\n            mov     x1, x6 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            lea     x3, buffer \n            mstr    x3, [sp, #16] \n            lea     x0, fmtStr \n            bl      printf \n\n            leave \n            endp    printSize \n\nvalues:     .dword  1, 10, 100, 1000, 10000, 100000, 1000000 \n            .dword  10000000, 100000000, 1000000000, 10000000000 \n            .dword  100000000000, 1000000000000, 10000000000000 \n            .dword  100000000000000, 1000000000000000 \n            .dword  10000000000000000, 100000000000000000 \n            .dword  1000000000000000000, 10000000000000000000 \n            .dword  0x7fffffffffffffff \n            .set    valSize, (.-values)/8 \n\nnegValues:  .dword  -1, -10, -100, -1000, -10000, -100000, -1000000 \n            .dword  -10000000, -100000000, -1000000000, -10000000000 \n            .dword  -100000000000, -1000000000000, -10000000000000 \n            .dword  -100000000000000, -1000000000000000 \n            .dword  -10000000000000000, -100000000000000000 \n            .dword  -1000000000000000000, -10000000000000000000 \n            .dword  0x8000000000000000 \n\nsizes:      .word   5, 6, 7, 8, 9, 10, 15, 15, 15, 15 \n            .word   20, 20, 20, 20, 20, 25, 25, 25, 25, 25, 30 \n\n///////////////////////////////////////////////////////\n//\n// Here is the asmMain function: \n\n ❾ proc    asmMain, public \n\n            locals  am \n            qword   am.x26x27 \n            qword   am.x24x25 \n            byte    am.stk, 64 \n            endl    am \n\n            enter   am.size     // Activation record \n            stp     x26, x27, [fp, #am.x26x27] \n            stp     x24, x25, [fp, #am.x24x25] \n\n// Test unsigned integers: \n\n            lea     x27, u64ToStrSize \n            lea     x24, values \n            lea     x25, sizes \n            mov     x26, #valSize \ntstLp:      ldr     x1, [x24], #8 \n            ldr     w2, [x25], #4 \n            bl      printSize \n            subs    x26, x26, #1 \n            bne     tstLp \n\n            lea     x27, i64ToStrSize \n            lea     x24, negValues \n            lea     x25, sizes \n            mov     x26, #valSize \nntstLp:     ldr     x1, [x24], #8 \n            ldr     w2, [x25], #4 \n            bl      printSize \n            subs    x26, x26, #1 \n            bne     ntstLp \n\n            ldp     x26, x27, [fp, #am.x26x27] \n            ldp     x24, x25, [fp, #am.x24x25] \n            leave \n            endp    asmMain \n```", "```\n$ ./build Listing9-12 \n$ ./Listing9-12 \nCalling Listing9-12: \n                   1:   5='    1' \n                  10:   6='    10' \n                 100:   7='    100' \n                1000:   8='    1000' \n               10000:   9='    10000' \n              100000:  10='    100000' \n             1000000:  15='        1000000' \n            10000000:  15='       10000000' \n           100000000:  15='      100000000' \n          1000000000:  15='     1000000000' \n         10000000000:  20='         10000000000' \n        100000000000:  20='        100000000000' \n       1000000000000:  20='       1000000000000' \n      10000000000000:  20='      10000000000000' \n     100000000000000:  20='     100000000000000' \n    1000000000000000:  25='         1000000000000000' \n   10000000000000000:  25='        10000000000000000' \n  100000000000000000:  25='       100000000000000000' \n 1000000000000000000:  25='      1000000000000000000' \n-8446744073709551616:  25='     10000000000000000000' \n 9223372036854775807:  30='           9223372036854775807' \n                  -1:   5='   -1' \n                 -10:   6='   -10' \n                -100:   7='   -100' \n               -1000:   8='   -1000' \n              -10000:   9='   -10000' \n             -100000:  10='   -100000' \n            -1000000:  15='       -1000000' \n           -10000000:  15='      -10000000' \n          -100000000:  15='     -100000000' \n         -1000000000:  15='    -1000000000' \n        -10000000000:  20='        -10000000000' \n       -100000000000:  20='       -100000000000' \n      -1000000000000:  20='      -1000000000000' \n     -10000000000000:  20='     -10000000000000' \n    -100000000000000:  20='    -100000000000000' \n   -1000000000000000:  25='        -1000000000000000' \n  -10000000000000000:  25='       -10000000000000000' \n -100000000000000000:  25='      -100000000000000000' \n-1000000000000000000:  25='     -1000000000000000000' \n 8446744073709551616:  25='      8446744073709551616' \n-9223372036854775808:  30='          -9223372036854775808' \nListing9-12 terminated \n```", "```\n// Listing9-13.S \n//\n// Floating-point (double) to string conversion \n//\n// Provides both exponential (scientific notation) \n// and decimal output formats \n            #include    \"aoaa.inc\"\n\n          ❶ .section    .rodata, \"\" \nttlStr:     .asciz      \"Listing 9-13\"\nfmtStr1:    .asciz      \"r64ToStr: value='%s'\\n\"\nfmtStr2:    .asciz      \"fpError: code=%lld\\n\"\nfmtStr3:    .asciz      \"e64ToStr: value='%s'\\n\"\nnewlines:   .asciz      \"\\n\\n\"\nexpStr:     .asciz      \"\\n\\nTesting e64ToStr:\\n\\n\"\n\n// r10str_1: A global character array that will \n// hold the converted string \n\n          ❷ .data \nr64str_1:   .space      32, 0 \n\n            .code \n            .extern     printf \n\n// tenTo15: Used to multiply a value from 1.0 \n// to less than 2.0 in order to convert the mantissa \n// to an actual integer \n\n❸ tenTo15:    .double     1.0e+15 \n\n// potPos, potNeg, and expTbl: \n//\n// Power of 10s tables (pot) used to quickly \n// multiply or divide a floating-point value \n// by powers of 10\\. expTbl is the power-of-\n// 10 exponent (absolute value) for each of\n// the entries in these tables. \n\n❹ potPos:     .double     1.0e+0 \n            .double     1.0e+1 \n            .double     1.0e+2 \n            .double     1.0e+4 \n            .double     1.0e+8 \n            .double     1.0e+16 \n            .double     1.0e+32 \n            .double     1.0e+64 \n            .double     1.0e+128 \n            .double     1.0e+256 \nexpCnt      =           (.-potPos) / 8 \n\npotNeg:     .double     1.0e-0 \n            .double     1.0e-1 \n            .double     1.0e-2 \n            .double     1.0e-4 \n            .double     1.0e-8 \n            .double     1.0e-16 \n            .double     1.0e-32 \n .double     1.0e-64 \n            .double     1.0e-128 \n            .double     1.0e-256 \n\nexpTbl:     .dword      0 \n            .dword      1 \n            .dword      2 \n            .dword      4 \n            .dword      8 \n            .dword      16 \n            .dword      32 \n            .dword      64 \n            .dword      128 \n            .dword      256 \n\n// Maximum number of significant digits for \n// a double-precision value: \n\n❺ maxDigits   =           16 \n\n// Return program title to C++ program: \n\n          ❻ proc    getTitle, public \n            lea     x0, ttlStr \n            ret \n            endp    getTitle \n```", "```\n// Listing9-13.S (cont.) \n//\n// u53toStr \n//\n//  Converts a 53-bit unsigned integer to a string containing \n//  exactly 16 digits (technically, it does 64-bit arithmetic, \n//  but is limited to 53 bits because of the 16-digit output \n//  format) \n//\n// Inputs: \n//  X0-     Pointer to buffer to receive string \n//  X1-     Unsigned 53-bit integer to convert \n//\n// Outputs: \n//  Buffer- Receives the zero-terminated string \n//  X0-     Points at zero-terminating byte in string \n//\n//  Buffer must have at least 17 bytes allocated for it. \n//\n// This code is a bit simplified from the u64toStr function \n// because it always emits exactly 16 digits \n// (never any leading 0s). \n\n          ❶ proc    u53toStr \n\n            stp     x1, x2, [sp, #-16]! \n            stp     x3, x4, [sp, #-16]! \n            str     x5, [sp, #-16]! \n\n            mov     x4, #10     // Mul/div by 10 using X4 \n            mov     x5, xzr     // Holds string of 8 chars \n\n            // Handle LO digit here. Note that the LO \n            // digit will ultimately be moved into \n            // bit positions 56-63 of X5 because numeric \n            // strings are, intrinsically, big-endian (with \n            // the HO digit appearing first in memory). \n\n          ❷ udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // The following is an unrolled loop \n            // (for speed) that processes the \n            // remaining 15 digits. \n            // \n // Handle digit 1 here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 2 here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 3 here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 4 here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 5 here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 6 here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 7 here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Store away LO 8 digits: \n\n            str     x5, [x0, #8] \n            mov     x5, xzr \n\n // Handle digit 8 here: \n\n          ❸ udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 9 here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 10 here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 11 here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 12 here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 13 here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 14 here: \n\n            udiv    x2, x1, x4      // X2 = quotient \n            msub    x3, x2, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            // Handle digit 15 here: \n\n            udiv    x1, x2, x4      // X1 = quotient \n            msub    x3, x1, x4, x2  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n // Store away HO 8 digits: \n\n            str     x5, [x0] \n            strb    wzr, [x0, #maxDigits]!  // Zero-terminating byte \n\n            ldr     x5, [sp], #16 \n            ldp     x3, x4, [sp], #16 \n            ldp     x1, x2, [sp], #16 \n            ret \n            endp    u53toStr \n```", "```\n// Listing9-13.S (cont.) \n//\n// FPDigits \n//\n//  Used to convert a floating-point value \n//  in D0 to a string of digits \n//\n// Inputs: \n//  D0-     Double-precision value to convert \n//  X0-     Pointer to buffer to receive chars \n//\n// Outputs: \n//  X0-     Still points at buffer \n//  X1-     Contains exponent of the number \n//  X2-     Contains sign (space or '-') \n\n            proc    FPDigits \n            str     lr,       [sp, #-16]! \n            str     d0,       [sp, #-16]! \n            stp     d1, d2,   [sp, #-16]! \n            stp     x22, x23, [sp, #-16]! \n stp     x24, x25, [sp, #-16]! \n            stp     x26, x27, [sp, #-16]! \n\n            mov     x2, #' '        // Assume sign is +. \n\n#define fp1 d2                      // D2 holds 1.0\\. \n\n            fmov    fp1, #1.0 \n\n             // Special case for 0.0: \n\n          ❶ fcmp    d0, #0.0 \n            bne     d0not0 \n\n            // Check for -0.0: \n\n          ❷ fmov    x1, d0 \n            ands    x1, x1, #0x8000000000000000 \n            beq     posZero \n            mov     x2, #'-' \n\nposZero: \n            mov     x1, #0x3030 \n            movk    x1, #0x3030, lsl #16 \n            movk    x1, #0x3030, lsl #32 \n            movk    x1, #0x3030, lsl #48 \n            str     x1, [x0] \n            str     x1, [x0, #8] \n            mov     x1, #0          // Exponent = 0 \n\n            // For debugging purposes, zero-terminate this \n            // string (the actual code just grabs 16 bytes, \n            // so this isn't strictly necessary): \n\n            strb    w0, [x0, #16] \n            b.al    fpdDone \n\n// If the number is nonzero, deal with it here. Note \n// that the flags were set by comparing D0 to 0.0 earlier. \n\n❸ d0not0:     bge     fpIsPositive    // See if positive or negative. \n\n            // If negative, negate and change the sign \n            // character to '-'. \n\n            fabs    d0, d0 \n            mov     x2, #'-' \n\n// Get the number from 1.0 to <10.0 so you can figure out \n// what the exponent is. Begin by checking to see if you have \n// a positive or negative exponent. \n\nfpIsPositive: \n            mov     x1, xzr         // Initialize exponent. \n ❹ fcmp    d0, fp1 \n            bge     posExp \n\n            // The value is in the range 0.0 to 1.0, \n            // exclusive, at this point. That means this \n            // number has a negative exponent. Multiply \n            // the number by an appropriate power of 10 \n            // until you get it in the range 1 through 10\\. \n\n            lea     x27, potNeg \n            lea     x26, potPos \n            lea     x25, expTbl \n            mov     x24, #expCnt \n\n// Search through the potNeg table until you find a power \n// of 10 that is less than the value in D0: \n\ncmpNegExp: \n          ❺ subs    x24, x24, #1 \n            blt     test1       // Branch if X24 < 1\\. \n\n            ldr     d1, [x27, x24, lsl #3]  // D1 = potNeg[X24 * 8] \n            fcmp    d1, d0      // Repeat while \n            ble     cmpNegExp   // table <= value. \n\n            // Eliminate the current exponent indexed by \n            // X24 by multiplying by the corresponding \n            // entry in potPos: \n\n            ldr     x22, [x25, x24, lsl #3] // X22 = expTbl[X24 * 8] \n            sub     x1, x1, x22 \n            ldr     d1, [x26, x24, lsl #3]  // D1 = potPos[X24 * 8] \n            fmul    d0, d0, d1 \n            b.al    cmpNegExp \n\n// If you get to this point, you've indexed through \n// all the elements in the potNeg and it's time to stop. \n//\n// If the remainder is *exactly* 1.0, you can branch \n// on to InRange1_10; otherwise, you still have to multiply \n// by 10.0 because you've overshot the mark a bit. \n\ntest1:      fcmp    d0, fp1 \n            beq     inRange1_10 \n\n            fmov    d1, #10.0 \n            fmul    d0, d0, d1 \n            sub     x1, x1, #1      // Decrement exponent. \n            b.al    inRange1_10 \n\n// At this point, you have a number that is 1 or greater. \n// Once again, your task is to get the value from 1.0 to <10.0\\. \n\nposExp: \n            lea     x26, potPos \n            lea     x25, expTbl \n            mov     x24, #expCnt \n\n❻ cmpPosExp:  subs    x24, x24, #1 \n            blt     inRange1_10     // If X24 < 1 \n\n            ldr     d1, [x26, x24, lsl #3]  // D1 = potPos[X24 * 8] \n            fcmp    d1, d0 \n            bgt     cmpPosExp \n\n            ldr     x22, [x25, x24, lsl #3] // X22 = expTbl[X24 * 8] \n            add     x1, x1, x22 \n            fdiv    d0, d0, d1 \n            b.al    cmpPosExp \n\n// Okay, at this point the number is in the range 1 <= x < 10\\. \n// Let's multiply it by 1e+15 to put the most significant digit \n// into the 16th print position, then convert the result to \n// a string and store away in memory. \n\n❼ inRange1_10: \n            ldr     d1, tenTo15 \n            fmul    d0, d0, d1 \n            fcvtau  x22, d0     // Convert to unsigned integer. \n\n            // Convert the integer mantissa to a \n            // string of digits: \n\n            stp     x0, x1, [sp, #-16]! \n            mov     x1, x22 \n            bl      u53toStr \n            ldp     x0, x1, [sp], #16 \n\nfpdDone: \n            ldp     x26, x27,   [sp], #16 \n            ldp     x24, x25,   [sp], #16 \n            ldp     x22, x23,   [sp], #16 \n            ldp     d1, d2,     [sp], #16 \n            ldr     d0,         [sp], #16 \n            ldr     lr,         [sp], #16 \n            ret \n            endp    FPDigits \n```", "```\n// Listing9-13.S (cont.) \n//\n// chkNaNINF \n//\n// Utility function used by r64ToStr and e64ToStr to check \n// for NaN and INF \n//\n// Inputs: \n//  D0-     Number to check against NaN and INF \n//  X19-    Field width for output \n//  X21-    Fill character \n//  X22-    (outBuf) Pointer to output buffer \n//  X25-    Return address to use if number is invalid \n//\n// Outputs: \n//  Buffer- Will be set to the string NaN, INF, \n//          or -INF if the number is not valid \n//\n//  Note: Modifies value in X0 \n\n            proc    chkNaNINF \n\n            // Handle NaN and INF special cases: \n\n          ❶ fmov    x0, d0 \n            lsr     x0, x0, #52 \n            and     x0, x0, #0x7ff \n            cmp     x0, #0x7ff \n            blo     notINFNaN \n\n            // At this point, it's NaN or INF. INF has a \n            // mantissa containing 0, NaN has a nonzero \n            // mantissa: \n\n          ❷ fmov    x0, d0 \n            ands    x0, x0, #0x000fffffffffffff \n            beq     isINF \n\n            // Is NaN here: \n\n          ❸ ldr     w0, ='N' + ('a' << 8) + ('N' << 16) \n            str     w0, [x22] \n            mov     x0, #3 \n            b.al    fillSpecial \n\n            // INF can be positive or negative. Must output a \n            // '-' character if it is -INF: \n\n❹ isINF:      fmov    x0, d0 \n            ands    x0, x0, #0x8000000000000000 // See if -INF. \n            bne     minusINF \n\n            ldr     w0, ='I' + ('N' << 8) + ('F' << 16) \n            str     w0, [x22] \n            mov     x0, #3 \n            b.al    fillSpecial \n\n❺ minusINF:   ldr     w0, ='-' + ('I' << 8) + ('N' << 16) + ('F' << 24) \n            str     w0, [x22] \n strb    wzr, [x22, #4] \n            mov     x0, #4 \n\n// For NaN and INF, fill the remainder of the string, as appropriate: \n\n❻ fillSpecial: \n            b.al    whlLTwidth \n\nfsLoop:     strb    w21, [x22, x0] \n            add     x0, x0, #1 \n whlLTwidth: \n            cmp     x0, x19 \n            blo     fsLoop \n          ❼ mov     lr, x25         // Return to alternate address. \n\nnotINFNaN:  ret \n            endp    chkNaNINF \n```", "```\n// Listing9-13.S (cont.) \n//\n// r64ToStr \n//\n// Converts a REAL64 floating-point number to the \n// corresponding string of digits. Note that this \n// function always emits the string using decimal \n// notation. For scientific notation, use the e10ToBuf \n// routine. \n//\n// On entry: \n//\n//  D0-         (r64) Real64 value to convert \n//\n//  X0-         (outBuf) r64ToStr stores the resulting \n//              characters in this string. \n//\n//  X1-         (fWidth) Field width for the number (note \n//              that this is an *exact* field width, not a \n//              minimum field width) \n//\n//  X2-         (decDigits) # of digits to display after the \n//              decimal pt \n//\n//  X3-         (fill) Padding character if the number of \n//              digits is smaller than the specified field \n//              width \n//\n//  X4-         (maxLength) Maximum string length \n//\n// On exit: \n//\n// Buffer contains the newly formatted string. If the \n// formatted value does not fit in the width specified, \n// r64ToStr will store \"#\" characters into this string. \n//\n// Carry-    Clear if success, set if an exception occurs. \n//           If width is larger than the maximum length of \n//           the string specified by buffer, this routine \n//           will return with the carry set. \n//\n//***********************************************************\n\n            proc    r64ToStr \n\n            // Local variables: \n\n            locals  rts \n            qword   rts.x0x1 \n            qword   rts.x2x3 \n            qword   rts.x4x5 \n            qword   rts.x19x20 \n            qword   rts.x21x22 \n            qword   rts.x23x24 \n\n            dword   rts.x25 \n            byte    rts.digits, 80 \n            byte    rts.stk, 64 \n            endl    rts \n\n            enter   rts.size \n\n            // Use meaningful names for the nonvolatile \n            // registers that hold local/parameter values: \n\n            #define fpVal d0 \n            #define fWidth x19      // chkNaNINF expects this here. \n #define decDigits x20 \n            #define fill w21        // chkNaNINF expects this here. \n            #define outBuf x22      // chkNaNINF expects this here. \n            #define maxLength x23 \n            #define exponent x24 \n            #define sign w25 \n            #define failAdrs x25    // chkNaNINF expects this here. \n\n            // Preserve registers: \n\n            stp     x0,   x1, [fp, #rts.x0x1] \n            stp     x2,   x3, [fp, #rts.x2x3] \n            stp     x4,   x5, [fp, #rts.x4x5] \n            stp     x19, x20, [fp, #rts.x19x20] \n            stp     x21, x22, [fp, #rts.x21x22] \n            stp     x23, x24, [fp, #rts.x23x24] \n            str     x25,      [fp, #rts.x25] \n\n            // Move parameter values to nonvolatile \n            // storage: \n\n            mov     outBuf, x0 \n            mov     fWidth, x1 \n            mov     decDigits, x2 \n            mov     fill, w3 \n            mov     maxLength, x4 \n\n            // First, make sure the number will fit into \n            // the specified string. \n\n            cmp     fWidth, maxLength \n            bhs     strOverflow \n\n            // If the width is 0, return an error: \n\n            cmp     fWidth, #0 \n            beq     valOutOfRange \n\n            // Handle NaN and INF special cases. \n            // Note: if the value is invalid, control \n            // transfers to clcAndRet rather than simply \n            // returning. \n\n          ❶ lea     failAdrs, clcAndRet \n            bl      chkNaNINF \n\n            // Okay, do the conversion. Begin by \n            // processing the mantissa digits: \n\n            add     x0, fp, #rts.digits // lea x0, rts.digits \n          ❷ bl      FPDigits            // Convert r64 to string. \n            mov     exponent, x1        // Save away exponent result. \n            mov     sign, w2            // Save mantissa sign char. \n\n// Round the string of digits to the number of significant \n// digits you want to display for this number. Note that \n// a maximum of 16 digits are produced for a 53-bit value. \n\n          ❸ cmp     exponent, #maxDigits \n            ble     dontForceWidthZero \n            mov     x0, xzr         // If the exponent is negative or \n                                    // too large, set width to 0\\. \ndontForceWidthZero: \n            add     x2, x0, decDigits // Compute rounding position. \n            cmp     x2, #maxDigits \n            bhs     dontRound       // Don't bother if a big #. \n\n            // To round the value to the number of \n            // significant digits, go to the digit just \n            // beyond the last one you are considering (X2 \n            // currently contains the number of decimal \n            // positions) and add 5 to that digit. \n            // Propagate any overflow into the remaining \n            // digit positions. \n\n            add     x2, x2, #1          // Index + 1 of last sig digit \n            ldrb    w0, [x1, x2]        // Get that digit. \n\n            add     w0, w0, #5          // Round (for example, +0.5) \n            cmp     w0, #'9' \n            bls     dontRound \n\n            mov     x0, #('0' + 10)     // Force to 0\\. \nwhileDigitGT9: \n            sub     w0, w0, #10         // Sub out overflow, \n            strb    w0, [x1, x2]        // carry, into prev \n            subs    x2, x2, #1          // digit (until first \n            bmi     hitFirstDigit       // digit in the #). \n\n            ldrb    w0, [x1, x2]        // Increment previous \n            add     w0, w0, #1          // digit. \n            strb    w0, [x1, x2] \n\n            cmp     w0, #'9'            // Overflow if > '9' \n            bhi     whileDigitGT9 \n            b.al    dontRound \n\nhitFirstDigit: \n\n            // If you get to this point, you've hit the \n            // first digit in the number, so you have to \n            // shift all the characters down one position \n            // in the string of bytes and put a \"1\" in the \n            // first character position. \n\n          ❹ mov     x2, #maxDigits      // Max digits in value \nrepeatUntilX2eq0: \n\n ldrb    w0, [x1, x2] \n            add     x2, x2, #1 \n            strb    w0, [x1, x2] \n            subs    x2, x2, #2 \n            bne     repeatUntilX2eq0 \n\n            mov     w0, #'1' \n            strb    w0, [x1, x2] \n\n            add     exponent, exponent, #1 // Increment exponent because \n                                           // you added a digit. \n\ndontRound: \n\n            // Handle positive and negative exponents separately. \n\n          ❺ mov     x5, xzr             // Index into output buf. \n            cmp     exponent, #0 \n            bge     positiveExponent \n\n            // Negative exponents: \n            // Handle values from 0 to 1.0 here (negative \n            // exponents imply negative powers of 10). \n            // \n            // Compute the number's width. Since this \n            // value is from 0 to 1, the width \n            // calculation is easy: it's just the number of \n            // decimal positions they've specified plus \n            // 3 (since you need to allow room for a \n            // leading \"-0.\"). X2 = number of digits to emit \n            // after \".\" \n\n            mov     x4, #4 \n            add     x2, decDigits, #3 \n            cmp     x2, x4 \n            csel    x2, x2, x4, hs  // If X2 < X4, X2 = X4 \n\n            cmp     x2, fWidth \n            bhi     widthTooBig \n\n            // This number will fit in the specified field \n            // width, so output any necessary leading pad \n            // characters. X3 = number of padding characters \n            // to output. \n\n          ❻ sub     x3, fWidth, x2 \n            b.al    testWhileX3ltWidth \n\nwhileX3ltWidth: \n            strb    fill, [outBuf, x5] \n            add     x5, x5, #1          // Index \n            add     x2, x2, #1          // Digits processed \ntestWhileX3ltWidth: \n            cmp     x2, fWidth \n            blo     whileX3ltWidth \n\n // Output \" 0.\" or \"-0.\", depending on \n            // the sign of the number: \n\n            strb    sign, [outBuf, x5] \n            add     x5, x5, #1 \n            mov     w0, #'0' \n            strb    w0, [outBuf, x5] \n            add     x5, x5, #1 \n            mov     w0, #'.' \n            strb    w0, [outBuf, x5] \n            add     x5, x5, #1 \n            add     x3, x3, #3 \n\n            // Now output the digits after the decimal point: \n\n            mov     x2, xzr             // Count the digits here. \n            add     x1, fp, #rts.digits // lea x1, rts.digits \n\n// If the exponent is currently negative, or if \n// you've output more than 16 significant digits, \n// just output a 0 character. \n\nrepeatUntilX3geWidth: \n            mov     x0, #'0' \n            adds    exponent, exponent, #1 \n            bmi     noMoreOutput \n\n            cmp     x2, #maxDigits \n            bge     noMoreOutput \n\n            ldrb    w0, [x1] \n            add     x1, x1, #1 \n\nnoMoreOutput: \n            strb    w0, [outBuf, x5] \n            add     x5, x5, #1          // Index \n            add     x2, x2, #1          // Digits processed \n            add     x3, x3, #1          // Digit count \n            cmp     x3, fWidth \n            blo     repeatUntilX3geWidth \n            b.al    r64BufDone \n\n// If the number's actual width was bigger than the width \n// specified by the caller, emit a sequence of '#' characters \n// to denote the error. \n\n❼ widthTooBig: \n\n            // The number won't fit in the specified field \n            // width, so fill the string with the \"#\" \n            // character to indicate an error. \n\n            mov     x2, fWidth \n            mov     w0, #'#' \nfillPound:  strb    w0, [outBuf, x5] \n            add     x5, x5, #1          // Index \n            subs    x2, x2, #1 \n            bne     fillPound \n            b.al    r64BufDone \n\n// Handle numbers with a positive exponent here. \n//\n// Compute # of print positions consumed by output string. \n// This is given by: \n//\n//                   Exponent     // # of digits to left of \".\" \n//           +       2            // Sign + 1's digit \n//           +       decDigits    // Add in digits right of \".\" \n//           +       1            // If there is a decimal point \n\n❽ positiveExponent: \n\n            mov     x3, exponent    // Digits to left of \".\" \n            add     x3, x3, #2      // sign posn \n            cmp     decDigits, #0   // See if any fractional \n            beq     decPtsIs0       // part. \n\n            add     x3, x3, decDigits // Digits to right of \".\" \n            add     x3, x3, #1        // Make room for the \".\" \n\ndecPtsIs0: \n\n            // Make sure the result will fit in the \n            // specified field width. \n\n            cmp     x3, fWidth \n            bhi     widthTooBig \n            beq     noFillChars \n\n            // If the actual number of print positions \n            // is less than the specified field width, \n            // output leading pad characters here. \n\n            subs    x2, fWidth, x3 \n            beq     noFillChars \n\nfillChars:  strb    fill, [outBuf, x5] \n            add     x5, x5, #1 \n            subs    x2, x2, #1 \n            bne     fillChars \n\nnoFillChars: \n\n            // Output the sign character: \n\n            strb    sign, [outBuf, x5] \n            add     x5, x5, #1 \n\n // Okay, output the digits for the number here: \n\n            mov     x2, xzr             // Counts # of output chars \n            add     x1, fp, #rts.digits // lea x1, rts.digits \n\n            // Calculate the number of digits to output \n            // before and after the decimal point: \n\n            add     x3, decDigits, exponent \n            add     x3, x3, #1          // Always one digit before \".\" \n\n// If we've output fewer than 16 digits, go ahead \n// and output the next digit. Beyond 16 digits, \n// output 0s. \n\nrepeatUntilX3eq0: \n\n            mov     w0, #'0' \n            cmp     x2, #maxDigits \n            bhs     putChar \n\n            ldrb    w0, [x1] \n            add     x1, x1, #1 \n\nputChar:    strb    w0, [outBuf, x5] \n            add     x5, x5, #1 \n\n            // If the exponent decrements down to 0, \n            // output a decimal point: \n\n            cmp     exponent, #0 \n            bne     noDecimalPt \n\n            cmp     decDigits, #0 \n            beq     noDecimalPt \n\n            mov     w0, #'.' \n            strb    w0, [outBuf, x5] \n            add     x5, x5, #1 \n\nnoDecimalPt: \n            sub     exponent, exponent, #1  // Count down to \".\" output. \n            add     x2, x2, #1    // # of digits thus far \n            subs    x3, x3, #1    // Total # of digits to output \n            bne     repeatUntilX3eq0 \n\n// Zero-terminate string and leave: \n\nr64BufDone: strb    wzr, [outBuf, x5] \n❾ clcAndRet:  msr     nzcv, xzr    // clc = no error \n            b.al    popRet \n\nstrOverflow: \n            mov     x0, #-3 // String overflow \n            b.al    ErrorExit \n\nvalOutOfRange: \n            mov     x0, #-1 // Range error \n❿ ErrorExit:  mrs     x1, nzcv \n            orr     x1, x1, #(1 << 29) \n            msr     nzcv, x1        // stc = error \n            strb    wzr, [outBuf]   // Just to be safe \n\n            // Change X0 on return: \n\n            str     x0, [fp, #rts.x0x1] \n\npopRet: \n            ldp     x0, x1,   [fp, #rts.x0x1] \n            ldp     x2, x3,   [fp, #rts.x2x3] \n            ldp     x4, x5,   [fp, #rts.x4x5] \n            ldp     x19, x20, [fp, #rts.x19x20] \n            ldp     x21, x22, [fp, #rts.x21x22] \n            ldp     x23, x24, [fp, #rts.x23x24] \n            ldr     x25,      [fp, #rts.x25] \n            leave \n            endp    r64ToStr \n```", "```\n// Listing9-13.S (cont.) \n//\n// expToBuf \n//\n// Unsigned integer to buffer \n// Used to output up to three-digit exponents \n//\n// Inputs: \n//\n//  X0-   Unsigned integer to convert \n//  X1-   Exponent print width 1-3 \n//  X2-   Points at buffer (must have at least 4 bytes) \n//\n// Outputs: \n//\n//  Buffer contains the string representing the converted \n//  exponent. \n//\n//  Carry is clear on success, set on error. \n\n            proc    expToBuf \n            stp     x0, lr, [sp, #-16]! \n            stp     x1, x3, [sp, #-16]! \n            stp     x4, x5, [sp, #-16]! \n\n            mov     x5, xzr     // Initialize output string. \n            mov     x4, #10     // For division by 10 \n\n// Verify exponent digit count is in the range 1-3: \n\n ❶ cmp     x1, #1 \n            blo     badExp \n            cmp     x1, #3 \n            bhi     badExp \n\n// Verify the actual exponent will fit in the number of digits: \n\n          ❷ cmp     x1, #2 \n            blo     oneDigit \n            beq     twoDigits \n\n            // Must be 3: \n\n            cmp     x0, #1000 \n            bhs     badExp \n\n// Convert three-digit value to a string: \n\n          ❸ udiv    x1, x0, x4      // X1 = quotient \n            msub    x3, x1, x4, x0  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            udiv    x0, x1, x4      // X0 = quotient \n            msub    x3, x0, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            udiv    x1, x0, x4      // X1 = quotient \n            msub    x3, x1, x4, x0  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n            b.al    outputExp \n\n// Single digit is easy: \n\noneDigit: \n          ❹ cmp     x0, #10 \n            bhs     badExp \n\n            orr     x5, x0, #'0' \n            b.al    outputExp \n\n// Convert value in the range 10-99 to a string \n// containing two characters: \n\ntwoDigits: \n          ❺ cmp     x0, #100 \n            bhs     badExp \n\n            udiv    x1, x0, x4      // X1 = quotient \n            msub    x3, x1, x4, x0  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n udiv    x0, x1, x4      // X0 = quotient \n            msub    x3, x0, x4, x1  // X3 = remainder \n            orr     x3, x3, #'0' \n            orr     x5, x3, x5, lsl #8 \n\n// Store the string into the buffer (includes a 0 \n// byte in the HO positions of W5): \n\noutputExp: \n          ❻ str     w5, [x2] \n            ldp     x4, x5, [sp], #16 \n            ldp     x1, x3, [sp], #16 \n            ldp     x0, lr, [sp], #16 \n            msr     nzcv, xzr    // clc = no error \n            ret \n            leave \n\nbadExp: \n            ldp     x4, x5, [sp], #16 \n            ldp     x1, x3, [sp], #16 \n            ldp     x0, lr, [sp], #16 \n            mrs     x0, nzcv \n            orr     x0, x0, #(1 << 29) \n            msr     nzcv, x0        // stc = error \n            mov     x0, #-1         // Value out of range ... \n            ret \n            endp    expToBuf \n```", "```\n// Listing9-13.S (cont.) \n//\n// e64ToStr \n//\n// Converts a REAL64 floating-point number to the \n// corresponding string of digits. Note that this \n// function always emits the string using scientific \n// notation; use the r64ToStr routine for decimal notation. \n//\n// On entry: \n//\n//  D0-     (e64) Double-precision value to convert \n//\n//  X0-     (buffer) e64ToStr stores the resulting characters in \n//          this buffer. \n//\n//  X1-     (width) Field width for the number (note that this \n//          is an *exact* field width, not a minimum \n//          field width) \n//\n//  X2-     (fill) Padding character if the number is smaller \n//          than the specified field width \n//\n//  X3-     (expDigs) Number of exponent digits (2 for real32 \n//          and 3 for real64) \n//\n//  X4-     (maxLength) Maximum buffer size \n//\n// On exit: \n//\n//  Buffer contains the newly formatted string. If the \n//  formatted value does not fit in the width specified, \n//  e64ToStr will store \"#\" characters into this string. \n//\n//  Carry-  Clear if no error, set if error. \n//          If error, X0 is \n//              -3 if string overflow \n//              -2 if bad width \n//              -1 if value out of range \n//\n//-----------------------------------------------------------\n//\n// Unlike the integer-to-string conversions, this routine \n// always right-justifies the number in the specified \n// string. Width must be a positive number; negative \n// values are illegal (actually, they are treated as \n// *really* big positive numbers that will always raise \n// a string overflow exception). \n//\n//***********************************************************\n\n            proc       e64ToStr \n\n#define     e2sWidth   x19      // chkNaNINF expects this here. \n#define     e2sExp     x20 \n#define     e2sFill    x21      // chkNaNINF expects this here. \n#define     e2sBuffer  x22      // chkNaNINF expects this here. \n#define     e2sMaxLen  x23 \n#define     e2sExpDigs x24 \n\n#define     e2sSign    w25 \n#define     eFailAdrs  x25      // chkNaNINF expects this here. \n#define     e2sMantSz  x26 \n\n            locals  e2s \n            qword   e2s.x1x2 \n            qword   e2s.x3x4 \n            qword   e2s.x5x19 \n            qword   e2s.x20x21 \n            qword   e2s.x22x23 \n            qword   e2s.x24x25 \n            qword   e2s.x26x27 \n            dword   e2s.x0 \n            dword   e2s.d0 \n            byte    e2s.digits, 64 \n            byte    e2s.stack, 64 \n            endl    e2s \n\n            // Build activation record and preserve registers: \n\n            enter   e2s.size \n            str     x0,       [fp, #e2s.x0] \n            stp     x1,  x2,  [fp, #e2s.x1x2] \n            stp     x3,  x4,  [fp, #e2s.x3x4] \n            stp     x5,  x19, [fp, #e2s.x5x19] \n            stp     x20, x21, [fp, #e2s.x20x21] \n            stp     x22, x23, [fp, #e2s.x22x23] \n            stp     x24, x25, [fp, #e2s.x24x25] \n            stp     x26, x27, [fp, #e2s.x26x27] \n            str     d0,       [fp, #e2s.d0] \n\n            // Move important data to nonvolatile registers: \n\n            mov     e2sBuffer, x0 \n            mov     e2sWidth, x1 \n            mov     e2sFill, x2 \n            mov     e2sExpDigs, x3 \n            mov     e2sMaxLen, x4 \n\n            // See if the width is greater than the buffer size: \n\n            cmp     e2sWidth, e2sMaxLen \n            bhs     strOvfl \n\n            strb    wzr, [e2sBuffer, e2sWidth]  // Zero-terminate str. \n\n// First, make sure the width isn't 0: \n\n          ❶ cmp     e2sWidth, #0 \n            beq     valOutOfRng \n\n// Just to be on the safe side, don't allow widths greater \n// than 1024: \n\n cmp     e2sWidth, #1024 \n            bhi     badWidth \n\n// Check for NaN and INF: \n\n          ❷ lea     failAdrs, exit_eToBuf   // Note: X25, used before \n            bl      chkNaNINF               // e2sSign (also X25) \n\n// Okay, do the conversion: \n\n          ❸ add     x0, fp, #e2s.digits // lea x1, e2s.digits \n            bl      FPDigits        // Convert D0 to digit str. \n            mov     e2sExp, x1      // Save away exponent result. \n            mov     e2sSign, w2     // Save mantissa sign char. \n\n// Verify that there is sufficient room for the mantissa's sign, \n// the decimal point, two mantissa digits, the \"E\",\n// and the exponent's sign. Also add in the number of digits \n// required by the exponent (2 for single, 3 for double). \n//\n// -1.2e+00    :real4 \n// -1.2e+000   :real8 \n\n          ❹ add     x2, e2sExpDigs, #6    // Minimum number of posns \n            cmp     x2, e2sWidth \n            bls     goodWidth \n\n// Output a sequence of \"#...#\" chars (to the specified width) \n// if the width value is not large enough to hold the \n// conversion: \n\n            mov     x2, e2sWidth \n            mov     x0, #'#' \n            mov     x1, e2sBuffer \nfillPnd:    strb    w0, [x1] \n            add     x1, x1, #1 \n            subs    x2, x2, #1 \n            bne     fillPnd \n            b.al    exit_eToBuf \n\n// Okay, the width is sufficient to hold the number; do the \n// conversion and output the string here: \n\ngoodWidth: \n            // Compute the # of mantissa digits to display, \n            // not counting mantissa sign, decimal point, \n            // \"E\", and exponent sign: \n\n          ❺ sub     e2sMantSz, e2sWidth, e2sExpDigs \n            sub     e2sMantSz, e2sMantSz, #4 \n\n            // Round the number to the specified number of \n            // print positions. (Note: since there are a \n            // maximum of 16 significant digits, don't \n // bother with the rounding if the field width \n            // is greater than 16 digits.) \n\n            cmp     e2sMantSz, #maxDigits \n            bhs     noNeedToRound \n\n            // To round the value to the number of \n            // significant digits, go to the digit just \n            // beyond the last one you are considering (e2sMantSz \n            // currently contains the number of decimal \n            // positions) and add 5 to that digit. \n            // Propagate any overflow into the remaining \n            // digit positions. \n\n            add     x1, e2sMantSz, #1 \n            add     x2, fp, #e2s.digits // lea x2, e2s.digits \n            ldrb    w0, [x2, x1]        // Get least sig digit + 1\\. \n            add     w0, w0, #5          // Round (for example, +0.5). \n            cmp     w0, #'9' \n            bhi     whileDigGT9 \n            b.al    noNeedToRound \n\n// Sneak this code in here, after a branch, so the \n// loop below doesn't get broken up. \n\nfirstDigitInNumber: \n\n            // If you get to this point, you've hit the \n            // first digit in the number, so you have to \n            // shift all the characters down one position \n            // in the string of bytes and put a \"1\" in the \n            // first character position. \n\n            ldr     x0, [x2, #8] \n            str     x0, [x2, #9] \n            ldr     x0, [x2] \n            str     x0, [x2, #1] \n\n            mov     x0, #'1'        // Store '1' in 1st \n            strb    w0, [x2]        // digit position. \n\n            // Bump exponent by 1, as the shift did \n            // a divide by 10\\. \n\n            add     e2sExp, e2sExp, #1 \n            b.al    noNeedToRound \n\n// Subtract out overflow and add the carry into the previous \n// digit (unless you hit the first digit in the number): \n\nwhileDigGT9: \n            sub     w0, w0, #10 \n            strb    w0, [x2, x1] \n            subs    x1, x1, #1 \n            bmi     firstDigitInNumber \n\n // Add in carry to previous digit: \n\n            ldrb    w0, [x2, x1] \n            add     w0, w0, #1 \n            strb    w0, [x2, x1] \n            cmp     w0, #'9'        // Overflow if char > '9' \n            bhi     whileDigGT9 \n\nnoNeedToRound: \n            add     x2, fp, #e2s.digits // lea x2, e2s.digits \n\n// Okay, emit the string at this point. This is pretty easy, \n// since all you really need to do is copy data from the \n// digits array and add an exponent (plus a few other simple chars). \n\n          ❻ mov     x1, #0      // Count output mantissa digits. \n            strb    e2sSign, [e2sBuffer], #1 \n\n// Output the first character and a following decimal point \n// if there are more than two mantissa digits to output. \n\n            ldrb    w0, [x2] \n            strb    w0, [e2sBuffer], #1 \n            add     x1, x1, #1 \n            cmp     x1, e2sMantSz \n            beq     noDecPt \n\n            mov     w0, #'.' \n            strb    w0, [e2sBuffer], #1 \n\nnoDecPt: \n\n// Output any remaining mantissa digits here. \n// Note that if the caller requests the output of \n// more than 16 digits, this routine will output 0s \n// for the additional digits. \n\n            b.al    whileX2ltMantSizeTest \n\nwhileX2ltMantSize: \n\n            mov     w0, #'0' \n            cmp     x1, #maxDigits \n            bhs     justPut0 \n\n            ldrb    w0, [x2, x1] \n\njustPut0: \n            strb    w0, [e2sBuffer], #1 \n            add     x1, x1, #1 \n\nwhileX2ltMantSizeTest: \n\n            cmp     x1, e2sMantSz \n            blo     whileX2ltMantSize \n\n// Output the exponent: \n\n          ❼ mov     w0, #'e' \n            strb    w0, [e2sBuffer], #1 \n            mov     w0, #'+' \n            mov     w4, #'-' \n            neg     x5, e2sExp \n\n            cmp     e2sExp, #0 \n            csel    w0, w0, w4, ge \n            csel    e2sExp, e2sExp, x5, ge \n\n            strb    w0, [e2sBuffer], #1 \n\n            mov     x0, e2sExp \n            mov     x1, e2sExpDigs \n            mov     x2, e2sBuffer \n            bl      expToBuf \n            bcs     error \n\nexit_eToBuf: \n            msr     nzcv, xzr    // clc = no error \n            ldr     x0, [fp, #e2s.x0] \n\nreturnE64: \n            ldp     x1,  x2,  [fp, #e2s.x1x2] \n            ldp     x3,  x4,  [fp, #e2s.x3x4] \n            ldp     x5,  x19, [fp, #e2s.x5x19] \n            ldp     x20, x21, [fp, #e2s.x20x21] \n            ldp     x22, x23, [fp, #e2s.x22x23] \n            ldp     x24, x25, [fp, #e2s.x24x25] \n            ldp     x26, x27, [fp, #e2s.x26x27] \n            ldr     d0,       [fp, #e2s.d0] \n            leave \n\nstrOvfl:    mov     x0, #-3 \n            b.al    error \n\nbadWidth:   mov     x0, #-2 \n            b.al    error \n\nvalOutOfRng: \n            mov     x0, #-1 \nerror: \n            mrs     x1, nzcv \n            orr     x1, x1, #(1 << 29) \n            msr     nzcv, x1        // stc = error \n            b.al    returnE64 \n\n            endp    e64ToStr \n```", "```\n// Listing9-13.S (cont.) \n//\n            proc    r64Print \n\n            stp     x0, x1, [sp, #-16]! \n            stp     x2, x3, [sp, #-16]! \n            stp     x4, x5, [sp, #-16]! \n            stp     x6, x7, [sp, #-16]! \n            stp     x8, lr, [sp, #-16]! \n            sub     sp, sp, #64 \n\n            lea     x0, fmtStr1 \n            lea     x1, r64str_1 \n            mstr    x1, [sp] \n            bl      printf \n\n            add     sp, sp, #64 \n            ldp     x8, lr, [sp], #16 \n            ldp     x6, x7, [sp], #16 \n            ldp     x4, x5, [sp], #16 \n            ldp     x2, x3, [sp], #16 \n ldp     x0, x1, [sp], #16 \n            ret \n            endp    r64Print \n\n            proc    e64Print \n            stp     x0, x1, [sp, #-16]! \n            stp     x2, x3, [sp, #-16]! \n            stp     x4, x5, [sp, #-16]! \n            stp     x6, x7, [sp, #-16]! \n            stp     x8, lr, [sp, #-16]! \n            sub     sp, sp, #64 \n\n            lea     x0, fmtStr3 \n            lea     x1, r64str_1 \n            mstr    x1, [sp] \n            bl      printf \n\n            add     sp, sp, #64 \n            ldp     x8, lr, [sp], #16 \n            ldp     x6, x7, [sp], #16 \n            ldp     x4, x5, [sp], #16 \n            ldp     x2, x3, [sp], #16 \n            ldp     x0, x1, [sp], #16 \n            ret \n            endp    e64Print \n```", "```\n// Listing9-13.S (cont.) \n//\n❶ r64_1:      .double  1.234567890123456 \n            .double  0.0000000000000001 \n            .double  1234567890123456.0 \n            .double  1234567890.123456 \n            .double  99499999999999999.0 \n            .dword   0x7ff0000000000000 \n            .dword   0xfff0000000000000 \n            .dword   0x7fffffffffffffff \n            .dword   0xffffffffffffffff \n            .double  0.0 \n            .double  -0.0 \nfCnt         =       (. - r64_1) \n\nrSizes:     .word    12, 12, 2, 7, 0, 0, 0, 0, 0, 2, 2 \n\ne64_1:      .double  1.234567890123456e123 \n            .double  1.234567890123456e-123 \ne64_3:      .double  1.234567890123456e1 \n .double  1.234567890123456e-1 \n            .double  1.234567890123456e10 \n            .double  1.234567890123456e-10 \n            .double  1.234567890123456e100 \n            .double  1.234567890123456e-100 \n            .dword   0x7ff0000000000000 \n            .dword   0xfff0000000000000 \n            .dword   0x7fffffffffffffff \n            .dword   0xffffffffffffffff \n            .double  0.0 \n            .double  -0.0 \neCnt         =       (. - e64_1) \n\neSizes:     .word    6, 9, 8, 12, 14, 16, 18, 20, 12, 12, 12, 12, 8, 8 \nexpSizes:   .word    3, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2 \n\n// Here is the asmMain function: \n\n            proc    asmMain, public \n\n            locals  am \n            dword   am.x8x9 \n            dword   am.x27 \n            byte    am.stk, 64 \n            endl    am \n\n            enter   am.size     // Activation record \n            stp     x8, x9, [fp, #am.x8x9] \n            str     x27,    [fp, #am.x27] \n\n// F output \n\n            mov     x2, #16         // decDigits \nfLoop: \n            ldr     d0, r64_1 \n            lea     x0, r64str_1    // Buffer \n            mov     x1, #30         // fWidth \n            mov     x3, #'.'        // Fill \n            mov     x4, 32          // maxLength \n            bl      r64ToStr \n            bcs     fpError \n            bl      r64Print \n            subs    x2, x2, #1 \n            bpl     fLoop \n\n            lea     x0, newlines \n            bl      printf \n\n            lea     x5, r64_1 \n            lea     x6, rSizes \n            mov     x7, #fCnt/8 \nf2Loop:     ldr     d0, [x5], #8 \n            lea     x0, r64str_1    // Buffer \n            mov     x1, #30         // fWidth \n ldr     w2, [x6], #4    // decDigits \n            mov     x3, #'.'        // Fill \n            mov     x4, #32         // maxLength \n            bl      r64ToStr \n            bcs     fpError \n            bl      r64Print \n            subs    x7, x7, #1 \n            bne     f2Loop \n\n// E output \n\n            lea     x0, expStr \n            bl      printf \n\n            lea     x5, e64_1 \n            lea     x6, eSizes \n            lea     x7, expSizes \n            mov     x8, #eCnt/8 \neLoop: \n            ldr     d0, [x5], #8 \n            lea     x0, r64str_1    // Buffer \n            ldr     w1, [x6], #4    // fWidth \n            mov     x2, #'.'        // Fill \n            ldr     w3, [x7], #4    // expDigits \n            mov     x4, #32         // maxLength \n            bl      e64ToStr \n            bcs     fpError \n            bl      e64Print \n            subs    x8, x8, #1 \n            bne     eLoop \n            b.al    allDone \n\nfpError: \n            mov     x1, x0 \n            lea     x0, fmtStr2 \n            mstr    x1, [sp] \n            bl      printf \n\nallDone: \n            ldp     x8, x9, [fp, #am.x8x9] \n            ldr     x27,    [fp, #am.x27] \n            leave \n            endp    asmMain \n```", "```\n% ./build Listing9-13 \n% 1G \nCalling Listing9-13: \nr64ToStr: value='........... 1.2345678901234560' \nr64ToStr: value='............ 1.234567890123456' \nr64ToStr: value='............. 1.23456789012345' \nr64ToStr: value='.............. 1.2345678901234' \nr64ToStr: value='............... 1.234567890123' \nr64ToStr: value='................ 1.23456789012' \nr64ToStr: value='................. 1.2345678901' \nr64ToStr: value='.................. 1.234567890' \nr64ToStr: value='................... 1.23456789' \nr64ToStr: value='.................... 1.2345678' \nr64ToStr: value='..................... 1.234567' \nr64ToStr: value='...................... 1.23456' \nr64ToStr: value='....................... 1.2345' \nr64ToStr: value='........................ 1.234' \nr64ToStr: value='......................... 1.23' \nr64ToStr: value='.......................... 1.2' \nr64ToStr: value='............................ 1' \n\nr64ToStr: value='............... 1.234567890123' \nr64ToStr: value='............... 0.000000000000' \nr64ToStr: value='.......... 1234567890123456.00' \nr64ToStr: value='........... 1234567890.1234560' \nr64ToStr: value='............ 99500000000000000' \nr64ToStr: value='INF                           ' \nr64ToStr: value='-INF                          ' \nr64ToStr: value='NaN                           ' \nr64ToStr: value='NaN                           ' \nr64ToStr: value='......................... 0.00' \nr64ToStr: value='.........................-0.00' \n\nTesting e64ToStr: \n\ne64ToStr: value='######' \ne64ToStr: value=' 1.2e-123' \ne64ToStr: value=' 1.2e+01' \ne64ToStr: value=' 1.23456e-01' \ne64ToStr: value=' 1.2345678e+10' \ne64ToStr: value=' 1.234567890e-10' \ne64ToStr: value=' 1.2345678901e+100' \ne64ToStr: value=' 1.234567890123e-100' \ne64ToStr: value='INF         ' \ne64ToStr: value='-INF        ' \ne64ToStr: value='NaN         ' \ne64ToStr: value='NaN         ' \ne64ToStr: value=' 0.0e+00' \ne64ToStr: value='-0.0e+00' \nListing9-13 terminated \n```", "```\n// Listing9-14.S \n//\n// String-to-numeric conversion \n\n            #include    \"aoaa.inc\"\n\nfalse       =           0 \ntrue        =           1 \ntab         =           9 \n\n            .section    .rodata, \"\" \nttlStr:     .asciz      \"Listing 9-14\"\nfmtStr1:    .ascii      \"strtou: String='%s'\\n\"\n            .asciz      \"    value=%llu\\n\"\n\nfmtStr2:    .ascii      \"Overflow: String='%s'\\n\"\n            .asciz      \"    value=%llx\\n\"\n\nfmtStr3:    .ascii      \"strtoi: String='%s'\\n\"\n            .asciz      \"    value=%lli\\n\"\n\nunexError:  .asciz      \"Unexpected error in program\\n\"\n\nvalue1:     .asciz      \"  1\"\nvalue2:     .asciz      \"12 \" \nvalue3:     .asciz      \" 123 \" \nvalue4:     .asciz      \"1234\"\nvalue5:     .asciz      \"1234567890123456789\"\nvalue6:     .asciz      \"18446744073709551615\"\nOFvalue:    .asciz      \"18446744073709551616\"\nOFvalue2:   .asciz      \"999999999999999999999\"\n\nivalue1:    .asciz      \"  -1\"\nivalue2:    .asciz      \"-12 \" \nivalue3:    .asciz      \" -123 \" \nivalue4:    .asciz      \"-1234\"\nivalue5:    .asciz      \"-1234567890123456789\"\nivalue6:    .asciz      \"-18446744073709551615\"\nOFivalue:   .asciz      \"18446744073709551616\"\nOFivalue2:  .asciz      \"-18446744073709551616\"\n\n            .code \n            .extern     printf \n\n////////////////////////////////////////////////////////////////////\n//\n// Return program title to C++ program: \n\n            proc        getTitle, public \n            lea         x0, ttlStr \n            ret \n            endp        getTitle \n```", "```\n// Listing9-14.S (cont.) \n//\n////////////////////////////////////////////////////////////////////\n//\n// strtou \n//\n// Converts string data to a 64-bit unsigned integer \n//\n// Input: \n//\n//   X1-    Pointer to buffer containing string to convert \n//\n// Outputs: \n//\n//   X0-    Contains converted string (if success), error code \n//          if an error occurs \n//\n//   X1-    Points at first char beyond end of numeric string \n//          If error, X1's value is restored to original value. \n//          Caller can check character at [X1] after a \n//          successful result to see if the character following \n//          the numeric digits is a legal numeric delimiter. \n//\n//   C-     (carry flag) Set if error occurs, clear if \n//          conversion was successful. On error, X0 will \n//          contain 0 (illegal initial character) or \n//          0ffffffffffffffffh (overflow). \n\n            proc    strtou \n\n            str     x5, [sp, #-16]! \n            stp     x3, x4, [sp, #-16]! \n            stp     x1, x2, [sp, #-16]! \n\n            mov     x3, xzr \n            mov     x0, xzr \n            mov     x4, #10     // Used to mul by 10 \n\n            // The following loop skips over any whitespace (spaces and \n            // tabs) that appear at the beginning of the string: \n\n          ❶ sub     x1, x1, #1      // Incremented below \nskipWS:     ldrb    w2, [x1, #1]!   // Fetch next (first) char. \n            cmp     w2, #' ' \n            beq     skipWS \n            cmp     w2, #tab \n            beq     skipWS \n\n            // If you don't have a numeric digit at this \n            // point, return an error. \n\n          ❷ cmp     w2, #'0'  // Note: '0' < '1' < ... < '9' \n            blo     badNumber \n            cmp     w2, #'9' \n            bhi     badNumber \n\n// Okay, the first digit is good. Convert the string \n// of digits to numeric form. \n//\n// Have to check for unsigned integer overflow here. \n// Unfortunately, madd does not set the carry or \n// overflow flag, so you have to use umulh to see if \n// overflow occurs after a multiplication and do \n// an explicit add (rather than madd) to add the \n// digit into the accumulator (X0). \n\n❸ convert:    umulh   x5, x0, x4      // Acc * 10 \n            cmp     x5, xzr \n            bne     overflow \n            and     x2, x2, #0xf    // Char -> numeric in X2 \n            mul     x0, x0, x4      // Can't use madd! \n            adds    x0, x0, x2      // Add in digit. \n            bcs     overflow \n\n ❹ ldrb    w2, [x1, #1]!   // Get next char. \n            cmp     w2, #'0'        // Check for digit. \n            blo     endOfNum \n            cmp     w2, #'9' \n            bls     convert \n\n// If you get to this point, you've successfully converted \n// the string to numeric form. Return without restoring \n// the value in X1 (X1 points at end of digits). \n\n❺ endOfNum:   ldp     x3, x4, [sp], #16   // Really X1, X2 \n            mov     x2, x4 \n            ldp     x3, x4, [sp], #16 \n            ldr     x5, [sp], #16 \n\n            // Because the conversion was successful, this \n            // procedure leaves X1 pointing at the first \n            // character beyond the converted digits. \n            // Therefore, we don't restore X1 from the stack. \n\n            msr     nzcv, xzr    // clr c = no error \n            ret \n\n// badNumber- Drop down here if the first character in \n//            the string was not a valid digit. \n\n❻ badNumber:  mov     x0, xzr \nerrorRet:   mrs     x1, nzcv    // Return error in carry flag. \n            orr     x1, x1, #(1 << 29) \n            msr     nzcv, x1    // Set c = error. \n\n            ldp     x1, x2, [sp], #16 \n            ldp     x3, x4, [sp], #16 \n            ldr     x5, [sp], #16 \n            ret \n\n// overflow- Drop down here if the accumulator overflowed \n//           while adding in the current character. \n\noverflow:   mov     x0, #-1  // 0xFFFFFFFFFFFFFFFF \n            b.al    errorRet \n            endp    strtou \n```", "```\nand  x2, x2, #0xf \nmadd x0, x0, x4, x2 // X4 contains 10\\. \n```", "```\n// Listing9-14.S (cont.) \n//\n// strtoi \n//\n// Converts string data to a 64-bit signed integer \n//\n// Input: \n//\n//   X1-    Pointer to buffer containing string to convert \n//\n// Outputs: \n//\n//   X0-    Contains converted string (if success), error code \n//          if an error occurs \n//\n//   X1-    Points at first char beyond end of numeric string. \n//          If error, X1's value is restored to original value. \n//          Caller can check character at [X1] after a \n//          successful result to see if the character following \n//          the numeric digits is a legal numeric delimiter. \n//\n//   C-    (carry flag) Set if error occurs, clear if \n//         conversion was successful. On error, X0 will \n//         contain 0 (illegal initial character) or \n//         -1 (overflow). \n\ntooBig:     .dword  0x7fffffffffffffff \n\n            proc    strtoi \n\n            locals  si \n            qword   si.saveX1X2 \n            endl    si \n\n            enter   si.size \n\n            // Preserve X1 in case you have to restore it; \n            // X2 is the sign flag: \n\n            stp     x1, x2, [fp, #si.saveX1X2] \n\n            // Assume you have a nonnegative number: \n\n            mov     x2, #false \n\n// The following loop skips over any whitespace (spaces and \n// tabs) that appear at the beginning of the string: \n\n          ❶ sub     x1, x1, #1  // Adjust for +1 below. \nskipWSi:    ldrb    w0, [x1, #1]! \n            cmp     w0, #' ' \n            beq     skipWSi \n            cmp     w0, #tab \n            beq     skipWSi \n\n            // If the first character you've encountered is \n            // '-', then skip it, but remember that this is \n            // a negative number: \n\n          ❷ cmp     w0, #'-' \n            bne     notNeg \n            mov     w2, #true \n            add     x1, x1, #1  // Skip '-' \n\n❸ notNeg:     bl      strtou       // Convert string to integer. \n            bcs     hadError \n\n            // strtou returned success. Check the negative \n            // flag and negate the input if the flag \n            // contains true: \n\n          ❹ cmp     w2, #true \n            bne     itsPosOr0 \n\n            negs    x0, x0 \n            bvs     overflowi \n            ldr     x2, [fp, #si.saveX1X2+8] \n msr     nzcv, xzr   // clr c = no error \n            leave \n\n// Success, so don't restore X1: \n\nitsPosOr0: \n            ldr     x2, tooBig \n            cmp     x0, x2     // Number is too big. \n            bhi     overflowi \n            ldr     x2, [fp, #si.saveX1X2+8] \n            msr     nzcv, xzr  // clr c = no error \n            leave \n\n// If you have an error, you need to restore RDI from the stack: \n\noverflowi:  mov     x0, #-1     // Indicate overflow. \nhadError: \n            mrs     x2, nzcv    // Return error in carry flag. \n            orr     x2, x2, #(1 << 29) \n            msr     nzcv, x2    // Set c = error. \n            ldp     x1, x2, [fp, #si.saveX1X2] \n            leave \n            endp    strtoi \n```", "```\n// Listing9-14.S (cont.) \n//\n////////////////////////////////////////////////////////////////////\n//\n// Here is the asmMain function: \n\n            proc    asmMain, public \n\n            locals  am \n            byte    am.shadow, 64 \n            endl    am \n\n            enter   am.size \n\n// Test unsigned conversions: \n\n            lea     x1, value1 \n            bl      strtou \n            bcs     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr1 \n            lea     x1, value1 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, value2 \n            bl      strtou \n            bcs     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr1 \n            lea     x1, value2 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, value3 \n            bl      strtou \n            bcs     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr1 \n            lea     x1, value3 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, value4 \n            bl      strtou \n            bcs     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr1 \n            lea     x1, value4 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n lea     x1, value5 \n            bl      strtou \n            bcs     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr1 \n            lea     x1, value5 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, value6 \n            bl      strtou \n            bcs     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr1 \n            lea     x1, value6 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, OFvalue \n            bl      strtou \n            bcc     UnexpectedError \n            cmp     x0, xzr        // Nonzero for overflow \n            beq     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr2 \n            lea     x1, OFvalue \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, OFvalue2 \n            bl      strtou \n            bcc     UnexpectedError \n            cmp     x0, xzr        // Nonzero for overflow \n            beq     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr2 \n            lea     x1, OFvalue2 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n// Test signed conversions: \n\n            lea     x1, ivalue1 \n            bl      strtoi \n            bcs     UnexpectedError \n\n            mov     x2, x0 \n lea     x0, fmtStr3 \n            lea     x1, ivalue1 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, ivalue2 \n            bl      strtoi \n            bcs     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr3 \n            lea     x1, ivalue2 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, ivalue3 \n            bl      strtoi \n            bcs     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr3 \n            lea     x1, ivalue3 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, ivalue4 \n            bl      strtoi \n            bcs     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr3 \n            lea     x1, ivalue4 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, ivalue5 \n            bl      strtoi \n            bcs     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr3 \n            lea     x1, ivalue5 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, ivalue6 \n            bl      strtoi \n            bcs     UnexpectedError \n\n mov     x2, x0 \n            lea     x0, fmtStr3 \n            lea     x1, ivalue6 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, OFivalue \n            bl      strtoi \n            bcc     UnexpectedError \n            cmp     x0, xzr        // Nonzero for overflow \n            beq     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr2 \n            lea     x1, OFivalue \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            lea     x1, OFivalue2 \n            bl      strtoi \n            bcc     UnexpectedError \n            cmp     x0, xzr        // Nonzero for overflow \n            beq     UnexpectedError \n\n            mov     x2, x0 \n            lea     x0, fmtStr2 \n            lea     x1, OFivalue2 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            b.al    allDone \n\nUnexpectedError: \n            lea     x0, unexError \n            bl      printf \n\nallDone:    leave   // Returns to caller \n            endp    asmMain \n```", "```\n% ./build Listing9-14 \n% ./Listing9-14 \nCalling Listing9-14: \nstrtou: String='  1' \n    value=1 \nstrtou: String='12 ' \n    value=12 \nstrtou: String=' 123 ' \n    value=123 \nstrtou: String='1234' \n    value=1234 \nstrtou: String='1234567890123456789' \n    value=1234567890123456789 \nstrtou: String='18446744073709551615' \n    value=18446744073709551615 \nOverflow: String='18446744073709551616' \n    value=ffffffffffffffff \nOverflow: String='999999999999999999999' \n    value=ffffffffffffffff \nstrtoi: String='  -1' \n    value=-1 \nstrtoi: String='-12 ' \n    value=-12 \nstrtoi: String=' -123 ' \n    value=-123 \nstrtoi: String='-1234' \n    value=-1234 \nstrtoi: String='-1234567890123456789' \n    value=-1234567890123456789 \nstrtoi: String='-18446744073709551615' \n    value=1 \nOverflow: String='18446744073709551616' \n    value=ffffffffffffffff \nOverflow: String='-18446744073709551616' \n    value=ffffffffffffffff \nListing9-14 terminated \n```", "```\n// Listing9-15.S \n//\n// Hexadecimal-string-to-numeric conversion \n\n            #include    \"aoaa.inc\"\n\nfalse       =           0 \ntrue        =           1 \ntab         =           9 \n\n            .section    .rodata, \"\" \nttlStr:     .asciz      \"Listing 9-15\"\nfmtStr1:    .ascii      \"strtoh: String='%s' \" \n            .asciz      \"value=%llx\\n\"\n\nfmtStr2:    .asciz      \"Error, str='%s', x0=%lld\\n\"\n\nfmtStr3:    .ascii      \"Error, expected overflow: x0=%llx, \" \n            .asciz      \"str='%s'\\n\"\n\nfmtStr4:    .ascii      \"Error, expected bad char: x0=%llx, \" \n            .asciz      \"str='%s'\\n\"\n\nhexStr:     .asciz      \"1234567890abcdef\"\nhexStrOVFL: .asciz      \"1234567890abcdef0\"\nhexStrBAD:  .asciz      \"x123\"\n\n            .code \n            .extern     printf \n\n/////////////////////////////////////////////////////////////\n//\n// Return program title to C++ program: \n\n            proc    getTitle, public \n            lea     x0, ttlStr \n            ret \n            endp    getTitle \n\n/////////////////////////////////////////////////////////////\n//\n// strtoh: \n//\n// Converts string data to a 64-bit unsigned integer \n//\n// Input: \n//\n//   X1-    Pointer to buffer containing string to convert \n//\n// Outputs: \n//\n//   X0-    Contains converted string (if success), error code \n//          if an error occurs \n//\n//   X1-    Points at first char beyond end of hexadecimal string. \n//          If error, X1's value is restored to original value. \n//          Caller can check character at [X1] after a \n//          successful result to see if the character following \n//          the hexadecimal digits is a legal delimiter. \n//\n//   C-     (carry flag) Set if error occurs, clear if \n//          conversion was successful. On error, X0 will \n//          contain 0 (illegal initial character) or \n//          -1 = 0xffffffffffffffff (overflow). \n\n            proc    strtoh \n\n            stp     x3, x4, [sp, #-16]! \n            stp     x1, x2, [sp, #-16]! \n\n            // This code will use the value in X3 to test \n            // whether overflow will occur in X0 when \n            // shifting to the left 4 bits: \n\n            mov     x3, 0xF000000000000000 \n            mov     x0, xzr // Zero out accumulator. \n\n            // 0x5f is used to convert lowercase to \n            // uppercase: \n\n            mov     x4, 0x5f \n\n// The following loop skips over any whitespace (spaces and \n// tabs) that appear at the beginning of the string: \n\n            sub     x1, x1, #1  // Because of inc below \nskipWS:     ldrb    w2, [x1, #1]! \n            cmp     w2, #' ' \n            beq     skipWS \n            cmp     w2, #tab \n            beq     skipWS \n\n            // If you don't have a hexadecimal digit at this \n            // point, return an error: \n\n ❶ cmp     w2, #'0'    // Note: '0' < '1' < ... < '9' \n            blo     badNumber \n            cmp     w2, #'9' \n            bls     convert \n            and     x2, x2, x4  // Cheesy LC -> UC conversion \n            cmp     w2, #'A' \n            blo     badNumber \n            cmp     w2, #'F' \n            bhi     badNumber \n            sub     w2, w2, #7  // Maps 41h..46h -> 3ah..3fh \n\n            // Okay, the first digit is good. Convert the \n            // string of digits to numeric form: \n\n❷ convert:    ands    xzr, x3, x0  // See if adding in the current \n            bne     overflow     // digit will cause an overflow. \n\n            and     x2, x2, #0xf // Convert to numeric in X2\\. \n\n            // Multiply 64-bit accumulator by 16 and add in \n            // new digit: \n\n          ❸ lsl     x0, x0, #4 \n            add     x0, x0, x2  // Never overflows \n\n            // Move on to next character: \n\n            ldrb    w2, [x1, #1]! \n            cmp     w2, #'0' \n            blo     endOfNum \n            cmp     w2, #'9' \n            bls     convert \n\n            and     x2, x2, x4  // Cheesy LC -> UC conversion \n            cmp     x2, #'A' \n            blo     endOfNum \n            cmp     x2, #'F' \n            bhi     endOfNum \n            sub     x2, x2, #7  // Maps 41h..46h -> 3ah..3fh \n            b.al    convert \n\n// If you get to this point, you've successfully converted \n// the string to numeric form: \n\nendOfNum: \n\n            // Because the conversion was successful, this \n            // procedure leaves X1 pointing at the first \n            // character beyond the converted digits. \n            // Therefore, don't restore X1 from the stack. \n\n            ldp     x3, x2, [sp], #16   // X3 holds old X1 \n            ldp     x3, x4, [sp], #16 \n            msr     nzcv, xzr   // clr c = no error \n            ret \n\n// badNumber- Drop down here if the first character in \n//            the string was not a valid digit. \n\nbadNumber:  mov     x0, xzr \n            b.al    errorExit \n\noverflow:   mov     x0, #-1     // Return -1 as error on overflow. \nerrorExit: \n            mrs     x1, nzcv    // Return error in carry flag. \n            orr     x1, x1, #(1 << 29) \n            msr     nzcv, x1    // Set c = error. \n\n            ldp     x1, x2, [sp], #16 \n            ldp     x3, x4, [sp], #16 \n            ret \n            endp    strtoh \n\n/////////////////////////////////////////////////////////////\n//\n// Here is the asmMain function: \n\n            proc    asmMain, public \n\n            locals  am \n            byte    am.stack, 64 \n            endl    am \n\n            enter   am.size \n\n            // Test hexadecimal conversion: \n\n            lea     x1, hexStr \n            bl      strtoh \n            bcs     error \n\n            mov     x2, x0 \n            lea     x1, hexStr \n            lea     x0, fmtStr1 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n // Test overflow conversion: \n\n            lea     x1, hexStrOVFL \n            bl      strtoh \n            bcc     unexpected \n\n            mov     x2, x0 \n            lea     x0, fmtStr2 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n// Test bad character: \n\n            lea     x1, hexStrBAD \n            bl      strtoh \n            bcc     unexp2 \n\n            mov     x2, x0 \n            lea     x0, fmtStr2 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\n            b.al    allDone \n\nunexpected: mov     x3, x0 \n            lea     x0, fmtStr3 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            mstr    x3, [sp, #16] \n            bl      printf \n            b.al    allDone \n\nunexp2:     mov     x3, x0 \n            lea     x0, fmtStr4 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            mstr    x3, [sp, #16] \n            bl      printf \n            b.al    allDone \n\nerror:      mov     x2, x0 \n            lea     x0, fmtStr2 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            bl      printf \n\nallDone:    leave \n            endp    asmMain \n```", "```\n% ./build Listing9-15 \n% ./Listing9-15 \nCalling Listing9-15: \nstrtoh: String='1234567890abcdef' value=1234567890abcdef \nError, str='1234567890abcdef0', x0=-1 \nError, str='x123', x0 = 0 \nListing9-15 terminated \n```", "```\n// Listing9-16.S \n//\n// 128-bit Hexadecimal-string-to-numeric conversion \n\n            #include    \"aoaa.inc\"\n\nfalse       =           0 \ntrue        =           1 \ntab         =           9 \n\n            .section    .rodata, \"\" \n tlStr:     .asciz      \"Listing 9-16\"\n\nfmtStr1:    .asciz      \"strtoh128: value=%llx%llx, String='%s'\\n\"\n\nhexStr:     .asciz      \"1234567890abcdeffedcba0987654321\"\n\n            .code \n            .extern     printf \n\n/////////////////////////////////////////////////////////////\n//\n// Return program title to C++ program: \n\n            proc    getTitle, public \n            lea     x0, ttlStr \n            ret \n            endp    getTitle \n\n/////////////////////////////////////////////////////////////\n//\n// strtoh128 \n//\n// Converts string data to a 128-bit unsigned integer \n//\n// Input: \n//\n//   X2-    Pointer to buffer containing string to convert \n//\n// Outputs: \n//\n//   X1:X0- Contains converted string (if success), error code \n//          if an error occurs \n//\n//   X2-    Points at first char beyond end of hexadecimal \n//          string. If error, X2's value is restored to \n//          original value. \n//          Caller can check character at [X2] after a \n//          successful result to see if the character following \n//          the hexadecimal digits is a legal delimiter. \n//\n//   C-     (carry flag) Set if error occurs, clear if \n//          conversion was successful. On error, X0 will \n//          contain 0 (illegal initial character) or \n//          -1 = 0xffffffffffffffff (overflow). \n\n            proc    strtoh128 \n\n            stp     x4, x5, [sp, #-16]! \n            stp     x2, x3, [sp, #-16]! \n\n            // This code will use the value in X4 to test \n            // whether overflow will occur in X1 when \n            // shifting to the left 4 bits: \n\n            mov     x4, 0xF000000000000000 \n            mov     x0, xzr // Zero out LO accumulator. \n            mov     x1, xzr // Zero out HO accumulator. \n\n            // 0x5f is used to convert lowercase to \n            // uppercase: \n\n            mov     x5, 0x5f \n\n// The following loop skips over any whitespace (spaces and \n// tabs) that appear at the beginning of the string: \n\n            sub     x2, x2, #1 // Because of inc below \nskipWS:     ldrb    w3, [x2, #1]! \n            cmp     w3, #' ' \n            beq     skipWS \n            cmp     w3, #tab \n            beq     skipWS \n\n            // If you don't have a hexadecimal digit at this \n            // point, return an error: \n\n            cmp     w3, #'0'   // Note: '0' < '1' < ... < '9' \n            blo     badNumber \n            cmp     w3, #'9' \n            bls     convert \n            and     x3, x3, x5 // Cheesy LC -> UC conversion \n            cmp     w3, #'A' \n            blo     badNumber \n            cmp     w3, #'F' \n            bhi     badNumber \n            sub     w3, w3, #7 // Maps 41h..46h -> 3ah..3fh \n\n            // Okay, the first digit is good. Convert the \n            // string of digits to numeric form: \n\nconvert:    ands    xzr, x4, x1  // See whether adding in the current \n            bne     overflow     // digit will cause an overflow. \n\n and     x3, x3, #0xf // Convert to numeric in X3\\. \n\n            // Multiply 128-bit accumulator by 16 and add in \n            // new digit (128-bit extended-precision shift \n            // by 4 bits): \n\n          ❶ lsl     x1, x1, #4  // 128 bits shifted left 4 bits \n            orr     x1, x1, x0, lsr #60 \n            lsl     x0, x0, #4 \n            add     x0, x0, x3  // Never overflows \n\n            // Move on to next character: \n\n            ldrb    w3, [x2, #1]! \n            cmp     w3, #'0' \n            blo     endOfNum \n            cmp     w3, #'9' \n            bls     convert \n\n            and     x3, x3, x5  // Cheesy LC -> UC conversion \n            cmp     x3, #'A' \n            blo     endOfNum \n            cmp     x3, #'F' \n            bhi     endOfNum \n            sub     x3, x3, #7 // Maps 41h..46h -> 3ah..3fh \n            b.al    convert \n\n// If you get to this point, you've successfully converted \n// the string to numeric form: \n\nendOfNum: \n\n            // Because the conversion was successful, this \n            // procedure leaves X2 pointing at the first \n            // character beyond the converted digits.\n            // Therefore, we don't restore X2 from the stack. \n\n            ldp     x4, x3, [sp], #16   // X4 holds old X2\\. \n            ldp     x4, x5, [sp], #16 \n            msr     nzcv, xzr   // clr c = no error \n\n            ret \n\n// badNumber- Drop down here if the first character in \n//            the string was not a valid digit. \n\nbadNumber:  mov     x0, xzr \n            b.al    errorExit \n\noverflow:   mov     x0, #-1     // Return -1 as error on overflow. \nerrorExit: \n mrs     x1, nzcv    // Return error in carry flag. \n            orr     x1, x1, #(1 << 29) \n            msr     nzcv, x1    // Set c = error. \n            ldp     x2, x3, [sp], #16 \n            ldp     x4, x5, [sp], #16 \n            ret \n            endp    strtoh128 \n\n/////////////////////////////////////////////////////////////\n//\n// Here is the asmMain function: \n\n            proc    asmMain, public \n\n            locals  am \n            byte    am.stack, 64 \n            endl    am \n\n            enter   am.size \n\n// Test hexadecimal conversion: \n\n            lea     x2, hexStr \n            bl      strtoh128 \n\n            lea     x3, hexStr \n            mov     x2, x0 \n            lea     x0, fmtStr1 \n            mstr    x1, [sp] \n            mstr    x2, [sp, #8] \n            mstr    x3, [sp, #16] \n            bl      printf \n\nallDone:    leave \n            endp    asmMain \n```", "```\n% ./build Listing9-16 \n% ./Listing9-16 \nCalling Listing9-16: \nstrtoh128: value=1234567890abcdeffedcba0987654321, String='1234567890abcdeffedcba0987654321' \nListing9-16 terminated \n```", "```\n// Listing9-17.S \n//\n// Real string to floating-point conversion \n\n            #include    \"aoaa.inc\"\n\nfalse       =           0 \ntrue        =           1 \ntab         =           9 \n\n .section    .rodata, \"\" \nttlStr:     .asciz      \"Listing 9-17\"\nfmtStr1:    .asciz      \"strToR64: str='%s', value=%e\\n\"\nerrFmtStr:  .asciz      \"strToR64 error, code=%ld\\n\"\n\n❶ fStr1a:     .asciz      \" 1.234e56\"\nfStr1b:     .asciz      \"\\t-1.234e+56\"\nfStr1c:     .asciz      \"1.234e-56\"\nfStr1d:     .asciz      \"-1.234e-56\"\nfStr2a:     .asciz      \"1.23\"\nfStr2b:     .asciz      \"-1.23\"\nfStr2c:     .asciz      \"001.23\"\nfStr2d:     .asciz      \"-001.23\"\nfStr3a:     .asciz      \"1\"\nfStr3b:     .asciz      \"-1\"\nfStr4a:     .asciz      \"0.1\"\nfStr4b:     .asciz      \"-0.1\"\nfStr4c:     .asciz      \"0000000.1\"\nfStr4d:     .asciz      \"-0000000.1\"\nfStr4e:     .asciz      \"0.1000000\"\nfStr4f:     .asciz      \"-0.1000000\"\nfStr4g:     .asciz      \"0.0000001\"\nfStr4h:     .asciz      \"-0.0000001\"\nfStr4i:     .asciz      \".1\"\nfStr4j:     .asciz      \"-.1\"\nfStr5a:     .asciz      \"123456\"\nfStr5b:     .asciz      \"12345678901234567890\"\nfStr5c:     .asciz      \"0\"\nfStr5d:     .asciz      \"1.\" \nfStr6a:     .asciz      \"0.000000000000000000001\"\n\n          ❷ .align      3 \nvalues:     .dword      fStr1a, fStr1b, fStr1c, fStr1d \n            .dword      fStr2a, fStr2b, fStr2c, fStr2d \n            .dword      fStr3a, fStr3b \n            .dword      fStr4a, fStr4b, fStr4c, fStr4d \n            .dword      fStr4e, fStr4f, fStr4g, fStr4h \n            .dword      fStr4i, fStr4j \n            .dword      fStr5a, fStr5b, fStr5c, fStr5d \n            .dword      fStr6a \n            .dword      0 \n\n❸ PotTbl:     .double     1.0e+256 \n            .double     1.0e+128 \n            .double     1.0e+64 \n            .double     1.0e+32 \n            .double     1.0e+16 \n            .double     1.0e+8 \n            .double     1.0e+4 \n            .double     1.0e+2 \n            .double     1.0e+1 \n            .double     1.0e+0 \n\n            .data \nr8Val:      .double     0.0 \n\n .code \n            .extern     printf \n\n///////////////////////////////////////////////////////////\n//\n// Return program title to C++ program: \n\n            proc    getTitle, public \n            lea     x0, ttlStr \n            ret \n            endp    getTitle \n```", "```\n// Listing9-17.S (cont.) \n//\n// strToR64 \n//\n// On entry: \n//\n//  X0- Points at a string of characters that represent a \n//      floating-point value \n//\n// On return: \n//\n//  D0- Converted result \n//  X0- On return, X0 points at the first character this \n//      routine couldn't convert (if no error). \n//\n//  C-  Carry flag is clear if no error, set if error. \n//      X7 is preserved if an error, X1 contains an \n//      error code if an error occurs (else X1 is \n//      preserved). \n\n            proc    strToR64 \n\n            locals  sr \n            qword   sr.x1x2 \n            qword   sr.x3x4 \n            qword   sr.x5x6 \n            qword   sr.x7x0 \n            dword   sr.d1 \n            byte    sr.stack, 64    // Not really needed, but ... \n endl    sr \n\n            enter   sr.size \n\n// Defines to give registers more \n// meaningful names: \n\n❶ #define mant    x1      // Mantissa value \n#define sigDig  x2      // Mantissa significant digits \n#define expAcc  x2      // Exponent accumulator \n#define sign    w3      // Mantissa sign \n#define fpExp   x4      // Exponent \n#define expSign w5      // Exponent sign \n#define ch      w6      // Current character \n#define xch     x6      // Current character (64 bits) \n#define ten     x7      // The value 10 \n\n            // Preserve the registers this \n            // code modifies: \n\n          ❷ stp     x1, x2, [fp, #sr.x1x2] \n            stp     x3, x4, [fp, #sr.x3x4] \n            stp     x5, x6, [fp, #sr.x5x6] \n            stp     x7, x0, [fp, #sr.x7x0] \n            str     d1,     [fp, #sr.d1  ] \n\n            // Useful initialization: \n\n            mov     fpExp, xzr      // X3 Decimal exponent value \n            mov     mant, xzr       // X0 Mantissa value   \n            mov     sign, wzr       // W2 Assume nonnegative. \n\n            // Initialize sigDig with 16, the number of \n            // significant digits left to process. \n\n            mov     sigDig, #16     // X1 \n\n            // Verify that X0 is not NULL. \n\n            cmp     x0, xzr \n            beq     refNULL \n```", "```\n// Listing9-17.S (cont.) \n\n            sub     x0, x0, #1      // Will inc'd in loop \nwhileWSLoop: \n            ldrb    ch, [x0, #1]!   // W5 \n            cmp     ch, #' ' \n            beq     whileWSLoop \n            cmp     ch, #tab \n            beq     whileWSLoop \n```", "```\n// Listing9-17.S (cont.) \n\n            // Check for + or - \n\n            cmp     ch, #'+' \n            beq     skipSign \n\n            cmp     ch, #'-' \n            cinc    sign, sign, eq  // W2 \n            bne     noSign \n\nskipSign:   ldrb    ch, [x0, #1]!   // Skip '-' \nnoSign: \n```", "```\n// Listing9-17.S (cont.) \n\n          ❶ sub     ch, ch, #'0'    // Quick test for '0' to '9' \n            cmp     ch, #9 \n            bls     scanDigits      // Branch if '0' to '9' \n\n          ❷ cmp     ch, #'.'-'0'    // Check for '.' \n            bne     convError \n\n            // If the first character is a decimal point, \n            // the second character needs to be a \n            // decimal digit. \n\n          ❸ ldrb    ch, [x0, #1]!   // W5 Skip period. \n            cmp     ch, #'0' \n            blo     convError \n cmp     ch, #'9' \n            bhi     convError \n            b.al    whileDigit2 \n```", "```\n// Listing9-17.S (cont.) \n//\n// Scan for digits at the beginning of the number: \n\nscanDigits: mov     ten, #10        // X7 used to multiply by 10 \n            add     ch, ch, #'0'    // Restore character. \n whileADigit: \n            sub     ch, ch, #'0'    // Quick way to test for \n            cmp     ch, #10         // a range and convert \n            bhs     notDigit        // to an integer \n\n            // Ignore any leading 0s in the number. \n            // You have a leading '0' if the mantissa is 0 \n            // and the current character is '0'. \n\n          ❶ cmp     mant, xzr       // Ignore leading 0s. \n            ccmp    ch, #0, #0, eq \n            beq     Beyond16 \n\n            // Each digit to the left of the decimal \n            // point increases the number by an \n            // additional power of 10\\. Deal with that \n            // here. \n\n          ❷ add     fpExp, fpExp, #1 \n\n            // Save all the significant digits but ignore \n            // any digits beyond the 16th digit. \n\n          ❸ cmp     sigDig, xzr     // X1 \n            beq     Beyond16 \n\n            // Count down the number of significant digits. \n\n            sub     sigDig, sigDig, #1 \n\n // Multiply the accumulator (mant) by 10 and \n            // add in the current digit. Note that ch \n            // has already been converted to an integer. \n\n          ❹ madd    mant, mant, ten, xch    // X0, X6, X5 \n\n            // Because you multiplied the exponent by 10, \n            // you need to undo the increment of fpExp. \n\n          ❺ sub     fpExp, fpExp, #1 \n\nBeyond16:   ldrb    ch, [x0, #1]!   // Get next char. \n            b.al    whileADigit \n```", "```\n// Listing9-17.S (cont.) \n//\n// If you encountered a nondigit character, \n// check for a decimal point: \n\nnotDigit: \n            cmp     ch, #'.'-'0'    // See if a decimal point. \n            bne     whileDigit2 \n\n// Okay, process any digits to the right of the decimal point. \n// If this code falls through from the above, it skips the \n// decimal point. \n\ngetNextChar: \n            ldrb    ch, [x0, #1]!   // Get the next character. \nwhileDigit2: \n            sub     ch, ch, #'0' \n            cmp     ch, #10 \n            bhs     noDigit2 \n\n            // Ignore digits after the 16th significant \n            // digit but don't count leading 0s \n            // as significant digits: \n\n          ❶ cmp     mant, xzr            // Ignore leading 0s. \n            ccmp    ch, wzr, #0, eq \n ccmp    sigDig, xzr, #0, eq  // X2 \n            beq     getNextChar \n\n            // Each digit to the right of the decimal point decreases \n            // the number by an additional power of 10\\. Deal with \n            // that here. \n\n          ❷ sub     fpExp, fpExp, #1 \n\n            // Count down the number of significant digits: \n\n            sub     sigDig, sigDig, #1 \n\n            // Multiply the accumulator (mant) by 10 and \n            // add in the current digit. Note that ch \n            // has already been converted to an integer: \n\n            Madd    mant, mant, ten, xch    // X1, X7, X6 \n            b.al    getNextChar \n```", "```\n// Listing9-17.S (cont.) \n\n❶ noDigit2: \n            mov     expSign, wzr    // W5 Initialize exp sign. \n            mov     expAcc, xzr     // X2 Initialize exponent. \n            cmp     ch, #'e'-'0' \n            beq     hasExponent \n            cmp     ch, #'E'-'0' \n            bne     noExponent \n\n❷ hasExponent: \n            ldrb    ch, [x0, #1]!           // Skip the \"E\".\n            cmp     ch, #'-'                // W6 \n            cinc    expSign, expSign, eq    // W5 \n            beq     doNextChar_2 \n            cmp     ch, #'+' \n            bne     getExponent \n\ndoNextChar_2: \n            ldrb    ch, [x0, #1]!   // Skip '+' or '-'. \n\n// Okay, you're past the \"E\" and the optional sign at this \n// point. You must have at least one decimal digit. \n\n❸ getExponent: \n            sub     ch, ch, #'0'    // W5 \n            cmp     ch, #10 \n            bhs     convError \n\n            mov     expAcc, xzr     // Compute exponent value in X2\\. \nExpLoop:    ldrb    ch, [x0], #1 \n            sub     ch, ch, #'0' \n            cmp     ch, #10 \n            bhs     ExpDone \n\n            madd    expAcc, expAcc, ten, xch    // X2, X7, X6 \n            b.al    ExpLoop \n\n// If the exponent was negative, negate your computed result: \n\n❹ ExpDone: \n            cmp     expSign, #false // W5 \n            beq     noNegExp \n\n            neg     expAcc, expAcc  // X2 \n\nnoNegExp: \n\n// Add in the computed decimal exponent with the exponent \n// accumulator: \n\n          ❺ add     fpExp, fpExp, expAcc    // X4, X2 \n\nnoExponent: \n\n// Verify that the exponent is from -324 to +308 (which \n// is the maximum dynamic range for a 64-bit FP value): \n\n          ❻ mov     x5, #308        // Reuse expSign here. \n            cmp     fpExp, x5 \n            bgt     voor            // Value out of range \n            mov     x5, #-324 \n            cmp     fpExp, x5 \n            blt     voor \n          ❼ ucvtf   d0, mant        // X1 \n```", "```\n// Listing9-17.S (cont.) \n//\n// Okay, you have the mantissa into D0\\. Now multiply \n// D0 by 10 raised to the value of the computed exponent \n// (currently in fpExp). \n//\n// This code uses power-of-10 tables to help make the \n// computation a little more accurate. \n//\n// You want to determine which power of 10 is just less than the \n// value of our exponent. The powers of 10 you are checking are \n// 10**256, 10**128, 10**64, 10**32, and so on. A slick way to \n// check is by shifting the bits in the exponent \n// to the left. Bit #8 is the 256 bit, so if this bit is set, \n// your exponent is >= 10**256\\. If not, check the next bit down \n// to see if your exponent >= 10**128, and so on. \n\n            mov     x1, -8      // Initial index into power-of-10 table \n            cmp     fpExp, xzr  // X4 \n            bpl     positiveExponent \n\n          ❶ // Handle negative exponents here: \n\n            neg     fpExp, fpExp \n            lsl     fpExp, fpExp, #55   // Bits 0..8 -> 55..63 \n            lea     x6, PotTbl \n ❷ whileExpNE0: \n            add     x1, x1, #8          // Next index into PotTbl. \n            adds    fpExp, fpExp, fpExp // (LSL) Need current POT? \n            bcc     testExp0 \n\n            ldr     d1, [x6, x1] \n            fdiv    d0, d0, d1 \n\ntestExp0:   cmp     fpExp, xzr \n            bne     whileExpNE0 \n            b.al    doMantissaSign \n\n// Handle positive exponents here. \n\n❸ positiveExponent: \n            lea     x6, PotTbl \n            lsl     fpExp, fpExp, #55       // Bits 0..8 -> 55..63 \n            b.al    testExpis0_2 \n\nwhileExpNE0_2: \n            add     x1, x1, #8 \n            adds    fpExp, fpExp, fpExp     // (LSL) \n            bcc     testExpis0_2 \n\n            ldr     d1, [x6, x1] \n            fmul    d0, d0, d1 \n\ntestExpis0_2: \n            cmp     fpExp, xzr \n            bne     whileExpNE0_2 \n```", "```\n// Listing9-17.S (cont.) \n\ndoMantissaSign: \n            cmp     sign, #false            // W3 \n            beq     mantNotNegative \n\n            fneg    d0, d0 \n\n// Successful return here. Note: does not restore X0 \n// on successful conversion. \n\nmantNotNegative: \n            msr     nzcv, xzr   // clr c = no error \n            ldp     x1, x2, [fp, #sr.x1x2] \n            ldp     x3, x4, [fp, #sr.x3x4] \n            ldp     x5, x6, [fp, #sr.x5x6] \n            ldr     x7,     [fp, #sr.x7x0] \n            ldr     d1,     [fp, #sr.d1  ] \n            leave \n```", "```\n// Listing9-17.S (cont.) \n//\n// Error returns down here. Returns error code in X0: \n\nrefNULL:    mov     x1, #-3 \n            b.al    ErrorExit \n\nconvError:  mov     x1, #-2 \n            b.al    ErrorExit \n\nvoor:       mov     x1, #-1 // Value out of range \n            b.al    ErrorExit \n\nillChar:    mov     x1, #-4 \n\n// Note: on error, this code restores X0\\. \n\nErrorExit: \n            str     x1, [fp, #sr.x1x2]  // Return error code in X1\\. \n            mrs     x1, nzcv            // Return error in carry flag. \n            orr     x1, x1, #(1 << 29) \n            msr     nzcv, x1            // Set c = error. \n            ldp     x1, x2, [fp, #sr.x1x2] \n            ldp     x3, x4, [fp, #sr.x3x4] \n            ldp     x5, x6, [fp, #sr.x5x6] \n            ldp     x7, x0, [fp, #sr.x7x0] \n            ldr     d1,     [fp, #sr.d1  ] \n            leave \n\n            endp    strToR64 \n```", "```\n// Listing9-17.S (cont.) \n\n// Here is the asmMain function: \n\n            proc    asmMain, public \n\n            locals  am \n            dword   am.x20 \n            byte    stack, 64 \n            endl    am \n\n            enter   am.size \n            str     x20, [fp, #am.x20] \n\n// Test floating-point conversion: \n\n            lea     x20, values \nValuesLp:   ldr     x0, [x20] \n            cmp     x0, xzr \n            beq     allDone \n            bl      strToR64 \n\n            lea     x0, fmtStr1 \n            ldr     x1, [x20] \n            mstr    x1, [sp] \n            mstr    d0, [sp, #8] \n            bl      printf \n            add     x20, x20, #8 \n            b.al    ValuesLp \n\nallDone:    ldr     x20, [fp, #am.x20] \n            leave \n            endp    asmMain \n```", "```\n% ./build Listing9-17 \n% ./Listing9-17 \nCalling Listing9-17: \nstrToR64: str=' 1.234e56', value=1.234000e+56 \nstrToR64: str='    -1.234e+56', value=-1.234000e+56 \nstrToR64: str='1.234e-56', value=1.234000e-56 \nstrToR64: str='-1.234e-56', value=-1.234000e-56 \nstrToR64: str='1.23', value=1.230000e+00 \nstrToR64: str='-1.23', value=-1.230000e+00 \nstrToR64: str='001.23', value=1.230000e+00 \nstrToR64: str='-001.23', value=-1.230000e+00 \nstrToR64: str='1', value=1.000000e+00 \nstrToR64: str='-1', value=-1.000000e+00 \nstrToR64: str='0.1', value=1.000000e-01 \nstrToR64: str='-0.1', value=-1.000000e-01 \nstrToR64: str='0000000.1', value=1.000000e-01 \nstrToR64: str='-0000000.1', value=-1.000000e-01 \nstrToR64: str='0.1000000', value=1.000000e-01 \nstrToR64: str='-0.1000000', value=-1.000000e-01 \nstrToR64: str='0.0000001', value=1.000000e-07 \nstrToR64: str='-0.0000001', value=-1.000000e-07 \nstrToR64: str='.1', value=1.000000e-01 \nstrToR64: str='-.1', value=-1.000000e-01 \nstrToR64: str='123456', value=1.234560e+05 \nstrToR64: str='12345678901234567890', value=1.234568e+19 \nstrToR64: str='0', value=0.000000e+00 \nstrToR64: str='1.', value=1.000000e+00 \nstrToR64: str='0.000000000000000000001', value=1.000000e-17 \nListing9-17 terminated \n```"]