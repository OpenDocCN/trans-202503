- en: '![Image](Images/f077-01.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f077-01.jpg)'
- en: '3'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: 'Hatlight: A Cave Exploring Platform Game'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Hatlight：一款洞穴探索平台游戏
- en: In this chapter, you’ll combine everything you learned about programming, character
    design and animation, and level design to make your own platform game in Scratch.
    A *platform game* is a fancy name for games like *Super Mario Bros.*, where the
    player has a cutaway view of the game world and gets around mostly by jumping
    on platforms suspended in midair, as you can see here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将结合所有学到的编程、角色设计与动画、以及关卡设计的知识，在Scratch中制作属于你自己的平台游戏。*平台游戏*是像*超级马里奥兄弟*这样的游戏的
    fancy 名称，其中玩家可以看到游戏世界的剖面图，主要通过跳跃在悬空的的平台上移动，就像这里展示的那样。
- en: '![Image](Images/f078-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f078-01.jpg)'
- en: '*The platform game we’ll create*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将创建的平台游戏*'
- en: If you don’t want to worry about the programming, go to *[http://tinyurl.com/hatlightempty/](http://tinyurl.com/hatlightempty/)*
    to find a version of the game with the platform engine code already written. All
    it needs is your level design.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想担心编程，可以访问*[http://tinyurl.com/hatlightempty/](http://tinyurl.com/hatlightempty/)*，这里有一个已写好平台引擎代码的游戏版本。你只需要进行关卡设计。
- en: About Hatlight
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于Hatlight
- en: Let’s preview a finished version of the *Hatlight* game to give you an idea
    of what we’re making. In this game, you’ll be an explorer who uses a hatlight
    (a flashlight mounted on a hat) to investigate a big, winding cave. Because it’s
    dark underground, you’ll need to use your trusty hatlight to find your way around,
    as shown in the following figure. If you can find some batteries, you can make
    your light stronger.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们预览一下完成版的*Hatlight*游戏，让你了解我们正在制作的内容。在这个游戏中，你将扮演一名探险者，使用头灯（装在帽子上的手电筒）来探索一个又大又弯曲的洞穴。因为地下很黑，你需要依靠你可靠的头灯来照亮道路，如下图所示。如果你能找到一些电池，就可以让光线变得更强。
- en: 'Play the game at the following link: *[https://scratch.mit.edu/projects/122190314/](https://scratch.mit.edu/projects/122190314/)*.
    You can use the left and right arrow keys to move around, and the up arrow key
    to jump. (You can also use the spacebar to jump or even the Z key—whichever feels
    more natural for you!)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接玩游戏：*[https://scratch.mit.edu/projects/122190314/](https://scratch.mit.edu/projects/122190314/)*。你可以使用左右箭头键进行移动，使用上箭头键跳跃。（你也可以使用空格键跳跃，或者甚至使用Z键——选择哪个键位更自然由你！）
- en: There are seven batteries in all! How many can you find?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有七个电池！你能找到多少个？
- en: '![Image](Images/f079-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f079-01.jpg)'
- en: '*Using the hatlight to explore!*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用头灯进行探索！*'
- en: Coding Platform Movement
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程平台移动
- en: When you’re making a game like *Hatlight*, you want to think about how the player
    will move. The player interacts with your game world by moving, so we want to
    make moving around the platform feel natural.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你制作像*Hatlight*这样的游戏时，你需要考虑玩家的移动方式。玩家通过移动与游戏世界互动，因此我们希望让平台上的移动感觉自然。
- en: 'Platform movement is a big project, so let’s break it down into smaller parts.
    Breaking down a large task into smaller parts is called *decomposition*. We’ll
    program four types of movement:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 平台移动是一个庞大的项目，所以让我们将其分解成更小的部分。将大任务分解成小部分的过程称为*分解*。我们将编写四种类型的移动：
- en: Walking side to side.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横向行走。
- en: Jumping around (of course!).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳跃（当然啦！）。
- en: Falling when there’s nothing to stand on.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有可站立物体的地方掉落。
- en: Climbing sloped or uneven surfaces. (This means we can draw our own levels and
    not worry about having flat and straight floors. Our game will take place in a
    cave, so we want a *lot* of bumpy floors.)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攀爬倾斜或不平的表面。（这意味着我们可以绘制自己的关卡，而不用担心地面是否平坦。我们的游戏将发生在一个洞穴中，所以我们希望有*很多*颠簸的地面。）
- en: If we work on one part at a time, it will be easier to create the game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一次只处理一部分内容，创建游戏会更容易。
- en: Creating a Hitbox Sprite
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建碰撞箱精灵
- en: Let’s start by creating a sprite that contains code for all of the player’s
    platforming action.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个包含所有玩家平台动作代码的精灵开始。
- en: Create a new project in Scratch and open the Paint Editor. Use the **Rectangle**
    tool to make a smooth, perfect rectangle, like this.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scratch中创建一个新项目并打开画图编辑器。使用**矩形**工具绘制一个平滑、完美的矩形，像这样。
- en: '![Image](Images/f080-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f080-01.jpg)'
- en: '*Drawing a hitbox rectangle*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*绘制碰撞箱矩形*'
- en: Don’t make the hitbox too big! We need to leave enough room on the screen so
    that the player can jump around and explore. When the player is running, jumping,
    and bouncing around from one platform to another, we’ll need to check for *collisions*.
    A collision lets us know whether the player runs into a wall. If that happens,
    we can say, “Hey! You and the wall shouldn’t be in the same place.” Then we can
    move the player outside the wall.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让碰撞箱太大！我们需要在屏幕上留出足够的空间，以便玩家能够跳跃和探索。当玩家在奔跑、跳跃并从一个平台跳到另一个平台时，我们需要检查 *碰撞*。碰撞让我们知道玩家是否撞到墙壁。如果发生这种情况，我们可以说：“嘿！你和墙壁不该在同一个地方。”然后我们可以把玩家移到墙壁外面。
- en: '**NOTE:** In the next chapter, we’ll create another sprite that handles the
    player’s animation. This sprite will move with the hitbox and change costumes
    depending on the status of the hitbox. For now, the hitbox looks perfectly flat
    and rectangular for the purpose of making collision easier.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 在下一章中，我们将创建另一个精灵来处理玩家的动画。这个精灵将与碰撞箱一起移动，并根据碰撞箱的状态改变服装。目前，碰撞箱看起来是完全平坦和矩形的，目的是为了让碰撞检测更容易。'
- en: When Scratch checks whether two sprites are touching, the *exact shape* of the
    sprite matters. For example, if the player sprite has a very long nose, they could
    hang from a platform by the tip of their nose!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Scratch 检查两个精灵是否接触时，精灵的 *精确形状* 很重要。例如，如果玩家的精灵有一个非常长的鼻子，他们可能会通过鼻尖挂在平台上！
- en: To prevent such situations, we’ll make sure Scratch always checks for collisions
    by making our sprite look like a neat, flat rectangle. This shape is sometimes
    called a *hitbox* or *bounding box*. In the finished game, it will be invisible.
    We’ll add better animation for the main character later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，我们将确保 Scratch 始终检查碰撞，通过让我们的精灵看起来像一个整齐的矩形。这种形状有时被称为 *碰撞箱* 或 *边界框*。在完成的游戏中，它将是不可见的。稍后我们会为主角添加更好的动画效果。
- en: Make sure your hitbox is centered on the `+`. Name the sprite `Hitbox`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的碰撞箱居中在 `+` 上。将精灵命名为 `Hitbox`。
- en: Drawing a Test Area
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制测试区域
- en: Before we code our `Hitbox` sprite, let’s create a test area where we can try
    out our movement and make sure it works the way we want it to.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 `Hitbox` 精灵的代码之前，让我们先创建一个测试区域，在其中试验我们的移动并确保其按预期工作。
- en: 'Create a sprite named `Walls` that will contain all the solid objects in our
    game: the walls, the floor, and the ceilings. The following figure shows all the
    objects we want the player to collide with.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Walls` 的精灵，它将包含我们游戏中的所有固体对象：墙壁、地板和天花板。下图展示了我们希望玩家与之碰撞的所有对象。
- en: '![Image](Images/f081-01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f081-01.jpg)'
- en: '*Creating Walls*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建墙壁*'
- en: The full size of the sprite drawing window is the same size as Scratch’s game
    window, so you can draw objects all the way to the edges. As you can see, this
    example shows the test level. We use the Rectangle tool to draw straight lines
    for all the floors. Later in this chapter, when we add code to make the player
    climb over bumpy floors, we’ll make the floors look less regular. For now, it’s
    okay to keep them simple.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵绘制窗口的完整大小与 Scratch 的游戏窗口大小相同，因此你可以将对象绘制到边缘。如你所见，示例展示了测试关卡。我们使用矩形工具绘制了所有楼层的直线。稍后在本章中，当我们为玩家添加代码以让其爬过崎岖的地面时，我们会让这些楼层看起来不那么规则。现在，保持简单即可。
- en: 'Make sure your `Walls` sprite is positioned exactly within the game screen.
    Here’s a handy trick for doing this: give the `Walls` sprite the code block `go
    to x: 0 y: 0`. Then double-click the code block to snap the sprite into position
    in the middle of the screen. (You can delete the code block afterward.)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '确保你的 `Walls` 精灵准确地放置在游戏屏幕内。这里有一个方便的小技巧：给 `Walls` 精灵添加代码块 `go to x: 0 y: 0`。然后双击代码块将精灵定位到屏幕的中间位置。（你可以在之后删除代码块。）'
- en: We’ll put all our levels into the `Walls` sprite as different costumes later
    on. But for now, all we need are some walls and platforms for our player to run
    around in.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会将所有关卡作为不同的服装放入 `Walls` 精灵中。但目前，我们只需要一些墙壁和平台，供玩家在其中奔跑。
- en: Organizing Our Code with Events
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用事件组织我们的代码
- en: Our platform game will involve quite a bit of code. We’ve already identified
    four different types of movement we need to code. If we don’t decide how to organize
    the code before we write it, it will get *very* confusing to keep track of.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的平台游戏将涉及大量的代码。我们已经确定了需要编写的四种不同类型的移动。如果我们在编写代码之前没有决定如何组织它，代码将变得 *非常* 混乱，难以追踪。
- en: 'Fortunately, we already identified different parts of the code that we need:
    walking, jumping, falling, and climbing. So instead of creating one long stack,
    we’ll create small stacks for each part.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经识别出代码中需要的不同部分：走路、跳跃、下落和攀爬。因此，我们不会创建一个很长的栈，而是会为每个部分创建小的栈。
- en: Creating a Chain of Events
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建事件链
- en: Every stack needs to begin with an event, so we’ll make a different event for
    each stack we want. Recall that in Scratch a sprite can receive the messages it
    broadcasts. This means that we can end each stack by broadcasting the next message
    in the sequence, creating the equivalent of a `forever` loop. The last event will
    call back to the first one, and the code will keep repeating.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个栈都需要以一个事件开始，因此我们会为每个需要的栈创建不同的事件。回想一下，在 Scratch 中，精灵可以接收它自己广播的消息。这意味着我们可以通过广播下一个消息来结束每个栈，从而创建一个等效于`forever`循环的效果。最后一个事件将回调到第一个事件，代码会不断重复。
- en: Create these events in the `Hitbox` sprite.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Hitbox`精灵中创建这些事件。
- en: '**NOTE:** The `wrap` event is for moving from screen to screen. We’ll come
    back to that later!'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** `wrap`事件用于从一个屏幕移动到另一个屏幕。我们稍后会回到这个问题！'
- en: '![Image](Images/f083-01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f083-01.jpg)'
- en: '*Creating a sequence of events*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建事件序列*'
- en: Now we have a series of events that play out in order, broadcasting the next
    one in sequence and eventually looping back to the start. None of the events have
    code in them yet, but we have a basic, working structure to build our game.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一系列按顺序播放的事件，每个事件都会广播下一个，最终循环回到开始。尽管这些事件中还没有代码，但我们已经有了一个基本的工作结构来构建我们的游戏。
- en: Let’s explore each event in more detail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探索每个事件。
- en: Creating Variables
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建变量
- en: We’ll begin by defining some variables using the Variables tab. We’ll put our
    variables in the `when green flag clicked` event, before our actual loop starts,
    as shown next. We only want them to be set once at the beginning of the game.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过变量标签定义一些变量。我们会把变量放在`绿旗点击`事件中，在实际的循环开始之前，如下所示。我们只希望它们在游戏开始时设置一次。
- en: '![Image](Images/f084-01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f084-01.jpg)'
- en: '*Creating variables for when green flag clicked event*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*为绿旗点击事件创建变量*'
- en: The `grounded` variable is a special type of variable called a *Boolean* variable,
    which has one of two values, like true or false, on or off, and so on. In this
    case, `grounded` is always either 0 or 1\. If it’s 0, the player is in midair.
    If it’s 1, the player is on the ground. We can use this value to make sure the
    player is on the ground before they can jump.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`grounded`变量是一种特殊类型的变量，称为*布尔*变量，它只有两个值，比如 true 或 false，开或关，等等。在这个例子中，`grounded`的值始终是0或1。如果它是0，玩家在空中；如果它是1，玩家就在地面上。我们可以利用这个值确保玩家在跳跃之前已经站在地面上。'
- en: Similar to the way we define variables in programming, we’ll set these four
    variables to the values we want them to start the game at. Each time the game
    starts, the program will reset all four of these variables.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在编程中定义变量的方式，我们将这些变量设置为我们希望它们在游戏开始时的值。每次游戏开始时，程序都会重置这四个变量。
- en: Coding Player Movement
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程玩家移动
- en: Now that we’ve defined our variables and set their default values, we can start
    programming each stack.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了变量并设置了它们的默认值，我们可以开始编写每个栈的程序了。
- en: Moving Left and Right
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 左右移动
- en: The first stack we’ll code is the `move left/right` stack. The full stack should
    look something like this.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写的第一个栈是`向左/向右移动`栈。完整的栈应该像这样。
- en: '![Image](Images/f085-01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f085-01.jpg)'
- en: '*The move code*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*移动代码*'
- en: Now let’s look at how this stack works step by step. Note that a positive value
    means the player moves to the right, and a negative value means the player moves
    to the left, like in a number line.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们一步一步地看看这个栈是如何工作的。注意，正值表示玩家向右移动，负值表示玩家向左移动，就像在数轴上一样。
- en: Climbing Slopes and Steps
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 攀爬斜坡和台阶
- en: So far we’ve programmed how the player should move on a flat surface. But we
    haven’t yet programmed how they should deal with sloping floors or steps.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编程了玩家在平坦表面上如何移动。但我们还没有编程如何处理斜坡或台阶。
- en: '![Image](Images/f086-01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f086-01.jpg)'
- en: '*The climb code*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*攀爬代码*'
- en: Let’s program players to climb slopes and steps as long as they’re not too steep
    or high. The player can only walk up bumps or slopes that are less than three
    steps high. If the player takes more than three steps, it will mean the slope
    is too steep or they’ve bumped into a wall. So if the player walks into a slope
    or step that is too high to climb, we’ll make it impossible for the player to
    climb over it. Here’s the complete `climb` code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编程让玩家爬坡和爬台阶，只要这些坡度不是太陡或太高。玩家只能走上小于三阶的坡道或台阶。如果玩家走了超过三阶的台阶，这意味着坡道太陡或者他们撞到了墙壁。所以如果玩家走到一个太高的坡道或台阶，无法爬过时，我们就让玩家无法通过它。这里是完整的`climb`代码。
- en: This last `if () then` block to shake the player loose is an emergency measure
    just to make sure they can never get stuck in the wall!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个`if () then`语句块用于紧急情况下让玩家从墙壁中松脱，确保他们永远不会卡在墙里！
- en: Falling
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下落
- en: Here’s the `fall` code that determines how the player should fall when they’re
    not touching the ground.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`fall`代码，用于确定玩家在没有接触地面时应该如何下落。
- en: '![Image](Images/f087-01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f087-01.jpg)'
- en: '*The fall code*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*坠落代码*'
- en: Remember that negative numbers mean down and positive numbers mean up. Because
    of the player’s `y speed`, they won’t line up with the floor exactly but might
    overlap it a bit. If so, we undo their last move by multiplying `y speed` by –1,
    causing the player to move in reverse.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，负数表示向下，正数表示向上。由于玩家的`y speed`，他们不会完全与地面对齐，而是可能略微重叠。如果发生这种情况，我们通过将`y speed`乘以-1来撤销他们的最后一个动作，使玩家反向移动。
- en: If `y speed` is negative, it means the player bumped into the floor while falling.
    If it’s positive, they’ve hit the ceiling while jumping. Either way, we set their
    `y speed` to 0 because they stop falling.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`y speed`是负数，意味着玩家在下落时撞到了地面。如果是正数，则意味着玩家在跳跃时撞到了天花板。无论是哪种情况，我们都会将他们的`y speed`设为0，因为他们停止了下落。
- en: Jumping
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跳跃
- en: Next, we’ll look at how to program the player’s jumping motion. Here’s the code
    for `jump`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何编程实现玩家的跳跃动作。这是`jump`的代码。
- en: '![Image](Images/f088-01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f088-01.jpg)'
- en: '*The jump code*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*跳跃代码*'
- en: Creating Natural Movement with Variables
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用变量创造自然运动
- en: Why do we use `x speed` and `y speed` variables instead of just changing `x`
    and `y`? For example, to set the player’s speed to 10, we *could* just increase
    the player’s `x` by 10 whenever the player presses the right arrow key.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用`x speed`和`y speed`变量，而不是直接改变`x`和`y`？例如，为了将玩家的速度设置为10，我们*可以*每当玩家按下右箭头键时，直接将玩家的`x`增加10。
- en: '![Image](Images/f088-02.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f088-02.jpg)'
- en: '*Increasing speed without using variables*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*不使用变量的加速*'
- en: In this example, the player has either stopped (speed 0) or is moving (speed
    10). The program doesn’t allow for any speed in between. This results in a binary
    movement that looks unnatural.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，玩家要么停止了（速度为0），要么在移动（速度为10）。程序不允许出现介于两者之间的任何速度。这导致了看起来不自然的二元运动。
- en: '![Image](Images/f089-01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f089-01.jpg)'
- en: '*Binary movement*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*二元运动*'
- en: But if we gradually increase the player’s speed over a series of moves, we create
    a more natural-feeling movement that allows the player to start slow and accelerate
    to full speed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们在一系列动作中逐渐增加玩家的速度，就能创造出更自然的运动感觉，让玩家从慢速开始，逐渐加速到全速。
- en: '![Image](Images/f089-02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f089-02.jpg)'
- en: '*Gradual acceleration*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*逐渐加速*'
- en: Similarly, we can also have the player decelerate instead of stopping instantly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们也可以让玩家减速，而不是立即停止。
- en: '![Image](Images/f090-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f090-01.jpg)'
- en: '*Deceleration*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*减速*'
- en: If you haven’t yet, try out your code in your test level. Make sure you change
    the `broadcast wrap` block to `broadcast climb` because we haven’t written the
    `wrap` part yet. Make changes to the test level by adding a sloped floor. If the
    player can’t jump high enough to reach a platform, make the platform lower. Or
    change the initial speed of the player’s jump. (It’s set to 12, as you can see
    in the `jump` code.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有，尝试在你的测试关卡中运行你的代码。确保你将`broadcast wrap`块改为`broadcast climb`，因为我们还没有编写`wrap`部分。通过添加一个倾斜的地面来更改测试关卡。如果玩家跳得不够高，无法到达平台，则降低平台的高度。或者更改玩家跳跃的初始速度。（如你在`jump`代码中看到的，设置为12。）
- en: You can change how the game feels by experimenting with the numbers in your
    code blocks. For example, try changing the gravity value or the player’s jump
    speed, the player’s maximum walking speed, or the speed of acceleration. Can you
    make it feel like the player is on the moon? Can you make the player’s movement
    feel really heavy? If you’re feeling very confident, try coding a double jump!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过修改代码块中的数字来改变游戏的感觉。例如，尝试改变重力值或玩家的跳跃速度、玩家的最大行走速度或加速速度。你能让玩家的移动感觉像是在月球上吗？你能让玩家的动作感觉非常沉重吗？如果你非常自信，尝试编写双重跳跃的代码！
- en: Creating a World that’s Fun to Explore
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个有趣的探索世界
- en: Platform games are neat because they give us an interesting way to think about
    space. In real life, down is always below, and up is always above. Because of
    gravity, it’s usually easier to move downward than upward. That means that getting
    to higher places can be tricky and require more effort.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 平台游戏非常有趣，因为它们给我们提供了一种有趣的思考空间的方式。在现实生活中，下方总是位于下方，上方总是位于上方。由于重力的作用，通常向下移动比向上移动容易。这意味着到达更高的地方可能会比较困难，并且需要更多的努力。
- en: But in our exploration platform game, the player can explore the world however
    they want, with fewer restrictions. It does mean we have to think about space
    a little differently. We have to consider how different parts of the platform
    connect with each other.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们的探索平台游戏中，玩家可以自由地以他们喜欢的方式探索世界，限制较少。这确实意味着我们需要从不同的角度来思考空间。我们必须考虑平台的不同部分是如何互相连接的。
- en: To really let the player feel like they’re exploring, we’ll need to create a
    world that’s larger than a single screen, but it will be consistent. For example,
    if the player walks off the right side of one screen, they should be able to return
    to where they started by walking left back into the screen. That way, the player
    can develop a feel for where all the different parts of the world are and how
    they connect.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让玩家真正感受到他们在探索，我们需要创建一个比单一屏幕更大的世界，但它会保持一致。例如，如果玩家走出一个屏幕的右侧，他们应该能通过向左走回到最初的地方。这样，玩家可以逐渐熟悉世界的不同部分以及它们是如何连接的。
- en: 'Have you ever felt excited to discover a new way to get to a place that you
    didn’t know before? In that moment, you understand your neighborhood a little
    better: things start to connect like pieces in a puzzle! We can create this feeling
    in our players by making an interesting world to explore.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有曾经因发现一条到达某个地方的新路线而感到兴奋？在那一刻，你对你的社区有了更深的了解：事情开始像拼图一样连接起来！我们可以通过创造一个有趣的世界让玩家产生这种感觉，去探索。
- en: Using a Variable to Create a Grid Map
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用变量创建一个网格地图
- en: Just like blocks in your neighborhood, we’ll arrange our screens into a grid.
    We’ll start with a grid of 4 rooms by 4 rooms, 16 total! Not too big but not too
    small. We’ll number each room to keep track of them, like this.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你所在社区的街区一样，我们将把屏幕安排成一个网格。我们将从一个 4 × 4 的房间网格开始，总共 16 个！既不大也不小。我们会给每个房间编号，以便追踪它们，就像这样。
- en: '| 1 | 2 | 3 | 4 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 3 | 4 |'
- en: '| 5 | 6 | 7 | 8 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 6 | 7 | 8 |'
- en: '| 9 | 10 | 11 | 12 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 10 | 11 | 12 |'
- en: '| 13 | 14 | 15 | 16 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 14 | 15 | 16 |'
- en: Think of the grid like panels on a comic book page. Looking at this grid, we
    can easily figure out how to get from one screen to another. To move right one
    screen, we just add 1 to the number. Room 1 + 1 = room 2\. To move left, we subtract
    1\. To move up or down, we have to get to a different row. For example, if we
    were trying to move down from room 2 to room 6, we would need to add 4\. To go
    back up, we would subtract 4.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将网格想象成漫画书页面上的面板。看看这个网格，我们可以轻松地弄清楚如何从一个屏幕移动到另一个屏幕。向右移动一个屏幕，我们只需将数字加 1。房间 1 +
    1 = 房间 2。向左移动，我们减去 1。向上或向下移动，我们需要进入不同的行。例如，如果我们想从房间 2 移动到房间 6，我们需要加 4。要回到上面，我们需要减去
    4。
- en: Moving up or down a row requires adding or subtracting 4 because each row has
    4 spaces. But in a 5 × 5 grid, we’d need to add 5 to drop down a row!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 向上或向下移动一行需要加或减去 4，因为每行有 4 个空间。但在一个 5 × 5 的网格中，向下移动一行需要加 5！
- en: This kind of movement is sometimes called *flickscreen* because instead of scrolling
    gradually, the screen flicks to a new image, like turning a page in a book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种移动有时被称为*快速翻页*，因为屏幕不是逐渐滚动，而是跳到一个新的图像，就像翻书一样。
- en: We’ll use a variable to keep track of which screen the player is on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个变量来跟踪玩家所在的屏幕。
- en: Moving from Screen to Screen
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 屏幕之间的移动
- en: We’ll use our `Walls` sprite to store all our screens. It has a costume for
    each room and changes costumes whenever the player walks off one screen to another.
    First, let’s code moving from one screen to another using the following code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `Walls` 精灵来存储所有的屏幕。它为每个房间都有一个服装，并在玩家走出一个屏幕进入另一个屏幕时更换服装。首先，让我们编写代码来实现从一个屏幕到另一个屏幕的移动，使用以下代码。
- en: '![Image](Images/f092-01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f092-01.jpg)'
- en: '*Code for screen swapping*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*换屏代码*'
- en: You can see we use a new variable, `screen`, and a new event, `new screen`.
    When the game starts, the `Walls` sprite sets the `screen` variable to 1 and then
    broadcasts the `new screen` event, changing its costume to match the screen the
    player is on. From now on, it’s mostly the player sprite that will change the
    screen.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们使用了一个新变量 `screen` 和一个新事件 `new screen`。当游戏开始时，`Walls` 精灵将 `screen` 变量设置为
    1，然后广播 `new screen` 事件，将其服装更改为与玩家所在屏幕匹配。从现在开始，主要是玩家精灵会切换屏幕。
- en: Testing Screen Switching
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试屏幕切换
- en: Now add 15 new costumes to the `Walls` sprite for a total of 16\. It’s okay
    to leave these blank for now, and it’s fine if you just name them `costume2`,
    `costume3`, and so on. In fact, it’s better to use numbers in their names. Just
    make sure the numbers are accurate and in the correct order!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为 `Walls` 精灵添加 15 个新服装，总共 16 个。现在可以先将它们留空，如果你只是将它们命名为 `costume2`、`costume3`
    等也是可以的。事实上，最好在它们的名称中使用数字。只要确保数字准确并按正确顺序排列即可！
- en: The one costume we should fill out is `costume2` so we can test whether screen
    switching works. It doesn’t matter what this screen looks like, but try to get
    platforms along the edge to line up with platforms in the first screen. The easiest
    way to do this is to use the Select tool to highlight just the edge of the previous
    screen before copying and pasting it into the new screen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该填充的一个服装是 `costume2`，这样我们就可以测试屏幕切换是否正常工作。这个屏幕的外观不重要，但尽量使屏幕边缘的平台与第一个屏幕中的平台对齐。最简单的方法是使用选择工具高亮显示上一屏幕的边缘，然后将其复制粘贴到新屏幕中。
- en: '![Image](Images/f093-01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f093-01.jpg)'
- en: '*Copy and paste the edge of the previous screen to costume2.*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*将上一屏幕的边缘复制粘贴到 `costume2`。*'
- en: Coding Screen Change
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写屏幕切换代码
- en: We added a `wrap` section to our code between the `move left/right` stack and
    the `climb` stack, but we left it blank. Now let’s fill it in!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中为 `move left/right` 堆栈和 `climb` 堆栈之间添加了一个 `wrap` 部分，但它被留空了。现在让我们来填充它！
- en: '![Image](Images/f094-01.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f094-01.jpg)'
- en: '*The wrap code*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*换屏代码*'
- en: 'We want the player to be able to walk off the side of the screen and then appear
    in the next one. For example, if they leave the right side of screen 1, they should
    appear at the left side of screen 2\. We’ll write code for all four directions
    the player can move in: up, down, left, and right.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望玩家能够从屏幕的一侧走出去，然后出现在下一个屏幕。例如，如果他们从屏幕 1 的右侧离开，应该出现在屏幕 2 的左侧。我们将为玩家可以移动的四个方向编写代码：上、下、左、右。
- en: 'For each direction, we need to do the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个方向，我们需要做以下事情：
- en: '**Check whether the player is outside the edge of the screen:** Remember that
    `x` runs from –240 on the left to 240 on the right, and `y` runs from 180 at the
    top to –180 at the bottom.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查玩家是否在屏幕边缘之外：** 记住，`x` 从左侧的 –240 到右侧的 240，`y` 从顶部的 180 到底部的 –180。'
- en: '**Move the player to enter the opposite edge of the screen:** When the player
    exits the bottom of one screen, they should move to the top of the next screen.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将玩家移动到屏幕的相对边缘：** 当玩家从一个屏幕的底部离开时，他们应该进入下一个屏幕的顶部。'
- en: '**Adjust the screen variable:** When moving up and down, the player needs to
    go –4 or 4 screens at a time.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调整屏幕变量：** 当玩家上下移动时，每次需要移动 –4 或 4 个屏幕。'
- en: '**Broadcast the new screen event:** This lets all the other sprites know the
    screen has changed, so the `Walls` sprite will change to the costume that matches
    the current screen number.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**广播新屏幕事件：** 这会让所有其他精灵知道屏幕已经切换，因此 `Walls` 精灵将更换到与当前屏幕编号匹配的服装。'
- en: You might need to adjust the values of the x and y positions depending on the
    size of your `Hitbox` sprite. Scratch stops sprites before they can get too far
    off-screen, which means a larger sprite might not be able to reach an x position
    of –240\. In that case, you might try –239 instead. Keep adjusting values until
    the code works the way you want.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要根据 `Hitbox` 精灵的大小调整 `x` 和 `y` 位置的值。Scratch 会在精灵离开屏幕前将其停止，这意味着较大的精灵可能无法达到
    x 位置 –240。在这种情况下，你可以尝试使用 –239。不断调整值，直到代码按你希望的方式工作。
- en: Using Light and Darkness
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用光明与黑暗
- en: To make the feeling of exploration stronger, we’ll limit what the player can
    see to the circle of light coming from their hatlight. This is a very simple effect.
    All the walls and platforms are black. When we put a black background behind them,
    we can’t see where the walls are. By putting a small field of light between the
    black background and the black walls, we create an area around the player where
    they can see the walls.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强探索的感觉，我们将限制玩家看到的范围，仅限于从他们的帽灯发出的光圈。这是一个非常简单的效果。所有的墙壁和平台都是黑色的。当我们在它们后面放一个黑色背景时，玩家无法看到墙壁的位置。通过在黑色背景和黑色墙壁之间放置一个小的光场，我们创建了一个玩家可以看到墙壁的区域。
- en: Of course, this only works if all the walls and the background are the same
    color. If the walls were a different color than the background, the player would
    see everything, and there would be less mystery and not much to explore in the
    game. You can use other colors to draw walls if you want them to show up, such
    as glowing moss on cave walls, or lava cracks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只有在所有墙壁和背景颜色相同的情况下才有效。如果墙壁与背景颜色不同，玩家会看到一切，游戏中的神秘感会减少，探索也没有什么意义。如果你希望墙壁可见，可以使用其他颜色来绘制墙壁，比如洞穴墙上的发光苔藓或岩浆裂缝。
- en: '![Image](Images/f096-01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f096-01.jpg)'
- en: '*Creating a field of light between the background and wall*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*在背景和墙壁之间创建光场*'
- en: Create a new sprite to represent the beam of light using the **Ellipse** tool.
    You can call the sprite `Flashlight`. An *ellipse* is a roundish shape that can
    be wider in one direction than the other, like a football. To draw a perfect circle,
    hold down the SHIFT key while you draw it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**椭圆**工具创建一个新的精灵来表示光束。你可以将这个精灵命名为`手电筒`。*椭圆*是一种形状，在一个方向上比另一个方向更宽，就像一个橄榄球。要画一个完美的圆形，在绘制时按住SHIFT键。
- en: '![Image](Images/f096-02.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f096-02.jpg)'
- en: '*Drawing a circle of light*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*绘制光圈*'
- en: The circle can be any size for now. Later, we’ll add code to make it bigger
    or smaller depending on the strength of the hatlight’s battery life! Just make
    sure the center of the circle is over the `+`. Here, we made it a bit yellow,
    like the color of a flashlight.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形现在可以是任何大小。稍后，我们将添加代码根据帽灯电池的电量来调整它的大小！只要确保圆形的中心在`+`的上方。这里，我们将它做成了稍微偏黄的颜色，像手电筒的光一样。
- en: Make sure the `Flashlight` sprite is between the black background and the walls.
    An easy way to adjust where sprites are is to drag a `go backward 1 layer` block
    into the `Flashlight` Scripts tab. You don’t have to connect it to an event. When
    you double-click on a code block, it will run instantly. Just double-click the
    `go backward 1 layer` block until the sprite is in the right place. Then you can
    delete the block.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`手电筒`精灵位于黑色背景和墙壁之间。调整精灵位置的一种简单方法是将`后退 1 层`积木拖到`手电筒`脚本标签下。你不需要将其连接到事件。当你双击一个代码块时，它会立即运行。只需双击`后退
    1 层`积木，直到精灵到达正确位置。然后你可以删除这个积木。
- en: Coding the Flashlight
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写手电筒代码
- en: Now it’s time to code the `Flashlight`. The following is the entire code that
    programs how the light will appear.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写`手电筒`的代码了。以下是编写光源如何显示的完整代码。
- en: '![Image](Images/f097-01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f097-01.jpg)'
- en: '*The Flashlight code*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*手电筒代码*'
- en: Creating Objects to Collect
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建可收集物品
- en: In [Chapter 2](ch02.xhtml#ch02), we talked about how collecting berries encouraged
    the player to think and pay attention to the way the bug moved. In this game,
    collecting objects can encourage the player to explore and find new paths and
    secrets in the game environment.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.xhtml#ch02)中，我们讨论了收集浆果如何鼓励玩家思考并注意虫子移动的方式。在这个游戏中，收集物品可以鼓励玩家探索并在游戏环境中发现新路径和秘密。
- en: Let’s create a sprite for a collectible battery that the player uses to make
    their hatlight stronger. (That’s not how flashlights work in real life, but let’s
    imagine that’s how it works!)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来创建一个可收集的电池精灵，玩家用它来增强他们的帽灯（这和现实中的手电筒工作方式不同，但我们可以假设就是这样！）。
- en: '![Image](Images/f098-01.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f098-01.jpg)'
- en: '*Creating the battery sprite*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建电池精灵*'
- en: The batteries should be visible even if they’re not in the player’s field of
    light, as long as they’re on the same screen. That way, the player can see a battery
    somewhere onscreen and try to find a way to reach it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 电池应该是可见的，即使它们不在玩家的光圈内，只要它们在同一个屏幕上。这样，玩家可以在屏幕上看到某个电池，并尝试找到方法到达那里。
- en: The finished game will have seven batteries the player can collect. To create
    multiple batteries, we’ll use cloning, just like we did to create multiple berries
    in [Chapter 2](ch02.xhtml#ch02).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的游戏将有七个电池，玩家可以收集它们。为了创建多个电池，我们将使用克隆，就像我们在[第2章](ch02.xhtml#ch02)中创建多个浆果一样。
- en: When the game starts, the `battery` sprite visits every spot a battery should
    appear, sets its `location` variable to the correct screen, and clones itself.
    At the start of a game, the battery creates seven clones, each with a different
    `x` and `y` position and screen number. Each clone uses the `location` variable
    to keep track of which screen it should appear on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始时，`battery`精灵会访问每个电池应该出现的位置，将其`location`变量设置为正确的屏幕，并克隆自己。在游戏开始时，电池会创建七个克隆，每个克隆都有不同的`x`和`y`位置以及屏幕编号。每个克隆使用`location`变量来跟踪它应该出现在的屏幕。
- en: After it’s finished making clones, the original `battery` sprite sets its own
    location to 0, so it doesn’t appear on any of the 16 screens. If we don’t do this,
    the parent `battery` will show up onscreen even though the player can never collect
    it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成克隆之后，原始的`battery`精灵将其自身的位置设为0，这样它就不会出现在任何16个屏幕上。如果我们不这么做，即使玩家无法收集到它，父级`battery`也会出现在屏幕上。
- en: To make sure batteries only appear when the player’s on their screens, we use
    the global `screen` variable to check whether it matches its local `location`
    variable. If it is, it’s the correct screen and the clone appears! Otherwise,
    it disappears.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保电池只在玩家所在的屏幕上出现，我们使用全局`screen`变量来检查它是否与本地`location`变量匹配。如果匹配，那就是正确的屏幕，克隆就会出现！否则，它就会消失。
- en: '![Image](Images/f099-01.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f099-01.jpg)'
- en: '*The Battery code*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*电池代码*'
- en: If a player makes contact with a battery, we add a value to the global `batteries
    found` variable, which was set to 0 at the start of the game, and makes the flashlight’s
    `glow` variable a little bigger. The more batteries the player collects, the more
    they can see, helping them track down even more batteries!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家与电池发生接触，我们会将一个值加到全局的`batteries found`变量中，该变量在游戏开始时被设置为0，并使手电筒的`glow`变量稍微增大。玩家收集的电池越多，他们能看到的范围就越大，从而帮助他们找到更多的电池！
- en: What You Learned
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: In this chapter, we tackled a lot of complex ideas. You learned how to program
    platform movement and create a character who can walk, climb, jump, and fall.
    You created a flashlight that the player uses to see in the darkness. By using
    flickscreen movement, you also created a larger world for your character to explore.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们处理了许多复杂的概念。你学会了如何编写平台运动程序，并创建了一个可以走路、爬墙、跳跃和下落的角色。你还创建了一个手电筒，玩家可以用它在黑暗中看东西。通过使用快速屏幕移动，你还为角色创造了一个更大的世界来探索。
- en: In the next chapter, we’ll continue designing *Hatlight* by filling it with
    secrets, challenges, and more interesting places for the player to discover. We’ll
    also create and animate a player character to replace that hitbox. Take a break,
    eat a snack, pet a cat, and meet me in [Chapter 4](ch04.xhtml#ch04) when you’re
    ready!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将继续设计*Hatlight*，为它填充更多的秘密、挑战以及供玩家发现的更有趣的地方。我们还将创建并动画化一个玩家角色，替代那个碰撞盒。休息一下，吃个小吃，抚摸一下猫，准备好后在[第4章](ch04.xhtml#ch04)见！
