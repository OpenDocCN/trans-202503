<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_77"/><strong>7 RF430 Backdoors</strong></h2>&#13;
<p class="noindent">It’s not uncommon to find that an unlisted chip is actually a commercially available chip with a custom ROM. Such is the RF430TAL152, which is pretty much an RF430FRL152 with a mask ROM that implements a blood glucose monitor in sensors sold under the Freestyle Libre brand.</p>&#13;
<p class="indent">In this chapter, we’ll discuss a backdoor in the RF430TAL152, first documented in Goodspeed and Apvrille (2019). We’ll begin with the freely available FRL152 variant of the chip, then explore the TAL152 variant, its custom commands, and a backdoor.</p>&#13;
<h3 class="h3" id="ch00lev1sec23"><strong>RF430FRL152, Commercial Variant</strong></h3>&#13;
<p class="noindent">Both the TAL152 and the FRL152 have sensor applications in 7kB of masked ROM at <code>0x4400</code>. Neither of the chips contains flash memory; instead, they use a new memory technology called ferroelectric RAM, FRAM for short. Like flash memory, it’s non-volatile and the contents survive without power. Like SRAM, it’s very power efficient to write this memory.</p>&#13;
<p class="indent">Minor patches against the ROM are loaded into two kilobytes of FRAM at <code>0xF840</code>. A small second region of FRAM exists at <code>0x1A00</code>, holding a serial number and calibration values.</p>&#13;
<p class="indent">FRAM is a weird memory, so let’s quickly review its properties. At the lowest levels, writes take very little power and most bits survive for decades without power. Like DRAM and core memory, reads are destructive.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_78"/><img id="ch7fig1" src="../images/f0078-01.jpg" alt="Image" width="777" height="785"/></div>&#13;
<p class="figcap">Figure 7.1: RF430TAL152 Surface</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_79"/><img id="ch7fig2" src="../images/f0079-01.jpg" alt="Image" width="777" height="783"/></div>&#13;
<p class="figcap">Figure 7.2: RF430FRL152 Delayered</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>Destructive reads and the occasional bit error would be a deal-breaker, so a memory controller corrects this with automated write-backs, error correction, and caching. At the higher levels, a programmer can pretend that it’s RAM, and the only contradicting evidence would be that sometimes reads take a little more time and a little more power than writes do. Isn’t that sweet?</p>&#13;
<p class="indent">The chip has a bit more SRAM than you might expect, 4kB of it at <code>0x4400</code>. SRAM is executable on the MSP430 architecture, and it can be mapped in place of half the ROM in order to develop custom ROMs. A developer could also store normal code in SRAM, at the risk of it being obliterated by a power failure.</p>&#13;
<p class="indent">Because changes to ROM require expensive mask revisions and fresh manufacturing, both the commercial and the custom ROM support patches in FRAM. These patches hook entries in a table of function pointers, redirecting calls from the ROM version of a function to its replacement in FRAM.</p>&#13;
<p class="indent">As the FRAM is used not just for code but also for data, it’s sort of a window into the remaining address space of the chip, and the first step to a full dump. You’ll see this later in the chapter, when we get around to exploiting a locked TAL152 chip.</p>&#13;
<p class="indent">The FRL152 can be read and written by JTAG at the frustratingly modern voltage of 1.5V. Texas Instruments helpfully sells a development kit, part number RF430FRL152HEVM, that includes level conversion to the 3.3V supported by their debugger tool. This allows the ROM to be extracted and disassembled from the commercial variant of the chip.</p>&#13;
<p class="indent">The RF430TAL152 in Freestyle Libre glucose sensors has a different ROM, and JTAG connections fail, but it speaks the same NFC Type V protocol, standardized as ISO 15693. This protocol is well supported by Android, and poorly supported by USB readers on Linux, so it’s in the awkward position of being more easily exploited by a cellphone app than by a laptop!</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_81"/><img id="ch7fig3" src="../images/f0081-01.jpg" alt="Image" width="286" height="428"/></div>&#13;
<p class="figcap">Figure 7.3: RF430FRL152 Memory Map</p>&#13;
<div class="image"><img id="ch7fig4" src="../images/f0081-02.jpg" alt="Image" width="751" height="523"/></div>&#13;
<p class="figcap">Figure 7.4: RF430FRL152 Carrier Board</p>&#13;
<h3 class="h3" id="ch00lev1sec24"><span epub:type="pagebreak" id="page_82"/><strong>NFC-V from Android</strong></h3>&#13;
<p class="noindent">Let’s take a brief interruption to discuss how NFC tags work in Android and how to write a tool to communicate wirelessly with the RF430.</p>&#13;
<p class="indent">In Android, NFC Type V tags are accessed through the class <code>android.nfc.tech.NfcV</code>, whose <code>transceive()</code> function sends a byte array to the tag and returns the result. As tags have such wildly varying properties as their command sets, block sizes and addressing modes, these raw commands are used rather than higher-level wrappers.</p>&#13;
<p class="indent">NFC-V transactions begin with an option byte, which is usually <code>02</code>. Next comes a command byte and the optional command parameters. An explicit address can be stuck in the middle if indicated by the option byte. Commands above <code>A0</code> require the manufacturer’s number to follow, which for TI is <code>07</code>. See <a href="ch07.xhtml#ch7fig5">Figure 7.5</a> for some example commands.</p>&#13;
<p class="indent">You can try out the low-level commands yourself in the NFC Tools app, whose Other/Advanced tab accepts raw commands after a scary disclaimer. Just set the I/O Class to <code>NfcV</code> and then send the following examples, before using them to implement our own high level functions for the chip.</p>&#13;
<p class="indent">We’ll get into more commands later, but for now you should pay attention to the general format. Here, <code>20</code> is the standard command to read a block from an 8-bit block address and <code>C0</code> is the secret vendor command to read a block from a 16-bit block address. The first byte of each reply is zero for success, non-zero for failure.</p>&#13;
<div class="imagel"><img src="../images/f0082-01.jpg" alt="Image" width="811" height="136"/></div>&#13;
<div class="image"><span epub:type="pagebreak" id="page_83"/><img id="ch7fig5" src="../images/f0083-01.jpg" alt="Image" width="766" height="551"/></div>&#13;
<p class="figcap">Figure 7.5: NFC-V Command Verbs</p>&#13;
<div class="image"><img id="ch7fig6" src="../images/f0083-02.jpg" alt="Image" width="647" height="125"/></div>&#13;
<p class="figcap">Figure 7.6: Example TAL152 Commands</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_84"/>The <code>C0</code> (read) command and matching <code>C1</code> (write) command accept a 16-bit address, but they are still confined to a subset of FRAM and SRAM. In the next section, we’ll see how to write some shellcode into the FRL152 and then execute it as a way to implement a truly arbitrary read.</p>&#13;
<h3 class="h3" id="ch00lev1sec25"><strong>Shellcode on the FRL152</strong></h3>&#13;
<p class="noindent">FRAM on the FRL152 might contain a table of command handlers. If this table is found, its entries are copied onto an array of function pointers near the beginning of SRAM. Further, the <code>C0</code> and <code>C1</code> commands allow us to freely read and write SRAM, so there’s plenty of control for remote code execution on the chip.</p>&#13;
<p class="indent">While we could overwrite the call stack, it is much easier to overwrite the function pointer table in early SRAM with a pointer to our function, because we can only perform writes of 4 or 8 bytes at a time.</p>&#13;
<p class="indent">There are plenty of functions to choose from, and an ideal hook would be one that won’t be missed by normal functions. We’d also prefer to have continuation wherever possible, so that executing the code doesn’t crash our target.</p>&#13;
<p class="indent">The function pointer we’ll overwrite is at <code>0x1C5C</code> in SRAM, pointing to <code>rom_rf13_senderror()</code> in ROM at <code>0x4FF6</code>. For proper continuation, the shellcode must write two bytes to the <code>RF13MTXF</code> peripheral and then return. Without these bytes, the protocol will be violated and a Java exception will be triggered. To unhook, we just write <code>0x4FF6</code> to <code>0x1C5C</code>, restoring the original handler.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7fig7">Figure 7.7</a> shows my Java method for executing shellcode at an arbitrary address and returning two bytes to the caller. These bytes happen to be necessary for continuation, but it’s always nice to get a little feedback from an exploit.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_85"/><img id="ch7fig7" src="../images/f0085-01.jpg" alt="Image" width="821" height="508"/></div>&#13;
<p class="figcap">Figure 7.7: Executing Shellcode in the RF430FRL152</p>&#13;
<h3 class="h3" id="ch00lev1sec26"><span epub:type="pagebreak" id="page_86"/><strong>RF430TAL152, Medical Variant</strong></h3>&#13;
<p class="noindent">The TAL152 glucose sensor is very similar in layout and appearance to the off-the-shelf FRL152, with the difference being the contents of mask ROM and the JTAG configuration. In this section, we’ll trace the long road from first examining this chip to finally dumping its ROM and then writing custom firmware to FRAM.</p>&#13;
<p class="indent">When first experimenting with the chip, we find that there is one extra block of FRAM exposed by NFC. Every last page is write protected, and we cannot change any of them with the standard write command, <code>21</code>. The <code>C0</code> and <code>C1</code> vendor commands from the FRL152 do not exist here, so we also lack a convenient way to mess around with out-of-bounds memory.</p>&#13;
<p class="indent">But all is not lost! There is a table of function pointers on the final page, and the value of the reset vector at the very end of memory tells us that this ROM is different from the FRL152, so we know that the two devices have different software in their ROMs.</p>&#13;
<p class="indent">This table is in the portion of memory that is readable by NFC, so we can use a handy smartphone to read it. It is, however, write protected, so we’re not yet able to write patches to the table. We’re sadly unable to read the lower portions of FRAM, or any of ROM or SRAM at this point.</p>&#13;
<p class="indent">We see the table from <a href="ch07.xhtml#ch7fig9">Figure 7.9</a>, which begins at <code>0xFFCE</code> with the magic word <code>0xABAB</code> and then grows downward to the same word at a lower address, <code>0xFFB8</code>.<sup><a id="ch7fn_1" href="footnotes.xhtml#ch7fn1">1</a></sup> Each entry in this table is a custom vendor command, and we see that much like the <code>C0</code> and <code>C1</code> commands that have been so handy on the FRL152, the TAL152 has commands <code>A0</code>, <code>A1</code>, <code>A2</code>, <code>A3</code>, and <code>A4</code>. The <code>A1</code> and <code>A3</code> handlers are in FRAM, where we can read at least part of their code.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_87"/><img id="ch7fig8" src="../images/f0087-01.jpg" alt="Image" width="811" height="113"/></div>&#13;
<p class="figcap">Figure 7.8: RF430FRL152 FRAM Command Table</p>&#13;
<div class="image"><img id="ch7fig9" src="../images/f0087-02.jpg" alt="Image" width="821" height="438"/></div>&#13;
<p class="figcap">Figure 7.9: RF430TAL152 FRAM Command Table</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>The table ends early, of course, with <code>E0</code>, <code>E1</code>, and <code>E2</code> being disabled by <code>E0</code>’s command number having been overwritten by the table end marker. These commands were available at some point in the manufacturing process, and we can read their command handlers from FRAM, but we cannot execute them.</p>&#13;
<p class="indent">Calling these functions is a bit disappointing. <code>A1</code> returns the device status of some sort, but the other <code>Ax</code> commands don’t even grace us with an error message in reply. The reason for this is hard to see from the partial assembly, but we later learned that they require a safety password.</p>&#13;
<p class="indent">Not yet being able to run the <code>A3</code> command, we read its disassembly. The function begins by calling another function at <code>0x1C20</code> and then proceeds to read a raw address and length before sending the requested number of 16-bit words out the RF13M peripheral to the reader.<sup><a id="ch7fn_2" href="footnotes.xhtml#ch7fn2">2</a></sup> If we could just call this command, we could dump the ROM and reverse engineer the behavior of the other commands!</p>&#13;
<h4 class="h4" id="ch00lev1sec27"><strong>Sniffing the Readers</strong></h4>&#13;
<p class="noindent">To get the password without already having a firmware dump, we had to sniff a legitimate reader’s attempts to call any <code>Ax</code> command other than <code>A1</code>, so that we could learn the password and then use <code>A3</code> to dump raw memory. We found this both by tapping the SPI bus of the manufacturer’s dedicated hardware reader and separately by observing the vendor’s Android app in Frida.<sup><a id="ch7fn_3" href="footnotes.xhtml#ch7fn3">3</a></sup></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>The 32-bit password, <code>C2AD7521</code>, came as a parameter to the <code>A0</code> command, which initializes the glucose sensor after injection into a patient’s arm. Trying this same password in <code>A3</code>, followed by an address and length, gave us the ability to read raw memory. Sending this command in a loop gave complete dumps of ROM and SRAM, as well as a complete dump of the FRAM regions. These regions are not exposed by the standard read command, <code>20</code>, which takes a block address.</p>&#13;
<h4 class="h4" id="ch00lev1sec28"><strong>Inside the TAL152 ROM</strong></h4>&#13;
<p class="noindent">Loading this complete dump into Ghidra shows that the ROM is related to that of the FRL152, but that they have diverged quite a bit. The TAL152 implements no vendor commands directly; rather, they must be added through the patch table.</p>&#13;
<p class="indent">We also lacked the ability to write to FRAM, as it was write protected. Sure enough, <code>A2</code> write protects every FRAM page that is exposed by NFC, and <code>A4</code> unlocks those same pages! A list of commands is found in <a href="ch07.xhtml#ch7fig5">Figure 7.5</a>.</p>&#13;
<p class="indent">Calling the <code>A4</code> command, we can then unlock pages and begin mucking around. A simple write to <code>0xFFB8</code> will re-enable the <code>Ex</code> commands, allowing us to experiment with restoring old sensors. Or we can compile our own firmware to run inside of the TAL152, turning a glucose sensor into something entirely different.</p>&#13;
<h3 class="h3" id="ch00lev1sec29"><span epub:type="pagebreak" id="page_90"/><strong>Some Other Unlocking Techniques</strong></h3>&#13;
<p class="noindent">While trying to dump the TAL152, we hit a few dead ends that might possibly work for you on other targets.</p>&#13;
<p class="indent">We can’t make a connection, but the JTAG of the TAL152 appears to be unlocked if it follows the same convention as the FRL152. This might very well be caused by a custom activation key, but whether it is a different locking mechanism or a different key, we were unable to get a connection. I’ve since heard that the bonding wires go to different pins on the TAL152, and that a connection can be made by adjusting them, but I’ve not confirmed that in my own lab.</p>&#13;
<p class="indent">We tried to wipe these chips back to a factory setting by raising them above their Curie point. Our theory was that the heat might erase FRAM while preserving ROM, so that ROM would be freely read.</p>&#13;
<p class="indent">Texas Instruments Application Report SLAA526A, <em>MSP430 FRAM Quality and Reliability</em>, leads us to believe this temperature is near 430 <sup>°</sup>C. Short experiments involving a hot air gun and strong magnets were unsuccessful, but we hope someday to bake a chip in a kiln for many hours to look for bit failures.</p>&#13;
<p class="indent">Test pins on the chip aroused our curiosity, as other chips use them to enter a bootloader and these chips might use them to reset to a factory state. This could be as effective as overheating the FRAM, without the hassles of extreme temperatures.</p>&#13;
<p class="indent">It’s worth noting that our successful method—using the <code>A3</code> command with the manufacturer’s password—can be accomplished <em>either</em> by tapping the hardware reader’s SPI bus <em>or</em> by reading that same password out of the manufacturer’s Android application. In reverse engineering, any technique that works is a good one, and there’s often more than one way to win the game.</p>&#13;
</div>
</div>
</body></html>