<html><head></head><body><section class="chapter" epub:type="chapter" id="wireless_networks_made_easy" title="Chapter&#xA0;4.&#xA0;Wireless Networks Made Easy"><div class="titlepage"><div><div><h2 class="title">Chapter 4. Wireless Networks Made Easy</h2></div></div></div><div class="mediaobject"><a id="med_id00006"/><img alt="Wireless Networks Made Easy" src="httpatomoreillycomsourcenostarchimages2127149.png.jpg"/></div><p><a class="indexterm" id="iddle2049"/>It’s rather tempting to say that on BSD—and OpenBSD, in particular—there’s no need to “make wireless networking easy” because it already is. Getting a wireless network running isn’t very different from getting a wired one up and running, but there are some issues that turn up simply because we’re dealing with radio waves and not wires. We’ll look briefly at some of the issues before moving on to the practical steps involved in creating a usable setup.</p><p>Once we have covered the basics of getting a wireless network up and running, we’ll turn to some of the options for making your wireless network more interesting and harder to break.</p><div class="sect1" title="A Little IEEE 802.11 Background"><div class="titlepage"><div><div><h2 class="title" id="little_ieee_802dot11_background" style="clear: both">A Little IEEE 802.11 Background</h2></div></div></div><p><a class="indexterm" id="iddle1054"/><a class="indexterm" id="iddle1357"/><a class="indexterm" id="iddle1467"/><a class="indexterm" id="iddle1468"/><a class="indexterm" id="iddle1969"/><a class="indexterm" id="iddle2045"/><a class="indexterm" id="iddle2054"/>Setting up any network interface, in principle, is a two-step process: You establish a link, and then you move on to configuring the interface for TCP/IP traffic.</p><p>In the case of wired Ethernet-type interfaces, establishing the link usually consists of plugging in a cable and seeing the link indicator light up. However, some interfaces require extra steps. Networking over dial-up connections, for example, requires telephony steps, such as dialing a number to get a carrier signal.</p><p>In the case of IEEE 802.11–style wireless networks, getting the carrier signal involves quite a few steps at the lowest level. First, you need to select the proper channel in the assigned frequency spectrum. Once you find a signal, you need to set a few link-level network identification parameters. Finally, if the station you want to link to uses some form of link-level encryption, you need to set the correct kind and probably negotiate some additional parameters.</p><p>Fortunately, on OpenBSD systems, all configuration of wireless network devices happens via <code class="literal">ifconfig</code> commands and options, as with any other network interface. While most network configuration happens via <code class="literal">ifconfig</code> on other BSDs, too, on some systems, specific features require other configu-ration.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch04fn01" id="ch04fn01">20</a>]</sup> Still, because we’re introducing wireless networks here, we need to look at security at various levels in the networking stack from this new perspective.</p><p>There are basically three kinds of popular and simple IEEE 802.11 privacy mechanisms, and we’ll discuss them briefly over the next sections.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note01"/>Note</h3><p><span class="emphasis"><em>For a more complete overview of issues surrounding security in wireless networks, see Professor Kjell Jørgen Hole’s articles and slides at</em></span> <a class="ulink" href="http://www.kjhole.com/" target="_top">http://www.kjhole.com/</a> <span class="emphasis"><em>and</em></span> <a class="ulink" href="http://www.nowires.org/" target="_top">http://www.nowires.org/</a><span class="emphasis"><em>.</em></span></p></div><div class="sect2" title="MAC Address Filtering"><div class="titlepage"><div><div><h3 class="title" id="mac_address_filtering">MAC Address Filtering</h3></div></div></div><p>The short version of the story about PF and MAC address filtering is that we don’t do it. A number of consumer-grade, off-the-shelf wireless access points offer MAC address filtering, but contrary to common belief, they don’t really add much security. The marketing succeeds largely because most consumers are unaware that it’s possible to change the MAC address of essentially any wireless network adapter on the market today.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch04fn02" id="ch04fn02">21</a>]</sup></p><div class="note" title="Note"><h3 class="title"><a id="ch04note02"/>Note</h3><p><a class="indexterm" id="iddle2038"/><a class="indexterm" id="iddle2046"/><a class="indexterm" id="iddle2047"/><a class="indexterm" id="iddle2055"/><a class="indexterm" id="iddle2056"/><a class="indexterm" id="iddle2071"/><span class="emphasis"><em>If you really want to try MAC address filtering, you could look into using the <code class="literal">bridge(4)</code> facility and the bridge-related rule options in <code class="literal">ifconfig(8)</code> on OpenBSD 4.7 and later. We’ll look at bridges and some of the more useful ways to use them with packet filtering in <a class="xref" href="ch05.html" title="Chapter 5. Bigger or Trickier Networks">Chapter 5</a>. Note that you can use the bridge filtering without really running a bridge by just adding one interface to the bridge.</em></span></p></div></div><div class="sect2" title="WEP"><div class="titlepage"><div><div><h3 class="title" id="wep">WEP</h3></div></div></div><p>One consequence of using radio waves instead of wires to move data is that it’s comparatively easier for outsiders to capture data in transit over radio waves. The designers of the 802.11 family of wireless network standards seem to have been aware of this fact, and they came up with a solution that they went on to market under the name <span class="emphasis"><em>Wired Equivalent Privacy</em></span>, or <span class="emphasis"><em>WEP</em></span>.</p><p>Unfortunately, the WEP designers came up with their wired equivalent encryption without actually reading up on recent research or consulting active researchers in the field. So the link-level encryption scheme they recommended is considered a pretty primitive homebrew among cryptography professionals. It was no great surprise when WEP encryption was reverse-engineered and cracked within a few months after the first products were released.</p><p>Even though you can download free tools to descramble WEP-encoded traffic in a matter of minutes, for a variety of reasons, WEP is still widely supported and used. Essentially, all IEEE 802.11 equipment available today has support for at least WEP, and a surprising number offer MAC address filtering, too.</p><p>You should consider network traffic protected only by WEP to be just marginally more secure than data broadcast in the clear. Then again, the token effort needed to crack into a WEP network may be sufficient to deter lazy and unsophisticated attackers.</p></div><div class="sect2" title="WPA"><div class="titlepage"><div><div><h3 class="title" id="wpa">WPA</h3></div></div></div><p>It dawned on the 802.11 designers fairly quickly that their WEP system wasn’t quite what it was cracked up to be, so they came up with a revised and slightly more comprehensive solution called <span class="emphasis"><em>Wi-Fi Protected Access</em></span>, or <span class="emphasis"><em>WPA</em></span>.</p><p>WPA looks better than WEP, at least on paper, but the specification is complicated enough that its widespread implementation was delayed. In addition, WPA has attracted its share of criticism over design issues and bugs that have produced occasional interoperability problems. Combined with the familiar issues of access to documentation and hardware, free software support varies. Most free systems have WPA support, and even though you may find that it’s not available for all devices, the situation has been improving over time. If your project specification includes WPA, look carefully at your operating system and driver documentation.</p><p><a class="indexterm" id="iddle1190"/><a class="indexterm" id="iddle1290"/><a class="indexterm" id="iddle1314"/><a class="indexterm" id="iddle1880"/><a class="indexterm" id="iddle1892"/><a class="indexterm" id="iddle2057"/><a class="indexterm" id="iddle2058"/><a class="indexterm" id="iddle2065"/>And, of course, it goes almost without saying that you’ll need further security measures, such as SSH or SSL encryption, to maintain any significant level of confidentiality for your data stream.</p></div><div class="sect2" title="The Right Hardware for the Task"><div class="titlepage"><div><div><h3 class="title" id="right_hardware_for_the_task">The Right Hardware for the Task</h3></div></div></div><p>Picking the right hardware is not necessarily a daunting task. On a BSD system, the following simple command is all you need to enter to see a listing of all manual pages with the word <span class="emphasis"><em>wireless</em></span> in their subject lines.<sup>[<a class="footnote" href="#ftn.ch04fn03" id="ch04fn03">22</a>]</sup></p><a id="pro_id00075"/><pre class="programlisting">$ <span class="strong"><strong>apropos wireless</strong></span></pre><p>Even on a freshly installed system, this command will give you a complete list of all wireless network drivers available in the operating system.</p><p>The next step is to read the driver manual pages and compare the lists of compatible devices with what is available as parts or built into the systems you’re considering. Take some time to think through your specific requirements. For test purposes, low-end <code class="literal">rum</code> or <code class="literal">ural</code> USB dongles (or the newer <code class="literal">urtwn</code> and <code class="literal">run</code>) will work and are quite convenient. Later, when you’re about to build a more permanent infrastructure, you may want to look into higher-end gear, although you may find that the inexpensive test gear will perform quite well. Some wireless chipsets require firmware that for legal reasons can’t be distributed on the OpenBSD install media. In most cases, the <span class="emphasis"><em>fw_update</em></span> script will be able to fetch the required firmware on first boot after a successful install, as long as a network connection is available. If you install the units in an already configured system, you can try running <span class="emphasis"><em>fw_update</em></span> manually. You may also want to read <a class="xref" href="apb.html" title="Appendix B. A Note On Hardware Support">Appendix B</a> of this book for some further discussion.</p></div><div class="sect2" title="Setting Up a Simple Wireless Network"><div class="titlepage"><div><div><h3 class="title" id="setting_up_a_simple_wireless_network">Setting Up a Simple Wireless Network</h3></div></div></div><p>For our first wireless network, it makes sense to use the basic gateway configuration from the previous chapter as our starting point. In your network design, it’s likely that the wireless network isn’t directly attached to the Internet at large but that the wireless network will require a gateway of some sort. For that reason, it makes sense to reuse the working gateway setup for this wireless access point, with some minor modifications introduced over the next few paragraphs. After all, doing so is more convenient than starting a new configuration from scratch.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note03"/>Note</h3><p><span class="emphasis"><em>We’re in infrastructure-building mode here, and we’ll be setting up the access point first. If you prefer to look at the client setup first, see <a class="xref" href="ch04.html#client_side" title="The Client Side">The Client Side</a>.</em></span></p></div><p>The first step is to make sure you have a supported card and to check that the driver loads and initializes the card properly. The boot-time system messages scroll by on the console, but they’re also recorded in the file <a class="indexterm" id="iddle1369"/><a class="indexterm" id="iddle1398"/><a class="indexterm" id="iddle1412"/><a class="indexterm" id="iddle1561"/><a class="indexterm" id="iddle1970"/><a class="indexterm" id="iddle2013"/><a class="indexterm" id="iddle2062"/><span class="emphasis"><em>/var/run/dmesg.boot</em></span>. You can view the file itself or use the <code class="literal">dmesg</code> command to see these messages. With a successfully configured PCI card, you should see something like this:</p><a id="pro_id00076"/><pre class="programlisting">ral0 at pci1 dev 10 function 0 "Ralink RT2561S" rev 0x00: apic 2 int 11 (irq&#13;
11), address 00:25:9c:72:cf:60&#13;
ral0: MAC/BBP RT2561C, RF RT2527</pre><p>If the interface you want to configure is a hot-pluggable type, such as a USB or PC Card device, you can see the kernel messages by viewing the <span class="emphasis"><em>/var/log/messages</em></span> file—for example, by running <code class="literal">tail -f</code> on the file before you plug in the device.</p><p>Next, you need to configure the interface: first to enable the link and, finally, to configure the system for TCP/IP. You can do this from the command line, like this:</p><a id="pro_id00077"/><pre class="programlisting">$ <span class="strong"><strong>sudo ifconfig ral0 up mediaopt hostap mode 11g chan 1 nwid unwiredbsd nwkey 0x1deadbeef9</strong></span></pre><p>This command does several things at once. It configures the <code class="literal">ral0</code> interface, enables the interface with the <code class="literal">up</code> parameter, and specifies that the interface is an access point for a wireless network with <code class="literal">mediaopt hostap</code>. Then, it explicitly sets the operating mode to <code class="literal">11g</code> and the channel to <code class="literal">11</code>. Finally, it uses the <code class="literal">nwid</code> parameter to set the network name to <code class="literal">unwiredbsd</code>, with the WEP key (<code class="literal">nwkey</code>) set to the hexadecimal string <code class="literal">0x1deadbeef9</code>.</p><p>Use <code class="literal">ifconfig</code> to check that the command successfully configured the interface:</p><a id="pro_id00078"/><pre class="programlisting"><span class="strong"><strong>$ ifconfig ral0</strong></span>&#13;
ral0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 00:25:9c:72:cf:60&#13;
        priority: 4&#13;
        groups: wlan&#13;
        media: IEEE802.11 autoselect mode 11g hostap&#13;
        status: active&#13;
        ieee80211: nwid unwiredbsd chan 1 bssid 00:25:9c:72:cf:60 nwkey &lt;not displayed&gt; 100dBm&#13;
        inet6 fe80::225:9cff:fe72:cf60%ral0 prefixlen 64 scopeid 0x2</pre><p>Note the contents of the <code class="literal">media</code> and <code class="literal">ieee80211</code> lines. The information displayed here should match what you entered on the <code class="literal">ifconfig</code> command line.</p><p>With the link part of your wireless network operational, you can assign an IP address to the interface. First, set an IPv4 address:</p><a id="pro_id00079"/><pre class="programlisting">$ <span class="strong"><strong>sudo ifconfig ral0 10.50.90.1 255.255.255.0</strong></span></pre><p>Setting an IPv6 is equally straightforward:</p><a id="pro_id00080"/><pre class="programlisting">$ <span class="strong"><strong>sudo ifconfig alias ral0 2001:db8::baad:f00d:1 64</strong></span></pre><p><a class="indexterm" id="iddle1271"/><a class="indexterm" id="iddle1532"/><a class="indexterm" id="iddle1563"/><a class="indexterm" id="iddle1570"/>On OpenBSD, you can combine both steps into one by creating a <span class="emphasis"><em>/etc/hostname.ral0</em></span> file, roughly like this:</p><a id="pro_id00081"/><pre class="programlisting">up mediaopt hostap mode 11g chan 1 nwid unwiredbsd nwkey 0x1deadbeef9&#13;
inet6 alias 2001:db8::baad:f00d:1 64</pre><p>Then, run <span class="strong"><strong><code class="literal">sh /etc/netstart ral0</code></strong></span> (as root) or wait patiently for your next boot to complete.</p><p>Notice that the preceding configuration is divided over several lines. The first line generates an <code class="literal">ifconfig</code> command that sets up the interface with the correct parameters for the physical wireless network. The second line generates the command that sets the IPv4 address after the first command completes, followed by setting an IPv6 address for a dual-stack configuration. Because this is our access point, we set the channel explicitly, and we enable weak WEP encryption by setting the <code class="literal">nwkey</code> parameter.</p><p>On NetBSD, you can normally combine all of these parameters in one <span class="emphasis"><em>rc.conf</em></span> setting:</p><a id="pro_id00082"/><pre class="programlisting">ifconfig_ral0="mediaopt hostap mode 11g chan 1 nwid unwiredbsd nwkey&#13;
0x1deadbeef inet 10.50.90.1 netmask 255.255.255.0 inet6 2001:db8::baad:f00d:1&#13;
prefixlen 64 alias"</pre><p>FreeBSD 8 and newer versions take a slightly different approach, tying wireless network devices to the unified <code class="literal">wlan(4)</code> driver. Depending on your kernel configuration, you may need to add the relevant module load lines to <span class="emphasis"><em>/boot/loader.conf</em></span>. On one of my test systems, <span class="emphasis"><em>/boot/loader.conf</em></span> looks like this:</p><a id="pro_id00083"/><pre class="programlisting">if_rum_load="YES"&#13;
wlan_scan_ap_load="YES"&#13;
wlan_scan_sta_load="YES"&#13;
wlan_wep_load="YES"&#13;
wlan_ccmp_load="YES"&#13;
wlan_tkip_load="YES"</pre><p>With the relevant modules loaded, setup is a multicommand affair, best handled by a <span class="emphasis"><em>start_if.if</em></span> file for your wireless network. Here is an example of an <span class="emphasis"><em>/etc/start_if.rum0</em></span> file for a WEP access point on FreeBSD 8:</p><a id="pro_id00084"/><pre class="programlisting">wlans_rum0="wlan0"&#13;
create_args_wlan0="wlandev rum0 wlanmode hostap"&#13;
ifconfig_wlan0="inet 10.50.90.1 netmask 255.255.255.0 ssid unwiredbsd \&#13;
wepmode on wepkey 0x1deadbeef9 mode 11g"&#13;
ifconfig_wlan0_ipv6="2001:db8::baad:f00d:1 prefixlen 64"</pre><p>After a successful configuration, your <code class="literal">ifconfig</code> output should show both the physical interface and the <code class="literal">wlan</code> interface up and running:</p><a id="pro_id00085"/><pre class="programlisting">rum0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 2290&#13;
        ether 00:24:1d:9a:bf:67&#13;
        media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;&#13;
        status: running&#13;
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500&#13;
        ether 00:24:1d:9a:bf:67&#13;
        inet 10.50.90.1 netmask 0xffffff00 broadcast 10.50.90.255&#13;
        inet6 2001:db8::baad:f00d:1 prefixlen 64&#13;
        media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;&#13;
        status: running&#13;
        ssid unwiredbsd channel 6 (2437 Mhz 11g) bssid 00:24:1d:9a:bf:67&#13;
        country US authmode OPEN privacy ON deftxkey UNDEF wepkey 1:40-bit&#13;
        txpower 0 scanvalid 60 protmode CTS dtimperiod 1 -dfs</pre><p><a class="indexterm" id="iddle1577"/><a class="indexterm" id="iddle2067"/><a class="indexterm" id="iddle2074"/>The line <code class="literal">status: running</code> means that you’re up and running, at least on the link level.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note04"/>Note</h3><p><span class="emphasis"><em>Be sure to check the most up-to-date <code class="literal">ifconfig</code> man page for other options that may be more appropriate for your configuration.</em></span></p></div></div><div class="sect2" title="An OpenBSD WPA Access Point"><div class="titlepage"><div><div><h3 class="title" id="openbsd_wpa_access_point">An OpenBSD WPA Access Point</h3></div></div></div><p>WPA support was introduced in OpenBSD 4.4, with extensions to most wireless network drivers, and all basic WPA keying functionality was merged into <code class="literal">ifconfig(8)</code> in OpenBSD 4.9.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note05"/>Note</h3><p><span class="emphasis"><em>There may still be wireless network drivers that don’t have WPA support, so check the driver’s man page to see whether WPA is supported before you try to configure your network to use it. You can combine 802.1</em></span>x <span class="emphasis"><em>key management with an external authentication server for “enterprise” mode via the <code class="literal">security/wpa_supplicant</code> package, but we’ll stick to the simpler preshared key setup for our purposes.</em></span></p></div><p>The procedure for setting up an access point with WPA is quite similar to the one we followed for WEP. For a WPA setup with a preshared key (sometimes referred to as a <span class="emphasis"><em>network password</em></span>), you would typically write a <span class="emphasis"><em>hostname.if</em></span> file like this:</p><a id="pro_id00086"/><pre class="programlisting">up media autoselect mediaopt hostap mode 11g chan 1 nwid unwiredbsd wpakey 0x1deadbeef9&#13;
inet6 alias 2001:db8::baad:f00d:1 64</pre><p>If you’re already running the WEP setup described earlier, disable those settings with the following:</p><a id="pro_id00087"/><pre class="programlisting">$ sudo ifconfig ral0 -nwid -nwkey</pre><p>Then, enable the new settings with this command:</p><a id="pro_id00088"/><pre class="programlisting">$ sudo sh /etc/netstart ral0</pre><p><a class="indexterm" id="iddle1173"/><a class="indexterm" id="iddle1273"/><a class="indexterm" id="iddle1329"/><a class="indexterm" id="iddle2064"/><a class="indexterm" id="iddle2073"/>You can check that the access point is up and running with <code class="literal">ifconfig</code>:</p><a id="pro_id00089"/><pre class="programlisting">$ ifconfig ral0&#13;
ral0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 00:25:9c:72:cf:60&#13;
        priority: 4&#13;
        groups: wlan&#13;
        media: IEEE802.11 autoselect mode 11g hostap&#13;
        status: active&#13;
        ieee80211: nwid unwiredbsd chan 1 bssid 00:25:9c:72:cf:60 wpapsk &lt;not displayed&gt;&#13;
wpaprotos wpa1,wpa2 wpaakms psk wpaciphers tkip,ccmp wpagroupcipher tkip 100dBm&#13;
        inet6 fe80::225:9cff:fe72:cf60%ral0 prefixlen 64 scopeid 0x2&#13;
        inet6 2001:db8::baad:f00d:1 prefixlen 64&#13;
        inet 10.50.90.1 netmask 0xff000000 broadcast 10.255.255.255</pre><p>Note the <code class="literal">status: active</code> indication and that the WPA options we didn’t set explicitly are shown with their sensible default values.</p></div><div class="sect2" title="A FreeBSD WPA Access Point"><div class="titlepage"><div><div><h3 class="title" id="freebsd_wpa_access_point">A FreeBSD WPA Access Point</h3></div></div></div><p>Moving from the WEP access point we configured earlier to a somewhat safer WPA setup is straightforward. WPA support on FreeBSD comes in the form of <code class="literal">hostapd</code> (a program that is somewhat similar to OpenBSD’s <code class="literal">hostapd</code> but not identical). We start by editing the <span class="emphasis"><em>/etc/start_if.rum0</em></span> file to remove the authentication information. The edited file should look something like this:</p><a id="pro_id00090"/><pre class="programlisting">wlans_rum0="wlan0"&#13;
create_args_wlan0="wlandev rum0 wlanmode hostap"&#13;
ifconfig_wlan0="inet 10.50.90.1 netmask 255.255.255.0 ssid unwiredbsd mode 11g"&#13;
ifconfig_wlan0_ipv6="2001:db8::baad:f00d:1 prefixlen 64"</pre><p>Next, we add the enable line for <code class="literal">hostapd</code> in <span class="emphasis"><em>/etc/rc.conf</em></span>:</p><a id="pro_id00091"/><pre class="programlisting">hostapd_enable="YES"</pre><p>And finally, <code class="literal">hostapd</code> will need some configuration of its own, in <span class="emphasis"><em>/etc/ hostapd.conf</em></span>:</p><a id="pro_id00092"/><pre class="programlisting">interface=wlan0&#13;
debug=1&#13;
ctrl_interface=/var/run/hostapd&#13;
ctrl_interface_group=wheel&#13;
ssid=unwiredbsd&#13;
wpa=1&#13;
wpa_passphrase=0x1deadbeef9&#13;
wpa_key_mgmt=WPA-PSK&#13;
wpa_pairwise=CCMP TKIP</pre><p>Here, the interface specification is rather self-explanatory, while the <code class="literal">debug</code> value is set to produce minimal messages. The range is <code class="literal">0</code> through <code class="literal">4</code>, where <code class="literal">0</code> is no debug messages at all. You shouldn’t need to change the <code class="literal">ctrl_interface*</code> settings unless you’re developing <code class="literal">hostapd</code>. The first of the next five lines <a class="indexterm" id="iddle1220"/><a class="indexterm" id="iddle1277"/><a class="indexterm" id="iddle1635"/><a class="indexterm" id="iddle1797"/><a class="indexterm" id="iddle2059"/>sets the network identifier. The subsequent lines enable WPA and set the passphrase. The final two lines specify accepted key-management algorithms and encryption schemes. (For the finer details and updates, see the <code class="literal">hostapd(8)</code> and <code class="literal">hostapd.conf(5)</code> man pages.)</p><p>After a successful configuration (running <code class="literal">sudo /etc/rc.d/hostapd force-start</code> comes to mind), <code class="literal">ifconfig</code> should produce output about the two interfaces similar to this:</p><a id="pro_id00093"/><pre class="programlisting">rum0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 2290&#13;
        ether 00:24:1d:9a:bf:67&#13;
        media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;&#13;
        status: running&#13;
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500&#13;
        ether 00:24:1d:9a:bf:67&#13;
        inet 10.50.90.1 netmask 0xffffff00 broadcast 10.50.90.255&#13;
        inet6 2001:db8::baad:f00d:1 prefixlen 64&#13;
        media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;&#13;
        status: running&#13;
        ssid unwiredbsd channel 6 (2437 Mhz 11g) bssid 00:24:1d:9a:bf:67&#13;
        country US authmode WPA privacy MIXED deftxkey 2 TKIP 2:128-bit&#13;
        txpower 0 scanvalid 60 protmode CTS dtimperiod 1 -dfs</pre><p>The line <code class="literal">status: running</code> means that you’re up and running, at least on the link level.</p></div><div class="sect2" title="The Access Point’s PF Rule Set"><div class="titlepage"><div><div><h3 class="title" id="access_pointapostrophes_pf_rule_set">The Access Point’s PF Rule Set</h3></div></div></div><p>With the interfaces configured, it’s time to start configuring the access point as a packet-filtering gateway. You can start by copying the basic gateway setup from <a class="xref" href="ch03.html" title="Chapter 3. Into the Real World">Chapter 3</a>. Enable gatewaying via the appropriate entries in the access point’s <span class="emphasis"><em>sysctl.conf</em></span> or <span class="emphasis"><em>rc.conf</em></span> file and then copy across the <span class="emphasis"><em>pf.conf</em></span> file. Depending on the parts of the previous chapter that were most useful to you, the <span class="emphasis"><em>pf.conf</em></span> file may look something like this:</p><a id="pro_id00094"/><pre class="programlisting">ext_if = "re0" # macro for external interface - use tun0 or pppoe0 for PPPoE&#13;
int_if = "re1" # macro for internal interface&#13;
localnet = $int_if:network&#13;
# nat_address = 203.0.113.5 # Set addess for nat-to&#13;
client_out = "{ ssh, domain, pop3, auth, nntp, http,\&#13;
                https, cvspserver, 2628, 5999, 8000, 8080 }"&#13;
udp_services = "{ domain, ntp }"&#13;
icmp_types = "{ echoreq, unreach }"&#13;
# if IPv6, some ICMP6 accommodation is needed&#13;
icmp6_types = "{ echoreq unreach timex paramprob }"&#13;
# If ext_if IPv4 address is dynamic, ($ext_if) otherwise nat to specific address, ie&#13;
# match out on $ext_if inet from $localnet nat-to $nat_address&#13;
match out on $ext_if inet from $localnet nat-to ($ext_if)&#13;
block all&#13;
pass quick inet proto { tcp, udp } from $localnet to port $udp_services&#13;
pass log inet proto icmp icmp-type $icmp_types&#13;
pass inet6 proto icmp6 icmp6-type $icmp6_types&#13;
pass inet proto tcp from $localnet port $client_out</pre><p><a class="indexterm" id="iddle1184"/><a class="indexterm" id="iddle1388"/><a class="indexterm" id="iddle1399"/><a class="indexterm" id="iddle1413"/><a class="indexterm" id="iddle1500"/><a class="indexterm" id="iddle1518"/><a class="indexterm" id="iddle1522"/><a class="indexterm" id="iddle1554"/><a class="indexterm" id="iddle1777"/><a class="indexterm" id="iddle2060"/>If you’re running a PF version equal to OpenBSD 4.6 or earlier, the <code class="literal">match</code> rule with <code class="literal">nat-to</code> instead becomes this (assuming the external interface has one address, dynamically assigned):</p><a id="pro_id00095"/><pre class="programlisting">nat on $ext_if from $localnet to any -&gt; ($ext_if)</pre><p>The only difference that’s strictly necessary for your access point to work is the definition of <code class="literal">int_if</code>. You must change the definition of <code class="literal">int_if</code> to match the wireless interface. In our example, this means the line should now read as follows:</p><a id="pro_id00096"/><pre class="programlisting">int_if = "ral0" # macro for internal interface</pre><p>More than likely, you’ll also want to set up <code class="literal">dhcpd</code> to serve addresses and other relevant network information to IPv4 clients after they’ve associated with your access point. For IPv6 networks, you probably want to set up <code class="literal">rtadvd</code> (or even a DHCP6 daemon) to aid your IPv6 clients in their autoconfiguration. Setting up <code class="literal">dhcpd</code> and <code class="literal">rtadvd</code> is fairly straightforward if you read the man pages.</p><p>That’s all there is to it. This configuration gives you a functional BSD access point, with at least token security (actually more like a <span class="emphasis"><em>Keep Out!</em></span> sign) via WEP encryption or a slightly more robust link-level encryption with WPA. If you need to support FTP, copy the <code class="literal">ftp-proxy</code> configuration from the machine you set up in <a class="xref" href="ch03.html" title="Chapter 3. Into the Real World">Chapter 3</a> and make changes similar to those you made for the rest of the rule set.</p></div><div class="sect2" title="Access Points with Three or More Interfaces"><div class="titlepage"><div><div><h3 class="title" id="access_points_with_three_or_more_interfa">Access Points with Three or More Interfaces</h3></div></div></div><p>If your network design dictates that your access point is also the gateway for a wired local network, or even several wireless networks, you need to make some minor changes to your rule set. Instead of just changing the value of the <code class="literal">int_if</code> macro, you might want to add another (descriptive) definition for the wireless interface, such as the following:</p><a id="pro_id00097"/><pre class="programlisting">air_if = "ral0"</pre><p>Your wireless interfaces are likely to be on separate subnets, so it might be useful to have a separate rule for each of them to handle any IPv4 NAT configuration. Here’s an example for OpenBSD 4.7 and newer systems:</p><a id="pro_id00098"/><pre class="programlisting">match out on $ext_if from $air_if:network nat-to ($ext_if)</pre><p>And here’s one on pre–OpenBSD 4.7 PF versions:</p><a id="pro_id00099"/><pre class="programlisting">nat on $ext_if from $air_if:network to any -&gt; ($ext_if) static-port</pre><p><a class="indexterm" id="iddle1129"/><a class="indexterm" id="iddle1382"/><a class="indexterm" id="iddle1383"/><a class="indexterm" id="iddle1385"/><a class="indexterm" id="iddle1891"/><a class="indexterm" id="iddle2009"/><a class="indexterm" id="iddle2024"/><a class="indexterm" id="iddle2030"/><a class="indexterm" id="iddle2061"/><a class="indexterm" id="iddle2068"/>Depending on your policy, you might also want to adjust your <code class="literal">localnet</code> definition, or at least include <code class="literal">$air_if</code> in your <code class="literal">pass</code> rules where appropriate. And once again, if you need to support FTP, a separate pass with divert or redirection for the wireless network to <code class="literal">ftp-proxy</code> may be in order.</p></div><div class="sect2" title="Handling IPSec, VPN Solutions"><div class="titlepage"><div><div><h3 class="title" id="handling_ipseccomma_vpn_solutions">Handling IPSec, VPN Solutions</h3></div></div></div><p>You can set up <span class="emphasis"><em>virtual private networks (VPNs)</em></span> using built-in IPsec tools, OpenSSH, or other tools. However, due to the perceived poor security profile of wireless networks in general or for other reasons, you’re likely to want to set up some additional security.</p><p>The options fall roughly into three categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p title="SSH"><span class="title"><strong><span class="strong"><strong>SSH</strong></span></strong></span>. If your VPN is based on SSH tunnels, the baseline rule set already contains all the filtering you need. Your tunneled traffic will be indistinguishable from other SSH traffic to the packet filter.</p></li><li class="listitem" style="list-style-type: none"><p title="IPsec with UDP key exchange (IKE/ISAKMP)"><span class="title"><strong><span class="strong"><strong>IPsec with UDP key exchange (IKE/ISAKMP)</strong></span></strong></span>. Several IPsec variants depend critically on key exchange via <code class="literal">proto udp port 500</code> and use <code class="literal">proto udp port 4500</code> for <span class="emphasis"><em>NAT Traversal (NAT-T)</em></span>. You need to let this traffic through in order to let the flows become established. Almost all implementations also depend critically on letting ESP protocol traffic (protocol number 50) pass between the hosts with the following:</p><a id="pro_id00100"/><pre class="programlisting">pass proto esp from $source to $target</pre></li><li class="listitem" style="list-style-type: none"><p title="Filtering on IPsec encapsulation interfaces"><span class="title"><strong><span class="strong"><strong>Filtering on IPsec encapsulation interfaces</strong></span></strong></span>. With a properly configured IPsec setup, you can set up PF to filter on the encapsulation interface <code class="literal">enc0</code> itself with the following:<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch04fn04" id="ch04fn04">23</a>]</sup></p><a id="pro_id00101"/><pre class="programlisting">pass on enc0 proto ipencap from $source to $target keep state (if-bound)</pre></li></ul></div><p>See <a class="xref" href="apa.html" title="Appendix A. Resources">Appendix A</a> for references to some of the more useful literature on the subject.</p></div><div class="sect2" title="The Client Side"><div class="titlepage"><div><div><h3 class="title" id="client_side">The Client Side</h3></div></div></div><p>As long as you have BSD clients, setup is extremely easy. The steps involved in connecting a BSD machine to a wireless network are quite similar to the ones we just went through to set up a wireless access point. On OpenBSD, the configuration centers on the <span class="emphasis"><em>hostname.if</em></span> file for the wireless interface. On FreeBSD, the configuration centers on <span class="emphasis"><em>rc.conf</em></span> but will most likely involve a few other files, depending on your exact configuration.</p></div><div class="sect2" title="OpenBSD Setup"><div class="titlepage"><div><div><h3 class="title" id="openbsd_setup">OpenBSD Setup</h3></div></div></div><p><a class="indexterm" id="iddle1182"/><a class="indexterm" id="iddle1370"/><a class="indexterm" id="iddle1414"/><a class="indexterm" id="iddle1562"/><a class="indexterm" id="iddle1564"/><a class="indexterm" id="iddle1576"/><a class="indexterm" id="iddle1778"/><a class="indexterm" id="iddle1971"/><a class="indexterm" id="iddle2014"/><a class="indexterm" id="iddle2066"/><a class="indexterm" id="iddle2075"/>Starting with the OpenBSD case, in order to connect to the WEP access point we just configured, your OpenBSD clients need a <span class="emphasis"><em>hostname.if</em></span> (for example, <span class="emphasis"><em>/etc/hostname.ral0</em></span>) configuration file with these lines:</p><a id="pro_id00102"/><pre class="programlisting">up media autoselect mode 11g chan 1 nwid unwiredbsd nwkey 0x1deadbeef9&#13;
dhcp&#13;
rtsol</pre><p>The first line sets the link-level parameters in more detail than usually required. Only <code class="literal">up</code> and the <code class="literal">nwid</code> and <code class="literal">nwkey</code> parameters are strictly necessary. In almost all cases, the driver will associate with the access point on the appropriate channel and in the best available mode. The second line calls for a DHCP configuration and, in practice, causes the system to run a <code class="literal">dhclient</code> command to retrieve TCP/IP configuration information. The final line invokes <code class="literal">rtsol(8)</code> to initiate IPv6 configuration.</p><p>If you choose to go with the WPA configuration, the file will look like this instead:</p><a id="pro_id00103"/><pre class="programlisting">up media autoselect mode 11g chan 1 nwid unwiredbsd wpakey 0x1deadbeef9&#13;
dhcp&#13;
rtsol</pre><p>Again, the first line sets the link-level parameters, where the crucial ones are the network selection and encryption parameters <code class="literal">nwid</code> and <code class="literal">wpakey</code>. You can try omitting the <code class="literal">mode</code> and <code class="literal">chan</code> parameters; in almost all cases, the driver will associate with the access point on the appropriate channel and in the best available mode.</p><p>If you want to try out the configuration commands from the command line before committing the configuration to your <span class="emphasis"><em>/etc/hostname.if</em></span> file, the command to set up a client for the WEP network is as follows:</p><a id="pro_id00104"/><pre class="programlisting">$ sudo ifconfig ral0 up mode 11g chan 1 nwid unwiredbsd nwkey 0x1deadbeef9</pre><p>The <code class="literal">ifconfig</code> command should complete without any output. You can then use <code class="literal">ifconfig</code> to check that the interface was successfully configured. The output should look something like this:</p><a id="pro_id00105"/><pre class="programlisting">$ ifconfig ral0&#13;
ral0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 00:25:9c:72:cf:60&#13;
        priority: 4&#13;
        groups: wlan&#13;
        media: IEEE802.11 autoselect (OFDM54 mode 11g)&#13;
        status: active&#13;
        ieee80211: nwid unwiredbsd chan 1 bssid 00:25:9c:72:cf:60 nwkey &lt;not displayed&gt; 100dBm&#13;
        inet6 fe80::225:9cff:fe72:cf60%ral0 prefixlen 64 scopeid 0x2</pre><p>Note that the <code class="literal">ieee80211:</code> line displays the network name and channel, along with a few other parameters. The information displayed here should match what you entered on the <code class="literal">ifconfig</code> command line.</p><p>Here is the command to configure your OpenBSD client to connect to the WPA network:</p><a id="pro_id00106"/><pre class="programlisting">$ sudo ifconfig ral0 nwid unwiredbsd wpakey 0x1deadbeef9</pre><p>The command should complete without any output. If you use <code class="literal">ifconfig</code> again to check the interface status, the output will look something like this:</p><a id="pro_id00107"/><pre class="programlisting">$ ifconfig ral0&#13;
ral0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500&#13;
        lladdr 00:25:9c:72:cf:60&#13;
        priority: 4&#13;
        groups: wlan&#13;
        media: IEEE802.11 autoselect (OFDM54 mode 11g)&#13;
        status: active&#13;
        ieee80211: nwid unwiredbsd chan 1 bssid 00:25:9c:72:cf:60 wpapsk &lt;not&#13;
displayed&gt; wpaprotos wpa1,wpa2 wpaakms psk wpaciphers tkip,ccmp wpagroupcipher&#13;
tkip 100dBm&#13;
        inet6 fe80::225:9cff:fe72:cf60%ral0 prefixlen 64 scopeid 0x2</pre><p>Check that the <code class="literal">ieee80211:</code> line displays the correct network name and sensible WPA parameters.</p><p>Once you are satisfied that the interface is configured at the link level, use the <code class="literal">dhclient</code> command to configure the interface for TCP/IP, like this:</p><a id="pro_id00108"/><pre class="programlisting">$ sudo dhclient ral0</pre><p>The <code class="literal">dhclient</code> command should print a summary of its dialogue with the DHCP server that looks something like this:</p><a id="pro_id00109"/><pre class="programlisting">DHCPREQUEST on ral0 to 255.255.255.255 port 67&#13;
DHCPREQUEST on ral0 to 255.255.255.255 port 67&#13;
DHCPACK from 10.50.90.1 (00:25:9c:72:cf:60)&#13;
bound to 10.50.90.11 -- renewal in 1800 seconds.</pre><p>To initialize the interface for IPv6, enter the following:</p><a id="pro_id00110"/><pre class="programlisting">$ <span class="strong"><strong>sudo rtsol ral0</strong></span></pre><p>The <code class="literal">rtsol</code> command normally completes without any messages. Check the interface configuration with <code class="literal">ifconfig</code> to see that the interface did in fact receive an IPv6 configuration.</p></div><div class="sect2" title="FreeBSD Setup"><div class="titlepage"><div><div><h3 class="title" id="freebsd_setup">FreeBSD Setup</h3></div></div></div><p><a class="indexterm" id="iddle1272"/><a class="indexterm" id="iddle1400"/><a class="indexterm" id="iddle1779"/><a class="indexterm" id="iddle2063"/>On FreeBSD, you may need to do a bit more work than is necessary with OpenBSD. Depending on your kernel configuration, you may need to add the relevant module load lines to <span class="emphasis"><em>/boot/loader.conf</em></span>. On one of my test systems, <span class="emphasis"><em>/boot/loader.conf</em></span> looks like this:</p><a id="pro_id00111"/><pre class="programlisting">if_rum_load="YES"&#13;
wlan_scan_ap_load="YES"&#13;
wlan_scan_sta_load="YES"&#13;
wlan_wep_load="YES"&#13;
wlan_ccmp_load="YES"&#13;
wlan_tkip_load="YES"</pre><p>With the relevant modules loaded, you can join the WEP network we configured earlier by issuing the following command:</p><a id="pro_id00112"/><pre class="programlisting">$ sudo ifconfig wlan create wlandev rum0 ssid unwiredbsd wepmode on wepkey 0x1deadbeef9 up</pre><p>Then, issue this command to get an IPv4 configuration for the interface:</p><a id="pro_id00113"/><pre class="programlisting">$ sudo dhclient wlan0</pre><p>To initialize the interface for IPv6, enter the following:</p><a id="pro_id00114"/><pre class="programlisting">$ <span class="strong"><strong>sudo rtsol ral0</strong></span></pre><p>The <code class="literal">rtsol</code> command normally completes without any messages. Check the interface configuration with <code class="literal">ifconfig</code> to see that the interface did in fact receive an IPv6 configuration.</p><p>For a more permanent configuration, create a <span class="emphasis"><em>start_if.rum0</em></span> file (replace <span class="emphasis"><em>rum0</em></span> with the name of the physical interface if it differs) with content like this:</p><a id="pro_id00115"/><pre class="programlisting">wlans_rum0="wlan0"&#13;
create_args_wlan0="wlandev rum0 ssid unwiredbsd wepmode on wepkey 0x1deadbeef9 up"&#13;
ifconfig_wlan0="DHCP"&#13;
ifconfig_wlan0_ipv6="inet6 accept_rtadv"</pre><p>If you want to join the WPA network, you need to set up <code class="literal">wpa_supplicant</code> and change your network interface settings slightly. For the WPA access point, connect with the following configuration in your <span class="emphasis"><em>start_if.rum0</em></span> file:</p><a id="pro_id00116"/><pre class="programlisting">wlans_rum0="wlan0"&#13;
create_args_wlan0="wlandev rum0"&#13;
ifconfig_wlan0="WPA"</pre><p><a class="indexterm" id="iddle1061"/><a class="indexterm" id="iddle1183"/><a class="indexterm" id="iddle1358"/><a class="indexterm" id="iddle2039"/><a class="indexterm" id="iddle2048"/><a class="indexterm" id="iddle2051"/><a class="indexterm" id="iddle2072"/>You also need an <span class="emphasis"><em>/etc/wpa_supplicant.conf</em></span> file that contains the following:</p><a id="pro_id00117"/><pre class="programlisting">network={&#13;
  ssid="unwiredbsd"&#13;
  psk="0x1deadbeef9"&#13;
}</pre><p>Finally, add a second <code class="literal">ifconfig_wlan0</code> line in <span class="emphasis"><em>rc.conf</em></span> to ensure that <code class="literal">dhclient</code> runs correctly.</p><a id="pro_id00118"/><pre class="programlisting">ifconfig_wlan0="DHCP"</pre><p>For the IPv6 configuration, add the following line to <span class="emphasis"><em>rc.conf</em></span>:</p><a id="pro_id00119"/><pre class="programlisting">ifconfig_wlan0_ipv6="inet6 accept_rtadv"</pre><p>Other WPA networks may require additional options. After a successful configuration, the <code class="literal">ifconfig</code> output should display something like this:</p><a id="pro_id00120"/><pre class="programlisting">rum0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 2290&#13;
        ether 00:24:1d:9a:bf:67&#13;
        media: IEEE 802.11 Wireless Ethernet autoselect mode 11g&#13;
        status: associated&#13;
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500&#13;
        ether 00:24:1d:9a:bf:67&#13;
        inet 10.50.90.16 netmask 0xffffff00 broadcast 10.50.90.255&#13;
        inet6 2001:db8::baad:f00d:1635 prefixlen 64&#13;
        media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g&#13;
        status: associated&#13;
        ssid unwiredbsd channel 1 (2412 Mhz 11g) bssid 00:25:9c:72:cf:60&#13;
        country US authmode WPA2/802.11i privacy ON deftxkey UNDEF&#13;
        TKIP 2:128-bit txpower 0 bmiss 7 scanvalid 450 bgscan bgscanintvl 300&#13;
        bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS roaming MANUAL</pre></div><div class="sect2" title="Guarding Your Wireless Network with authpf"><div class="titlepage"><div><div><h3 class="title" id="guarding_your_wireless_network_with_auth">Guarding Your Wireless Network with authpf</h3></div></div></div><p>Security professionals tend to agree that even though WEP encryption offers little protection, it’s just barely enough to signal to would-be attackers that you don’t intend to let all and sundry use your network resources. Using WPA increases security significantly, at the cost of some complexity in contexts that require the “enterprise”-grade options.</p><p>The configurations we’ve built so far in this chapter are functional. Both the WEP and WPA configurations will let all reasonably configured wireless clients connect, and that may be a problem in itself because that configuration doesn’t have any real support built in for letting you decide who uses your network.</p><p><a class="indexterm" id="iddle1062"/><a class="indexterm" id="iddle1063"/><a class="indexterm" id="iddle1469"/><a class="indexterm" id="iddle1882"/><a class="indexterm" id="iddle2052"/>As mentioned earlier, MAC address filtering is not really a solid defense against attackers because changing a MAC address is just too easy. The Open-BSD developers chose a radically different approach to this problem when they introduced <code class="literal">authpf</code> in OpenBSD version 3.1. Instead of tying access to a hardware identifier, such as the network card’s MAC address, they decided that the robust and highly flexible user authentication mechanisms already in place were more appropriate for the task. The user shell <code class="literal">authpf</code> lets the system load PF rules on a per-user basis, effectively deciding which user gets to do what.</p><p>To use <code class="literal">authpf</code>, you create users with the <code class="literal">authpf</code> program as their shell. In order to get network access, the user logs in to the gateway using SSH. Once the user successfully completes SSH authentication, <code class="literal">authpf</code> loads the rules you have defined for the user or the relevant class of users.</p><p>These rules, which usually are written to apply only to the IP address the user logged in from, stay loaded and in force for as long as the user stays logged in via the SSH connection. Once the SSH session is terminated, the rules are unloaded, and in most scenarios, all non-SSH traffic from the user’s IP address is denied. With a reasonable setup, only traffic originated by authenticated users will be let through.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note06"/>Note</h3><p><span class="emphasis"><em>On OpenBSD, <code class="literal">authpf</code> is one of the login classes offered by default, as you’ll notice the next time you create a user with <code class="literal">adduser</code>.</em></span></p></div><p>For systems where the <code class="literal">authpf</code> login class isn’t available by default, you may need to add the following lines to your <span class="emphasis"><em>/etc/login.conf</em></span> file:</p><a id="pro_id00121"/><pre class="programlisting">authpf:\&#13;
       :welcome=/etc/motd.authpf:\&#13;
       :shell=/usr/sbin/authpf:\&#13;
       :tc=default:</pre><p>The next couple of sections contain a few examples that may or may not fit your situation directly but that I hope will give you ideas you can use.</p></div><div class="sect2" title="A Basic Authenticating Gateway"><div class="titlepage"><div><div><h3 class="title" id="basic_authenticating_gateway">A Basic Authenticating Gateway</h3></div></div></div><p>Setting up an authenticating gateway with <code class="literal">authpf</code> involves creating and maintaining a few files besides your basic <span class="emphasis"><em>pf.conf</em></span>. The main addition is <span class="emphasis"><em>authpf.rules</em></span>. The other files are fairly static entities that you won’t be spending much time on once they’ve been created.</p><p>Start by creating an empty <span class="emphasis"><em>/etc/authpf/authpf.conf</em></span> file. This file needs to be there in order for <code class="literal">authpf</code> to work, but it doesn’t actually need any content, so creating an empty file with touch is appropriate.</p><p>The other relevant bits of <span class="emphasis"><em>/etc/pf.conf</em></span> follow. First, here are the interface macros:</p><a id="pro_id00122"/><pre class="programlisting">ext_if = "re0"&#13;
int_if = "athn0"</pre><p><a class="indexterm" id="iddle1046"/><a class="indexterm" id="iddle1082"/><a class="indexterm" id="iddle1519"/><a class="indexterm" id="iddle1555"/><a class="indexterm" id="iddle2007"/>In addition, if you define a table called <code class="literal">&lt;authpf_users&gt;</code>, <code class="literal">authpf</code> will add the IP addresses of authenticated users to the table:</p><a id="pro_id00123"/><pre class="programlisting">table &lt;authpf_users&gt; persist</pre><p>If you need to run NAT, the rules that take care of the translation could just as easily go in <span class="emphasis"><em>authpf.rules</em></span>, but keeping them in the <span class="emphasis"><em>pf.conf</em></span> file doesn’t hurt in a simple setup like this:</p><a id="pro_id00124"/><pre class="programlisting">pass out on $ext_if inet from $localnet nat-to ($ext_if)</pre><p>Here’s pre–OpenBSD 4.7 syntax:</p><a id="pro_id00125"/><pre class="programlisting">nat on $ext_if inet from $localnet to any -&gt; ($ext_if)</pre><p>Next, we create the <code class="literal">authpf</code> anchor, where rules from <span class="emphasis"><em>authpf.rules</em></span> are loaded once the user authenticates:</p><a id="pro_id00126"/><pre class="programlisting">anchor "authpf/*"</pre><p>For pre–OpenBSD 4.7 <code class="literal">authpf</code> versions, several anchors were required, so the corresponding section would be as follows:</p><a id="pro_id00127"/><pre class="programlisting">nat-anchor "authpf/*"&#13;
rdr-anchor "authpf/*"&#13;
binat-anchor "authpf/*"&#13;
anchor "authpf/*"</pre><p>This brings us to the end of the required parts of a <span class="emphasis"><em>pf.conf</em></span> file for an <code class="literal">authpf</code> setup.</p><p>For the filtering part, we start with the block all default and then add the <code class="literal">pass</code> rules we need. The only essential item at this point is to let SSH traffic pass on the internal network:</p><a id="pro_id00128"/><pre class="programlisting">pass quick on $int_if proto { tcp, udp } to $int_if port ssh</pre><p>From here on out, it really is up to you. Do you want to let your clients have name resolution before they authenticate? If so, put the <code class="literal">pass</code> rules for the TCP and UDP service domain in your <span class="emphasis"><em>pf.conf</em></span> file, too.</p><p>For a relatively simple and egalitarian setup, you could include the rest of our baseline rule set, changing the <code class="literal">pass</code> rules to allow traffic from the addresses in the <code class="literal">&lt;authpf_users&gt;</code> table, rather than any address in your local network:</p><a id="pro_id00129"/><pre class="programlisting">pass quick proto { tcp, udp } from &lt;authpf_users&gt; to port $udp_services&#13;
pass proto tcp from &lt;authpf_users&gt; to port $client_out</pre><p><a class="indexterm" id="iddle1064"/><a class="indexterm" id="iddle1225"/><a class="indexterm" id="iddle1751"/><a class="indexterm" id="iddle1972"/><a class="indexterm" id="iddle2016"/><a class="indexterm" id="iddle2053"/>For a more differentiated setup, you could put the rest of your rule set in <span class="emphasis"><em>/etc/authpf/authpf.rules</em></span> or per-user rules in customized <span class="emphasis"><em>authpf.rules</em></span> files in each user’s directory under <span class="emphasis"><em>/etc/authpf/users/</em></span>. If your users generally need some protection, your general <span class="emphasis"><em>/etc/authpf/authpf.rules</em></span> could have content like this:</p><a id="pro_id00130"/><pre class="programlisting">client_out = "{ ssh, domain, pop3, auth, nntp, http, https }"&#13;
udp_services = "{ domain, ntp }"&#13;
pass quick proto { tcp, udp } from $user_ip to port $udp_services&#13;
pass proto tcp from $user_ip to port $client_out</pre><p>The macro <code class="literal">user_ip</code> is built into <code class="literal">authpf</code> and expands to the IP address from which the user authenticated. These rules will apply to any user who completes authentication at your gateway.</p><p>A nice and relatively easy addition to implement is special-case rules for users with different requirements than your general user population. If an <span class="emphasis"><em>authpf.rules</em></span> file exists in the user’s directory under <span class="emphasis"><em>/etc/authpf/users/</em></span>, the rules in that file will be loaded for the user. This means that your naive user Peter who only needs to surf the Web and have access to a service that runs on a high port on a specific machine could get what he needs with a <span class="emphasis"><em>/etc/ authpf/users/peter/authpf.rules</em></span> file like this:</p><a id="pro_id00131"/><pre class="programlisting">client_out = "{ domain, http, https }"&#13;
pass inet from $user_ip to 192.168.103.84 port 9000&#13;
pass quick inet proto { tcp, udp } from $user_ip to port $client_out</pre><p>On the other hand, Peter’s colleague Christina runs OpenBSD and generally knows what she’s doing, even if she sometimes generates traffic to and from odd ports. You could give her free rein by putting this in <span class="emphasis"><em>/etc/authpf/users/christina/authpf.rules</em></span>:</p><a id="pro_id00132"/><pre class="programlisting">pass from $user_ip os = "OpenBSD" to any</pre><p>This means Christina can do pretty much anything she likes over TCP/IP as long as she authenticates from her OpenBSD machines.</p></div><div class="sect2" title="Wide Open but Actually Shut"><div class="titlepage"><div><div><h3 class="title" id="wide_open_but_actually_shut">Wide Open but Actually Shut</h3></div></div></div><p>In some settings, it makes sense to set up your network to be open and unencrypted at the link level, while enforcing some restrictions via <code class="literal">authpf</code>. The next example is very similar to Wi-Fi zones you may encounter in airports or other public spaces, where anyone can associate to the access points and get an IP address, but any attempt at accessing the Web will be redirected to one specific Web page until the user has cleared some sort of authentication.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch04fn05" id="ch04fn05">24</a>]</sup></p><p><a class="indexterm" id="iddle1047"/>This <span class="emphasis"><em>pf.conf</em></span> file is again built on our baseline, with two important additions to the basic <code class="literal">authpf</code> setup—a macro and a redirection:</p><a id="pro_id00133"/><pre class="programlisting">ext_if = "re0"&#13;
int_if = "ath0"&#13;
auth_web="192.168.27.20"&#13;
dhcp_services = "{ bootps, bootpc }" # DHCP server + client&#13;
table &lt;authpf_users&gt; persist&#13;
pass in quick on $int_if proto tcp from ! &lt;authpf_users&gt; to port http rdr-to $auth_web&#13;
match out on $ext_if from $int_if:network nat-to ($ext_if)&#13;
anchor "authpf/*"&#13;
block all&#13;
pass quick on $int_if inet proto { tcp, udp } to $int_if port $dhcp_services&#13;
pass quick inet proto { tcp, udp } from $int_if:network to any port domain&#13;
pass quick on $int_if inet proto { tcp, udp } to $int_if port ssh&#13;
For older authpf versions, use this file instead:&#13;
ext_if = "re0"&#13;
int_if = "ath0"&#13;
auth_web="192.168.27.20"&#13;
dhcp_services = "{ bootps, bootpc }" # DHCP server + client&#13;
table &lt;authpf_users&gt; persist&#13;
rdr pass on $int_if proto tcp from ! &lt;authpf_users&gt; to any port http -&gt; $auth_web&#13;
nat on $ext_if from $localnet to any -&gt; ($ext_if)&#13;
nat-anchor "authpf/*"&#13;
rdr-anchor "authpf/*"&#13;
binat-anchor "authpf/*"&#13;
anchor "authpf/*"&#13;
block all&#13;
pass quick on $int_if inet proto { tcp, udp } to $int_if port $dhcp_services&#13;
pass quick inet proto { tcp, udp } from $int_if:network to port domain&#13;
pass quick on $int_if inet proto { tcp, udp } to $int_if port ssh</pre><p>The <code class="literal">auth_web</code> macro and the redirection make sure all Web traffic from addresses that are not in the <code class="literal">&lt;authpf_users&gt;</code> table leads all nonauthenticated users to a specific address. At that address, you set up a Web server that serves up whatever you need. This could range from a single page with instructions on whom to contact in order to get access to the network all the way up to a system that accepts credit cards and handles user creation.</p><p>Note that in this setup, name resolution will work, but all surfing attempts will end up at the <code class="literal">auth_web</code> address. Once the users clear authentication, you can add general rules or user-specific ones to the <span class="emphasis"><em>authpf.rules</em></span> files as appropriate for your situation.</p></div></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.ch04fn01"><p><sup>[<a class="para" href="#ch04fn01">20</a>] </sup>On some systems, the older, device-specific programs, such as <code class="literal">wicontrol</code> and <code class="literal">ancontrol,</code> are still around, but for the most part, they are deprecated and have long been replaced with <code class="literal">ifconfig</code> functionality. On OpenBSD, the consolidation into <code class="literal">ifconfig</code> has been completed.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch04fn02"><p><sup>[<a class="para" href="#ch04fn02">21</a>] </sup>A quick man page lookup on OpenBSD will tell you that the command to change the MAC address for the interface <code class="literal">rum0</code> is simply <code class="literal">ifconfig rum0 lladdr 00:ba:ad:f0:0d:11</code>.</p></div><div class="footnote" id="ftn.ch04fn03"><p><sup>[<a class="para" href="#ch04fn03">22</a>] </sup>In addition, it’s possible to look up man pages on the Web. Check <span class="emphasis"><em><a class="ulink" href="http://www.openbsd.org/" target="_top">http://www.openbsd.org/</a></em></span> and the other project websites. They offer keyword-based man page searching.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch04fn04"><p><sup>[<a class="para" href="#ch04fn04">23</a>] </sup>In OpenBSD 4.8, the encapsulation interface became a cloneable interface, and you can configure several separate <code class="literal">enc</code> interfaces. All <code class="literal">enc</code> interfaces become members of the <code class="literal">enc</code> interface group.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch04fn05"><p><sup>[<a class="para" href="#ch04fn05">24</a>] </sup>Thanks to Vegard Engen for the idea and for showing me his configuration, which is preserved here in spirit, if not in all its details.</p></div></div></section></body></html>