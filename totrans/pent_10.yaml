- en: Chapter 7. Capturing Traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we move on to exploitation, we’ll use the Wireshark monitoring tool,
    as well as other tools, to sniff and manipulate traffic to gain useful information
    from other machines on the local network. On an internal penetration test, when
    we’re simulating an insider threat or an attacker who has breached the perimeter,
    capturing traffic from other systems in the network can give us additional interesting
    information (perhaps even usernames and passwords) that can help us with exploitation.
    The trouble is that capturing traffic can produce a massive amount of potentially
    useful data. Capturing all traffic on just your home network could quickly fill
    several Wireshark screens, and discovering which traffic is useful for a pentest
    can be difficult. In this chapter, we’ll look at several ways to manipulate a
    network to get access to traffic we have no business being able to see.
  prefs: []
  type: TYPE_NORMAL
- en: Networking for Capturing Traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you find yourself in a network that uses hubs rather than switches, capturing
    traffic not intended for your machine will be easy, because when a network hub
    receives a packet, it rebroadcasts it on all ports, leaving it up to each device
    to decide whom the packet belongs to. In a hubbed network, capturing other systems’
    traffic is as easy as selecting Use promiscuous mode on all interfaces in Wireshark.
    This tells our Network Interface Controller (NIC) to grab everything it sees,
    which in a hubbed network will be every packet.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike hubs, switches send traffic only to the intended system, so on a switched
    network, we won’t be able to view, for example, all the traffic to and from the
    domain controller without fooling the network into sending us that traffic. Most
    networks you encounter on pentests will probably be switched networks; even some
    legacy network hardware that claims to be a hub may have the functionality of
    a switch.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual networks seem to act like hubs, because all your virtual machines share
    one physical device. If you capture traffic in promiscuous mode in a virtual network,
    you may be able to see traffic from every virtual machine as well as the host
    machine, even if you are using a switch instead of a hub in your environment.
    To simulate a non-virtualized network, we’ll turn off Use promiscuous mode on
    all interfaces in Wireshark, which means we will have to work a little harder
    to capture traffic from our target virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: Using Wireshark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wireshark is a graphical network protocol analyzer that lets us take a deep
    dive into the individual packets moving around the network. Wireshark can be used
    to capture Ethernet, wireless, Bluetooth, and many other kinds of traffic. It
    can decode different protocols that it sees, so you could, for instance, reconstruct
    the audio of Voice over IP (VoIP) phone calls. Let’s take a look at the basics
    of using Wireshark to capture and analyze traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing Traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by using Wireshark to capture traffic on our local network. Start
    Wireshark in Kali, as shown here. Click through any warnings about using Wireshark
    as root being dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tell Wireshark to capture on the local network interface (eth0) by selecting
    **Capture** ▸ **Options**, and selecting the **eth0** option, as shown in [Figure 7-1](ch07.xhtml#starting_a_wireshark_capture
    "Figure 7-1. Starting a Wireshark capture"). Remember to uncheck the Use promiscuous
    mode on all interfaces option so that the results will be like those on a physical
    switched network rather than the VMware network. Exit the Options menu. Finally,
    click **Capture** ▸ **Start** to begin the traffic capture.
  prefs: []
  type: TYPE_NORMAL
- en: You should start to see traffic coming in, and you should be able to capture
    all traffic intended for the Kali machine as well as any broadcast traffic (traffic
    sent to the entire network).
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting a Wireshark capture](httpatomoreillycomsourcenostarchimages2030356.png.jpg)Figure 7-1. Starting
    a Wireshark capture'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the traffic we can capture in a switched network, let’s start
    by contacting our Windows XP target from our Kali machine over FTP. Log in as
    *anonymous*, as shown in [Example 7-1](ch07.xhtml#logging_in_via_ftp "Example 7-1. Logging
    in via FTP"), to see the captured traffic in Wireshark. (In the previous chapter,
    we discovered that the *anonymous* user is allowed on the Windows XP target. Although
    *anonymous* requires that you enter a password, it doesn’t matter what it is.
    Traditionally, it is an email address, but the FTP server will accept whatever
    you would like to use.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1. Logging in via FTP
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You should see packets in Wireshark from the system with IP address 192.168.20.9
    to 192.168.20.10 and vice versa, with the Protocol field marked as FTP. Wireshark
    is capturing the traffic moving to and from our Kali machine.
  prefs: []
  type: TYPE_NORMAL
- en: Switch over to your Ubuntu Linux target machine, and log in to the FTP server
    on the Windows XP target. Looking back at Wireshark in Kali, you should see that
    no additional FTP packets have been captured. In our simulated switched network,
    any traffic not destined for our Kali machine will not be seen by the network
    interface and, thus, will not be captured by Wireshark. (We’ll learn how to rectify
    this situation and capture other systems’ traffic in [ARP Cache Poisoning](ch07.xhtml#arp_cache_poisoning
    "ARP Cache Poisoning").)
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sheer volume of network traffic captured by Wireshark can be a bit overwhelming
    because, in addition to our FTP traffic, every other packet to or from the Kali
    system is captured. To find specific interesting packets, we can use Wireshark
    filters. The Filter field is located at the top left of the Wireshark GUI. As
    a very simple first Wireshark filtering example, let’s look for all traffic that
    uses the FTP protocol. Enter **`ftp`** in the Filter field and click **Apply**,
    as shown in [Figure 7-2](ch07.xhtml#filtering_traffic_in_wireshark "Figure 7-2. Filtering
    traffic in Wireshark").
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering traffic in Wireshark](httpatomoreillycomsourcenostarchimages2030358.png.jpg)Figure 7-2. Filtering
    traffic in Wireshark'
  prefs: []
  type: TYPE_NORMAL
- en: As expected, Wireshark filters the captured packets to show only those that
    use the FTP protocol. We can see our entire FTP conversation, including our login
    information, in plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: We can use more advanced filters to further fine-tune the packets returned.
    For example, we can use the filter *ip.dst==192.168.20.10* to return only packets
    with the destination IP address 192.168.20.10\. We can even chain filters together,
    such as using the filter *ip.dst==192.168.20.10 and ftp* to find only FTP traffic
    destined for 192.168.20.10.
  prefs: []
  type: TYPE_NORMAL
- en: Following a TCP Stream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even after filtering traffic, there may be multiple FTP connections captured
    during the same time frame, so it could still be difficult to tell what’s going
    on. But once we find an interesting packet, such as the beginning of an FTP login,
    we can dig deeper into the conversation by right-clicking the packet and selecting
    **Follow TCP Stream**, as shown in [Figure 7-3](ch07.xhtml#following_the_tcp_stream_in_wireshark
    "Figure 7-3. Following the TCP stream in Wireshark").
  prefs: []
  type: TYPE_NORMAL
- en: '![Following the TCP stream in Wireshark](httpatomoreillycomsourcenostarchimages2030360.png.jpg)Figure 7-3. Following
    the TCP stream in Wireshark'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting screen will show us the full contents of our FTP connection, including
    its credentials in plaintext, as shown in [Example 7-2](ch07.xhtml#ftp_login_conversation
    "Example 7-2. FTP login conversation").
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2. FTP login conversation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Dissecting Packets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By selecting a specific captured packet, we can get more information about the
    captured data, as shown in [Figure 7-4](ch07.xhtml#packet_details_in_wireshark
    "Figure 7-4. Packet details in Wireshark"). At the bottom of the Wireshark screen,
    you can see details of the selected packet. With a little guidance, Wireshark
    will break down the data for you. For example, we can easily find the TCP destination
    port by selecting the TCP entry and looking for Destination port, as highlighted
    in the figure. When we select this field, the entry in the raw bytes of the packet
    is highlighted as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Packet details in Wireshark](httpatomoreillycomsourcenostarchimages2030362.png)Figure 7-4. Packet
    details in Wireshark'
  prefs: []
  type: TYPE_NORMAL
- en: ARP Cache Poisoning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is nice to see the details of our own traffic, for pentesting purposes,
    it would be preferable to see the traffic that wasn’t intended for our Kali system.
    Perhaps we’ll be able to capture another user’s login session that uses an account
    other than *anonymous* to log in; that would give us working credentials for the
    FTP server, as well as a set of credentials that might be reused elsewhere in
    the environment.
  prefs: []
  type: TYPE_NORMAL
- en: To capture traffic not intended for the Kali system, we need to find some way
    to have the relevant data sent to our Kali system. Because the network switch
    will send only packets that belong to us, we need to trick our target machine
    or the switch (or ideally both) into believing the traffic belongs to us. We will
    perform a so-called man-in-the-middle attack, which will allow us to redirect
    and intercept traffic between two systems (other than our own system) before forwarding
    packets on to the correct destination. One tried-and-true technique for masquerading
    as another device on the network is called *Address Resolution Protocol (ARP)
    cache poisoning* (also known as *ARP spoofing*).
  prefs: []
  type: TYPE_NORMAL
- en: ARP Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we connect to another machine on our local network, we usually use its
    hostname, fully qualified domain name, or IP address. (We’ll look at domain name
    server cache poisoning in [DNS Cache Poisoning](ch07.xhtml#dns_cache_poisoning
    "DNS Cache Poisoning").) Before a packet can be sent from our Kali machine to
    the Windows XP target, Kali must map the IP address of the XP target machine to
    the Media Access Control (MAC) address of the network interface card (NIC) so
    Kali knows where on the network to send the packet. To do this, it uses ARP to
    broadcast “Who has IP address 192.168.20.10?” on the local network. The machine
    with the IP address 192.168.20.10 writes back, “I have 192.168.20.10, and my MAC
    address is 00:0c:29:a9:ce:92.” In our case this will be the Windows XP target.
    Our Kali system will store the mapping from IP address 192.168.20.10 to the MAC
    address 00:0c:29:a9:ce:92 in its ARP cache.
  prefs: []
  type: TYPE_NORMAL
- en: When it sends the next packet, our machine will first look to its ARP cache
    for an entry for 192.168.20.10\. If it finds one, it will use that entry as the
    address of the target rather than sending another ARP broadcast. (ARP cache entries
    are flushed out regularly because network topology may change at any time.) Thus,
    systems will regularly be sending ARP broadcasts as their caches are flushed.
    This process will come in handy when we perform ARP cache poisoning in the next
    section. The ARP process is illustrated in [Figure 7-5](ch07.xhtml#arp_resolution_process
    "Figure 7-5. ARP resolution process").
  prefs: []
  type: TYPE_NORMAL
- en: '![ARP resolution process](httpatomoreillycomsourcenostarchimages2030364.png.jpg)Figure 7-5. ARP
    resolution process'
  prefs: []
  type: TYPE_NORMAL
- en: To view the ARP cache in our Kali machine, enter **`arp`**. Currently, the only
    IP address–to–MAC address mappings that it knows are 192.168.20.1, the default
    gateway, as well as 192.168.20.10, the Windows XP machine we engaged in the last
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now restart the Wireshark capture, and use the *anonymous* login to interact
    with the Ubuntu target’s FTP server again. Next, use the *arp* filter, as shown
    in [Figure 7-6](ch07.xhtml#arp_broadcast_and_reply "Figure 7-6. ARP broadcast
    and reply"), to see the ARP broadcast from the Kali machine and the reply from
    the Ubuntu target with its MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: '![ARP broadcast and reply](httpatomoreillycomsourcenostarchimages2030366.png.jpg)Figure 7-6. ARP
    broadcast and reply'
  prefs: []
  type: TYPE_NORMAL
- en: Check your Kali Linux’s ARP cache again. You should see an entry for 192.168.20.10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The trouble with relying on ARP for addressing is that there’s no guarantee
    that the IP address–to–MAC address answer you get is correct. Any machine can
    reply to an ARP request for 192.168.20.11, even if that machine is really at 192.168.20.12
    or some other IP address. The target machine will accept the reply, regardless.
  prefs: []
  type: TYPE_NORMAL
- en: That’s ARP cache poisoning in a nutshell. We send out a series of ARP replies
    that tell our target that we are another machine on the network. Thus, when the
    target sends traffic intended for that machine, it will instead send the packets
    straight to us to be picked up by our traffic sniffer, as shown in [Figure 7-7](ch07.xhtml#arp_cache_poisoning_redirects_traffic_th
    "Figure 7-7. ARP cache poisoning redirects traffic through Kali.").
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 7](ch07.xhtml "Chapter 7. Capturing Traffic") that we initiated
    an FTP connection from our Ubuntu target to the Windows XP target, but the traffic
    flowing through that connection was not captured by Wireshark on our Kali system.
    Using an ARP cache poisoning attack, we can trick the two systems into sending
    their traffic to our Kali machine instead, to be captured in Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: '![ARP cache poisoning redirects traffic through Kali.](httpatomoreillycomsourcenostarchimages2030368.png.jpg)Figure 7-7. ARP
    cache poisoning redirects traffic through Kali.'
  prefs: []
  type: TYPE_NORMAL
- en: IP Forwarding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But before we can trick the Linux target into sending credentials for the FTP
    server to us instead, we need to turn on IP forwarding to tell our Kali machine
    to forward any extraneous packets it receives to their proper destination. Without
    IP forwarding, we’ll create a *denial-of-service (DoS)* condition on our network,
    where legitimate clients are unable to access services. For example, if we were
    to use ARP cache poisoning without IP forwarding to redirect traffic from the
    Linux target, intended for the Windows XP target, to our Kali machine, the FTP
    server on the Windows XP machine would never receive the packets from the Linux
    machine and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: The setting for IP forwarding on Kali is in */proc/sys/net/ipv4/ip_forward*.
    We need to set this value to **`1`**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Before we start ARP cache poisoning, note the entry for the Windows XP target
    (192.168.20.10) in the Linux target’s ARP cache. This value will change to the
    MAC address of the Kali machine after we commence ARP cache poisoning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: ARP Cache Poisoning with Arpspoof
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One easy-to-use tool for ARP cache poisoning is Arpspoof. To use Arpspoof, we
    tell it which network interface to use, the target of our ARP cache poisoning
    attack, and the IP address we would like to masquerade as. (If you leave out the
    target, you’ll poison the entire network.) For our example, to fool the Linux
    target into thinking we are the Windows XP machine, I set the **`-i`** option
    as eth0 to specify the interface, the **`-t`** option as 192.168.20.11 to specify
    the target as the Linux box, and 192.168.20.10 as the Windows XP machine I want
    to pretend to be.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Arpspoof immediately starts sending ARP replies to the Linux target, informing
    it that the Windows XP machine is located at the Kali machine’s MAC address. (ARP
    cache entries are updated at varying times among different implementations, but
    one minute is a safe length of time to wait.)
  prefs: []
  type: TYPE_NORMAL
- en: To capture the other side of the conversation, we need to fool the Windows XP
    machine into sending traffic intended for the Linux target to the Kali machine
    as well. Start another instance of Arpspoof, and this time set the target as the
    Windows XP machine and the recipient as the Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once you start ARP cache poisoning, check your Linux target’s ARP cache again.
    Notice that the MAC address associated with the Windows XP target has changed
    to 70:56:81:b2:f0:53\. The Linux target should send all traffic intended for the
    Windows XP target to the Kali machine, where we can capture it in Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now log in to the Windows XP target’s FTP server from the Linux target using
    another account (see [Example 7-3](ch07.xhtml#logging_in_to_ftp_on_windows_xp_from_the
    "Example 7-3. Logging in to FTP on Windows XP from the Ubuntu target with a user
    account")). (The credentials *georgia:password* will work if you followed my instructions
    in [Chapter 1](ch01.xhtml "Chapter 1. Setting Up Your Virtual Lab"). If you set
    your credentials as something else, use those instead.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-3. Logging in to FTP on Windows XP from the Ubuntu target with a user
    account
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Because we have IP forwarding turned on, everything appears to work normally
    as far as our user is concerned. Returning to Wireshark, we see that this time
    we were able to capture the FTP traffic and read the plaintext login credentials.
    The Wireshark output shown in [Figure 7-8](ch07.xhtml#wireshark_captures_the_login_information
    "Figure 7-8. Wireshark captures the login information.") confirms that our Kali
    machine is forwarding the FTP traffic between the two targets. After each FTP
    packet, there is a retransmission packet.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wireshark captures the login information.](httpatomoreillycomsourcenostarchimages2030370.png.jpg)Figure 7-8. Wireshark
    captures the login information.'
  prefs: []
  type: TYPE_NORMAL
- en: Using ARP Cache Poisoning to Impersonate the Default Gateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use ARP cache poisoning to impersonate the default gateway on a
    network and access traffic entering and leaving the network, including traffic
    destined for the Internet. Stop the Arpspoof processes you have running, and try
    tricking the Linux target into routing all traffic to the gateway through the
    Kali machine by impersonating the default gateway, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we start to browse the Internet from the Linux target, we should see HTTP
    packets being captured by Wireshark. Even if sensitive information is encrypted
    with HTTPS, we’ll still be able to see where users are going and any other information
    sent over HTTP. For example, if we run a Google query, the plaintext of the query
    will be captured in Wireshark, as shown in [Figure 7-9](ch07.xhtml#query_captured_in_wireshark
    "Figure 7-9. Query captured in Wireshark").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use ARP cache poisoning to trick a large network into thinking your pentest
    machine is the default gateway, you may unwittingly cause networking issues. All
    the traffic in a network going through one laptop (or worse, one virtual machine)
    can slow things down to the point of denial of service in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: '![Query captured in Wireshark](httpatomoreillycomsourcenostarchimages2030372.png.jpg)Figure 7-9. Query
    captured in Wireshark'
  prefs: []
  type: TYPE_NORMAL
- en: DNS Cache Poisoning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to ARP cache poisoning, we can also poison Domain Name Service (DNS)
    cache entries (mappings from domain names to IP addresses) to route traffic intended
    for another website to one we control. Just as ARP resolves IP to MAC addresses
    to properly route traffic, DNS maps (or resolves) domain names such as *[www.gmail.com](http://www.gmail.com)*
    to IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: To reach another system on the Internet or local network, our machine needs
    to know the IP address to connect to. It is easy to remember the URL *[www.gmail.com](http://www.gmail.com)*
    if we want to visit our web mail account, but it’s difficult to remember a bunch
    of IP addresses, which may even change regularly. DNS resolution translates the
    human-readable domain name into an IP address. For example, we can use the tool
    Nslookup to translate *[www.gmail.com](http://www.gmail.com)* into an IP address,
    as shown in [Example 7-4](ch07.xhtml#nslookup_dns_resolution "Example 7-4. Nslookup
    DNS resolution").
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-4. Nslookup DNS resolution
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Nslookup translates *[www.gmail.com](http://www.gmail.com)*
    to a number of IP addresses, including 173.194.37.85 and 173.194.37.86, all of
    which we can use to reach Gmail. To perform DNS resolution ([Figure 7-10](ch07.xhtml#dns_resolution
    "Figure 7-10. DNS resolution")), our system queries its local DNS server for information
    about a specific domain name, such as *[www.gmail.com](http://www.gmail.com)*.
    If the DNS server has a cache entry for the address, it gives our system the correct
    IP address. If not, it contacts other DNS servers on the Internet looking for
    the correct information.
  prefs: []
  type: TYPE_NORMAL
- en: When the correct IP address is returned, the DNS server writes back to our machine
    with the correct IP address resolution for *[www.gmail.com](http://www.gmail.com)*,
    and our system then translates *[www.gmail.com](http://www.gmail.com)* into 173.194.37.85,
    as shown in [Example 7-4](ch07.xhtml#nslookup_dns_resolution "Example 7-4. Nslookup
    DNS resolution"). Users can then access *[www.gmail.com](http://www.gmail.com)*
    by name without having to use the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '![DNS resolution](httpatomoreillycomsourcenostarchimages2030374.png.jpg)Figure 7-10. DNS
    resolution'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DNS cache poisoning works like ARP cache poisoning: We send a bunch of bogus
    DNS resolution replies pointing to the wrong IP address for a domain name.'
  prefs: []
  type: TYPE_NORMAL
- en: Now make sure the Apache server is running with the command `service apache2
    start`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Before we use a DNS cache poisoning tool, we need to create a file that specifies
    which DNS names we would like to spoof and where to send traffic. For example,
    let’s tell any system that runs a DNS resolution for *[www.gmail.com](http://www.gmail.com)*
    that that domain’s IP address is our Kali machine by adding the entry `192.168.20.9
    www.gmail.com` to a new file called *hosts.txt*. (You can name the file anything
    you like.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using Dnsspoof
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Restart Arpspoof between the Linux target and the default gateway and vice versa
    as discussed in [Using ARP Cache Poisoning to Impersonate the Default Gateway](ch07.xhtml#using_arp_cache_poisoning_to_impersonate
    "Using ARP Cache Poisoning to Impersonate the Default Gateway"). Now we can start
    sending DNS cache poisoning attempts using the Dnsspoof DNS spoofing tool, as
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We specify the network interface ❶ to use, and point Dnsspoof to the file (*hosts.txt*)
    we just created ❷ telling it which values to spoof.
  prefs: []
  type: TYPE_NORMAL
- en: Once Dnsspoof is running, when we run the `nslookup` command from our Linux
    target, the IP address returned should be our Kali machine’s, as shown in [Example 7-5](ch07.xhtml#nslookup_after_attack
    "Example 7-5. Nslookup after attack"). This is clearly not the real IP address
    for Gmail.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-5. Nslookup after attack
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate this attack, set up a website to direct traffic to. The Apache
    server in Kali will by default serve an “It Works” page to anyone who visits it.
    We can change the contents of the *index.html* file in the folder */var/www*,
    but the default “It Works” text is fine for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Now if we browse to *[http://www.gmail.com/](http://www.gmail.com/)* from the
    Ubuntu target, the URL bar should say *[http://www.gmail.com/](http://www.gmail.com/)*,
    but we’re actually at our Kali machine’s web server, as shown in [Figure 7-11](ch07.xhtml#this_isnapostrophet_gmaildot
    "Figure 7-11. This isn’t Gmail."). We can even make this attack more interesting
    by cloning the actual Gmail website (or any other site the attacker chooses) so
    the user won’t notice the difference.
  prefs: []
  type: TYPE_NORMAL
- en: '![This isn’t Gmail.](httpatomoreillycomsourcenostarchimages2030376.png.jpg)Figure 7-11. This
    isn’t Gmail.'
  prefs: []
  type: TYPE_NORMAL
- en: SSL Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve been able to intercept encrypted traffic, but we haven’t been
    able to get any sensitive information out of the encrypted connection. For this
    next attack, we’ll rely on a user’s willingness to click past an SSL certificate
    warning to perform a man-in-the-middle attack and get the plaintext out of a Secure
    Sockets Layer (SSL) connection, which encrypts traffic to protect it from being
    read by an eavesdropper.
  prefs: []
  type: TYPE_NORMAL
- en: SSL Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of SSL is to provide reasonable assurance that any sensitive information
    (such as credentials or credit card numbers) transmitted between a user’s browser
    and a server is secure—unable to be read by a malicious entity along the way.
    To prove that the connection is secure, SSL uses certificates. When you browse
    to an SSL-enabled site, your browser asks the site to identify itself with its
    SSL certificate. The site presents its certificate, which your browser verifies.
    If your browser accepts the certificate, it informs the server, the server returns
    a digitally signed acknowledgment, and SSL-secured communication begins.
  prefs: []
  type: TYPE_NORMAL
- en: An SSL certificate includes an encryption key pair as well as identifying information,
    such as the domain name and the name of the company that owns the site. A server’s
    SSL certificate is generally vouched for by a certificate authority (CA) such
    as VeriSign or Thawte. Browsers come preinstalled with a list of trusted CAs,
    and if a server’s SSL certificate is vouched for by a trusted CA, the browser
    can create a secure connection. If the certificate is untrusted, the user will
    be presented with a warning that basically says, “The connection might be secure,
    but it might not be. Proceed at your own risk.”
  prefs: []
  type: TYPE_NORMAL
- en: Using Ettercap for SSL Man-in-the-Middle Attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our ARP cache poisoning attack, we man-in-the-middled the traffic between
    our Windows XP and Ubuntu targets (as well as the Ubuntu target and the Internet).
    These systems were still able to communicate with each other, but our Kali system
    was able to capture the traffic. We can do the same thing to attack SSL traffic.
    We can break the secure SSL connection by redirecting traffic to and from *[www.facebook.com](http://www.facebook.com)*
    to our Kali system so we can intercept sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we’ll use Ettercap, a multifunction suite for man-in-the-middle
    attacks that, in addition to SSL attacks, can also complete all of the attacks
    we have performed so far with Arpspoof and Dnsspoof. Turn off any other spoofing
    tools before starting Ettercap. See [Ettercap](ch01.xhtml#ettercap "Ettercap")
    for configuration instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Ettercap has multiple interfaces, but we will use the `-T` option for the text-based
    interface in this example. Use the `-M` option with `arp:remote /` *`gateway`*`/
    /`*`target`*`/` to set up an ARP cache poisoning attack between the default gateway
    and the Linux target, as shown next. The actual attack will work the same way
    as our previous exercise with Arpspoof.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With Ettercap running, we just wait for users to start interacting with SSL-based
    web servers. Switch over to your Linux target, and attempt to log in to a website
    using SSL. You should be greeted with a certificate warning like the one in [Figure 7-12](ch07.xhtml#facebook_cannot_be_verifieddot
    "Figure 7-12. Facebook cannot be verified.").
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a man-in-the-middle attack, the SSL session’s security cannot
    be verified. The certificate Ettercap presents isn’t valid for *[www.facebook.com](http://www.facebook.com)*,
    so the trust is broken, as illustrated in [Figure 7-13](ch07.xhtml#ssl_man-in-the-middle_attack
    "Figure 7-13. SSL man-in-the-middle attack").
  prefs: []
  type: TYPE_NORMAL
- en: 'But security warnings don’t stop all users. If we click through the warning
    and enter our credentials, Ettercap will grab them in plaintext before forwarding
    them on to the server, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Facebook cannot be verified.](httpatomoreillycomsourcenostarchimages2030378.png.jpg)Figure 7-12. Facebook
    cannot be verified.![SSL man-in-the-middle attack](httpatomoreillycomsourcenostarchimages2030380.png.jpg)Figure 7-13. SSL
    man-in-the-middle attack'
  prefs: []
  type: TYPE_NORMAL
- en: SSL Stripping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, the trouble with SSL man-in-the-middle attacks is that users have
    to click through the SSL certificate warning. Depending on the browser, this can
    be an involved process that is difficult, if not impossible, for a user to ignore.
    Most readers can probably think of a time they clicked through a security warning
    and continued to the page despite their better judgment. (Case in point: Our default
    Nessus install uses Tenable’s self-signed certificate, which throws a certificate
    error when you browse to the web interface. If you chose to follow along with
    that example, you most likely decided to click through the warning.)'
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to say how effective certificate warnings are at stopping users
    from visiting HTTPS sites without valid certificates. I have run social-engineering
    tests that employed self-signed SSL certificates, and the success rate has been
    significantly lower than those with valid certificates or those that don’t use
    HTTPS. Though some users did click through and visit the sites, a more sophisticated
    attack would allow us to capture information in plaintext without triggering those
    obvious warnings that the SSL connection is compromised.
  prefs: []
  type: TYPE_NORMAL
- en: With SSL stripping, we man-in-the-middle the HTTP connection before it is redirected
    to SSL and add SSL functionality before sending the packets on to the web server.
    When the web server replies, SSL stripping again intercepts the traffic and removes
    the HTTPS tags before sending the packets to the client. This technique is illustrated
    in [Figure 7-14](ch07.xhtml#ssl_stripping_attack "Figure 7-14. SSL stripping attack").
  prefs: []
  type: TYPE_NORMAL
- en: '![SSL stripping attack](httpatomoreillycomsourcenostarchimages2030382.png.jpg)Figure 7-14. SSL
    stripping attack'
  prefs: []
  type: TYPE_NORMAL
- en: Moxie Marlinspike, the author of SSLstrip, called certificate warnings *negative
    feedback*, as opposed to *positive feedback* that a session is valid, such as
    seeing HTTPS in the browser URL bar. Avoiding this negative feedback is much more
    important to an attack’s success than including positive feedback because users
    are naturally less likely to notice that a URL says HTTP instead of HTTPS than
    they are a giant certificate warning they have to actively click through. SSL
    stripping avoids the certificate warning by again man-in-the-middling the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Users typically encounter HTTPS either through clicking links or through HTTP
    302 redirects. Most users don’t enter *[https://www.facebook.com](https://www.facebook.com)*
    or even *[http://www.facebook.com](http://www.facebook.com)* into their browsers;
    they type *[www.facebook.com](http://www.facebook.com)* or sometimes just *facebook.com.*
    And that’s why this attack is possible. SSLstrip adds the HTTPS itself and thus
    the SSL connection between Facebook and Kali is valid. SSLstrip just turns the
    connection back to HTTP to send to the original requester. There is no certificate
    warning.
  prefs: []
  type: TYPE_NORMAL
- en: Using SSLstrip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tool SSLstrip implements SSL stripping. Before we start it, we need to set
    an Iptables rule to pass traffic that is headed to port 80 through SSLstrip. We’ll
    run SSLstrip on port 8080, as shown next, then restart Arpspoof and spoof the
    default gateway. (For instructions, jump back to [Using ARP Cache Poisoning to
    Impersonate the Default Gateway](ch07.xhtml#using_arp_cache_poisoning_to_impersonate
    "Using ARP Cache Poisoning to Impersonate the Default Gateway").)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now start SSLstrip, and tell it to listen on port 8080 with the `-l` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, browse to a site that uses SSL (try any Internet site that requires login
    credentials) from your Linux target, like the Twitter login page shown in [Figure 7-15](ch07.xhtml#twitter_login_page_with_sslstrip_running
    "Figure 7-15. Twitter login page with SSLstrip running"). As you can see, HTTP
    has replaced HTTPS in the address bar.
  prefs: []
  type: TYPE_NORMAL
- en: When you log in, your credentials will be reported in plaintext by SSLstrip.
    (No, my Twitter password isn’t really “password.”)
  prefs: []
  type: TYPE_NORMAL
- en: This attack is more sophisticated than a straight SSL man-in-the-middle attack.
    We are able to avoid the certificate warning because the server is completing
    an SSL connection with SSLstrip rather than the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, SSLstrip reports the entered credentials (*georgiaweidman:
    password*) in plaintext.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Twitter login page with SSLstrip running](httpatomoreillycomsourcenostarchimages2030384.png.jpg)Figure 7-15. Twitter
    login page with SSLstrip running'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we’ve fiddled with network traffic to create some interesting
    results. Using various tools and techniques, we were able to intercept traffic
    that we had no business seeing in a switched network. We used ARP cache poisoning
    to redirect traffic in a switched network to our Kali system and DNS cache poisoning
    to redirect users to our web servers. We used Ettercap to automate an SSL man-in-the-middle
    attack and (assuming that the user clicks through a warning) capture sensitive
    information in plaintext. Finally, we made the attack even more sophisticated
    by avoiding an invalid certificate warning using SSL stripping.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing traffic from the local network can glean useful information for our
    pentest. For example, we were able to capture valid credentials for the FTP server
    for use in exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of exploitation, let’s get started.
  prefs: []
  type: TYPE_NORMAL
