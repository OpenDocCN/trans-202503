- en: Chapter 7. Capturing Traffic
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章 捕获流量
- en: Before we move on to exploitation, we’ll use the Wireshark monitoring tool,
    as well as other tools, to sniff and manipulate traffic to gain useful information
    from other machines on the local network. On an internal penetration test, when
    we’re simulating an insider threat or an attacker who has breached the perimeter,
    capturing traffic from other systems in the network can give us additional interesting
    information (perhaps even usernames and passwords) that can help us with exploitation.
    The trouble is that capturing traffic can produce a massive amount of potentially
    useful data. Capturing all traffic on just your home network could quickly fill
    several Wireshark screens, and discovering which traffic is useful for a pentest
    can be difficult. In this chapter, we’ll look at several ways to manipulate a
    network to get access to traffic we have no business being able to see.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入利用阶段之前，我们将使用 Wireshark 监控工具以及其他工具来嗅探和操控流量，以从本地网络中的其他机器中获取有用的信息。在一次内部渗透测试中，当我们模拟内部威胁或攻击者突破防线时，捕获网络中其他系统的流量可以为我们提供额外的有趣信息（甚至可能是用户名和密码），帮助我们进行进一步的利用。问题在于，捕获流量可能会产生大量潜在有用的数据。仅仅捕获家用网络上的所有流量就可能迅速填满多个
    Wireshark 窗口，而且发现哪些流量对渗透测试有用可能会很困难。在本章中，我们将探讨几种操控网络以获取我们本不该能看到的流量的方法。
- en: Networking for Capturing Traffic
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获流量的网络设置
- en: If you find yourself in a network that uses hubs rather than switches, capturing
    traffic not intended for your machine will be easy, because when a network hub
    receives a packet, it rebroadcasts it on all ports, leaving it up to each device
    to decide whom the packet belongs to. In a hubbed network, capturing other systems’
    traffic is as easy as selecting Use promiscuous mode on all interfaces in Wireshark.
    This tells our Network Interface Controller (NIC) to grab everything it sees,
    which in a hubbed network will be every packet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己处于一个使用集线器而不是交换机的网络中，捕获不属于你机器的流量将变得非常容易，因为当网络集线器接收到一个数据包时，它会将其在所有端口上重新广播，由每个设备决定该数据包属于谁。在一个使用集线器的网络中，捕获其他系统的流量就像在
    Wireshark 中选择“在所有接口上使用混杂模式”一样简单。这会告诉我们的网络接口控制器（NIC）抓取它看到的所有内容，而在集线器网络中，这将是每个数据包。
- en: Unlike hubs, switches send traffic only to the intended system, so on a switched
    network, we won’t be able to view, for example, all the traffic to and from the
    domain controller without fooling the network into sending us that traffic. Most
    networks you encounter on pentests will probably be switched networks; even some
    legacy network hardware that claims to be a hub may have the functionality of
    a switch.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与集线器不同，交换机会将流量仅发送到目标系统，因此在交换机网络中，我们将无法看到例如域控制器的所有进出流量，除非通过某种方式让网络将这些流量发送给我们。你在渗透测试中遇到的大多数网络可能都是交换机网络；即使是一些标榜为集线器的老旧网络硬件，也可能具备交换机的功能。
- en: Virtual networks seem to act like hubs, because all your virtual machines share
    one physical device. If you capture traffic in promiscuous mode in a virtual network,
    you may be able to see traffic from every virtual machine as well as the host
    machine, even if you are using a switch instead of a hub in your environment.
    To simulate a non-virtualized network, we’ll turn off Use promiscuous mode on
    all interfaces in Wireshark, which means we will have to work a little harder
    to capture traffic from our target virtual machines.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟网络看起来像是集线器，因为你所有的虚拟机共享一个物理设备。如果你在虚拟网络中以混杂模式捕获流量，即使你在环境中使用的是交换机而不是集线器，你也可能能够看到来自每个虚拟机以及主机的流量。为了模拟一个非虚拟化的网络，我们将在
    Wireshark 中关闭“在所有接口上使用混杂模式”，这意味着我们需要更加努力地捕获目标虚拟机的流量。
- en: Using Wireshark
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Wireshark
- en: Wireshark is a graphical network protocol analyzer that lets us take a deep
    dive into the individual packets moving around the network. Wireshark can be used
    to capture Ethernet, wireless, Bluetooth, and many other kinds of traffic. It
    can decode different protocols that it sees, so you could, for instance, reconstruct
    the audio of Voice over IP (VoIP) phone calls. Let’s take a look at the basics
    of using Wireshark to capture and analyze traffic.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 是一个图形化网络协议分析工具，可以让我们深入查看在网络中流动的每一个数据包。Wireshark 可以用于捕获以太网、无线、蓝牙以及其他多种类型的流量。它可以解码它所看到的不同协议，因此你可以重建例如语音传输协议（VoIP）电话通话的音频。让我们来看看使用
    Wireshark 捕获和分析流量的基础。
- en: Capturing Traffic
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获流量
- en: Let’s start by using Wireshark to capture traffic on our local network. Start
    Wireshark in Kali, as shown here. Click through any warnings about using Wireshark
    as root being dangerous.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tell Wireshark to capture on the local network interface (eth0) by selecting
    **Capture** ▸ **Options**, and selecting the **eth0** option, as shown in [Figure 7-1](ch07.xhtml#starting_a_wireshark_capture
    "Figure 7-1. Starting a Wireshark capture"). Remember to uncheck the Use promiscuous
    mode on all interfaces option so that the results will be like those on a physical
    switched network rather than the VMware network. Exit the Options menu. Finally,
    click **Capture** ▸ **Start** to begin the traffic capture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: You should start to see traffic coming in, and you should be able to capture
    all traffic intended for the Kali machine as well as any broadcast traffic (traffic
    sent to the entire network).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting a Wireshark capture](httpatomoreillycomsourcenostarchimages2030356.png.jpg)Figure 7-1. Starting
    a Wireshark capture'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the traffic we can capture in a switched network, let’s start
    by contacting our Windows XP target from our Kali machine over FTP. Log in as
    *anonymous*, as shown in [Example 7-1](ch07.xhtml#logging_in_via_ftp "Example 7-1. Logging
    in via FTP"), to see the captured traffic in Wireshark. (In the previous chapter,
    we discovered that the *anonymous* user is allowed on the Windows XP target. Although
    *anonymous* requires that you enter a password, it doesn’t matter what it is.
    Traditionally, it is an email address, but the FTP server will accept whatever
    you would like to use.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1. Logging in via FTP
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should see packets in Wireshark from the system with IP address 192.168.20.9
    to 192.168.20.10 and vice versa, with the Protocol field marked as FTP. Wireshark
    is capturing the traffic moving to and from our Kali machine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Switch over to your Ubuntu Linux target machine, and log in to the FTP server
    on the Windows XP target. Looking back at Wireshark in Kali, you should see that
    no additional FTP packets have been captured. In our simulated switched network,
    any traffic not destined for our Kali machine will not be seen by the network
    interface and, thus, will not be captured by Wireshark. (We’ll learn how to rectify
    this situation and capture other systems’ traffic in [ARP Cache Poisoning](ch07.xhtml#arp_cache_poisoning
    "ARP Cache Poisoning").)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Traffic
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sheer volume of network traffic captured by Wireshark can be a bit overwhelming
    because, in addition to our FTP traffic, every other packet to or from the Kali
    system is captured. To find specific interesting packets, we can use Wireshark
    filters. The Filter field is located at the top left of the Wireshark GUI. As
    a very simple first Wireshark filtering example, let’s look for all traffic that
    uses the FTP protocol. Enter **`ftp`** in the Filter field and click **Apply**,
    as shown in [Figure 7-2](ch07.xhtml#filtering_traffic_in_wireshark "Figure 7-2. Filtering
    traffic in Wireshark").
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark捕获的网络流量量庞大，可能会让人感到有些不知所措，因为除了我们的FTP流量外，所有进出Kali系统的数据包都会被捕获。为了找到特定的有趣数据包，我们可以使用Wireshark的过滤器。过滤器字段位于Wireshark界面左上方。作为第一个简单的Wireshark过滤示例，我们可以查找所有使用FTP协议的流量。在过滤器字段中输入**`ftp`**并点击**应用**，如[图
    7-2](ch07.xhtml#filtering_traffic_in_wireshark "Figure 7-2. Filtering traffic
    in Wireshark")所示。
- en: '![Filtering traffic in Wireshark](httpatomoreillycomsourcenostarchimages2030358.png.jpg)Figure 7-2. Filtering
    traffic in Wireshark'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![在Wireshark中过滤流量](httpatomoreillycomsourcenostarchimages2030358.png.jpg)图
    7-2. 在Wireshark中过滤流量'
- en: As expected, Wireshark filters the captured packets to show only those that
    use the FTP protocol. We can see our entire FTP conversation, including our login
    information, in plaintext.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，Wireshark会过滤捕获的数据包，仅显示使用FTP协议的数据包。我们可以看到整个FTP会话，包括明文的登录信息。
- en: We can use more advanced filters to further fine-tune the packets returned.
    For example, we can use the filter *ip.dst==192.168.20.10* to return only packets
    with the destination IP address 192.168.20.10\. We can even chain filters together,
    such as using the filter *ip.dst==192.168.20.10 and ftp* to find only FTP traffic
    destined for 192.168.20.10.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更高级的过滤器来进一步调整返回的数据包。例如，我们可以使用过滤器*ip.dst==192.168.20.10*来只返回目标IP地址为192.168.20.10的包。我们甚至可以将过滤器链在一起使用，例如使用过滤器*ip.dst==192.168.20.10
    and ftp*来查找仅针对192.168.20.10的FTP流量。
- en: Following a TCP Stream
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪TCP流
- en: Even after filtering traffic, there may be multiple FTP connections captured
    during the same time frame, so it could still be difficult to tell what’s going
    on. But once we find an interesting packet, such as the beginning of an FTP login,
    we can dig deeper into the conversation by right-clicking the packet and selecting
    **Follow TCP Stream**, as shown in [Figure 7-3](ch07.xhtml#following_the_tcp_stream_in_wireshark
    "Figure 7-3. Following the TCP stream in Wireshark").
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在过滤流量之后，仍然可能在相同时间段内捕获到多个FTP连接，因此可能仍然难以了解发生了什么。但一旦我们找到一个有趣的数据包，比如FTP登录的开始，我们可以通过右键单击数据包并选择**跟踪TCP流**来深入查看会话，如[图
    7-3](ch07.xhtml#following_the_tcp_stream_in_wireshark "Figure 7-3. Following the
    TCP stream in Wireshark")所示。
- en: '![Following the TCP stream in Wireshark](httpatomoreillycomsourcenostarchimages2030360.png.jpg)Figure 7-3. Following
    the TCP stream in Wireshark'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![在Wireshark中跟踪TCP流](httpatomoreillycomsourcenostarchimages2030360.png.jpg)图
    7-3. 在Wireshark中跟踪TCP流'
- en: The resulting screen will show us the full contents of our FTP connection, including
    its credentials in plaintext, as shown in [Example 7-2](ch07.xhtml#ftp_login_conversation
    "Example 7-2. FTP login conversation").
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 结果界面会显示我们整个FTP连接的内容，包括其中的明文凭据，如[示例 7-2](ch07.xhtml#ftp_login_conversation "Example
    7-2. FTP login conversation")所示。
- en: Example 7-2. FTP login conversation
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-2. FTP登录对话
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Dissecting Packets
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解剖数据包
- en: By selecting a specific captured packet, we can get more information about the
    captured data, as shown in [Figure 7-4](ch07.xhtml#packet_details_in_wireshark
    "Figure 7-4. Packet details in Wireshark"). At the bottom of the Wireshark screen,
    you can see details of the selected packet. With a little guidance, Wireshark
    will break down the data for you. For example, we can easily find the TCP destination
    port by selecting the TCP entry and looking for Destination port, as highlighted
    in the figure. When we select this field, the entry in the raw bytes of the packet
    is highlighted as well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择特定的捕获数据包，我们可以获得有关捕获数据的更多信息，如[图 7-4](ch07.xhtml#packet_details_in_wireshark
    "Figure 7-4. Packet details in Wireshark")所示。在Wireshark界面底部，你可以看到所选数据包的详细信息。在一点点引导下，Wireshark会为你分解数据。例如，我们可以通过选择TCP条目并查找目标端口（Destination
    port）轻松找到TCP目标端口，如图中高亮显示的部分。当我们选择这个字段时，数据包原始字节中的对应条目也会被高亮显示。
- en: '![Packet details in Wireshark](httpatomoreillycomsourcenostarchimages2030362.png)Figure 7-4. Packet
    details in Wireshark'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![Wireshark中的数据包详情](httpatomoreillycomsourcenostarchimages2030362.png)图 7-4. Wireshark中的数据包详情'
- en: ARP Cache Poisoning
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARP缓存中毒
- en: While it is nice to see the details of our own traffic, for pentesting purposes,
    it would be preferable to see the traffic that wasn’t intended for our Kali system.
    Perhaps we’ll be able to capture another user’s login session that uses an account
    other than *anonymous* to log in; that would give us working credentials for the
    FTP server, as well as a set of credentials that might be reused elsewhere in
    the environment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看到我们自己流量的详细信息很不错，但对于渗透测试目的来说，最好看到那些不打算发送到我们Kali系统的流量。也许我们能够捕获另一个用户的登录会话，该会话使用的是除*匿名*之外的帐户登录；这将为我们提供FTP服务器的有效凭据，并且可能会有一组凭据可以在环境中的其他地方被重用。
- en: To capture traffic not intended for the Kali system, we need to find some way
    to have the relevant data sent to our Kali system. Because the network switch
    will send only packets that belong to us, we need to trick our target machine
    or the switch (or ideally both) into believing the traffic belongs to us. We will
    perform a so-called man-in-the-middle attack, which will allow us to redirect
    and intercept traffic between two systems (other than our own system) before forwarding
    packets on to the correct destination. One tried-and-true technique for masquerading
    as another device on the network is called *Address Resolution Protocol (ARP)
    cache poisoning* (also known as *ARP spoofing*).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获不打算发送到Kali系统的流量，我们需要找到一种方法将相关数据发送到我们的Kali系统。由于网络交换机会只发送属于我们的数据包，我们需要欺骗目标机器或交换机（或者最好是两者），让它们相信这些流量属于我们。我们将执行一种所谓的中间人攻击，这将允许我们在将数据包转发到正确的目的地之前，重定向并拦截两个系统之间的流量（不包括我们自己的系统）。一种经验证有效的技术是伪装成网络上的其他设备，这被称为*地址解析协议（ARP）缓存投毒*（也叫*ARP欺骗*）。
- en: ARP Basics
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ARP基础
- en: When we connect to another machine on our local network, we usually use its
    hostname, fully qualified domain name, or IP address. (We’ll look at domain name
    server cache poisoning in [DNS Cache Poisoning](ch07.xhtml#dns_cache_poisoning
    "DNS Cache Poisoning").) Before a packet can be sent from our Kali machine to
    the Windows XP target, Kali must map the IP address of the XP target machine to
    the Media Access Control (MAC) address of the network interface card (NIC) so
    Kali knows where on the network to send the packet. To do this, it uses ARP to
    broadcast “Who has IP address 192.168.20.10?” on the local network. The machine
    with the IP address 192.168.20.10 writes back, “I have 192.168.20.10, and my MAC
    address is 00:0c:29:a9:ce:92.” In our case this will be the Windows XP target.
    Our Kali system will store the mapping from IP address 192.168.20.10 to the MAC
    address 00:0c:29:a9:ce:92 in its ARP cache.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们连接到本地网络上的另一台机器时，通常会使用它的主机名、完全限定域名或IP地址。（我们将在[DNS缓存投毒](ch07.xhtml#dns_cache_poisoning
    "DNS缓存投毒")中讨论域名服务器缓存投毒。）在数据包从我们的Kali机器发送到Windows XP目标之前，Kali必须将XP目标机器的IP地址映射到网络接口卡（NIC）的媒体访问控制（MAC）地址，以便Kali知道将数据包发送到网络的哪个位置。为此，它使用ARP广播“谁拥有IP地址192.168.20.10？”在本地网络上。拥有IP地址192.168.20.10的机器回复：“我有192.168.20.10，我的MAC地址是00:0c:29:a9:ce:92。”在我们的案例中，这将是Windows
    XP目标。我们的Kali系统将在其ARP缓存中存储从IP地址192.168.20.10到MAC地址00:0c:29:a9:ce:92的映射。
- en: When it sends the next packet, our machine will first look to its ARP cache
    for an entry for 192.168.20.10\. If it finds one, it will use that entry as the
    address of the target rather than sending another ARP broadcast. (ARP cache entries
    are flushed out regularly because network topology may change at any time.) Thus,
    systems will regularly be sending ARP broadcasts as their caches are flushed.
    This process will come in handy when we perform ARP cache poisoning in the next
    section. The ARP process is illustrated in [Figure 7-5](ch07.xhtml#arp_resolution_process
    "Figure 7-5. ARP resolution process").
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当它发送下一个数据包时，我们的机器将首先查找其ARP缓存中是否有192.168.20.10的条目。如果找到，它将使用该条目作为目标地址，而不是发送另一个ARP广播。（ARP缓存条目会定期被清除，因为网络拓扑可能随时发生变化。）因此，系统会定期发送ARP广播，因为它们的缓存会被清空。这个过程将在我们下一节进行ARP缓存投毒时派上用场。ARP过程在[图7-5](ch07.xhtml#arp_resolution_process
    "图7-5. ARP解析过程")中进行了说明。
- en: '![ARP resolution process](httpatomoreillycomsourcenostarchimages2030364.png.jpg)Figure 7-5. ARP
    resolution process'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![ARP解析过程](httpatomoreillycomsourcenostarchimages2030364.png.jpg)图7-5. ARP解析过程'
- en: To view the ARP cache in our Kali machine, enter **`arp`**. Currently, the only
    IP address–to–MAC address mappings that it knows are 192.168.20.1, the default
    gateway, as well as 192.168.20.10, the Windows XP machine we engaged in the last
    exercise.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Kali机器中的ARP缓存，输入**`arp`**。目前，它只知道192.168.20.1（默认网关）和192.168.20.10（我们在上一个练习中使用的Windows
    XP机器）这两个IP地址到MAC地址的映射。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now restart the Wireshark capture, and use the *anonymous* login to interact
    with the Ubuntu target’s FTP server again. Next, use the *arp* filter, as shown
    in [Figure 7-6](ch07.xhtml#arp_broadcast_and_reply "Figure 7-6. ARP broadcast
    and reply"), to see the ARP broadcast from the Kali machine and the reply from
    the Ubuntu target with its MAC address.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新启动Wireshark捕获，并使用*匿名*登录再次与Ubuntu目标的FTP服务器交互。接下来，使用*arp*过滤器，如[图7-6](ch07.xhtml#arp_broadcast_and_reply
    "图7-6。ARP广播和应答")所示，查看来自Kali机器的ARP广播以及来自Ubuntu目标的带有其MAC地址的应答。
- en: '![ARP broadcast and reply](httpatomoreillycomsourcenostarchimages2030366.png.jpg)Figure 7-6. ARP
    broadcast and reply'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![ARP广播和应答](httpatomoreillycomsourcenostarchimages2030366.png.jpg)图7-6。ARP广播和应答'
- en: Check your Kali Linux’s ARP cache again. You should see an entry for 192.168.20.10.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查你的Kali Linux的ARP缓存。你应该能看到192.168.20.10的条目。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The trouble with relying on ARP for addressing is that there’s no guarantee
    that the IP address–to–MAC address answer you get is correct. Any machine can
    reply to an ARP request for 192.168.20.11, even if that machine is really at 192.168.20.12
    or some other IP address. The target machine will accept the reply, regardless.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖ARP进行地址解析的问题在于，无法保证你得到的IP地址与MAC地址的映射是正确的。任何机器都可以回应192.168.20.11的ARP请求，即使那台机器的实际IP地址是192.168.20.12或其他任何地址。目标机器会接受这个应答，无论其是否正确。
- en: That’s ARP cache poisoning in a nutshell. We send out a series of ARP replies
    that tell our target that we are another machine on the network. Thus, when the
    target sends traffic intended for that machine, it will instead send the packets
    straight to us to be picked up by our traffic sniffer, as shown in [Figure 7-7](ch07.xhtml#arp_cache_poisoning_redirects_traffic_th
    "Figure 7-7. ARP cache poisoning redirects traffic through Kali.").
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是ARP缓存中毒的基本原理。我们发送一系列的ARP应答，告诉目标我们是网络中的另一台机器。因此，当目标机器发送本应发送给那台机器的流量时，它将把数据包直接发送给我们，由我们的流量嗅探器捕获，如[图7-7](ch07.xhtml#arp_cache_poisoning_redirects_traffic_th
    "图7-7。ARP缓存中毒通过Kali重定向流量")所示。
- en: Recall from [Chapter 7](ch07.xhtml "Chapter 7. Capturing Traffic") that we initiated
    an FTP connection from our Ubuntu target to the Windows XP target, but the traffic
    flowing through that connection was not captured by Wireshark on our Kali system.
    Using an ARP cache poisoning attack, we can trick the two systems into sending
    their traffic to our Kali machine instead, to be captured in Wireshark.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第7章](ch07.xhtml "第7章。捕获流量")中，我们从Ubuntu目标机器发起了一个FTP连接到Windows XP目标机器，但该连接中的流量并未被Wireshark在我们的Kali系统上捕获。通过使用ARP缓存中毒攻击，我们可以欺骗这两台系统，将它们的流量发送到我们的Kali机器，从而在Wireshark中捕获。
- en: '![ARP cache poisoning redirects traffic through Kali.](httpatomoreillycomsourcenostarchimages2030368.png.jpg)Figure 7-7. ARP
    cache poisoning redirects traffic through Kali.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![ARP缓存中毒通过Kali重定向流量。](httpatomoreillycomsourcenostarchimages2030368.png.jpg)图7-7。ARP缓存中毒通过Kali重定向流量。'
- en: IP Forwarding
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IP转发
- en: But before we can trick the Linux target into sending credentials for the FTP
    server to us instead, we need to turn on IP forwarding to tell our Kali machine
    to forward any extraneous packets it receives to their proper destination. Without
    IP forwarding, we’ll create a *denial-of-service (DoS)* condition on our network,
    where legitimate clients are unable to access services. For example, if we were
    to use ARP cache poisoning without IP forwarding to redirect traffic from the
    Linux target, intended for the Windows XP target, to our Kali machine, the FTP
    server on the Windows XP machine would never receive the packets from the Linux
    machine and vice versa.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在我们能够欺骗Linux目标将FTP服务器的凭证发送给我们之前，我们需要启用IP转发，告诉我们的Kali机器将它接收到的任何额外数据包转发到正确的目的地。如果没有IP转发，我们将会在网络上创建*拒绝服务（DoS）*状态，导致合法客户端无法访问服务。例如，如果我们在没有IP转发的情况下使用ARP缓存中毒，将Linux目标的流量重定向到我们的Kali机器，原本应发送到Windows
    XP目标的流量，Windows XP机器上的FTP服务器将永远无法接收到来自Linux机器的数据包，反之亦然。
- en: The setting for IP forwarding on Kali is in */proc/sys/net/ipv4/ip_forward*.
    We need to set this value to **`1`**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Kali中IP转发的设置在*/proc/sys/net/ipv4/ip_forward*。我们需要将此值设置为**`1`**。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before we start ARP cache poisoning, note the entry for the Windows XP target
    (192.168.20.10) in the Linux target’s ARP cache. This value will change to the
    MAC address of the Kali machine after we commence ARP cache poisoning.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始ARP缓存中毒之前，请注意Linux目标ARP缓存中Windows XP目标（192.168.20.10）的条目。开始ARP缓存中毒后，这个值将更改为Kali机器的MAC地址。
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ARP Cache Poisoning with Arpspoof
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Arpspoof进行ARP缓存中毒
- en: One easy-to-use tool for ARP cache poisoning is Arpspoof. To use Arpspoof, we
    tell it which network interface to use, the target of our ARP cache poisoning
    attack, and the IP address we would like to masquerade as. (If you leave out the
    target, you’ll poison the entire network.) For our example, to fool the Linux
    target into thinking we are the Windows XP machine, I set the **`-i`** option
    as eth0 to specify the interface, the **`-t`** option as 192.168.20.11 to specify
    the target as the Linux box, and 192.168.20.10 as the Windows XP machine I want
    to pretend to be.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个易于使用的ARP缓存中毒工具是Arpspoof。使用Arpspoof时，我们需要告诉它使用哪个网络接口、ARP缓存中毒攻击的目标是什么，以及我们想要伪装成的IP地址。（如果你不指定目标，它将中毒整个网络。）在我们的示例中，为了让Linux目标误以为我们是Windows
    XP机器，我将**`-i`**选项设置为eth0以指定接口，将**`-t`**选项设置为192.168.20.11来指定目标为Linux机器，将192.168.20.10设置为我想要伪装成的Windows
    XP机器。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Arpspoof immediately starts sending ARP replies to the Linux target, informing
    it that the Windows XP machine is located at the Kali machine’s MAC address. (ARP
    cache entries are updated at varying times among different implementations, but
    one minute is a safe length of time to wait.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Arpspoof立即开始向Linux目标发送ARP响应，通知它Windows XP机器位于Kali机器的MAC地址上。（ARP缓存条目的更新时间在不同实现中有所不同，但等待一分钟是一个安全的时间。）
- en: To capture the other side of the conversation, we need to fool the Windows XP
    machine into sending traffic intended for the Linux target to the Kali machine
    as well. Start another instance of Arpspoof, and this time set the target as the
    Windows XP machine and the recipient as the Linux machine.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获对话的另一端，我们需要让Windows XP机器也将原本应发送到Linux目标的流量发送到Kali机器。启动另一个Arpspoof实例，这次将目标设置为Windows
    XP机器，接收方设置为Linux机器。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once you start ARP cache poisoning, check your Linux target’s ARP cache again.
    Notice that the MAC address associated with the Windows XP target has changed
    to 70:56:81:b2:f0:53\. The Linux target should send all traffic intended for the
    Windows XP target to the Kali machine, where we can capture it in Wireshark.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始ARP缓存中毒，再次检查Linux目标的ARP缓存。请注意，Windows XP目标关联的MAC地址已经更改为70:56:81:b2:f0:53\。Linux目标应该会将所有原本应发送到Windows
    XP目标的流量发送到Kali机器，我们可以在Wireshark中捕获这些流量。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now log in to the Windows XP target’s FTP server from the Linux target using
    another account (see [Example 7-3](ch07.xhtml#logging_in_to_ftp_on_windows_xp_from_the
    "Example 7-3. Logging in to FTP on Windows XP from the Ubuntu target with a user
    account")). (The credentials *georgia:password* will work if you followed my instructions
    in [Chapter 1](ch01.xhtml "Chapter 1. Setting Up Your Virtual Lab"). If you set
    your credentials as something else, use those instead.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从Linux目标使用另一个账户登录Windows XP目标的FTP服务器（参见[示例7-3](ch07.xhtml#logging_in_to_ftp_on_windows_xp_from_the
    "示例7-3. 使用用户账户从Ubuntu目标登录Windows XP的FTP")）。 （如果你按照我在[第1章](ch01.xhtml "第1章. 设置虚拟实验室")中的说明设置了*georgia:password*，那么这个账户可以使用。如果你设置了其他凭据，请使用那些凭据。）
- en: Example 7-3. Logging in to FTP on Windows XP from the Ubuntu target with a user
    account
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例7-3. 使用用户账户从Ubuntu目标登录Windows XP的FTP
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because we have IP forwarding turned on, everything appears to work normally
    as far as our user is concerned. Returning to Wireshark, we see that this time
    we were able to capture the FTP traffic and read the plaintext login credentials.
    The Wireshark output shown in [Figure 7-8](ch07.xhtml#wireshark_captures_the_login_information
    "Figure 7-8. Wireshark captures the login information.") confirms that our Kali
    machine is forwarding the FTP traffic between the two targets. After each FTP
    packet, there is a retransmission packet.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们启用了IP转发，所以从用户的角度来看，一切似乎都正常。回到Wireshark，我们看到这次我们能够捕获FTP流量并读取明文登录凭证。Wireshark显示的输出（见[图7-8](ch07.xhtml#wireshark_captures_the_login_information
    "图7-8. Wireshark捕获登录信息")）确认我们的Kali机器正在转发两台目标之间的FTP流量。在每个FTP数据包后面，都有一个重传数据包。
- en: '![Wireshark captures the login information.](httpatomoreillycomsourcenostarchimages2030370.png.jpg)Figure 7-8. Wireshark
    captures the login information.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![Wireshark捕获登录信息。](httpatomoreillycomsourcenostarchimages2030370.png.jpg)图7-8.
    Wireshark捕获登录信息。'
- en: Using ARP Cache Poisoning to Impersonate the Default Gateway
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ARP 缓存中毒来冒充默认网关
- en: We can also use ARP cache poisoning to impersonate the default gateway on a
    network and access traffic entering and leaving the network, including traffic
    destined for the Internet. Stop the Arpspoof processes you have running, and try
    tricking the Linux target into routing all traffic to the gateway through the
    Kali machine by impersonating the default gateway, as shown here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 ARP 缓存中毒来冒充网络上的默认网关，访问进出网络的流量，包括目标是互联网的流量。停止你正在运行的 Arpspoof 进程，然后尝试通过冒充默认网关，欺骗
    Linux 目标将所有流量路由到 Kali 机器，如下所示。
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we start to browse the Internet from the Linux target, we should see HTTP
    packets being captured by Wireshark. Even if sensitive information is encrypted
    with HTTPS, we’ll still be able to see where users are going and any other information
    sent over HTTP. For example, if we run a Google query, the plaintext of the query
    will be captured in Wireshark, as shown in [Figure 7-9](ch07.xhtml#query_captured_in_wireshark
    "Figure 7-9. Query captured in Wireshark").
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 Linux 目标开始浏览互联网，我们应该能看到 Wireshark 捕获的 HTTP 数据包。即使敏感信息使用 HTTPS 加密，我们仍然可以看到用户访问的站点以及任何通过
    HTTP 发送的其他信息。例如，如果我们运行一个 Google 查询，查询的明文内容将被 Wireshark 捕获，如 [图 7-9](ch07.xhtml#query_captured_in_wireshark
    "图 7-9. 查询被 Wireshark 捕获") 所示。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you use ARP cache poisoning to trick a large network into thinking your pentest
    machine is the default gateway, you may unwittingly cause networking issues. All
    the traffic in a network going through one laptop (or worse, one virtual machine)
    can slow things down to the point of denial of service in some cases.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 ARP 缓存中毒让一个大型网络误认为你的渗透测试机器是默认网关，你可能会不自觉地引发网络问题。所有经过一个笔记本电脑（或者更糟，一个虚拟机）的网络流量，可能会导致某些情况下的服务拒绝，甚至让网络速度变得非常缓慢。
- en: '![Query captured in Wireshark](httpatomoreillycomsourcenostarchimages2030372.png.jpg)Figure 7-9. Query
    captured in Wireshark'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![查询被 Wireshark 捕获](httpatomoreillycomsourcenostarchimages2030372.png.jpg)图
    7-9. 查询被 Wireshark 捕获'
- en: DNS Cache Poisoning
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DNS 缓存中毒
- en: In addition to ARP cache poisoning, we can also poison Domain Name Service (DNS)
    cache entries (mappings from domain names to IP addresses) to route traffic intended
    for another website to one we control. Just as ARP resolves IP to MAC addresses
    to properly route traffic, DNS maps (or resolves) domain names such as *[www.gmail.com](http://www.gmail.com)*
    to IP addresses.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 ARP 缓存中毒，我们还可以中毒域名服务（DNS）缓存条目（即从域名到 IP 地址的映射），将原本应该访问其他网站的流量引导到我们控制的网站。就像
    ARP 将 IP 地址解析为 MAC 地址以正确路由流量一样，DNS 将域名（例如 *[www.gmail.com](http://www.gmail.com)*）解析为
    IP 地址。
- en: To reach another system on the Internet or local network, our machine needs
    to know the IP address to connect to. It is easy to remember the URL *[www.gmail.com](http://www.gmail.com)*
    if we want to visit our web mail account, but it’s difficult to remember a bunch
    of IP addresses, which may even change regularly. DNS resolution translates the
    human-readable domain name into an IP address. For example, we can use the tool
    Nslookup to translate *[www.gmail.com](http://www.gmail.com)* into an IP address,
    as shown in [Example 7-4](ch07.xhtml#nslookup_dns_resolution "Example 7-4. Nslookup
    DNS resolution").
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问互联网上或本地网络中的另一个系统，我们的机器需要知道要连接的 IP 地址。如果我们想访问我们的网页邮件账户，记住 URL *[www.gmail.com](http://www.gmail.com)*
    很容易，但记住一堆 IP 地址就很困难，而且这些地址可能会定期更改。DNS 解析将人类可读的域名转换为 IP 地址。例如，我们可以使用工具 Nslookup
    将 *[www.gmail.com](http://www.gmail.com)* 转换为 IP 地址，如 [示例 7-4](ch07.xhtml#nslookup_dns_resolution
    "示例 7-4. Nslookup DNS 解析") 所示。
- en: Example 7-4. Nslookup DNS resolution
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-4. Nslookup DNS 解析
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, Nslookup translates *[www.gmail.com](http://www.gmail.com)*
    to a number of IP addresses, including 173.194.37.85 and 173.194.37.86, all of
    which we can use to reach Gmail. To perform DNS resolution ([Figure 7-10](ch07.xhtml#dns_resolution
    "Figure 7-10. DNS resolution")), our system queries its local DNS server for information
    about a specific domain name, such as *[www.gmail.com](http://www.gmail.com)*.
    If the DNS server has a cache entry for the address, it gives our system the correct
    IP address. If not, it contacts other DNS servers on the Internet looking for
    the correct information.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Nslookup 将* [www.gmail.com](http://www.gmail.com) *转换为多个 IP 地址，包括 173.194.37.85
    和 173.194.37.86，我们可以使用这些地址访问 Gmail。为了执行 DNS 解析（[图 7-10](ch07.xhtml#dns_resolution
    "图 7-10. DNS 解析")），我们的系统查询其本地 DNS 服务器以获取有关特定域名的信息，如* [www.gmail.com](http://www.gmail.com)
    *。如果 DNS 服务器有该地址的缓存条目，它会返回正确的 IP 地址。如果没有，它会联系互联网上的其他 DNS 服务器寻找正确的信息。
- en: When the correct IP address is returned, the DNS server writes back to our machine
    with the correct IP address resolution for *[www.gmail.com](http://www.gmail.com)*,
    and our system then translates *[www.gmail.com](http://www.gmail.com)* into 173.194.37.85,
    as shown in [Example 7-4](ch07.xhtml#nslookup_dns_resolution "Example 7-4. Nslookup
    DNS resolution"). Users can then access *[www.gmail.com](http://www.gmail.com)*
    by name without having to use the IP address.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回正确的 IP 地址时，DNS 服务器会将正确的 IP 地址解析结果写回我们的机器，对于* [www.gmail.com](http://www.gmail.com)
    *，我们的系统随后将* [www.gmail.com](http://www.gmail.com) *转换为 173.194.37.85，如[示例 7-4](ch07.xhtml#nslookup_dns_resolution
    "示例 7-4. Nslookup DNS 解析")所示。用户然后可以通过名称访问* [www.gmail.com](http://www.gmail.com)
    *，无需使用 IP 地址。
- en: '![DNS resolution](httpatomoreillycomsourcenostarchimages2030374.png.jpg)Figure 7-10. DNS
    resolution'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![DNS 解析](httpatomoreillycomsourcenostarchimages2030374.png.jpg)图 7-10. DNS
    解析'
- en: Getting Started
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入门
- en: 'DNS cache poisoning works like ARP cache poisoning: We send a bunch of bogus
    DNS resolution replies pointing to the wrong IP address for a domain name.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 缓存中毒的工作原理类似于 ARP 缓存中毒：我们发送一系列虚假的 DNS 解析回复，将域名指向错误的 IP 地址。
- en: Now make sure the Apache server is running with the command `service apache2
    start`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在确保 Apache 服务器正在运行，使用命令`service apache2 start`。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Before we use a DNS cache poisoning tool, we need to create a file that specifies
    which DNS names we would like to spoof and where to send traffic. For example,
    let’s tell any system that runs a DNS resolution for *[www.gmail.com](http://www.gmail.com)*
    that that domain’s IP address is our Kali machine by adding the entry `192.168.20.9
    www.gmail.com` to a new file called *hosts.txt*. (You can name the file anything
    you like.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 DNS 缓存中毒工具之前，我们需要创建一个文件，指定我们希望伪造的 DNS 名称以及流量的发送位置。例如，让我们告诉任何进行 DNS 解析的系统，对于*
    [www.gmail.com](http://www.gmail.com) *，该域名的 IP 地址是我们的 Kali 机器，通过将条目`192.168.20.9
    www.gmail.com`添加到一个名为*hosts.txt*的新文件中。（你可以随意命名文件。）
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using Dnsspoof
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Dnsspoof
- en: Restart Arpspoof between the Linux target and the default gateway and vice versa
    as discussed in [Using ARP Cache Poisoning to Impersonate the Default Gateway](ch07.xhtml#using_arp_cache_poisoning_to_impersonate
    "Using ARP Cache Poisoning to Impersonate the Default Gateway"). Now we can start
    sending DNS cache poisoning attempts using the Dnsspoof DNS spoofing tool, as
    shown here.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 目标机和默认网关之间重新启动 Arpspoof，反之亦然，正如[使用 ARP 缓存中毒伪装默认网关](ch07.xhtml#using_arp_cache_poisoning_to_impersonate
    "使用 ARP 缓存中毒伪装默认网关")中所讨论的那样。现在我们可以开始使用 Dnsspoof DNS 伪造工具发送 DNS 缓存中毒尝试，如下所示。
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We specify the network interface ❶ to use, and point Dnsspoof to the file (*hosts.txt*)
    we just created ❷ telling it which values to spoof.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定要使用的网络接口❶，并将 Dnsspoof 指向我们刚刚创建的文件（*hosts.txt*）❷，告诉它需要伪造哪些值。
- en: Once Dnsspoof is running, when we run the `nslookup` command from our Linux
    target, the IP address returned should be our Kali machine’s, as shown in [Example 7-5](ch07.xhtml#nslookup_after_attack
    "Example 7-5. Nslookup after attack"). This is clearly not the real IP address
    for Gmail.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Dnsspoof 运行，当我们在 Linux 目标机上执行`nslookup`命令时，返回的 IP 地址应该是我们的 Kali 机器的地址，如[示例
    7-5](ch07.xhtml#nslookup_after_attack "示例 7-5. 攻击后的 Nslookup")所示。这显然不是 Gmail 的真实
    IP 地址。
- en: Example 7-5. Nslookup after attack
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-5. 攻击后的 Nslookup
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To demonstrate this attack, set up a website to direct traffic to. The Apache
    server in Kali will by default serve an “It Works” page to anyone who visits it.
    We can change the contents of the *index.html* file in the folder */var/www*,
    but the default “It Works” text is fine for our purposes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个攻击，设置一个网站来引导流量。Kali 中的 Apache 服务器默认会为任何访问者提供一个 “It Works” 页面。我们可以更改文件夹
    */var/www* 中 *index.html* 文件的内容，但默认的 “It Works” 文本对于我们的目的来说已经足够。
- en: Now if we browse to *[http://www.gmail.com/](http://www.gmail.com/)* from the
    Ubuntu target, the URL bar should say *[http://www.gmail.com/](http://www.gmail.com/)*,
    but we’re actually at our Kali machine’s web server, as shown in [Figure 7-11](ch07.xhtml#this_isnapostrophet_gmaildot
    "Figure 7-11. This isn’t Gmail."). We can even make this attack more interesting
    by cloning the actual Gmail website (or any other site the attacker chooses) so
    the user won’t notice the difference.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们从 Ubuntu 目标浏览 *[http://www.gmail.com/](http://www.gmail.com/)*，网址栏应该显示
    *[http://www.gmail.com/](http://www.gmail.com/)*，但实际上我们访问的是 Kali 机器的网页服务器，如 [图
    7-11](ch07.xhtml#this_isnapostrophet_gmaildot "图 7-11. 这不是 Gmail。") 所示。我们甚至可以通过克隆实际的
    Gmail 网站（或攻击者选择的任何其他网站），让用户无法察觉差异，从而使这个攻击更加有趣。
- en: '![This isn’t Gmail.](httpatomoreillycomsourcenostarchimages2030376.png.jpg)Figure 7-11. This
    isn’t Gmail.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![这不是 Gmail。](httpatomoreillycomsourcenostarchimages2030376.png.jpg)图 7-11.
    这不是 Gmail。'
- en: SSL Attacks
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL 攻击
- en: So far, we’ve been able to intercept encrypted traffic, but we haven’t been
    able to get any sensitive information out of the encrypted connection. For this
    next attack, we’ll rely on a user’s willingness to click past an SSL certificate
    warning to perform a man-in-the-middle attack and get the plaintext out of a Secure
    Sockets Layer (SSL) connection, which encrypts traffic to protect it from being
    read by an eavesdropper.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够拦截加密流量，但还无法从加密连接中获取任何敏感信息。对于下一个攻击，我们将依赖用户愿意点击通过 SSL 证书警告，执行中间人攻击并从
    SSL 连接中获取明文，而 SSL 连接用于加密流量，以防止被窃听者读取。
- en: SSL Basics
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSL 基础
- en: The goal of SSL is to provide reasonable assurance that any sensitive information
    (such as credentials or credit card numbers) transmitted between a user’s browser
    and a server is secure—unable to be read by a malicious entity along the way.
    To prove that the connection is secure, SSL uses certificates. When you browse
    to an SSL-enabled site, your browser asks the site to identify itself with its
    SSL certificate. The site presents its certificate, which your browser verifies.
    If your browser accepts the certificate, it informs the server, the server returns
    a digitally signed acknowledgment, and SSL-secured communication begins.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SSL 的目标是提供合理的保障，确保在用户的浏览器与服务器之间传输的任何敏感信息（如凭证或信用卡号码）都是安全的——在传输过程中不会被恶意实体读取。为了证明连接是安全的，SSL
    使用证书。当你浏览到一个启用了 SSL 的网站时，浏览器会要求该网站用 SSL 证书来证明其身份。该网站提供证书，浏览器进行验证。如果浏览器接受证书，它会通知服务器，服务器会返回一个数字签名的确认，然后
    SSL 安全通信开始。
- en: An SSL certificate includes an encryption key pair as well as identifying information,
    such as the domain name and the name of the company that owns the site. A server’s
    SSL certificate is generally vouched for by a certificate authority (CA) such
    as VeriSign or Thawte. Browsers come preinstalled with a list of trusted CAs,
    and if a server’s SSL certificate is vouched for by a trusted CA, the browser
    can create a secure connection. If the certificate is untrusted, the user will
    be presented with a warning that basically says, “The connection might be secure,
    but it might not be. Proceed at your own risk.”
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 SSL 证书包括一对加密密钥以及标识信息，如域名和拥有该网站的公司名称。服务器的 SSL 证书通常由证书颁发机构（CA）如 VeriSign 或
    Thawte 进行认证。浏览器预装了一个受信任的 CA 列表，如果服务器的 SSL 证书得到受信任 CA 的认证，浏览器就可以建立安全连接。如果证书不被信任，用户将看到一个警告，基本意思是：“连接可能是安全的，但也可能不是。请自行决定是否继续。”
- en: Using Ettercap for SSL Man-in-the-Middle Attacks
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Ettercap 进行 SSL 中间人攻击
- en: In our ARP cache poisoning attack, we man-in-the-middled the traffic between
    our Windows XP and Ubuntu targets (as well as the Ubuntu target and the Internet).
    These systems were still able to communicate with each other, but our Kali system
    was able to capture the traffic. We can do the same thing to attack SSL traffic.
    We can break the secure SSL connection by redirecting traffic to and from *[www.facebook.com](http://www.facebook.com)*
    to our Kali system so we can intercept sensitive information.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we’ll use Ettercap, a multifunction suite for man-in-the-middle
    attacks that, in addition to SSL attacks, can also complete all of the attacks
    we have performed so far with Arpspoof and Dnsspoof. Turn off any other spoofing
    tools before starting Ettercap. See [Ettercap](ch01.xhtml#ettercap "Ettercap")
    for configuration instructions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Ettercap has multiple interfaces, but we will use the `-T` option for the text-based
    interface in this example. Use the `-M` option with `arp:remote /` *`gateway`*`/
    /`*`target`*`/` to set up an ARP cache poisoning attack between the default gateway
    and the Linux target, as shown next. The actual attack will work the same way
    as our previous exercise with Arpspoof.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With Ettercap running, we just wait for users to start interacting with SSL-based
    web servers. Switch over to your Linux target, and attempt to log in to a website
    using SSL. You should be greeted with a certificate warning like the one in [Figure 7-12](ch07.xhtml#facebook_cannot_be_verifieddot
    "Figure 7-12. Facebook cannot be verified.").
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a man-in-the-middle attack, the SSL session’s security cannot
    be verified. The certificate Ettercap presents isn’t valid for *[www.facebook.com](http://www.facebook.com)*,
    so the trust is broken, as illustrated in [Figure 7-13](ch07.xhtml#ssl_man-in-the-middle_attack
    "Figure 7-13. SSL man-in-the-middle attack").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'But security warnings don’t stop all users. If we click through the warning
    and enter our credentials, Ettercap will grab them in plaintext before forwarding
    them on to the server, as shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Facebook cannot be verified.](httpatomoreillycomsourcenostarchimages2030378.png.jpg)Figure 7-12. Facebook
    cannot be verified.![SSL man-in-the-middle attack](httpatomoreillycomsourcenostarchimages2030380.png.jpg)Figure 7-13. SSL
    man-in-the-middle attack'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: SSL Stripping
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, the trouble with SSL man-in-the-middle attacks is that users have
    to click through the SSL certificate warning. Depending on the browser, this can
    be an involved process that is difficult, if not impossible, for a user to ignore.
    Most readers can probably think of a time they clicked through a security warning
    and continued to the page despite their better judgment. (Case in point: Our default
    Nessus install uses Tenable’s self-signed certificate, which throws a certificate
    error when you browse to the web interface. If you chose to follow along with
    that example, you most likely decided to click through the warning.)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to say how effective certificate warnings are at stopping users
    from visiting HTTPS sites without valid certificates. I have run social-engineering
    tests that employed self-signed SSL certificates, and the success rate has been
    significantly lower than those with valid certificates or those that don’t use
    HTTPS. Though some users did click through and visit the sites, a more sophisticated
    attack would allow us to capture information in plaintext without triggering those
    obvious warnings that the SSL connection is compromised.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: With SSL stripping, we man-in-the-middle the HTTP connection before it is redirected
    to SSL and add SSL functionality before sending the packets on to the web server.
    When the web server replies, SSL stripping again intercepts the traffic and removes
    the HTTPS tags before sending the packets to the client. This technique is illustrated
    in [Figure 7-14](ch07.xhtml#ssl_stripping_attack "Figure 7-14. SSL stripping attack").
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![SSL stripping attack](httpatomoreillycomsourcenostarchimages2030382.png.jpg)Figure 7-14. SSL
    stripping attack'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Moxie Marlinspike, the author of SSLstrip, called certificate warnings *negative
    feedback*, as opposed to *positive feedback* that a session is valid, such as
    seeing HTTPS in the browser URL bar. Avoiding this negative feedback is much more
    important to an attack’s success than including positive feedback because users
    are naturally less likely to notice that a URL says HTTP instead of HTTPS than
    they are a giant certificate warning they have to actively click through. SSL
    stripping avoids the certificate warning by again man-in-the-middling the connection.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Users typically encounter HTTPS either through clicking links or through HTTP
    302 redirects. Most users don’t enter *[https://www.facebook.com](https://www.facebook.com)*
    or even *[http://www.facebook.com](http://www.facebook.com)* into their browsers;
    they type *[www.facebook.com](http://www.facebook.com)* or sometimes just *facebook.com.*
    And that’s why this attack is possible. SSLstrip adds the HTTPS itself and thus
    the SSL connection between Facebook and Kali is valid. SSLstrip just turns the
    connection back to HTTP to send to the original requester. There is no certificate
    warning.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Using SSLstrip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tool SSLstrip implements SSL stripping. Before we start it, we need to set
    an Iptables rule to pass traffic that is headed to port 80 through SSLstrip. We’ll
    run SSLstrip on port 8080, as shown next, then restart Arpspoof and spoof the
    default gateway. (For instructions, jump back to [Using ARP Cache Poisoning to
    Impersonate the Default Gateway](ch07.xhtml#using_arp_cache_poisoning_to_impersonate
    "Using ARP Cache Poisoning to Impersonate the Default Gateway").)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now start SSLstrip, and tell it to listen on port 8080 with the `-l` flag.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, browse to a site that uses SSL (try any Internet site that requires login
    credentials) from your Linux target, like the Twitter login page shown in [Figure 7-15](ch07.xhtml#twitter_login_page_with_sslstrip_running
    "Figure 7-15. Twitter login page with SSLstrip running"). As you can see, HTTP
    has replaced HTTPS in the address bar.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: When you log in, your credentials will be reported in plaintext by SSLstrip.
    (No, my Twitter password isn’t really “password.”)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: This attack is more sophisticated than a straight SSL man-in-the-middle attack.
    We are able to avoid the certificate warning because the server is completing
    an SSL connection with SSLstrip rather than the browser.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, SSLstrip reports the entered credentials (*georgiaweidman:
    password*) in plaintext.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Twitter login page with SSLstrip running](httpatomoreillycomsourcenostarchimages2030384.png.jpg)Figure 7-15. Twitter
    login page with SSLstrip running'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we’ve fiddled with network traffic to create some interesting
    results. Using various tools and techniques, we were able to intercept traffic
    that we had no business seeing in a switched network. We used ARP cache poisoning
    to redirect traffic in a switched network to our Kali system and DNS cache poisoning
    to redirect users to our web servers. We used Ettercap to automate an SSL man-in-the-middle
    attack and (assuming that the user clicks through a warning) capture sensitive
    information in plaintext. Finally, we made the attack even more sophisticated
    by avoiding an invalid certificate warning using SSL stripping.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Capturing traffic from the local network can glean useful information for our
    pentest. For example, we were able to capture valid credentials for the FTP server
    for use in exploitation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of exploitation, let’s get started.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
