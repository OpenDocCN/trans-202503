- en: Chapter 14. File Systems
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14章. 文件系统
- en: 'In [Chapter 4](ch04.html "Chapter 4. File I/O: The Universal I/O Model"), [Chapter 5](ch05.html
    "Chapter 5. File I/O: Further Details"), and [Chapter 13](ch13.html "Chapter 13. File
    I/O Buffering"), we looked at file I/O, with a particular focus on regular (i.e.,
    disk) files. In this and the following chapters, we go into detail on a range
    of file-related topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章. 文件I/O：通用I/O模型")、[第5章](ch05.html "第5章. 文件I/O：更多细节")和[第13章](ch13.html
    "第13章. 文件I/O缓存")中，我们探讨了文件I/O，特别关注了常规（即磁盘）文件。在本章及接下来的章节中，我们将详细讨论一系列与文件相关的主题：
- en: This chapter looks at file systems.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章介绍了文件系统。
- en: '[Chapter 15](ch15.html "Chapter 15. File Attributes") describes various attributes
    associated with a file, including the timestamps, ownership, and permissions.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第15章](ch15.html "第15章. 文件属性")描述了与文件相关的各种属性，包括时间戳、所有权和权限。'
- en: '[Chapter 16](ch16.html "Chapter 16. Extended Attributes") and 17 consider two
    new features of Linux 2.6: extended attributes and access control lists (ACLs).
    Extended attributes are a method of associating arbitrary metadata with a file.
    ACLs are an extension of the traditional UNIX file permission model.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第16章](ch16.html "第16章. 扩展属性")和第17章探讨了Linux 2.6的两个新特性：扩展属性和访问控制列表（ACLs）。扩展属性是一种将任意元数据与文件关联的方法。ACLs是对传统UNIX文件权限模型的扩展。'
- en: '[Chapter 18](ch18.html "Chapter 18. Directories and Links") looks at directories
    and links.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第18章](ch18.html "第18章. 目录和链接")探讨了目录和链接。'
- en: The majority of this chapter is concerned with file systems, which are organized
    collections of files and directories. We explain a range of file-system concepts,
    sometimes using the traditional Linux *ext2* file system as a specific example.
    We also briefly describe some of the journaling file systems available on Linux.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容涉及文件系统，文件系统是组织文件和目录的集合。我们解释了一系列文件系统的概念，有时以传统的Linux *ext2*文件系统作为具体示例。我们还简要描述了Linux上可用的一些日志文件系统。
- en: We conclude the chapter with a discussion of the system calls used to mount
    and unmount a file system, and the library functions used to obtain information
    about mounted file systems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后讨论了用于挂载和卸载文件系统的系统调用，以及用于获取已挂载文件系统信息的库函数。
- en: Device Special Files (Devices)
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备特殊文件（设备）
- en: This chapter frequently mentions disk devices, so we start with a brief overview
    of the concept of a device file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章频繁提到磁盘设备，因此我们首先简要概述一下设备文件的概念。
- en: A device special file corresponds to a device on the system. Within the kernel,
    each device type has a corresponding device driver, which handles all I/O requests
    for the device. A *device driver* is a unit of kernel code that implements a set
    of operations that (normally) correspond to input and output actions on an associated
    piece of hardware. The API provided by device drivers is fixed, and includes operations
    corresponding to the system calls *open()*, *close()*, *read()*, *write()*, *mmap()*,
    and *ioctl()*. The fact that each device driver provides a consistent interface,
    hiding the differences in operation of individual devices, allows for *universality
    of I/O* ([Universality of I/O](ch04.html#universality_of_i_solidus_o "Universality
    of I/O")).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设备特殊文件对应系统中的设备。在内核中，每种设备类型都有一个相应的设备驱动程序，负责处理该设备的所有I/O请求。*设备驱动程序*是内核代码的一部分，实现了一组操作，这些操作通常对应于与关联硬件进行输入输出操作。设备驱动程序提供的API是固定的，包括与系统调用*open()*、*close()*、*read()*、*write()*、*mmap()*和*ioctl()*对应的操作。每个设备驱动程序提供一致的接口，隐藏了各个设备操作的差异，从而实现了*I/O的通用性*（[I/O的通用性](ch04.html#universality_of_i_solidus_o
    "I/O的通用性")）。
- en: Some devices are real, such as mice, disks, and tape drives. Others are *virtual*,
    meaning that there is no corresponding hardware; rather, the kernel provides (via
    a device driver) an abstract device with an API that is the same as a real device.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设备是真实的，例如鼠标、磁盘和磁带驱动器。其他设备是*虚拟的*，意味着没有对应的硬件；相反，内核通过设备驱动程序提供一个抽象设备，其API与真实设备相同。
- en: 'Devices can be divided into two types:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 设备可以分为两种类型：
- en: '*Character devices* handle data on a character-by-character basis. Terminals
    and keyboards are examples of character devices.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字符设备*按字符逐个处理数据。终端和键盘是字符设备的例子。'
- en: '*Block devices* handle data a block at a time. The size of a block depends
    on the type of device, but is typically some multiple of 512 bytes. Examples of
    block devices include disks and tape drives.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*块设备*一次处理一个数据块。块的大小取决于设备类型，但通常是512字节的倍数。块设备的例子包括磁盘和磁带驱动器。'
- en: Device files appear within the file system, just like other files, usually under
    the `/dev` directory. The superuser can create a device file using the *mknod*
    command, and the same task can be performed in a privileged (`CAP_MKNOD`) program
    using the *mknod()* system call.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 设备文件出现在文件系统中，就像其他文件一样，通常位于`/dev`目录下。超级用户可以使用*mknod*命令创建设备文件，同样的任务也可以在具有特权的（`CAP_MKNOD`）程序中使用*mknod()*系统调用来完成。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t describe the *mknod()* (“make file-system i-node”) system call in detail
    since its use is straightforward, and the only purpose for which it is required
    nowadays is to create device files, which is not a common application requirement.
    We can also use *mknod()* to create FIFOs ([FIFOs](ch44.html#fifos "FIFOs")),
    but the *mkfifo()* function is preferred for this task. Historically, some UNIX
    implementations also used *mknod()* for creating directories, but this use has
    now been replaced by the *mkdir()* system call. Nevertheless, some UNIX implementations—but
    not Linux—preserve this capability in *mknod()* for backward compatibility. See
    the *mknod(2)* manual page for further details.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细描述*mknod()*（“创建文件系统 i-node”）系统调用，因为它的使用非常直接，而且如今唯一需要它的目的就是创建设备文件，这并不是一个常见的应用需求。我们也可以使用*mknod()*来创建FIFO（[FIFO](ch44.html#fifos
    "FIFO")），但在这项任务中，*mkfifo()*函数更为推荐。从历史上看，一些UNIX实现也使用*mknod()*来创建目录，但现在这一用法已被*mkdir()*系统调用所取代。然而，一些UNIX实现——但不是Linux——为了向后兼容，仍保留了*mknod()*中的此功能。有关详细信息，请参见*mknod(2)*手册页。
- en: In earlier versions of Linux, `/dev` contained entries for all possible devices
    on the system, even if such devices weren’t actually connected to the system.
    This meant that `/dev` could contain literally thousands of unused entries, slowing
    the task of programs that needed to scan the contents of that directory, and making
    it impossible to use the contents of the directory as a means of discovering which
    devices were actually present on the system. In Linux 2.6, these problems are
    solved by the *udev* program. The *udev* program relies on the *sysfs* file system,
    which exports information about devices and other kernel objects into user space
    via a pseudo-file system mounted under `/sys`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本的Linux中，`/dev`包含系统上所有可能设备的条目，即使这些设备实际上并未连接到系统。这意味着`/dev`可能包含成千上万的未使用条目，从而减慢了需要扫描该目录内容的程序的任务，并且使得无法将目录内容作为发现哪些设备实际存在于系统中的手段。在Linux
    2.6中，这些问题通过*udev*程序得到解决。*udev*程序依赖于*sysfs*文件系统，它通过挂载在`/sys`下的伪文件系统将关于设备和其他内核对象的信息导出到用户空间。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[Kroah-Hartman, 2003] provides an overview of *udev*, and outlines the reasons
    it is considered superior to *devfs*, the Linux 2.4 solution to the same problems.
    Information about the *sysfs* file system can be found in the Linux 2.6 kernel
    source file `Documentation/filesystems/sysfs.txt` and in [Mochel, 2005].'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kroah-Hartman, 2003]提供了关于*udev*的概述，并概述了它为何被认为优于*devfs*，即Linux 2.4解决相同问题的方案。有关*sysfs*文件系统的信息可以在Linux
    2.6内核源文件`Documentation/filesystems/sysfs.txt`中找到，并在[Mochel, 2005]中提供。'
- en: Device IDs
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设备 ID
- en: Each device file has a *major ID number* and a *minor ID number*. The major
    ID identifies the general class of device, and is used by the kernel to look up
    the appropriate driver for this type of device. The minor ID uniquely identifies
    a particular device within a general class. The major and minor IDs of a device
    file are displayed by the *ls -l* command.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备文件都有一个*主 ID 数字*和一个*次 ID 数字*。主 ID标识设备的大类，并由内核用于查找该类型设备的适当驱动程序。次 ID唯一标识大类中的特定设备。设备文件的主
    ID 和次 ID 可以通过*ls -l*命令显示。
- en: A device’s major and minor IDs are recorded in the i-node for the device file.
    (We describe i-nodes in Section 14.4.) Each device driver registers its association
    with a specific major device ID, and this association provides the connection
    between the device special file and the device driver. The name of the device
    file has no relevance when the kernel looks for the device driver.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的主 ID 和次 ID 会记录在设备文件的 i-node 中。（我们在第14.4节描述了 i-node。）每个设备驱动程序都会注册其与特定主设备 ID
    的关联，而这种关联提供了设备特殊文件与设备驱动程序之间的连接。当内核查找设备驱动程序时，设备文件的名称并不重要。
- en: On Linux 2.4 and earlier, the total number of devices on the system is limited
    by the fact that device major and minor IDs are each represented using just 8
    bits. The fact that major device IDs are fixed and centrally assigned (by the
    Linux Assigned Names and Numbers Authority; see [http://www.lanana.org/](http://www.lanana.org/))
    further exacerbates this limitation. Linux 2.6 eases this limitation by using
    more bits to hold the major and minor device IDs (respectively, 12 and 20 bits).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 2.4 及更早版本中，系统上的设备总数受到限制，因为设备的主次 ID 各自仅使用 8 位表示。由于主设备 ID 是固定的，并由 Linux
    分配名称和编号机构（参见 [http://www.lanana.org/](http://www.lanana.org/)）集中分配，这进一步加剧了这个限制。Linux
    2.6 通过使用更多的位来表示主次设备 ID（分别是 12 位和 20 位），缓解了这个限制。
- en: Disks and Partitions
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磁盘和分区
- en: Regular files and directories typically reside on hard disk devices. (Files
    and directories may also exist on other devices, such as CD-ROMs, flash memory
    cards, and virtual disks, but for the present discussion, we are interested primarily
    in hard disk devices.) In the following sections, we look at how disks are organized
    and divided into partitions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 常规文件和目录通常存储在硬盘设备上。（文件和目录也可以存储在其他设备上，如 CD-ROM、闪存卡和虚拟磁盘，但在本讨论中，我们主要关注硬盘设备。）在接下来的章节中，我们将讨论磁盘是如何组织和分区的。
- en: Disk drives
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 磁盘驱动器
- en: A hard disk drive is a mechanical device consisting of one or more platters
    that rotate at high speed (of the order of thousands of revolutions per minute).
    Magnetically encoded information on the disk surface is retrieved or modified
    by read/write heads that move radially across the disk. Physically, information
    on the disk surface is located on a set of concentric circles called *tracks*.
    Tracks themselves are divided into a number of *sectors*, each of which consists
    of a series of *physical* blocks. Physical blocks are typically 512 bytes (or
    some multiple thereof) in size, and represent the smallest unit of information
    that the drive can read or write.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘驱动器是一个机械设备，由一个或多个以高速旋转的盘片组成（转速大约是每分钟几千转）。磁盘表面上磁性编码的信息通过读写头来检索或修改，读写头会沿着磁盘径向移动。从物理上讲，磁盘表面上的信息位于一组同心圆上，这些圆被称为
    *磁道*。磁道本身被划分为若干个 *扇区*，每个扇区由一系列 *物理* 块组成。物理块的大小通常为 512 字节（或其倍数），它们代表了驱动器可以读取或写入的最小信息单位。
- en: Although modern disks are fast, reading and writing information on the disk
    still takes significant time. The disk head must first move to the appropriate
    track (seek time), then the drive must wait until the appropriate sector rotates
    under the head (rotational latency), and finally the required blocks must be transferred
    (transfer time). The total time required to carry out such an operation is typically
    of the order of milliseconds. By comparison, modern CPUs are capable of executing
    millions of instructions in this time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现代磁盘非常快速，但读取和写入磁盘上的信息仍然需要相当长的时间。磁盘头首先必须移动到适当的磁道（寻道时间），然后驱动器必须等待直到适当的扇区转动到磁头下方（旋转延迟），最后需要的块必须被传输（传输时间）。完成此操作所需的总时间通常是以毫秒为单位的。相比之下，现代
    CPU 在这个时间内能够执行数百万条指令。
- en: Disk partitions
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 磁盘分区
- en: Each disk is divided into one or more (nonoverlapping) *partitions*. Each partition
    is treated by the kernel as a separate device residing under the `/dev` directory.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个磁盘被划分为一个或多个（不重叠的）*分区*。每个分区都被内核视为一个独立的设备，位于 `/dev` 目录下。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The system administrator determines the number, type, and size of partitions
    on a disk using the *fdisk* command. The command *fdisk -l* lists all partitions
    on a disk. The Linux-specific `/proc/partitions` file lists the major and minor
    device numbers, size, and name of each disk partition on the system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员通过使用 *fdisk* 命令来决定磁盘的分区数量、类型和大小。命令 *fdisk -l* 会列出磁盘上的所有分区。Linux 特有的 `/proc/partitions`
    文件列出了系统上每个磁盘分区的主次设备编号、大小和名称。
- en: 'A disk partition may hold any type of information, but usually contains one
    of the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘分区可以存储任何类型的信息，但通常包含以下之一：
- en: a *file system* holding regular files and directories, as described in [File
    Systems](ch14.html#file_systems-id1 "File Systems");
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *文件系统* 用于存储常规文件和目录，如在 [文件系统](ch14.html#file_systems-id1 "File Systems") 中所述；
- en: 'a *data area* accessed as a raw-mode device, as described in [Bypassing the
    Buffer Cache: Direct I/O](ch13.html#bypassing_the_buffer_cache_colon_direct "Bypassing
    the Buffer Cache: Direct I/O") (some database management systems use this technique);
    or'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为原始模式设备访问的 *数据区*，如在 [绕过缓冲区缓存：直接I/O](ch13.html#bypassing_the_buffer_cache_colon_direct
    "绕过缓冲区缓存：直接I/O") 中所描述（一些数据库管理系统使用此技术）；或者
- en: a *swap area* used by the kernel for memory management.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由内核用于内存管理的 *交换区*。
- en: A swap area is created using the *mkswap(8)* command. A privileged (`CAP_SYS_ADMIN`)
    process can use the *swapon()* system call to notify the kernel that a disk partition
    is to be used as a swap area. The *swapoff()* system call performs the converse
    function, telling the kernel to cease using a disk partition as a swap area. These
    system calls are not standardized in SUSv3, but they exist on many UNIX implementations.
    See the *swapon(2)*, and *swapon(8)* manual pages for additional information.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*mkswap(8)* 命令用于创建交换区。一个特权 (`CAP_SYS_ADMIN`) 进程可以使用 *swapon()* 系统调用通知内核某个磁盘分区将作为交换区使用。*swapoff()*
    系统调用则执行相反的功能，告诉内核停止使用磁盘分区作为交换区。这些系统调用在SUSv3中并未标准化，但在许多UNIX实现中存在。有关更多信息，请参见 *swapon(2)*
    和 *swapon(8)* 手册页。'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Linux-specific `/proc/swaps` file can be used to display information about
    the currently enabled swap areas on the system. This information includes the
    size of each swap area and the amount of the area that is in use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Linux特有的 `/proc/swaps` 文件可以用来显示当前启用的交换区的信息。该信息包括每个交换区的大小以及已使用的部分。
- en: File Systems
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统
- en: A file system is an organized collection of regular files and directories. A
    file system is created using the *mkfs* command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统是由常规文件和目录组成的有组织的集合。文件系统是通过 *mkfs* 命令创建的。
- en: 'One of the strengths of Linux is that it supports a wide variety of file systems,
    including the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的一个优点是它支持各种各样的文件系统，包括以下几种：
- en: the traditional *ext2* file system;
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的 *ext2* 文件系统；
- en: various native UNIX file systems such as the Minix, System V, and BSD file systems;
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种本地UNIX文件系统，如Minix、System V和BSD文件系统；
- en: Microsoft’s FAT, FAT32, and NTFS file systems;
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft的FAT、FAT32和NTFS文件系统；
- en: the ISO 9660 CD-ROM file system;
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO 9660 CD-ROM文件系统；
- en: Apple Macintosh’s HFS;
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果Macintosh的HFS；
- en: a range of network file systems, including Sun’s widely used NFS (information
    about the Linux implementation of NFS is available at [http://nfs.sourceforge.net/](http://nfs.sourceforge.net/)),
    IBM and Microsoft’s SMB, Novell’s NCP, and the Coda file system developed at Carnegie
    Mellon University; and
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列网络文件系统，包括Sun公司广泛使用的NFS（关于Linux上NFS的实现信息可在 [http://nfs.sourceforge.net/](http://nfs.sourceforge.net/)
    查阅），IBM和Microsoft的SMB，Novell的NCP，以及卡内基梅隆大学开发的Coda文件系统；并且
- en: a range of journaling file systems, including *ext3*, *ext4*, *Reiserfs*, *JFS*,
    *XFS*, and *Btrfs*.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列日志文件系统，包括 *ext3*、*ext4*、*Reiserfs*、*JFS*、*XFS* 和 *Btrfs*。
- en: The file-system types currently known by the kernel can be viewed in the Linux-specific
    `/proc/filesystems` file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当前内核已知的文件系统类型可以在Linux特有的 `/proc/filesystems` 文件中查看。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Linux 2.6.14 added the *Filesystem in Userspace* (FUSE) facility. This mechanism
    adds hooks to the kernel that allow a file system to be completely implemented
    via a user-space program, without needing to patch or recompile the kernel. For
    further details, see [http://fuse.sourceforge.net/](http://fuse.sourceforge.net/).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6.14 增加了 *Filesystem in Userspace*（FUSE）功能。该机制为内核添加了钩子，允许通过用户空间程序完全实现文件系统，而无需打补丁或重新编译内核。更多详细信息，请参见
    [http://fuse.sourceforge.net/](http://fuse.sourceforge.net/)。
- en: The *ext2* file system
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*ext2* 文件系统'
- en: For many years, the most widely used file system on Linux was *ext2*, the *Second
    Extended File System*, which is the successor to the original Linux file system,
    *ext*. In more recent times, the use of *ext2* has declined in favor of various
    journaling file systems. Sometimes, it is useful to describe generic file-system
    concepts in terms of a specific file-system implementation, and for this purpose,
    we use *ext2* as an example at various points later in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Linux上最广泛使用的文件系统是 *ext2*，即 *第二扩展文件系统*，它是原始Linux文件系统 *ext* 的继任者。近年来，*ext2*
    的使用已经减少，取而代之的是各种日志文件系统。有时，为了描述通用的文件系统概念，可能会通过特定文件系统的实现来说明，在这种情况下，我们将在本章后面的多个地方使用
    *ext2* 作为示例。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *ext2* file system was written by Remy Card. The source code for *ext2*
    is small (around 5000 lines of C) and forms the model for several other file-system
    implementations. The *ext2* home page is [http://e2fsprogs.sourceforge.net/ext2.html](http://e2fsprogs.sourceforge.net/ext2.html).
    This web site includes a good overview paper describing the implementation of
    *ext2*. *The Linux Kernel*, an online book by David Rusling available at [http://www.tldp.org/](http://www.tldp.org/),
    also describes *ext2*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*ext2*文件系统是由Remy Card编写的。*ext2*的源代码很小（大约5000行C语言），并为其他几个文件系统实现提供了模型。*ext2*的主页是
    [http://e2fsprogs.sourceforge.net/ext2.html](http://e2fsprogs.sourceforge.net/ext2.html)。这个网站包括一篇很好的概述文章，描述了*ext2*的实现。David
    Rusling的在线书籍《*Linux Kernel*》可以在[http://www.tldp.org/](http://www.tldp.org/)上找到，也描述了*ext2*。'
- en: File-system structure
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件系统结构
- en: The basic unit for allocating space in a file system is a *logical* block, which
    is some multiple of contiguous physical blocks on the disk device on which the
    file system resides. For example, the logical block size on *ext2* is 1024, 2048,
    or 4096 bytes. (The logical block size is specified as an argument of the *mkfs(8)*
    command used to build the file system.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统中分配空间的基本单位是*逻辑*块，它是磁盘设备中一系列连续物理块的倍数，文件系统驻留在该设备上。例如，*ext2*的逻辑块大小为1024、2048或4096字节。（逻辑块大小作为*mkfs(8)*命令的一个参数来指定，该命令用于构建文件系统。）
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A privileged (`CAP_SYS_RAWIO`) program can use the `FIBMAP` *ioctl()* operation
    to determine the physical location of a specified block of a file. The third argument
    of the call is a value-result integer. Before the call, this argument should be
    set to a logical block number (the first logical block is number 0); after the
    call, it is set to the number of the starting physical block where that logical
    block is stored.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有特权的（`CAP_SYS_RAWIO`）程序可以使用`FIBMAP` *ioctl()* 操作来确定指定文件块的物理位置。调用的第三个参数是一个值结果整数。在调用之前，该参数应设置为逻辑块号（第一个逻辑块号为0）；调用之后，它将被设置为存储该逻辑块的起始物理块号。
- en: '[Figure 14-1](ch14.html#layout_of_disk_partitions_and_a_file_sys "Figure 14-1. Layout
    of disk partitions and a file system") shows the relationship between disk partitions
    and file systems, and shows the parts of a (generic) file system.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-1](ch14.html#layout_of_disk_partitions_and_a_file_sys "图14-1. 磁盘分区和文件系统的布局")展示了磁盘分区与文件系统之间的关系，并展示了（通用）文件系统的各个部分。'
- en: '![Layout of disk partitions and a file system](figs/web/14-1_FS-file-systems-scale90.png.jpg)Figure 14-1. Layout
    of disk partitions and a file system'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![磁盘分区和文件系统的布局](figs/web/14-1_FS-file-systems-scale90.png.jpg)图14-1. 磁盘分区和文件系统的布局'
- en: 'A file system contains the following parts:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个文件系统包含以下部分：
- en: '*Boot block*: This is always the first block in a file system. The boot block
    is not used by the file system; rather, it contains information used to boot the
    operating system. Although only one boot block is needed by the operating system,
    all file systems have a boot block (most of which are unused).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引导块*：这是文件系统中的第一个块。引导块不是由文件系统使用的，而是包含用于引导操作系统的信息。尽管操作系统只需要一个引导块，但所有文件系统都有一个引导块（其中大部分未使用）。'
- en: '*Superblock*: This is a single block, immediately following the boot block,
    which contains parameter information about the file system, including:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*超级块*：这是一个单独的块，紧随引导块之后，包含关于文件系统的参数信息，包括：'
- en: the size of the i-node table;
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: i-节点表的大小；
- en: the size of logical blocks in this file system; and
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统中逻辑块的大小；以及
- en: the size of the file system in logical blocks.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统在逻辑块中的大小。
- en: Different file systems residing on the same physical device can be of different
    types and sizes, and have different parameter settings (e.g., block size). This
    is one of the reasons for splitting a disk into multiple partitions.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同的文件系统可以驻留在同一物理设备上，它们的类型和大小可以不同，并且有不同的参数设置（例如，块大小）。这也是将磁盘分割为多个分区的原因之一。
- en: '*I-node table*: Each file or directory in the file system has a unique entry
    in the i-node table. This entry records various information about the file. I-nodes
    are discussed in greater detail in the next section. The i-node table is sometimes
    also called the *i-list*.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*I-节点表*：文件系统中的每个文件或目录在i-节点表中都有一个唯一的条目。该条目记录关于文件的各种信息。i-节点将在下一节中详细讨论。i-节点表有时也被称为*i-列表*。'
- en: '*Data blocks*: The great majority of space in a file system is used for the
    blocks of data that form the files and directories residing in the file system.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据块*：文件系统中大部分空间用于存储形成文件和目录的数据块，这些文件和目录驻留在文件系统中。'
- en: Note
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the specific case of the *ext2* file system, the picture is somewhat more
    complex than described in the main text. After the initial boot block, the file
    system is broken into a set of equal-sized *block groups*. Each block group contains
    a copy of the superblock, parameter information about the block group, and then
    the i-node table and data blocks for this block group. By attempting to store
    all of the blocks of a file within the same block group, the *ext2* file system
    aims to reduce seek time when sequentially accessing a file. For further information,
    see the Linux source code file `Documentation/filesystems/ext2.txt`, the source
    code of the *dumpe2fs* program that comes as part of the *e2fsprogs* package,
    and [Bovet & Cesati, 2005].
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *ext2* 文件系统的具体情况下，图示比主文中描述的更为复杂。在初始引导块之后，文件系统被分为一组等大小的 *块组*。每个块组包含超级块的副本、有关块组的参数信息，然后是该块组的i节点表和数据块。通过尝试将文件的所有块存储在同一个块组中，*ext2*
    文件系统旨在减少顺序访问文件时的寻道时间。有关更多信息，请参见Linux源代码文件 `Documentation/filesystems/ext2.txt`，作为
    *e2fsprogs* 包的一部分的 *dumpe2fs* 程序源代码，以及[Bovet & Cesati, 2005]。
- en: I-nodes
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I节点
- en: 'A file system’s i-node table contains one i-node (short for *index node*) for
    each file residing in the file system. I-nodes are identified numerically by their
    sequential location in the i-node table. The *i-node number* (or simply *i-number*)
    of a file is the first field displayed by the *ls -li* command. The information
    maintained in an i-node includes the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个文件系统的i节点表包含每个文件的一个i节点（i节点是*索引节点*的缩写）。I节点通过其在i节点表中的顺序位置按数字标识。文件的 *i节点号*（或简称
    *i-number*）是 *ls -li* 命令显示的第一个字段。i节点中维护的信息包括以下内容：
- en: File type (e.g., regular file, directory, symbolic link, character device).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件类型（例如，普通文件、目录、符号链接、字符设备）。
- en: Owner (also referred to as the user ID or UID) for the file.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的所有者（也称为用户ID或UID）。
- en: Group (also referred to as the group ID or GID) for the file.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的组（也称为组ID或GID）。
- en: 'Access permissions for three categories of user: *owner* (sometimes referred
    to as *user*), *group*, and *other* (the rest of the world). [File Permissions](ch15.html#file_permissions
    "File Permissions") provides further details.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三类用户的访问权限：*owner*（有时称为 *user*）、*group* 和 *other*（其余的世界）。[文件权限](ch15.html#file_permissions
    "文件权限")提供了更多的细节。
- en: 'Three timestamps: time of last access to the file (shown by *ls -lu*), time
    of last modification of the file (the default time shown by *ls -l*), and time
    of last status change (last change to i-node information, shown by *ls -lc*).
    As on other UNIX implementations, it is notable that most Linux file systems don’t
    record the creation time of a file.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个时间戳：文件最后访问时间（通过 *ls -lu* 显示）、文件最后修改时间（*ls -l* 显示的默认时间）、最后状态更改时间（i节点信息的最后更改时间，通过
    *ls -lc* 显示）。与其他UNIX实现类似，值得注意的是，大多数Linux文件系统并不记录文件的创建时间。
- en: Number of hard links to the file.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的硬链接数量。
- en: Size of the file in bytes.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的字节大小。
- en: 'Number of blocks actually allocated to the file, measured in units of 512-byte
    blocks. There may not be a simple correspondence between this number and the size
    of the file in bytes, since a file can contain holes ([Changing the File Offset:
    *lseek()*](ch04.html#changing_the_file_offset_colon_lseek_ope "Changing the File
    Offset: lseek()")), and thus require fewer allocated blocks than would be expected
    according to its nominal size in bytes.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际分配给文件的块数，以512字节的块为单位进行度量。此数字与文件的字节大小之间可能没有简单的对应关系，因为文件可能包含空洞（[改变文件偏移量：*lseek()*](ch04.html#changing_the_file_offset_colon_lseek_ope
    "改变文件偏移量：lseek()")），因此需要的分配块数可能少于按字节大小预期的块数。
- en: Pointers to the data blocks of the file.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向文件数据块的指针。
- en: I-nodes and data block pointers in *ext2*
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*ext2*中的I节点和数据块指针'
- en: Like most UNIX file systems, the *ext2* file system doesn’t store the data blocks
    of a file contiguously or even in sequential order (though it does attempt to
    store them close to one another). To locate the file data blocks, the kernel maintains
    a set of pointers in the i-node. The system used for doing this on the *ext2*
    file system is shown in [Figure 14-2](ch14.html#structure_of_file_blocks_for_a_file_in_a
    "Figure 14-2. Structure of file blocks for a file in an ext2 file system").
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数UNIX文件系统类似，*ext2*文件系统并不将文件的数据块连续存储，甚至不按顺序存储（尽管它确实尽量将它们存储在彼此接近的位置）。为了定位文件数据块，内核在i节点中维护一组指针。在
    *ext2* 文件系统上执行此操作的系统在[图14-2](ch14.html#structure_of_file_blocks_for_a_file_in_a
    "图14-2. ext2文件系统中一个文件的数据块结构")中展示。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Removing the need to store the blocks of a file contiguously allows the file
    system to use space in an efficient way. In particular, it reduces the incidence
    of *fragmentation* of free disk space—the wastage created by the existence of
    numerous pieces of noncontiguous free space, all of which are too small to use.
    Put conversely, we could say that the advantage of efficiently using the free
    disk space is paid for by fragmenting files in the filled disk space.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 去除必须将文件块存储为连续块的需求，使得文件系统能够高效地使用磁盘空间。特别地，它减少了磁盘空间中 *碎片化* 的发生——即存在大量不连续的小块空闲空间，这些空闲空间过小，无法使用。反过来说，我们可以说，高效利用空闲磁盘空间的好处是通过在已填满的磁盘空间中碎片化文件来实现的。
- en: 'Under *ext2*, each i-node contains 15 pointers. The first 12 of these pointers
    (numbered 0 to 11 in [Figure 14-2](ch14.html#structure_of_file_blocks_for_a_file_in_a
    "Figure 14-2. Structure of file blocks for a file in an ext2 file system")) point
    to the location in the file system of the first 12 blocks of the file. The next
    pointer is a *pointer to a block of pointers* that give the locations of the thirteenth
    and subsequent data blocks of the file. The number of pointers in this block depends
    on the block size of the file system. Each pointer requires 4 bytes, so there
    may be from 256 pointers (for a 1024-byte block size) to 1024 pointers (for a
    4096-byte block size). This allows for quite large files. For even larger files,
    the fourteenth pointer (numbered 13 in the diagram) is a *double indirect pointer*—it
    points to blocks of pointers that in turn point to blocks of pointers that in
    turn point to data blocks of the file. And should the need for a truly enormous
    file arise, there is a further level of indirection: the last pointer in the i-node
    is a *triple-indirect pointer*.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ext2* 文件系统中，每个 i-node 包含 15 个指针。这些指针中的前 12 个（编号为 0 至 11，在[图 14-2](ch14.html#structure_of_file_blocks_for_a_file_in_a
    "图 14-2. *ext2* 文件系统中文件块的结构")中）指向文件系统中文件的前 12 个数据块的位置。接下来的指针是一个 *指向指针块的指针*，它指向文件的第十三个及后续数据块的位置。这个块中的指针数量取决于文件系统的块大小。每个指针需要
    4 字节，因此指针的数量可以从 256 个（对于 1024 字节块大小）到 1024 个（对于 4096 字节块大小）。这样可以支持相当大的文件。对于更大的文件，第十四个指针（图中的编号
    13）是一个 *双重间接指针* ——它指向一块指针块，而这些指针块指向其他指针块，这些指针块又指向文件的实际数据块。如果需要处理真正庞大的文件，还可以进一步增加间接层次：i-node
    中的最后一个指针是一个 *三重间接指针*。
- en: This seemingly complex system is designed to satisfy a number of requirements.
    To begin with, it allows the i-node structure to be a fixed size, while at the
    same time allowing for files of an arbitrary size. Additionally, it allows the
    file system to store the blocks of a file noncontiguously, while also allowing
    the data to be accessed randomly via *lseek()*; the kernel just needs to calculate
    which pointer(s) to follow. Finally, for small files, which form the overwhelming
    majority of files on most systems, this scheme allows the file data blocks to
    be accessed rapidly via the direct pointers of the i-node.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似复杂的系统旨在满足多个要求。首先，它允许 i-node 结构具有固定大小，同时也支持任意大小的文件。此外，它还允许文件系统以非连续的方式存储文件的块，同时又能通过
    *lseek()* 随机访问数据；内核只需要计算应该跟随哪个指针。最后，对于大多数系统中占压倒性多数的小文件，这种方案通过 i-node 的直接指针快速访问文件数据块。
- en: '![Structure of file blocks for a file in an ext2 file system](figs/web/14-2_FS-file-blocks.png.jpg)Figure 14-2. Structure
    of file blocks for a file in an *ext2* file system'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![ext2 文件系统中文件块的结构](figs/web/14-2_FS-file-blocks.png.jpg)图 14-2. *ext2* 文件系统中文件块的结构'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As an example, the author measured one system containing somewhat more than
    150,000 files. Just over 30% of the files were less than 1000 bytes in size, and
    80% occupied 10,000 bytes or less. Assuming a 1024-byte block size, all of the
    latter files could be referenced using just the 12 direct pointers, which can
    refer to blocks containing a total of 12,288 bytes. Using a 4096-byte block size,
    this limit rises to 49,152 bytes (95% of the files on the system fell under that
    limit).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，作者测量了一个包含略多于 150,000 个文件的系统。超过 30% 的文件小于 1000 字节，80% 的文件占用的空间小于 10,000
    字节。假设块大小为 1024 字节，所有后者的文件都可以仅通过 12 个直接指针来引用，这些指针可以引用包含总共 12,288 字节的块。使用 4096 字节的块大小时，这个限制上升到
    49,152 字节（系统中 95% 的文件都小于这个限制）。
- en: This design also allows for enormous file sizes; for a block size of 4096 bytes,
    the theoretical largest file size is slightly more than 1024*1024*1024*4096, or
    approximately 4 terabytes (4096 GB). (We say *slightly more* because of the blocks
    pointed to by the direct, indirect, and double indirect pointers. These are insignificant
    compared to the range that can be pointed to by the triple indirect pointer.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计还允许巨大的文件大小；对于4096字节的块大小，理论上的最大文件大小略大于1024*1024*1024*4096，约为4TB（4096 GB）。（我们说*略大*是因为直接、间接和双重间接指针指向的块。与三重间接指针能够指向的范围相比，这些块可以忽略不计。）
- en: One other benefit conferred by this design is that files can have holes, as
    described in Section 4.7\. Rather than allocate blocks of null bytes for the holes
    in a file, the file system can just mark (with the value 0) appropriate pointers
    in the i-node and in the indirect pointer blocks to indicate that they don’t refer
    to actual disk blocks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计带来的另一个好处是文件可以有空洞，如第4.7节所述。文件系统可以通过在i节点和间接指针块中标记（值为0）适当的指针，来指示它们不指向实际的磁盘块，而不是为文件中的空洞分配空字节块。
- en: The Virtual File System (VFS)
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟文件系统（VFS）
- en: 'Each of the file systems available on Linux differs in the details of its implementation.
    Such differences include, for example, the way in which the blocks of a file are
    allocated and the manner in which directories are organized. If every program
    that worked with files needed to understand the specific details of each file
    system, the task of writing programs that worked with all of the different file
    systems would be nearly impossible. The *virtual file system* (VFS, sometimes
    also referred to as the *virtual file switch*) is a kernel feature that resolves
    this problem by creating an abstraction layer for file-system operations (see
    [Figure 14-3](ch14.html#the_virtual_file_system "Figure 14-3. The virtual file
    system")). The ideas behind the VFS are straightforward:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，每个文件系统的实现细节都有所不同。这些差异包括例如文件的块是如何分配的，以及目录是如何组织的。如果每个与文件交互的程序都需要理解每个文件系统的具体细节，那么编写能够支持所有不同文件系统的程序几乎是不可能的。*虚拟文件系统*（VFS，有时也称为*虚拟文件交换机*）是一个内核特性，它通过为文件系统操作创建一个抽象层来解决这个问题（见[图14-3](ch14.html#the_virtual_file_system
    "图14-3. 虚拟文件系统")）。VFS的理念很简单：
- en: The VFS defines a generic interface for file-system operations. All programs
    that work with files specify their operations in terms of this generic interface.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VFS定义了一个通用的文件系统操作接口。所有与文件交互的程序都通过此通用接口指定它们的操作。
- en: Each file system provides an implementation for the VFS interface.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文件系统为VFS接口提供一个实现。
- en: Under this scheme, programs need to understand only the VFS interface and can
    ignore details of individual file-system implementations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方案下，程序只需要理解VFS接口，忽略各个文件系统实现的细节。
- en: The VFS interface includes operations corresponding to all of the usual system
    calls for working with file systems and directories, such as *open()*, *read()*,
    *write()*, *lseek()*, *close()*, *truncate()*, *stat()*, *mount()*, *umount()*,
    *mmap()*, *mkdir()*, *link()*, *unlink()*, *symlink()*, and *rename()*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: VFS接口包含了与操作文件系统和目录的所有常用系统调用对应的操作，例如*open()*、*read()*、*write()*、*lseek()*、*close()*、*truncate()*、*stat()*、*mount()*、*umount()*、*mmap()*、*mkdir()*、*link()*、*unlink()*、*symlink()*和*rename()*。
- en: The VFS abstraction layer is closely modeled on the traditional UNIX file-system
    model. Naturally, some file systems—especially non-UNIX file systems—don’t support
    all of the VFS operations (e.g., Microsoft’s VFAT doesn’t support the notion of
    symbolic links, created using *symlink()*). In such cases, the underlying file
    system passes an error code back to the VFS layer indicating the lack of support,
    and the VFS in turn passes this error code back to the application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: VFS抽象层与传统的UNIX文件系统模型紧密对应。自然地，一些文件系统——特别是非UNIX文件系统——不支持所有VFS操作（例如，Microsoft的VFAT不支持通过*symlink()*创建的符号链接的概念）。在这种情况下，底层文件系统会将一个错误代码返回给VFS层，指示不支持该操作，而VFS又将此错误代码返回给应用程序。
- en: '![The virtual file system](figs/web/14-3_FS-VFS-scale90.png.jpg)Figure 14-3. The
    virtual file system'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![虚拟文件系统](figs/web/14-3_FS-VFS-scale90.png.jpg)图14-3. 虚拟文件系统'
- en: Journaling File Systems
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志文件系统
- en: 'The *ext2* file system is a good example of a traditional UNIX file system,
    and suffers from a classic limitation of such file systems: after a system crash,
    a file-system consistency check (*fsck*) must be performed on reboot in order
    to ensure the integrity of the file system. This is necessary because, at the
    time of the system crash, a file update may have been only partially completed,
    and the file-system metadata (directory entries, i-node information, and file
    data block pointers) may be in an inconsistent state, so that the file system
    might be further damaged if these inconsistencies are not repaired. A file-system
    consistency check ensures the consistency of the file-system metadata. Where possible,
    repairs are performed; otherwise, information that is not retrievable (possibly
    including file data) is discarded.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*ext2* 文件系统是传统 UNIX 文件系统的一个典型例子，并且存在这种文件系统的经典局限性：在系统崩溃后，必须在重启时执行文件系统一致性检查（*fsck*），以确保文件系统的完整性。这是必要的，因为在系统崩溃时，文件更新可能只完成了一部分，而文件系统元数据（目录条目、i-node
    信息和文件数据块指针）可能处于不一致状态，因此如果不修复这些不一致，文件系统可能会进一步损坏。文件系统一致性检查确保文件系统元数据的一致性。如果可能，进行修复；否则，丢弃无法恢复的信息（可能包括文件数据）。'
- en: The problem is that a consistency check requires examining the entire file system.
    On a small file system, this may take anything from several seconds to a few minutes.
    On a large file system, this may require several hours, which is a serious problem
    for systems that must maintain high availability (e.g., network servers).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，一致性检查需要检查整个文件系统。在小型文件系统中，这可能需要几秒钟到几分钟的时间。而在大型文件系统中，这可能需要几个小时，这对必须保持高可用性的系统（例如，网络服务器）来说是一个严重问题。
- en: Journaling file systems eliminate the need for lengthy file-system consistency
    checks after a system crash. A journaling file system logs (journals) all metadata
    updates to a special on-disk journal file before they are actually carried out.
    The updates are logged in groups of related metadata updates (*transactions*).
    In the event of a system crash in the middle of a transaction, on system reboot,
    the log can be used to rapidly redo any incomplete updates and bring the file
    system back to a consistent state. (To borrow database parlance, we can say that
    a journaling file system ensures that file metadata transactions are always *committed*
    as a complete unit.) Even very large journaling file systems can typically be
    available within seconds after a system crash, making them very attractive for
    systems with high-availability requirements.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件系统消除了系统崩溃后进行文件系统一致性检查的需要。日志文件系统在实际执行更新之前，会将所有元数据更新记录（日志）到一个特殊的磁盘日志文件中。这些更新以相关元数据更新的组（*事务*）形式进行记录。如果在事务执行过程中发生系统崩溃，系统重启时，日志可以用于快速重做任何未完成的更新，并将文件系统恢复到一致状态。（借用数据库术语，我们可以说，日志文件系统确保文件元数据事务始终以完整单元进行
    *提交*。）即使是非常大的日志文件系统，在系统崩溃后通常也能在几秒钟内恢复，因此对需要高可用性的系统非常有吸引力。
- en: The most notable disadvantage of journaling is that it adds time to file updates,
    though good design can make this overhead low.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 日志的最显著缺点是，它会增加文件更新的时间，尽管良好的设计可以使这种开销保持较低。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Some journaling file systems ensure only the consistency of file metadata. Because
    they don’t log file data, data may still be lost in the event of a crash. The
    *ext3*, *ext4*, and *Reiserfs* file systems provide options for logging data updates,
    but, depending on the workload, this may result in lower file I/O performance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一些日志文件系统仅确保文件元数据的一致性。因为它们不记录文件数据，所以在系统崩溃时数据可能仍然会丢失。*ext3*、*ext4* 和 *Reiserfs*
    文件系统提供了记录数据更新的选项，但根据工作负载的不同，这可能会导致较低的文件 I/O 性能。
- en: 'The journaling file systems available for Linux include the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于 Linux 的日志文件系统包括以下几种：
- en: '*Reiserfs* was the first of the journaling file systems to be integrated into
    the kernel (in version 2.4.1). *Reiserfs* provides a feature called *tail packing*
    (or *tail merging*): small files (and the final fragment of larger files) are
    packed into the same disk blocks as the file metadata. Because many systems have
    (and some applications create) large numbers of small files, this can save a significant
    amount of disk space.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Reiserfs* 是第一个被集成到内核中的日志文件系统（在版本 2.4.1 中）。*Reiserfs* 提供了一种名为 *尾部打包*（或 *尾部合并*）的功能：小文件（以及较大文件的最后一个片段）被打包到与文件元数据相同的磁盘块中。由于许多系统（以及一些应用程序）会创建大量小文件，这可以节省大量磁盘空间。'
- en: The *ext3* file system was a result of a project to add journaling to *ext2*
    with minimal impact. The migration path from *ext2* to *ext3* is very easy (no
    backup and restore are required), and it is possible to migrate in the reverse
    direction as well. The *ext3* file system was integrated into the kernel in version
    2.4.15.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ext3* 文件系统是一个为 *ext2* 添加日志记录功能的项目，且其对性能的影响最小。*ext2* 到 *ext3* 的迁移路径非常简单（不需要备份和恢复），也可以进行反向迁移。*ext3*
    文件系统被集成到 2.4.15 版本的内核中。'
- en: '*JFS* was developed at IBM. It was integrated into the 2.4.20 kernel.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JFS* 是在 IBM 开发的，它被集成到 2.4.20 内核中。'
- en: '*XFS* ([http://oss.sgi.com/projects/xfs/](http://oss.sgi.com/projects/xfs/))
    was originally developed by Silicon Graphics (SGI) in the early 1990s for Irix,
    its proprietary UNIX implementation. In 2001, *XFS* was ported to Linux and made
    available as a free software project. *XFS* was integrated into the 2.4.24 kernel.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*XFS* ([http://oss.sgi.com/projects/xfs/](http://oss.sgi.com/projects/xfs/))
    最初由硅谷图形公司（SGI）在 1990 年代初期为 Irix（其专有 UNIX 实现）开发。2001 年，*XFS* 被移植到 Linux 并作为自由软件项目发布。*XFS*
    被集成到 2.4.24 内核中。'
- en: Support for the various file systems is enabled using kernel options that are
    set under the *File systems* menu when configuring the kernel.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 支持各种文件系统是通过在配置内核时，在*文件系统*菜单下设置内核选项来启用的。
- en: 'At the time of writing, work is in progress on two other file systems that
    provide journaling and a range of other advanced features:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，正在开发另外两个提供日志记录以及一系列其他高级特性的文件系统：
- en: The *ext4* file system ([http://ext4.wiki.kernel.org/](http://ext4.wiki.kernel.org/))
    is the successor to *ext3*. The first pieces of the implementation were added
    in kernel 2.6.19, and various features were added in later kernel versions. Among
    the planned (or already implemented) features for *ext4* are extents (reservation
    of contiguous blocks of storage) and other allocation features that aim to reduce
    file fragmentation, online file-system defragmentation, faster file-system checking,
    and support for nanosecond timestamps.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ext4* 文件系统 ([http://ext4.wiki.kernel.org/](http://ext4.wiki.kernel.org/))
    是 *ext3* 的继任者。最初的实现部分被添加到 2.6.19 版本的内核中，之后的内核版本增加了各种特性。对于 *ext4*，计划中的（或已实现的）特性包括扩展（保留连续的存储块）以及其他旨在减少文件碎片、在线文件系统碎片整理、更快速的文件系统检查和对纳秒时间戳支持的分配特性。'
- en: '*Btrfs* (B-tree FS, usually pronounced “butter FS”; [http://btrfs.wiki.kernel.org/](http://btrfs.wiki.kernel.org/))
    is a new file system designed from the ground up to provide a range of modern
    features, including extents, writable snapshots (which provide functionality equivalent
    to metadata and data journaling), checksums on data and metadata, online file-system
    checking, online file-system defragmentation, space-efficient packing of small
    files, and space-efficient indexed directories. It was integrated into the kernel
    in version 2.6.29.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Btrfs*（B-tree FS，通常发音为“butter FS”；[http://btrfs.wiki.kernel.org/](http://btrfs.wiki.kernel.org/)）是一个从零开始设计的新型文件系统，提供一系列现代特性，包括扩展、可写快照（提供等同于元数据和数据日志记录的功能）、数据和元数据的校验和、在线文件系统检查、在线文件系统碎片整理、小文件的空间高效打包，以及空间高效的索引目录。它被集成到
    2.6.29 版本的内核中。'
- en: Single Directory Hierarchy and Mount Points
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一目录层次结构与挂载点
- en: 'On Linux, as on other UNIX systems, all files from all file systems reside
    under a single directory tree. At the base of this tree is the root directory,
    `/` (slash). Other file systems are *mounted* under the root directory and appear
    as subtrees within the overall hierarchy. The superuser uses a command of the
    following form to mount a file system:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统上，和其他 UNIX 系统一样，所有文件都位于单一的目录树下。该树的根目录是根目录`/`（斜杠）。其他文件系统被*挂载*在根目录下，并在整个层级结构中作为子树显示。超级用户使用如下命令来挂载文件系统：
- en: '[PRE0]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command attaches the file system on the named *device* into the directory
    hierarchy at the specified *directory*—the file system’s *mount point*. It is
    possible to change the location at which a file system is mounted—the file system
    is unmounted using the *umount* command, and then mounted once more at a different
    point.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将指定的*设备*上的文件系统附加到指定的*目录*—文件系统的*挂载点*。可以改变文件系统挂载的位置—通过使用*umount*命令卸载文件系统，然后在不同的点重新挂载。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With Linux 2.4.19 and later, things became more complicated. The kernel now
    supports per-process *mount namespaces*. This means that each process potentially
    has its own set of file-system mount points, and thus may see a different single
    directory hierarchy from other processes. We explain this point further when we
    describe the `CLONE_NEWNS` flag in [Example program](ch28.html#example_program-id39
    "Example program").
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux 2.4.19及以后版本开始，事情变得更加复杂。内核现在支持每个进程的*挂载命名空间*。这意味着每个进程可能有自己的一组文件系统挂载点，因此可能会看到与其他进程不同的单一目录层次结构。当我们在[示例程序](ch28.html#example_program-id39
    "示例程序")中描述`CLONE_NEWNS`标志时，我们会进一步解释这一点。
- en: 'To list the currently mounted file systems, we can use the command *mount*,
    with no arguments, as in the following example (whose output has been somewhat
    abridged):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出当前挂载的文件系统，我们可以使用不带任何参数的*mount*命令，如以下示例所示（输出已略微缩减）：
- en: '[PRE1]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Figure 14-4](ch14.html#example_directory_hierarchy_showing_file "Figure 14-4. Example
    directory hierarchy showing file-system mount points") shows a partial directory
    and file structure for the system on which the above *mount* command was performed.
    This diagram shows how the mount points map onto the directory hierarchy.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-4](ch14.html#example_directory_hierarchy_showing_file "图14-4. 显示文件系统挂载点的示例目录层次结构")显示了执行上述*mount*命令的系统的部分目录和文件结构。该图显示了挂载点如何映射到目录层次结构。'
- en: '![Example directory hierarchy showing file-system mount points](figs/web/14-4_FS-mount.png.jpg)Figure 14-4. Example
    directory hierarchy showing file-system mount points'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![显示文件系统挂载点的示例目录层次结构](figs/web/14-4_FS-mount.png.jpg)图14-4. 显示文件系统挂载点的示例目录层次结构'
- en: Mounting and Unmounting File Systems
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载和卸载文件系统
- en: The *mount()* and *umount()* system calls allow a privileged (`CAP_SYS_ADMIN`)
    process to mount and unmount file systems. Most UNIX implementations provide versions
    of these system calls. However, they are not standardized by SUSv3, and their
    operation varies both across UNIX implementations and across file systems.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*mount()*和*umount()*系统调用允许具有特权（`CAP_SYS_ADMIN`）的进程挂载和卸载文件系统。大多数UNIX实现提供这些系统调用的版本。然而，它们并没有被SUSv3标准化，而且它们的操作在不同的UNIX实现和不同的文件系统之间有所不同。'
- en: 'Before looking at these system calls, it is useful to know about three files
    that contain information about the file systems that are currently mounted or
    can be mounted:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这些系统调用之前，了解包含当前挂载或可挂载文件系统信息的三个文件是很有用的：
- en: A list of the currently mounted file systems can be read from the Linux-specific
    `/proc/mounts` virtual file. `/proc/mounts` is an interface to kernel data structures,
    so it always contains accurate information about mounted file systems.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从Linux特定的`/proc/mounts`虚拟文件中读取当前挂载的文件系统列表。`/proc/mounts`是对内核数据结构的接口，因此它始终包含关于挂载文件系统的准确信息。
- en: Note
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With the arrival of the per-process mount namespace feature mentioned earlier,
    each process now has a `/proc/`*PID*`/mounts` file that lists the mount points
    constituting its mount namespace, and `/proc/mounts` is just a symbolic link to
    /`proc/self/mounts`.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着之前提到的每个进程挂载命名空间功能的出现，每个进程现在都有一个`/proc/`*PID*`/mounts`文件，列出了构成其挂载命名空间的挂载点，而`/proc/mounts`只是指向`/proc/self/mounts`的符号链接。
- en: The *mount(8)* and *umount(8)* commands automatically maintain the file `/etc/mtab`,
    which contains information that is similar to that in `/proc/mounts`, but slightly
    more detailed. In particular, `/etc/mtab` includes file system–specific options
    given to *mount(8)*, which are not shown in `/proc/mounts`. However, because the
    *mount()* and *umount()* system calls don’t update `/etc/mtab`, this file may
    be inaccurate if some application that mounts or unmounts devices fails to update
    it.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*mount(8)*和*umount(8)*命令会自动维护文件`/etc/mtab`，该文件包含类似于`/proc/mounts`中的信息，但稍微更详细。特别是，`/etc/mtab`包括传递给*mount(8)*的特定于文件系统的选项，而这些选项在`/proc/mounts`中没有显示。然而，由于*mount()*和*umount()*系统调用不会更新`/etc/mtab`，因此如果某个挂载或卸载设备的应用程序未能更新该文件，则该文件可能不准确。'
- en: The `/etc/fstab` file, maintained manually by the system administrator, contains
    descriptions of all of the available file systems on a system, and is used by
    the *mount(8)*, *umount(8)*, and *fsck(8)* commands.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/fstab`文件由系统管理员手动维护，包含系统上所有可用文件系统的描述，并由*mount(8)*、*umount(8)*和*fsck(8)*命令使用。'
- en: 'The `/proc/mounts`, `/etc/mtab`, and `/etc/fstab` files share a common format,
    described in the *fstab(5)* manual page. Here is an example of a line from the
    `/proc/mounts` file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/mounts`、`/etc/mtab`和`/etc/fstab`文件共享一个共同的格式，具体描述请参见*fstab(5)*手册页。以下是来自`/proc/mounts`文件的一行示例：'
- en: '[PRE2]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This line contains six fields:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行包含六个字段：
- en: The name of the mounted device.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已挂载设备的名称。
- en: The mount point for the device.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备的挂载点。
- en: The file-system type.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件系统类型。
- en: Mount flags. In the above example, *rw* indicates that the file system was mounted
    read-write.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载标志。在上面的例子中，*rw* 表示文件系统以读写方式挂载。
- en: A number used to control the operation of file-system backups by *dump(8)*.
    This field and the next are used only in the `/etc/fstab` file; for `/proc/mounts`
    and /`etc/mtab`, these fields are always 0.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个用于控制 *dump(8)* 文件系统备份操作的数字。此字段和下一个字段仅在 `/etc/fstab` 文件中使用；对于 `/proc/mounts`
    和 `/etc/mtab`，这些字段始终为 0。
- en: A number used to control the order in which *fsck(8)* checks file systems at
    system boot time.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个用于控制 *fsck(8)* 在系统启动时检查文件系统顺序的数字。
- en: The *getfsent(3)* and *getmntent(3)* manual pages document functions that can
    be used to read records from these files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*getfsent(3)* 和 *getmntent(3)* 手册页面记录了可以用来从这些文件中读取记录的函数。'
- en: 'Mounting a File System: *mount()*'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂载文件系统：*mount()*
- en: The *mount()* system call mounts the file system contained on the device specified
    by *source* under the directory (the *mount point*) specified by *target*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*mount()* 系统调用将包含在由 *source* 指定的设备上的文件系统挂载到由 *target* 指定的目录（即 *挂载点*）下。'
- en: '[PRE3]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1。
- en: The names *source* and *target* are used for the first two arguments because
    *mount()* can perform other tasks than mounting a disk file system under a directory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*source* 和 *target* 这两个名称用于前两个参数，因为 *mount()* 除了可以在目录下挂载磁盘文件系统外，还可以执行其他任务。'
- en: The *fstype* argument is a string identifying the type of file system contained
    on the device, such as *ext4* or *btrfs*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*fstype* 参数是一个字符串，标识设备上包含的文件系统类型，如 *ext4* 或 *btrfs*。'
- en: The *mountflags* argument is a bit mask constructed by ORing (`|`) zero or more
    of the flags shown in [Table 14-1](ch14.html#mountflags_values_for_mount_open_parenth
    "Table 14-1. mountflags values for mount()"), which are described in more detail
    below.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*mountflags* 参数是通过 OR 运算（`|`）将零个或多个标志结合成的位掩码，这些标志在 [表 14-1](ch14.html#mountflags_values_for_mount_open_parenth
    "表 14-1. mountflags 值") 中列出，下面有更详细的描述。'
- en: The final *mount()* argument, *data*, is a pointer to a buffer of information
    whose interpretation depends on the file system. For most file-system types, this
    argument is a string consisting of comma-separated option settings. A full list
    of these options can be found in the *mount(8)* manual page (or the documentation
    for the file system concerned, if it is not described in *mount(8)*).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 *mount()* 参数，*data*，是一个指向信息缓冲区的指针，缓冲区内容的解释依赖于文件系统。对于大多数文件系统类型，此参数是一个由逗号分隔的选项设置组成的字符串。可以在
    *mount(8)* 手册页面中找到这些选项的完整列表（如果文件系统没有在 *mount(8)* 中描述，则请查阅相关文件系统的文档）。
- en: Table 14-1. mountflags `values for` mount()
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-1. *mount()* 的 `mountflags` 值
- en: '| Flag | Purpose |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 目的 |'
- en: '| --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `MS_BIND` | Create a bind mount (since Linux 2.4) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `MS_BIND` | 创建绑定挂载（自 Linux 2.4 起） |'
- en: '| `MS_DIRSYNC` | Make directory updates synchronous (since Linux 2.6) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `MS_DIRSYNC` | 使目录更新同步（自 Linux 2.6 起） |'
- en: '| `MS_MANDLOCK` | Permit mandatory locking of files |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `MS_MANDLOCK` | 允许强制锁定文件 |'
- en: '| `MS_MOVE` | Atomically move mount point to new location |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `MS_MOVE` | 原子地将挂载点移动到新位置 |'
- en: '| `MS_NOATIME` | Don’t update last access time for files |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `MS_NOATIME` | 不更新文件的最后访问时间 |'
- en: '| `MS_NODEV` | Don’t allow access to devices |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `MS_NODEV` | 不允许访问设备 |'
- en: '| `MS_NODIRATIME` | Don’t update last access time for directories |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `MS_NODIRATIME` | 不更新目录的最后访问时间 |'
- en: '| `MS_NOEXEC` | Don’t allow programs to be executed |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `MS_NOEXEC` | 不允许执行程序 |'
- en: '| `MS_NOSUID` | Disable set-user-ID and set-group-ID programs |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `MS_NOSUID` | 禁用设置用户 ID 和设置组 ID 的程序 |'
- en: '| `MS_RDONLY` | Read-only mount; files can’t be created or modified |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `MS_RDONLY` | 只读挂载；不能创建或修改文件 |'
- en: '| `MS_REC` | Recursive mount (since Linux 2.6.20) |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `MS_REC` | 递归挂载（自 Linux 2.6.20 起） |'
- en: '| `MS_RELATIME` | Update last access time only if older than last modification
    time or last status change time (since Linux 2.4.11) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `MS_RELATIME` | 只有当最后访问时间晚于最后修改时间或最后状态变化时间时才更新最后访问时间（自 Linux 2.4.11 起） |'
- en: '| `MS_REMOUNT` | Remount with new *mountflags* and *data* |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `MS_REMOUNT` | 使用新的 *mountflags* 和 *data* 重新挂载 |'
- en: '| `MS_STRICTATIME` | Always update last access time (since Linux 2.6.30) |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `MS_STRICTATIME` | 始终更新最后访问时间（自 Linux 2.6.30 起） |'
- en: '| `MS_SYNCHRONOUS` | Make all file and directory updates synchronous |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `MS_SYNCHRONOUS` | 使所有文件和目录更新同步 |'
- en: 'The *mountflags* argument is a bit mask of flags that modify the operation
    of *mount()*. Zero or more of the following flags can be specified in *mountflags*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*mountflags* 参数是一个位掩码，包含修改 *mount()* 操作的标志。可以在 *mountflags* 中指定以下一个或多个标志：'
- en: '`MS_BIND` (since Linux 2.4)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_BIND`（自 Linux 2.4 起）'
- en: Create a bind mount. We describe this feature in [Bind Mounts](ch14.html#bind_mounts
    "Bind Mounts"). If this flag is specified, then the *fstype*, *mountflags*, and
    *data* arguments are ignored.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建绑定挂载。我们在[绑定挂载](ch14.html#bind_mounts "绑定挂载")中描述了此功能。如果指定此标志，则 *fstype*、*mountflags*
    和 *data* 参数将被忽略。
- en: '`MS_DIRSYNC` (since Linux 2.6)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_DIRSYNC`（自 Linux 2.6 起）'
- en: Make directory updates synchronous. This is similar to the effect of the *open()*
    `O_SYNC` flag ([Controlling Kernel Buffering of File I/O](ch13.html#controlling_kernel_buffering_of_file_i_s
    "Controlling Kernel Buffering of File I/O")), but applies only to directory updates.
    The `MS_SYNCHRONOUS` flag described below provides a superset of the functionality
    of `MS_DIRSYNC`, ensuring that both file and directory updates are performed synchronously.
    The `MS_DIRSYNC` flag allows an application to ensure that directory updates (e.g.,
    *open(pathname, O_CREAT)*, *rename()*, *link()*, *unlink()*, *symlink()*, and
    *mkdir()*) are synchronized without incurring the expense of synchronizing all
    file updates. The `FS_DIRSYNC_FL` flag ([I-node Flags (*ext2* Extended File Attributes)](ch15.html#i-node_flags_open_parenthesis_ext2_exten
    "I-node Flags (ext2 Extended File Attributes)")) serves a similar purpose to `MS_DIRSYNC`,
    with the difference that `FS_DIRSYNC_FL` can be applied to individual directories.
    In addition, on Linux, calling *fsync()* on a file descriptor that refers to a
    directory provides a means of synchronizing directory updates on a per-directory
    basis. (This Linux-specific *fsync()* behavior is not specified in SUSv3.)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使目录更新同步。这类似于 *open()* 的 `O_SYNC` 标志（[控制内核文件 I/O 缓存](ch13.html#controlling_kernel_buffering_of_file_i_s
    "控制内核文件 I/O 缓存")），但仅适用于目录更新。下面描述的 `MS_SYNCHRONOUS` 标志提供了 `MS_DIRSYNC` 的超集功能，确保文件和目录更新都同步执行。`MS_DIRSYNC`
    标志允许应用程序确保目录更新（例如 *open(pathname, O_CREAT)*、*rename()*、*link()*、*unlink()*、*symlink()*
    和 *mkdir()*）是同步的，而不需要同步所有文件更新。`FS_DIRSYNC_FL` 标志（[I节点标志（*ext2* 扩展文件属性）](ch15.html#i-node_flags_open_parenthesis_ext2_exten
    "I节点标志（ext2 扩展文件属性）")）与 `MS_DIRSYNC` 的作用类似，但 `FS_DIRSYNC_FL` 可以应用于单个目录。此外，在 Linux
    上，调用 *fsync()* 以同步引用目录的文件描述符，可以实现按目录同步更新。（这种 Linux 特有的 *fsync()* 行为未在 SUSv3 中规定。）
- en: '`MS_MANDLOCK`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_MANDLOCK`'
- en: Permit mandatory record locking on files in this file system. We describe record
    locking in [Chapter 55](ch55.html "Chapter 55. File Locking").
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 允许在该文件系统中的文件上强制记录锁定。我们在[第 55 章](ch55.html "第 55 章. 文件锁定")中描述了记录锁定。
- en: '`MS_MOVE`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_MOVE`'
- en: Atomically move the existing mount point specified by *source* to the new location
    specified by *target*. This corresponds to the *—move* option to *mount(8)*. This
    is equivalent to unmounting the subtree and then remounting at a different location,
    except that there is no point in time when the subtree is unmounted. The *source*
    argument should be a string specified as a *target* in a previous *mount()* call.
    When this flag is specified, the *fstype*, *mountflags*, and *data* arguments
    are ignored.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 原子性地将由 *source* 指定的现有挂载点移动到由 *target* 指定的新位置。这对应于 *mount(8)* 的 *—move* 选项。这相当于先卸载子树，然后再在不同位置重新挂载，唯一不同的是在此过程中子树从未被卸载。*source*
    参数应为先前 *mount()* 调用中指定的 *target* 字符串。当指定此标志时，*fstype*、*mountflags* 和 *data* 参数将被忽略。
- en: '`MS_NOATIME`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_NOATIME`'
- en: Don’t update the last access time for files in this file system. The purpose
    of this flag, as well as the `MS_NODIRATIME` flag described below, is to eliminate
    the extra disk access required to update the file i-node each time a file is accessed.
    In some applications, maintaining this timestamp is not critical, and avoiding
    doing so can significantly improve performance. The `MS_NOATIME` flag serves a
    similar purpose to the `FS_NOATIME_FL` flag ([I-node Flags (*ext2* Extended File
    Attributes)](ch15.html#i-node_flags_open_parenthesis_ext2_exten "I-node Flags
    (ext2 Extended File Attributes)")), with the difference that `FS_NOATIME_FL` can
    be applied to single files. Linux also provides similar functionality via the
    `O_NOATIME` *open()* flag, which selects this behavior for individual open files
    ([File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()")).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不更新此文件系统中文件的最后访问时间。此标志的目的，与下面描述的 `MS_NODIRATIME` 标志一样，是为了消除每次访问文件时更新文件 i-node
    所需的额外磁盘访问。在某些应用中，维护此时间戳并不关键，避免更新它可以显著提高性能。`MS_NOATIME` 标志与 `FS_NOATIME_FL` 标志（[I-node
    标志 (*ext2* 扩展文件属性)](ch15.html#i-node_flags_open_parenthesis_ext2_exten "I-node
    Flags (ext2 Extended File Attributes)"))的作用类似，区别在于 `FS_NOATIME_FL` 可以应用于单个文件。Linux
    还通过 `O_NOATIME` *open()* 标志提供了类似的功能，这个标志为单个打开的文件选择此行为（[通过 *open()* 返回的文件描述符号](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()")）。
- en: '`MS_NODEV`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_NODEV`'
- en: Don’t allow access to block and character devices on this file system. This
    is a security feature designed to prevent users from doing things such as inserting
    a removable disk containing device special files that would allow arbitrary access
    to the system.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许访问此文件系统上的块设备和字符设备。这是一个安全特性，旨在防止用户执行如插入含有设备特殊文件的可移动磁盘等操作，从而可能导致对系统的任意访问。
- en: '`MS_NODIRATIME`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_NODIRATIME`'
- en: Don’t update the last access time for directories on this file system. (This
    flag provides a subset of the functionality of `MS_NOATIME`, which prevents updates
    to the last access time for all file types.)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不更新此文件系统中文件夹的最后访问时间。（此标志提供了 `MS_NOATIME` 的子集功能，`MS_NOATIME` 会阻止更新所有文件类型的最后访问时间。）
- en: '`MS_NOEXEC`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_NOEXEC`'
- en: Don’t allow programs (or scripts) to be executed from this file system. This
    is useful if the file system contains non-Linux executables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止从此文件系统执行程序（或脚本）。如果文件系统包含非 Linux 可执行文件，这个选项会很有用。
- en: '`MS_NOSUID`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_NOSUID`'
- en: Disable set-user-ID and set-group-ID programs on this file system. This is a
    security feature to prevent users from running set-user-ID and set-group-ID programs
    from removable devices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止在此文件系统上运行 set-user-ID 和 set-group-ID 程序。这是一个安全特性，用于防止用户从可移动设备上运行 set-user-ID
    和 set-group-ID 程序。
- en: '`MS_RDONLY`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_RDONLY`'
- en: Mount the file system read-only, so that no new files can be created and no
    existing files can be modified.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以只读方式挂载文件系统，确保不能创建新文件或修改现有文件。
- en: '`MS_REC` (since Linux 2.4.11)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_REC`（自 Linux 2.4.11 起）'
- en: This flag is used in conjunction with other flags (e.g., `MS_BIND`) to recursively
    apply the mount action to all of the mounts in a subtree.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志与其他标志一起使用（例如 `MS_BIND`），以递归地将挂载操作应用于子树中的所有挂载点。
- en: '`MS_RELATIME` (since Linux 2.6.20)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_RELATIME`（自 Linux 2.6.20 起）'
- en: Update the last access timestamp for files on this file system only if the current
    setting of this timestamp is less than or equal to either the last modification
    or the last status change timestamp. This provides some of the performance benefits
    of `MS_NOATIME`, but is useful for programs that need to know if a file has been
    read since it was last updated. Since Linux 2.6.30, the behavior provided by `MS_RELATIME`
    is the default (unless the `MS_NOATIME` flag is specified), and the `MS_STRICTATIME`
    flag is required to obtain classical behavior. In addition, since Linux 2.6.30,
    the last access timestamp is always updated if its current value is more than
    24 hours in the past, even if the current value is more recent than the last modification
    and last status change timestamps. (This is useful for certain system programs
    that monitor directories to see whether files have recently been accessed.)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当当前的最后访问时间戳小于或等于最后修改时间戳或最后状态更改时间戳时，才更新此文件系统中文件的最后访问时间戳。这提供了与 `MS_NOATIME` 类似的一些性能优势，但对于需要知道文件自上次更新以来是否被读取的程序很有用。自
    Linux 2.6.30 起，`MS_RELATIME` 提供的行为为默认行为（除非指定了 `MS_NOATIME` 标志），而 `MS_STRICTATIME`
    标志是获取经典行为所必需的。此外，自 Linux 2.6.30 起，如果最后访问时间戳当前的值距离现在超过 24 小时，即使当前值比最后修改和最后状态更改时间戳更新，也会始终更新该时间戳。（这对于某些系统程序很有用，这些程序监控目录，以查看文件是否最近被访问过。）
- en: '`MS_REMOUNT`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_REMOUNT`'
- en: 'Alter the *mountflags* and *data* for a file system that is already mounted
    (e.g., to make a read-only file system writable). When using this flag, the *source*
    and *target* arguments should be the same as for the original *mount()* call,
    and the *fstype* argument is ignored. This flag avoids the need to unmount and
    remount the disk, which may not be possible in some cases. For example, we can’t
    unmount a file system if any process has files open on, or its current working
    directory located within, the file system (this will always be true of the root
    file system). Another example of where we need to use `MS_REMOUNT` is with *tmpfs*
    (memory-based) file systems ([A Virtual Memory File System: *tmpfs*](ch14.html#a_virtual_memory_file_system_colon_tmpfs
    "A Virtual Memory File System: tmpfs")), which can’t be unmounted without losing
    their contents. Not all *mountflags* are modifiable; see the *mount(2)* manual
    page for details.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '修改已挂载的文件系统的 *mountflags* 和 *data*（例如，将只读文件系统改为可写）。使用此标志时，*source* 和 *target*
    参数应与原始 *mount()* 调用中的相同，*fstype* 参数会被忽略。此标志避免了卸载和重新挂载磁盘的需求，在某些情况下可能无法执行。例如，如果任何进程在文件系统中打开了文件，或其当前工作目录位于该文件系统内，我们无法卸载该文件系统（根文件系统始终如此）。另一个需要使用
    `MS_REMOUNT` 的例子是 *tmpfs*（基于内存的）文件系统（[虚拟内存文件系统：*tmpfs*](ch14.html#a_virtual_memory_file_system_colon_tmpfs
    "A Virtual Memory File System: tmpfs")），它们无法在不丢失内容的情况下卸载。并非所有 *mountflags* 都是可修改的；详细信息请参见
    *mount(2)* 手册页。'
- en: '`MS_STRICTATIME` (since Linux 2.6.30)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_STRICTATIME`（自 Linux 2.6.30 起）'
- en: Always update the last access timestamp when files on this file system are accessed.
    This was the default behavior before Linux 2.6.30\. If `MS_STRICTATIME` is specified,
    then `MS_NOATIME` and `MS_RELATIME` are ignored if they are also specified in
    *mountflags*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问此文件系统上的文件时，总是更新最后访问时间戳。这是在 Linux 2.6.30 之前的默认行为。如果指定了 `MS_STRICTATIME`，则如果在*mountflags*中同时指定了
    `MS_NOATIME` 和 `MS_RELATIME`，则这两个选项将被忽略。
- en: '`MS_SYNCHRONOUS`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`MS_SYNCHRONOUS`'
- en: Make all file and directory updates on this file system synchronous. (In the
    case of files, this is as though files were always opened with the *open()* `O_SYNC`
    flag.)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使此文件系统上的所有文件和目录更新同步进行。（对于文件来说，这就像文件总是使用 *open()* `O_SYNC` 标志打开一样。）
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with kernel 2.6.15, Linux provides four new mount flags to support
    the notion of *shared subtrees*. The new flags are `MS_PRIVATE`, `MS_SHARED`,
    `MS_SLAVE`, and `MS_UNBINDABLE`. (These flags can be used in conjunction with
    `MS_REC` to propagate their effects to all of the submounts under a mount subtree.)
    Shared subtrees are designed for use with certain advanced file-system features,
    such as per-process mount namespaces (see the description of `CLONE_NEWNS` in
    [Example program](ch28.html#example_program-id39 "Example program")), and the
    *Filesystem in Userspace* (FUSE) facility. The shared subtree facility permits
    file-system mounts to be propagated between mount namespaces in a controlled fashion.
    Details on shared subtrees can be found in the kernel source code file `Documentation/filesystems/sharedsubtree.txt`
    and [Viro & Pai, 2006].
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核2.6.15开始，Linux提供了四个新的挂载标志以支持*共享子树*的概念。这些新标志是`MS_PRIVATE`、`MS_SHARED`、`MS_SLAVE`和`MS_UNBINDABLE`。（这些标志可以与`MS_REC`结合使用，以将它们的效果传播到挂载子树下的所有子挂载。）共享子树是为某些高级文件系统特性设计的，如每进程挂载命名空间（请参见[示例程序](ch28.html#example_program-id39
    "示例程序")中`CLONE_NEWNS`的描述），以及*用户空间文件系统*（FUSE）设施。共享子树设施允许文件系统挂载在挂载命名空间之间以受控方式传播。有关共享子树的详细信息，请参见内核源代码文件`Documentation/filesystems/sharedsubtree.txt`和[Viro
    & Pai, 2006]。
- en: Example program
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: 'The program in [Example 14-1](ch14.html#using_mount_open_parenthesis_close_paren
    "Example 14-1. Using mount()") provides a command-level interface to the *mount(2)*
    system call. In effect, it is a crude version of the *mount(8)* command. The following
    shell session log demonstrates the use of this program. We begin by creating a
    directory to be used as a mount point and mounting a file system:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 14-1](ch14.html#using_mount_open_parenthesis_close_paren "示例 14-1. 使用mount()")中的程序提供了一个命令级接口来调用*mount(2)*系统调用。实际上，它是*mount(8)*命令的粗略版本。以下shell会话日志演示了该程序的使用。我们首先创建一个目录用作挂载点，并挂载文件系统：'
- en: '[PRE4]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We find that the preceding *grep* command produces no output because our program
    doesn’t update `/etc/mtab`. We continue, remounting the file system read-only:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现前面的*grep*命令没有输出，因为我们的程序没有更新`/etc/mtab`。我们继续，重新挂载文件系统为只读：
- en: '[PRE5]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The string *ro* in the line displayed from `/proc/mounts` indicates that this
    is a read-only mount.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 行中显示的字符串*ro*来自`/proc/mounts`，表示这是一个只读挂载。
- en: 'Finally, we move the mount point to a new location within the directory hierarchy:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将挂载点移动到目录层次结构中的新位置：
- en: '[PRE6]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Example 14-1. Using *mount()*
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 14-1. 使用*mount()*
- en: '[PRE7]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unmounting a File System: *umount()* and *umount2()*'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卸载文件系统：*umount()* 和 *umount2()*
- en: The *umount()* system call unmounts a mounted file system.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*umount()*系统调用卸载已挂载的文件系统。'
- en: '[PRE8]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: The *target* argument specifies the mount point of the file system to be unmounted.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*target*参数指定要卸载的文件系统的挂载点。'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On Linux 2.2 and earlier, the file system can be identified in two ways: by
    the mount point or by the name of the device containing the file system. Since
    kernel 2.4, Linux doesn’t allow the latter possibility, because a single file
    system can now be mounted at multiple locations, so that specifying a file system
    for *target* would be ambiguous. We explain this point in further detail in [Mounting
    a File System at Multiple Mount Points](ch14.html#mounting_a_file_system_at_multiple_mount
    "Mounting a File System at Multiple Mount Points").'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux 2.2及之前版本中，文件系统可以通过两种方式识别：通过挂载点或通过包含文件系统的设备名称。从内核2.4开始，Linux不再允许后一种方式，因为一个文件系统现在可以挂载在多个位置，因此为*target*指定文件系统会变得模糊不清。我们在[在多个挂载点挂载文件系统](ch14.html#mounting_a_file_system_at_multiple_mount
    "在多个挂载点挂载文件系统")中对此进行了更详细的解释。
- en: It is not possible to unmount a file system that is *busy*; that is, if there
    are open files on the file system, or a process’s current working directory is
    somewhere in the file system. Calling *umount()* on a busy file system yields
    the error `EBUSY`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 无法卸载*忙碌*的文件系统；也就是说，如果文件系统上有打开的文件，或者某个进程的当前工作目录位于该文件系统中的某个位置。对忙碌的文件系统调用*umount()*会产生`EBUSY`错误。
- en: The *umount2()* system call is an extended version of *umount()*. It allows
    finer control over the unmount operation via the *flags* argument.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*umount2()*系统调用是*umount()*的扩展版本。它通过*flags*参数提供对卸载操作的更精细控制。'
- en: '[PRE9]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: 'This *flags* bit-mask argument consists of zero or more of the following values
    ORed together:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该*flags*位掩码参数由以下值的零个或多个通过OR操作组合而成：
- en: '`MNT_DETACH` (since Linux 2.4.11)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`MNT_DETACH`（自Linux 2.4.11起）'
- en: Perform a *lazy* unmount. The mount point is marked so that no process can make
    new accesses to it, but processes that are already using it can continue to do
    so. The file system is actually unmounted when all processes cease using the mount.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 执行*懒惰*卸载。挂载点会被标记，确保没有进程能访问它，但已经在使用该挂载点的进程可以继续使用。文件系统实际上会在所有进程停止使用该挂载点时卸载。
- en: '`MNT_EXPIRE` (since Linux 2.6.8)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`MNT_EXPIRE`（自 Linux 2.6.8 起）'
- en: Mark the mount point as *expired*. If an initial *umount2()* call is made specifying
    this flag, and the mount point is not busy, then the call fails with the error
    `EAGAIN`, but the mount point is marked to expire. (If the mount point is busy,
    then the call fails with the error `EBUSY`, and the mount point is not marked
    to expire.) A mount point remains expired as long as no process subsequently makes
    use of it. A second *umount2()* call specifying `MNT_EXPIRE` will unmount an expired
    mount point. This provides a mechanism to unmount a file system that hasn’t been
    used for some period of time. This flag can’t be specified with `MNT_DETACH` or
    `MNT_FORCE`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将挂载点标记为*过期*。如果在初始的*umount2()*调用中指定了此标志，并且挂载点没有被占用，则该调用会失败并显示错误`EAGAIN`，但挂载点会被标记为过期。（如果挂载点被占用，则调用会失败并显示错误`EBUSY`，挂载点不会被标记为过期。）只要没有进程随后使用该挂载点，挂载点就会保持过期状态。第二次指定`MNT_EXPIRE`的*umount2()*调用将卸载已过期的挂载点。这提供了一种卸载一段时间未使用的文件系统的机制。此标志不能与`MNT_DETACH`或`MNT_FORCE`一起使用。
- en: '`MNT_FORCE`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`MNT_FORCE`'
- en: Force an unmount even if the device is busy (NFS mounts only). Employing this
    option can cause data loss.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 即使设备正在使用，也强制卸载（仅限 NFS 挂载）。使用此选项可能会导致数据丢失。
- en: '`UMOUNT_NOFOLLOW` (since Linux 2.6.34)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`UMOUNT_NOFOLLOW`（自 Linux 2.6.34 起）'
- en: Don’t dereference *target* if it is a symbolic link. This flag is designed for
    use in certain set-user-ID-*root* programs that allow unprivileged users to perform
    unmounts, in order to avoid the security problems that could occur if *target*
    is a symbolic link that is changed to point to a different location.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*target*是符号链接，则不要取消引用它。此标志专为某些允许无权限用户执行卸载操作的 set-user-ID-*root* 程序设计，以避免在*target*是符号链接且该链接被更改为指向其他位置时可能发生的安全问题。
- en: Advanced Mount Features
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级挂载功能
- en: We now look at a number of more advanced features that can be employed when
    mounting file systems. We demonstrate the use of most of these features using
    the *mount(8)* command. The same effects can also be accomplished from a program
    via calls to *mount(2)*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些可以在挂载文件系统时使用的更高级的功能。我们通过使用*mount(8)*命令演示了大部分这些功能的使用。通过调用*mount(2)*，程序也可以实现相同的效果。
- en: Mounting a File System at Multiple Mount Points
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在多个挂载点挂载文件系统
- en: 'In kernel versions before 2.4, a file system could be mounted only on a single
    mount point. From kernel 2.4 onward, a file system can be mounted at multiple
    locations within the file system. Because each of the mount points shows the same
    subtree, changes made via one mount point are visible through the other(s), as
    demonstrated by the following shell session:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.4 版本之前的内核中，一个文件系统只能挂载到一个挂载点。从 2.4 内核开始，文件系统可以在文件系统内的多个位置挂载。由于每个挂载点显示的是相同的子树，通过一个挂载点所做的更改可以通过其他挂载点看到，正如以下
    shell 会话所示：
- en: '[PRE10]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output of the *ls* command shows that the change made via the first mount
    point (`/testfs`) was visible via the second mount point (`/demo`).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*ls*命令的输出显示，通过第一个挂载点（`/testfs`）所做的更改可以通过第二个挂载点（`/demo`）看到。'
- en: We present one example of why it is useful to mount a file system at multiple
    points when we describe bind mounts in [Bind Mounts](ch14.html#bind_mounts "Bind
    Mounts").
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[绑定挂载](ch14.html#bind_mounts "Bind Mounts")中描述绑定挂载时，提供了一个示例，说明为什么在多个挂载点挂载文件系统是有用的。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is because a device can be mounted at multiple points that the *umount()*
    system call can’t take a device as its argument in Linux 2.4 and later.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个设备可以在多个挂载点挂载，因此在 Linux 2.4 及以后的版本中，*umount()* 系统调用不能将设备作为参数。
- en: Stacking Multiple Mounts on the Same Mount Point
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在同一挂载点上堆叠多个挂载
- en: 'In kernel versions before 2.4, a mount point could be used only once. Since
    kernel 2.4, Linux allows multiple mounts to be stacked on a single mount point.
    Each new mount hides the directory subtree previously visible at that mount point.
    When the mount at the top of the stack is unmounted, the previously hidden mount
    becomes visible once more, as demonstrated by the following shell session:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.4版本之前，挂载点只能使用一次。从2.4版本开始，Linux允许在单个挂载点上堆叠多个挂载。每个新的挂载都会隐藏在该挂载点上先前可见的目录子树。当堆栈顶部的挂载被卸载时，之前隐藏的挂载将再次可见，以下shell会话演示了这一效果：
- en: '[PRE11]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One use of mount stacking is to stack a new mount on an existing mount point
    that is busy. Processes that hold file descriptors open, that are *chroot()*-jailed,
    or that have current working directories within the old mount point continue to
    operate under that mount, but processes making new accesses to the mount point
    use the new mount. Combined with a `MNT_DETACH` unmount, this can provide a smooth
    migration off a file system without needing to take the system into single-user
    mode. We’ll see another example of how stacking mounts is useful when we discuss
    the *tmpfs* file system in [A Virtual Memory File System: *tmpfs*](ch14.html#a_virtual_memory_file_system_colon_tmpfs
    "A Virtual Memory File System: tmpfs").'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '挂载堆叠的一种用途是将新挂载堆叠到一个正在使用的现有挂载点。保持文件描述符打开、被*chroot()*限制，或当前工作目录位于旧挂载点内的进程继续在该挂载点下操作，但进行新访问的进程则使用新挂载点。结合`MNT_DETACH`卸载，这可以实现文件系统的平滑迁移，无需将系统切换到单用户模式。我们将在讨论*[tmpfs]*文件系统时看到堆叠挂载的另一种有用示例，详见[A虚拟内存文件系统：*tmpfs*](ch14.html#a_virtual_memory_file_system_colon_tmpfs
    "A Virtual Memory File System: tmpfs")。'
- en: Mount Flags That Are Per-Mount Options
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个挂载选项的挂载标志
- en: 'In kernel versions before 2.4, there was a one-to-one correspondence between
    file systems and mount points. Because this no longer holds in Linux 2.4 and later,
    some of the *mountflags* values described in [Mounting a File System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open
    "Mounting a File System: mount()") can be set on a per-mount basis. These flags
    are `MS_NOATIME` (since Linux 2.6.16), `MS_NODEV`, `MS_NODIRATIME` (since Linux
    2.6.16), `MS_NOEXEC`, `MS_NOSUID`, `MS_RDONLY` (since Linux 2.6.26), and `MS_RELATIME`.
    The following shell session demonstrates this effect for the `MS_NOEXEC` flag:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '在2.4版本之前，文件系统和挂载点之间存在一一对应关系。由于这一点在Linux 2.4及以后的版本中不再成立，因此在[挂载文件系统：*mount()*](ch14.html#mounting_a_file_system_colon_mount_open
    "Mounting a File System: mount()")中描述的一些*mountflags*值可以按每个挂载的基础上设置。这些标志包括`MS_NOATIME`（自Linux
    2.6.16以来）、`MS_NODEV`、`MS_NODIRATIME`（自Linux 2.6.16以来）、`MS_NOEXEC`、`MS_NOSUID`、`MS_RDONLY`（自Linux
    2.6.26以来）和`MS_RELATIME`。以下shell会话演示了`MS_NOEXEC`标志的效果：'
- en: '[PRE12]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Bind Mounts
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定挂载
- en: 'Starting with kernel 2.4, Linux permits the creation of bind mounts. A *bind
    mount* (created using the *mount()* `MS_BIND` flag) allows a directory or a file
    to be mounted at some other location in the file-system hierarchy. This results
    in the directory or file being visible in both locations. A bind mount is somewhat
    like a hard link, but differs in two respects:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从2.4版本开始，Linux允许创建绑定挂载。*绑定挂载*（使用*mount()*的`MS_BIND`标志创建）允许将目录或文件挂载到文件系统层次结构中的其他位置。这将导致该目录或文件在两个位置都可见。绑定挂载有点像硬链接，但在两个方面有所不同：
- en: A bind mount can cross file-system mount points (and even *chroot* jails).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定挂载可以跨越文件系统挂载点（甚至是*chroot*监狱）。
- en: It is possible to make a bind mount for a directory.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以为一个目录创建绑定挂载。
- en: We can create a bind mount from the shell using the *—bind* option to *mount(8)*,
    as shown in the following examples.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*—bind*选项通过shell创建一个绑定挂载，以下示例演示了这一点。
- en: 'In the first example, we bind mount a directory at another location and show
    that files created in one directory are visible at the other location:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们将一个目录绑定挂载到另一个位置，并展示在一个目录中创建的文件在另一个位置可见：
- en: '[PRE13]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the second example, we bind mount a file at another location and demonstrate
    that changes to the file via one mount are visible via the other mount:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们将文件绑定挂载到另一个位置，并演示通过一个挂载对文件的更改在另一个挂载下可见：
- en: '[PRE14]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'One example of when we might use a bind mount is in the creation of a *chroot*
    jail ([Changing the Root Directory of a Process: *chroot()*](ch18.html#changing_the_root_directory_of_a_process
    "Changing the Root Directory of a Process: chroot()")). Rather than replicating
    various standard directories (such as `/lib`) in the jail, we can simply create
    bind mounts for these directories (possibly mounted read-only) within the jail.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定挂载的一个例子是在创建*chroot*监狱时（[更改进程的根目录：*chroot()*](ch18.html#changing_the_root_directory_of_a_process
    "更改进程的根目录：chroot()")）。我们可以通过为监狱中的这些目录（可能是只读挂载）创建绑定挂载，而不是在监狱中复制各种标准目录（如`/lib`）。
- en: Recursive Bind Mounts
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归绑定挂载
- en: By default, if we create a bind mount for a directory using `MS_BIND`, then
    only that directory is mounted at the new location; if there are any submounts
    under the source directory, they are not replicated under the mount *target*.
    Linux 2.4.11 added the `MS_REC` flag, which can be ORed with `MS_BIND` as part
    of the *flags* argument to *mount()* so that submounts *are* replicated under
    the mount target. This is referred to as a *recursive bind mount*. The *mount(8)*
    command provides the *—rbind* option to achieve the same effect from the shell,
    as shown in the following shell session.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果我们使用`MS_BIND`为一个目录创建绑定挂载，那么只有该目录会被挂载到新位置；如果源目录下有任何子挂载，它们不会在挂载*目标*下被复制。Linux
    2.4.11添加了`MS_REC`标志，它可以与`MS_BIND`一起作为*flags*参数传递给*mount()*，以便子挂载会在挂载目标下被复制。这就是所谓的*递归绑定挂载*。*mount(8)*命令提供了`--rbind`选项，可以通过这个选项从shell中实现相同的效果，如下所示的shell会话所示。
- en: We begin by creating a directory tree (`src1`) mounted under `top`. This tree
    includes a submount (`src2`) at `top/sub`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个挂载在`top`下的目录树（`src1`）。该树包含一个在`top/sub`处的子挂载（`src2`）。
- en: '[PRE15]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we create another bind mount (`dir1`) using `top` as the source. Since this
    new mount is nonrecursive, the submount is not replicated.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用`top`作为源，创建另一个绑定挂载（`dir1`）。由于这个新挂载是非递归的，因此子挂载不会被复制。
- en: '[PRE16]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The absence of `dir1/sub/bbb` in the output of *find* shows that the submount
    `top/sub` was not replicated.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在*find*命令的输出中没有`dir1/sub/bbb`，这表明子挂载`top/sub`没有被复制。
- en: Now we create a recursive bind mount (`dir2`) using `top` as the source.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用`top`作为源，创建一个递归绑定挂载（`dir2`）。
- en: '[PRE17]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The presence of `dir2/sub/bbb` in the output of *find* shows that the submount
    `top/sub` was replicated.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在*find*命令的输出中存在`dir2/sub/bbb`，这表明子挂载`top/sub`已经被复制。
- en: 'A Virtual Memory File System: *tmpfs*'
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟内存文件系统：*tmpfs*
- en: 'All of the file systems we have described so far in this chapter reside on
    disks. However, Linux also supports the notion of *virtual file systems* that
    reside in memory. To applications, these look just like any other file system—the
    same operations (*open()*, *read()*, *write()*, *link()*, *mkdir()*, and so on)
    can be applied to files and directories in such file systems. There is, however,
    one important difference: file operations are much faster, since no disk access
    is involved.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本章中描述的所有文件系统都驻留在磁盘上。然而，Linux还支持驻留在内存中的*虚拟文件系统*的概念。对于应用程序来说，这些文件系统看起来就像任何其他文件系统——可以对这些文件系统中的文件和目录执行相同的操作（*open()*,
    *read()*, *write()*, *link()*, *mkdir()*等）。不过，有一个重要的区别：文件操作要快得多，因为不涉及磁盘访问。
- en: Various memory-based file systems have been developed for Linux. The most sophisticated
    of these to date is the *tmpfs* file system, which first appeared in Linux 2.4\.
    The *tmpfs* file system differs from other memory-based file systems in that it
    is a *virtual* memory file system. This means that *tmpfs* uses not only RAM,
    but also the swap space, if RAM is exhausted. (Although the *tmpfs* file system
    described here is Linux-specific, most UNIX implementations provide some form
    of memory-based file system.)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 各种基于内存的文件系统已经为Linux开发。到目前为止，最先进的是*tmpfs*文件系统，它首次出现在Linux 2.4中。*tmpfs*文件系统与其他基于内存的文件系统不同，它是一个*虚拟*内存文件系统。这意味着*tmpfs*不仅使用RAM，如果RAM不足，还会使用交换空间。（尽管此处描述的*tmpfs*文件系统是Linux特有的，但大多数UNIX实现提供某种形式的基于内存的文件系统。）
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *tmpfs* file system is an optional Linux kernel component that is configured
    via the `CONFIG_TMPFS` option.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*tmpfs*文件系统是一个可选的Linux内核组件，可以通过`CONFIG_TMPFS`选项进行配置。'
- en: 'To create a *tmpfs* file system, we use a command of the following form:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个*tmpfs*文件系统，我们使用以下形式的命令：
- en: '[PRE18]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The *source* can be any name; its only significance is that it appears in `/proc/mounts`
    and is displayed by the *mount* and *df* commands. As usual, *target* is the mount
    point for the file system. Note that it is not necessary to use *mkfs* to create
    a file system first, because the kernel automatically builds a file system as
    part of the *mount()* system call.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*source*可以是任何名称；它的唯一意义在于它出现在`/proc/mounts`中，并且由*mount*和*df*命令显示。如通常情况，*target*是文件系统的挂载点。请注意，不需要使用*mkfs*首先创建文件系统，因为内核会自动在*mount()*系统调用中构建一个文件系统。'
- en: 'As an example of the use of *tmpfs*, we could employ mount stacking (so that
    we don’t need to care if `/tmp` is already in use) and create a *tmpfs* file system
    mounted on `/tmp` as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用*tmpfs*的示例，我们可以使用挂载堆叠（这样我们就不需要担心`/tmp`是否已经在使用）并创建一个挂载在`/tmp`的*tmpfs*文件系统，如下所示：
- en: '[PRE19]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A command such as the above (or an equivalent entry in `/etc/fstab`) is sometimes
    used to improve the performance of applications (e.g., compilers) that make heavy
    use of the `/tmp` directory for creating temporary files.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令（或`/etc/fstab`中的等效条目）有时用于提高大量使用`/tmp`目录来创建临时文件的应用程序（例如编译器）的性能。
- en: By default, a *tmpfs* file system is permitted to grow to half the size of RAM,
    but the *size=nbytes mount* option can be used to set a different ceiling for
    the file-system size, either when the file system is created or during a later
    remount. (A *tmpfs* file system consumes only as much memory and swap space as
    is currently required for the files it holds.)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*tmpfs*文件系统的大小允许增长到RAM的一半，但可以使用*size=nbytes mount*选项来设置文件系统大小的不同上限，无论是在创建文件系统时还是在稍后的重新挂载时。（*tmpfs*文件系统仅消耗当前存储其文件所需的内存和交换空间。）
- en: If we unmount a *tmpfs* file system, or the system crashes, then all data in
    the file system is lost; hence the name *tmpfs*.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们卸载一个*tmpfs*文件系统，或者系统崩溃，那么文件系统中的所有数据都会丢失；这就是*tmpfs*名称的由来。
- en: 'Aside from use by user applications, *tmpfs* file systems also serve two special
    purposes:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 除了被用户应用程序使用外，*tmpfs*文件系统还有两个特殊的用途：
- en: An invisible *tmpfs* file system, mounted internally by the kernel, is used
    for implementing System V shared memory ([Chapter 48](ch48.html "Chapter 48. System
    V Shared Memory")) and shared anonymous memory mappings ([Chapter 49](ch49.html
    "Chapter 49. Memory Mappings")).
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由内核内部挂载的不可见*tmpfs*文件系统用于实现System V共享内存（[第48章](ch48.html "第48章：System V共享内存")）和共享匿名内存映射（[第49章](ch49.html
    "第49章：内存映射")）。
- en: A *tmpfs* file system mounted at `/dev/shm` is used for the *glibc* implementation
    of POSIX shared memory and POSIX semaphores.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载在`/dev/shm`的*tmpfs*文件系统用于*glibc*实现的POSIX共享内存和POSIX信号量。
- en: 'Obtaining Information About a File System: *statvfs()*'
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取文件系统信息：*statvfs()*
- en: The *statvfs()* and *fstatvfs()* library functions obtain information about
    a mounted file system.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*statvfs()*和*fstatvfs()*库函数用于获取挂载文件系统的信息。'
- en: '[PRE20]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 两者在成功时返回0，出错时返回-1。
- en: 'The only difference between these two functions is in how the file system is
    identified. For *statvfs()*, we use *pathname* to specify the name of any file
    in the file system. For *fstatvfs()*, we specify an open file descriptor, *fd*,
    referring to any file in the file system. Both functions return a *statvfs* structure
    containing information about the file system in the buffer pointed to by *statvfsbuf*.
    This structure has the following form:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数之间的唯一区别在于文件系统的识别方式。对于*statvfs()*，我们使用*pathname*来指定文件系统中任何文件的名称。对于*fstatvfs()*，我们指定一个打开的文件描述符*fd*，它指向文件系统中的任何文件。这两个函数都返回一个*statvfs*结构，包含指向*statvfsbuf*的缓冲区中的文件系统信息。该结构具有以下形式：
- en: '[PRE21]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The purpose of most of the fields in the *statvfs* structure is made clear
    in the comments above. We note a few further points regarding some fields:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*statvfs*结构中大多数字段的目的如上面注释中所述。我们注意到一些字段的进一步说明：'
- en: The *fsblkcnt_t* and *fsfilcnt_t* data types are integer types specified by
    SUSv3.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*fsblkcnt_t*和*fsfilcnt_t*数据类型是由SUSv3指定的整数类型。'
- en: For most Linux file systems, the values of *f_bsize* and *f_frsize* are the
    same. However, some file systems support the notion of block fragments, which
    can be used to allocate a smaller unit of storage at the end of the file if a
    full block is not required. This avoids the waste of space that would otherwise
    occur if a full block was allocated. On such file systems, *f_frsize* is the size
    of a fragment, and *f_bsize* is the size of a whole block. (The notion of fragments
    in UNIX file systems first appeared in the early 1980s with the 4.2BSD Fast File
    System, described in [McKusick et al., 1984].)
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大多数 Linux 文件系统，*f_bsize* 和 *f_frsize* 的值是相同的。然而，一些文件系统支持块片段的概念，如果不需要完整的块，可以在文件末尾分配一个更小的存储单元。这样可以避免分配完整块时浪费空间。在这些文件系统中，*f_frsize*
    是片段的大小，*f_bsize* 是完整块的大小。（UNIX 文件系统中的片段概念首次出现在 1980 年代初期的 4.2BSD 快速文件系统中，详见 [McKusick
    等，1984]。）
- en: Many native UNIX and Linux file systems support the notion of reserving a certain
    portion of the blocks of a file system for the superuser, so that if the file
    system fills up, the superuser can still log in to the system and do some work
    to resolve the problem. If there are reserved blocks in the file system, then
    the difference in values of the *f_bfree* and *f_bavail* fields in the *statvfs*
    structure tells us how many blocks are reserved.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多原生 UNIX 和 Linux 文件系统支持为超级用户保留文件系统的一定块，以便如果文件系统已满，超级用户仍然可以登录系统并进行一些工作来解决问题。如果文件系统中有保留的块，那么
    *statvfs* 结构中 *f_bfree* 和 *f_bavail* 字段的值差异告诉我们有多少块是保留的。
- en: The *f_flag* field is a bit mask of the flags used to mount the file system;
    that is, it contains information similar to the *mountflags* argument given to
    *mount(2)*. However, the constants used for the bits in this field have names
    starting with `ST_` instead of the `MS_` used for *mountflags*. SUSv3 requires
    only the `ST_RDONLY` and `ST_NOSUID` constants, but the *glibc* implementation
    supports a full range of constants with names corresponding to the `MS_*` constants
    described for the *mount() mountflags* argument.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f_flag* 字段是用于挂载文件系统的标志的位掩码；也就是说，它包含类似于传递给 *mount(2)* 的 *mountflags* 参数的信息。然而，该字段中用于位的常量的名称以
    `ST_` 开头，而不是 *mountflags* 中使用的 `MS_`。SUSv3 只要求 `ST_RDONLY` 和 `ST_NOSUID` 常量，但
    *glibc* 实现支持一整套常量，名称对应于 *mount() mountflags* 参数中描述的 `MS_*` 常量。'
- en: The *f_fsid* field is used on some UNIX implementations to return a unique identifier
    for the file system—for example, a value based on the identifier of the device
    on which the file system resides. For most Linux file systems, this field contains
    0.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f_fsid* 字段在某些 UNIX 实现中用于返回文件系统的唯一标识符——例如，基于文件系统所在设备的标识符。对于大多数 Linux 文件系统，该字段包含
    0。'
- en: SUSv3 specifies both *statvfs()* and *fstatvfs()*. On Linux (as on several other
    UNIX implementations), these functions are layered on top of the quite similar
    *statfs()* and *fstatfs()* system calls. (Some UNIX implementations provide a
    *statfs()* system call, but don’t provide *statvfs()*.) The principal differences
    (aside from some differently named fields) are as follows
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定了 *statvfs()* 和 *fstatvfs()*。在 Linux（以及其他一些 UNIX 实现）中，这些函数是建立在类似的 *statfs()*
    和 *fstatfs()* 系统调用之上的。（一些 UNIX 实现提供 *statfs()* 系统调用，但不提供 *statvfs()*。）主要区别（除了某些字段名称不同）如下：
- en: The *statvfs()* and *fstatvfs()* functions return the *f_flag* field, giving
    information about the file-system mount flags. (The *glibc* implementation obtains
    this information by scanning `/proc/mounts` or `/etc/mtab`.)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*statvfs()* 和 *fstatvfs()* 函数返回 *f_flag* 字段，提供关于文件系统挂载标志的信息。（*glibc* 实现通过扫描
    `/proc/mounts` 或 `/etc/mtab` 获取此信息。）'
- en: The *statfs()* and *fstatfs()* system calls return the field *f_type*, giving
    the type of the file system (e.g., the value `0xef53` indicates that this is an
    *ext2* file system).
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*statfs()* 和 *fstatfs()* 系统调用返回字段 *f_type*，提供文件系统的类型（例如，值 `0xef53` 表示这是一个 *ext2*
    文件系统）。'
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `filesys` subdirectory in the source code distribution for this book contains
    two files, `t_statvfs.c` and `t_statfs.c`, demonstrating the use of *statvfs()*
    and *statfs()*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码分发包中的 `filesys` 子目录包含两个文件，`t_statvfs.c` 和 `t_statfs.c`，演示了 *statvfs()*
    和 *statfs()* 的使用。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Devices are represented by entries in the `/dev` directory. Each device has
    a corresponding device driver, which implements a standard set of operations,
    including those corresponding to the *open()*, *read()*, *write()*, and *close()*
    system calls. A device may be real, meaning that there is a corresponding hardware
    device, or virtual, meaning that no hardware device exists, but the kernel nevertheless
    provides a device driver that implements an API that is the same as a real device.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 设备通过 `/dev` 目录中的条目表示。每个设备都有一个相应的设备驱动程序，该驱动程序实现一套标准操作，包括与 *open()*、*read()*、*write()*
    和 *close()* 系统调用对应的操作。设备可以是真实的，意味着有相应的硬件设备，或者是虚拟的，意味着没有硬件设备存在，但内核仍然提供一个设备驱动程序，实现在
    API 层面与真实设备相同。
- en: A hard disk is divided into one or more partitions, each of which may contain
    a file system. A file system is an organized collection of regular files and directories.
    Linux implements a wide variety of file systems, including the traditional *ext2*
    file system. The *ext2* file system is conceptually similar to early UNIX file
    systems, consisting of a boot block, a superblock, an i-node table, and a data
    area containing file data blocks. Each file has an entry in the file system’s
    i-node table. This entry contains various information about the file, including
    its type, size, link count, ownership, permissions, timestamps, and pointers to
    the file’s data blocks.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘被划分为一个或多个分区，每个分区可能包含一个文件系统。文件系统是一个组织良好的常规文件和目录的集合。Linux 实现了多种文件系统，包括传统的 *ext2*
    文件系统。*ext2* 文件系统在概念上类似于早期的 UNIX 文件系统，包含一个启动块、一个超级块、一个 i-node 表和一个包含文件数据块的数据区域。每个文件在文件系统的
    i-node 表中都有一个条目。该条目包含有关文件的各种信息，包括其类型、大小、链接计数、所有权、权限、时间戳以及指向文件数据块的指针。
- en: Linux provides a range of journaling file systems, including *Reiserfs*, *ext3*,
    *ext4*, *XFS*, *JFS*, and *Btrfs*. A journaling file system records metadata updates
    (and optionally on some file systems, data updates) to a log file before the actual
    file updates are performed. This means that in the event of a system crash, the
    log file can be replayed to quickly restore the file system to a consistent state.
    The key benefit of journaling file systems is that they avoid the lengthy file-system
    consistency checks required by conventional UNIX file systems after a system crash.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 提供了一系列日志文件系统，包括 *Reiserfs*、*ext3*、*ext4*、*XFS*、*JFS* 和 *Btrfs*。日志文件系统会在实际文件更新之前，将元数据更新（在某些文件系统中可选地包括数据更新）记录到日志文件中。这意味着在系统崩溃的情况下，可以通过重放日志文件来快速将文件系统恢复到一致的状态。日志文件系统的主要优点是，它们避免了传统
    UNIX 文件系统在系统崩溃后需要进行的长时间文件系统一致性检查。
- en: All file systems on a Linux system are mounted under a single directory tree,
    with the directory `/` at its root. The location at which a file system is mounted
    in the directory tree is called its mount point.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统上的所有文件系统都挂载在一个单一的目录树下，目录 `/` 为其根目录。文件系统在目录树中的挂载位置称为其挂载点。
- en: A privileged process can mount and unmount a file system using the *mount()*
    and *umount()* system calls. Information about a mounted file system can be retrieved
    using *statvfs()*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 特权进程可以使用 *mount()* 和 *umount()* 系统调用来挂载和卸载文件系统。有关已挂载文件系统的信息可以通过 *statvfs()*
    获取。
- en: Further information
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步的信息
- en: For detailed information about devices and device drivers, see [Bovet & Cesati,
    2005] and especially [Corbet et al., 2005]. Some useful information about devices
    can be found in the kernel source file `Documentation/devices.txt`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 有关设备和设备驱动程序的详细信息，请参阅 [Bovet & Cesati, 2005]，尤其是 [Corbet et al., 2005]。有关设备的一些有用信息可以在内核源文件
    `Documentation/devices.txt` 中找到。
- en: Several books provide further information about file systems. [Tanenbaum, 2007]
    is a general introduction to file-system structures and implementation. [Bach,
    1986] provides an introduction to the implementation of UNIX file systems, oriented
    primarily toward System V. [Vahalia, 1996] and [Goodheart & Cox, 1994] also describe
    the System V file-system implementation. [Love, 2010] and [Bovet & Cesati, 2005]
    describe the Linux VFS implementation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 有几本书提供了有关文件系统的进一步信息。[Tanenbaum, 2007] 是一本关于文件系统结构和实现的一般介绍。[Bach, 1986] 提供了关于
    UNIX 文件系统实现的介绍，主要面向 System V。[Vahalia, 1996] 和 [Goodheart & Cox, 1994] 也描述了 System
    V 文件系统的实现。[Love, 2010] 和 [Bovet & Cesati, 2005] 描述了 Linux VFS 的实现。
- en: Documentation on various file systems can be found in the kernel source subdirectory
    `Documentation/filesystems`. Individual web sites can be found describing most
    of the file-system implementations available on Linux.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有关各种文件系统的文档可以在内核源代码子目录`Documentation/filesystems`中找到。描述Linux上大多数文件系统实现的个人网站也可以找到。
- en: Exercise
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Write a program that measures the time required to create and then remove a
    large number of 1-byte files from a single directory. The program should create
    files with names of the form `xNNNNNN`, where `NNNNNN` is replaced by a random
    six-digit number. The files should be created in the random order in which their
    names are generated, and then deleted in increasing numerical order (i.e., an
    order that is different from that in which they were created). The number of files
    (*NF*) and the directory in which they are to be created should be specifiable
    on the command line. Measure the times required for different values of *NF* (e.g.,
    in the range from 1000 to 20,000) and for different file systems (e.g., *ext2*,
    *ext3*, and *XFS*). What patterns do you observe on each file system as *NF* increases?
    How do the various file systems compare? Do the results change if the files are
    created in increasing numerical order (`x000001`, `x000001`, `x0000002`, and so
    on) and then deleted in the same order? If so, what do you think the reason(s)
    might be? Again, do the results vary across file-system types?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，测量在单个目录中创建并删除大量1字节文件所需的时间。程序应创建名称形式为`xNNNNNN`的文件，其中`NNNNNN`由一个随机的六位数字替换。文件应按照生成名称的随机顺序创建，然后按递增的数字顺序删除（即与创建时的顺序不同）。文件数量（*NF*）和文件创建目录应在命令行中指定。测量不同*NF*值（例如从1000到20000的范围）和不同文件系统（例如*ext2*、*ext3*、*XFS*）下的时间。随着*NF*的增加，你在每种文件系统上观察到什么模式？不同的文件系统如何比较？如果文件按递增数字顺序创建（`x000001`、`x000002`、`x000003`，以此类推），并按相同的顺序删除，结果是否有所不同？如果不同，你认为可能的原因是什么？同样，结果是否在不同文件系统类型之间有所变化？
