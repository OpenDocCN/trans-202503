<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Controllers"><div class="titlepage"><div><div><h1 class="title"><a id="controllers"/>Chapter 4. Controllers</h1></div></div></div><p><a class="indexterm" id="iddle1377"/><a class="indexterm" id="iddle1563"/><a class="indexterm" id="iddle2093"/><a class="indexterm" id="iddle2108"/>Rails <span class="emphasis"><em>controllers</em></span> connect your application’s models
        and views. Any web requests that your application receives are routed to the appropriate
        controller. The controller gets data from the model and then renders the appropriate view or
        redirects to a different location.</p><p>In this chapter, we continue working on our blog. Along the way, you’ll learn
        about controllers in detail. I’ll cover resource representation with REST, routing
        resources, and the types of actions a controller can take.</p><div class="sect1" title="Representational State Transfer"><div class="titlepage"><div><div><h1 class="title"><a id="representational_state_transfer"/>Representational State Transfer</h1></div></div></div><p><span class="emphasis"><em>Representational State Transfer</em></span>, or <span class="emphasis"><em>REST</em></span>, is
          a client-server software architecture introduced in 2000 by Dr. Roy Fielding, one of the
          authors of the HTTP specification. REST deals with the representation of resources, and in
          Rails, resources correspond to models. In RESTful architectures, clients initiate requests
          to servers. Servers process those requests and return <a class="indexterm" id="iddle1390"/><a class="indexterm" id="iddle1407"/><a class="indexterm" id="iddle1434"/><a class="indexterm" id="iddle1436"/><a class="indexterm" id="iddle1475"/><a class="indexterm" id="iddle1487"/><a class="indexterm" id="iddle1521"/><a class="indexterm" id="iddle1622"/><a class="indexterm" id="iddle1706"/><a class="indexterm" id="iddle1720"/><a class="indexterm" id="iddle1872"/><a class="indexterm" id="iddle1940"/><a class="indexterm" id="iddle1976"/><a class="indexterm" id="iddle2157"/><a class="indexterm" id="iddle2278"/>responses to the clients. In a Rails application, the server that processes
          requests and returns responses is the controller. The controller interacts with the client
          through a collection of common URLs and HTTP verbs.</p><p>You’re probably already familiar with at least two of these HTTP verbs. A
          request for a web page is sometimes called a <span class="emphasis"><em>GET</em></span> request. A GET
          request doesn’t change the state of the application; it simply returns data. When
          you submit form data on a web page, the result is usually a <span class="emphasis"><em>POST</em></span>
          request. In an application using REST, a POST request is used to create a record on the
          server.</p><p>During our discussion of models in the last chapter, you learned about CRUD (create,
          read, update, and delete). REST uses the four HTTP verbs in <a class="xref" href="ch04.html#mapping_database_actions_to_http_verbs" title="Table 4-1. Mapping Database Actions to HTTP Verbs">Table 4-1</a>, which correspond to each of those
          actions.</p><div class="table"><a id="mapping_database_actions_to_http_verbs"/><p class="title">Table 4-1. Mapping Database Actions to HTTP Verbs</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Mapping Database Actions to HTTP Verbs"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Database Action</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>HTTP Verb</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">Create</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>POST</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">Read</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>GET</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">Update</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>PATCH</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">Delete</code></p></td><td style="" valign="top"><p>DELETE</p></td></tr></tbody></table></div></div><p>Your application determines how to handle a request based on the HTTP verb used. A GET
          request for a resource returns the data from the corresponding model; a PATCH request
          updates the model with new information; and a DELETE request destroys the model. All three
          of these actions use the same URL. Only the HTTP verb is different.</p><p>Rails applications add three more actions in addition to the four CRUD actions in
            <a class="xref" href="ch04.html#mapping_database_actions_to_http_verbs" title="Table 4-1. Mapping Database Actions to HTTP Verbs">Table 4-1</a>. The <code class="literal">index</code>
          action displays a list of all resources; the <code class="literal">new</code> action displays a form
          for creating a new resource; and the <code class="literal">edit</code> action displays a form for
          editing an existing resource.</p><p>Each of these actions has a corresponding method in a Rails controller. These seven
          methods are summarized in <a class="xref" href="ch04.html#default_restful_actions" title="Table 4-2. Default RESTful Actions">Table 4-2</a>.</p><div class="table"><a id="default_restful_actions"/><p class="title">Table 4-2. Default RESTful Actions</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Default RESTful Actions"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Action</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Description</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>HTTP Verb</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">index</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>List all records</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>GET</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">show</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Show one record</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>GET</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">new</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Show form to create a record</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>GET</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">edit</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Show form to edit a record</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>GET</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">create</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Create a new record</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>POST</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">update</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Update an existing record</p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>PATCH</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">destroy</code></p></td><td style="border-right: 0.5pt solid ; " valign="top"><p>Delete a record</p></td><td style="" valign="top"><p>DELETE</p></td></tr></tbody></table></div></div><p>We’ll cover each of these actions in this chapter, but first let’s see how
          URLs are generated.</p></div><div class="sect1" title="Routing"><div class="titlepage"><div><div><h1 class="title"><a id="routing"/>Routing</h1></div></div></div><p><a class="indexterm" id="iddle1365"/><a class="indexterm" id="iddle1510"/><a class="indexterm" id="iddle1870"/><a class="indexterm" id="iddle2100"/><a class="indexterm" id="iddle2116"/><a class="indexterm" id="iddle2287"/>Setting up all of these URLs and mapping actions to verbs might sound pretty
          complicated, but luckily, Rails routing handles all of this for you.
            <span class="emphasis"><em>Routes</em></span> connect URLs to the code that comprises an application.
          First, let’s look at the most common type of route, the resource route.</p><div class="sect2" title="Resources"><div class="titlepage"><div><div><h2 class="title"><a id="resources"/>Resources</h2></div></div></div><p>Your application’s routes are stored in the file
              <span class="emphasis"><em>config/routes.rb</em></span>. Open that file in your text editor.</p><p>Ignore all of the comments. Your file should only have three lines right now:</p><a id="pro_id00103"/><pre class="programlisting">Rails.application.routes.draw do
  resources :posts
end</pre><p>Rails applications use REST by default. The blog application currently has only one
            resource (blog posts), and the single line <code class="literal">resources :posts</code> builds a
            set of routes for your application. Use the <code class="literal">rake</code> command to display
            your application’s routes:</p><a id="pro_id00104"/><pre class="programlisting">$ <span class="strong"><strong>bin/rake routes</strong></span>
Prefix Verb   URI Pattern                Controller#Action
 posts GET    /posts(.:format)           posts#index
       POST   /posts(.:format)           posts#create
--<span class="emphasis"><em>snip</em></span>--</pre><p>This command outputs the route helper prefix, HTTP verb, URL pattern, and controller
            action for each of the seven default RESTful actions.</p><p>For example, a GET request to <span class="emphasis"><em>/posts</em></span> calls the
              <code class="literal">PostsController#index</code> method. As you make changes to the routes
            file, run this command again to see how your application’s routes also
            change.</p><div class="sect3" title="Nested Resources"><div class="titlepage"><div><div><h3 class="title"><a id="nested_resources"/>Nested Resources</h3></div></div></div><p>When one resource belongs to another resource, you can add it as a
                <span class="emphasis"><em>nested resource</em></span>. In the blog, comments belong to posts.
              Here’s how you represent that in <span class="emphasis"><em>config/routes.rb</em></span>:</p><a id="pro_id00105"/><pre class="programlisting">resources :posts <span class="strong"><strong>do</strong></span>
  <span class="strong"><strong>resources :comments</strong></span>
<span class="strong"><strong>end</strong></span></pre><p>Add a block after <code class="literal">resources :posts</code> with a
              <code class="literal">do</code>, <code class="literal">end</code> pair. Then add <code class="literal">resources
                :comments</code> inside that block. This tells Rails that comments are only
              available inside of posts.</p></div><div class="sect3" title="Restricted Resources"><div class="titlepage"><div><div><h3 class="title"><a id="restricted_resources"/>Restricted Resources</h3></div></div></div><p><a class="indexterm" id="iddle1366"/><a class="indexterm" id="iddle1428"/><a class="indexterm" id="iddle1476"/><a class="indexterm" id="iddle1623"/><a class="indexterm" id="iddle1810"/><a class="indexterm" id="iddle1812"/><a class="indexterm" id="iddle1977"/><a class="indexterm" id="iddle2101"/><a class="indexterm" id="iddle2109"/><a class="indexterm" id="iddle2117"/>Adding <code class="literal">resources :comments</code> as you just saw creates
              routes for each of the seven default RESTful actions for comments. For now,
              let’s only worry about creating new comments. You can restrict the set of routes
              generated for a resource by adding an <code class="literal">only</code> clause to that resource
              in <span class="emphasis"><em>config/routes.rb</em></span>:</p><a id="pro_id00106"/><pre class="programlisting">resources :posts do
  resources :comments<span class="strong"><strong>, only: :create</strong></span>
end</pre><p>Now, only the comment <code class="literal">create</code> action is mapped to a URL. You
              should only provide routes to actions that you plan to implement.</p></div></div><div class="sect2" title="Custom Routes"><div class="titlepage"><div><div><h2 class="title"><a id="custom_routes"/>Custom Routes</h2></div></div></div><p>Some actions in your application may not correspond to any of the seven default
            actions. For example, your application may include a <code class="literal">search</code> action
            that returns a list of posts containing a specific term. In cases such as this, Rails
            lets you manually configure <span class="emphasis"><em>custom routes</em></span>.</p><p>Custom routes are also useful for mapping old URLs to a new Rails application or
            simplifying URLs for complex actions. For example, imagine your application allows users
            to log in by creating a new session and log out by destroying their session. Adding
              <code class="literal">resources :user_session</code> creates paths like
              <span class="emphasis"><em>user_session/new</em></span>. If you would rather use different paths, you
            can create custom routes for <span class="emphasis"><em>login</em></span> and
            <span class="emphasis"><em>logout.</em></span></p><a id="pro_id00107"/><pre class="programlisting">Rails.application.routes.draw do
  resources :posts do
    resources :comments, :only =&gt; :create
  end

  <span class="strong"><strong>get 'login' =&gt; 'user_sessions#new'</strong></span>
  <span class="strong"><strong>post 'login' =&gt; 'user_session#create'</strong></span>
  <span class="strong"><strong>delete 'logout' =&gt; 'user_sessions#destroy'</strong></span>
end</pre><p>Now your application’s login page should be at the path
              <span class="emphasis"><em>/login</em></span>. When a user visits the login page, his or her browser
            sends a GET request for this path. The controller displays the login form in response to
            that GET request. When the user submits the form, the browser sends a POST request to
            the same path with the contents of the form. The controller then creates a new session
            for the user in response to the POST request. When the user clicks the log out button, a
            DELETE request to the path <span class="emphasis"><em>/logout</em></span> destroys the user’s
            session.</p><p>We aren’t adding authentication to the blog application, but you can still add
            these routes to <span class="emphasis"><em>config/routes.rb</em></span> if you want to see the routes
            created. Remove them before moving on because accessing a path that doesn’t
            correspond to a controller action results in an error.</p></div><div class="sect2" title="The Root Route"><div class="titlepage"><div><div><h2 class="title"><a id="root_route"/>The Root Route</h2></div></div></div><p><a class="indexterm" id="iddle1380"/><a class="indexterm" id="iddle1684"/><a class="indexterm" id="iddle1697"/><a class="indexterm" id="iddle1943"/><a class="indexterm" id="iddle2113"/><a class="indexterm" id="iddle2118"/><a class="indexterm" id="iddle2235"/><a class="indexterm" id="iddle2285"/>Finally, let’s create a <span class="emphasis"><em>root route</em></span> so we
            don’t have to add <span class="emphasis"><em>/posts</em></span> to the browser’s address bar
            every time. The root route sets the home page for your application. Add <code class="literal">root
              'posts#index'</code> near the end of <span class="emphasis"><em>config/routes.rb</em></span>:</p><a id="pro_id00108"/><pre class="programlisting">Rails.application.routes.draw do
  resources :posts do
    resources :comments, :only =&gt; :create
  end
  <span class="strong"><strong>root 'posts#index'</strong></span>
end</pre><p>Now, accessing your server without a path should display the posts index page. You
            should always include a root route for your application.</p></div><div class="sect2" title="Paths and URLs"><div class="titlepage"><div><div><h2 class="title"><a id="paths_and_urls"/>Paths and URLs</h2></div></div></div><p>Adding a route also automatically creates helpers for your controllers and views.
            You can use these helpers, shown in <a class="xref" href="ch04.html#rails_path_and_url_helpers" title="Table 4-3. Rails Path and URL Helpers">Table 4-3</a>,
            instead of manually typing URLs in your application. That way, if you decide to change
            your application’s URLs in the future, you won’t have to search for and
            update all of the old URLs in your code.</p><div class="table"><a id="rails_path_and_url_helpers"/><p class="title">Table 4-3. Rails Path and URL Helpers</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Rails Path and URL Helpers"><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Path Helpers</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>URL Helpers</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">posts_path</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">posts_url</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">new_post_path</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">new_post_url</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">edit_post_path(id)</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">edit_post_url(id)</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">post_path(id)</code></p></td><td style="" valign="top"><p><code class="literal">post_url(id)</code></p></td></tr></tbody></table></div></div><p>The <span class="emphasis"><em>path helpers</em></span> include only the path, whereas the
              <span class="emphasis"><em>URL helpers</em></span> also include the protocol, server, and port (if not
            standard). Rails applications generally use path helpers. The URL helpers are useful for
            situations in which the full URL is needed, such as to generate URLs for inclusion in
            emails.</p><p>The first part of each method name matches the prefix displayed by the
              <code class="literal">bin/rake routes</code> command.</p><p>You can test these helpers in the Rails console like this:</p><a id="pro_id00109"/><pre class="programlisting">2.1.0 :001 &gt; <span class="strong"><strong>app.posts_path</strong></span>
 =&gt; "/posts"
2.1.0 :002 &gt; <span class="strong"><strong>app.post_path(1)</strong></span>
 =&gt; "/posts/1"
2.1.0 :003 &gt; <span class="strong"><strong>app.new_post_path</strong></span>
 =&gt; "/posts/new"
2.1.0 :004 &gt; <span class="strong"><strong>app.root_path</strong></span>
 =&gt; "/"</pre><p><a class="indexterm" id="iddle1089"/><a class="indexterm" id="iddle1225"/><a class="indexterm" id="iddle1378"/><a class="indexterm" id="iddle1437"/><a class="indexterm" id="iddle1721"/><a class="indexterm" id="iddle2152"/><a class="indexterm" id="iddle2158"/>Testing these helpers is a useful sanity check when working with Rails
            routes. If you forget which helper to use to create a path, you can type it in the
            console to see the result.</p></div></div><div class="sect1" title="Controller Actions"><div class="titlepage"><div><div><h1 class="title"><a id="controller_actions"/>Controller Actions</h1></div></div></div><p>The convention in Rails is to have a controller corresponding to each resource. That
          controller includes methods for each action. (Remember the principle from <a class="xref" href="ch02.html" title="Chapter 2. Rails Fundamentals">Chapter 2</a>: convention over configuration.) The Rails scaffold
          generator created a controller for posts. Open the file
            <span class="emphasis"><em>app/controllers/posts_controller.rb</em></span> to see the Ruby code behind
          these methods. I recommend running the Rails server as you work your way through the rest
          of this chapter:</p><a id="pro_id00110"/><pre class="programlisting">$ <span class="strong"><strong>bin/rails server</strong></span></pre><p>Now, let’s look at each controller method in turn, starting with
            <code class="literal">index</code> and working our way down to <code class="literal">destroy</code>.</p><p>The <code class="literal">index</code> action retrieves all posts from the database:</p><a id="pro_id00111"/><pre class="programlisting">def index
  @posts = Post.all
end</pre><p>You see the familiar <code class="literal">@post = Post.all</code> in that method. You may be
          surprised that this is the <span class="emphasis"><em>only</em></span> line of code in the
            <code class="literal">index</code> method. By default, Rails renders a view file matching the
          action name, in this case <span class="emphasis"><em>app/views/posts/index.html.erb</em></span>.
          (We’ll discuss views in the next chapter.)</p><p>Go to <span class="emphasis"><em>http://localhost:3000/posts</em></span> in your browser to see the
          results of the <code class="literal">index</code> action.</p><p>The <code class="literal">show</code> action retrieves a single post from the database, but the
            <code class="literal">show</code> method contains no code at all:</p><a id="pro_id00112"/><pre class="programlisting">def show
end</pre><p>This method relies on a Rails <code class="literal">before_action</code>, which you should see
          on line two of the controller:</p><a id="pro_id00113"/><pre class="programlisting">before_action :set_post, only: [:show, :edit, :update, :destroy]</pre><p>The <code class="literal">before_action</code> is a class method that automatically calls the
            <code class="literal">set_post</code> method, shown next, before the methods
            <code class="literal">show</code>, <code class="literal">edit</code>, <code class="literal">update</code>, and
            <code class="literal">destroy</code>. This eliminates duplicate code in these methods. (Remember
          DRY: Don’t repeat yourself.)</p><a id="pro_id00114"/><pre class="programlisting">def set_post
  @post = Post.find(params[:id])
end</pre><p><a class="indexterm" id="iddle1381"/><a class="indexterm" id="iddle1522"/><a class="indexterm" id="iddle1873"/><a class="indexterm" id="iddle1926"/><a class="indexterm" id="iddle1930"/>The <code class="literal">set_post</code> method is defined near the bottom of the
          controller under the keyword <code class="literal">private</code>. It calls the
            <code class="literal">Post.find</code> method to retrieve the post with an <code class="literal">id</code>
          corresponding to a parameter passed to the controller. Parameters are covered in more
          detail in the next section, so for now, let’s continue examining these controller
          methods.</p><p>The <code class="literal">new</code> action displays a form for adding a new post:</p><a id="pro_id00115"/><pre class="programlisting">def new
  @post = Post.new
end</pre><p>The form uses data from a newly created post. Click the <span class="emphasis"><em>New Post</em></span>
          link at the bottom of the post index page to see this form.</p><p>The <code class="literal">edit</code> action displays a form for editing an existing post. Like
          the <code class="literal">show</code> method, this method contains no code:</p><a id="pro_id00116"/><pre class="programlisting">def edit
end</pre><p>This form uses data retrieved by the <code class="literal">set_post</code> method discussed
          previously.</p><div class="sect2" title="A Brief Detour from Actions"><div class="titlepage"><div><div><h2 class="title"><a id="brief_detour_from_actions"/>A Brief Detour from Actions</h2></div></div></div><p>Before discussing <code class="literal">create</code>, <code class="literal">update</code>, and
              <code class="literal">destroy</code>, let’s talk about a few key Rails topics that you
            need to know to understand those methods. In this section, we’ll explore
            parameters, render/redirect, response formats, and the flash.</p><div class="sect3" title="Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="parameters"/>Parameters</h3></div></div></div><p><span class="emphasis"><em>Parameters</em></span> generally represent part of the URL used to
              request a page or values from a form, and they’re accessible in the controller
              as a hash named <code class="literal">params</code>. For example, the
                <code class="literal">set_post</code> method you saw earlier retrieved the
                <code class="literal">id</code> of the requested post from the <code class="literal">params</code> hash,
              like this:</p><a id="pro_id00117"/><pre class="programlisting">@post = Post.find(params[:id])</pre><p>You can see the parameters passed with each request in the output from the
                <code class="literal">rails server</code> command in your terminal. For example, go to
                <span class="emphasis"><em>http://localhost:3000/posts/1</em></span> and then look at the Rails server
              output in your terminal:</p><a id="pro_id00118"/><pre class="programlisting">  Started GET "/posts/1" for 127.0.0.1 at 2014-03-31 20:30:03 -0500
  Processing by PostsController#show as HTML
➊   Parameters: {"id"=&gt;"1"}
    Post Load (0.3ms) SELECT "posts".* FROM "posts"
      WHERE "posts"."id" = ? LIMIT 1 [["id", "1"]]
    Rendered posts/show.html.erb within layouts/application (233.9ms)
  Completed 200 OK in 274ms (Views: 245.5ms | ActiveRecord: 26.2ms)</pre><p><a class="indexterm" id="iddle1974"/><a class="indexterm" id="iddle2076"/><a class="indexterm" id="iddle2089"/><a class="indexterm" id="iddle2199"/>In this case, the <code class="literal">1</code> in the URL represents the
                <code class="literal">id</code> of the requested post ➊. Because we requested a single
              post, the <code class="literal">show</code> method is called, and this <code class="literal">id</code> is
              used to find the post in <code class="literal">set_post</code>.</p><p>Form data is represented by a nested hash with values. For example, editing this
              post results in a <code class="literal">params</code> hash more like this:</p><a id="pro_id00119"/><pre class="programlisting">  {
    "utf8"=&gt;"✓",
    "authenticity_token"=&gt;"...",
➊   "post"=&gt;{"title"=&gt;"First Post", "body"=&gt;""},
    "commit"=&gt;"Update Post",
➋   "id"=&gt;"1"
  }</pre><p>You still access <code class="literal">params[:id]</code> ➋ to find the correct post,
              and you can also access <code class="literal">params[:post]</code> ➊ to see the new
              values submitted by the user. Because these are user-submitted values, you should
              ensure that your application only accepts data for the appropriate attributes.
              Malicious users could send requests with invalid parameters in an attempt to attack
              your application.</p><p>For blog posts, you only want users to be able to edit the
                <code class="literal">title</code> and <code class="literal">body</code> attributes. Rails includes a
              feature called <span class="emphasis"><em>Strong Parameters</em></span>, which makes specifying which
              attributes your application accepts easy. You can see the feature in action in the
                <code class="literal">post_params</code> method:</p><a id="pro_id00120"/><pre class="programlisting">def post_params
  params.require(:post).permit(:title, :body)
end</pre><p>This method first requires the <code class="literal">params</code> hash to contain a nested
              hash with the key <code class="literal">:post</code>. It then returns only the permitted values
                (<code class="literal">:title</code> and <code class="literal">:body</code>) from this nested hash.
              Using the earlier example <code class="literal">params</code> hash,
                <code class="literal">post_params</code> returns a hash like this:</p><a id="pro_id00121"/><pre class="programlisting">{"title" =&gt; "First Post", "body" =&gt; ""}</pre><p>Other values in the <code class="literal">params[:post]</code> hash are silently ignored.
              Remember, always use the <code class="literal">post_params</code> method when accessing the
              parameters for a newly created or updated post.</p></div><div class="sect3" title="Render or Redirect"><div class="titlepage"><div><div><h3 class="title"><a id="render_or_redirect"/>Render or Redirect</h3></div></div></div><p>Every action must either <span class="emphasis"><em>render</em></span> a view or
                <span class="emphasis"><em>redirect</em></span> to another action. By default, an action renders a
              file matching the action name. For example, the <code class="literal">show</code> method in the
              posts controller looks for a file named
                <span class="emphasis"><em>app/views/posts/show.html.erb</em></span> and uses that file to build the
              HTML response that is sent back to the user.</p><p><a class="indexterm" id="iddle1064"/><a class="indexterm" id="iddle1110"/><a class="indexterm" id="iddle1382"/><a class="indexterm" id="iddle1770"/><a class="indexterm" id="iddle1780"/><a class="indexterm" id="iddle1879"/><a class="indexterm" id="iddle1945"/><a class="indexterm" id="iddle1978"/><a class="indexterm" id="iddle2077"/><a class="indexterm" id="iddle2086"/><a class="indexterm" id="iddle2280"/><a class="indexterm" id="iddle2342"/>You can tell Rails to render the response for a different action with the
                <code class="literal">render</code> method like this:</p><a id="pro_id00122"/><pre class="programlisting">render action: "edit"</pre><p>The ability to specify actions is helpful if you need to render a different view
              based on user input. This example is from the <code class="literal">update</code> method. If the
              post could not be updated with the data provided by the user, this method renders the
                <code class="literal">edit</code> view again, giving the user a chance to correct the
              data.</p><p>Sometimes you need to send the user to a page other than the one he or she
              requested. Use the <code class="literal">redirect_to</code> method to take care of this. For
              example, if the user enters valid data while creating or updating a post, the
              controller action redirects the user to that post:</p><a id="pro_id00123"/><pre class="programlisting">redirect_to @post</pre><p>When you call <code class="literal">redirect_to</code>, the address in the user’s
              browser changes to reflect the new page, and another request is made. You can see this
              by watching the address bar as you submit form data and by looking at the output from
                <code class="literal">rails server</code> in your terminal.</p><p>To see this in action, first go to
                <span class="emphasis"><em>http://localhost:3000/posts/new</em></span> in your browser. This is the
              new post form. Enter a title for the new post, and then click the <span class="emphasis"><em>Create
                Post</em></span> button. Watch the address bar closely after clicking the
              button.</p><p>The form makes a POST request to <span class="emphasis"><em>http://localhost:3000/posts</em></span>.
              This request is routed to the <code class="literal">create</code> method. After creating the
              post, you are redirected to <span class="emphasis"><em>http://localhost:3000/posts/3</em></span>,
              assuming that your new post has an <code class="literal">id</code> of 3. The address is changed
              automatically by the <code class="literal">redirect_to</code> method.</p></div><div class="sect3" title="Response Formats"><div class="titlepage"><div><div><h3 class="title"><a id="response_formats"/>Response Formats</h3></div></div></div><p>Rails can generate responses in several formats, though all I’ve discussed
              so far is HTML. Scaffold-generated controllers can also include JavaScript Object
              Notation (JSON) responses, which are useful for creating application programming
              interfaces (APIs). Other formats include XML and even PDF.</p><p>You can try another response type in your web browser by visiting this URL:
                <span class="emphasis"><em>http://localhost:3000/posts.json</em></span>. This URL is the same as the
              posts index URL used earlier, except it has <span class="emphasis"><em>.json</em></span> added to the
              end. Rails recognizes this as a JSON request and renders the collection of posts as
              JSON, as in <a class="xref" href="ch04.html#posts_in_json_format" title="Figure 4-1. Posts in JSON format">Figure 4-1</a>.</p><div class="figure"><a id="posts_in_json_format"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00003"/><img alt="Posts in JSON format" src="httpatomoreillycomsourcenostarchimages2169064.png.jpg"/></div></div><p class="title">Figure 4-1. Posts in JSON format</p></div><p><a class="indexterm" id="iddle1386"/><a class="indexterm" id="iddle1576"/><a class="indexterm" id="iddle1988"/>You specify the formats an action accepts and the responses to each format
              with a call to the <code class="literal">respond_to</code> method. This method accepts a block
              with a single parameter representing the requested format. Here is an example from the
                <code class="literal">destroy</code> method:</p><a id="pro_id00124"/><pre class="programlisting">respond_to do |format|
 format.html { redirect_to posts_url }
 format.json { head :no_content }
end</pre><p>This method is called right after a post is destroyed. If the client requests HTML
              data, this block redirects to <code class="literal">posts_url</code>, the index page. If the
              client requests JSON data, by adding <span class="emphasis"><em>.json</em></span> to the end of the URL,
              this block responds with an empty header to indicate the post no longer exists.</p></div><div class="sect3" title="The Flash"><div class="titlepage"><div><div><h3 class="title"><a id="flash"/>The Flash</h3></div></div></div><p><span class="emphasis"><em>Flash messages</em></span> are alerts to the user that are only valid for
              a single request. Flash messages are stored in the user’s session, typically in
              a cookie. They are usually styled differently to stand out. For example, the
              stylesheet included with Rails scaffolding uses green text for flash messages.</p><p>Flash messages are helpful for sending error messages or other notifications to
              the user. They are generally set on a redirect. Here’s an example from the
                <code class="literal">create</code> method in the posts controller:</p><a id="pro_id00125"/><pre class="programlisting">redirect_to @post, notice: 'Post was successfully created.'</pre><p>When a post is successfully created, the user is redirected to the new post and a
              flash message like the one in <a class="xref" href="ch04.html#flash_message" title="Figure 4-2. A flash message">Figure 4-2</a> is shown.</p><div class="figure"><a id="flash_message"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00004"/><img alt="A flash message" src="httpatomoreillycomsourcenostarchimages2169066.png.jpg"/></div></div><p class="title">Figure 4-2. A flash message</p></div><p>The <code class="literal">create</code> flash message is the green text, and it matches the
              message added earlier.</p></div></div><div class="sect2" title="Back to Controller Actions"><div class="titlepage"><div><div><h2 class="title"><a id="back_to_controller_actions"/>Back to Controller Actions</h2></div></div></div><p>Now you should know everything you need to understand the <code class="literal">create</code>,
              <code class="literal">update</code>, and <code class="literal">destroy</code> actions. The methods written
            by the scaffold generator respond to requests for both HTML and JSON data with messages
            indicating success or errors, but let’s focus on the HTML responses for now.
            I’ll cover JSON responses in depth when I talk about building your own
            APIs.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note01"/>Note</h3><p><a class="indexterm" id="iddle1398"/><a class="indexterm" id="iddle1490"/><a class="indexterm" id="iddle1880"/><a class="indexterm" id="iddle1929"/><a class="indexterm" id="iddle2103"/><a class="indexterm" id="iddle2200"/><a class="indexterm" id="iddle2281"/><span class="emphasis"><em>The formatting in each method has been adjusted slightly to
                better fit this page.</em></span></p></div><p>The <code class="literal">create</code> method is responsible for creating a post using the
              <code class="literal">params</code> from the new post form:</p><a id="pro_id00126"/><pre class="programlisting">def create
  @post = Post.new(post_params)

  respond_to do |format|
    if @post.save
      format.html { redirect_to @post,
                    notice: 'Post was successfully created.' }
      format.json { render action: 'show',
                    status: :created, location: @post }
    else
      format.html { render action: 'new' }
      format.json { render json: @post.errors,
                    status: :unprocessable_entity }

    end
  end
end</pre><p>The first line of the method <code class="literal">@post = Post.new(post_params)</code> uses
            Strong Parameters to ensure only the accepted parameters are allowed into the call to
              <code class="literal">new</code>. Inside the <code class="literal">respond_to</code> block, the return
            value of <code class="literal">@post.save</code> is checked. If it’s
            <code class="literal">true</code>, then the user is redirected to the newly created post. If it is
              <code class="literal">false</code>, then the <code class="literal">new</code> action is rendered again so
            the user can correct any errors.</p><p>The <code class="literal">update</code> method is similar to the <code class="literal">create</code>
            method. The main difference is that the code checks the return value of
              <code class="literal">@post.update</code> instead of <code class="literal">@post.save</code>.</p><a id="pro_id00127"/><pre class="programlisting">def update
  respond_to do |format|
    if @post.update(post_params)
      format.html { redirect_to @post,
                    notice: 'Post was successfully updated.' }
      format.json { render action: 'show',
                    status: :ok, location: @post }

    else
      format.html { render action: 'edit' }
      format.json { render json: @post.errors,
                    status: :unprocessable_entity }
    end
  end
end</pre><p>If <code class="literal">@post.update</code> returns <code class="literal">true</code>, the code
            redirects the user to the updated post; otherwise, it renders the edit form so the user
            can correct the errors.</p><p>The <code class="literal">destroy</code> method is simpler than the <code class="literal">create</code>
            and <code class="literal">update</code> methods because it doesn’t check the return value of
              <code class="literal">@post.destroy</code>.</p><a id="pro_id00128"/><pre class="programlisting">def destroy
  @post.destroy
  respond_to do |format|
    format.html { redirect_to posts_url }
    format.json { head :no_content }
  end
end</pre><p><a class="indexterm" id="iddle1342"/><a class="indexterm" id="iddle1394"/><a class="indexterm" id="iddle2051"/>After the post is destroyed, the code redirects the user back to the index
            page, <code class="literal">posts_url</code>.</p></div></div><div class="sect1" title="Adding Comments"><div class="titlepage"><div><div><h1 class="title"><a id="adding_comments"/>Adding Comments</h1></div></div></div><p>You added a route to the <code class="literal">create</code> comment action earlier, so now
          let’s add a simple controller for that action. You’ll add the form for
          entering new comments in the next chapter.</p><p>Generate a new controller for comments using the Rails generator:</p><a id="pro_id00129"/><pre class="programlisting">  $ <span class="strong"><strong>bin/rails generate controller comments</strong></span>
➊    create  app/controllers/comments_controller.rb
     invoke  erb
➋    create    app/views/comments
     invoke  test_unit
     create    test/controllers/comments_controller_test.rb
     invoke  helper
     create    app/helpers/comments_helper.rb
     invoke    test_unit
     create      test/helpers/comments_helper_test.rb
     invoke  assets
     invoke    coffee
     create      app/assets/javascripts/comments.js.coffee
     invoke    scss
     create      app/assets/stylesheets/comments.css.scss</pre><p>Note that I specified only a controller, not scaffolding. This code generates an empty
          controller ➊ and an empty <span class="emphasis"><em>views</em></span> directory ➋, as well as
          files for helpers, tests, and assets. We’ll have to fill in the details ourselves.
          Start by opening the file <span class="emphasis"><em>app/controllers/comments_controller.rb</em></span> in
          your editor:</p><a id="pro_id00130"/><pre class="programlisting">class CommentsController &lt; ApplicationController
end</pre><p>Because you’re implementing the <code class="literal">create</code> action, the first
          thing you need is a <code class="literal">create</code> method. You can model it after the
            <code class="literal">create</code> method in the posts controller. Assume that users won’t
          be adding comments via an API, so it isn’t necessary to generate JSON
          responses.</p><a id="pro_id00131"/><pre class="programlisting">  class CommentsController &lt; ApplicationController
    <span class="strong"><strong>def create</strong></span>
1     <span class="strong"><strong>@post = Post.find(params[:post_id])</strong></span>

2     <span class="strong"><strong>if @post.comments.create(comment_params)</strong></span>
3       <span class="strong"><strong>redirect_to @post,</strong></span>
                    <span class="strong"><strong>notice: 'Comment was successfully created.'</strong></span>
      <span class="strong"><strong>else</strong></span>
        <span class="strong"><strong>redirect_to @post,</strong></span>
                    <span class="strong"><strong>alert: 'Error creating comment.'</strong></span>
      <span class="strong"><strong>end</strong></span>
    <span class="strong"><strong>end</strong></span>
  end</pre><p><a class="indexterm" id="iddle1340"/><a class="indexterm" id="iddle2201"/>This code first finds the correct post ➊ using the
            <code class="literal">post_id</code> in the <code class="literal">params</code> hash. It then uses the
            <code class="literal">comments</code> association to create a new comment ➋ and redirects
          back to the post ➌. Each call to <code class="literal">redirect_to</code> sets a flash
          message to indicate success or failure.</p><p>Because you’re using Strong Parameters in your application, you also need to add
          the <code class="literal">comment_params</code> method to specify the parameters you want to
          accept.</p><a id="pro_id00132"/><pre class="programlisting">class CommentsController &lt; ApplicationController
  --<span class="emphasis"><em>snip</em></span>--

  <span class="strong"><strong>private</strong></span>

  <span class="strong"><strong>def comment_params</strong></span>
    <span class="strong"><strong>params.require(:comment).permit(:author, :body)</strong></span>
  <span class="strong"><strong>end</strong></span>
end</pre><p>In the case of comments, you only accept an <code class="literal">author</code> and a
            <code class="literal">body</code>. Any other parameters are ignored. In the next chapter,
          you’ll update the post <code class="literal">show</code> view to display existing comments and
          include a form for creating new comments.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00006"/>Summary</h1></div></div></div><p>This chapter introduced many important Rails concepts—REST, routing, and
          controllers. I also discussed parameters, render versus redirect, response formats, and
          the flash.</p><p>We started at the database in the last chapter and worked our way forward in this
          chapter. In the next chapter, we’ll get all the way to the user and cover the last
          piece of the MVC puzzle: views.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id00007"/>Exercises</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch04qa1"/><table border="0" summary="Q and A Set" width="100%"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch04qa1qe1"/><a id="ch04qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. Good error messages are important for any application. If something goes
                wrong, your users need to know what the problem is and how to correct it. Currently,
                if a comment can’t be created, users see the message “Error creating
                comment.” Update the <code class="literal">CommentsController create</code> method to
                also show a list of error messages in the alert.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch04qa1qe2"/><a id="ch04qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. In Exercise 1 at the end of <a class="xref" href="ch03.html" title="Chapter 3. Models">Chapter 3</a>, you added an
                  <code class="literal">email</code> field to the <code class="literal">Comment</code> model. Update the
                  <code class="literal">comment_params</code> method in <code class="literal">CommentsController</code>
                to also accept this field.</p></td></tr></tbody></table></div></div></div></body></html>