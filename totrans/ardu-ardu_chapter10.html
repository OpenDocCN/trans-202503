<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch10" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch10">
<span class="CN"><span aria-label=" Page 143. " epub:type="pagebreak" id="pg_143" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">USING MULTIPLE I</samp><samp class="SANS_Dogma_OT_Bold_B-SUP_11">2</samp><samp class="SANS_Dogma_OT_Bold_B_11">C DEVICES WITH THE SAME ADDRESS</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">In your Arduino journey, you’ve likely come across devices that interface via the I<sup>2</sup>C bus, a simple two-wire data bus for which the Arduino is considered the <i>primary</i> device, and each additional device or IC on the bus is a <i>secondary</i> device. Each secondary device has its own address that allows the Arduino to communicate with it. If two or more devices have the same bus address, however, you simply can’t use them together on the same bus.</p>
<p class="TX">This chapter shows you how to use two or more devices with the same bus address with the help of the TCA9548A I<sup>2</sup>C switch IC. You’ll learn to:</p>
<ul class="ul">
<li class="BL">Build an I<sup>2</sup>C address scanner to determine device bus addresses</li>
<li class="BL">Use compact graphic organic light-emitting diode (OLED) displays</li>
<li class="BL">Use the BMP180 temperature and air pressure sensor</li>
<li class="BL">Combine the BMP180 and OLED devices</li>
</ul>
<p class="TX"><span aria-label=" Page 144. " epub:type="pagebreak" id="pg_144" role="doc-pagebreak"/>To prepare you to work with multiple I<sup>2</sup>C devices at once, I’ll first introduce a simple tool that reports the bus address of a device connected to the Arduino’s I<sup>2</sup>C bus: the I<sup>2</sup>C bus scanner.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>If you’re not familiar with the I</i> <i><sup>2</sup></i><i>C bus, you can review Chapter 19 of</i> <span class="note">Arduino Workshop</span><i>, 2nd edition.</i></p>
<p class="HeadProject"><span id="h1-68"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #30: Using an I<sup>2</sup>C Bus Scanner</samp></p>
<p class="TNI">In this project, you’ll learn to use an I<sup>2</sup>C bus scanner. This tool helps you gather information on parts or devices whose documentation you can’t find, such as the part’s bus address. It’s also ideal for quick I<sup>2</sup>C bus testing once you’ve connected a device to the bus.</p>
<p class="TX">You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A solderless breadboard or mounting for the I<sup>2</sup>C device</li>
<li class="BL">Various jumper wires</li>
</ul>
<p class="TX">The hardware connection will depend on the I<sup>2</sup>C device under test. As an example, I’ll use the BMP180 sensor for temperature, barometric pressure, and altitude, as shown in <a href="chapter10.xhtml#fig10-1">Figure 10-1</a>.</p>
<figure class="IMG"><img alt="A BMP180 TEMPERATURE SENSOR CONNECTED TO AN ARDUINO UNO WITH WIRES AND A SOLDERLESS BREADBOARD" class="img7" id="fig10-1" src="../images/fig10-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: The BMP180 sensor board</samp></p></figcaption>
</figure>
<p class="TX">You’ll also use the BMP180 later in the chapter and elsewhere in this book, but for this project, you can use any I<sup>2</sup>C device that’s 5 V tolerant. If your device isn’t a module, don’t forget to use pull-up resistors as you normally would.</p>
<p class="TX"><span aria-label=" Page 145. " epub:type="pagebreak" id="pg_145" role="doc-pagebreak"/>The sketch for this project is provided with the Arduino IDE. Open and upload the i2c_scanner sketch included with the Wire library examples, by selecting <b>File</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Examples</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Wire</b> <img alt="" class="inline" src="../images/arr.png"/> <b>i2c_scanner</b>.</p>
<p class="TX">The sketch should interrogate the bus and report the address (or addresses) found in the Serial Monitor, as shown in <a href="chapter10.xhtml#fig10-2">Figure 10-2</a>.</p>
<figure class="IMG"><img alt="A SCREEN CAPTURE OF THE I2C SCANNER SKETCH OUTPUT ON THE SERIAL MONITOR" class="img7" id="fig10-2" src="../images/fig10-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: The results of the I</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">C scanner sketch</samp></p></figcaption>
</figure>
<p class="TX">If you have two or more devices on the bus, the scanner will report both addresses, but you won’t know which device belongs to which address. For example, <a href="chapter10.xhtml#fig10-3">Figure 10-3</a> shows the bus addresses for the two devices connected to the bus. When you’re using two or more devices at once with the scanner, it’s okay to remove one or more devices even when the power is on, as the I<sup>2</sup>C bus is capable of “hot swapping.” That is, it’s designed to allow for devices to be connected or removed while operating.</p>
<figure class="IMG"><img alt="A SCREEN CAPTURE OF THE I2C SCANNER SKETCH OUTPUT ON THE SERIAL MONITOR, SHOWING TWO DEVICES’ BUS ADDRESSES" class="img7" id="fig10-3" src="../images/fig10-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: The results of the I</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUP_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">C scanner sketch with two devices</samp></p></figcaption>
</figure>
<p class="TX">The sketch is quite simple. Let’s see how it works:</p>
<span id="pro-30"/>

<pre><code>// Project #30 - I2C bus address scanner

void loop()
{
    int nDevices = 0;
    Serial.println("Scanning…");
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> for (byte address = 1; address &lt; 127; ++address)
    {
        Wire.beginTransmission(address);
        byte error = Wire.endTransmission();
     <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if (error == 0)
        {
            Serial.print("I2C device found at address 0x");
            if (address &lt; 16)
            {
<span aria-label=" Page 146. " epub:type="pagebreak" id="pg_146" role="doc-pagebreak"/>                Serial.print("0");
            }
            Serial.print(address, HEX);
            Serial.println(" !");
            ++nDevices;
        }
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> else if (error == 4)
        {
            Serial.print("Unknown error at address 0x");
            if (address &lt; 16)
            {
                Serial.print("0");
            }
            Serial.println(address, HEX);
        }
    }
    if (nDevices == 0)
    {
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> Serial.println("No I2C devices found\n");
    } else
    {
        Serial.println("done\n");
    }
    delay(5000); // Wait 5 seconds for next scan
}
</code></pre>

<p class="TX">The sketch starts and finishes an I<sup>2</sup>C connection to every possible I<sup>2</sup>C address location (0 through 127) <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If a device exists on the address being tested, the sketch returns an error code of 0 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>; if an error occurs, it returns a 4 <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If it doesn’t find any devices, it prints the message <samp class="SANS_TheSansMonoCd_W5Regular_11">No I2C devices found</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">Now that you’ve seen how to connect an I<sup>2</sup>C device or two to the bus, let’s get started with the TCA9548A.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-69"/><samp class="SANS_Futura_Std_Bold_B_11">The TCA9548A Breakout Board</samp></h2>
<p class="TNI">The TCA9548A, shown on a breakout board in <a href="chapter10.xhtml#fig10-4">Figure 10-4</a>, allows you to connect the single I<sup>2</sup>C bus from your Arduino to one of eight separate buses that emanate from the TCA9548A, each of which operates in the same manner as the Arduino’s original I<sup>2</sup>C bus.</p>
<figure class="IMG"><img alt="A PHOTO OF A TCA9548A BREAKOUT BOARD" class="img5" id="fig10-4" src="../images/fig10-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: The TCA9548A breakout board</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 147. " epub:type="pagebreak" id="pg_147" role="doc-pagebreak"/>The TCA9548A also handles voltage translation, enabling you to use devices with the host Arduino that operate on different voltages—a convenient benefit, since an increasing number of devices operate only at 3.3 V or 1.8 V. Unfortunately, the TCA9548A is available in surface-mount format only, so it can’t be used with a solderless breadboard or prototyping board. Instead, you’ll need to use the module.</p>
<p class="TX">The TCA9548A breakout board should include a pair of inline header pins that are not yet soldered to the board. Let’s solder them in now. To line up the pins properly, you can drop them into a solderless breadboard, as shown in <a href="chapter10.xhtml#fig10-5">Figure 10-5</a>.</p>
<figure class="IMG"><img alt="A TCA9548A BREAKOUT BOARD WITH INLINE HEADER PINS IN A SOLDERLESS BREADBOARD" class="img5" id="fig10-5" src="../images/fig10-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: The TCA9548A breakout board with inline header pins before soldering</samp></p></figcaption>
</figure>
<p class="TX">After you solder in the pins, your board is ready for use in solderless breadboards and other hardware solutions, as shown in <a href="chapter10.xhtml#fig10-6">Figure 10-6</a>.</p>
<figure class="IMG"><img alt="A TCA9548A BREAKOUT BOARD WITH INLINE HEADER PINS SOLDERED TO PCB PADS" class="img3" id="fig10-6" src="../images/fig10-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: The TCA9548A breakout board with inline header pins soldered to PCB pads</samp></p></figcaption>
</figure>
<p class="TX">The pinouts on the board match the schematic diagram shown in <a href="chapter10.xhtml#fig10-7">Figure 10-7</a>, which also includes the connections you should make to your Arduino Uno or compatible board.<span aria-label=" Page 148. " epub:type="pagebreak" id="pg_148" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE TCA9548A BREAKOUT BOARD SCHEMATIC" class="img5" id="fig10-7" src="../images/fig10-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-7: The TCA9548A schematic</samp></p></figcaption>
</figure>
<p class="TX">The TCA9548A requires pull-up resistors between the I<sup>2</sup>C bus and the positive power rail; these resistors are included on the breakout board.</p>
<p class="TX">The pins labeled A0 to A2 in the schematic are used to define the bus address for the TCA9548A. As you can see, the schematic sets them all to GND. If you run the port scanner, it will return an address of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>. If necessary, you can change the address by connecting the pins A0 to A2 to combinations of GND or 5V, as listed in <a href="chapter10.xhtml#tab10-1">Table 10-1</a>.</p>
<figure class="table">
<p class="TableTitle" id="tab10-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">TCA9548A Address Configuration</samp></p>
<table class="table">
<thead>
<tr>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">A0</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">A1</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">A2</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Address</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">0x70</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">0x71</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">0x72</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">0x73</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">0x74</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">0x75</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">0x76</samp></p></td>
</tr>
<tr>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">0x77</samp></p></td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">The eight I<sup>2</sup>C bus pairs in the schematic are labeled as SC0/SD0 through SC7/SD7 (Clock and Data, respectively). The TCA9548A treats them each as a physically separate I<sup>2</sup>C bus.</p>
<p class="TX"><span aria-label=" Page 149. " epub:type="pagebreak" id="pg_149" role="doc-pagebreak"/>Using the TCA9548A in your sketch requires just one additional step before using your I<sup>2</sup>C devices as normal: instructing the TCA9548A to use one of the eight buses it controls. To do this, you’ll send a byte of data to the TCA9548A’s I<sup>2</sup>C bus register, which will determine which of the eight buses you want to use. Each bit of the byte is used to turn the bus on or off, with the most significant bit (MSB) for bus 7, and the least significant bit (LSB) for bus 0. For example, sending B00000001 (in binary) or 0 in decimal activates bus 0, while sending B00010000 activates bus 5. The TCA9548A then channels all data in and out of the bus to the Arduino on the selected bus; the TCA9548A itself is transparent to the Arduino.</p>
<p class="TX">Send the bus selection data only when you want to change buses. To simplify this process, you can use the following function to select the required bus:</p>

<pre><code>void TCA9548A(uint8_t bus)
{
    Wire.beginTransmission(0x70); // TCA9548A address is 0x70
    Wire.write(1 &lt;&lt; bus);         // Send byte to select bus
    Wire.endTransmission();
}
</code></pre>

<p class="TX">This function accepts a bus number and places a 1 in the TCA9548A’s bus register, matching our requirements. Insert this function right before you need to access a device on a particular I<sup>2</sup>C bus. For example, you’d use this function to access a device on bus 0:</p>

<pre><code>TCA9548A(0);
</code></pre>

<p class="TX">Here’s the function to access a device on bus 7:</p>

<pre><code>TCA9548A(7);
</code></pre>

<p class="TX">Now that you know how to select the required bus, I’ll introduce a neat display that you’ll use in your projects.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-70"/><samp class="SANS_Futura_Std_Bold_B_11">Graphic OLED Displays</samp></h2>
<p class="TNI">You may be familiar with classic 16 <span class="symbol">×</span> 2–character LCDs, as they’re quite popular and inexpensive. However, they are also somewhat bulky and old fashioned. The OLED display is a sleeker, more contemporary option that can display both text and graphics in various sizes.</p>
<p class="TX">For the projects in this chapter, you’ll use a compact 128 <span class="symbol">×</span> 32–pixel OLED display with a diagonal display size of 0.91 inches, such as PMD Way part 35998841A, shown in <a href="chapter10.xhtml#fig10-8">Figure 10-8</a>.<span aria-label=" Page 150. " epub:type="pagebreak" id="pg_150" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A PHOTO OF A COMPACT OLED DISPLAY WITH INLINE HEADER PINS" class="img7" id="fig10-8" src="../images/fig10-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-8: A compact OLED display with inline header pins</samp></p></figcaption>
</figure>
<p class="TX">Inline headers for using with a solderless breadboard are included with the example board from PMD Way and are usually included with others, but check with the supplier. You can easily solder these to the breadboard by mounting the pins and the OLED in a breadboard, as shown in <a href="chapter10.xhtml#fig10-9">Figure 10-9</a>. Supporting the other end of the OLED with something to keep the display level, such as another group of inline header pins, as shown in <a href="chapter10.xhtml#fig10-9">Figure 10-9</a>, helps to ensure the pins are straight.</p>
<figure class="IMG"><img alt="A PHOTO OF A COMPACT OLED DISPLAY SITTING IN INLINE HEADER PINS, READY FOR SOLDERING" class="img7" id="fig10-9" src="../images/fig10-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-9: A compact OLED display sitting in inline header pins, ready for soldering</samp></p></figcaption>
</figure>
<p class="TX">Once you’re ready to use the OLED, remove the plastic screen protector by pulling the blue tag, as shown in <a href="chapter10.xhtml#fig10-10">Figure 10-10</a>.</p>
<figure class="IMG"><img alt="AN IMAGE OF A COMPACT OLED DISPLAY WITH ITS INLINE HEADER PINS SOLDERED" class="img4" id="fig10-10" src="../images/fig10-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-10: Ready-to-use OLED</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 151. " epub:type="pagebreak" id="pg_151" role="doc-pagebreak"/>To use the OLED, you’ll need to install an Arduino library. Search for <b>u8g2</b> in the Library Manager, and then click <b>Install</b> at the bottom of the library description.</p>
<p class="TX">Once you’ve installed the library, test the OLED by running the I<sup>2</sup>C scanner sketch. It should return the address 0x3C, but if you get a different result, make a note of it for later. Next, connect the OLED to your Arduino Uno or compatible board using the connections listed in <a href="chapter10.xhtml#tab10-2">Table 10-2</a>.</p>
<figure class="table">
<p class="TableTitle" id="tab10-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 10-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">OLED to Arduino Connections</samp></p>
<table class="table">
<thead>
<tr>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">OLED</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Arduino Uno</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">SDA</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">A4</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">SCL</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">A5</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">VCC</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
</tr>
<tr>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Now enter and upload the <a href="#LiT-10-1">Listing 10-1</a> sketch, which you can find in the downloadable code files on this book’s web page. After a few moments, the display should scroll between displaying “Count!” and an integer, as shown in <a href="chapter10.xhtml#fig10-11">Figure 10-11</a>. If your display had a different bus address to 0x3C, insert the new address into the “address” field in the line <samp class="SANS_TheSansMonoCd_W5Regular_11">u8g2_2.setI2CAddress(0x3D);</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, then uncomment the line and save and re-upload the sketch.</p>
<figure class="IMG"><img alt="AN IMAGE OF OLED DISPLAYS, SHOWING TEXT (“COUNT!”)AND DIGITS (“30434”)" class="img1" id="fig10-11" src="../images/fig10-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-11: Example displays from <a href="#LiT-10-1">Listing 10-1</a></samp></p></figcaption>
</figure>
<p class="TX"><a href="#LiT-10-1">Listing 10-1</a> shows how this works.</p>
<span id="LiT-10-1"/>

<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;U8g2lib.h&gt;
#include &lt;Wire.h&gt;
U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);

void setup()
{
    Wire.begin();
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> u8g2.begin();
    //u8g2_2.setI2CAddress(address);
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> u8g2.setFont(<var>u8g2_font_logisoso32_tr</var>); // Select font
}

<span aria-label=" Page 152. " epub:type="pagebreak" id="pg_152" role="doc-pagebreak"/>void loop()
{
    for (int a = 29999; a &lt; 32767; a++)
    {
        u8g2.clearBuffer(); // Clear OLED memory
      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> u8g2.drawStr(0, 32, "Count!"); // Write text to memory
        u8g2.sendBuffer(); // Display contents of memory
        delay(1000);
        u8g2.clearBuffer(); // Clear OLED memory
        u8g2.setCursor(0, 32); // Position cursor in memory
        u8g2.print(a); // Write integer to memory
        u8g2.sendBuffer(); // Display contents of memory
        delay(1000);
    }
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: Using graphic OLED displays</samp></p>
<p class="TX">First, the sketch includes the u8g2 library and includes the OLED library <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, after which it creates the instance of an OLED. The OLED’s specifications are defined in this file so the library knows which type of OLED you’re using.</p>
<p class="TX">The sketch then initializes the OLED <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and selects a font for the display <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The sketch uses a font that’s 32 pixels high, which works well for this OLED, but you can replace it with any of the fonts available at <a href="https://github.com/olikraus/u8g2/wiki/fntlistall"><i>https://<wbr/>github<wbr/>.com<wbr/>/olikraus<wbr/>/u8g2<wbr/>/wiki<wbr/>/fntlistall</i></a>.</p>
<p class="TX">The sketch controls the OLED by drawing up the intended display in its memory and then sending the contents of the memory to the display. After the OLED’s memory is cleared, the function <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> accepts the lower x- and y-coordinates of the OLED display and then starts drawing the text itself. The sketch then prints the contents of the OLED memory to the display.</p>
<p class="TX">The sketch clears the memory again after a short delay and displays a number by first setting the cursor position and then printing the number to the memory, followed by another <samp class="SANS_TheSansMonoCd_W5Regular_11">sendBuffer()</samp> function to display the memory.</p>
<p class="TX">Now that you’ve mastered the OLED display, I’ll introduce a sensor that you’ll use along with an OLED in your final project.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-71"/><samp class="SANS_Futura_Std_Bold_B_11">BMP180 Sensors</samp></h2>
<p class="TNI">The BMP180 sensor is an inexpensive, easy-to-use I<sup>2</sup>C device that measures ambient temperature and air pressure. This chapter’s final project uses a compact BMP180 module with pull-up resistors like the one used in Project #30, such as PMD Way part 18000001, shown in <a href="chapter10.xhtml#fig10-12">Figure 10-12</a>.<span aria-label=" Page 153. " epub:type="pagebreak" id="pg_153" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A PHOTO OF THE BMP180 TEMPERATURE AND HUMIDITY SENSOR PLACED IN A SOLDERLESS BREADBOARD" class="img4" id="fig10-12" src="../images/fig10-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-12: The BMP180 sensor module</samp></p></figcaption>
</figure>
<p class="TX">As with the OLED display, begin by soldering the BMP180’s header pins to the board. Next, find the <b>Adafruit BMP180</b> library in the Arduino Library Manager and install it.</p>
<p class="TX">During the process of installing the BMP180 library, you may be asked to install some missing dependencies. Click <b>Install All</b> if prompted to do so.</p>
<p class="TX">Now enter and upload the <a href="#LiT-10-2">Listing 10-2</a> sketch. Once the upload is complete, open the Serial Monitor in the IDE, where you’ll find the current temperature in degrees Celsius, along with the air pressure in hectopascals. In some regions, the unit of air pressure is the millibar. One hectopascal equals one millibar. <a href="chapter10.xhtml#fig10-13">Figure 10-13</a> shows an example of this output.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF AN EXAMPLE TEMPERATURE AND PRESSURE READINGS OUTPUT IN SERIAL MONITOR" class="img7" id="fig10-13" src="../images/fig10-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-13: Example output from <a href="#LiT-10-2">Listing 10-2</a></samp></p></figcaption>
</figure>
<p class="TX"><a href="#LiT-10-2">Listing 10-2</a> shows how this works.</p>
<span id="LiT-10-2"/>

<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include "Adafruit_BMP085.h"
Adafruit_BMP085 bmp;

int temperature;
int pressure;

void setup()
{
    Serial.begin(9600);
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> bmp.begin();
}

<span aria-label=" Page 154. " epub:type="pagebreak" id="pg_154" role="doc-pagebreak"/>void loop()
{
    Serial.print("Temperature = ");
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> temperature = bmp.readTemperature();
    Serial.print(temperature);
    Serial.println(" degrees C");
    Serial.print("Pressure = ");
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> Serial.print(int(bmp.readPressure() / 100));
    Serial.println(" hPa");
    Serial.println();
    delay(500);
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Using BMP180 temperature and air pressure sensors</samp></p>
<p class="TX">To set up the BMP180, the sketch first includes the requisite library and creates an instance of the sensor <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Two variables, <samp class="SANS_TheSansMonoCd_W5Regular_11">temperature</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">pressure</samp>, store the sensor data. This is followed by initialization of the sensor <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">The sketch can then retrieve the data from the sensor using the <samp class="SANS_TheSansMonoCd_W5Regular_11">read Temperature()</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">readPressure()</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> functions. The temperature and air pressure readings (with the latter divided by 100 to convert it to hectopascals) are then sent to the Serial Monitor.</p>
<p class="HeadProject"><span id="h1-72"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #31: Creating a Temperature and Air Pressure Display</samp></p>
<p class="TNI">This project combines all the techniques you’ve learned in this chapter so far, using multiple I<sup>2</sup>C buses to display the BMP180’s temperature and air pressure readings with an OLED. You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A 128 <span class="symbol">×</span> 32–pixel, 0.91-inch OLED display</li>
<li class="BL">A BMP180 temperature and air pressure sensor board</li>
<li class="BL">A TCA9548A breakout board</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Various jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter10.xhtml#fig10-14">Figure 10-14</a>.<span aria-label=" Page 155. " epub:type="pagebreak" id="pg_155" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT 31" class="img8" id="fig10-14" src="../images/fig10-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-14: The schematic for Project #31</samp></p></figcaption>
</figure>
<p class="TX">Next, enter and upload the Project #31 sketch. The temperature and air pressure should alternately display on the OLED, as shown in <a href="chapter10.xhtml#fig10-15">Figure 10-15</a>.</p>
<figure class="IMG"><img alt="EXAMPLES OF THE OLED DISPLAYING TEMPERATURE (“25 C”) AND HUMIDITY (“999 H”)" class="img1" id="fig10-15" src="../images/fig10-15.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-15: Example output from Project #31</samp></p></figcaption>
</figure>
<p class="TX">Let’s see how this works:</p>
<span id="pro-31"/>

<pre><code>// Project #31 - Temperature display

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;U8g2lib.h&gt;
#include &lt;Adafruit_BMP085.h&gt;
#include &lt;Wire.h&gt;

U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);
Adafruit_BMP085 bmp;
float temperature;
float pressure;

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> void TCA9548A(uint8_t bus)
{
    Wire.beginTransmission(0x70); // TCA9548A address is 0x70
    Wire.write(1 &lt;&lt; bus);        // Send byte to select bus
    Wire.endTransmission();
}

<span aria-label=" Page 156. " epub:type="pagebreak" id="pg_156" role="doc-pagebreak"/>void setup()
{
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Wire.begin();
    u8g2.begin();
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> u8g2.setFont(u8g2_font_logisoso32_tr); // Select font
    TCA9548A(0); // Select I2C bus 0 for the BMP180
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> bmp.begin();
}

void loop()
{
    // First, get the temperature from the BMP180
  <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> TCA9548A(0); // Select I2C bus 0 for the BMP180
    temperature = bmp.readTemperature();
    pressure = bmp.readPressure();

    // Next, display the temperature on the OLED
  <span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> TCA9548A(1); // Select I2C bus 1 for the OLED
    u8g2.clearBuffer(); // Clear OLED memory
    u8g2.setCursor(0, 32);
    u8g2.print(int(temperature));
    u8g2.drawStr(50, 32, "C");
  <span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> u8g2.sendBuffer();
    delay(1000);

    u8g2.clearBuffer(); // Clear OLED memory
    u8g2.setCursor(0, 32);
    pressure = pressure / 100; // Convert to hectopascals
    u8g2.print(int(pressure));
    u8g2.drawStr(80, 32, "h");
  <span aria-label="annotation9" class="CodeAnnotationHang1">❾</span> u8g2.sendBuffer();
    delay(1000);
}
</code></pre>

<p class="TX">The sketch first includes the required libraries <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and configures the OLED type to use, temperature sensor, and required variables, as covered previously. It then defines a custom function to select the I<sup>2</sup>C bus from the TCA9548A <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. It starts the I<sup>2</sup>C and OLED functions <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, selects the OLED font <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, and starts the temperature sensor <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
<p class="TX">The sketch then switches the TCA9548A to the first of its I<sup>2</sup>C buses to retrieve data from the BMP180 <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> and then to the second I<sup>2</sup>C bus <span aria-label="annotation7" class="CodeAnnotationCode">❼</span> so that the temperature and pressure data can be displayed on the OLED <span aria-label="annotation8" class="CodeAnnotationCode">❽</span> <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-73"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">In this chapter, you learned to harness multiple devices on an I<sup>2</sup>C bus, alongside adding a new sensor and display to your tool kit. You might use these skills to make a large, multiple-time-zone clock with many OLEDs and a real-time clock IC, or you could use many temperature sensors in one area to determine the variations of temperature inside a refrigerator. No <span aria-label=" Page 157. " epub:type="pagebreak" id="pg_157" role="doc-pagebreak"/>matter the project, you’re no longer limited by inexpensive devices with a single I<sup>2</sup>C bus address.</p>
<p class="TX">In the next chapter, you’ll use an Arduino Leonardo or compatible board to emulate a USB mouse and keyboard, which opens up many interesting and useful possibilities.</p>
</section>
</section>
</body>
</html>