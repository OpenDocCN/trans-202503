["```\nM: array [0..1023] of integer;\n```", "```\n\n\t\t\ti := 0; (* assume \"i\" is an integer variable *)\nM [i] := 100;\n```", "```\n\n\t\t\ti := 5;         (* assume all variables are integers*)\nj := 10;\nk := 50;\nm [i*j-k] := 100;\n```", "```\n\n\t\t\tM [1] := 0;\nM [ M [1] ] := 100;\n```", "```\n\n\t\t\tmov( PointerVariable, ebx ); // Load pointer variable into a register.\nmov( [ebx], eax );           // Use register-indirect mode to access data.\n```", "```\n\n\t\t\ti = **cDblPtr;\ni := pDblPtr^^;\n```", "```\n\n\t\t\tmov( hDblPtr, ebx );  // Get the pointer to a pointer\nmov( [ebx], ebx );    // Get the pointer to the value\nmov( [ebx], eax );    // Get the value\n```", "```\n\n\t\t\tstatic int i;\nstatic int j;\nstatic int *cSnglPtr;\nstatic int **cDblPtr;\n\nint main( void )\n{\n        .\n        .\n        .\n    j = *cSnglPtr;\n    i = **cDblPtr;\n        .\n        .\n        .\n```", "```\n\n\t\t\t; j = *cSnglPtr;\n\n        addis r11,r31,ha16(_j-L1$pb)\n        la r11,lo16(_j-L1$pb)(r11)\n        addis r9,r31,ha16(_cSnglPtr-L1$pb)\n        la r9,lo16(_cSnglPtr-L1$pb)(r9)\n        lwz r9,0(r9)  // Get the ptr into register R9\n        lwz r0,0(r9)  // Get the data at the pointer\n        stw r0,0(r11) // Store into j\n\n; i = **cDblPtr;\n;\n; Begin by getting the address of cDblPtr into R9:\n\n        addis r11,r31,ha16(_i-L1$pb)\n        la r11,lo16(_i-L1$pb)(r11)\n        addis r9,r31,ha16(_cDblPtr-L1$pb)\n        la r9,lo16(_cDblPtr-L1$pb)(r9)\n\n        lwz r9,0(r9)  // Get the dbl ptr into R9\n        lwz r9,0(r9)  // Get the ptr into R9\n        lwz r0,0(r9)  // Get the value into R9\n        stw r0,0(r11) // Store value into i\n```", "```\n\n\t\t\t; j = *cSnglPtr;\n\n        movl    cSnglPtr, %eax\n        movl    (%eax), %eax\n        movl    %eax, j\n\n; i = **cDblPtr;\n\n        movl    cDblPtr, %eax\n        movl    (%eax), %eax\n        movl    (%eax), %eax\n        movl    %eax, i\n```", "```\n\n\t\t\tptrVar = malloc( bytes_to_allocate );\n```", "```\nptrVar = malloc( sizeof( int ) * 8 ); // An array of 8 integers\n```", "```\n\n\t\t\t// malloc returns storage for eight\n//  int32 objects in EAX.\n\nmalloc( @size( int32 ) * 8 );\n\nmov( 0, ecx );\nmov( ecx, [eax] );     // Zero out the 32 bytes\nmov( ecx, [eax+4] );   // (4 bytes at a time).\nmov( ecx, [eax+8] );\nmov( ecx, [eax+12] );\nmov( ecx, [eax+16] );\nmov( ecx, [eax+20] );\nmov( ecx, [eax+24] );\nmov( ecx, [eax+28] );\n```", "```\n\n\t\t\tint *intPtr;\n        .\n        .\n        .\n    // Allocate storage for eight integers:\n\n    intPtr = malloc( sizeof( int ) * 8 );\n\n    // Initialize each of these integer values:\n\n    *(intPtr+0) = 0;\n    *(intPtr+1) = 1;\n    *(intPtr+2) = 2;\n    *(intPtr+3) = 3;\n    *(intPtr+4) = 4;\n    *(intPtr+5) = 5;\n    *(intPtr+6) = 6;\n    *(intPtr+7) = 7;\n```", "```\nmov( [ebx-4], eax );\n```", "```\n\n\t\t\tint distance;\nchar *aPtr;\nchar *ePtr;\n    .\n    .\n    .\naPtr = someString;  // Get ptr to start of string in aPtr.\n// While we're not at the end of the string\n// and the current char isn't 'a':\n\nwhile( *aPtr != '\\0' && *aPtr != 'a' )\n{\n    // Move on to the next character pointed at by aPtr.\n\n    aPtr = aPtr + 1;\n}\n\n// while we're not at the end of the string\n// and the current character isn't 'e'\n//\n// Start at the 'a' char (or end of string if no 'a').\n\nePtr = aPtr;\nwhile( *ePtr != '\\0' && *ePtr != 'e' )\n{\n    // Move on to the next character pointed at by aPtr.\n    ePtr = ePtr + 1;\n}\n\n// Now compute the number of characters between\n// the 'a' and the 'e' (counting the 'a' but not\n// counting the 'e'):\n\ndistance = (ePtr - aPtr);\n```", "```\n\n\t\t\t#include <stdio.h>\n\nint iArray[256];\nint *ltPtr;\nint *gtPtr;\n\nint main( int argc, char **argv )\n{\n    int lt;\n    int gt;\n\n    // Put the address of the \"argc\" element\n    // of iArray into ltPtr. This is done\n    // so that the optimizer doesn't completely\n    // eliminate the following code (as would\n    // happen if we just specified a constant\n    // index):\n\n    ltPtr = &iArray[argc];\n\n    // Put the address of the eighth array\n    // element into gtPtr.\n\n    gtPtr = &iArray[7];\n\n    // Assuming you don't type seven or more\n    // command-line parameters when running\n    // this program, the following two\n    // assignments should set lt and gt to 1.\n\n    lt = ltPtr < gtPtr;\n    gt = gtPtr > ltPtr;\n    printf( \"lt:%d, gt:%d\\n\", lt, gt );\n    return 0;\n}\n```", "```\n\n\t\t\t;\n; Grab ARGC (passed to the program in rcx), use\n; it as an index into iArray (4 bytes per element,\n; hence the \"*4\" in the scaled-index addressing mode),\n; compute the address of this array element (using the\n; LEA -- load effective address -- instruction), and\n; store the resulting address into ltPtr:\n; Line 24\n        movsxd  rax, ecx ; rax=rcx\n; Line 37\n        xor     edx, edx ;edx = 0\n        mov     r8d, edx ;Initialize boolean result w/false\n        lea     rcx, OFFSET FLAT:iArray ;rcx = base address of iArray\n        lea     rcx, QWORD PTR [rcx+rax*4] ;rcx = &iArray[argc]\n\n        lea     rax, OFFSET FLAT:iArray+28 ;rax=&iArray[7] (7*4 = 28)\n        mov     QWORD PTR ltPtr, rcx ;ltPtr = &iArray[argc]\n        cmp     rax, rcx ;carry flag = !(ltPtr < gtPtr)\n        mov     QWORD PTR gtPtr, rax ;gtPtr = &iArray[7]\n        seta    r8b ;r8b = ltPtr < gtPtr (which is !gtPtr > ltPtr)\n        cmp     rcx, rax ;Carry flag = !(gtPtr > ltPtr)\n; Line 38\n        lea     rcx, OFFSET FLAT:??_C@_0O@KJKFINNE@lt?3?$CFd?0?5gt?3?$CFd?6?$AA@\n        setb    dl ;dl = !(ltPtr < gtPtr ) (which is !(gtPtr > ltPtr)\n        call    printf\n;\n```", "```\nand( $FFFF_FFFC, ebx );\n```", "```\n\n\t\t\t// # of bytes to allocate\n\nmov( nBytes, eax );\n\n// Provide a \"cushion\" for rounding.\n\nadd( 3, eax );\n\n// Allocate the memory (returns pointer in EAX).\n\nmalloc( eax );\n\n// Round up to the next higher dword, if not dword-aligned.\n\nadd( 3, eax );\n\n// Make the address a multiple of 4.\n\nand( $ffff_fffc, eax );\n```", "```\n\n\t\t\tint main()\n{\n    static int *pointer;\n\n    *pointer = 0;\n}\n```", "```\n\n\t\t\tint main()\n{\n     static int i;\n\n     static int *pointer = &i;\n\n    *pointer = 0;\n}\n```", "```\n\n\t\t\t(* Allocate storage for a new object of type p  *)\n\nnew( p );\n\n(* Use the pointer *)\n\np^ := 0;\n    .\n    . (* Code that uses the storage associated with p *)\n    .\n(* free the storage associated with pointer p *)\n\ndispose( p );\n\n    .\n    . (* Code that doesn't reference p *)\n    .\n(* Dangling pointer                             *)\n\np^ := 5;\n```", "```\n\n\t\t\t// Pointer to storage in \"ptr\" variable.\n\nptr = malloc( 256 );\n    .\n    . // Code that doesn't free \"ptr\"\n    .\nptr = malloc( 512 );\n\n// At this point, there is no way to reference the\n// original block of 256 bytes allocated by malloc.\n```", "```\n\n\t\t\tchar *pc;\n    .\n    .\n    .\npc = malloc( sizeof( char ));\n    .\n    .\n    .\n// Typecast pc to be a pointer to an integer\n// rather than a pointer to a character:\n\n*((int *) pc) = 5000;\n```", "```\n\n\t\t\tint  i [4] = {1,2,3,4};\nint *p     = &i[0];\n      .\n      .\n      .\n    p = (int *)((char *)p + 1);\n    *p = 5;\n```"]