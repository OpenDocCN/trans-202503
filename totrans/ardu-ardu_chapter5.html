<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch5" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch5">
<span class="CN"><span aria-label=" Page 57. " epub:type="pagebreak" id="pg_57" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">CONTROLLING LEDS WITH CHARLIEPLEXING</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">It’s easy to control many LEDs with one Arduino board. However, you can also use the <i>Charlieplexing</i> method in the Arduino environment to control multiple LEDs one at a time without external display driver ICs. This is a great way to reduce part count (and expenses) in a project involving numeric or character displays.</p>
<p class="TX">In this chapter, you’ll learn to:</p>
<ul class="ul">
<li class="BL">Use Charlieplexing with an Arduino Uno or compatible board or an ATtiny85 microcontroller</li>
<li class="BL">Use Charlieplexing with 6 and 12 LEDs</li>
<li class="BL">Simplify planning Charlieplexed circuits with the help of logic tables</li>
</ul>
<p class="TX">You’ll also build a 30-LED matrix display for alphanumeric data that you can use for your own projects</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-35"/><span aria-label=" Page 58. " epub:type="pagebreak" id="pg_58" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_B_11">Introduction to Charlieplexing</samp></h2>
<p class="TNI">The term <i>Charlieplexing</i> is named after Charlie Allen, who originally proposed the idea during his time at Maxim Integrated (now part of Analog Devices), which produced integrated circuits such as the popular MAX7219 LED display driver. The word is a portmanteau composed of “Charlie” and “multiplexing,” the latter being a method of controlling many LEDs with few I/O pins on a microcontroller.</p>
<p class="TX">Charlieplexing is a type of multiplexing that relies on the <i>tri-state</i> capability of microcontroller I/O pins to control the required current to activate multiple LEDs in circuits. You can set each pin to be in one of three states:</p>
<p class="RunInPara1"><b>High</b>    Current flows from an I/O pin, such as when using a <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp> function.</p>
<p class="RunInPara"><b>Low</b>    Current does not flow from an I/O pin, when the pin can also sink (receive current).</p>
<p class="RunInPara2"><b>Input state (or high-Z)</b>    The pin is set to a digital input. In this state, little to no current will flow in either direction. This is also known as the <i>high impedance</i> or <i>high-Z</i> state.</p>
<p class="TX">You can set these I/O pins to different states to direct current through a circuit and create a controllable matrix of LEDs. Only one LED may be turned on at any given time, and all the LEDs used in one circuit must be the same specification—that is, they must all have the same forward voltage and operating current.</p>
<p class="TX">To help understand Charlieplexing, let’s work through some small examples. First, consider the schematic in <a href="chapter5.xhtml#fig5-1">Figure 5-1</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC OF TWO LEDS IN THE CHARLIEPLEXING ARRANGEMENT" class="img5" id="fig5-1" src="../images/fig5-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: The schematic for two LEDs connected to the Arduino outputs</samp></p></figcaption>
</figure>
<p class="TX">If pin D13 is HIGH and pin D12 is LOW, current flows from pin D13 through R<sub>1</sub>, through D<sub>2</sub>, through R<sub>2</sub>, and into D12, meaning LED D<sub>2</sub> will turn on. If you reverse the outputs so pin D12 is HIGH and pin D13 is LOW, current flows from pin D12 through D<sub>1</sub>, through R<sub>1</sub>, and into D13, meaning LED D<sub>1</sub> will turn on. Current will always flow through both resistors, so the sum of their values should be suitable for running an LED from a digital output. With a 5 V output, values of 270 Ω through around 510 Ω would enable sufficient brightness.</p>
<p class="TX">To test Charlieplexing, build the circuit in <a href="chapter5.xhtml#fig5-1">Figure 5-1</a>; then run the sketch in <a href="#LiT-5-1">Listing 5-1</a>.</p>
<span id="LiT-5-1"/>

<pre><code><span aria-label=" Page 59. " epub:type="pagebreak" id="pg_59" role="doc-pagebreak"/>void setup()
{
    pinMode(13, OUTPUT);
    pinMode(12, OUTPUT);
}

void loop()
{
    digitalWrite(13, HIGH);
    digitalWrite(12, LOW);
    delay(500);
    digitalWrite(13, LOW);
    digitalWrite(12, HIGH);
    delay(500);
}
</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: Two-LED demonstration</samp></p>
<p class="TX">This sketch shows how to direct current to control one of two LEDs without a GND pin. It’s intended only as a basic introduction to the concept of Charlieplexing; there’s no real benefit to Charlieplexing two LEDs, as it doesn’t reduce the number of I/O pins used. However, the possibilities of Charlieplexing become obvious once you add another I/O pin to the circuit, as shown in the next project.</p>
<p class="HeadProject"><span id="h1-36"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #15: Charlieplexing with Six LEDs</samp></p>
<p class="TNI">In this project, you’ll control six LEDs with only three digital output pins, demonstrating the benefits of Charlieplexing.</p>
<p class="TX">You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">Three 270 Ω, 0.25 W, 1 percent resistors</li>
<li class="BL">Six LEDs</li>
<li class="BL">Two solderless breadboards</li>
<li class="BL">Male-to-male jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter5.xhtml#fig5-2">Figure 5-2</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #15" class="img8" id="fig5-2" src="../images/fig5-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: The schematic for Project #15</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 60. " epub:type="pagebreak" id="pg_60" role="doc-pagebreak"/>For easy assembly, use two solderless breadboards side by side, as shown in <a href="chapter5.xhtml#fig5-3">Figure 5-3</a>.</p>
<figure class="IMG"><img alt="AN IMAGE OF PROJECT #15 ON A SOLDERLESS BREADBOARD, WITH THE UPPER RIGHT LIGHT IN A SET OF FOUR BEING THE ONLY ONE LIT UP" class="img6" id="fig5-3" src="../images/fig5-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: The assembled Project #15</samp></p></figcaption>
</figure>
<p class="TX">Now enter and upload the following sketch to your Arduino. A moment after uploading the sketch, each LED from 1 through 6 should light in turn.</p>
<span id="pro-15"/>

<pre><code>// Project #15 - Charlieplexing six LEDs

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #define d 1000

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> void LED1()
{
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> DDRB = B00110000;
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> PORTB = B00010000;
}

void LED2()
{
    DDRB = B00110000;
    PORTB = B00100000;
}

void LED3()
{
    DDRB = B00011000;
    PORTB = B00001000;
}

void LED4()
{
    DDRB = B00011000;
    PORTB = B00010000;
}

void LED5()
{
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> DDRB = B00101000;
    PORTB = B00001000;
}

void LED6()
{
    DDRB = B00101000;
<span aria-label=" Page 61. " epub:type="pagebreak" id="pg_61" role="doc-pagebreak"/>    PORTB = B00100000;
}

void setup() {}

void loop()
<span aria-label="annotation6" class="CodeAnnotationHang">❻</span> {
    LED1(); delay(d); LED2(); delay(d); LED3(); delay(d);
    LED4(); delay(d); LED5(); delay(d); LED6(); delay(d);
}
</code></pre>

<p class="TX">The first few moments of operation may seem like magic if you’re accustomed to using one LED per digital output pin, but you can achieve these effects simply by carefully directing current through the appropriate pins and resistors.</p>
<p class="TX">Consider the first LED in the schematic, D<sub>1</sub>, controlled by the function <samp class="SANS_TheSansMonoCd_W5Regular_11">LED1()</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Trace the path through the schematic as follows: current needs to flow from pin D12 through R<sub>2</sub>, through the LED itself, then through R<sub>1</sub>, and into pin D13. You don’t want current to flow through D<sub>4</sub>, so you set pin D11 to an input, blocking current flow. Although D<sub>4</sub> and D<sub>5</sub> are in the current’s path, they will not activate, as the resistor and their forward operating voltage reduce the current’s voltage so greatly.</p>
<p class="TX">Instead of using lots of <samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp> functions, this sketch uses port manipulation (covered in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>) to control the digital pins. This greatly reduces the amount of required code, which also frees up more memory for the rest of your project.</p>
<p class="TX">To turn on D<sub>1</sub> in the code, the sketch turns on LED D<sub>1</sub> and sets pin D13 to HIGH and D12 to LOW using port manipulation. The sketch first activates PORTB pin types D13 to D8 <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, setting D13 to output, setting D12 to output, setting D11 to input, and leaving the unused pins at 0. It then activates the output pins <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, setting D13 to LOW, setting D12 to HIGH, and leaving input as 0. This turns on LED D<sub>1</sub>.</p>
<p class="TX">For another example in the project, consider LED D<sub>5</sub>. To turn it on, current must flow from pin D11 through R<sub>3</sub>, D<sub>4</sub>, and R<sub>1</sub>, and then into D13. The sketch sets pin D11 to HIGH, pin D13 to LOW, and pin D12 as an input <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> to stop current flowing in that direction.</p>
<p class="TX">The sketch sets the flow of current in this way for each LED in turn, within a function for each LED from <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> onward. Unlike using conventional <samp class="SANS_TheSansMonoCd_W5Regular_11">digitalWrite()</samp> functions where you need to first use <samp class="SANS_TheSansMonoCd_W5Regular_11">pinMode()</samp> functions to configure a pin as an output or input, nothing is required in <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, so the code then lights each LED in turn from <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>.</p>
<p class="TX">You can adjust the amount of time between each LED being switched on by changing the defined value of <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Although the sketch doesn’t use this option, you can also turn off all the LEDs at once at any point in the code with the following line of code:</p>

<pre><code>DDRB = B00000000; // Set all pins to inputs (high-Z)
</code></pre>

<p class="TX"><span aria-label=" Page 62. " epub:type="pagebreak" id="pg_62" role="doc-pagebreak"/>Keep this project’s hardware together to use in the following project. In the next section, I’ll show you a more systematic way of determining which pins to set as HIGH or LOW.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-37"/><samp class="SANS_Futura_Std_Bold_B_11">Larger Charlieplexing Displays</samp></h2>
<p class="TNI">When building larger Charlieplexing circuits, creating a logic table with the LEDs and their required pin types and outputs can help you plan how to write your code. This makes it easier to create the required <samp class="SANS_TheSansMonoCd_W5Regular_11">DDRB</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTB</samp> functions to control the LEDs. To do this, trace the current path you require for each LED and then determine the pin status for each LED. For example, <a href="chapter5.xhtml#tab5-1">Table 5-1</a> is the logic table for Project #15, where L stands for LOW, H for HIGH, and Z for input.</p>
<figure class="table">
<p class="TableTitle" id="tab5-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 5-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Logic Table for Project #15</samp></p>
<table class="table">
<thead>
<tr>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">LED#</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Pin D13</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Pin D12</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Pin D11</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
</tr>
<tr>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Creating such a table simplifies the process of determining the port manipulation commands, as you can just match each letter with its respective ones, zeros, and inputs. To make your own table, trace the current flow in the schematic required for each LED and then note the status required for each I/O pin. For example, to activate LED 4 in Project #15, current must flow out from pin D12 (so it’s HIGH) through R<sub>2</sub>, through LED D<sub>4</sub>, then through R<sub>3</sub>, and back to D11 (so it’s LOW). You don’t want current to flow in or out of D13, so it will be Z. You can then use this HIGH, LOW, and Z information to create the required <samp class="SANS_TheSansMonoCd_W5Regular_11">DDR</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTB</samp> functions in your code.</p>
<p class="TX">Once you have more than two I/O pins in use, you can connect a pair of LEDs to each of the other I/O lines. To determine how many LEDs you can control with any number of available I/O pins on your Arduino, use the formula <i>L</i> = <i>n</i><sup>2</sup> <span class="symbol">−</span> <i>n</i>, where <i>L</i> is the number of LEDs and <i>n</i> is the number of I/O pins. For example, if you have 4 pins, you can use 12 LEDs (4<sup>2</sup> <span class="symbol">−</span> 4 = 12).</p>
<p class="TX">Let’s try this in the next project.</p>
<p class="HeadProject"><span id="h1-38"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #16: Charlieplexing with 12 LEDs</samp></p>
<p class="TNI">In this project, you’ll practice using Charlieplexing to control an even larger LED display with only four digital output pins. You’ll need the following parts:</p>
<ul class="ul">
<li class="BL"><span aria-label=" Page 63. " epub:type="pagebreak" id="pg_63" role="doc-pagebreak"/>An Arduino Uno or compatible board and USB cable</li>
<li class="BL">Four 270 Ω, 0.25 W, 1 percent resistors</li>
<li class="BL">12 LEDs</li>
<li class="BL">Two solderless breadboards</li>
<li class="BL">Male-to-male jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter5.xhtml#fig5-4">Figure 5-4</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #16" class="img1" id="fig5-4" src="../images/fig5-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: The schematic for Project #16</samp></p></figcaption>
</figure>
<p class="TX">You can build this project by expanding on the hardware setup from Project #15, using two solderless breadboards side by side, as shown in <a href="chapter5.xhtml#fig5-5">Figure 5-5</a>.</p>
<figure class="IMG"><img alt="AN IMAGE OF THE ASSEMBLED PROJECT #15" class="img8" id="fig5-5" src="../images/fig5-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: The assembled Project #16</samp></p></figcaption>
</figure>
<p class="TX"><a href="chapter5.xhtml#tab5-2">Table 5-2</a> is Project #16’s logic table. You can compare this with the port manipulations in the subsequent sketch to increase your familiarity with controlling the LEDs. For practice, trace the current for various LEDs through the schematic and compare with the table.</p>
<figure class="table">
<p class="TableTitle" id="tab5-2"><span aria-label=" Page 64. " epub:type="pagebreak" id="pg_64" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 5-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Logic Table for Project #16</samp></p>
<table class="table">
<thead>
<tr>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">LED#</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Pin D13</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Pin D12</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Pin D11</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Pin D10</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">4</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">8</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">9</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">10</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">11</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
</tr>
<tr>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">12</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Enter and upload the Project #16 sketch to your Arduino. Once again, a moment or two after uploading the sketch, each LED should illuminate in turn.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-16"/>

<pre><code>// Project #16 - Charlieplexing with 12 LEDs

#define d 250 <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
void LED1()
{
    DDRB = B00110000; <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
    PORTB = B00010000;
}

void LED2() {DDRB = B00110000; PORTB = B00100000;}
void LED3() {DDRB = B00011000; PORTB = B00001000;}
void LED4() {DDRB = B00011000; PORTB = B00010000;}
void LED5() {DDRB = B00101000; PORTB = B00001000;}
void LED6() {DDRB = B00101000; PORTB = B00100000;}
void LED7() {DDRB = B00001100; PORTB = B00000100;}
void LED8() {DDRB = B00001100; PORTB = B00001000;}
void LED9() {DDRB = B00010100; PORTB = B00000100;}
void LED10(){DDRB = B00010100; PORTB = B00010000;}
void LED11(){DDRB = B00100100; PORTB = B00000100;}
void LED12(){DDRB = B00100100; PORTB = B00100000;}

void noLED() <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
{
    DDRB = B00000000; // All to inputs, high-impedance
}

<span aria-label=" Page 65. " epub:type="pagebreak" id="pg_65" role="doc-pagebreak"/>void setup() {}

void loop()
{
LED1(); delay(d); LED2(); delay(d); LED3(); delay(d); LED4(); delay(d);
LED5(); delay(d); LED6(); delay(d); LED7(); delay(d); LED8(); delay(d);
LED9(); delay(d); LED10(); delay(d); LED11(); delay(d); LED12(); delay(d); <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
}</code></pre>

<p class="TX">As with Project #15, each LED is activated by its own function from <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> onward. After <samp class="SANS_TheSansMonoCd_W5Regular_11">void LED1()</samp>, I’ve compressed each function into one line of code to save space. Again, port manipulation greatly improves the sketch’s efficiency.</p>
<p class="TX">You can change the delay between each LED’s turning on and off <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The sketch includes a function to turn off all the LEDs if required for other future projects <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Once again, to save space, I’ve placed multiple functions on one line <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, where each LED is turned on after a preset delay.</p>
<p class="TX">The placement of the LEDs in this project may seem random, but you now have the skills to create more useful, complicated displays with Charlieplexing, which you’ll do in Project #18. First, however, I’ll show you how to use Charlieplexing with an ATtiny85.</p>
<p class="HeadProject"><span id="h1-39"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #17: Charlieplexing with the ATtiny85</samp></p>
<p class="TNI">Using Charlieplexing with an ATtiny85 microcontroller gives you a cheaper and smaller-circuit solution for controlling lots of LEDs without external devices. This project demonstrates how to control 12 LEDs using the ATtiny85.</p>
<p class="TX">You’ll need the assembled LED circuit from Project #16, as well as either the ATtiny85 programming shield from <span class="Xref">Project #13 in <a href="chapter3.xhtml">Chapter 3</a></span> or the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">An ATtiny85 microcontroller</li>
<li class="BL">A 10 µF electrolytic capacitor</li>
<li class="BL">Two solderless breadboards</li>
<li class="BL">Male-to-male jumper wires</li>
</ul>
<p class="TX">First, assemble your ATtiny85 programming setup using the instructions from <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> (using <span class="Xref">Project #13</span> if you built it), using the programming shield or the parts listed for this project, and then upload the code. Next, connect your ATtiny85 to the LED circuit, as shown in <a href="chapter5.xhtml#fig5-6">Figure 5-6</a>. The LED circuit has different pin connections from those in Project #16 but is otherwise the same.<span aria-label=" Page 66. " epub:type="pagebreak" id="pg_66" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #17" class="img1" id="fig5-6" src="../images/fig5-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-6: The schematic for Project #17</samp></p></figcaption>
</figure>
<p class="TX">Next, upload the sketch:</p>
<span id="pro-17"/>

<pre><code>// Project 17 - Charlieplexing with ATtiny85

#define d 250
void LED1() {DDRB = B00001100; PORTB = B00000100;}
void LED2() {DDRB = B00001100; PORTB = B00001000;}
void LED3() {DDRB = B00000110; PORTB = B00000010;}
void LED4() {DDRB = B00000110; PORTB = B00000100;}
void LED5() {DDRB = B00001010; PORTB = B00000010;}
void LED6() {DDRB = B00001010; PORTB = B00001000;}
void LED7() {DDRB = B00000011; PORTB = B00000001;}
void LED8() {DDRB = B00000011; PORTB = B00000010;}
void LED9() {DDRB = B00000101; PORTB = B00000001;}
void LED10(){DDRB = B00000101; PORTB = B00000100;}
void LED11(){DDRB = B00001001; PORTB = B00000001;}
void LED12(){DDRB = B00001001; PORTB = B00001000;}

void noLED(){DDRB = B00000000;} // All to inputs, high-impedance

void setup() {}

void loop()
{
LED1(); delay(d); LED2(); delay(d); LED3(); delay(d); LED4(); delay(d);
LED5(); delay(d); LED6(); delay(d); LED7(); delay(d); LED8(); delay(d);
LED9(); delay(d); LED10(); delay(d); LED11(); delay(d); LED12(); delay(d);
}</code></pre>

<p class="TX"><span aria-label=" Page 67. " epub:type="pagebreak" id="pg_67" role="doc-pagebreak"/>Once uploaded, this sketch should operate in the same manner as Project #16, with each of 12 LEDs lighting up in turn. However, the code sets up the port manipulation differently. Since you’re using <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTB</samp> pins 3, 2, 1, and 0 (digital D3 to D0) on the ATtiny85, your <samp class="SANS_TheSansMonoCd_W5Regular_11">DDRB</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTB</samp> functions need to address bits 0 to 3.</p>
<p class="HeadProject"><span id="h1-40"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #18: Building a 30-LED Matrix Display</samp></p>
<p class="TNI">This project takes Charlieplexing to the next level with a larger, 30-LED circuit you can use to display digits or characters of your own design.</p>
<p class="TX">It’s theoretically possible but extremely difficult to build the circuit for this project on a pair of solderless breadboards, so I highly recommend downloading the PCB files for this project and having your own PCB manufactured. You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">Six 270 <span lang="el" xml:lang="el">Ω</span>, 0.25 W, 1 percent resistors</li>
<li class="BL">Thirty 5 mm LEDs</li>
<li class="BL">Two solderless breadboards or Project #18 PCB</li>
<li class="BL">1 <span class="symbol">×</span> 40 2.54 mm inline header pins (if using PCB)</li>
<li class="BL">Various jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter5.xhtml#fig5-7">Figure 5-7</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #18" class="img1" id="fig5-7" src="../images/fig5-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-7: The schematic for Project #18</samp></p></figcaption>
</figure>
<p class="TX">If you ordered the PCB, assembly is simple. You can see from the layout on the board that all the LEDs have the anode pin pointing toward the top and the cathodes (the flat side) toward the bottom, as shown in <a href="chapter5.xhtml#fig5-8">Figure 5-8</a>.<span aria-label=" Page 68. " epub:type="pagebreak" id="pg_68" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="AN UNPOPULATED PCB FOR PROJECT #18" class="img6" id="fig5-8" src="../images/fig5-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-8: The PCB for Project #18</samp></p></figcaption>
</figure>
<p class="TX">Start with the resistors first, then the LEDs, followed by the inline header pins. Place the pins so they emerge from the rear, and then prop the PCB up with jumper wires to the Arduino, or just place the PCB directly into the Arduino itself, as shown in <a href="chapter5.xhtml#fig5-9">Figure 5-9</a>. The pins on the PCB are labeled with matching Arduino pin numbers on the rear of the PCB.</p>
<figure class="IMG"><img alt="A PHOTO OF THE PROJECT #18 PCB COMPLETED AND INSERTED INTO THE ARDUINO UNO" class="img1" id="fig5-9" src="../images/fig5-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-9: The completed Project #18 circuit</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 69. " epub:type="pagebreak" id="pg_69" role="doc-pagebreak"/><a href="chapter5.xhtml#tab5-3">Table 5-3</a> is the logic table for Project #18, which you can compare with the port manipulations in the sketches for <a href="#LiT-5-2">Listing 5-2</a> and that for Project #18 listed shortly afterward or the schematic in <a href="chapter5.xhtml#fig5-7">Figure 5-7</a>. Again, for practice, trace the current for various LEDs through the schematic and compare with the table to increase your familiarity with controlling the LEDs.</p>
<figure class="table"><img alt="" class="img1" id="tab5-3" src="../images/table5-3.png"/></figure>
<p class="TX">Before moving on, please make sure your LEDs are working correctly by entering and uploading the sketch from <a href="#LiT-5-2">Listing 5-2</a>, which should make each LED turn on and off in succession.</p>
<span id="LiT-5-2"/>

<pre><code>#define d 250 <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
void LED1() {DDRB = B00110000; PORTB = B00010000;} <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
void LED2() {DDRB = B00011000; PORTB = B00001000;}
void LED3() {DDRB = B00001100; PORTB = B00000100;}
void LED4() {DDRB = B00000110; PORTB = B00000010;}
void LED5() {DDRB = B00000011; PORTB = B00000001;}
void LED6() {DDRB = B00110000; PORTB = B00100000;}
void LED7() {DDRB = B00011000; PORTB = B00010000;}
void LED8() {DDRB = B00001100; PORTB = B00001000;}
void LED9() {DDRB = B00000110; PORTB = B00000100;}
void LED10(){DDRB = B00000011; PORTB = B00000010;}
void LED11(){DDRB = B00101000; PORTB = B00001000;}
void LED12(){DDRB = B00101000; PORTB = B00100000;}
void LED13(){DDRB = B00100100; PORTB = B00000100;}
void LED14(){DDRB = B00100100; PORTB = B00100000;}
void LED15(){DDRB = B00100010; PORTB = B00000010;}
void LED16(){DDRB = B00100010; PORTB = B00100000;}
void LED17(){DDRB = B00100001; PORTB = B00000001;}
void LED18(){DDRB = B00100001; PORTB = B00100000;}
void LED19(){DDRB = B00010100; PORTB = B00000100;}
void LED20(){DDRB = B00010100; PORTB = B00010000;}
void LED21(){DDRB = B00010010; PORTB = B00000010;}
void LED22(){DDRB = B00010010; PORTB = B00010000;}
void LED23(){DDRB = B00010001; PORTB = B00000001;}
void LED24(){DDRB = B00010001; PORTB = B00010000;}
void LED25(){DDRB = B00000101; PORTB = B00000001;}
void LED26(){DDRB = B00000101; PORTB = B00000100;}
void LED27(){DDRB = B00001010; PORTB = B00000010;}
void LED28(){DDRB = B00001010; PORTB = B00001000;}
void LED29(){DDRB = B00001001; PORTB = B00000001;}
void LED30(){DDRB = B00001001; PORTB = B00001000;}

<span aria-label=" Page 70. " epub:type="pagebreak" id="pg_70" role="doc-pagebreak"/>void noLED(){DDRB = B00000000;} // All LEDs to input, high impedance <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>

void setup() {}

void loop()
{
LED1(); delay(d); LED2(); delay(d); LED3(); delay(d); LED4(); delay(d);
LED5(); delay(d); LED6(); delay(d); LED7(); delay(d); LED8(); delay(d);
LED9(); delay(d); LED10(); delay(d); LED11(); delay(d); LED12(); delay(d);
LED13(); delay(d); LED14(); delay(d); LED15(); delay(d); LED16(); delay(d);
LED17(); delay(d); LED18(); delay(d); LED19(); delay(d); LED20(); delay(d);
LED21(); delay(d); LED22(); delay(d); LED23(); delay(d); LED24(); delay(d);
LED25(); delay(d); LED26(); delay(d); LED27(); delay(d); LED28(); delay(d);
LED29(); delay(d); LED30(); delay(d);
}</code></pre>

<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: Testing the 30-LED matrix display</samp></p>
<p class="TX">The sketch sets the delay between each LED lighting up and turning off by defining <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. From <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> onward, functions set the GPIO pin port to control each required pin to activate the LEDs in turn. The function <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> turns all the LEDs off. After that, the main loop endlessly activates each LED in turn. I’ve minimized the code spacing for display efficiency.</p>
<p class="TX">Now that you’ve tested the LEDs, you’re ready to enter and upload the project sketch itself. (Rather than typing the code yourself, I recommend you download it from the book’s web page, <a href="https://nostarch.com/arduino-arduinians"><i>https://<wbr/>nostarch<wbr/>.com<wbr/>/arduino<wbr/>-arduinians</i></a>, if you haven’t already done so.) The digits 0 through 9 should appear on the LED display in succession and then start again at 0.</p>
<span id="pro-18"/>

<pre><code>// Project #18 - Using the 30-LED matrix display

int pixels[10][30] = <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
{ {0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},
  {0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
  {0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0},
  {1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0},
  {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0},
  {1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0},
  {0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0},
  {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0},
  {1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0},
  {1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0}};

void displayDigits(int i, int duration) <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
{
    for (int a = 0; a &lt; duration; a++)
    {
        for (int b = 0; b &lt; 30; b++)
        {
            if (pixels[i][b] == 1)
            {
                turnOnLED(b + 1); <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
                delay(1); // Adjust as required <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
<span aria-label=" Page 71. " epub:type="pagebreak" id="pg_71" role="doc-pagebreak"/>            }
        }
    }
    noLED();
}

void LED1() {DDRB = B00110000; PORTB = B00010000;} <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
void LED2() {DDRB = B00011000; PORTB = B00001000;}
void LED3() {DDRB = B00001100; PORTB = B00000100;}
void LED4() {DDRB = B00000110; PORTB = B00000010;}
void LED5() {DDRB = B00000011; PORTB = B00000001;}
void LED6() {DDRB = B00110000; PORTB = B00100000;}
void LED7() {DDRB = B00011000; PORTB = B00010000;}
void LED8() {DDRB = B00001100; PORTB = B00001000;}
void LED9() {DDRB = B00000110; PORTB = B00000100;}
void LED10(){DDRB = B00000011; PORTB = B00000010;}
void LED11(){DDRB = B00101000; PORTB = B00001000;}
void LED12(){DDRB = B00101000; PORTB = B00100000;}
void LED13(){DDRB = B00100100; PORTB = B00000100;}
void LED14(){DDRB = B00100100; PORTB = B00100000;}
void LED15(){DDRB = B00100010; PORTB = B00000010;}
void LED16(){DDRB = B00100010; PORTB = B00100000;}
void LED17(){DDRB = B00100001; PORTB = B00000001;}
void LED18(){DDRB = B00100001; PORTB = B00100000;}
void LED19(){DDRB = B00010100; PORTB = B00000100;}
void LED20(){DDRB = B00010100; PORTB = B00010000;}
void LED21(){DDRB = B00010010; PORTB = B00000010;}
void LED22(){DDRB = B00010010; PORTB = B00010000;}
void LED23(){DDRB = B00010001; PORTB = B00000001;}
void LED24(){DDRB = B00010001; PORTB = B00010000;}
void LED25(){DDRB = B00000101; PORTB = B00000001;}
void LED26(){DDRB = B00000101; PORTB = B00000100;}
void LED27(){DDRB = B00001010; PORTB = B00000010;}
void LED28(){DDRB = B00001010; PORTB = B00001000;}
void LED29(){DDRB = B00001001; PORTB = B00000001;}
void LED30(){DDRB = B00001001; PORTB = B00001000;}

void noLED(){DDRB = B00000000;} // all LEDs to input, high impedance

void turnOnLED(int l)
{
    switch (l)
    {<span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
        case 1 : LED1(); break;
        case 2 : LED2(); break;
        case 3 : LED3(); break;
        case 4 : LED4(); break;
        case 5 : LED5(); break;
        case 6 : LED6(); break;
        case 7 : LED7(); break;
        case 8 : LED8(); break;
        case 9 : LED9(); break;
        case 10 : LED10(); break;
        case 11 : LED11(); break;
<span aria-label=" Page 72. " epub:type="pagebreak" id="pg_72" role="doc-pagebreak"/>        case 12 : LED12(); break;
        case 13 : LED13(); break;
        case 14 : LED14(); break;
        case 15 : LED15(); break;
        case 16 : LED16(); break;
        case 17 : LED17(); break;
        case 18 : LED18(); break;
        case 19 : LED19(); break;
        case 20 : LED20(); break;
        case 21 : LED21(); break;
        case 22 : LED22(); break;
        case 23 : LED23(); break;
        case 24 : LED24(); break;
        case 25 : LED25(); break;
        case 26 : LED26(); break;
        case 27 : LED27(); break;
        case 28 : LED28(); break;
        case 29 : LED29(); break;
        case 30 : LED30(); break;
    }
}

void setup(){}

void loop()
{
    for (int q = 0; q &lt; 10; q++) <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>
    {
        displayDigits(q, 50); <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>
        delay(250);
    }
}</code></pre>

<p class="TX">The two-dimensional array <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> contains 10 arrays, one for each digit from 0 through 9. Each digit array has 30 elements, to match the 30 LEDs on the display board. The display board’s LEDs are arranged from 1 at the top left to 30 at the bottom right. In the arrays, each <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> represents the LEDs that need to turn on in quick succession for each number to be displayed.</p>
<p class="TX">The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">displayDigits()</samp> function <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> accepts the digit you want to display and the number of times the function will display the LEDs required in turn to show the digit. The greater the number in the second parameter, the longer the digit will appear on the display. The <samp class="SANS_TheSansMonoCd_W5Regular_11">displayDigits()</samp> function uses another custom function, <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOnLED()</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, to turn on the required LED. The <samp class="SANS_TheSansMonoCd_W5Regular_11">turnOnLED()</samp> function, in turn, uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> to call the appropriate function from the list <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> and turn on each individual LED.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">delay()</samp> function <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> within <samp class="SANS_TheSansMonoCd_W5Regular_11">displayDigits()</samp> is set to keep each LED on for 1 millisecond before the next is illuminated. Because the LEDs flip on and off so quickly, the human eye perceives all the LEDs required for a given digit as on at the same time, as shown in <a href="chapter5.xhtml#fig5-10">Figure 5-10</a>. You can alter the length of the delay to tailor the display to your own preferences.</p>
<p class="TX"><span aria-label=" Page 73. " epub:type="pagebreak" id="pg_73" role="doc-pagebreak"/>Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, the digits 0 through 9 are displayed in order <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>, with a short delay in between. Each digit is displayed using 50 refreshes of the digit <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>.</p>
<figure class="IMG"><img alt="EXAMPLE DISPLAYS WITH PROJECT #18, SHOWING THE NUMERALS 0, 4, AND 7" class="img8" id="fig5-10" src="../images/fig5-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-10: Examples of Project #18</samp></p></figcaption>
</figure>
<p class="TX">This sketch displays digits using the Monomin font, as shown in <a href="chapter5.xhtml#fig5-11">Figure 5-11</a>.</p>
<figure class="IMG"><img alt="A DEMONSTRATION OF MONOMIN 6X5 PIXEL FONT DIGITS, 0 THROUGH 9" class="img6" id="fig5-11" src="../images/fig5-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-11: The Monomin 6×5 font digits</samp></p></figcaption>
</figure>
<p class="TX">You can find more information about this font by visiting <a href="https://fontstruct.com"><i>https://<wbr/>fontstruct<wbr/>.com</i></a> and searching for the Monomin 6 <span class="symbol">×</span> 5 font.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-41"/><samp class="SANS_Futura_Std_Bold_B_11">Making Custom Character Displays</samp></h2>
<p class="TNI">It’s possible to create display types beyond just the numbers shown in Project #18. To make your own characters, first draw how you would like them to appear using some grid paper or a spreadsheet. For example, to create a boundary rectangle, draw the diagram shown in <a href="chapter5.xhtml#fig5-12">Figure 5-12</a>.</p>
<figure class="IMG"><img alt="SPREADSHEET CELLS SHOWING A 5X6 RECTANGLE OF X’S" class="img5" id="fig5-12" src="../images/fig5-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-12: Planning the character to display</samp></p></figcaption>
</figure>
<p class="TX">The top-left X represents LED 1, and the bottom-right X represents LED 30. You then create your own array that represents the status of each LED. For this example, the array would look like this:</p>

<pre><code>{1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1}</code></pre>

<p class="TX"><span aria-label=" Page 74. " epub:type="pagebreak" id="pg_74" role="doc-pagebreak"/>You can then add or swap this array into the sketch in the same way as for the other digits in Project #18 and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">displayDigits()</samp> function to show your custom character on the display, as demonstrated in <a href="chapter5.xhtml#fig5-13">Figure 5-13</a>.</p>
<figure class="IMG"><img alt="THE CUSTOM CHARACTER SHOWN ON THE DISPLAY BOARD" class="img6" id="fig5-13" src="../images/fig5-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-13: The custom character</samp></p></figcaption>
</figure>
<p class="TX">When designing your own custom characters, it can help to use a spreadsheet or graph paper to plan the layout of the LEDs you’d like to turn on and off.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-42"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">With Charlieplexing in your toolbox, you can now control multiple LEDs with minimal I/O pins and without using external ICs. You learned how to control 2, 6, 12, or 30 LEDs with a minimum of digital output pins, as well as how to use Charlieplexing with the compact ATtiny microcontrollers.</p>
<p class="TX">In the next chapter, you’ll learn to give your Arduino the power to turn itself off.</p>
</section>
</section>
</body>
</html>